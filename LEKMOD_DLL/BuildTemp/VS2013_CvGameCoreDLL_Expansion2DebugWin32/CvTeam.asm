; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvTeam.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
PUBLIC	?m_aTeams@CvTeam@@1PAV1@A			; CvTeam::m_aTeams
_BSS	SEGMENT
?m_aTeams@CvTeam@@1PAV1@A DD 01H DUP (?)		; CvTeam::m_aTeams
_BSS	ENDS
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	??0CvTeam@@QAE@XZ				; CvTeam::CvTeam
PUBLIC	??1CvTeam@@QAE@XZ				; CvTeam::~CvTeam
PUBLIC	?initStatics@CvTeam@@SAXXZ			; CvTeam::initStatics
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	SEGMENT
__unwindtable$?initStatics@CvTeam@@SAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?initStatics@CvTeam@@SAXXZ$0
__ehfuncinfo$?initStatics@CvTeam@@SAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?initStatics@CvTeam@@SAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?initStatics@CvTeam@@SAXXZ
_TEXT	SEGMENT
tv76 = -28						; size = 4
$T229850 = -24						; size = 4
$T229849 = -20						; size = 4
_i$222285 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?initStatics@CvTeam@@SAXXZ PROC				; CvTeam::initStatics, COMDAT

; 42   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?initStatics@CvTeam@@SAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 43   : 	m_aTeams = FNEW(CvTeam[REALLY_MAX_TEAMS], c_eCiv5GameplayDLL, 0);

	push	238724					; 0003a484H
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T229850[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T229850[ebp], 0
	je	SHORT $LN6@initStatic
	mov	eax, DWORD PTR $T229850[ebp]
	mov	DWORD PTR [eax], 80			; 00000050H
	push	OFFSET ??1CvTeam@@QAE@XZ		; CvTeam::~CvTeam
	push	OFFSET ??0CvTeam@@QAE@XZ		; CvTeam::CvTeam
	push	80					; 00000050H
	push	2984					; 00000ba8H
	mov	ecx, DWORD PTR $T229850[ebp]
	add	ecx, 4
	push	ecx
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	mov	edx, DWORD PTR $T229850[ebp]
	add	edx, 4
	mov	DWORD PTR tv76[ebp], edx
	jmp	SHORT $LN7@initStatic
$LN6@initStatic:
	mov	DWORD PTR tv76[ebp], 0
$LN7@initStatic:
	mov	eax, DWORD PTR tv76[ebp]
	mov	DWORD PTR $T229849[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T229849[ebp]
	mov	DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A, ecx ; CvTeam::m_aTeams

; 44   : 
; 45   : 	for(int i = 0; i < REALLY_MAX_TEAMS; ++i)

	mov	DWORD PTR _i$222285[ebp], 0
	jmp	SHORT $LN3@initStatic
$LN2@initStatic:
	mov	edx, DWORD PTR _i$222285[ebp]
	add	edx, 1
	mov	DWORD PTR _i$222285[ebp], edx
$LN3@initStatic:
	cmp	DWORD PTR _i$222285[ebp], 80		; 00000050H
	jge	SHORT $LN4@initStatic

; 46   : 	{
; 47   : 		m_aTeams[i].m_eID = (TeamTypes)i;

	mov	eax, DWORD PTR _i$222285[ebp]
	imul	eax, 2984				; 00000ba8H
	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	edx, DWORD PTR _i$222285[ebp]
	mov	DWORD PTR [ecx+eax+4], edx
	jmp	SHORT $LN2@initStatic
$LN4@initStatic:

; 48   : 	}
; 49   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?initStatics@CvTeam@@SAXXZ$0:
	mov	eax, DWORD PTR $T229850[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__ehhandler$?initStatics@CvTeam@@SAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?initStatics@CvTeam@@SAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?initStatics@CvTeam@@SAXXZ ENDP				; CvTeam::initStatics
PUBLIC	??_ECvTeam@@QAEPAXI@Z				; CvTeam::`vector deleting destructor'
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
; Function compile flags: /Odtp
;	COMDAT ??_ECvTeam@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_ECvTeam@@QAEPAXI@Z PROC				; CvTeam::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector
	push	OFFSET ??1CvTeam@@QAE@XZ		; CvTeam::~CvTeam
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	2984					; 00000ba8H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector
$LN3@vector:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvTeam@@QAE@XZ			; CvTeam::~CvTeam
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector:
	mov	esp, ebp
	pop	ebp
	ret	4
??_ECvTeam@@QAEPAXI@Z ENDP				; CvTeam::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?freeStatics@CvTeam@@SAXXZ			; CvTeam::freeStatics
; Function compile flags: /Odtp
;	COMDAT ?freeStatics@CvTeam@@SAXXZ
_TEXT	SEGMENT
tv68 = -12						; size = 4
$T229870 = -8						; size = 4
$T229869 = -4						; size = 4
?freeStatics@CvTeam@@SAXXZ PROC				; CvTeam::freeStatics, COMDAT

; 53   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 54   : 	delete[] m_aTeams;

	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T229870[ebp], eax
	mov	ecx, DWORD PTR $T229870[ebp]
	mov	DWORD PTR $T229869[ebp], ecx
	cmp	DWORD PTR $T229869[ebp], 0
	je	SHORT $LN3@freeStatic
	push	3
	mov	ecx, DWORD PTR $T229869[ebp]
	call	??_ECvTeam@@QAEPAXI@Z
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $LN4@freeStatic
$LN3@freeStatic:
	mov	DWORD PTR tv68[ebp], 0
$LN4@freeStatic:

; 55   : 	m_aTeams = NULL;

	mov	DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A, 0	; CvTeam::m_aTeams

; 56   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?freeStatics@CvTeam@@SAXXZ ENDP				; CvTeam::freeStatics
_TEXT	ENDS
PUBLIC	??1?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::~vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >
PUBLIC	??1?$_Vector_val@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ ; std::_Vector_val<enum ResourceTypes,std::allocator<enum ResourceTypes> >::~_Vector_val<enum ResourceTypes,std::allocator<enum ResourceTypes> >
PUBLIC	??1?$FAllocArrayType@HU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ; FAllocArrayType<int,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > > >
PUBLIC	?reset@CvTeam@@QAEXW4TeamTypes@@_N@Z		; CvTeam::reset
PUBLIC	?_Buy@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAE_NI@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Buy
PUBLIC	??0?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@QAE@XZ ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > >::FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > >
PUBLIC	??_7CvTeam@@6B@					; CvTeam::`vftable'
PUBLIC	?Read@CvTeam@@UAEXAAVFDataStream@@@Z		; CvTeam::Read
PUBLIC	?Write@CvTeam@@UBEXAAVFDataStream@@@Z		; CvTeam::Write
EXTRN	??0CvTeamTechs@@QAE@XZ:PROC			; CvTeamTechs::CvTeamTechs
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__CxxThrowException@8:PROC
;	COMDAT ??_7CvTeam@@6B@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
CONST	SEGMENT
??_7CvTeam@@6B@ DD FLAT:?Read@CvTeam@@UAEXAAVFDataStream@@@Z ; CvTeam::`vftable'
	DD	FLAT:?Write@CvTeam@@UBEXAAVFDataStream@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CvTeam@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvTeam@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvTeam@@QAE@XZ$13
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvTeam@@QAE@XZ$1
	DD	02H
	DD	FLAT:__unwindfunclet$??0CvTeam@@QAE@XZ$2
__ehfuncinfo$??0CvTeam@@QAE@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0CvTeam@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ??0CvTeam@@QAE@XZ
_TEXT	SEGMENT
tv129 = -152						; size = 4
tv274 = -148						; size = 4
tv299 = -144						; size = 4
_this$ = -140						; size = 4
$T230094 = -136						; size = 4
$T230044 = -42						; size = 1
$T230031 = -41						; size = 1
$T230027 = -40						; size = 4
$T230020 = -32						; size = 4
$T230013 = -24						; size = 4
$T229877 = -20						; size = 4
$T229876 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvTeam@@QAE@XZ PROC					; CvTeam::CvTeam, COMDAT
; _this$ = ecx

; 61   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvTeam@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 140				; 0000008cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvTeam@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2888				; 00000b48H
	mov	DWORD PTR $T230013[ebp], ecx
	mov	ecx, DWORD PTR $T230013[ebp]
	call	??0?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2964				; 00000b94H
	mov	DWORD PTR $T230094[ebp], edx
	lea	eax, DWORD PTR $T230044[ebp]
	mov	DWORD PTR $T230020[ebp], eax
	lea	ecx, DWORD PTR $T230031[ebp]
	mov	DWORD PTR $T230027[ebp], ecx
	mov	edx, DWORD PTR $T230094[ebp]
	mov	DWORD PTR tv299[ebp], edx
	mov	eax, DWORD PTR $T230094[ebp]
	mov	DWORD PTR tv274[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	push	0
	mov	ecx, DWORD PTR $T230094[ebp]
	call	?_Buy@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAE_NI@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Buy
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 62   : 	m_abCanLaunch = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2896], 0

; 63   : 	m_abVictoryAchieved = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2900], 0

; 64   : 	m_abSmallAwardAchieved = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2904], 0

; 65   : 
; 66   : 	m_paiRouteChange = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2908], 0

; 67   : 	m_paiBuildTimeChange = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2912], 0

; 68   : 	m_paiProjectCount = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2916], 0

; 69   : 	m_paiProjectDefaultArtTypes = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2920], 0

; 70   : 	m_pavProjectArtTypes = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2960], 0

; 71   : 	m_paiProjectMaking = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2924], 0

; 72   : 	m_paiUnitClassCount = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2928], 0

; 73   : 	m_paiBuildingClassCount = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2932], 0

; 74   : 	m_paiObsoleteBuildingCount = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2936], 0

; 75   : 	m_paiTerrainTradeCount = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2940], 0

; 76   : 	m_aiVictoryCountdown = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2944], 0

; 77   : 	m_aiForceTeamVoteEligibilityCount = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2892], 0

; 78   : 
; 79   : 	m_pTeamTechs = FNEW(CvTeamTechs, c_eCiv5GameplayDLL, 0);

	push	28					; 0000001cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T229877[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	cmp	DWORD PTR $T229877[ebp], 0
	je	SHORT $LN3@CvTeam
	mov	ecx, DWORD PTR $T229877[ebp]
	call	??0CvTeamTechs@@QAE@XZ			; CvTeamTechs::CvTeamTechs
	mov	DWORD PTR tv129[ebp], eax
	jmp	SHORT $LN4@CvTeam
$LN3@CvTeam:
	mov	DWORD PTR tv129[ebp], 0
$LN4@CvTeam:
	mov	ecx, DWORD PTR tv129[ebp]
	mov	DWORD PTR $T229876[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T229876[ebp]
	mov	DWORD PTR [edx+2980], eax

; 80   : 
; 81   : 	m_ppaaiImprovementYieldChange = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2948], 0

; 82   : 	m_ppaaiImprovementNoFreshWaterYieldChange = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2952], 0

; 83   : 	m_ppaaiImprovementFreshWaterYieldChange = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2956], 0

; 84   : 
; 85   : 	reset((TeamTypes)0, true);

	push	1
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?reset@CvTeam@@QAEXW4TeamTypes@@_N@Z	; CvTeam::reset

; 86   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvTeam@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2888				; 00000b48H
	jmp	??1?$FAllocArrayType@HU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ
__unwindfunclet$??0CvTeam@@QAE@XZ$13:
	mov	ecx, DWORD PTR $T230094[ebp]
	jmp	??1?$_Vector_val@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ
__unwindfunclet$??0CvTeam@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2964				; 00000b94H
	jmp	??1?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::~vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >
__unwindfunclet$??0CvTeam@@QAE@XZ$2:
	mov	eax, DWORD PTR $T229877[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$??0CvTeam@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-144]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvTeam@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvTeam@@QAE@XZ ENDP					; CvTeam::CvTeam
; Function compile flags: /Odtp
;	COMDAT ??1?$FAllocArrayType@HU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$FAllocArrayType@HU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ PROC ; FAllocArrayType<int,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$FAllocArrayType@HU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ENDP ; FAllocArrayType<int,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@QAE@XZ PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > >::FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@QAE@XZ ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > >::FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > >
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXXZ ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Tidy
PUBLIC	?uninit@CvTeam@@QAEXXZ				; CvTeam::uninit
EXTRN	??1CvTeamTechs@@QAE@XZ:PROC			; CvTeamTechs::~CvTeamTechs
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fbatchallocate.h
xdata$x	SEGMENT
__unwindtable$??1CvTeam@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvTeam@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvTeam@@QAE@XZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvTeam@@QAE@XZ$2
__ehfuncinfo$??1CvTeam@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1CvTeam@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ??1CvTeam@@QAE@XZ
_TEXT	SEGMENT
tv74 = -68						; size = 4
_this$ = -64						; size = 4
$T230990 = -60						; size = 4
$T230612 = -56						; size = 4
$T230518 = -20						; size = 4
$T230517 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvTeam@@QAE@XZ PROC					; CvTeam::~CvTeam, COMDAT
; _this$ = ecx

; 91   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvTeam@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvTeam@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 92   : 	uninit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?uninit@CvTeam@@QAEXXZ			; CvTeam::uninit

; 93   : 
; 94   : 	delete m_pTeamTechs;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2980]
	mov	DWORD PTR $T230518[ebp], edx
	mov	eax, DWORD PTR $T230518[ebp]
	mov	DWORD PTR $T230517[ebp], eax
	cmp	DWORD PTR $T230517[ebp], 0
	je	SHORT $LN3@CvTeam@2
	mov	ecx, DWORD PTR $T230517[ebp]
	call	??1CvTeamTechs@@QAE@XZ			; CvTeamTechs::~CvTeamTechs
	mov	ecx, 1
	and	ecx, 1
	je	SHORT $LN8@CvTeam@2
	mov	edx, DWORD PTR $T230517[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@CvTeam@2:
	mov	eax, DWORD PTR $T230517[ebp]
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $LN1@CvTeam@2
$LN3@CvTeam@2:
	mov	DWORD PTR tv74[ebp], 0
$LN1@CvTeam@2:

; 95   : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2964				; 00000b94H
	mov	DWORD PTR $T230612[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR $T230612[ebp]
	call	?_Tidy@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXXZ ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2888				; 00000b48H
	mov	DWORD PTR $T230990[ebp], edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvTeam@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2888				; 00000b48H
	jmp	??1?$FAllocArrayType@HU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ
__unwindfunclet$??1CvTeam@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2964				; 00000b94H
	jmp	??1?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::~vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >
__unwindfunclet$??1CvTeam@@QAE@XZ$2:
	mov	ecx, DWORD PTR $T230612[ebp]
	jmp	??1?$_Vector_val@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ
__ehhandler$??1CvTeam@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-60]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvTeam@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvTeam@@QAE@XZ ENDP					; CvTeam::~CvTeam
PUBLIC	?init@CvTeam@@QAEXW4TeamTypes@@@Z		; CvTeam::init
; Function compile flags: /Odtp
;	COMDAT ?init@CvTeam@@QAEXW4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eID$ = 8						; size = 4
?init@CvTeam@@QAEXW4TeamTypes@@@Z PROC			; CvTeam::init, COMDAT
; _this$ = ecx

; 100  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 101  : 	//--------------------------------
; 102  : 	// Init saved data
; 103  : 	reset(eID);

	push	0
	mov	eax, DWORD PTR _eID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?reset@CvTeam@@QAEXW4TeamTypes@@_N@Z	; CvTeam::reset

; 104  : 
; 105  : 	//--------------------------------
; 106  : 	// Init non-saved data
; 107  : 
; 108  : 	//--------------------------------
; 109  : 	// Init other game data
; 110  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?init@CvTeam@@QAEXW4TeamTypes@@@Z ENDP			; CvTeam::init
_TEXT	ENDS
EXTRN	?Uninit@CvTeamTechs@@QAEXXZ:PROC		; CvTeamTechs::Uninit
; Function compile flags: /Odtp
;	COMDAT ?uninit@CvTeam@@QAEXXZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T231272 = -20						; size = 4
$T231270 = -16						; size = 4
_i$222402 = -12						; size = 4
_i$222398 = -8						; size = 4
_i$222394 = -4						; size = 4
?uninit@CvTeam@@QAEXXZ PROC				; CvTeam::uninit, COMDAT
; _this$ = ecx

; 115  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 116  : 
; 117  : 	//Free the batch-allocated memory
; 118  : 	m_BatchData.Free();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2888				; 00000b48H
	mov	DWORD PTR $T231272[ebp], eax
	mov	ecx, DWORD PTR $T231272[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T231270[ebp], edx
	mov	eax, DWORD PTR $T231270[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T231272[ebp]
	mov	DWORD PTR [ecx], 0

; 119  : 
; 120  : 	//Set the ptrs to null
; 121  : 	m_abCanLaunch = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2896], 0

; 122  : 	m_abVictoryAchieved = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2900], 0

; 123  : 	m_abSmallAwardAchieved = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2904], 0

; 124  : 
; 125  : 	m_paiRouteChange = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2908], 0

; 126  : 	m_paiBuildTimeChange = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2912], 0

; 127  : 	m_paiProjectCount = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2916], 0

; 128  : 	m_paiProjectDefaultArtTypes = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2920], 0

; 129  : 	m_pavProjectArtTypes = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2960], 0

; 130  : 	m_paiProjectMaking = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2924], 0

; 131  : 	m_paiUnitClassCount = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2928], 0

; 132  : 	m_paiBuildingClassCount = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2932], 0

; 133  : 	m_paiObsoleteBuildingCount = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2936], 0

; 134  : 	m_paiTerrainTradeCount = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2940], 0

; 135  : 	m_aiVictoryCountdown = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2944], 0

; 136  : 	m_aiForceTeamVoteEligibilityCount = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2892], 0

; 137  : 
; 138  : 	m_ppaaiImprovementYieldChange = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2948], 0

; 139  : 	m_ppaaiImprovementNoFreshWaterYieldChange = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2952], 0

; 140  : 	m_ppaaiImprovementFreshWaterYieldChange = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2956], 0

; 141  : 
; 142  : 	m_pTeamTechs->Uninit();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+2980]
	call	?Uninit@CvTeamTechs@@QAEXXZ		; CvTeamTechs::Uninit

; 143  : 
; 144  : 	m_iNumMembers = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 145  : 	m_iAliveCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 146  : 	m_iEverAliveCount = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0

; 147  : 	m_iNumCities = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 148  : 	m_iTotalPopulation = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 0

; 149  : 	m_iTotalLand = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], 0

; 150  : 	m_iNukeInterception = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32], 0

; 151  : 	m_iExtraWaterSeeFromCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+36], 0

; 152  : 	m_iMapTradingCount = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+40], 0

; 153  : 	m_iTechTradingCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+44], 0

; 154  : 	m_iGoldTradingCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+48], 0

; 155  : 	m_iAllowEmbassyTradingAllowedCount = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+52], 0

; 156  : 	m_iOpenBordersTradingAllowedCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 0

; 157  : 	m_iDefensivePactTradingAllowedCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+60], 0

; 158  : 	m_iResearchAgreementTradingAllowedCount = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+64], 0

; 159  : 	m_iTradeAgreementTradingAllowedCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+68], 0

; 160  : 	m_iPermanentAllianceTradingCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+72], 0

; 161  : 	m_iBridgeBuildingCount = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+76], 0

; 162  : 	m_iWaterWorkCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+80], 0

; 163  : 	m_iRiverTradeCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+84], 0

; 164  : 	m_iBorderObstacleCount = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+88], 0

; 165  : 	m_iVictoryPoints = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+92], 0

; 166  : 	m_iEmbarkedExtraMoves = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+96], 0

; 167  : 	//EAP: Extra embarked visibility on tech
; 168  : 	m_iEmbarkedExtraSight = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+100], 0

; 169  : 	m_iCanEmbarkCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+104], 0

; 170  : 	m_iDefensiveEmbarkCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+108], 0

; 171  : 	m_iEmbarkedAllWaterPassageCount = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+112], 0

; 172  : 	m_iNumNaturalWondersDiscovered = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+116], 0

; 173  : 	m_iBestPossibleRoute = NO_ROUTE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+120], -1

; 174  : 	m_iNumMinorCivsAttacked = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+124], 0

; 175  : #ifdef AUI_ASTAR_TWEAKED_OPTIMIZED_BUT_CAN_STILL_USE_ROADS
; 176  : 	m_iBestRouteFlatCostMultiplier = 0;
; 177  : 	m_iBestRouteNormalCostMultiplier = 1;
; 178  : 	m_iUseFlatCostIfBelowThis = -1;
; 179  : #endif
; 180  : 
; 181  : 	m_bMapCentering = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+128], 0

; 182  : 	m_bHasBrokenPeaceTreaty = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+129], 0

; 183  : 	m_bHomeOfUnitedNations = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+130], 0

; 184  : 	m_bHasTechForWorldCongress = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+131], 0

; 185  : 
; 186  : 	m_bBrokenMilitaryPromise = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+132], 0

; 187  : 	m_bBrokenExpansionPromise = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+133], 0

; 188  : 	m_bBrokenBorderPromise = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+134], 0

; 189  : 	m_bBrokenCityStatePromise = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+135], 0

; 190  : 
; 191  : 	m_eCurrentEra = ((EraTypes) 0);

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+136], 0

; 192  : 
; 193  : 	m_eLiberatedByTeam = NO_TEAM;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+140], -1

; 194  : 	m_eKilledByTeam = NO_TEAM;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+144], -1

; 195  : 
; 196  : 	for(int i = 0; i < NUM_DOMAIN_TYPES; i++)

	mov	DWORD PTR _i$222394[ebp], 0
	jmp	SHORT $LN9@uninit
$LN8@uninit:
	mov	edx, DWORD PTR _i$222394[ebp]
	add	edx, 1
	mov	DWORD PTR _i$222394[ebp], edx
$LN9@uninit:
	cmp	DWORD PTR _i$222394[ebp], 5
	jge	SHORT $LN7@uninit

; 197  : 	{
; 198  : 		m_aiExtraMoves[i] = 0;

	mov	eax, DWORD PTR _i$222394[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+1108], 0

; 199  : 	}

	jmp	SHORT $LN8@uninit
$LN7@uninit:

; 200  : 
; 201  : 	for(int i = 0; i < MAX_TEAMS; i++)

	mov	DWORD PTR _i$222398[ebp], 0
	jmp	SHORT $LN6@uninit
$LN5@uninit:
	mov	edx, DWORD PTR _i$222398[ebp]
	add	edx, 1
	mov	DWORD PTR _i$222398[ebp], edx
$LN6@uninit:
	cmp	DWORD PTR _i$222398[ebp], 64		; 00000040H
	jge	$LN4@uninit

; 202  : 	{
; 203  : 		m_aiTechShareCount[i] = 0;

	mov	eax, DWORD PTR _i$222398[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+148], 0

; 204  : 		m_paiTurnMadePeaceTreatyWithTeam[i] = -1;

	mov	edx, DWORD PTR _i$222398[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx*4+1128], -1

; 205  : 		m_aiIgnoreWarningCount[i] = 0;

	mov	ecx, DWORD PTR _i$222398[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+1448], 0

; 206  : 		m_abHasMet[i] = false;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _i$222398[ebp]
	mov	BYTE PTR [eax+1848], 0

; 207  : 		m_abAtWar[i] = false;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR _i$222398[ebp]
	mov	BYTE PTR [ecx+1928], 0

; 208  : 		m_abPermanentWarPeace[i] = false;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR _i$222398[ebp]
	mov	BYTE PTR [edx+2008], 0

; 209  : 		m_abEmbassy[i] = false;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _i$222398[ebp]
	mov	BYTE PTR [eax+2088], 0

; 210  : 		m_abOpenBorders[i] = false;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR _i$222398[ebp]
	mov	BYTE PTR [ecx+2168], 0

; 211  : 		m_abDefensivePact[i] = false;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR _i$222398[ebp]
	mov	BYTE PTR [edx+2248], 0

; 212  : 		m_abResearchAgreement[i] = false;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _i$222398[ebp]
	mov	BYTE PTR [eax+2328], 0

; 213  : 		m_abTradeAgreement[i] = false;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR _i$222398[ebp]
	mov	BYTE PTR [ecx+2408], 0

; 214  : 		m_abForcePeace[i] = false;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR _i$222398[ebp]
	mov	BYTE PTR [edx+2488], 0

; 215  : 	}

	jmp	$LN5@uninit
$LN4@uninit:

; 216  : 
; 217  : 	for(int i = 0; i < MAX_PLAYERS; i++)

	mov	DWORD PTR _i$222402[ebp], 0
	jmp	SHORT $LN3@uninit
$LN2@uninit:
	mov	eax, DWORD PTR _i$222402[ebp]
	add	eax, 1
	mov	DWORD PTR _i$222402[ebp], eax
$LN3@uninit:
	cmp	DWORD PTR _i$222402[ebp], 64		; 00000040H
	jge	SHORT $LN1@uninit

; 218  : 	{
; 219  : 		m_abHasFoundPlayersTerritory[i] = false;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR _i$222402[ebp]
	mov	BYTE PTR [ecx+1768], 0

; 220  : 	}

	jmp	SHORT $LN2@uninit
$LN1@uninit:

; 221  : 
; 222  : 	m_eID = NO_TEAM;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], -1

; 223  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?uninit@CvTeam@@QAEXXZ ENDP				; CvTeam::uninit
_TEXT	ENDS
PUBLIC	?erase@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@0@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::erase
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
PUBLIC	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > > >::Alloc
EXTRN	?Init@CvTeamTechs@@QAEXPAVCvTechXMLEntries@@PAVCvTeam@@@Z:PROC ; CvTeamTechs::Init
EXTRN	?GetGameTechs@CvGlobals@@QBEPAVCvTechXMLEntries@@XZ:PROC ; CvGlobals::GetGameTechs
EXTRN	?getNumImprovementInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumImprovementInfos
EXTRN	?getNumTerrainInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumTerrainInfos
EXTRN	?getNumBuildingInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumBuildingInfos
EXTRN	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ:PROC ; CvGlobals::getNumBuildingClassInfos
EXTRN	?getNumUnitClassInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumUnitClassInfos
EXTRN	?getNumProjectInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumProjectInfos
EXTRN	?getNumBuildInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumBuildInfos
EXTRN	?getNumRouteInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumRouteInfos
EXTRN	?getNumSmallAwardInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumSmallAwardInfos
EXTRN	?getNumVictoryInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumVictoryInfos
EXTRN	?getNumVoteSourceInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumVoteSourceInfos
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?reset@CvTeam@@QAEXW4TeamTypes@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?reset@CvTeam@@QAEXW4TeamTypes@@_N@Z$0
__ehfuncinfo$?reset@CvTeam@@QAEXW4TeamTypes@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?reset@CvTeam@@QAEXW4TeamTypes@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?reset@CvTeam@@QAEXW4TeamTypes@@_N@Z
_TEXT	SEGMENT
tv393 = -516						; size = 4
_this$ = -512						; size = 4
$T231538 = -508						; size = 4
$T231371 = -440						; size = 4
$T231355 = -436						; size = 4
$T231525 = -432						; size = 4
$T231524 = -428						; size = 4
$T231523 = -424						; size = 4
$T231522 = -420						; size = 4
$T231521 = -416						; size = 4
$T231319 = -332						; size = 4
$T231318 = -328						; size = 4
$T231317 = -324						; size = 4
_j$222472 = -320					; size = 4
_i$222468 = -316					; size = 4
_i$222464 = -312					; size = 4
_i$222460 = -308					; size = 4
_i$222456 = -304					; size = 4
_i$222452 = -300					; size = 4
_i$222448 = -296					; size = 4
_i$222444 = -292					; size = 4
_i$222440 = -288					; size = 4
_i$222436 = -284					; size = 4
_i$222432 = -280					; size = 4
_i$222428 = -276					; size = 4
_i$222424 = -272					; size = 4
_numUnitClassInfos$222418 = -268			; size = 4
_numVoteSourceInfos$222412 = -264			; size = 4
_numBuildingInfos$222420 = -260				; size = 4
_numTerrainInfos$222421 = -256				; size = 4
_numSmallAwardInfos$222414 = -252			; size = 4
_numImprovementInfos$222422 = -248			; size = 4
_numProjectInfos$222417 = -244				; size = 4
_numBuildingClassInfos$222419 = -240			; size = 4
_aData$222423 = -236					; size = 204
_numRouteInfos$222415 = -24				; size = 4
_numBuildInfos$222416 = -20				; size = 4
_numVictoryInfos$222413 = -16				; size = 4
__$EHRec$ = -12						; size = 12
_eID$ = 8						; size = 4
_bConstructorCall$ = 12					; size = 1
?reset@CvTeam@@QAEXW4TeamTypes@@_N@Z PROC		; CvTeam::reset, COMDAT
; _this$ = ecx

; 230  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?reset@CvTeam@@QAEXW4TeamTypes@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 504				; 000001f8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 231  : 	//--------------------------------
; 232  : 	// Uninit class
; 233  : 	uninit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?uninit@CvTeam@@QAEXXZ			; CvTeam::uninit

; 234  : 
; 235  : 	m_eID = eID;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _eID$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 236  : 
; 237  : 	if(!bConstructorCall)

	movzx	edx, BYTE PTR _bConstructorCall$[ebp]
	test	edx, edx
	jne	$LN41@reset

; 238  : 	{
; 239  : 		//Collect sizes
; 240  : #ifdef AUI_WARNING_FIXES
; 241  : 		uint numVoteSourceInfos = GC.getNumVoteSourceInfos();
; 242  : 		uint numVictoryInfos = GC.getNumVictoryInfos();
; 243  : 		uint numSmallAwardInfos = GC.getNumSmallAwardInfos();
; 244  : 		uint numRouteInfos = GC.getNumRouteInfos();
; 245  : 		uint numBuildInfos = GC.getNumBuildInfos();
; 246  : 		uint numProjectInfos = GC.getNumProjectInfos();
; 247  : 		uint numUnitClassInfos = GC.getNumUnitClassInfos();
; 248  : 		uint numBuildingClassInfos = GC.getNumBuildingClassInfos();
; 249  : 		uint numBuildingInfos = GC.getNumBuildingInfos();
; 250  : 		uint numTerrainInfos = GC.getNumTerrainInfos();
; 251  : 		uint numImprovementInfos = GC.getNumImprovementInfos();
; 252  : #else
; 253  : 		int numVoteSourceInfos = GC.getNumVoteSourceInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumVoteSourceInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumVoteSourceInfos
	mov	DWORD PTR _numVoteSourceInfos$222412[ebp], eax

; 254  : 		int numVictoryInfos = GC.getNumVictoryInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumVictoryInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumVictoryInfos
	mov	DWORD PTR _numVictoryInfos$222413[ebp], eax

; 255  : 		int numSmallAwardInfos = GC.getNumSmallAwardInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumSmallAwardInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumSmallAwardInfos
	mov	DWORD PTR _numSmallAwardInfos$222414[ebp], eax

; 256  : 		int numRouteInfos = GC.getNumRouteInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumRouteInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumRouteInfos
	mov	DWORD PTR _numRouteInfos$222415[ebp], eax

; 257  : 		int numBuildInfos = GC.getNumBuildInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	mov	DWORD PTR _numBuildInfos$222416[ebp], eax

; 258  : 		int numProjectInfos = GC.getNumProjectInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumProjectInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumProjectInfos
	mov	DWORD PTR _numProjectInfos$222417[ebp], eax

; 259  : 		int numUnitClassInfos = GC.getNumUnitClassInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumUnitClassInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitClassInfos
	mov	DWORD PTR _numUnitClassInfos$222418[ebp], eax

; 260  : 		int numBuildingClassInfos = GC.getNumBuildingClassInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	mov	DWORD PTR _numBuildingClassInfos$222419[ebp], eax

; 261  : 		int numBuildingInfos = GC.getNumBuildingInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	mov	DWORD PTR _numBuildingInfos$222420[ebp], eax

; 262  : 		int numTerrainInfos = GC.getNumTerrainInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTerrainInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTerrainInfos
	mov	DWORD PTR _numTerrainInfos$222421[ebp], eax

; 263  : 		int numImprovementInfos = GC.getNumImprovementInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumImprovementInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumImprovementInfos
	mov	DWORD PTR _numImprovementInfos$222422[ebp], eax

; 264  : #endif
; 265  : 
; 266  : 		//Perform batch allocation
; 267  : 		AllocData aData[] =
; 268  : 		{
; 269  : 			{&m_aiForceTeamVoteEligibilityCount,	numVoteSourceInfos, 0},

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2892				; 00000b4cH
	mov	DWORD PTR _aData$222423[ebp], eax
	mov	ecx, DWORD PTR _numVoteSourceInfos$222412[ebp]
	mov	DWORD PTR _aData$222423[ebp+4], ecx
	mov	DWORD PTR _aData$222423[ebp+8], 0

; 270  : 
; 271  : 			{&m_abCanLaunch,						numVictoryInfos, 0},

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2896				; 00000b50H
	mov	DWORD PTR _aData$222423[ebp+12], edx
	mov	eax, DWORD PTR _numVictoryInfos$222413[ebp]
	mov	DWORD PTR _aData$222423[ebp+16], eax
	mov	DWORD PTR _aData$222423[ebp+20], 0

; 272  : 			{&m_abVictoryAchieved,					numVictoryInfos, 0},

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2900				; 00000b54H
	mov	DWORD PTR _aData$222423[ebp+24], ecx
	mov	edx, DWORD PTR _numVictoryInfos$222413[ebp]
	mov	DWORD PTR _aData$222423[ebp+28], edx
	mov	DWORD PTR _aData$222423[ebp+32], 0

; 273  : 			{&m_abSmallAwardAchieved,				numSmallAwardInfos, 0},

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2904				; 00000b58H
	mov	DWORD PTR _aData$222423[ebp+36], eax
	mov	ecx, DWORD PTR _numSmallAwardInfos$222414[ebp]
	mov	DWORD PTR _aData$222423[ebp+40], ecx
	mov	DWORD PTR _aData$222423[ebp+44], 0

; 274  : 
; 275  : 			{&m_paiRouteChange,						numRouteInfos, 0},

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2908				; 00000b5cH
	mov	DWORD PTR _aData$222423[ebp+48], edx
	mov	eax, DWORD PTR _numRouteInfos$222415[ebp]
	mov	DWORD PTR _aData$222423[ebp+52], eax
	mov	DWORD PTR _aData$222423[ebp+56], 0

; 276  : 			{&m_paiBuildTimeChange,					numBuildInfos, 0},

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2912				; 00000b60H
	mov	DWORD PTR _aData$222423[ebp+60], ecx
	mov	edx, DWORD PTR _numBuildInfos$222416[ebp]
	mov	DWORD PTR _aData$222423[ebp+64], edx
	mov	DWORD PTR _aData$222423[ebp+68], 0

; 277  : 
; 278  : 			{&m_paiProjectCount,					numProjectInfos, 0},

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2916				; 00000b64H
	mov	DWORD PTR _aData$222423[ebp+72], eax
	mov	ecx, DWORD PTR _numProjectInfos$222417[ebp]
	mov	DWORD PTR _aData$222423[ebp+76], ecx
	mov	DWORD PTR _aData$222423[ebp+80], 0

; 279  : 			{&m_paiProjectDefaultArtTypes,			numProjectInfos, 0},

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2920				; 00000b68H
	mov	DWORD PTR _aData$222423[ebp+84], edx
	mov	eax, DWORD PTR _numProjectInfos$222417[ebp]
	mov	DWORD PTR _aData$222423[ebp+88], eax
	mov	DWORD PTR _aData$222423[ebp+92], 0

; 280  : 			{&m_paiProjectMaking,					numProjectInfos, 0},

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2924				; 00000b6cH
	mov	DWORD PTR _aData$222423[ebp+96], ecx
	mov	edx, DWORD PTR _numProjectInfos$222417[ebp]
	mov	DWORD PTR _aData$222423[ebp+100], edx
	mov	DWORD PTR _aData$222423[ebp+104], 0

; 281  : 
; 282  : 			{&m_paiUnitClassCount,					numUnitClassInfos, 0},

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2928				; 00000b70H
	mov	DWORD PTR _aData$222423[ebp+108], eax
	mov	ecx, DWORD PTR _numUnitClassInfos$222418[ebp]
	mov	DWORD PTR _aData$222423[ebp+112], ecx
	mov	DWORD PTR _aData$222423[ebp+116], 0

; 283  : 			{&m_paiBuildingClassCount,				numBuildingClassInfos, 0},

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2932				; 00000b74H
	mov	DWORD PTR _aData$222423[ebp+120], edx
	mov	eax, DWORD PTR _numBuildingClassInfos$222419[ebp]
	mov	DWORD PTR _aData$222423[ebp+124], eax
	mov	DWORD PTR _aData$222423[ebp+128], 0

; 284  : 			{&m_paiObsoleteBuildingCount,			numBuildingInfos, 0},

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2936				; 00000b78H
	mov	DWORD PTR _aData$222423[ebp+132], ecx
	mov	edx, DWORD PTR _numBuildingInfos$222420[ebp]
	mov	DWORD PTR _aData$222423[ebp+136], edx
	mov	DWORD PTR _aData$222423[ebp+140], 0

; 285  : 			{&m_paiTerrainTradeCount,				numTerrainInfos, 0},

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2940				; 00000b7cH
	mov	DWORD PTR _aData$222423[ebp+144], eax
	mov	ecx, DWORD PTR _numTerrainInfos$222421[ebp]
	mov	DWORD PTR _aData$222423[ebp+148], ecx
	mov	DWORD PTR _aData$222423[ebp+152], 0

; 286  : 			{&m_aiVictoryCountdown,					numVictoryInfos, 0},

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2944				; 00000b80H
	mov	DWORD PTR _aData$222423[ebp+156], edx
	mov	eax, DWORD PTR _numVictoryInfos$222413[ebp]
	mov	DWORD PTR _aData$222423[ebp+160], eax
	mov	DWORD PTR _aData$222423[ebp+164], 0

; 287  : 
; 288  : 			{&m_ppaaiImprovementYieldChange,		numImprovementInfos, NUM_YIELD_TYPES},

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2948				; 00000b84H
	mov	DWORD PTR _aData$222423[ebp+168], ecx
	mov	edx, DWORD PTR _numImprovementInfos$222422[ebp]
	mov	DWORD PTR _aData$222423[ebp+172], edx
	mov	DWORD PTR _aData$222423[ebp+176], 6

; 289  : 			{&m_ppaaiImprovementNoFreshWaterYieldChange,numImprovementInfos, NUM_YIELD_TYPES},

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2952				; 00000b88H
	mov	DWORD PTR _aData$222423[ebp+180], eax
	mov	ecx, DWORD PTR _numImprovementInfos$222422[ebp]
	mov	DWORD PTR _aData$222423[ebp+184], ecx
	mov	DWORD PTR _aData$222423[ebp+188], 6

; 290  : 			{&m_ppaaiImprovementFreshWaterYieldChange,numImprovementInfos, NUM_YIELD_TYPES}

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2956				; 00000b8cH
	mov	DWORD PTR _aData$222423[ebp+192], edx
	mov	eax, DWORD PTR _numImprovementInfos$222422[ebp]
	mov	DWORD PTR _aData$222423[ebp+196], eax
	mov	DWORD PTR _aData$222423[ebp+200], 6

; 291  : 		};
; 292  : 		m_BatchData.Alloc(aData);

	lea	ecx, DWORD PTR _aData$222423[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2888				; 00000b48H
	call	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > > >::Alloc

; 293  : 
; 294  : 		//Init the data - it is valid now
; 295  : #ifdef AUI_WARNING_FIXES
; 296  : 		for (uint i = 0; i < numVoteSourceInfos; i++)
; 297  : #else
; 298  : 		for(int i = 0; i < numVoteSourceInfos; i++)

	mov	DWORD PTR _i$222424[ebp], 0
	jmp	SHORT $LN39@reset
$LN38@reset:
	mov	edx, DWORD PTR _i$222424[ebp]
	add	edx, 1
	mov	DWORD PTR _i$222424[ebp], edx
$LN39@reset:
	mov	eax, DWORD PTR _i$222424[ebp]
	cmp	eax, DWORD PTR _numVoteSourceInfos$222412[ebp]
	jge	SHORT $LN37@reset

; 299  : #endif
; 300  : 		{
; 301  : 			m_aiForceTeamVoteEligibilityCount[i] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2892]
	mov	eax, DWORD PTR _i$222424[ebp]
	mov	DWORD PTR [edx+eax*4], 0

; 302  : 		}

	jmp	SHORT $LN38@reset
$LN37@reset:

; 303  : #ifdef AUI_WARNING_FIXES
; 304  : 		for (uint i = 0; i < numVictoryInfos; i++)
; 305  : #else
; 306  : 		for(int i = 0; i < numVictoryInfos; i++)

	mov	DWORD PTR _i$222428[ebp], 0
	jmp	SHORT $LN36@reset
$LN35@reset:
	mov	ecx, DWORD PTR _i$222428[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$222428[ebp], ecx
$LN36@reset:
	mov	edx, DWORD PTR _i$222428[ebp]
	cmp	edx, DWORD PTR _numVictoryInfos$222413[ebp]
	jge	SHORT $LN34@reset

; 307  : #endif
; 308  : 		{
; 309  : 			m_abCanLaunch[i] = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2896]
	mov	edx, DWORD PTR _i$222428[ebp]
	mov	BYTE PTR [ecx+edx], 0

; 310  : 			m_abVictoryAchieved[i] = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2900]
	mov	edx, DWORD PTR _i$222428[ebp]
	mov	BYTE PTR [ecx+edx], 0

; 311  : 			m_aiVictoryCountdown[i] = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2944]
	mov	edx, DWORD PTR _i$222428[ebp]
	mov	DWORD PTR [ecx+edx*4], -1

; 312  : 		}

	jmp	SHORT $LN35@reset
$LN34@reset:

; 313  : #ifdef AUI_WARNING_FIXES
; 314  : 		for (uint i = 0; i < numSmallAwardInfos; i++)
; 315  : #else
; 316  : 		for(int i = 0; i < numSmallAwardInfos; i++)

	mov	DWORD PTR _i$222432[ebp], 0
	jmp	SHORT $LN33@reset
$LN32@reset:
	mov	eax, DWORD PTR _i$222432[ebp]
	add	eax, 1
	mov	DWORD PTR _i$222432[ebp], eax
$LN33@reset:
	mov	ecx, DWORD PTR _i$222432[ebp]
	cmp	ecx, DWORD PTR _numSmallAwardInfos$222414[ebp]
	jge	SHORT $LN31@reset

; 317  : #endif
; 318  : 		{
; 319  : 			m_abSmallAwardAchieved[i] = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2904]
	mov	ecx, DWORD PTR _i$222432[ebp]
	mov	BYTE PTR [eax+ecx], 0

; 320  : 		}

	jmp	SHORT $LN32@reset
$LN31@reset:

; 321  : #ifdef AUI_WARNING_FIXES
; 322  : 		for (uint i = 0; i < numRouteInfos; i++)
; 323  : #else
; 324  : 		for(int i = 0; i < numRouteInfos; i++)

	mov	DWORD PTR _i$222436[ebp], 0
	jmp	SHORT $LN30@reset
$LN29@reset:
	mov	edx, DWORD PTR _i$222436[ebp]
	add	edx, 1
	mov	DWORD PTR _i$222436[ebp], edx
$LN30@reset:
	mov	eax, DWORD PTR _i$222436[ebp]
	cmp	eax, DWORD PTR _numRouteInfos$222415[ebp]
	jge	SHORT $LN28@reset

; 325  : #endif
; 326  : 		{
; 327  : 			m_paiRouteChange[i] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2908]
	mov	eax, DWORD PTR _i$222436[ebp]
	mov	DWORD PTR [edx+eax*4], 0

; 328  : 		}

	jmp	SHORT $LN29@reset
$LN28@reset:

; 329  : #ifdef AUI_WARNING_FIXES
; 330  : 		for (uint i = 0; i < numBuildInfos; i++)
; 331  : #else
; 332  : 		for (int i = 0; i < numBuildInfos; i++)

	mov	DWORD PTR _i$222440[ebp], 0
	jmp	SHORT $LN27@reset
$LN26@reset:
	mov	ecx, DWORD PTR _i$222440[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$222440[ebp], ecx
$LN27@reset:
	mov	edx, DWORD PTR _i$222440[ebp]
	cmp	edx, DWORD PTR _numBuildInfos$222416[ebp]
	jge	SHORT $LN25@reset

; 333  : #endif
; 334  : 		{
; 335  : 			m_paiBuildTimeChange[i] = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2912]
	mov	edx, DWORD PTR _i$222440[ebp]
	mov	DWORD PTR [ecx+edx*4], 0

; 336  : 		}

	jmp	SHORT $LN26@reset
$LN25@reset:

; 337  : #ifdef AUI_WARNING_FIXES
; 338  : 		for (uint i = 0; i < numProjectInfos; i++)
; 339  : #else
; 340  : 		for(int i = 0; i < numProjectInfos; i++)

	mov	DWORD PTR _i$222444[ebp], 0
	jmp	SHORT $LN24@reset
$LN23@reset:
	mov	eax, DWORD PTR _i$222444[ebp]
	add	eax, 1
	mov	DWORD PTR _i$222444[ebp], eax
$LN24@reset:
	mov	ecx, DWORD PTR _i$222444[ebp]
	cmp	ecx, DWORD PTR _numProjectInfos$222417[ebp]
	jge	SHORT $LN22@reset

; 341  : #endif
; 342  : 		{
; 343  : 			m_paiProjectCount[i] = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2916]
	mov	ecx, DWORD PTR _i$222444[ebp]
	mov	DWORD PTR [eax+ecx*4], 0

; 344  : 			m_paiProjectDefaultArtTypes[i] = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2920]
	mov	ecx, DWORD PTR _i$222444[ebp]
	mov	DWORD PTR [eax+ecx*4], 0

; 345  : 			m_paiProjectMaking[i] = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2924]
	mov	ecx, DWORD PTR _i$222444[ebp]
	mov	DWORD PTR [eax+ecx*4], 0

; 346  : 		}

	jmp	SHORT $LN23@reset
$LN22@reset:

; 347  : #ifdef AUI_WARNING_FIXES
; 348  : 		for (uint i = 0; i < numUnitClassInfos; i++)
; 349  : #else
; 350  : 		for(int i = 0; i < numUnitClassInfos; i++)

	mov	DWORD PTR _i$222448[ebp], 0
	jmp	SHORT $LN21@reset
$LN20@reset:
	mov	edx, DWORD PTR _i$222448[ebp]
	add	edx, 1
	mov	DWORD PTR _i$222448[ebp], edx
$LN21@reset:
	mov	eax, DWORD PTR _i$222448[ebp]
	cmp	eax, DWORD PTR _numUnitClassInfos$222418[ebp]
	jge	SHORT $LN19@reset

; 351  : #endif
; 352  : 		{
; 353  : 			m_paiUnitClassCount[i] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2928]
	mov	eax, DWORD PTR _i$222448[ebp]
	mov	DWORD PTR [edx+eax*4], 0

; 354  : 		}

	jmp	SHORT $LN20@reset
$LN19@reset:

; 355  : #ifdef AUI_WARNING_FIXES
; 356  : 		for (uint i = 0; i < numBuildingClassInfos; i++)
; 357  : #else
; 358  : 		for(int i = 0; i < numBuildingClassInfos; i++)

	mov	DWORD PTR _i$222452[ebp], 0
	jmp	SHORT $LN18@reset
$LN17@reset:
	mov	ecx, DWORD PTR _i$222452[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$222452[ebp], ecx
$LN18@reset:
	mov	edx, DWORD PTR _i$222452[ebp]
	cmp	edx, DWORD PTR _numBuildingClassInfos$222419[ebp]
	jge	SHORT $LN16@reset

; 359  : #endif
; 360  : 		{
; 361  : 			m_paiBuildingClassCount[i] = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2932]
	mov	edx, DWORD PTR _i$222452[ebp]
	mov	DWORD PTR [ecx+edx*4], 0

; 362  : 		}

	jmp	SHORT $LN17@reset
$LN16@reset:

; 363  : #ifdef AUI_WARNING_FIXES
; 364  : 		for (uint i = 0; i < numBuildingInfos; i++)
; 365  : #else
; 366  : 		for(int i = 0; i < numBuildingInfos; i++)

	mov	DWORD PTR _i$222456[ebp], 0
	jmp	SHORT $LN15@reset
$LN14@reset:
	mov	eax, DWORD PTR _i$222456[ebp]
	add	eax, 1
	mov	DWORD PTR _i$222456[ebp], eax
$LN15@reset:
	mov	ecx, DWORD PTR _i$222456[ebp]
	cmp	ecx, DWORD PTR _numBuildingInfos$222420[ebp]
	jge	SHORT $LN13@reset

; 367  : #endif
; 368  : 		{
; 369  : 			m_paiObsoleteBuildingCount[i] = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2936]
	mov	ecx, DWORD PTR _i$222456[ebp]
	mov	DWORD PTR [eax+ecx*4], 0

; 370  : 		}

	jmp	SHORT $LN14@reset
$LN13@reset:

; 371  : #ifdef AUI_WARNING_FIXES
; 372  : 		for (uint i = 0; i < numTerrainInfos; i++)
; 373  : #else
; 374  : 		for(int i = 0; i < numTerrainInfos; i++)

	mov	DWORD PTR _i$222460[ebp], 0
	jmp	SHORT $LN12@reset
$LN11@reset:
	mov	edx, DWORD PTR _i$222460[ebp]
	add	edx, 1
	mov	DWORD PTR _i$222460[ebp], edx
$LN12@reset:
	mov	eax, DWORD PTR _i$222460[ebp]
	cmp	eax, DWORD PTR _numTerrainInfos$222421[ebp]
	jge	SHORT $LN10@reset

; 375  : #endif
; 376  : 		{
; 377  : 			m_paiTerrainTradeCount[i] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2940]
	mov	eax, DWORD PTR _i$222460[ebp]
	mov	DWORD PTR [edx+eax*4], 0

; 378  : 		}

	jmp	SHORT $LN11@reset
$LN10@reset:

; 379  : 
; 380  : 		for(int i = 0; i < MAX_TEAMS; i++)

	mov	DWORD PTR _i$222464[ebp], 0
	jmp	SHORT $LN9@reset
$LN8@reset:
	mov	ecx, DWORD PTR _i$222464[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$222464[ebp], ecx
$LN9@reset:
	cmp	DWORD PTR _i$222464[ebp], 64		; 00000040H
	jge	SHORT $LN7@reset

; 381  : 		{
; 382  : 			m_aiTurnTeamMet[i] = -1;

	mov	edx, DWORD PTR _i$222464[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx*4+2568], -1

; 383  : 			m_aiNumTurnsAtWar[i] = 0;

	mov	ecx, DWORD PTR _i$222464[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+468], 0

; 384  : 			m_aiNumTurnsLockedIntoWar[i] = 0;

	mov	eax, DWORD PTR _i$222464[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+788], 0

; 385  : 		}

	jmp	SHORT $LN8@reset
$LN7@reset:

; 386  : 
; 387  : #ifdef AUI_WARNING_FIXES
; 388  : 		for (uint i = 0; i < numImprovementInfos; i++)
; 389  : #else
; 390  : 		for(int i = 0; i < numImprovementInfos; i++)

	mov	DWORD PTR _i$222468[ebp], 0
	jmp	SHORT $LN6@reset
$LN5@reset:
	mov	edx, DWORD PTR _i$222468[ebp]
	add	edx, 1
	mov	DWORD PTR _i$222468[ebp], edx
$LN6@reset:
	mov	eax, DWORD PTR _i$222468[ebp]
	cmp	eax, DWORD PTR _numImprovementInfos$222422[ebp]
	jge	$LN4@reset

; 391  : #endif
; 392  : 		{
; 393  : 			for(int j = 0; j < NUM_YIELD_TYPES; j++)

	mov	DWORD PTR _j$222472[ebp], 0
	jmp	SHORT $LN3@reset
$LN2@reset:
	mov	ecx, DWORD PTR _j$222472[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$222472[ebp], ecx
$LN3@reset:
	cmp	DWORD PTR _j$222472[ebp], 6
	jge	SHORT $LN1@reset

; 394  : 			{
; 395  : 				m_ppaaiImprovementYieldChange[i][j] = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2948]
	mov	ecx, DWORD PTR _i$222468[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _j$222472[ebp]
	mov	DWORD PTR [edx+eax*4], 0

; 396  : 				m_ppaaiImprovementNoFreshWaterYieldChange[i][j] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2952]
	mov	eax, DWORD PTR _i$222468[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _j$222472[ebp]
	mov	DWORD PTR [ecx+edx*4], 0

; 397  : 				m_ppaaiImprovementFreshWaterYieldChange[i][j] = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2956]
	mov	edx, DWORD PTR _i$222468[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _j$222472[ebp]
	mov	DWORD PTR [eax+ecx*4], 0

; 398  : 			}

	jmp	SHORT $LN2@reset
$LN1@reset:

; 399  : 		}

	jmp	$LN5@reset
$LN4@reset:

; 400  : 
; 401  : 		m_pTeamTechs->Init(GC.GetGameTechs(), this);

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameTechs@CvGlobals@@QBEPAVCvTechXMLEntries@@XZ ; CvGlobals::GetGameTechs
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2980]
	call	?Init@CvTeamTechs@@QAEXPAVCvTechXMLEntries@@PAVCvTeam@@@Z ; CvTeamTechs::Init

; 402  : 		m_pavProjectArtTypes = FNEW(std::vector<int> [GC.getNumProjectInfos()], c_eCiv5GameplayDLL, 0);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumProjectInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumProjectInfos
	mov	DWORD PTR $T231317[ebp], eax
	xor	ecx, ecx
	mov	eax, DWORD PTR $T231317[ebp]
	mov	edx, 16					; 00000010H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T231319[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T231319[ebp], 0
	je	SHORT $LN43@reset
	mov	ecx, DWORD PTR $T231319[ebp]
	mov	edx, DWORD PTR $T231317[ebp]
	mov	DWORD PTR [ecx], edx
	push	OFFSET ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
	push	OFFSET ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	eax, DWORD PTR $T231317[ebp]
	push	eax
	push	16					; 00000010H
	mov	ecx, DWORD PTR $T231319[ebp]
	add	ecx, 4
	push	ecx
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	mov	edx, DWORD PTR $T231319[ebp]
	add	edx, 4
	mov	DWORD PTR tv393[ebp], edx
	jmp	SHORT $LN44@reset
$LN43@reset:
	mov	DWORD PTR tv393[ebp], 0
$LN44@reset:
	mov	eax, DWORD PTR tv393[ebp]
	mov	DWORD PTR $T231318[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T231318[ebp]
	mov	DWORD PTR [ecx+2960], edx

; 403  : 		m_aeRevealedResources.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2964				; 00000b94H
	mov	DWORD PTR $T231538[ebp], eax
	mov	ecx, DWORD PTR $T231538[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T231355[ebp], edx
	mov	eax, DWORD PTR $T231355[ebp]
	mov	DWORD PTR $T231522[ebp], eax
	mov	ecx, DWORD PTR $T231522[ebp]
	mov	DWORD PTR $T231521[ebp], ecx
	mov	edx, DWORD PTR $T231538[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T231371[ebp], eax
	mov	ecx, DWORD PTR $T231371[ebp]
	mov	DWORD PTR $T231524[ebp], ecx
	mov	edx, DWORD PTR $T231524[ebp]
	mov	DWORD PTR $T231523[ebp], edx
	mov	eax, DWORD PTR $T231521[ebp]
	push	eax
	mov	ecx, DWORD PTR $T231523[ebp]
	push	ecx
	lea	edx, DWORD PTR $T231525[ebp]
	push	edx
	mov	ecx, DWORD PTR $T231538[ebp]
	call	?erase@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@0@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::erase
$LN41@reset:

; 404  : 	}
; 405  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?reset@CvTeam@@QAEXW4TeamTypes@@_N@Z$0:
	mov	eax, DWORD PTR $T231319[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__ehhandler$?reset@CvTeam@@QAEXW4TeamTypes@@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-508]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?reset@CvTeam@@QAEXW4TeamTypes@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?reset@CvTeam@@QAEXW4TeamTypes@@_N@Z ENDP		; CvTeam::reset
PUBLIC	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
PUBLIC	??_E?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z ; std::vector<int,std::allocator<int> >::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_E?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_E?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z$0
__ehfuncinfo$??_E?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_E?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??_E?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_E?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z PROC	; std::vector<int,std::allocator<int> >::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??_E?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@2
	push	OFFSET ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@2
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@2:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@2
$LN3@vector@2:
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@2
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@2:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@2:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_E?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__ehhandler$??_E?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??_E?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??_E?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z ENDP	; std::vector<int,std::allocator<int> >::`vector deleting destructor'
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
PUBLIC	?shareCounters@CvTeam@@QAEXW4TeamTypes@@@Z	; CvTeam::shareCounters
PUBLIC	?setForcePeace@CvTeam@@QAEXW4TeamTypes@@_N@Z	; CvTeam::setForcePeace
PUBLIC	?isForcePeace@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isForcePeace
PUBLIC	?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasDefensivePact
PUBLIC	?IsHasDefensivePact@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsHasDefensivePact
PUBLIC	?SetAllowsOpenBordersToTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetAllowsOpenBordersToTeam
PUBLIC	?IsAllowsOpenBordersToTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsAllowsOpenBordersToTeam
PUBLIC	?SetHasEmbassyAtTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasEmbassyAtTeam
PUBLIC	?HasEmbassyAtTeam@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::HasEmbassyAtTeam
PUBLIC	?setPermanentWarPeace@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::setPermanentWarPeace
PUBLIC	?isPermanentWarPeace@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::isPermanentWarPeace
PUBLIC	?declareWar@CvTeam@@QAEXW4TeamTypes@@_N@Z	; CvTeam::declareWar
PUBLIC	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z		; CvTeam::isAtWar
PUBLIC	?meet@CvTeam@@QAEXW4TeamTypes@@_N@Z		; CvTeam::meet
PUBLIC	?shareItems@CvTeam@@QAEXW4TeamTypes@@@Z		; CvTeam::shareItems
PUBLIC	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ	; CvTeam::getLeaderID
PUBLIC	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
PUBLIC	??_C@_0CH@BFNGIGJO@TXT_KEY_MISC_PLAYER_PERMANENT_AL@ ; `string'
PUBLIC	?getName@CvTeam@@QBE?AVCvString@@XZ		; CvTeam::getName
PUBLIC	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z		; CvTeam::isHasMet
PUBLIC	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ		; CvTeam::GetID
PUBLIC	__$ArrayPad$
PUBLIC	?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z		; CvTeam::addTeam
EXTRN	?updateScore@CvGame@@QAEX_N@Z:PROC		; CvGame::updateScore
EXTRN	?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z:PROC ; CvPlot::setRevealed
EXTRN	?changeInvisibleVisibilityCount@CvPlot@@QAEXW4TeamTypes@@W4InvisibleTypes@@H@Z:PROC ; CvPlot::changeInvisibleVisibilityCount
EXTRN	?getInvisibleVisibilityCount@CvPlot@@QBEHW4TeamTypes@@W4InvisibleTypes@@@Z:PROC ; CvPlot::getInvisibleVisibilityCount
EXTRN	?changeVisibilityCount@CvPlot@@QAE?AW4PlotVisibilityChangeResult@@W4TeamTypes@@HW4InvisibleTypes@@_N2@Z:PROC ; CvPlot::changeVisibilityCount
EXTRN	?setTeam@CvPlayer@@QAEXW4TeamTypes@@@Z:PROC	; CvPlayer::setTeam
EXTRN	?addReplayMessage@CvGame@@QAEXW4ReplayMessageTypes@@W4PlayerTypes@@ABVCvString@@HH@Z:PROC ; CvGame::addReplayMessage
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
EXTRN	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ:PROC ; CvGame::getActivePlayer
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
;	COMDAT ??_C@_0CH@BFNGIGJO@TXT_KEY_MISC_PLAYER_PERMANENT_AL@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0CH@BFNGIGJO@TXT_KEY_MISC_PLAYER_PERMANENT_AL@ DB 'TXT_KEY_MISC_PLA'
	DB	'YER_PERMANENT_ALLIANCE', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z$6
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z
_TEXT	SEGMENT
tv864 = -480						; size = 4
tv831 = -476						; size = 4
tv830 = -472						; size = 4
tv200 = -468						; size = 4
tv829 = -464						; size = 4
tv66 = -460						; size = 4
tv620 = -456						; size = 4
_this$ = -452						; size = 4
$T231955 = -448						; size = 4
_uiOffset$231950 = -444					; size = 4
$T231941 = -440						; size = 4
$T231934 = -436						; size = 4
$T231930 = -432						; size = 4
$T231926 = -428						; size = 4
$T231922 = -424						; size = 4
$T231910 = -420						; size = 4
$T231906 = -416						; size = 4
$T231896 = -412						; size = 4
$T231892 = -408						; size = 4
$T231885 = -404						; size = 4
$T231875 = -400						; size = 4
$T231871 = -396						; size = 4
$T231864 = -392						; size = 4
$T231854 = -388						; size = 4
$T231850 = -384						; size = 4
$T231843 = -380						; size = 4
$T231836 = -376						; size = 4
$T231829 = -372						; size = 4
$T231822 = -368						; size = 4
$T231815 = -364						; size = 4
$T231808 = -360						; size = 4
$T231801 = -356						; size = 4
$T231794 = -352						; size = 4
$T231787 = -348						; size = 4
$T231783 = -344						; size = 4
$T231779 = -340						; size = 4
$T231763 = -336						; size = 4
$T231759 = -332						; size = 4
$T231755 = -328						; size = 4
$T231751 = -324						; size = 4
$T231747 = -320						; size = 4
$T231743 = -316						; size = 4
$T231739 = -312						; size = 4
$T231723 = -308						; size = 4
$T231719 = -304						; size = 4
$T231715 = -300						; size = 4
$T231711 = -296						; size = 4
$T231707 = -292						; size = 4
$T231703 = -288						; size = 4
$T231699 = -284						; size = 4
$T231690 = -280						; size = 4
$T231686 = -276						; size = 4
$T231682 = -272						; size = 4
$T231673 = -268						; size = 4
$T231661 = -264						; size = 4
$T231657 = -260						; size = 4
$T231648 = -256						; size = 4
$T231644 = -249						; size = 1
$T231635 = -248						; size = 4
$T231620 = -244						; size = 28
$T231619 = -216						; size = 28
$T231618 = -188						; size = 4
$T231617 = -184						; size = 28
$T231616 = -156						; size = 4
$T231615 = -152						; size = 28
$T231614 = -124						; size = 28
$T231613 = -96						; size = 4
$T231612 = -92						; size = 28
$T231611 = -64						; size = 4
_strBuffer$ = -60					; size = 28
__$ArrayPad$ = -32					; size = 4
_iJ$ = -28						; size = 4
_iNumInvisibleInfos$ = -24				; size = 4
_iI$ = -20						; size = 4
_pLoopPlot$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_eTeam$ = 8						; size = 4
?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z PROC		; CvTeam::addTeam, COMDAT
; _this$ = ecx

; 410  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 468				; 000001d4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 411  : 	CvPlot* pLoopPlot;
; 412  : 	CvString strBuffer;

	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 413  : #ifdef AUI_WARNING_FIXES
; 414  : 	int iI;
; 415  : 	uint iJ;
; 416  : #else
; 417  : 	int iI, iJ;
; 418  : #endif
; 419  : 
; 420  : 	CvAssert(eTeam != NO_TEAM);
; 421  : 	CvAssert(eTeam != GetID());
; 422  : 
; 423  : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN74@addTeam
$LN73@addTeam:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN74@addTeam:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	$LN72@addTeam

; 424  : 	{
; 425  : 		if(GET_PLAYER((PlayerTypes)iI).isAlive())

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T231635[ebp], ecx
	mov	edx, DWORD PTR $T231635[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T231644[ebp], al
	movzx	ecx, BYTE PTR $T231644[ebp]
	test	ecx, ecx
	je	$LN71@addTeam

; 426  : 		{
; 427  : 			if((GET_PLAYER((PlayerTypes)iI).getTeam() != GetID()) && (GET_PLAYER((PlayerTypes)iI).getTeam() != eTeam))

	mov	edx, DWORD PTR _iI$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T231648[ebp], edx
	mov	eax, DWORD PTR $T231648[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T231657[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T231657[ebp], eax
	je	$LN71@addTeam
	mov	edx, DWORD PTR _iI$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T231661[ebp], edx
	mov	eax, DWORD PTR $T231661[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	eax, DWORD PTR _eTeam$[ebp]
	je	$LN71@addTeam

; 428  : 			{
; 429  : 				if(GET_TEAM(GET_PLAYER((PlayerTypes)iI).getTeam()).isHasMet(GetID()) && GET_TEAM(GET_PLAYER((PlayerTypes)iI).getTeam()).isHasMet(eTeam))

	mov	edx, DWORD PTR _iI$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T231673[ebp], edx
	mov	eax, DWORD PTR $T231673[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T231682[ebp], eax
	mov	edx, DWORD PTR $T231682[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T231686[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	ecx, DWORD PTR $T231686[ebp]
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	movzx	eax, al
	test	eax, eax
	je	$LN71@addTeam
	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T231690[ebp], ecx
	mov	edx, DWORD PTR $T231690[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T231699[ebp], eax
	mov	ecx, DWORD PTR $T231699[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T231703[ebp], ecx
	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T231703[ebp]
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	movzx	eax, al
	test	eax, eax
	je	$LN71@addTeam

; 430  : 				{
; 431  : 					if(iI == GC.getGame().getActivePlayer())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T231707[ebp], ecx
	mov	ecx, DWORD PTR $T231707[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	DWORD PTR _iI$[ebp], eax
	jne	$LN71@addTeam

; 432  : 					{
; 433  : 						strBuffer = GetLocalizedText("TXT_KEY_MISC_PLAYER_PERMANENT_ALLIANCE", getName().GetCString(), GET_TEAM(eTeam).getName().GetCString());

	mov	edx, DWORD PTR _eTeam$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T231711[ebp], edx
	lea	eax, DWORD PTR $T231612[ebp]
	push	eax
	mov	ecx, DWORD PTR $T231711[ebp]
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	DWORD PTR tv620[ebp], eax
	mov	ecx, DWORD PTR tv620[ebp]
	mov	DWORD PTR $T231715[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR $T231715[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T231611[ebp], eax
	lea	edx, DWORD PTR $T231614[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	DWORD PTR tv66[ebp], eax
	mov	eax, DWORD PTR tv66[ebp]
	mov	DWORD PTR $T231719[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR $T231719[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T231613[ebp], eax
	lea	ecx, DWORD PTR $T231611[ebp]
	push	ecx
	lea	edx, DWORD PTR $T231613[ebp]
	push	edx
	push	OFFSET ??_C@_0CH@BFNGIGJO@TXT_KEY_MISC_PLAYER_PERMANENT_AL@
	lea	eax, DWORD PTR $T231615[ebp]
	push	eax
	call	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv829[ebp], eax
	mov	ecx, DWORD PTR tv829[ebp]
	mov	DWORD PTR $T231723[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	edx, DWORD PTR $T231723[ebp]
	push	edx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T231615[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T231614[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T231612[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 434  : 						DLLUI->AddMessage(0, ((PlayerTypes)iI), false, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, "AS2D_THEIRALLIANCE", MESSAGE_TYPE_MINOR_EVENT, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_HIGHLIGHT_TEXT")*/);

	mov	eax, DWORD PTR $T231739[ebp]
	mov	DWORD PTR tv200[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv200[ebp], ecx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T231743[ebp], eax
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	mov	DWORD PTR $T231747[ebp], edx
	push	0
	push	0
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR $T231743[ebp]
	push	eax
	mov	ecx, DWORD PTR $T231747[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR tv200[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv200[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN71@addTeam:

; 435  : 					}
; 436  : 				}
; 437  : 			}
; 438  : 		}
; 439  : 	}

	jmp	$LN73@addTeam
$LN72@addTeam:

; 440  : 
; 441  : 	strBuffer = GetLocalizedText("TXT_KEY_MISC_PLAYER_PERMANENT_ALLIANCE", getName().GetCString(), GET_TEAM(eTeam).getName().GetCString());

	mov	ecx, DWORD PTR _eTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T231751[ebp], ecx
	lea	edx, DWORD PTR $T231617[ebp]
	push	edx
	mov	ecx, DWORD PTR $T231751[ebp]
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	DWORD PTR tv830[ebp], eax
	mov	eax, DWORD PTR tv830[ebp]
	mov	DWORD PTR $T231755[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR $T231755[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T231616[ebp], eax
	lea	ecx, DWORD PTR $T231619[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	DWORD PTR tv831[ebp], eax
	mov	edx, DWORD PTR tv831[ebp]
	mov	DWORD PTR $T231759[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR $T231759[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T231618[ebp], eax
	lea	eax, DWORD PTR $T231616[ebp]
	push	eax
	lea	ecx, DWORD PTR $T231618[ebp]
	push	ecx
	push	OFFSET ??_C@_0CH@BFNGIGJO@TXT_KEY_MISC_PLAYER_PERMANENT_AL@
	lea	edx, DWORD PTR $T231620[ebp]
	push	edx
	call	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv864[ebp], eax
	mov	eax, DWORD PTR tv864[ebp]
	mov	DWORD PTR $T231763[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR $T231763[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T231620[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T231619[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T231617[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 442  : 	GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, getLeaderID(), strBuffer, -1, -1);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T231779[ebp], edx
	push	-1
	push	-1
	lea	eax, DWORD PTR _strBuffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	push	eax
	push	0
	mov	ecx, DWORD PTR $T231779[ebp]
	call	?addReplayMessage@CvGame@@QAEXW4ReplayMessageTypes@@W4PlayerTypes@@ABVCvString@@HH@Z ; CvGame::addReplayMessage

; 443  : 
; 444  : 	// To be replaced with new diplomatic code
; 445  : 
; 446  : 	shareItems(eTeam);

	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?shareItems@CvTeam@@QAEXW4TeamTypes@@@Z	; CvTeam::shareItems

; 447  : 	GET_TEAM(eTeam).shareItems(GetID());

	mov	edx, DWORD PTR _eTeam$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T231783[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	ecx, DWORD PTR $T231783[ebp]
	call	?shareItems@CvTeam@@QAEXW4TeamTypes@@@Z	; CvTeam::shareItems

; 448  : 
; 449  : 	for(iI = 0; iI < MAX_TEAMS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN67@addTeam
$LN66@addTeam:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN67@addTeam:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	$LN65@addTeam

; 450  : 	{
; 451  : 		if((iI != GetID()) && (iI != eTeam))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR _iI$[ebp], eax
	je	$LN64@addTeam
	mov	ecx, DWORD PTR _iI$[ebp]
	cmp	ecx, DWORD PTR _eTeam$[ebp]
	je	$LN64@addTeam

; 452  : 		{
; 453  : 			if(GET_TEAM((TeamTypes)iI).isAlive())

	mov	edx, DWORD PTR _iI$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T231787[ebp], edx
	mov	eax, DWORD PTR $T231787[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+12], 0
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN64@addTeam

; 454  : 			{
; 455  : 				if(GET_TEAM(eTeam).isHasMet((TeamTypes)iI))

	mov	eax, DWORD PTR _eTeam$[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T231794[ebp], eax
	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T231794[ebp]
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN62@addTeam

; 456  : 				{
; 457  : 					meet(((TeamTypes)iI), false);

	push	0
	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?meet@CvTeam@@QAEXW4TeamTypes@@_N@Z	; CvTeam::meet
	jmp	SHORT $LN64@addTeam
$LN62@addTeam:

; 458  : 				}
; 459  : 				else if(isHasMet((TeamTypes)iI))

	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN64@addTeam

; 460  : 				{
; 461  : 					GET_TEAM(eTeam).meet((TeamTypes)iI, false);

	push	0
	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?meet@CvTeam@@QAEXW4TeamTypes@@_N@Z	; CvTeam::meet
$LN64@addTeam:

; 462  : 				}
; 463  : 			}
; 464  : 		}
; 465  : 	}

	jmp	$LN66@addTeam
$LN65@addTeam:

; 466  : 
; 467  : 	for(iI = 0; iI < MAX_TEAMS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN59@addTeam
$LN58@addTeam:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN59@addTeam:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	$LN57@addTeam

; 468  : 	{
; 469  : 		if((iI != GetID()) && (iI != eTeam))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR _iI$[ebp], eax
	je	$LN56@addTeam
	mov	edx, DWORD PTR _iI$[ebp]
	cmp	edx, DWORD PTR _eTeam$[ebp]
	je	$LN56@addTeam

; 470  : 		{
; 471  : 			if(GET_TEAM((TeamTypes)iI).isAlive())

	mov	eax, DWORD PTR _iI$[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T231801[ebp], eax
	mov	ecx, DWORD PTR $T231801[ebp]
	xor	edx, edx
	cmp	DWORD PTR [ecx+12], 0
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN56@addTeam

; 472  : 			{
; 473  : 				if(GET_TEAM(eTeam).isAtWar((TeamTypes)iI))

	mov	ecx, DWORD PTR _eTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T231808[ebp], ecx
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T231808[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN54@addTeam

; 474  : 				{
; 475  : 					declareWar(((TeamTypes)iI));

	push	0
	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?declareWar@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::declareWar
	jmp	SHORT $LN56@addTeam
$LN54@addTeam:

; 476  : 				}
; 477  : 				else if(isAtWar((TeamTypes)iI))

	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN56@addTeam

; 478  : 				{
; 479  : 					GET_TEAM(eTeam).declareWar(((TeamTypes)iI));

	push	0
	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _eTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?declareWar@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::declareWar
$LN56@addTeam:

; 480  : 				}
; 481  : 			}
; 482  : 		}
; 483  : 	}

	jmp	$LN58@addTeam
$LN57@addTeam:

; 484  : 
; 485  : 	for(iI = 0; iI < MAX_TEAMS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN51@addTeam
$LN50@addTeam:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN51@addTeam:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	$LN49@addTeam

; 486  : 	{
; 487  : 		if((iI != GetID()) && (iI != eTeam))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR _iI$[ebp], eax
	je	$LN48@addTeam
	mov	eax, DWORD PTR _iI$[ebp]
	cmp	eax, DWORD PTR _eTeam$[ebp]
	je	$LN48@addTeam

; 488  : 		{
; 489  : 			if(GET_TEAM((TeamTypes)iI).isAlive())

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T231815[ebp], ecx
	mov	edx, DWORD PTR $T231815[ebp]
	xor	eax, eax
	cmp	DWORD PTR [edx+12], 0
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN48@addTeam

; 490  : 			{
; 491  : 				if(GET_TEAM(eTeam).isPermanentWarPeace((TeamTypes)iI))

	mov	edx, DWORD PTR _eTeam$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T231822[ebp], edx
	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T231822[ebp]
	call	?isPermanentWarPeace@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::isPermanentWarPeace
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN46@addTeam

; 492  : 				{
; 493  : 					setPermanentWarPeace(((TeamTypes)iI), true);

	push	1
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setPermanentWarPeace@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::setPermanentWarPeace
	jmp	SHORT $LN48@addTeam
$LN46@addTeam:

; 494  : 				}
; 495  : 				else if(isPermanentWarPeace((TeamTypes)iI))

	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isPermanentWarPeace@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::isPermanentWarPeace
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN48@addTeam

; 496  : 				{
; 497  : 					GET_TEAM(eTeam).setPermanentWarPeace(((TeamTypes)iI), true);

	push	1
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	ecx, DWORD PTR _eTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?setPermanentWarPeace@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::setPermanentWarPeace
$LN48@addTeam:

; 498  : 				}
; 499  : 			}
; 500  : 		}
; 501  : 	}

	jmp	$LN50@addTeam
$LN49@addTeam:

; 502  : 
; 503  : 	for(iI = 0; iI < MAX_TEAMS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN43@addTeam
$LN42@addTeam:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN43@addTeam:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	$LN41@addTeam

; 504  : 	{
; 505  : 		if((iI != GetID()) && (iI != eTeam))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR _iI$[ebp], eax
	je	$LN40@addTeam
	mov	ecx, DWORD PTR _iI$[ebp]
	cmp	ecx, DWORD PTR _eTeam$[ebp]
	je	$LN40@addTeam

; 506  : 		{
; 507  : 			if(GET_TEAM((TeamTypes)iI).isAlive())

	mov	edx, DWORD PTR _iI$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T231829[ebp], edx
	mov	eax, DWORD PTR $T231829[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+12], 0
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN40@addTeam

; 508  : 			{
; 509  : 				if(GET_TEAM(eTeam).HasEmbassyAtTeam((TeamTypes)iI))

	mov	eax, DWORD PTR _eTeam$[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T231836[ebp], eax
	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T231836[ebp]
	call	?HasEmbassyAtTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::HasEmbassyAtTeam
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN38@addTeam

; 510  : 				{
; 511  : 					SetHasEmbassyAtTeam(((TeamTypes)iI), true);

	push	1
	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetHasEmbassyAtTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasEmbassyAtTeam
	jmp	SHORT $LN40@addTeam
$LN38@addTeam:

; 512  : 				}
; 513  : 				else if(HasEmbassyAtTeam((TeamTypes)iI))

	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasEmbassyAtTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::HasEmbassyAtTeam
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN40@addTeam

; 514  : 				{
; 515  : 					GET_TEAM(eTeam).SetHasEmbassyAtTeam(((TeamTypes)iI), true);

	push	1
	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?SetHasEmbassyAtTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasEmbassyAtTeam
$LN40@addTeam:

; 516  : 				}
; 517  : 			}
; 518  : 		}
; 519  : 	}

	jmp	$LN42@addTeam
$LN41@addTeam:

; 520  : 
; 521  : 	for(iI = 0; iI < MAX_TEAMS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN35@addTeam
$LN34@addTeam:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN35@addTeam:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	$LN33@addTeam

; 522  : 	{
; 523  : 		if((iI != GetID()) && (iI != eTeam))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR _iI$[ebp], eax
	je	$LN32@addTeam
	mov	edx, DWORD PTR _iI$[ebp]
	cmp	edx, DWORD PTR _eTeam$[ebp]
	je	$LN32@addTeam

; 524  : 		{
; 525  : 			if(GET_TEAM((TeamTypes)iI).isAlive())

	mov	eax, DWORD PTR _iI$[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T231843[ebp], eax
	mov	ecx, DWORD PTR $T231843[ebp]
	xor	edx, edx
	cmp	DWORD PTR [ecx+12], 0
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	$LN32@addTeam

; 526  : 			{
; 527  : 				if(GET_TEAM(eTeam).IsAllowsOpenBordersToTeam((TeamTypes)iI))

	mov	ecx, DWORD PTR _eTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T231850[ebp], ecx
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T231850[ebp]
	call	?IsAllowsOpenBordersToTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsAllowsOpenBordersToTeam
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN30@addTeam

; 528  : 				{
; 529  : 					SetAllowsOpenBordersToTeam(((TeamTypes)iI), true);

	push	1
	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAllowsOpenBordersToTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetAllowsOpenBordersToTeam

; 530  : 					GET_TEAM((TeamTypes)iI).SetAllowsOpenBordersToTeam(GetID(), true);

	mov	edx, DWORD PTR _iI$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T231854[ebp], edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	ecx, DWORD PTR $T231854[ebp]
	call	?SetAllowsOpenBordersToTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetAllowsOpenBordersToTeam
	jmp	SHORT $LN32@addTeam
$LN30@addTeam:

; 531  : 				}
; 532  : 				else if(IsAllowsOpenBordersToTeam((TeamTypes)iI))

	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsAllowsOpenBordersToTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsAllowsOpenBordersToTeam
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN32@addTeam

; 533  : 				{
; 534  : 					GET_TEAM(eTeam).SetAllowsOpenBordersToTeam(((TeamTypes)iI), true);

	push	1
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	ecx, DWORD PTR _eTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?SetAllowsOpenBordersToTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetAllowsOpenBordersToTeam

; 535  : 					GET_TEAM((TeamTypes)iI).SetAllowsOpenBordersToTeam(eTeam, true);

	push	1
	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?SetAllowsOpenBordersToTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetAllowsOpenBordersToTeam
$LN32@addTeam:

; 536  : 				}
; 537  : 			}
; 538  : 		}
; 539  : 	}

	jmp	$LN34@addTeam
$LN33@addTeam:

; 540  : 
; 541  : 	for(iI = 0; iI < MAX_TEAMS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN27@addTeam
$LN26@addTeam:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN27@addTeam:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	$LN25@addTeam

; 542  : 	{
; 543  : 		if((iI != GetID()) && (iI != eTeam))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR _iI$[ebp], eax
	je	$LN24@addTeam
	mov	edx, DWORD PTR _iI$[ebp]
	cmp	edx, DWORD PTR _eTeam$[ebp]
	je	$LN24@addTeam

; 544  : 		{
; 545  : 			if(GET_TEAM((TeamTypes)iI).isAlive())

	mov	eax, DWORD PTR _iI$[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T231864[ebp], eax
	mov	ecx, DWORD PTR $T231864[ebp]
	xor	edx, edx
	cmp	DWORD PTR [ecx+12], 0
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	$LN24@addTeam

; 546  : 			{
; 547  : 				if(GET_TEAM(eTeam).IsHasDefensivePact((TeamTypes)iI))

	mov	ecx, DWORD PTR _eTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T231871[ebp], ecx
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T231871[ebp]
	call	?IsHasDefensivePact@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsHasDefensivePact
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN22@addTeam

; 548  : 				{
; 549  : 					SetHasDefensivePact(((TeamTypes)iI), true);

	push	1
	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasDefensivePact

; 550  : 					GET_TEAM((TeamTypes)iI).SetHasDefensivePact(GetID(), true);

	mov	edx, DWORD PTR _iI$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T231875[ebp], edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	ecx, DWORD PTR $T231875[ebp]
	call	?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasDefensivePact
	jmp	SHORT $LN24@addTeam
$LN22@addTeam:

; 551  : 				}
; 552  : 				else if(IsHasDefensivePact((TeamTypes)iI))

	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHasDefensivePact@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsHasDefensivePact
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN24@addTeam

; 553  : 				{
; 554  : 					GET_TEAM(eTeam).SetHasDefensivePact(((TeamTypes)iI), true);

	push	1
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	ecx, DWORD PTR _eTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasDefensivePact

; 555  : 					GET_TEAM((TeamTypes)iI).SetHasDefensivePact(eTeam, true);

	push	1
	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasDefensivePact
$LN24@addTeam:

; 556  : 				}
; 557  : 			}
; 558  : 		}
; 559  : 	}

	jmp	$LN26@addTeam
$LN25@addTeam:

; 560  : 
; 561  : 	for(iI = 0; iI < MAX_TEAMS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN19@addTeam
$LN18@addTeam:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN19@addTeam:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	$LN17@addTeam

; 562  : 	{
; 563  : 		if((iI != GetID()) && (iI != eTeam))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR _iI$[ebp], eax
	je	$LN16@addTeam
	mov	edx, DWORD PTR _iI$[ebp]
	cmp	edx, DWORD PTR _eTeam$[ebp]
	je	$LN16@addTeam

; 564  : 		{
; 565  : 			if(GET_TEAM((TeamTypes)iI).isAlive())

	mov	eax, DWORD PTR _iI$[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T231885[ebp], eax
	mov	ecx, DWORD PTR $T231885[ebp]
	xor	edx, edx
	cmp	DWORD PTR [ecx+12], 0
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	$LN16@addTeam

; 566  : 			{
; 567  : 				if(GET_TEAM(eTeam).isForcePeace((TeamTypes)iI))

	mov	ecx, DWORD PTR _eTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T231892[ebp], ecx
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T231892[ebp]
	call	?isForcePeace@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::isForcePeace
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN14@addTeam

; 568  : 				{
; 569  : 					setForcePeace(((TeamTypes)iI), true);

	push	1
	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setForcePeace@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::setForcePeace

; 570  : 					GET_TEAM((TeamTypes)iI).setForcePeace(GetID(), true);

	mov	edx, DWORD PTR _iI$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T231896[ebp], edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	ecx, DWORD PTR $T231896[ebp]
	call	?setForcePeace@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::setForcePeace
	jmp	SHORT $LN16@addTeam
$LN14@addTeam:

; 571  : 				}
; 572  : 				else if(isForcePeace((TeamTypes)iI))

	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isForcePeace@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::isForcePeace
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN16@addTeam

; 573  : 				{
; 574  : 					GET_TEAM(eTeam).setForcePeace(((TeamTypes)iI), true);

	push	1
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	ecx, DWORD PTR _eTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?setForcePeace@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::setForcePeace

; 575  : 					GET_TEAM((TeamTypes)iI).setForcePeace(eTeam, true);

	push	1
	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?setForcePeace@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::setForcePeace
$LN16@addTeam:

; 576  : 				}
; 577  : 			}
; 578  : 		}
; 579  : 	}

	jmp	$LN18@addTeam
$LN17@addTeam:

; 580  : 
; 581  : 	shareCounters(eTeam);

	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?shareCounters@CvTeam@@QAEXW4TeamTypes@@@Z ; CvTeam::shareCounters

; 582  : 	GET_TEAM(eTeam).shareCounters(GetID());

	mov	edx, DWORD PTR _eTeam$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T231906[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	ecx, DWORD PTR $T231906[ebp]
	call	?shareCounters@CvTeam@@QAEXW4TeamTypes@@@Z ; CvTeam::shareCounters

; 583  : 
; 584  : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN11@addTeam
$LN10@addTeam:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN11@addTeam:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	SHORT $LN9@addTeam

; 585  : 	{
; 586  : 		if(GET_PLAYER((PlayerTypes)iI).getTeam() == eTeam)

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T231910[ebp], ecx
	mov	edx, DWORD PTR $T231910[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	eax, DWORD PTR _eTeam$[ebp]
	jne	SHORT $LN8@addTeam

; 587  : 		{
; 588  : 			GET_PLAYER((PlayerTypes)iI).setTeam(GetID());

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T231922[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	ecx, DWORD PTR $T231922[ebp]
	call	?setTeam@CvPlayer@@QAEXW4TeamTypes@@@Z	; CvPlayer::setTeam
$LN8@addTeam:

; 589  : 		}
; 590  : 	}

	jmp	SHORT $LN10@addTeam
$LN9@addTeam:

; 591  : 
; 592  : 	const int iNumInvisibleInfos = NUM_INVISIBLE_TYPES;

	mov	DWORD PTR _iNumInvisibleInfos$[ebp], 1

; 593  : #ifdef AUI_WARNING_FIXES
; 594  : 	for (iJ = 0; iJ < GC.getMap().numPlots(); iJ++)
; 595  : 	{
; 596  : 		pLoopPlot = GC.getMap().plotByIndexUnchecked(iJ);
; 597  : #else
; 598  : 	for(iI = 0; iI < GC.getMap().numPlots(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN7@addTeam
$LN6@addTeam:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN7@addTeam:
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T231926[ebp], eax
	mov	ecx, DWORD PTR $T231926[ebp]
	mov	edx, DWORD PTR [ecx+4028]
	mov	DWORD PTR $T231930[ebp], edx
	mov	eax, DWORD PTR _iI$[ebp]
	cmp	eax, DWORD PTR $T231930[ebp]
	jge	$LN5@addTeam

; 599  : 	{
; 600  : 		pLoopPlot = GC.getMap().plotByIndexUnchecked(iI);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T231934[ebp], ecx
	mov	edx, DWORD PTR _iI$[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T231934[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR _pLoopPlot$[ebp], edx

; 601  : #endif
; 602  : 
; 603  : 		pLoopPlot->changeVisibilityCount(GetID(), pLoopPlot->getVisibilityCount(eTeam), NO_INVISIBLE, true, false);

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	mov	edx, DWORD PTR [ecx+156]
	mov	eax, DWORD PTR _eTeam$[ebp]
	movsx	ecx, WORD PTR [edx+eax*2]
	mov	DWORD PTR $T231941[ebp], ecx
	push	0
	push	1
	push	-1
	mov	edx, DWORD PTR $T231941[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?changeVisibilityCount@CvPlot@@QAE?AW4PlotVisibilityChangeResult@@W4TeamTypes@@HW4InvisibleTypes@@_N2@Z ; CvPlot::changeVisibilityCount

; 604  : 
; 605  : #ifdef AUI_WARNING_FIXES
; 606  : 		for (iI = 0; iI < iNumInvisibleInfos; iI++)
; 607  : 		{
; 608  : 			pLoopPlot->changeInvisibleVisibilityCount(GetID(), ((InvisibleTypes)iI), pLoopPlot->getInvisibleVisibilityCount(eTeam, ((InvisibleTypes)iI)));
; 609  : #else
; 610  : 		for(iJ = 0; iJ < iNumInvisibleInfos; iJ++)

	mov	DWORD PTR _iJ$[ebp], 0
	jmp	SHORT $LN4@addTeam
$LN3@addTeam:
	mov	eax, DWORD PTR _iJ$[ebp]
	add	eax, 1
	mov	DWORD PTR _iJ$[ebp], eax
$LN4@addTeam:
	cmp	DWORD PTR _iJ$[ebp], 1
	jge	SHORT $LN2@addTeam

; 611  : 		{
; 612  : 			pLoopPlot->changeInvisibleVisibilityCount(GetID(), ((InvisibleTypes)iJ), pLoopPlot->getInvisibleVisibilityCount(eTeam, ((InvisibleTypes)iJ)));

	mov	ecx, DWORD PTR _iJ$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?getInvisibleVisibilityCount@CvPlot@@QBEHW4TeamTypes@@W4InvisibleTypes@@@Z ; CvPlot::getInvisibleVisibilityCount
	push	eax
	mov	eax, DWORD PTR _iJ$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?changeInvisibleVisibilityCount@CvPlot@@QAEXW4TeamTypes@@W4InvisibleTypes@@H@Z ; CvPlot::changeInvisibleVisibilityCount

; 613  : #endif
; 614  : 		}

	jmp	SHORT $LN3@addTeam
$LN2@addTeam:

; 615  : 
; 616  : 		if(pLoopPlot->isRevealed(eTeam))

	mov	ecx, DWORD PTR _eTeam$[ebp]
	shr	ecx, 5
	mov	DWORD PTR _uiOffset$231950[ebp], ecx
	mov	edx, DWORD PTR _uiOffset$231950[ebp]
	shl	edx, 5
	mov	ecx, DWORD PTR _eTeam$[ebp]
	sub	ecx, edx
	mov	eax, 1
	shl	eax, cl
	mov	ecx, DWORD PTR _uiOffset$231950[ebp]
	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	and	eax, DWORD PTR [edx+ecx*4+8]
	setne	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@addTeam

; 617  : 		{
; 618  : 			pLoopPlot->setRevealed(GetID(), true, false, eTeam);

	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z ; CvPlot::setRevealed
$LN1@addTeam:

; 619  : 		}
; 620  : 	}

	jmp	$LN6@addTeam
$LN5@addTeam:

; 621  : 
; 622  : 	GC.getGame().updateScore(true);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T231955[ebp], eax
	push	1
	mov	ecx, DWORD PTR $T231955[ebp]
	call	?updateScore@CvGame@@QAEX_N@Z		; CvGame::updateScore

; 623  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z$0:
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z$1:
	lea	ecx, DWORD PTR $T231612[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z$2:
	lea	ecx, DWORD PTR $T231614[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z$3:
	lea	ecx, DWORD PTR $T231615[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z$4:
	lea	ecx, DWORD PTR $T231617[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z$5:
	lea	ecx, DWORD PTR $T231619[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z$6:
	lea	ecx, DWORD PTR $T231620[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-472]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z ENDP		; CvTeam::addTeam
PUBLIC	?processBuilding@CvTeam@@QAEXW4BuildingTypes@@H_N@Z ; CvTeam::processBuilding
PUBLIC	?isObsoleteBuilding@CvTeam@@QBE_NW4BuildingTypes@@@Z ; CvTeam::isObsoleteBuilding
PUBLIC	?setForceRevealedResource@CvTeam@@QAEXW4ResourceTypes@@_N@Z ; CvTeam::setForceRevealedResource
PUBLIC	?isForceRevealedResource@CvTeam@@QBE_NW4ResourceTypes@@@Z ; CvTeam::isForceRevealedResource
PUBLIC	?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z ; CvTeam::setHasTech
PUBLIC	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ	; CvTeam::GetTeamTechs
EXTRN	?processBuilding@CvPlayer@@QAEXW4BuildingTypes@@H_NPAVCvArea@@@Z:PROC ; CvPlayer::processBuilding
EXTRN	?area@CvCity@@QBEPAVCvArea@@XZ:PROC		; CvCity::area
EXTRN	?IsTeamShare@CvBuildingEntry@@QBE_NXZ:PROC	; CvBuildingEntry::IsTeamShare
EXTRN	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z:PROC ; CvCityBuildings::GetNumBuilding
EXTRN	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ:PROC ; CvCity::GetCityBuildings
EXTRN	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z:PROC ; CvGlobals::getBuildingInfo
EXTRN	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::nextCity
EXTRN	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::firstCity
EXTRN	?getNumResourceInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumResourceInfos
EXTRN	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z:PROC	; CvTeamTechs::HasTech
EXTRN	?getNumTechInfos@CvGlobals@@QAEHXZ:PROC		; CvGlobals::getNumTechInfos
; Function compile flags: /Odtp
;	COMDAT ?shareItems@CvTeam@@QAEXW4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T232011 = -48						; size = 4
$T232002 = -42						; size = 1
$T231982 = -41						; size = 1
_kOtherPlayer$222691 = -40				; size = 4
_eBuilding$222681 = -36					; size = 4
_pkBuildingInfo$222683 = -32				; size = 4
_kPlayer$222671 = -28					; size = 4
_iJ$ = -24						; size = 4
_kTeam$ = -20						; size = 4
_iK$ = -16						; size = 4
_iI$ = -12						; size = 4
_pLoopCity$ = -8					; size = 4
_iLoop$ = -4						; size = 4
_eTeam$ = 8						; size = 4
?shareItems@CvTeam@@QAEXW4TeamTypes@@@Z PROC		; CvTeam::shareItems, COMDAT
; _this$ = ecx

; 628  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 629  : 	CvCity* pLoopCity;
; 630  : 	int iLoop;
; 631  : #ifdef AUI_WARNING_FIXES
; 632  : 	uint iI, iJ;
; 633  : 	int iK;
; 634  : #else
; 635  : 	int iI, iJ, iK;
; 636  : #endif
; 637  : 
; 638  : 	CvAssert(eTeam != NO_TEAM);
; 639  : 	CvAssert(eTeam != GetID());
; 640  : 
; 641  : 	CvTeam& kTeam = GET_TEAM(eTeam);

	mov	eax, DWORD PTR _eTeam$[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR _kTeam$[ebp], eax

; 642  : 
; 643  : 	for(iI = 0; iI < GC.getNumTechInfos(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN27@shareItems
$LN26@shareItems:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN27@shareItems:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	cmp	DWORD PTR _iI$[ebp], eax
	jge	SHORT $LN25@shareItems

; 644  : 	{
; 645  : 		if(kTeam.GetTeamTechs()->HasTech((TechTypes)iI))

	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	ecx, DWORD PTR _kTeam$[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN24@shareItems

; 646  : 		{
; 647  : 			setHasTech(((TechTypes)iI), true, NO_PLAYER, true, false);

	push	0
	push	1
	push	-1
	push	1
	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z ; CvTeam::setHasTech
$LN24@shareItems:

; 648  : 		}
; 649  : 	}

	jmp	SHORT $LN26@shareItems
$LN25@shareItems:

; 650  : 
; 651  : 	for(iI = 0; iI < GC.getNumResourceInfos(); ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN23@shareItems
$LN22@shareItems:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN23@shareItems:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	DWORD PTR _iI$[ebp], eax
	jge	SHORT $LN21@shareItems

; 652  : 	{
; 653  : 		if(kTeam.isForceRevealedResource((ResourceTypes)iI))

	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kTeam$[ebp]
	call	?isForceRevealedResource@CvTeam@@QBE_NW4ResourceTypes@@@Z ; CvTeam::isForceRevealedResource
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN20@shareItems

; 654  : 		{
; 655  : 			setForceRevealedResource((ResourceTypes)iI, true);

	push	1
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setForceRevealedResource@CvTeam@@QAEXW4ResourceTypes@@_N@Z ; CvTeam::setForceRevealedResource
$LN20@shareItems:

; 656  : 		}
; 657  : 	}

	jmp	SHORT $LN22@shareItems
$LN21@shareItems:

; 658  : 
; 659  : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN19@shareItems
$LN18@shareItems:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN19@shareItems:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	$LN28@shareItems

; 660  : 	{
; 661  : 		CvPlayerAI& kPlayer = GET_PLAYER(static_cast<PlayerTypes>(iI));

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$222671[ebp], ecx

; 662  : 		if(kPlayer.isAlive())

	mov	edx, DWORD PTR _kPlayer$222671[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T231982[ebp], al
	movzx	ecx, BYTE PTR $T231982[ebp]
	test	ecx, ecx
	je	$LN16@shareItems

; 663  : 		{
; 664  : 			if(kPlayer.getTeam() == eTeam)

	mov	edx, DWORD PTR _kPlayer$222671[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	eax, DWORD PTR _eTeam$[ebp]
	jne	$LN16@shareItems

; 665  : 			{
; 666  : 				for(pLoopCity = kPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kPlayer.nextCity(&iLoop))

	push	0
	lea	ecx, DWORD PTR _iLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kPlayer$222671[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
	jmp	SHORT $LN14@shareItems
$LN13@shareItems:
	push	0
	lea	edx, DWORD PTR _iLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR _kPlayer$222671[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
$LN14@shareItems:
	cmp	DWORD PTR _pLoopCity$[ebp], 0
	je	$LN16@shareItems

; 667  : 				{
; 668  : 					for(iJ = 0; iJ < GC.getNumBuildingInfos(); iJ++)

	mov	DWORD PTR _iJ$[ebp], 0
	jmp	SHORT $LN11@shareItems
$LN10@shareItems:
	mov	eax, DWORD PTR _iJ$[ebp]
	add	eax, 1
	mov	DWORD PTR _iJ$[ebp], eax
$LN11@shareItems:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	cmp	DWORD PTR _iJ$[ebp], eax
	jge	$LN9@shareItems

; 669  : 					{
; 670  : 						const BuildingTypes eBuilding = static_cast<BuildingTypes>(iJ);

	mov	ecx, DWORD PTR _iJ$[ebp]
	mov	DWORD PTR _eBuilding$222681[ebp], ecx

; 671  : 						CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);

	mov	edx, DWORD PTR _eBuilding$222681[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	DWORD PTR _pkBuildingInfo$222683[ebp], eax

; 672  : 						if(pkBuildingInfo)

	cmp	DWORD PTR _pkBuildingInfo$222683[ebp], 0
	je	$LN8@shareItems

; 673  : 						{
; 674  : 							if(pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)

	mov	eax, DWORD PTR _eBuilding$222681[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	$LN8@shareItems

; 675  : 							{
; 676  : 								if(!isObsoleteBuilding(eBuilding))

	mov	ecx, DWORD PTR _eBuilding$222681[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isObsoleteBuilding@CvTeam@@QBE_NW4BuildingTypes@@@Z ; CvTeam::isObsoleteBuilding
	movzx	edx, al
	test	edx, edx
	jne	$LN8@shareItems

; 677  : 								{
; 678  : 									if(pkBuildingInfo->IsTeamShare())

	mov	ecx, DWORD PTR _pkBuildingInfo$222683[ebp]
	call	?IsTeamShare@CvBuildingEntry@@QBE_NXZ	; CvBuildingEntry::IsTeamShare
	movzx	eax, al
	test	eax, eax
	je	$LN5@shareItems

; 679  : 									{
; 680  : 										for(iK = 0; iK < MAX_PLAYERS; iK++)

	mov	DWORD PTR _iK$[ebp], 0
	jmp	SHORT $LN4@shareItems
$LN3@shareItems:
	mov	ecx, DWORD PTR _iK$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iK$[ebp], ecx
$LN4@shareItems:
	cmp	DWORD PTR _iK$[ebp], 64			; 00000040H
	jge	SHORT $LN5@shareItems

; 681  : 										{
; 682  : 											CvPlayerAI& kOtherPlayer = GET_PLAYER(static_cast<PlayerTypes>(iK));

	mov	edx, DWORD PTR _iK$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kOtherPlayer$222691[ebp], edx

; 683  : 											if(kOtherPlayer.isAlive() && kOtherPlayer.getTeam() == m_eID)

	mov	eax, DWORD PTR _kOtherPlayer$222691[ebp]
	mov	cl, BYTE PTR [eax+2256]
	mov	BYTE PTR $T232002[ebp], cl
	movzx	edx, BYTE PTR $T232002[ebp]
	test	edx, edx
	je	SHORT $LN1@shareItems
	mov	eax, DWORD PTR _kOtherPlayer$222691[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T232011[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T232011[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN1@shareItems

; 684  : 											{
; 685  : 												kOtherPlayer.processBuilding(eBuilding, pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding), /*bFirst*/ false, pLoopCity->area());

	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?area@CvCity@@QBEPAVCvArea@@XZ		; CvCity::area
	push	eax
	push	0
	mov	ecx, DWORD PTR _eBuilding$222681[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	push	eax
	mov	edx, DWORD PTR _eBuilding$222681[ebp]
	push	edx
	mov	ecx, DWORD PTR _kOtherPlayer$222691[ebp]
	call	?processBuilding@CvPlayer@@QAEXW4BuildingTypes@@H_NPAVCvArea@@@Z ; CvPlayer::processBuilding
$LN1@shareItems:

; 686  : 											}
; 687  : 										}

	jmp	SHORT $LN3@shareItems
$LN5@shareItems:

; 688  : 									}
; 689  : 
; 690  : 									processBuilding(eBuilding, pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding), /*bFirst*/ false);

	push	0
	mov	eax, DWORD PTR _eBuilding$222681[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	push	eax
	mov	ecx, DWORD PTR _eBuilding$222681[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?processBuilding@CvTeam@@QAEXW4BuildingTypes@@H_N@Z ; CvTeam::processBuilding
$LN8@shareItems:

; 691  : 								}
; 692  : 							}
; 693  : 						}
; 694  : 					}

	jmp	$LN10@shareItems
$LN9@shareItems:

; 695  : 				}

	jmp	$LN13@shareItems
$LN16@shareItems:

; 696  : 			}
; 697  : 		}

	jmp	$LN18@shareItems
$LN28@shareItems:

; 698  : 	}
; 699  : 
; 700  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?shareItems@CvTeam@@QAEXW4TeamTypes@@@Z ENDP		; CvTeam::shareItems
_TEXT	ENDS
PUBLIC	?changeBuildingClassCount@CvTeam@@QAEXW4BuildingClassTypes@@H@Z ; CvTeam::changeBuildingClassCount
PUBLIC	?getBuildingClassCount@CvTeam@@QBEHW4BuildingClassTypes@@@Z ; CvTeam::getBuildingClassCount
PUBLIC	?changeUnitClassCount@CvTeam@@QAEXW4UnitClassTypes@@H@Z ; CvTeam::changeUnitClassCount
PUBLIC	?getUnitClassCount@CvTeam@@QBEHW4UnitClassTypes@@@Z ; CvTeam::getUnitClassCount
PUBLIC	?changeProjectMaking@CvTeam@@QAEXW4ProjectTypes@@H@Z ; CvTeam::changeProjectMaking
PUBLIC	?getProjectMaking@CvTeam@@QBEHW4ProjectTypes@@@Z ; CvTeam::getProjectMaking
PUBLIC	?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z ; CvTeam::changeProjectCount
PUBLIC	?getProjectCount@CvTeam@@QBEHW4ProjectTypes@@@Z	; CvTeam::getProjectCount
EXTRN	?SetNoTradeTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z:PROC ; CvTeamTechs::SetNoTradeTech
EXTRN	?IsNoTradeTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z:PROC ; CvTeamTechs::IsNoTradeTech
EXTRN	?SetResearchProgress@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z:PROC ; CvTeamTechs::SetResearchProgress
EXTRN	?GetResearchProgress@CvTeamTechs@@QBEHW4TechTypes@@@Z:PROC ; CvTeamTechs::GetResearchProgress
EXTRN	?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z:PROC ; CvGlobals::getBuildingClassInfo
EXTRN	?getUnitClassInfo@CvGlobals@@QAEPAVCvUnitClassInfo@@W4UnitClassTypes@@@Z:PROC ; CvGlobals::getUnitClassInfo
EXTRN	?incrementProjectCreatedCount@CvGame@@QAEXW4ProjectTypes@@H@Z:PROC ; CvGame::incrementProjectCreatedCount
; Function compile flags: /Odtp
;	COMDAT ?shareCounters@CvTeam@@QAEXW4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T232045 = -48						; size = 4
$T232041 = -44						; size = 4
$T232037 = -40						; size = 4
$T232033 = -36						; size = 4
$T232029 = -32						; size = 4
$T232025 = -28						; size = 4
$T232021 = -24						; size = 4
$T232017 = -20						; size = 4
_pkBuildingClassInfo$222721 = -16			; size = 4
_pkUnitClassInfo$222713 = -12				; size = 4
_iExtraProjects$222702 = -8				; size = 4
_iI$ = -4						; size = 4
_eTeam$ = 8						; size = 4
?shareCounters@CvTeam@@QAEXW4TeamTypes@@@Z PROC		; CvTeam::shareCounters, COMDAT
; _this$ = ecx

; 705  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 706  : #ifdef AUI_WARNING_FIXES
; 707  : 	uint iI;
; 708  : #else
; 709  : 	int iI;
; 710  : #endif
; 711  : 
; 712  : 	for(iI = 0; iI < GC.getNumProjectInfos(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN17@shareCount
$LN16@shareCount:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN17@shareCount:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumProjectInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumProjectInfos
	cmp	DWORD PTR _iI$[ebp], eax
	jge	$LN15@shareCount

; 713  : 	{
; 714  : 		int iExtraProjects = GET_TEAM(eTeam).getProjectCount((ProjectTypes)iI) - getProjectCount((ProjectTypes)iI);

	mov	ecx, DWORD PTR _eTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T232017[ebp], ecx
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T232017[ebp]
	call	?getProjectCount@CvTeam@@QBEHW4ProjectTypes@@@Z ; CvTeam::getProjectCount
	mov	esi, eax
	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getProjectCount@CvTeam@@QBEHW4ProjectTypes@@@Z ; CvTeam::getProjectCount
	sub	esi, eax
	mov	DWORD PTR _iExtraProjects$222702[ebp], esi

; 715  : 		if(iExtraProjects > 0)

	cmp	DWORD PTR _iExtraProjects$222702[ebp], 0
	jle	SHORT $LN14@shareCount

; 716  : 		{
; 717  : 			changeProjectCount((ProjectTypes)iI, iExtraProjects);

	mov	ecx, DWORD PTR _iExtraProjects$222702[ebp]
	push	ecx
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z ; CvTeam::changeProjectCount

; 718  : 			GC.getGame().incrementProjectCreatedCount((ProjectTypes)iI, -iExtraProjects);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232021[ebp], eax
	mov	ecx, DWORD PTR _iExtraProjects$222702[ebp]
	neg	ecx
	push	ecx
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T232021[ebp]
	call	?incrementProjectCreatedCount@CvGame@@QAEXW4ProjectTypes@@H@Z ; CvGame::incrementProjectCreatedCount
$LN14@shareCount:

; 719  : 		}
; 720  : 
; 721  : 		changeProjectMaking(((ProjectTypes)iI), GET_TEAM(eTeam).getProjectMaking((ProjectTypes)iI));

	mov	eax, DWORD PTR _eTeam$[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T232025[ebp], eax
	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T232025[ebp]
	call	?getProjectMaking@CvTeam@@QBEHW4ProjectTypes@@@Z ; CvTeam::getProjectMaking
	push	eax
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeProjectMaking@CvTeam@@QAEXW4ProjectTypes@@H@Z ; CvTeam::changeProjectMaking

; 722  : 	}

	jmp	$LN16@shareCount
$LN15@shareCount:

; 723  : 
; 724  : 	for(iI = 0; iI < GC.getNumUnitClassInfos(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN13@shareCount
$LN12@shareCount:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN13@shareCount:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumUnitClassInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitClassInfos
	cmp	DWORD PTR _iI$[ebp], eax
	jge	SHORT $LN11@shareCount

; 725  : 	{
; 726  : 		CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo((UnitClassTypes)iI);

	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitClassInfo@CvGlobals@@QAEPAVCvUnitClassInfo@@W4UnitClassTypes@@@Z ; CvGlobals::getUnitClassInfo
	mov	DWORD PTR _pkUnitClassInfo$222713[ebp], eax

; 727  : 		if(!pkUnitClassInfo)

	cmp	DWORD PTR _pkUnitClassInfo$222713[ebp], 0
	jne	SHORT $LN10@shareCount

; 728  : 		{
; 729  : 			continue;

	jmp	SHORT $LN12@shareCount
$LN10@shareCount:

; 730  : 		}
; 731  : 
; 732  : 		changeUnitClassCount(((UnitClassTypes)iI), GET_TEAM(eTeam).getUnitClassCount((UnitClassTypes)iI));

	mov	edx, DWORD PTR _eTeam$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T232029[ebp], edx
	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T232029[ebp]
	call	?getUnitClassCount@CvTeam@@QBEHW4UnitClassTypes@@@Z ; CvTeam::getUnitClassCount
	push	eax
	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeUnitClassCount@CvTeam@@QAEXW4UnitClassTypes@@H@Z ; CvTeam::changeUnitClassCount

; 733  : 	}

	jmp	SHORT $LN12@shareCount
$LN11@shareCount:

; 734  : 
; 735  : 	for(iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN9@shareCount
$LN8@shareCount:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN9@shareCount:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	DWORD PTR _iI$[ebp], eax
	jge	SHORT $LN7@shareCount

; 736  : 	{
; 737  : 		CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo((BuildingClassTypes)iI);

	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z ; CvGlobals::getBuildingClassInfo
	mov	DWORD PTR _pkBuildingClassInfo$222721[ebp], eax

; 738  : 		if(!pkBuildingClassInfo)

	cmp	DWORD PTR _pkBuildingClassInfo$222721[ebp], 0
	jne	SHORT $LN6@shareCount

; 739  : 		{
; 740  : 			continue;

	jmp	SHORT $LN8@shareCount
$LN6@shareCount:

; 741  : 		}
; 742  : 
; 743  : 		changeBuildingClassCount(((BuildingClassTypes)iI), GET_TEAM(eTeam).getBuildingClassCount((BuildingClassTypes)iI));

	mov	ecx, DWORD PTR _eTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T232033[ebp], ecx
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T232033[ebp]
	call	?getBuildingClassCount@CvTeam@@QBEHW4BuildingClassTypes@@@Z ; CvTeam::getBuildingClassCount
	push	eax
	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeBuildingClassCount@CvTeam@@QAEXW4BuildingClassTypes@@H@Z ; CvTeam::changeBuildingClassCount

; 744  : 	}

	jmp	SHORT $LN8@shareCount
$LN7@shareCount:

; 745  : 
; 746  : 	for(iI = 0; iI < GC.getNumTechInfos(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN5@shareCount
$LN4@shareCount:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN5@shareCount:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	cmp	DWORD PTR _iI$[ebp], eax
	jge	$LN18@shareCount

; 747  : 	{
; 748  : 		if(GET_TEAM(eTeam).GetTeamTechs()->GetResearchProgress((TechTypes)iI) > GetTeamTechs()->GetResearchProgress((TechTypes)iI))

	mov	edx, DWORD PTR _eTeam$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T232037[ebp], edx
	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T232037[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?GetResearchProgress@CvTeamTechs@@QBEHW4TechTypes@@@Z ; CvTeamTechs::GetResearchProgress
	mov	esi, eax
	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?GetResearchProgress@CvTeamTechs@@QBEHW4TechTypes@@@Z ; CvTeamTechs::GetResearchProgress
	cmp	esi, eax
	jle	SHORT $LN2@shareCount

; 749  : 		{
; 750  : 			GetTeamTechs()->SetResearchProgress(((TechTypes)iI), GET_TEAM(eTeam).GetTeamTechs()->GetResearchProgress((TechTypes)iI), getLeaderID());

	mov	edx, DWORD PTR _eTeam$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T232041[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	push	eax
	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T232041[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?GetResearchProgress@CvTeamTechs@@QBEHW4TechTypes@@@Z ; CvTeamTechs::GetResearchProgress
	push	eax
	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?SetResearchProgress@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z ; CvTeamTechs::SetResearchProgress
$LN2@shareCount:

; 751  : 		}
; 752  : 
; 753  : 		if(GET_TEAM(eTeam).GetTeamTechs()->IsNoTradeTech((TechTypes)iI))

	mov	edx, DWORD PTR _eTeam$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T232045[ebp], edx
	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T232045[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?IsNoTradeTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::IsNoTradeTech
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@shareCount

; 754  : 		{
; 755  : 			GetTeamTechs()->SetNoTradeTech((TechTypes)iI, true);

	push	1
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?SetNoTradeTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z ; CvTeamTechs::SetNoTradeTech
$LN1@shareCount:

; 756  : 		}

	jmp	$LN4@shareCount
$LN18@shareCount:

; 757  : 	}
; 758  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?shareCounters@CvTeam@@QAEXW4TeamTypes@@@Z ENDP		; CvTeam::shareCounters
_TEXT	ENDS
PUBLIC	?setMapCentering@CvTeam@@QAEX_N@Z		; CvTeam::setMapCentering
PUBLIC	?changeBorderObstacleCount@CvTeam@@QAEXH@Z	; CvTeam::changeBorderObstacleCount
PUBLIC	?changeTechShareCount@CvTeam@@QAEXHH@Z		; CvTeam::changeTechShareCount
PUBLIC	?changeVictoryPoints@CvTeam@@QAEXH@Z		; CvTeam::changeVictoryPoints
PUBLIC	?SetHomeOfUnitedNations@CvTeam@@QAEX_N@Z	; CvTeam::SetHomeOfUnitedNations
EXTRN	?ChangeBuildingDefenseMod@CvCityBuildings@@QAEXH@Z:PROC ; CvCityBuildings::ChangeBuildingDefenseMod
EXTRN	?GetGlobalDefenseModifier@CvBuildingEntry@@QBEHXZ:PROC ; CvBuildingEntry::GetGlobalDefenseModifier
EXTRN	?IsMapCentering@CvBuildingEntry@@QBE_NXZ:PROC	; CvBuildingEntry::IsMapCentering
EXTRN	?IsBorderObstacle@CvBuildingEntry@@QBE_NXZ:PROC	; CvBuildingEntry::IsBorderObstacle
EXTRN	?GetTechShare@CvBuildingEntry@@QBEHXZ:PROC	; CvBuildingEntry::GetTechShare
EXTRN	?GetVictoryPoints@CvBuildingEntry@@QBEHXZ:PROC	; CvBuildingEntry::GetVictoryPoints
EXTRN	?DoUnitedNationsBuilt@CvGameLeagues@@QAEXW4PlayerTypes@@@Z:PROC ; CvGameLeagues::DoUnitedNationsBuilt
EXTRN	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ:PROC ; CvGame::GetGameLeagues
EXTRN	?IsDiplomaticVoting@CvBuildingEntry@@QBE_NXZ:PROC ; CvBuildingEntry::IsDiplomaticVoting
; Function compile flags: /Odtp
;	COMDAT ?processBuilding@CvTeam@@QAEXW4BuildingTypes@@H_N@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T232072 = -29						; size = 1
$T232063 = -28						; size = 4
$T232051 = -24						; size = 4
_pLoopCity$222758 = -20					; size = 4
_iLoop$222759 = -16					; size = 4
_kPlayer$222755 = -12					; size = 4
_iPlayerLoop$222751 = -8				; size = 4
_pBuildingInfo$ = -4					; size = 4
_eBuilding$ = 8						; size = 4
_iChange$ = 12						; size = 4
_bFirst$ = 16						; size = 1
?processBuilding@CvTeam@@QAEXW4BuildingTypes@@H_N@Z PROC ; CvTeam::processBuilding, COMDAT
; _this$ = ecx

; 763  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 764  : 	CvBuildingEntry* pBuildingInfo = GC.getBuildingInfo(eBuilding);

	mov	eax, DWORD PTR _eBuilding$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	DWORD PTR _pBuildingInfo$[ebp], eax

; 765  : 	if(pBuildingInfo == NULL)

	cmp	DWORD PTR _pBuildingInfo$[ebp], 0
	jne	SHORT $LN14@processBui

; 766  : 		return;

	jmp	$LN15@processBui
$LN14@processBui:

; 767  : 
; 768  : 	// One-shot items
; 769  : 	if(bFirst && iChange > 0)

	movzx	ecx, BYTE PTR _bFirst$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@processBui
	cmp	DWORD PTR _iChange$[ebp], 0
	jle	SHORT $LN13@processBui

; 770  : 	{
; 771  : 		// Diplo victory
; 772  : 		if(pBuildingInfo->IsDiplomaticVoting())

	mov	ecx, DWORD PTR _pBuildingInfo$[ebp]
	call	?IsDiplomaticVoting@CvBuildingEntry@@QBE_NXZ ; CvBuildingEntry::IsDiplomaticVoting
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN13@processBui

; 773  : 		{
; 774  : 			SetHomeOfUnitedNations(true);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetHomeOfUnitedNations@CvTeam@@QAEX_N@Z ; CvTeam::SetHomeOfUnitedNations

; 775  : 			GC.getGame().GetGameLeagues()->DoUnitedNationsBuilt(getLeaderID());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232051[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	push	eax
	mov	ecx, DWORD PTR $T232051[ebp]
	call	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ ; CvGame::GetGameLeagues
	mov	ecx, eax
	call	?DoUnitedNationsBuilt@CvGameLeagues@@QAEXW4PlayerTypes@@@Z ; CvGameLeagues::DoUnitedNationsBuilt
$LN13@processBui:

; 776  : 		}
; 777  : 	}
; 778  : 
; 779  : 	changeVictoryPoints((pBuildingInfo->GetVictoryPoints()) * iChange);

	mov	ecx, DWORD PTR _pBuildingInfo$[ebp]
	call	?GetVictoryPoints@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetVictoryPoints
	imul	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeVictoryPoints@CvTeam@@QAEXH@Z	; CvTeam::changeVictoryPoints

; 780  : 
; 781  : 	if((pBuildingInfo->GetTechShare() > 0) && (pBuildingInfo->GetTechShare() <= MAX_TEAMS))

	mov	ecx, DWORD PTR _pBuildingInfo$[ebp]
	call	?GetTechShare@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetTechShare
	test	eax, eax
	jle	SHORT $LN11@processBui
	mov	ecx, DWORD PTR _pBuildingInfo$[ebp]
	call	?GetTechShare@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetTechShare
	cmp	eax, 64					; 00000040H
	jg	SHORT $LN11@processBui

; 782  : 	{
; 783  : 		changeTechShareCount((pBuildingInfo->GetTechShare() - 1), iChange);

	mov	ecx, DWORD PTR _iChange$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pBuildingInfo$[ebp]
	call	?GetTechShare@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetTechShare
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeTechShareCount@CvTeam@@QAEXHH@Z	; CvTeam::changeTechShareCount
$LN11@processBui:

; 784  : 	}
; 785  : 
; 786  : 	if(pBuildingInfo->IsBorderObstacle())

	mov	ecx, DWORD PTR _pBuildingInfo$[ebp]
	call	?IsBorderObstacle@CvBuildingEntry@@QBE_NXZ ; CvBuildingEntry::IsBorderObstacle
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN10@processBui

; 787  : 	{
; 788  : 		changeBorderObstacleCount(pBuildingInfo->IsBorderObstacle() * iChange);

	mov	ecx, DWORD PTR _pBuildingInfo$[ebp]
	call	?IsBorderObstacle@CvBuildingEntry@@QBE_NXZ ; CvBuildingEntry::IsBorderObstacle
	movzx	eax, al
	imul	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeBorderObstacleCount@CvTeam@@QAEXH@Z ; CvTeam::changeBorderObstacleCount
$LN10@processBui:

; 789  : 	}
; 790  : 
; 791  : 	if(pBuildingInfo->IsMapCentering())

	mov	ecx, DWORD PTR _pBuildingInfo$[ebp]
	call	?IsMapCentering@CvBuildingEntry@@QBE_NXZ ; CvBuildingEntry::IsMapCentering
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN9@processBui

; 792  : 	{
; 793  : 		if(iChange > 0)

	cmp	DWORD PTR _iChange$[ebp], 0
	jle	SHORT $LN9@processBui

; 794  : 		{
; 795  : 			setMapCentering(true);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setMapCentering@CvTeam@@QAEX_N@Z	; CvTeam::setMapCentering
$LN9@processBui:

; 796  : 		}
; 797  : 	}
; 798  : 
; 799  : 	// Effects in every City on this Team
; 800  : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)

	mov	DWORD PTR _iPlayerLoop$222751[ebp], 0
	jmp	SHORT $LN7@processBui
$LN6@processBui:
	mov	edx, DWORD PTR _iPlayerLoop$222751[ebp]
	add	edx, 1
	mov	DWORD PTR _iPlayerLoop$222751[ebp], edx
$LN7@processBui:
	cmp	DWORD PTR _iPlayerLoop$222751[ebp], 63	; 0000003fH
	jge	$LN15@processBui

; 801  : 	{
; 802  : 		CvPlayerAI& kPlayer = GET_PLAYER((PlayerTypes) iPlayerLoop);

	mov	eax, DWORD PTR _iPlayerLoop$222751[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$222755[ebp], eax

; 803  : 		if(kPlayer.getTeam() == m_eID && kPlayer.isAlive())

	mov	ecx, DWORD PTR _kPlayer$222755[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T232063[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T232063[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN4@processBui
	mov	edx, DWORD PTR _kPlayer$222755[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T232072[ebp], al
	movzx	ecx, BYTE PTR $T232072[ebp]
	test	ecx, ecx
	je	SHORT $LN4@processBui

; 804  : 		{
; 805  : 			CvCity* pLoopCity;
; 806  : 			int iLoop;
; 807  : 
; 808  : 			for(pLoopCity = kPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kPlayer.nextCity(&iLoop))

	push	0
	lea	edx, DWORD PTR _iLoop$222759[ebp]
	push	edx
	mov	ecx, DWORD PTR _kPlayer$222755[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$222758[ebp], eax
	jmp	SHORT $LN3@processBui
$LN2@processBui:
	push	0
	lea	eax, DWORD PTR _iLoop$222759[ebp]
	push	eax
	mov	ecx, DWORD PTR _kPlayer$222755[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$222758[ebp], eax
$LN3@processBui:
	cmp	DWORD PTR _pLoopCity$222758[ebp], 0
	je	SHORT $LN4@processBui

; 809  : 			{
; 810  : 				pLoopCity->GetCityBuildings()->ChangeBuildingDefenseMod(pBuildingInfo->GetGlobalDefenseModifier() * iChange);

	mov	ecx, DWORD PTR _pBuildingInfo$[ebp]
	call	?GetGlobalDefenseModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGlobalDefenseModifier
	imul	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopCity$222758[ebp]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?ChangeBuildingDefenseMod@CvCityBuildings@@QAEXH@Z ; CvCityBuildings::ChangeBuildingDefenseMod
	jmp	SHORT $LN2@processBui
$LN4@processBui:

; 811  : 			}

	jmp	$LN6@processBui
$LN15@processBui:

; 812  : 		}
; 813  : 	}
; 814  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?processBuilding@CvTeam@@QAEXW4BuildingTypes@@H_N@Z ENDP ; CvTeam::processBuilding
_TEXT	ENDS
PUBLIC	?testCircumnavigated@CvTeam@@IAEXXZ		; CvTeam::testCircumnavigated
PUBLIC	?DoTestSmallAwards@CvTeam@@QAEXXZ		; CvTeam::DoTestSmallAwards
PUBLIC	?DoMinorCivTech@CvTeam@@QAEXXZ			; CvTeam::DoMinorCivTech
PUBLIC	?isMinorCiv@CvTeam@@QBE_NXZ			; CvTeam::isMinorCiv
PUBLIC	?ChangeNumTurnsLockedIntoWar@CvTeam@@QAEXW4TeamTypes@@H@Z ; CvTeam::ChangeNumTurnsLockedIntoWar
PUBLIC	?GetNumTurnsLockedIntoWar@CvTeam@@QBEHW4TeamTypes@@@Z ; CvTeam::GetNumTurnsLockedIntoWar
PUBLIC	?SetNumTurnsAtWar@CvTeam@@QAEXW4TeamTypes@@H@Z	; CvTeam::SetNumTurnsAtWar
PUBLIC	?ChangeNumTurnsAtWar@CvTeam@@QAEXW4TeamTypes@@H@Z ; CvTeam::ChangeNumTurnsAtWar
PUBLIC	?DoBarbarianTech@CvTeam@@QAEXXZ			; CvTeam::DoBarbarianTech
PUBLIC	?isBarbarian@CvTeam@@QBE_NXZ			; CvTeam::isBarbarian
PUBLIC	?doTurn@CvTeam@@QAEXXZ				; CvTeam::doTurn
; Function compile flags: /Odtp
;	COMDAT ?doTurn@CvTeam@@QAEXXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T232078 = -16						; size = 4
_iTeamLoop$222770 = -12					; size = 4
_eTeam$222769 = -8					; size = 4
_iI$ = -4						; size = 4
?doTurn@CvTeam@@QAEXXZ PROC				; CvTeam::doTurn, COMDAT
; _this$ = ecx

; 819  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 820  : #ifdef AUI_WARNING_FIXES
; 821  : 	uint iI;
; 822  : #else
; 823  : 	int iI;
; 824  : #endif
; 825  : 
; 826  : 	CvAssertMsg(isAlive(), "isAlive is expected to be true");
; 827  : 
; 828  : 	// Barbarians get all Techs that 3/4 of alive players get
; 829  : 	if(isBarbarian())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isBarbarian@CvTeam@@QBE_NXZ		; CvTeam::isBarbarian
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN13@doTurn

; 830  : 	{
; 831  : 		DoBarbarianTech();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoBarbarianTech@CvTeam@@QAEXXZ		; CvTeam::DoBarbarianTech

; 832  : 	}
; 833  : 	// NOT barbs
; 834  : 	else

	jmp	$LN12@doTurn
$LN13@doTurn:

; 835  : 	{
; 836  : 		// War counter
; 837  : 		TeamTypes eTeam;
; 838  : 		int iTeamLoop;
; 839  : 		for(iTeamLoop = 0; iTeamLoop < MAX_CIV_TEAMS; iTeamLoop++)

	mov	DWORD PTR _iTeamLoop$222770[ebp], 0
	jmp	SHORT $LN11@doTurn
$LN10@doTurn:
	mov	ecx, DWORD PTR _iTeamLoop$222770[ebp]
	add	ecx, 1
	mov	DWORD PTR _iTeamLoop$222770[ebp], ecx
$LN11@doTurn:
	cmp	DWORD PTR _iTeamLoop$222770[ebp], 63	; 0000003fH
	jge	SHORT $LN12@doTurn

; 840  : 		{
; 841  : 			eTeam = (TeamTypes) iTeamLoop;

	mov	edx, DWORD PTR _iTeamLoop$222770[ebp]
	mov	DWORD PTR _eTeam$222769[ebp], edx

; 842  : 
; 843  : 			if(!GET_TEAM(eTeam).isBarbarian())

	mov	eax, DWORD PTR _eTeam$222769[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T232078[ebp], eax
	mov	ecx, DWORD PTR $T232078[ebp]
	call	?isBarbarian@CvTeam@@QBE_NXZ		; CvTeam::isBarbarian
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN8@doTurn

; 844  : 			{
; 845  : 				if(isAtWar(eTeam))

	mov	edx, DWORD PTR _eTeam$222769[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@doTurn

; 846  : 					ChangeNumTurnsAtWar(eTeam, 1);

	push	1
	mov	ecx, DWORD PTR _eTeam$222769[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChangeNumTurnsAtWar@CvTeam@@QAEXW4TeamTypes@@H@Z ; CvTeam::ChangeNumTurnsAtWar

; 847  : 				else

	jmp	SHORT $LN8@doTurn
$LN7@doTurn:

; 848  : 					SetNumTurnsAtWar(eTeam, 0);

	push	0
	mov	edx, DWORD PTR _eTeam$222769[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetNumTurnsAtWar@CvTeam@@QAEXW4TeamTypes@@H@Z ; CvTeam::SetNumTurnsAtWar
$LN8@doTurn:

; 849  : 			}
; 850  : 
; 851  : 			if(GetNumTurnsLockedIntoWar(eTeam) > 0)

	mov	eax, DWORD PTR _eTeam$222769[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumTurnsLockedIntoWar@CvTeam@@QBEHW4TeamTypes@@@Z ; CvTeam::GetNumTurnsLockedIntoWar
	test	eax, eax
	jle	SHORT $LN5@doTurn

; 852  : 				ChangeNumTurnsLockedIntoWar(eTeam, -1);

	push	-1
	mov	ecx, DWORD PTR _eTeam$222769[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChangeNumTurnsLockedIntoWar@CvTeam@@QAEXW4TeamTypes@@H@Z ; CvTeam::ChangeNumTurnsLockedIntoWar
$LN5@doTurn:

; 853  : 		}

	jmp	$LN10@doTurn
$LN12@doTurn:

; 854  : 	}
; 855  : 
; 856  : 	// City States also get all Techs that 3/4 of alive players get
; 857  : 	if(isMinorCiv())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN4@doTurn

; 858  : 	{
; 859  : 		DoMinorCivTech();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoMinorCivTech@CvTeam@@QAEXXZ		; CvTeam::DoMinorCivTech
$LN4@doTurn:

; 860  : 	}
; 861  : 
; 862  : 	for(iI = 0; iI < GC.getNumTechInfos(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN3@doTurn
$LN2@doTurn:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN3@doTurn:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	cmp	DWORD PTR _iI$[ebp], eax
	jge	SHORT $LN1@doTurn

; 863  : 	{
; 864  : 		GetTeamTechs()->SetNoTradeTech(((TechTypes)iI), false);

	push	0
	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?SetNoTradeTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z ; CvTeamTechs::SetNoTradeTech

; 865  : 	}

	jmp	SHORT $LN2@doTurn
$LN1@doTurn:

; 866  : 
; 867  : 	DoTestSmallAwards();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoTestSmallAwards@CvTeam@@QAEXXZ	; CvTeam::DoTestSmallAwards

; 868  : 
; 869  : 	testCircumnavigated();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?testCircumnavigated@CvTeam@@IAEXXZ	; CvTeam::testCircumnavigated

; 870  : 
; 871  : #ifndef FINAL_RELEASE
; 872  : 	for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
; 873  : 	{
; 874  : 		if(!isAtWar(GET_PLAYER((PlayerTypes) iMinorLoop).getTeam()))
; 875  : 			continue;
; 876  : 
; 877  : 		CvAssertMsg(GET_PLAYER((PlayerTypes) iMinorLoop).GetMinorCivAI()->GetAlly() != getLeaderID(), "Major civ is now at war with a minor it is allied with! This is dumb and bad. Please send Jon this along with your last 5 autosaves and a changelist #.");
; 878  : 	}
; 879  : #endif
; 880  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?doTurn@CvTeam@@QAEXXZ ENDP				; CvTeam::doTurn
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?DoBarbarianTech@CvTeam@@QAEXXZ
_TEXT	SEGMENT
tv79 = -72						; size = 4
_this$ = -68						; size = 4
$T232120 = -64						; size = 4
$T232116 = -60						; size = 4
$T232109 = -56						; size = 4
$T232103 = -52						; size = 4
$T232093 = -48						; size = 4
$T232086 = -44						; size = 4
$T232082 = -40						; size = 4
$T232081 = -36						; size = 4
_iTechLoop$222802 = -32					; size = 4
_iCount$ = -28						; size = 4
_iTeamLoop$ = -24					; size = 4
_iPossibleCount$ = -20					; size = 4
_eTech$ = -16						; size = 4
_iTeamsNeeded$ = -12					; size = 4
_eTeam$ = -8						; size = 4
_iTechPercent$ = -4					; size = 4
?DoBarbarianTech@CvTeam@@QAEXXZ PROC			; CvTeam::DoBarbarianTech, COMDAT
; _this$ = ecx

; 885  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	DWORD PTR _this$[ebp], ecx

; 886  : 	int iCount;
; 887  : 
; 888  : 	TechTypes eTech;
; 889  : 	TeamTypes eTeam;
; 890  : 
; 891  : 	int iPossibleCount = 0;

	mov	DWORD PTR _iPossibleCount$[ebp], 0

; 892  : 
; 893  : 	// See how many majors are still around
; 894  : 	int iTeamLoop;
; 895  : 	for(iTeamLoop = 0; iTeamLoop < MAX_CIV_TEAMS; iTeamLoop++)

	mov	DWORD PTR _iTeamLoop$[ebp], 0
	jmp	SHORT $LN16@DoBarbaria
$LN15@DoBarbaria:
	mov	eax, DWORD PTR _iTeamLoop$[ebp]
	add	eax, 1
	mov	DWORD PTR _iTeamLoop$[ebp], eax
$LN16@DoBarbaria:
	cmp	DWORD PTR _iTeamLoop$[ebp], 63		; 0000003fH
	jge	SHORT $LN14@DoBarbaria

; 896  : 	{
; 897  : 		eTeam = (TeamTypes) iTeamLoop;

	mov	ecx, DWORD PTR _iTeamLoop$[ebp]
	mov	DWORD PTR _eTeam$[ebp], ecx

; 898  : 
; 899  : 		if(GET_TEAM(eTeam).isAlive())

	mov	edx, DWORD PTR _eTeam$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T232086[ebp], edx
	mov	eax, DWORD PTR $T232086[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+12], 0
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN13@DoBarbaria

; 900  : 		{
; 901  : 			if(!GET_TEAM(eTeam).isMinorCiv())

	mov	eax, DWORD PTR _eTeam$[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T232093[ebp], eax
	mov	ecx, DWORD PTR $T232093[ebp]
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN13@DoBarbaria

; 902  : 			{
; 903  : 				iPossibleCount++;

	mov	edx, DWORD PTR _iPossibleCount$[ebp]
	add	edx, 1
	mov	DWORD PTR _iPossibleCount$[ebp], edx
$LN13@DoBarbaria:

; 904  : 			}
; 905  : 		}
; 906  : 	}

	jmp	SHORT $LN15@DoBarbaria
$LN14@DoBarbaria:

; 907  : 
; 908  : 	CvAssertMsg(iPossibleCount > 0, "Zero possible players? Uhhh...");
; 909  : 
; 910  : 	// 75% of majors (rounded down) need the tech for the Barbs to get it
; 911  : 	int iTechPercent = /*75*/ GC.getBARBARIAN_TECH_PERCENT();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7092
	mov	DWORD PTR _iTechPercent$[ebp], eax

; 912  : 	int iTeamsNeeded = max(1, iPossibleCount * iTechPercent / 100);

	mov	eax, DWORD PTR _iPossibleCount$[ebp]
	imul	eax, DWORD PTR _iTechPercent$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR $T232081[ebp], eax
	mov	DWORD PTR $T232082[ebp], 1
	mov	edx, DWORD PTR $T232082[ebp]
	cmp	edx, DWORD PTR $T232081[ebp]
	jge	SHORT $LN29@DoBarbaria
	lea	eax, DWORD PTR $T232081[ebp]
	mov	DWORD PTR tv79[ebp], eax
	jmp	SHORT $LN30@DoBarbaria
$LN29@DoBarbaria:
	lea	ecx, DWORD PTR $T232082[ebp]
	mov	DWORD PTR tv79[ebp], ecx
$LN30@DoBarbaria:
	mov	edx, DWORD PTR tv79[ebp]
	mov	DWORD PTR $T232103[ebp], edx
	mov	eax, DWORD PTR $T232103[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iTeamsNeeded$[ebp], ecx

; 913  : 
; 914  : #ifdef AUI_WARNING_FIXES
; 915  : 	for (uint iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)
; 916  : #else
; 917  : 	for(int iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)

	mov	DWORD PTR _iTechLoop$222802[ebp], 0
	jmp	SHORT $LN11@DoBarbaria
$LN10@DoBarbaria:
	mov	edx, DWORD PTR _iTechLoop$222802[ebp]
	add	edx, 1
	mov	DWORD PTR _iTechLoop$222802[ebp], edx
$LN11@DoBarbaria:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	cmp	DWORD PTR _iTechLoop$222802[ebp], eax
	jge	$LN17@DoBarbaria

; 918  : #endif
; 919  : 	{
; 920  : 		eTech = (TechTypes) iTechLoop;

	mov	eax, DWORD PTR _iTechLoop$222802[ebp]
	mov	DWORD PTR _eTech$[ebp], eax

; 921  : 
; 922  : 		if(!GetTeamTechs()->HasTech(eTech))

	mov	ecx, DWORD PTR _eTech$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	edx, al
	test	edx, edx
	jne	$LN8@DoBarbaria

; 923  : 		{
; 924  : 			iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0

; 925  : 
; 926  : 			for(iTeamLoop = 0; iTeamLoop < MAX_CIV_TEAMS; iTeamLoop++)

	mov	DWORD PTR _iTeamLoop$[ebp], 0
	jmp	SHORT $LN7@DoBarbaria
$LN6@DoBarbaria:
	mov	eax, DWORD PTR _iTeamLoop$[ebp]
	add	eax, 1
	mov	DWORD PTR _iTeamLoop$[ebp], eax
$LN7@DoBarbaria:
	cmp	DWORD PTR _iTeamLoop$[ebp], 63		; 0000003fH
	jge	$LN5@DoBarbaria

; 927  : 			{
; 928  : 				eTeam = (TeamTypes) iTeamLoop;

	mov	ecx, DWORD PTR _iTeamLoop$[ebp]
	mov	DWORD PTR _eTeam$[ebp], ecx

; 929  : 
; 930  : 				if(GET_TEAM(eTeam).isAlive())

	mov	edx, DWORD PTR _eTeam$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T232109[ebp], edx
	mov	eax, DWORD PTR $T232109[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+12], 0
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN4@DoBarbaria

; 931  : 				{
; 932  : 					// Only look at Majors, as the City States will lag behind
; 933  : 					if(!GET_TEAM(eTeam).isMinorCiv())

	mov	eax, DWORD PTR _eTeam$[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T232116[ebp], eax
	mov	ecx, DWORD PTR $T232116[ebp]
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN4@DoBarbaria

; 934  : 					{
; 935  : 						if(GET_TEAM(eTeam).GetTeamTechs()->HasTech(eTech))

	mov	edx, DWORD PTR _eTeam$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T232120[ebp], edx
	mov	eax, DWORD PTR _eTech$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T232120[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@DoBarbaria

; 936  : 						{
; 937  : 							iCount++;

	mov	edx, DWORD PTR _iCount$[ebp]
	add	edx, 1
	mov	DWORD PTR _iCount$[ebp], edx
$LN4@DoBarbaria:

; 938  : 						}
; 939  : 					}
; 940  : 				}
; 941  : 			}

	jmp	$LN6@DoBarbaria
$LN5@DoBarbaria:

; 942  : 
; 943  : 			// Do enough majors have this tech?
; 944  : 			if(iCount >= iTeamsNeeded)

	mov	eax, DWORD PTR _iCount$[ebp]
	cmp	eax, DWORD PTR _iTeamsNeeded$[ebp]
	jl	SHORT $LN8@DoBarbaria

; 945  : 			{
; 946  : 				setHasTech(eTech, true, getLeaderID(), false, false);

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	push	eax
	push	1
	mov	ecx, DWORD PTR _eTech$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z ; CvTeam::setHasTech
$LN8@DoBarbaria:

; 947  : 			}
; 948  : 		}

	jmp	$LN10@DoBarbaria
$LN17@DoBarbaria:

; 949  : 	}
; 950  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DoBarbarianTech@CvTeam@@QAEXXZ ENDP			; CvTeam::DoBarbarianTech
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?DoMinorCivTech@CvTeam@@QAEXXZ
_TEXT	SEGMENT
tv79 = -72						; size = 4
_this$ = -68						; size = 4
$T232162 = -64						; size = 4
$T232158 = -60						; size = 4
$T232151 = -56						; size = 4
$T232145 = -52						; size = 4
$T232135 = -48						; size = 4
$T232128 = -44						; size = 4
$T232124 = -40						; size = 4
$T232123 = -36						; size = 4
_iTechLoop$222834 = -32					; size = 4
_iCount$ = -28						; size = 4
_iTeamLoop$ = -24					; size = 4
_iPossibleCount$ = -20					; size = 4
_eTech$ = -16						; size = 4
_iTeamsNeeded$ = -12					; size = 4
_eTeam$ = -8						; size = 4
_iTechPercent$ = -4					; size = 4
?DoMinorCivTech@CvTeam@@QAEXXZ PROC			; CvTeam::DoMinorCivTech, COMDAT
; _this$ = ecx

; 955  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	DWORD PTR _this$[ebp], ecx

; 956  : 	int iCount;
; 957  : 
; 958  : 	TechTypes eTech;
; 959  : 	TeamTypes eTeam;
; 960  : 
; 961  : 	int iPossibleCount = 0;

	mov	DWORD PTR _iPossibleCount$[ebp], 0

; 962  : 
; 963  : 	// See how many majors are still around
; 964  : 	int iTeamLoop;
; 965  : 	for(iTeamLoop = 0; iTeamLoop < MAX_CIV_TEAMS; iTeamLoop++)

	mov	DWORD PTR _iTeamLoop$[ebp], 0
	jmp	SHORT $LN16@DoMinorCiv
$LN15@DoMinorCiv:
	mov	eax, DWORD PTR _iTeamLoop$[ebp]
	add	eax, 1
	mov	DWORD PTR _iTeamLoop$[ebp], eax
$LN16@DoMinorCiv:
	cmp	DWORD PTR _iTeamLoop$[ebp], 63		; 0000003fH
	jge	SHORT $LN14@DoMinorCiv

; 966  : 	{
; 967  : 		eTeam = (TeamTypes) iTeamLoop;

	mov	ecx, DWORD PTR _iTeamLoop$[ebp]
	mov	DWORD PTR _eTeam$[ebp], ecx

; 968  : 
; 969  : 		if(GET_TEAM(eTeam).isAlive())

	mov	edx, DWORD PTR _eTeam$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T232128[ebp], edx
	mov	eax, DWORD PTR $T232128[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+12], 0
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN13@DoMinorCiv

; 970  : 		{
; 971  : 			if(!GET_TEAM(eTeam).isMinorCiv())

	mov	eax, DWORD PTR _eTeam$[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T232135[ebp], eax
	mov	ecx, DWORD PTR $T232135[ebp]
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN13@DoMinorCiv

; 972  : 			{
; 973  : 				iPossibleCount++;

	mov	edx, DWORD PTR _iPossibleCount$[ebp]
	add	edx, 1
	mov	DWORD PTR _iPossibleCount$[ebp], edx
$LN13@DoMinorCiv:

; 974  : 			}
; 975  : 		}
; 976  : 	}

	jmp	SHORT $LN15@DoMinorCiv
$LN14@DoMinorCiv:

; 977  : 
; 978  : 	CvAssertMsg(iPossibleCount > 0, "Zero possible players? Uhhh...");
; 979  : 
; 980  : 	// 40% of majors (rounded down) need the tech for the Minors to get it
; 981  : 	int iTechPercent = /*40*/ GC.getMINOR_CIV_TECH_PERCENT();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7300
	mov	DWORD PTR _iTechPercent$[ebp], eax

; 982  : 	int iTeamsNeeded = max(1, iPossibleCount * iTechPercent / 100);

	mov	eax, DWORD PTR _iPossibleCount$[ebp]
	imul	eax, DWORD PTR _iTechPercent$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR $T232123[ebp], eax
	mov	DWORD PTR $T232124[ebp], 1
	mov	edx, DWORD PTR $T232124[ebp]
	cmp	edx, DWORD PTR $T232123[ebp]
	jge	SHORT $LN29@DoMinorCiv
	lea	eax, DWORD PTR $T232123[ebp]
	mov	DWORD PTR tv79[ebp], eax
	jmp	SHORT $LN30@DoMinorCiv
$LN29@DoMinorCiv:
	lea	ecx, DWORD PTR $T232124[ebp]
	mov	DWORD PTR tv79[ebp], ecx
$LN30@DoMinorCiv:
	mov	edx, DWORD PTR tv79[ebp]
	mov	DWORD PTR $T232145[ebp], edx
	mov	eax, DWORD PTR $T232145[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iTeamsNeeded$[ebp], ecx

; 983  : 
; 984  : #ifdef AUI_WARNING_FIXES
; 985  : 	for (uint iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)
; 986  : #else
; 987  : 	for(int iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)

	mov	DWORD PTR _iTechLoop$222834[ebp], 0
	jmp	SHORT $LN11@DoMinorCiv
$LN10@DoMinorCiv:
	mov	edx, DWORD PTR _iTechLoop$222834[ebp]
	add	edx, 1
	mov	DWORD PTR _iTechLoop$222834[ebp], edx
$LN11@DoMinorCiv:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	cmp	DWORD PTR _iTechLoop$222834[ebp], eax
	jge	$LN17@DoMinorCiv

; 988  : #endif
; 989  : 	{
; 990  : 		eTech = (TechTypes) iTechLoop;

	mov	eax, DWORD PTR _iTechLoop$222834[ebp]
	mov	DWORD PTR _eTech$[ebp], eax

; 991  : 
; 992  : 		if(!GetTeamTechs()->HasTech(eTech))

	mov	ecx, DWORD PTR _eTech$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	edx, al
	test	edx, edx
	jne	$LN8@DoMinorCiv

; 993  : 		{
; 994  : 			iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0

; 995  : 
; 996  : 			for(iTeamLoop = 0; iTeamLoop < MAX_CIV_TEAMS; iTeamLoop++)

	mov	DWORD PTR _iTeamLoop$[ebp], 0
	jmp	SHORT $LN7@DoMinorCiv
$LN6@DoMinorCiv:
	mov	eax, DWORD PTR _iTeamLoop$[ebp]
	add	eax, 1
	mov	DWORD PTR _iTeamLoop$[ebp], eax
$LN7@DoMinorCiv:
	cmp	DWORD PTR _iTeamLoop$[ebp], 63		; 0000003fH
	jge	$LN5@DoMinorCiv

; 997  : 			{
; 998  : 				eTeam = (TeamTypes) iTeamLoop;

	mov	ecx, DWORD PTR _iTeamLoop$[ebp]
	mov	DWORD PTR _eTeam$[ebp], ecx

; 999  : 
; 1000 : 				if(GET_TEAM(eTeam).isAlive())

	mov	edx, DWORD PTR _eTeam$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T232151[ebp], edx
	mov	eax, DWORD PTR $T232151[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+12], 0
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN4@DoMinorCiv

; 1001 : 				{
; 1002 : 					// Only look at Majors
; 1003 : 					if(!GET_TEAM(eTeam).isMinorCiv())

	mov	eax, DWORD PTR _eTeam$[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T232158[ebp], eax
	mov	ecx, DWORD PTR $T232158[ebp]
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN4@DoMinorCiv

; 1004 : 					{
; 1005 : 						if(GET_TEAM(eTeam).GetTeamTechs()->HasTech(eTech))

	mov	edx, DWORD PTR _eTeam$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T232162[ebp], edx
	mov	eax, DWORD PTR _eTech$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T232162[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@DoMinorCiv

; 1006 : 						{
; 1007 : 							iCount++;

	mov	edx, DWORD PTR _iCount$[ebp]
	add	edx, 1
	mov	DWORD PTR _iCount$[ebp], edx
$LN4@DoMinorCiv:

; 1008 : 						}
; 1009 : 					}
; 1010 : 				}
; 1011 : 			}

	jmp	$LN6@DoMinorCiv
$LN5@DoMinorCiv:

; 1012 : 
; 1013 : 			// Do enough majors have this tech?
; 1014 : 			if(iCount >= iTeamsNeeded)

	mov	eax, DWORD PTR _iCount$[ebp]
	cmp	eax, DWORD PTR _iTeamsNeeded$[ebp]
	jl	SHORT $LN8@DoMinorCiv

; 1015 : 			{
; 1016 : 				setHasTech(eTech, true, getLeaderID(), false, false);

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	push	eax
	push	1
	mov	ecx, DWORD PTR _eTech$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z ; CvTeam::setHasTech
$LN8@DoMinorCiv:

; 1017 : 			}
; 1018 : 		}

	jmp	$LN10@DoMinorCiv
$LN17@DoMinorCiv:

; 1019 : 	}
; 1020 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DoMinorCivTech@CvTeam@@QAEXXZ ENDP			; CvTeam::DoMinorCivTech
_TEXT	ENDS
PUBLIC	?updateYield@CvTeam@@QAEXXZ			; CvTeam::updateYield
EXTRN	?updateYield@CvPlayer@@QAEXXZ:PROC		; CvPlayer::updateYield
; Function compile flags: /Odtp
;	COMDAT ?updateYield@CvTeam@@QAEXXZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T232190 = -20						; size = 4
$T232181 = -16						; size = 4
$T232177 = -9						; size = 1
$T232168 = -8						; size = 4
_iI$ = -4						; size = 4
?updateYield@CvTeam@@QAEXXZ PROC			; CvTeam::updateYield, COMDAT
; _this$ = ecx

; 1024 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1025 : 	int iI;
; 1026 : 
; 1027 : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN5@updateYiel
$LN4@updateYiel:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN5@updateYiel:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	SHORT $LN6@updateYiel

; 1028 : 	{
; 1029 : 		if(GET_PLAYER((PlayerTypes)iI).isAlive())

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232168[ebp], ecx
	mov	edx, DWORD PTR $T232168[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T232177[ebp], al
	movzx	ecx, BYTE PTR $T232177[ebp]
	test	ecx, ecx
	je	SHORT $LN2@updateYiel

; 1030 : 		{
; 1031 : 			if(GET_PLAYER((PlayerTypes)iI).getTeam() == GetID())

	mov	edx, DWORD PTR _iI$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232181[ebp], edx
	mov	eax, DWORD PTR $T232181[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T232190[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T232190[ebp], eax
	jne	SHORT $LN2@updateYiel

; 1032 : 			{
; 1033 : 				GET_PLAYER((PlayerTypes)iI).updateYield();

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?updateYield@CvPlayer@@QAEXXZ		; CvPlayer::updateYield
$LN2@updateYiel:

; 1034 : 			}
; 1035 : 		}

	jmp	SHORT $LN4@updateYiel
$LN6@updateYiel:

; 1036 : 	}
; 1037 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?updateYield@CvTeam@@QAEXXZ ENDP			; CvTeam::updateYield
_TEXT	ENDS
PUBLIC	?canChangeWarPeace@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::canChangeWarPeace
EXTRN	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z:PROC ; CvGame::isOption
; Function compile flags: /Odtp
;	COMDAT ?canChangeWarPeace@CvTeam@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T232211 = -16						; size = 4
$T232207 = -12						; size = 4
$T232203 = -8						; size = 4
$T232199 = -4						; size = 4
_eTeam$ = 8						; size = 4
?canChangeWarPeace@CvTeam@@QBE_NW4TeamTypes@@@Z PROC	; CvTeam::canChangeWarPeace, COMDAT
; _this$ = ecx

; 1041 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 1042 : 	if(eTeam == NO_TEAM) return false;

	cmp	DWORD PTR _eTeam$[ebp], -1
	jne	SHORT $LN7@canChangeW
	xor	al, al
	jmp	$LN8@canChangeW
$LN7@canChangeW:

; 1043 : 
; 1044 : 	if(GC.getGame().isOption(GAMEOPTION_NO_CHANGING_WAR_PEACE))

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232199[ebp], eax
	push	6
	mov	ecx, DWORD PTR $T232199[ebp]
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@canChangeW

; 1045 : 	{
; 1046 : 		return false;

	xor	al, al
	jmp	$LN8@canChangeW
$LN6@canChangeW:

; 1047 : 	}
; 1048 : 
; 1049 : 	if(GC.getGame().isOption(GAMEOPTION_ALWAYS_PEACE))

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232203[ebp], edx
	push	4
	mov	ecx, DWORD PTR $T232203[ebp]
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@canChangeW

; 1050 : 	{
; 1051 : 		return false;

	xor	al, al
	jmp	SHORT $LN8@canChangeW
$LN5@canChangeW:

; 1052 : 	}
; 1053 : 
; 1054 : 	if(GC.getGame().isOption(GAMEOPTION_ALWAYS_WAR))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232207[ebp], ecx
	push	3
	mov	ecx, DWORD PTR $T232207[ebp]
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN4@canChangeW

; 1055 : 	{
; 1056 : 		return false;

	xor	al, al
	jmp	SHORT $LN8@canChangeW
$LN4@canChangeW:

; 1057 : 	}
; 1058 : 
; 1059 : 	if(eTeam == GetID())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR _eTeam$[ebp], eax
	jne	SHORT $LN3@canChangeW

; 1060 : 	{
; 1061 : 		return false;

	xor	al, al
	jmp	SHORT $LN8@canChangeW
$LN3@canChangeW:

; 1062 : 	}
; 1063 : 
; 1064 : 	if(isPermanentWarPeace(eTeam) || GET_TEAM(eTeam).isPermanentWarPeace(GetID()))

	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isPermanentWarPeace@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::isPermanentWarPeace
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@canChangeW
	mov	edx, DWORD PTR _eTeam$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T232211[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	ecx, DWORD PTR $T232211[ebp]
	call	?isPermanentWarPeace@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::isPermanentWarPeace
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@canChangeW
$LN1@canChangeW:

; 1065 : 	{
; 1066 : 		return false;

	xor	al, al
	jmp	SHORT $LN8@canChangeW
$LN2@canChangeW:

; 1067 : 	}
; 1068 : 
; 1069 : 	return true;

	mov	al, 1
$LN8@canChangeW:

; 1070 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?canChangeWarPeace@CvTeam@@QBE_NW4TeamTypes@@@Z ENDP	; CvTeam::canChangeWarPeace
_TEXT	ENDS
PUBLIC	??_C@_0O@IKFANLMN@CanDeclareWar?$AA@		; `string'
PUBLIC	?isHuman@CvTeam@@QBE_NXZ			; CvTeam::isHuman
PUBLIC	??_C@_0BF@FAPEFALO@GAMEOPTION_AI_TWEAKS?$AA@	; `string'
PUBLIC	?canDeclareWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::canDeclareWar
EXTRN	??1CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::~CvLuaArgsHandle
EXTRN	?CallTestAll@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z:PROC ; LuaSupport::CallTestAll
EXTRN	??0CvLuaArgsHandle@@QAE@I@Z:PROC		; CvLuaArgsHandle::CvLuaArgsHandle
EXTRN	?isOption@CvGame@@QBE_NPBD@Z:PROC		; CvGame::isOption
;	COMDAT ??_C@_0O@IKFANLMN@CanDeclareWar?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaargshandle.h
CONST	SEGMENT
??_C@_0O@IKFANLMN@CanDeclareWar?$AA@ DB 'CanDeclareWar', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FAPEFALO@GAMEOPTION_AI_TWEAKS?$AA@
CONST	SEGMENT
??_C@_0BF@FAPEFALO@GAMEOPTION_AI_TWEAKS?$AA@ DB 'GAMEOPTION_AI_TWEAKS', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?canDeclareWar@CvTeam@@QBE_NW4TeamTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?canDeclareWar@CvTeam@@QBE_NW4TeamTypes@@@Z$0
__ehfuncinfo$?canDeclareWar@CvTeam@@QBE_NW4TeamTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?canDeclareWar@CvTeam@@QBE_NW4TeamTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?canDeclareWar@CvTeam@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
tv184 = -64						; size = 4
tv175 = -60						; size = 4
tv163 = -56						; size = 4
_this$ = -52						; size = 4
$T232251 = -48						; size = 4
$T232241 = -44						; size = 4
$T232237 = -40						; size = 4
$T232233 = -36						; size = 4
$T232226 = -32						; size = 4
$T232219 = -28						; size = 4
$T232214 = -22						; size = 1
_bResult$222890 = -21					; size = 1
_args$222889 = -20					; size = 4
_pkScriptSystem$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_eTeam$ = 8						; size = 4
?canDeclareWar@CvTeam@@QBE_NW4TeamTypes@@@Z PROC	; CvTeam::canDeclareWar, COMDAT
; _this$ = ecx

; 1074 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?canDeclareWar@CvTeam@@QBE_NW4TeamTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1075 : 	if(eTeam == GetID())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR _eTeam$[ebp], eax
	jne	SHORT $LN14@canDeclare

; 1076 : 	{
; 1077 : 		return false;

	xor	al, al
	jmp	$LN15@canDeclare
$LN14@canDeclare:

; 1078 : 	}
; 1079 : #ifdef AI_CANT_DECLARE_WAR
; 1080 : 	if(GC.getGame().isOption("GAMEOPTION_AI_TWEAKS"))

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232219[ebp], eax
	push	OFFSET ??_C@_0BF@FAPEFALO@GAMEOPTION_AI_TWEAKS?$AA@
	mov	ecx, DWORD PTR $T232219[ebp]
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN20@canDeclare

; 1081 : 	{
; 1082 : 		if(!isHuman())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isHuman@CvTeam@@QBE_NXZ		; CvTeam::isHuman
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN20@canDeclare

; 1083 : 		{
; 1084 : 			return false;

	xor	al, al
	jmp	$LN15@canDeclare

; 1085 : 		}
; 1086 : 	}
; 1087 : #endif
; 1088 : 
; 1089 : 	if(!(isAlive()) || !(GET_TEAM(eTeam).isAlive()))

$LN20@canDeclare:
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+12], 0
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN10@canDeclare
	mov	eax, DWORD PTR _eTeam$[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T232226[ebp], eax
	mov	ecx, DWORD PTR $T232226[ebp]
	xor	edx, edx
	cmp	DWORD PTR [ecx+12], 0
	setg	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN11@canDeclare
$LN10@canDeclare:

; 1090 : 	{
; 1091 : 		return false;

	xor	al, al
	jmp	$LN15@canDeclare
$LN11@canDeclare:

; 1092 : 	}
; 1093 : 
; 1094 : 	if(isAtWar(eTeam))

	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN9@canDeclare

; 1095 : 	{
; 1096 : 		return false;

	xor	al, al
	jmp	$LN15@canDeclare
$LN9@canDeclare:

; 1097 : 	}
; 1098 : 
; 1099 : 	if(!isHasMet(eTeam))

	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN8@canDeclare

; 1100 : 	{
; 1101 : 		return false;

	xor	al, al
	jmp	$LN15@canDeclare
$LN8@canDeclare:

; 1102 : 	}
; 1103 : 
; 1104 : 	if(isForcePeace(eTeam))

	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isForcePeace@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::isForcePeace
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@canDeclare

; 1105 : 	{
; 1106 : 		return false;

	xor	al, al
	jmp	$LN15@canDeclare
$LN7@canDeclare:

; 1107 : 	}
; 1108 : 
; 1109 : 	if(!canChangeWarPeace(eTeam))

	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?canChangeWarPeace@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::canChangeWarPeace
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN6@canDeclare

; 1110 : 	{
; 1111 : 		return false;

	xor	al, al
	jmp	$LN15@canDeclare
$LN6@canDeclare:

; 1112 : 	}
; 1113 : 
; 1114 : 	if(GC.getGame().isOption(GAMEOPTION_ALWAYS_PEACE))

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232233[ebp], eax
	push	4
	mov	ecx, DWORD PTR $T232233[ebp]
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@canDeclare

; 1115 : 	{
; 1116 : 		return false;

	xor	al, al
	jmp	$LN15@canDeclare
$LN5@canDeclare:

; 1117 : 	}
; 1118 : 
; 1119 : #ifdef NEW_DEFENSIVE_PACT
; 1120 : 	if(GET_TEAM(eTeam).IsHasDefensivePact(GetID()))

	mov	edx, DWORD PTR _eTeam$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T232237[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	ecx, DWORD PTR $T232237[ebp]
	call	?IsHasDefensivePact@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsHasDefensivePact
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@canDeclare

; 1121 : 	{
; 1122 : 		return false;

	xor	al, al
	jmp	$LN15@canDeclare
$LN4@canDeclare:

; 1123 : 	}
; 1124 : #endif
; 1125 : 
; 1126 : 	// First, obtain the Lua script system.
; 1127 : 	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR $T232241[ebp]
	mov	DWORD PTR tv163[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv163[ebp], edx
	mov	eax, DWORD PTR tv163[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv163[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pkScriptSystem$[ebp], eax

; 1128 : 	if(pkScriptSystem)

	cmp	DWORD PTR _pkScriptSystem$[ebp], 0
	je	$LN3@canDeclare

; 1129 : 	{
; 1130 : 		// Construct and push in some event arguments.
; 1131 : 		CvLuaArgsHandle args(2);

	push	2
	lea	ecx, DWORD PTR _args$222889[ebp]
	call	??0CvLuaArgsHandle@@QAE@I@Z		; CvLuaArgsHandle::CvLuaArgsHandle
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1132 : 		args->Push(GetID());

	mov	ecx, DWORD PTR _args$222889[ebp]
	mov	DWORD PTR tv175[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	edx, DWORD PTR tv175[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv175[ebp]
	mov	edx, DWORD PTR [eax+8]
	call	edx

; 1133 : 		args->Push(eTeam);

	mov	eax, DWORD PTR _args$222889[ebp]
	mov	DWORD PTR tv184[ebp], eax
	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv184[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv184[ebp]
	mov	edx, DWORD PTR [eax+8]
	call	edx

; 1134 : 
; 1135 : 		// Attempt to execute the game events.
; 1136 : 		// Will return false if there are no registered listeners.
; 1137 : 		bool bResult = false;

	mov	BYTE PTR _bResult$222890[ebp], 0

; 1138 : 		if(LuaSupport::CallTestAll(pkScriptSystem, "CanDeclareWar", args.get(), bResult))

	mov	eax, DWORD PTR _args$222889[ebp]
	mov	DWORD PTR $T232251[ebp], eax
	lea	ecx, DWORD PTR _bResult$222890[ebp]
	push	ecx
	mov	edx, DWORD PTR $T232251[ebp]
	push	edx
	push	OFFSET ??_C@_0O@IKFANLMN@CanDeclareWar?$AA@
	mov	eax, DWORD PTR _pkScriptSystem$[ebp]
	push	eax
	call	?CallTestAll@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallTestAll
	add	esp, 16					; 00000010H
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@canDeclare

; 1139 : 		{
; 1140 : 			// Check the result.
; 1141 : 			if(bResult == false)

	movzx	edx, BYTE PTR _bResult$222890[ebp]
	test	edx, edx
	jne	SHORT $LN2@canDeclare

; 1142 : 			{
; 1143 : 				return false;

	mov	BYTE PTR $T232214[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _args$222889[ebp]
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
	mov	al, BYTE PTR $T232214[ebp]
	jmp	SHORT $LN15@canDeclare
$LN2@canDeclare:

; 1144 : 			}
; 1145 : 		}
; 1146 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _args$222889[ebp]
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN3@canDeclare:

; 1147 : 
; 1148 : 	return true;

	mov	al, 1
$LN15@canDeclare:

; 1149 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?canDeclareWar@CvTeam@@QBE_NW4TeamTypes@@@Z$0:
	lea	ecx, DWORD PTR _args$222889[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__ehhandler$?canDeclareWar@CvTeam@@QBE_NW4TeamTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?canDeclareWar@CvTeam@@QBE_NW4TeamTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?canDeclareWar@CvTeam@@QBE_NW4TeamTypes@@@Z ENDP	; CvTeam::canDeclareWar
PUBLIC	?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z	; CvTeam::DoDeclareWar
EXTRN	?RefreshDangerPlots@CvPlayerManager@@SAXXZ:PROC	; CvPlayerManager::RefreshDangerPlots
; Function compile flags: /Odtp
;	COMDAT ?declareWar@CvTeam@@QAEXW4TeamTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eTeam$ = 8						; size = 4
_bDefensivePact$ = 12					; size = 1
?declareWar@CvTeam@@QAEXW4TeamTypes@@_N@Z PROC		; CvTeam::declareWar, COMDAT
; _this$ = ecx

; 1153 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 	DoDeclareWar(eTeam, bDefensivePact);

	push	0
	movzx	eax, BYTE PTR _bDefensivePact$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z ; CvTeam::DoDeclareWar

; 1155 : 
; 1156 : 	CvPlayerManager::RefreshDangerPlots();

	call	?RefreshDangerPlots@CvPlayerManager@@SAXXZ ; CvPlayerManager::RefreshDangerPlots

; 1157 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?declareWar@CvTeam@@QAEXW4TeamTypes@@_N@Z ENDP		; CvTeam::declareWar
_TEXT	ENDS
PUBLIC	?ChangeNumMinorCivsAttacked@CvTeam@@QAEXH@Z	; CvTeam::ChangeNumMinorCivsAttacked
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0CC@LCPDBBFO@TXT_KEY_MISC_SOMEONE_DECLARES_WA@ ; `string'
PUBLIC	??_C@_0CC@KMCACDHN@TXT_KEY_MISC_SOMEONE_DECLARED_WA@ ; `string'
PUBLIC	??_C@_0CB@IPLANLDM@TXT_KEY_MISC_DECLARED_WAR_ON_YOU@ ; `string'
PUBLIC	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
PUBLIC	??_C@_0CB@FEDIKDJG@TXT_KEY_MISC_YOU_DECLARED_WAR_ON@ ; `string'
PUBLIC	?SetHasBrokenPeaceTreaty@CvTeam@@QAEX_N@Z	; CvTeam::SetHasBrokenPeaceTreaty
PUBLIC	?GetTurnMadePeaceTreatyWithTeam@CvTeam@@QBEHW4TeamTypes@@@Z ; CvTeam::GetTurnMadePeaceTreatyWithTeam
PUBLIC	?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z ; CvTeam::DoNowAtWarOrPeace
PUBLIC	??_C@_0L@BPLCHNAB@DeclareWar?$AA@		; `string'
PUBLIC	?setAtWar@CvTeam@@QAEXW4TeamTypes@@_N@Z		; CvTeam::setAtWar
PUBLIC	?EvacuateDiplomatsAtTeam@CvTeam@@QAEXW4TeamTypes@@@Z ; CvTeam::EvacuateDiplomatsAtTeam
PUBLIC	?CancelResearchAgreement@CvTeam@@QAEXW4TeamTypes@@@Z ; CvTeam::CancelResearchAgreement
PUBLIC	?CloseEmbassyAtTeam@CvTeam@@QAEXW4TeamTypes@@@Z	; CvTeam::CloseEmbassyAtTeam
EXTRN	?DoTeamDeclaredWarOnMe@CvMinorCivAI@@QAEXW4TeamTypes@@@Z:PROC ; CvMinorCivAI::DoTeamDeclaredWarOnMe
EXTRN	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ:PROC ; CvPlayer::GetMinorCivAI
EXTRN	?ChangeOtherPlayerNumMajorsAttacked@CvDiplomacyAI@@QAEXW4PlayerTypes@@HW4TeamTypes@@@Z:PROC ; CvDiplomacyAI::ChangeOtherPlayerNumMajorsAttacked
EXTRN	?ChangeOtherPlayerNumMinorsAttacked@CvDiplomacyAI@@QAEXW4PlayerTypes@@H@Z:PROC ; CvDiplomacyAI::ChangeOtherPlayerNumMinorsAttacked
EXTRN	?DoPlayerDeclaredWarOnSomeone@CvDiplomacyAI@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z:PROC ; CvDiplomacyAI::DoPlayerDeclaredWarOnSomeone
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z:PROC ; CvNotifications::Add
EXTRN	__imp_?toUTF8@String@Localization@@QAEPBDXZ:PROC
EXTRN	__imp_??4String@Localization@@QAEAAV01@ABV01@@Z:PROC
EXTRN	__imp_?Lookup@Localization@@YA?AVString@1@PBD@Z:PROC
EXTRN	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ:PROC ; CvPlayer::GetNotifications
EXTRN	?isFinalInitialized@CvGame@@QBE_NXZ:PROC	; CvGame::isFinalInitialized
EXTRN	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ:PROC ; CvGame::getActiveTeam
EXTRN	?getElapsedGameTurns@CvGame@@QBEHXZ:PROC	; CvGame::getElapsedGameTurns
EXTRN	?DoSomeoneDeclaredWarOnMe@CvDiplomacyAI@@QAEXW4TeamTypes@@@Z:PROC ; CvDiplomacyAI::DoSomeoneDeclaredWarOnMe
EXTRN	?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z:PROC ; LuaSupport::CallHook
EXTRN	??0CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::CvLuaArgsHandle
EXTRN	?verifyUnitValidPlot@CvMap@@QAEXXZ:PROC		; CvMap::verifyUnitValidPlot
EXTRN	?DoCancelDealsBetweenTeams@CvGameDeals@@QAEXW4TeamTypes@@0@Z:PROC ; CvGameDeals::DoCancelDealsBetweenTeams
EXTRN	?GetGameDeals@CvGame@@QAEPAVCvGameDeals@@XZ:PROC ; CvGame::GetGameDeals
EXTRN	?ChangeNumCitiesLiberated@CvDiplomacyAI@@QAEXW4PlayerTypes@@H@Z:PROC ; CvDiplomacyAI::ChangeNumCitiesLiberated
EXTRN	?GetNumCitiesLiberated@CvDiplomacyAI@@QAEHW4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetNumCitiesLiberated
EXTRN	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ:PROC ; CvPlayer::GetDiplomacyAI
EXTRN	?InvalidateTradeBetweenTeams@CvGameTrade@@QAEXW4TeamTypes@@0@Z:PROC ; CvGameTrade::InvalidateTradeBetweenTeams
EXTRN	?CancelTradeBetweenTeams@CvGameTrade@@QAEXW4TeamTypes@@0_N@Z:PROC ; CvGameTrade::CancelTradeBetweenTeams
EXTRN	?DoAutoWarPlundering@CvGameTrade@@QAEXW4TeamTypes@@0@Z:PROC ; CvGameTrade::DoAutoWarPlundering
EXTRN	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ:PROC ; CvGame::GetGameTrade
EXTRN	__imp_??1String@Localization@@UAE@XZ:PROC
EXTRN	__imp_??0String@Localization@@QAE@XZ:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@LCPDBBFO@TXT_KEY_MISC_SOMEONE_DECLARES_WA@
CONST	SEGMENT
??_C@_0CC@LCPDBBFO@TXT_KEY_MISC_SOMEONE_DECLARES_WA@ DB 'TXT_KEY_MISC_SOM'
	DB	'EONE_DECLARES_WAR', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@KMCACDHN@TXT_KEY_MISC_SOMEONE_DECLARED_WA@
CONST	SEGMENT
??_C@_0CC@KMCACDHN@TXT_KEY_MISC_SOMEONE_DECLARED_WA@ DB 'TXT_KEY_MISC_SOM'
	DB	'EONE_DECLARED_WAR', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@IPLANLDM@TXT_KEY_MISC_DECLARED_WAR_ON_YOU@
CONST	SEGMENT
??_C@_0CB@IPLANLDM@TXT_KEY_MISC_DECLARED_WAR_ON_YOU@ DB 'TXT_KEY_MISC_DEC'
	DB	'LARED_WAR_ON_YOU', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@FEDIKDJG@TXT_KEY_MISC_YOU_DECLARED_WAR_ON@
CONST	SEGMENT
??_C@_0CB@FEDIKDJG@TXT_KEY_MISC_YOU_DECLARED_WAR_ON@ DB 'TXT_KEY_MISC_YOU'
	DB	'_DECLARED_WAR_ON', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BPLCHNAB@DeclareWar?$AA@
CONST	SEGMENT
??_C@_0L@BPLCHNAB@DeclareWar?$AA@ DB 'DeclareWar', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z DD 019930522H
	DD	0dH
	DD	FLAT:__unwindtable$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$5
	DD	00H
	DD	FLAT:__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$6
	DD	00H
	DD	FLAT:__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$8
	DD	00H
	DD	FLAT:__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$9
	DD	00H
	DD	FLAT:__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$10
	DD	0aH
	DD	FLAT:__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$11
	DD	00H
	DD	FLAT:__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$12
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z
_TEXT	SEGMENT
tv1005 = -1064						; size = 4
tv1054 = -1060						; size = 4
tv1053 = -1056						; size = 4
tv848 = -1052						; size = 4
tv1052 = -1048						; size = 4
tv1051 = -1044						; size = 4
tv1050 = -1040						; size = 4
tv842 = -1036						; size = 4
tv1049 = -1032						; size = 4
tv822 = -1028						; size = 4
tv838 = -1024						; size = 4
tv1003 = -1020						; size = 4
tv469 = -1016						; size = 4
tv65 = -1012						; size = 4
tv834 = -1008						; size = 4
tv263 = -1004						; size = 4
tv384 = -1000						; size = 4
tv372 = -996						; size = 4
tv277 = -992						; size = 4
tv268 = -988						; size = 4
tv257 = -984						; size = 4
_this$ = -980						; size = 4
$T232716 = -976						; size = 4
$T232712 = -969						; size = 1
$T232703 = -968						; size = 4
$T232691 = -964						; size = 4
$T232687 = -960						; size = 4
$T232683 = -956						; size = 4
$T232679 = -952						; size = 4
$T232675 = -948						; size = 4
$T232671 = -944						; size = 4
$T232667 = -940						; size = 4
$T232658 = -936						; size = 4
$T232654 = -932						; size = 4
$T232645 = -928						; size = 4
$T232641 = -921						; size = 1
$T232632 = -920						; size = 4
$T232628 = -916						; size = 4
$T232619 = -912						; size = 4
$T232611 = -908						; size = 4
$T232607 = -904						; size = 4
$T232590 = -900						; size = 4
$T232586 = -896						; size = 4
$T232582 = -892						; size = 4
$T232578 = -888						; size = 4
$T232566 = -884						; size = 4
$T232562 = -880						; size = 4
$T232558 = -876						; size = 4
$T232554 = -872						; size = 4
$T232550 = -868						; size = 4
$T232541 = -864						; size = 4
$T232537 = -860						; size = 4
$T232533 = -856						; size = 4
$T232524 = -852						; size = 4
$T232520 = -848						; size = 4
$T232512 = -844						; size = 4
$T232500 = -840						; size = 4
$T232496 = -836						; size = 4
$T232492 = -832						; size = 4
$T232484 = -828						; size = 4
$T232480 = -824						; size = 4
$T232476 = -820						; size = 4
$T232472 = -816						; size = 4
$T232463 = -812						; size = 4
$T232459 = -808						; size = 4
$T232455 = -801						; size = 1
$T232446 = -800						; size = 4
$T232442 = -796						; size = 4
$T232438 = -792						; size = 4
$T232434 = -788						; size = 4
$T232430 = -784						; size = 4
$T232426 = -780						; size = 4
$T232422 = -776						; size = 4
$T232418 = -772						; size = 4
$T232414 = -768						; size = 4
$T232410 = -764						; size = 4
$T232398 = -757						; size = 1
$T232386 = -756						; size = 4
$T232373 = -752						; size = 4
$T232369 = -748						; size = 4
$T232365 = -744						; size = 4
$T232352 = -740						; size = 4
$T232340 = -733						; size = 1
$T232328 = -732						; size = 4
$T232319 = -725						; size = 1
$T232307 = -724						; size = 4
$T232303 = -720						; size = 4
$T232299 = -716						; size = 4
$T232295 = -712						; size = 4
$T232278 = -708						; size = 28
$T232277 = -680						; size = 28
$T232276 = -652						; size = 4
$T232275 = -648						; size = 28
$T232274 = -620						; size = 4
$T232273 = -616						; size = 80
$T232272 = -536						; size = 28
$T232271 = -508						; size = 4
$T232270 = -504						; size = 28
$T232269 = -476						; size = 4
$T232268 = -472						; size = 80
$T232267 = -392						; size = 28
$T232266 = -364						; size = 4
$T232265 = -360						; size = 80
$T232264 = -280						; size = 28
$T232263 = -252						; size = 4
$T232262 = -248						; size = 80
_iMajorCivLoop2$222994 = -168				; size = 4
_ePlayer$222951 = -164					; size = 4
_iTurnsSincePeace$222945 = -160				; size = 4
_iPeaceTreatyTurn$222943 = -156				; size = 4
_kPlayer$222939 = -152					; size = 4
_bResult$222933 = -145					; size = 1
_args$222932 = -144					; size = 4
_iNumCitiesLiberated$222928 = -140			; size = 4
_eDefendingPlayer$222924 = -136				; size = 4
_kDefendingPlayer$222926 = -132				; size = 4
_iDefendingPlayer$222920 = -128				; size = 4
_kAttackingPlayer$222918 = -124				; size = 4
_eAttackingPlayer$222916 = -120				; size = 4
_iAttackingPlayer$222912 = -116				; size = 4
_iMinorCivLoop$ = -112					; size = 4
_locString$ = -108					; size = 80
_iI$ = -24						; size = 4
_pkScriptSystem$ = -20					; size = 4
_iMajorCivLoop$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_eTeam$ = 8						; size = 4
_bDefensivePact$ = 12					; size = 1
_bMinorAllyPact$ = 16					; size = 1
?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z PROC	; CvTeam::DoDeclareWar, COMDAT
; _this$ = ecx

; 1161 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1052				; 0000041cH
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1162 : 	Localization::String locString;

	lea	ecx, DWORD PTR _locString$[ebp]
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1163 : 	int iI;
; 1164 : 
; 1165 : 	CvAssertMsg(eTeam != NO_TEAM, "eTeam is not assigned a valid value");
; 1166 : 	CvAssertMsg(eTeam != GetID(), "eTeam is not expected to be equal with GetID()");
; 1167 : 
; 1168 : 	if (isAtWar(eTeam))

	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN58@DoDeclareW

; 1169 : 	{
; 1170 : 		return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _locString$[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	jmp	$LN59@DoDeclareW
$LN58@DoDeclareW:

; 1171 : 	}
; 1172 : 
; 1173 : 	CvAssertMsg(eTeam != GetID(), "eTeam is not expected to be equal with GetID()");
; 1174 : 	if (!isBarbarian())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isBarbarian@CvTeam@@QBE_NXZ		; CvTeam::isBarbarian
	movzx	edx, al
	test	edx, edx
	jne	$LN57@DoDeclareW

; 1175 : 	{
; 1176 : 		// Since we declared war, all of OUR Defensive Pacts are nullified
; 1177 : 
; 1178 : 		
; 1179 : #ifndef NEW_DEFENSIVE_PACT //EAP: DP is now a peace treaty
; 1180 : 		cancelDefensivePacts();
; 1181 : #endif
; 1182 : 		GC.getGame().GetGameTrade()->DoAutoWarPlundering(m_eID, eTeam);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232295[ebp], eax
	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR $T232295[ebp]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?DoAutoWarPlundering@CvGameTrade@@QAEXW4TeamTypes@@0@Z ; CvGameTrade::DoAutoWarPlundering

; 1183 : #ifdef NQM_TEAM_TRADE_ROUTES_CANCELLED_NOT_DESTROYED_FOR_WAR_DEFENDER_ON_DOW
; 1184 : 		if (bDefensivePact)

	movzx	ecx, BYTE PTR _bDefensivePact$[ebp]
	test	ecx, ecx
	je	SHORT $LN56@DoDeclareW

; 1185 : 		{
; 1186 : 			GC.getGame().GetGameTrade()->CancelTradeBetweenTeams(m_eID, eTeam, true);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232299[ebp], edx
	push	1
	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR $T232299[ebp]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?CancelTradeBetweenTeams@CvGameTrade@@QAEXW4TeamTypes@@0_N@Z ; CvGameTrade::CancelTradeBetweenTeams

; 1187 : 		}
; 1188 : 		else

	jmp	$LN57@DoDeclareW
$LN56@DoDeclareW:

; 1189 : 		{
; 1190 : 			// Returns units for cancelled trade routes to the defender
; 1191 : 			GC.getGame().GetGameTrade()->InvalidateTradeBetweenTeams(eTeam, m_eID);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232303[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T232303[ebp]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?InvalidateTradeBetweenTeams@CvGameTrade@@QAEXW4TeamTypes@@0@Z ; CvGameTrade::InvalidateTradeBetweenTeams

; 1192 : 			// Destroys attackers' units for cancelled trade routes
; 1193 : 			GC.getGame().GetGameTrade()->CancelTradeBetweenTeams(m_eID, eTeam);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232307[ebp], ecx
	push	0
	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR $T232307[ebp]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?CancelTradeBetweenTeams@CvGameTrade@@QAEXW4TeamTypes@@0_N@Z ; CvGameTrade::CancelTradeBetweenTeams

; 1194 : #else
; 1195 : 		GC.getGame().GetGameTrade()->CancelTradeBetweenTeams(m_eID, eTeam);
; 1196 : 
; 1197 : 		if (!bDefensivePact)
; 1198 : 		{
; 1199 : #endif
; 1200 : 			for (int iAttackingPlayer = 0; iAttackingPlayer < MAX_MAJOR_CIVS; iAttackingPlayer++)

	mov	DWORD PTR _iAttackingPlayer$222912[ebp], 0
	jmp	SHORT $LN54@DoDeclareW
$LN53@DoDeclareW:
	mov	edx, DWORD PTR _iAttackingPlayer$222912[ebp]
	add	edx, 1
	mov	DWORD PTR _iAttackingPlayer$222912[ebp], edx
$LN54@DoDeclareW:
	cmp	DWORD PTR _iAttackingPlayer$222912[ebp], 22 ; 00000016H
	jge	$LN57@DoDeclareW

; 1201 : 			{
; 1202 : 				PlayerTypes eAttackingPlayer = (PlayerTypes)iAttackingPlayer;

	mov	eax, DWORD PTR _iAttackingPlayer$222912[ebp]
	mov	DWORD PTR _eAttackingPlayer$222916[ebp], eax

; 1203 : 				CvPlayerAI& kAttackingPlayer = GET_PLAYER(eAttackingPlayer);

	mov	ecx, DWORD PTR _eAttackingPlayer$222916[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kAttackingPlayer$222918[ebp], ecx

; 1204 : 				if (kAttackingPlayer.isAlive() && kAttackingPlayer.getTeam() == GetID())

	mov	edx, DWORD PTR _kAttackingPlayer$222918[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T232319[ebp], al
	movzx	ecx, BYTE PTR $T232319[ebp]
	test	ecx, ecx
	je	$LN51@DoDeclareW
	mov	edx, DWORD PTR _kAttackingPlayer$222918[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T232328[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T232328[ebp], eax
	jne	$LN51@DoDeclareW

; 1205 : 				{
; 1206 : 					for (int iDefendingPlayer = 0; iDefendingPlayer < MAX_MAJOR_CIVS; iDefendingPlayer++)

	mov	DWORD PTR _iDefendingPlayer$222920[ebp], 0
	jmp	SHORT $LN50@DoDeclareW
$LN49@DoDeclareW:
	mov	ecx, DWORD PTR _iDefendingPlayer$222920[ebp]
	add	ecx, 1
	mov	DWORD PTR _iDefendingPlayer$222920[ebp], ecx
$LN50@DoDeclareW:
	cmp	DWORD PTR _iDefendingPlayer$222920[ebp], 22 ; 00000016H
	jge	$LN51@DoDeclareW

; 1207 : 					{
; 1208 : 						PlayerTypes eDefendingPlayer = (PlayerTypes)iDefendingPlayer;

	mov	edx, DWORD PTR _iDefendingPlayer$222920[ebp]
	mov	DWORD PTR _eDefendingPlayer$222924[ebp], edx

; 1209 : 						CvPlayerAI& kDefendingPlayer = GET_PLAYER(eDefendingPlayer);

	mov	eax, DWORD PTR _eDefendingPlayer$222924[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kDefendingPlayer$222926[ebp], eax

; 1210 : 						if (kDefendingPlayer.isAlive() && kDefendingPlayer.getTeam() == eTeam)

	mov	ecx, DWORD PTR _kDefendingPlayer$222926[ebp]
	mov	dl, BYTE PTR [ecx+2256]
	mov	BYTE PTR $T232340[ebp], dl
	movzx	eax, BYTE PTR $T232340[ebp]
	test	eax, eax
	je	SHORT $LN47@DoDeclareW
	mov	ecx, DWORD PTR _kDefendingPlayer$222926[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	eax, DWORD PTR _eTeam$[ebp]
	jne	SHORT $LN47@DoDeclareW

; 1211 : 						{
; 1212 : 							// Forget any of that liberation crud!
; 1213 : 							int iNumCitiesLiberated = kDefendingPlayer.GetDiplomacyAI()->GetNumCitiesLiberated(eAttackingPlayer);

	mov	eax, DWORD PTR _eAttackingPlayer$222916[ebp]
	push	eax
	mov	ecx, DWORD PTR _kDefendingPlayer$222926[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetNumCitiesLiberated@CvDiplomacyAI@@QAEHW4PlayerTypes@@@Z ; CvDiplomacyAI::GetNumCitiesLiberated
	mov	DWORD PTR _iNumCitiesLiberated$222928[ebp], eax

; 1214 : 							kDefendingPlayer.GetDiplomacyAI()->ChangeNumCitiesLiberated(eAttackingPlayer, -iNumCitiesLiberated);

	mov	ecx, DWORD PTR _iNumCitiesLiberated$222928[ebp]
	neg	ecx
	push	ecx
	mov	edx, DWORD PTR _eAttackingPlayer$222916[ebp]
	push	edx
	mov	ecx, DWORD PTR _kDefendingPlayer$222926[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?ChangeNumCitiesLiberated@CvDiplomacyAI@@QAEXW4PlayerTypes@@H@Z ; CvDiplomacyAI::ChangeNumCitiesLiberated
$LN47@DoDeclareW:

; 1215 : 						}
; 1216 : 					}

	jmp	$LN49@DoDeclareW
$LN51@DoDeclareW:

; 1217 : 				}
; 1218 : 			}

	jmp	$LN53@DoDeclareW
$LN57@DoDeclareW:

; 1219 : 		}
; 1220 : 
; 1221 : #ifndef NEW_DEFENSIVE_PACT // EAP: Defensive Pact is now a peace treaty
; 1222 : 		// Auto War for Defensive Pacts
; 1223 : 		for (iI = 0; iI < MAX_TEAMS; iI++)
; 1224 : 		{
; 1225 : 			if (GET_TEAM((TeamTypes)iI).isAlive())
; 1226 : 			{
; 1227 : 				if (GET_TEAM((TeamTypes)iI).IsHasDefensivePact(eTeam))
; 1228 : 				{
; 1229 : 					GET_TEAM((TeamTypes)iI).DoDeclareWar(GetID(), /*bDefensivePact*/ true);
; 1230 : 				}
; 1231 : 			}
; 1232 : 		}
; 1233 : #endif
; 1234 : 	}
; 1235 : 
; 1236 : 	// Cancel Trade Deals, RAs, diplomats
; 1237 : 	if (!isBarbarian())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isBarbarian@CvTeam@@QBE_NXZ		; CvTeam::isBarbarian
	movzx	eax, al
	test	eax, eax
	jne	$LN46@DoDeclareW

; 1238 : 	{
; 1239 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1240 : 		// Because second team is the "to" team, so cancel all of their deals to this team first
; 1241 : 		GC.getGame().GetGameDeals()->DoCancelDealsBetweenTeams(eTeam, GetID());
; 1242 : #else
; 1243 : 		GC.getGame().GetGameDeals()->DoCancelDealsBetweenTeams(GetID(), eTeam);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232352[ebp], ecx
	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	ecx, DWORD PTR $T232352[ebp]
	call	?GetGameDeals@CvGame@@QAEPAVCvGameDeals@@XZ ; CvGame::GetGameDeals
	mov	ecx, eax
	call	?DoCancelDealsBetweenTeams@CvGameDeals@@QAEXW4TeamTypes@@0@Z ; CvGameDeals::DoCancelDealsBetweenTeams

; 1244 : #endif
; 1245 : 		CloseEmbassyAtTeam(eTeam);

	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CloseEmbassyAtTeam@CvTeam@@QAEXW4TeamTypes@@@Z ; CvTeam::CloseEmbassyAtTeam

; 1246 : 		GET_TEAM(eTeam).CloseEmbassyAtTeam(m_eID);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _eTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?CloseEmbassyAtTeam@CvTeam@@QAEXW4TeamTypes@@@Z ; CvTeam::CloseEmbassyAtTeam

; 1247 : 		CancelResearchAgreement(eTeam);

	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CancelResearchAgreement@CvTeam@@QAEXW4TeamTypes@@@Z ; CvTeam::CancelResearchAgreement

; 1248 : 		GET_TEAM(eTeam).CancelResearchAgreement(m_eID);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _eTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?CancelResearchAgreement@CvTeam@@QAEXW4TeamTypes@@@Z ; CvTeam::CancelResearchAgreement

; 1249 : 		EvacuateDiplomatsAtTeam(eTeam);

	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EvacuateDiplomatsAtTeam@CvTeam@@QAEXW4TeamTypes@@@Z ; CvTeam::EvacuateDiplomatsAtTeam

; 1250 : 		GET_TEAM(eTeam).EvacuateDiplomatsAtTeam(m_eID);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _eTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?EvacuateDiplomatsAtTeam@CvTeam@@QAEXW4TeamTypes@@@Z ; CvTeam::EvacuateDiplomatsAtTeam
$LN46@DoDeclareW:

; 1251 : 	}
; 1252 : 
; 1253 : 	// Bump Units out of places they shouldn't be
; 1254 : 	GC.getMap().verifyUnitValidPlot();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T232365[ebp], eax
	mov	ecx, DWORD PTR $T232365[ebp]
	call	?verifyUnitValidPlot@CvMap@@QAEXXZ	; CvMap::verifyUnitValidPlot

; 1255 : 
; 1256 : 	setAtWar(eTeam, true);

	push	1
	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setAtWar@CvTeam@@QAEXW4TeamTypes@@_N@Z	; CvTeam::setAtWar

; 1257 : 	GET_TEAM(eTeam).setAtWar(GetID(), true);

	mov	edx, DWORD PTR _eTeam$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T232369[ebp], edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	ecx, DWORD PTR $T232369[ebp]
	call	?setAtWar@CvTeam@@QAEXW4TeamTypes@@_N@Z	; CvTeam::setAtWar

; 1258 : 
; 1259 : 	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	eax, DWORD PTR $T232373[ebp]
	mov	DWORD PTR tv257[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv257[ebp], ecx
	mov	edx, DWORD PTR tv257[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv257[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	DWORD PTR _pkScriptSystem$[ebp], eax

; 1260 : 	if (pkScriptSystem)

	cmp	DWORD PTR _pkScriptSystem$[ebp], 0
	je	$LN45@DoDeclareW

; 1261 : 	{
; 1262 : 		CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$222932[ebp]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1263 : 		args->Push(GetID());

	mov	eax, DWORD PTR _args$222932[ebp]
	mov	DWORD PTR tv268[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	ecx, DWORD PTR tv268[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv268[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 1264 : 		args->Push(eTeam);

	mov	ecx, DWORD PTR _args$222932[ebp]
	mov	DWORD PTR tv277[ebp], ecx
	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	eax, DWORD PTR tv277[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv277[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 1265 : 
; 1266 : 		bool bResult;
; 1267 : 		LuaSupport::CallHook(pkScriptSystem, "DeclareWar", args.get(), bResult);

	lea	ecx, DWORD PTR _bResult$222933[ebp]
	push	ecx
	mov	edx, DWORD PTR _args$222932[ebp]
	push	edx
	push	OFFSET ??_C@_0L@BPLCHNAB@DeclareWar?$AA@
	mov	eax, DWORD PTR _pkScriptSystem$[ebp]
	push	eax
	call	?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallHook
	add	esp, 16					; 00000010H

; 1268 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _args$222932[ebp]
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN45@DoDeclareW:

; 1269 : 
; 1270 : 	// One shot things
; 1271 : 	DoNowAtWarOrPeace(eTeam, true);

	push	1
	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z ; CvTeam::DoNowAtWarOrPeace

; 1272 : 	GET_TEAM(eTeam).DoNowAtWarOrPeace(GetID(), true);

	mov	edx, DWORD PTR _eTeam$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T232386[ebp], edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	ecx, DWORD PTR $T232386[ebp]
	call	?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z ; CvTeam::DoNowAtWarOrPeace

; 1273 : 
; 1274 : 	// Meet the team if we haven't already
; 1275 : 	meet(eTeam, false);

	push	0
	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?meet@CvTeam@@QAEXW4TeamTypes@@_N@Z	; CvTeam::meet

; 1276 : 
; 1277 : 	// Update the ATTACKED players' Diplo AI
; 1278 : 	if (!isBarbarian())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isBarbarian@CvTeam@@QBE_NXZ		; CvTeam::isBarbarian
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN44@DoDeclareW

; 1279 : 	{
; 1280 : 		for (iI = 0; iI < MAX_CIV_PLAYERS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN43@DoDeclareW
$LN42@DoDeclareW:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN43@DoDeclareW:
	cmp	DWORD PTR _iI$[ebp], 63			; 0000003fH
	jge	SHORT $LN41@DoDeclareW

; 1281 : 		{
; 1282 : 			CvPlayerAI& kPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	eax, DWORD PTR _iI$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$222939[ebp], eax

; 1283 : 			if (kPlayer.isAlive() && kPlayer.getTeam() == eTeam)

	mov	ecx, DWORD PTR _kPlayer$222939[ebp]
	mov	dl, BYTE PTR [ecx+2256]
	mov	BYTE PTR $T232398[ebp], dl
	movzx	eax, BYTE PTR $T232398[ebp]
	test	eax, eax
	je	SHORT $LN40@DoDeclareW
	mov	ecx, DWORD PTR _kPlayer$222939[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	eax, DWORD PTR _eTeam$[ebp]
	jne	SHORT $LN40@DoDeclareW

; 1284 : 				kPlayer.GetDiplomacyAI()->DoSomeoneDeclaredWarOnMe(GetID());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	ecx, DWORD PTR _kPlayer$222939[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?DoSomeoneDeclaredWarOnMe@CvDiplomacyAI@@QAEXW4TeamTypes@@@Z ; CvDiplomacyAI::DoSomeoneDeclaredWarOnMe
$LN40@DoDeclareW:

; 1285 : 		}

	jmp	SHORT $LN42@DoDeclareW
$LN41@DoDeclareW:

; 1286 : 
; 1287 : 		// If we've made a peace treaty before, this is bad news (no minors though)
; 1288 : 		if (!GET_TEAM(eTeam).isMinorCiv())

	mov	eax, DWORD PTR _eTeam$[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T232410[ebp], eax
	mov	ecx, DWORD PTR $T232410[ebp]
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN44@DoDeclareW

; 1289 : 		{
; 1290 : 			int iPeaceTreatyTurn = GetTurnMadePeaceTreatyWithTeam(eTeam);

	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTurnMadePeaceTreatyWithTeam@CvTeam@@QBEHW4TeamTypes@@@Z ; CvTeam::GetTurnMadePeaceTreatyWithTeam
	mov	DWORD PTR _iPeaceTreatyTurn$222943[ebp], eax

; 1291 : 			if (iPeaceTreatyTurn != -1)

	cmp	DWORD PTR _iPeaceTreatyTurn$222943[ebp], -1
	je	SHORT $LN44@DoDeclareW

; 1292 : 			{
; 1293 : 				int iTurnsSincePeace = GC.getGame().getElapsedGameTurns() - iPeaceTreatyTurn;

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232414[ebp], eax
	mov	ecx, DWORD PTR $T232414[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	sub	eax, DWORD PTR _iPeaceTreatyTurn$222943[ebp]
	mov	DWORD PTR _iTurnsSincePeace$222945[ebp], eax

; 1294 : 				if (iTurnsSincePeace < GC.getPEACE_TREATY_LENGTH())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6688
	mov	DWORD PTR $T232418[ebp], ecx
	mov	edx, DWORD PTR _iTurnsSincePeace$222945[ebp]
	cmp	edx, DWORD PTR $T232418[ebp]
	jge	SHORT $LN44@DoDeclareW

; 1295 : 				{
; 1296 : 					SetHasBrokenPeaceTreaty(true);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetHasBrokenPeaceTreaty@CvTeam@@QAEX_N@Z ; CvTeam::SetHasBrokenPeaceTreaty
$LN44@DoDeclareW:

; 1297 : 				}
; 1298 : 			}
; 1299 : 		}
; 1300 : 	}
; 1301 : 
; 1302 : 	// Update interface stuff
; 1303 : 	if ((GetID() == GC.getGame().getActiveTeam()) || (eTeam == GC.getGame().getActiveTeam()))

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232422[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	mov	esi, eax
	mov	ecx, DWORD PTR $T232422[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	esi, eax
	je	SHORT $LN35@DoDeclareW
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232426[ebp], ecx
	mov	ecx, DWORD PTR $T232426[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	DWORD PTR _eTeam$[ebp], eax
	jne	SHORT $LN36@DoDeclareW
$LN35@DoDeclareW:

; 1304 : 	{
; 1305 : 		DLLUI->setDirty(Score_DIRTY_BIT, true);

	mov	edx, DWORD PTR $T232430[ebp]
	mov	DWORD PTR tv372[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv372[ebp], eax
	push	1
	push	12					; 0000000cH
	mov	ecx, DWORD PTR tv372[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv372[ebp]
	mov	eax, DWORD PTR [edx+260]
	call	eax

; 1306 : 		DLLUI->setDirty(CityInfo_DIRTY_BIT, true);

	mov	ecx, DWORD PTR $T232434[ebp]
	mov	DWORD PTR tv384[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv384[ebp], edx
	push	1
	push	18					; 00000012H
	mov	eax, DWORD PTR tv384[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv384[ebp]
	mov	eax, DWORD PTR [edx+260]
	call	eax
$LN36@DoDeclareW:

; 1307 : 	}
; 1308 : 
; 1309 : 	if (GC.getGame().isFinalInitialized())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232438[ebp], ecx
	mov	ecx, DWORD PTR $T232438[ebp]
	call	?isFinalInitialized@CvGame@@QBE_NXZ	; CvGame::isFinalInitialized
	movzx	edx, al
	test	edx, edx
	je	$LN34@DoDeclareW

; 1310 : 	{
; 1311 : 		// Message everyone about what happened
; 1312 : 		if (!isBarbarian() && !(GET_TEAM(eTeam).isBarbarian()))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isBarbarian@CvTeam@@QBE_NXZ		; CvTeam::isBarbarian
	movzx	eax, al
	test	eax, eax
	jne	$LN34@DoDeclareW
	mov	ecx, DWORD PTR _eTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T232442[ebp], ecx
	mov	ecx, DWORD PTR $T232442[ebp]
	call	?isBarbarian@CvTeam@@QBE_NXZ		; CvTeam::isBarbarian
	movzx	edx, al
	test	edx, edx
	jne	$LN34@DoDeclareW

; 1313 : 		{
; 1314 : 			{
; 1315 : 				PlayerTypes ePlayer;
; 1316 : 				for (iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN32@DoDeclareW
$LN31@DoDeclareW:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN32@DoDeclareW:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	$LN30@DoDeclareW

; 1317 : 				{
; 1318 : 					ePlayer = (PlayerTypes)iI;

	mov	ecx, DWORD PTR _iI$[ebp]
	mov	DWORD PTR _ePlayer$222951[ebp], ecx

; 1319 : 
; 1320 : 					if (GET_PLAYER(ePlayer).isAlive() && GET_PLAYER(ePlayer).GetNotifications())

	mov	edx, DWORD PTR _ePlayer$222951[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232446[ebp], edx
	mov	eax, DWORD PTR $T232446[ebp]
	mov	cl, BYTE PTR [eax+2256]
	mov	BYTE PTR $T232455[ebp], cl
	movzx	edx, BYTE PTR $T232455[ebp]
	test	edx, edx
	je	$LN29@DoDeclareW
	mov	eax, DWORD PTR _ePlayer$222951[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232459[ebp], eax
	mov	ecx, DWORD PTR $T232459[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	test	eax, eax
	je	$LN29@DoDeclareW

; 1321 : 					{
; 1322 : 						// If this declaration is a minor following a major's declaration, don't send out these individual notifications
; 1323 : 						if (!bMinorAllyPact)

	movzx	ecx, BYTE PTR _bMinorAllyPact$[ebp]
	test	ecx, ecx
	jne	$LN29@DoDeclareW

; 1324 : 						{
; 1325 : 							// Players on team that declared
; 1326 : 							if (GET_PLAYER(ePlayer).getTeam() == GetID())

	mov	edx, DWORD PTR _ePlayer$222951[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232463[ebp], edx
	mov	eax, DWORD PTR $T232463[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T232472[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T232472[ebp], eax
	jne	$LN27@DoDeclareW

; 1327 : 							{
; 1328 : 								if (ePlayer == GC.getGame().getActivePlayer())

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232476[ebp], edx
	mov	ecx, DWORD PTR $T232476[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	DWORD PTR _ePlayer$222951[ebp], eax
	jne	$LN26@DoDeclareW

; 1329 : 								{
; 1330 : 									locString = Localization::Lookup("TXT_KEY_MISC_YOU_DECLARED_WAR_ON");

	push	OFFSET ??_C@_0CB@FEDIKDJG@TXT_KEY_MISC_YOU_DECLARED_WAR_ON@
	lea	eax, DWORD PTR $T232262[ebp]
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR tv263[ebp], eax
	mov	ecx, DWORD PTR tv263[ebp]
	mov	DWORD PTR tv834[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR tv834[ebp]
	push	edx
	lea	ecx, DWORD PTR _locString$[ebp]
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T232262[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1331 : 									locString << GET_TEAM(eTeam).getName().GetCString();

	mov	eax, DWORD PTR _eTeam$[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T232480[ebp], eax
	lea	ecx, DWORD PTR $T232264[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T232480[ebp]
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	DWORD PTR tv65[ebp], eax
	mov	edx, DWORD PTR tv65[ebp]
	mov	DWORD PTR $T232484[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR $T232484[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T232263[ebp], eax
	lea	eax, DWORD PTR $T232263[ebp]
	push	eax
	lea	ecx, DWORD PTR _locString$[ebp]
	push	ecx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T232264[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1332 : 									DLLUI->AddMessage(0, (ePlayer), true, GC.getEVENT_MESSAGE_TIME(), locString.toUTF8()/*, "AS2D_DECLAREWAR", MESSAGE_TYPE_MAJOR_EVENT, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_WARNING_TEXT")*/);

	mov	edx, DWORD PTR $T232492[ebp]
	mov	DWORD PTR tv469[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv469[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	mov	DWORD PTR $T232496[ebp], ecx
	push	0
	push	0
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR _locString$[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	mov	edx, DWORD PTR $T232496[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _ePlayer$222951[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR tv469[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv469[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN26@DoDeclareW:

; 1333 : 								}
; 1334 : 							}

	jmp	$LN29@DoDeclareW
$LN27@DoDeclareW:

; 1335 : 							// Players on team that got declared on
; 1336 : 							else if (GET_PLAYER(ePlayer).getTeam() == eTeam)

	mov	ecx, DWORD PTR _ePlayer$222951[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232500[ebp], ecx
	mov	edx, DWORD PTR $T232500[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	eax, DWORD PTR _eTeam$[ebp]
	jne	$LN24@DoDeclareW

; 1337 : 							{
; 1338 : 								locString = Localization::Lookup("TXT_KEY_MISC_DECLARED_WAR_ON_YOU");

	push	OFFSET ??_C@_0CB@IPLANLDM@TXT_KEY_MISC_DECLARED_WAR_ON_YOU@
	lea	ecx, DWORD PTR $T232265[ebp]
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR tv1003[ebp], eax
	mov	edx, DWORD PTR tv1003[ebp]
	mov	DWORD PTR tv838[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	eax, DWORD PTR tv838[ebp]
	push	eax
	lea	ecx, DWORD PTR _locString$[ebp]
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T232265[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1339 : 								locString << getName().GetCString();

	lea	ecx, DWORD PTR $T232267[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	DWORD PTR tv822[ebp], eax
	mov	edx, DWORD PTR tv822[ebp]
	mov	DWORD PTR $T232512[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR $T232512[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T232266[ebp], eax
	lea	eax, DWORD PTR $T232266[ebp]
	push	eax
	lea	ecx, DWORD PTR _locString$[ebp]
	push	ecx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T232267[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1340 : 								GET_PLAYER(ePlayer).GetNotifications()->Add(NOTIFICATION_WAR_ACTIVE_PLAYER, locString.toUTF8(), locString.toUTF8(), -1, -1, this->getLeaderID());

	mov	edx, DWORD PTR _ePlayer$222951[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232520[ebp], edx
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	push	eax
	push	-1
	push	-1
	lea	ecx, DWORD PTR _locString$[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _locString$[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	push	-190211195				; f4a99b85H
	mov	ecx, DWORD PTR $T232520[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ecx, eax
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
	jmp	$LN29@DoDeclareW
$LN24@DoDeclareW:

; 1341 : 							}
; 1342 : 							// Players that are on neither team, but know both parties
; 1343 : 							else if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isHasMet(GetID()) && GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isHasMet(eTeam))

	mov	eax, DWORD PTR _ePlayer$222951[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232524[ebp], eax
	mov	ecx, DWORD PTR $T232524[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T232533[ebp], eax
	mov	eax, DWORD PTR $T232533[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T232537[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	ecx, DWORD PTR $T232537[ebp]
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	movzx	ecx, al
	test	ecx, ecx
	je	$LN29@DoDeclareW
	mov	edx, DWORD PTR _ePlayer$222951[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232541[ebp], edx
	mov	eax, DWORD PTR $T232541[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T232550[ebp], eax
	mov	edx, DWORD PTR $T232550[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T232554[ebp], edx
	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T232554[ebp]
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	movzx	ecx, al
	test	ecx, ecx
	je	$LN29@DoDeclareW

; 1344 : 							{
; 1345 : 								locString = Localization::Lookup("TXT_KEY_MISC_SOMEONE_DECLARED_WAR");

	push	OFFSET ??_C@_0CC@KMCACDHN@TXT_KEY_MISC_SOMEONE_DECLARED_WA@
	lea	edx, DWORD PTR $T232268[ebp]
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR tv1049[ebp], eax
	mov	eax, DWORD PTR tv1049[ebp]
	mov	DWORD PTR tv842[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR tv842[ebp]
	push	ecx
	lea	ecx, DWORD PTR _locString$[ebp]
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T232268[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1346 : 								locString << getName().GetCString() << GET_TEAM(eTeam).getName().GetCString();

	mov	edx, DWORD PTR _eTeam$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T232558[ebp], edx
	lea	eax, DWORD PTR $T232270[ebp]
	push	eax
	mov	ecx, DWORD PTR $T232558[ebp]
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	DWORD PTR tv1050[ebp], eax
	mov	ecx, DWORD PTR tv1050[ebp]
	mov	DWORD PTR $T232562[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	ecx, DWORD PTR $T232562[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T232269[ebp], eax
	lea	edx, DWORD PTR $T232272[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	DWORD PTR tv1051[ebp], eax
	mov	eax, DWORD PTR tv1051[ebp]
	mov	DWORD PTR $T232566[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	ecx, DWORD PTR $T232566[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T232271[ebp], eax
	lea	ecx, DWORD PTR $T232269[ebp]
	push	ecx
	lea	edx, DWORD PTR $T232271[ebp]
	push	edx
	lea	eax, DWORD PTR _locString$[ebp]
	push	eax
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8
	push	eax
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	lea	ecx, DWORD PTR $T232272[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T232270[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1347 : 								GET_PLAYER(ePlayer).GetNotifications()->Add(NOTIFICATION_WAR, locString.toUTF8(), locString.toUTF8(), -1, -1, this->getLeaderID(), eTeam);

	mov	ecx, DWORD PTR _ePlayer$222951[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232578[ebp], ecx
	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	push	eax
	push	-1
	push	-1
	lea	ecx, DWORD PTR _locString$[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _locString$[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	push	-958154983				; c6e3b719H
	mov	ecx, DWORD PTR $T232578[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ecx, eax
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN29@DoDeclareW:

; 1348 : 							}
; 1349 : 						}
; 1350 : 					}
; 1351 : 				}

	jmp	$LN31@DoDeclareW
$LN30@DoDeclareW:

; 1352 : 			}
; 1353 : 
; 1354 : 			locString = Localization::Lookup("TXT_KEY_MISC_SOMEONE_DECLARES_WAR");

	push	OFFSET ??_C@_0CC@LCPDBBFO@TXT_KEY_MISC_SOMEONE_DECLARES_WA@
	lea	eax, DWORD PTR $T232273[ebp]
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR tv1052[ebp], eax
	mov	ecx, DWORD PTR tv1052[ebp]
	mov	DWORD PTR tv848[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	mov	edx, DWORD PTR tv848[ebp]
	push	edx
	lea	ecx, DWORD PTR _locString$[ebp]
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T232273[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1355 : 			locString << getName().GetCString() << GET_TEAM(eTeam).getName().GetCString();

	mov	eax, DWORD PTR _eTeam$[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T232582[ebp], eax
	lea	ecx, DWORD PTR $T232275[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T232582[ebp]
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	DWORD PTR tv1053[ebp], eax
	mov	edx, DWORD PTR tv1053[ebp]
	mov	DWORD PTR $T232586[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	ecx, DWORD PTR $T232586[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T232274[ebp], eax
	lea	eax, DWORD PTR $T232277[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	DWORD PTR tv1054[ebp], eax
	mov	ecx, DWORD PTR tv1054[ebp]
	mov	DWORD PTR $T232590[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	mov	ecx, DWORD PTR $T232590[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T232276[ebp], eax
	lea	edx, DWORD PTR $T232274[ebp]
	push	edx
	lea	eax, DWORD PTR $T232276[ebp]
	push	eax
	lea	ecx, DWORD PTR _locString$[ebp]
	push	ecx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8
	push	eax
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	lea	ecx, DWORD PTR $T232277[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T232275[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1356 : 			GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, getLeaderID(), locString.toUTF8(), -1, -1);

	lea	ecx, DWORD PTR _locString$[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	mov	DWORD PTR $T232607[ebp], eax
	cmp	DWORD PTR $T232607[ebp], 0
	je	SHORT $LN236@DoDeclareW
	mov	edx, DWORD PTR $T232607[ebp]
	mov	DWORD PTR tv1005[ebp], edx
	jmp	SHORT $LN237@DoDeclareW
$LN236@DoDeclareW:
	mov	DWORD PTR tv1005[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN237@DoDeclareW:
	mov	eax, DWORD PTR tv1005[ebp]
	push	eax
	lea	ecx, DWORD PTR $T232278[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232611[ebp], ecx
	push	-1
	push	-1
	lea	edx, DWORD PTR $T232278[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	push	eax
	push	0
	mov	ecx, DWORD PTR $T232611[ebp]
	call	?addReplayMessage@CvGame@@QAEXW4ReplayMessageTypes@@W4PlayerTypes@@ABVCvString@@HH@Z ; CvGame::addReplayMessage
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T232278[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN34@DoDeclareW:

; 1357 : 		}
; 1358 : 	}
; 1359 : 
; 1360 : #ifdef NQM_GAME_EXTEND_TURN_TIMER_ON_LAST_MINUTE_WAR_DECLARATION_IF_SIMULTANEOUS
; 1361 : 	if (isHuman() && GET_TEAM(eTeam).isHuman())
; 1362 : 	{
; 1363 : #ifdef AUI_GAME_BETTER_HYBRID_MODE
; 1364 : 		if (getTurnOrder() == GET_TEAM(eTeam).getTurnOrder())
; 1365 : #else
; 1366 : 		if (isSimultaneousTurns() || GET_TEAM(eTeam).isSimultaneousTurns())
; 1367 : #endif
; 1368 : 		{
; 1369 : 			CvGame& kGame = GC.getGame();
; 1370 : 			if (kGame.isOption(GAMEOPTION_END_TURN_TIMER_ENABLED) && kGame.getElapsedGameTurns() > 0 && 
; 1371 : #ifdef AUI_GAME_RELATIVE_TURN_TIMERS
; 1372 : 				(kGame.getPitbossTurnTime() == 0 || kGame.isOption("GAMEOPTION_RELATIVE_TURN_TIMER")))
; 1373 : #else
; 1374 : 				kGame.getPitbossTurnTime() == 0)
; 1375 : #endif
; 1376 : 			{
; 1377 : 				const CvTurnTimerInfo& kTurnTimer = CvPreGame::turnTimerInfo();
; 1378 : 				float fBaseTurnTime = static_cast<float>(kTurnTimer.getBaseTime());
; 1379 : 
; 1380 : #ifdef AUI_GAME_PLAYER_BASED_TURN_LENGTH
; 1381 : 				FFastVector<int, true, c_eCiv5GameplayDLL>::const_iterator piCurMaxTurnLength = kGame.m_aiMaxTurnLengths.begin();
; 1382 : 				piCurMaxTurnLength += GET_PLAYER(kGame.getActivePlayer()).getTurnOrder();
; 1383 : 
; 1384 : 				float fGameTurnEnd = static_cast<float>(*piCurMaxTurnLength);
; 1385 : #else
; 1386 : 				float fGameTurnEnd = static_cast<float>(kGame.getMaxTurnLen());
; 1387 : 
; 1388 : 				//NOTE:  These times exclude the time used for AI processing.
; 1389 : 				//Time since the current player's turn started.  Used for measuring time for players in sequential turn mode.
; 1390 : 				float fTimeSinceCurrentTurnStart = kGame.m_curTurnTimer.Peek() + kGame.m_fCurrentTurnTimerPauseDelta;
; 1391 : #ifndef AUI_GAME_BETTER_HYBRID_MODE
; 1392 : 				//Time since the game (year) turn started.  Used for measuring time for players in simultaneous turn mode.
; 1393 : 				float fTimeSinceGameTurnStart = kGame.m_timeSinceGameTurnStart.Peek() + kGame.m_fCurrentTurnTimerPauseDelta;
; 1394 : #endif
; 1395 : #endif
; 1396 : #ifdef AUI_GAME_PLAYER_BASED_TURN_LENGTH
; 1397 : 				float fTimeElapsed = kGame.m_curTurnTimer.Peek() + kGame.m_fCurrentTurnTimerPauseDelta;
; 1398 : #elif defined(AUI_GAME_BETTER_HYBRID_MODE)
; 1399 : 				float fTimeElapsed = timeSinceCurrentTurnStart;
; 1400 : #else
; 1401 : 				float fTimeElapsed = (GET_PLAYER(kGame.getActivePlayer()).isSimultaneousTurns() ? fTimeSinceGameTurnStart : fTimeSinceCurrentTurnStart);
; 1402 : #endif
; 1403 : 				float fTimeToAdd = MAX(0.0f, fTimeElapsed - fGameTurnEnd + fBaseTurnTime);
; 1404 : 				if (fTimeToAdd > 0)
; 1405 : 				{
; 1406 : 					kGame.m_curTurnTimer.m_qStart += (__int64)(fTimeToAdd/ kGame.m_curTurnTimer.m_fFreq);
; 1407 : 					kGame.m_timeSinceGameTurnStart.m_qStart += (__int64)(fTimeToAdd / kGame.m_timeSinceGameTurnStart.m_fFreq);
; 1408 : 				}
; 1409 : 			}
; 1410 : 		}
; 1411 : 	}
; 1412 : #endif
; 1413 : 
; 1414 : 	int iMinorCivLoop;
; 1415 : 	int iMajorCivLoop;
; 1416 : 
; 1417 : 	// Minor Civs declaring war
; 1418 : 	if(isMinorCiv())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN21@DoDeclareW

; 1419 : 	{
; 1420 : 
; 1421 : 	}
; 1422 : 	// Major is declaring War
; 1423 : 	else

	jmp	$LN20@DoDeclareW
$LN21@DoDeclareW:

; 1424 : 	{
; 1425 : 		int iMajorCivLoop2;
; 1426 : 
; 1427 : 		// Update what every Major Civ sees
; 1428 : 		for(iMajorCivLoop = 0; iMajorCivLoop < MAX_MAJOR_CIVS; iMajorCivLoop++)

	mov	DWORD PTR _iMajorCivLoop$[ebp], 0
	jmp	SHORT $LN19@DoDeclareW
$LN18@DoDeclareW:
	mov	ecx, DWORD PTR _iMajorCivLoop$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iMajorCivLoop$[ebp], ecx
$LN19@DoDeclareW:
	cmp	DWORD PTR _iMajorCivLoop$[ebp], 22	; 00000016H
	jge	$LN20@DoDeclareW

; 1429 : 		{
; 1430 : 			if(GET_PLAYER((PlayerTypes) iMajorCivLoop).getTeam() == GetID())

	mov	edx, DWORD PTR _iMajorCivLoop$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232619[ebp], edx
	mov	eax, DWORD PTR $T232619[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T232628[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T232628[ebp], eax
	jne	$LN16@DoDeclareW

; 1431 : 			{
; 1432 : 				if(GET_PLAYER((PlayerTypes) iMajorCivLoop).isAlive())

	mov	edx, DWORD PTR _iMajorCivLoop$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232632[ebp], edx
	mov	eax, DWORD PTR $T232632[ebp]
	mov	cl, BYTE PTR [eax+2256]
	mov	BYTE PTR $T232641[ebp], cl
	movzx	edx, BYTE PTR $T232641[ebp]
	test	edx, edx
	je	$LN16@DoDeclareW

; 1433 : 				{
; 1434 : 					// Alter Grand Strategy stats for all Majors in the game whove met this declaring war Major
; 1435 : 					for(iMajorCivLoop2 = 0; iMajorCivLoop2 < MAX_MAJOR_CIVS; iMajorCivLoop2++)

	mov	DWORD PTR _iMajorCivLoop2$222994[ebp], 0
	jmp	SHORT $LN14@DoDeclareW
$LN13@DoDeclareW:
	mov	eax, DWORD PTR _iMajorCivLoop2$222994[ebp]
	add	eax, 1
	mov	DWORD PTR _iMajorCivLoop2$222994[ebp], eax
$LN14@DoDeclareW:
	cmp	DWORD PTR _iMajorCivLoop2$222994[ebp], 22 ; 00000016H
	jge	$LN12@DoDeclareW

; 1436 : 					{
; 1437 : 						// I don't care if it's me
; 1438 : 						if(iMajorCivLoop != iMajorCivLoop2)

	mov	ecx, DWORD PTR _iMajorCivLoop$[ebp]
	cmp	ecx, DWORD PTR _iMajorCivLoop2$222994[ebp]
	je	$LN11@DoDeclareW

; 1439 : 						{
; 1440 : 							// Have I actually met this player declaring war?
; 1441 : 							if(GET_TEAM(GET_PLAYER((PlayerTypes) iMajorCivLoop2).getTeam()).isHasMet(GET_PLAYER((PlayerTypes) iMajorCivLoop).getTeam()))

	mov	edx, DWORD PTR _iMajorCivLoop$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232645[ebp], edx
	mov	eax, DWORD PTR $T232645[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T232654[ebp], eax
	mov	edx, DWORD PTR _iMajorCivLoop2$222994[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232658[ebp], edx
	mov	eax, DWORD PTR $T232658[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T232667[ebp], eax
	mov	edx, DWORD PTR $T232667[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T232671[ebp], edx
	mov	eax, DWORD PTR $T232654[ebp]
	push	eax
	mov	ecx, DWORD PTR $T232671[ebp]
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	movzx	ecx, al
	test	ecx, ecx
	je	$LN11@DoDeclareW

; 1442 : 							{
; 1443 : 								GET_PLAYER((PlayerTypes) iMajorCivLoop2).GetDiplomacyAI()->DoPlayerDeclaredWarOnSomeone((PlayerTypes) iMajorCivLoop, eTeam);

	mov	edx, DWORD PTR _iMajorCivLoop2$222994[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232675[ebp], edx
	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iMajorCivLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T232675[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?DoPlayerDeclaredWarOnSomeone@CvDiplomacyAI@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z ; CvDiplomacyAI::DoPlayerDeclaredWarOnSomeone

; 1444 : 
; 1445 : 								if(!bDefensivePact)

	movzx	edx, BYTE PTR _bDefensivePact$[ebp]
	test	edx, edx
	jne	$LN11@DoDeclareW

; 1446 : 								{
; 1447 : 									// Major declaring war on Minor
; 1448 : 									if(GET_TEAM(eTeam).isMinorCiv())

	mov	eax, DWORD PTR _eTeam$[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T232679[ebp], eax
	mov	ecx, DWORD PTR $T232679[ebp]
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN8@DoDeclareW

; 1449 : 									{
; 1450 : 										GET_PLAYER((PlayerTypes) iMajorCivLoop2).GetDiplomacyAI()->ChangeOtherPlayerNumMinorsAttacked((PlayerTypes) iMajorCivLoop, 1);

	mov	edx, DWORD PTR _iMajorCivLoop2$222994[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232683[ebp], edx
	push	1
	mov	eax, DWORD PTR _iMajorCivLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T232683[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?ChangeOtherPlayerNumMinorsAttacked@CvDiplomacyAI@@QAEXW4PlayerTypes@@H@Z ; CvDiplomacyAI::ChangeOtherPlayerNumMinorsAttacked

; 1451 : 									}
; 1452 : 									// Major declaring war on Major
; 1453 : 									else

	jmp	SHORT $LN11@DoDeclareW
$LN8@DoDeclareW:

; 1454 : 									{
; 1455 : 										GET_PLAYER((PlayerTypes) iMajorCivLoop2).GetDiplomacyAI()->ChangeOtherPlayerNumMajorsAttacked((PlayerTypes) iMajorCivLoop, 1, eTeam);

	mov	ecx, DWORD PTR _iMajorCivLoop2$222994[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232687[ebp], ecx
	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _iMajorCivLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T232687[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?ChangeOtherPlayerNumMajorsAttacked@CvDiplomacyAI@@QAEXW4PlayerTypes@@HW4TeamTypes@@@Z ; CvDiplomacyAI::ChangeOtherPlayerNumMajorsAttacked
$LN11@DoDeclareW:

; 1456 : 									}
; 1457 : 								}
; 1458 : 							}
; 1459 : 						}
; 1460 : 					}

	jmp	$LN13@DoDeclareW
$LN12@DoDeclareW:

; 1461 : 
; 1462 : 					// Declaring war on Minor
; 1463 : 					for(iMinorCivLoop = MAX_MAJOR_CIVS; iMinorCivLoop < MAX_CIV_PLAYERS; iMinorCivLoop++)

	mov	DWORD PTR _iMinorCivLoop$[ebp], 22	; 00000016H
	jmp	SHORT $LN6@DoDeclareW
$LN5@DoDeclareW:
	mov	ecx, DWORD PTR _iMinorCivLoop$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iMinorCivLoop$[ebp], ecx
$LN6@DoDeclareW:
	cmp	DWORD PTR _iMinorCivLoop$[ebp], 63	; 0000003fH
	jge	$LN16@DoDeclareW

; 1464 : 					{
; 1465 : 						// Now loop through all players on this team to nullify Quests for them
; 1466 : 						if(GET_PLAYER((PlayerTypes) iMinorCivLoop).getTeam() == eTeam)

	mov	edx, DWORD PTR _iMinorCivLoop$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232691[ebp], edx
	mov	eax, DWORD PTR $T232691[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	eax, DWORD PTR _eTeam$[ebp]
	jne	$LN3@DoDeclareW

; 1467 : 						{
; 1468 : 							if(GET_PLAYER((PlayerTypes) iMinorCivLoop).isAlive())

	mov	edx, DWORD PTR _iMinorCivLoop$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232703[ebp], edx
	mov	eax, DWORD PTR $T232703[ebp]
	mov	cl, BYTE PTR [eax+2256]
	mov	BYTE PTR $T232712[ebp], cl
	movzx	edx, BYTE PTR $T232712[ebp]
	test	edx, edx
	je	SHORT $LN3@DoDeclareW

; 1469 : 							{
; 1470 : 								// Increment # of Minors this player has attacked - note that this will be called EACH time a team declares war on a Minor,
; 1471 : 								// even the same Minor multiple times.  The current design assumes that once a player is at war with a Minor it's forever, so this is fine
; 1472 : 								//antonjs: consider: this statement is no longer valid, since current design allows peace to be made; update the implementation
; 1473 : 								if(!isMinorCiv() && !bDefensivePact)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@DoDeclareW
	movzx	ecx, BYTE PTR _bDefensivePact$[ebp]
	test	ecx, ecx
	jne	SHORT $LN3@DoDeclareW

; 1474 : 								{
; 1475 : 									ChangeNumMinorCivsAttacked(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChangeNumMinorCivsAttacked@CvTeam@@QAEXH@Z ; CvTeam::ChangeNumMinorCivsAttacked

; 1476 : 
; 1477 : 									GET_PLAYER((PlayerTypes) iMinorCivLoop).GetMinorCivAI()->DoTeamDeclaredWarOnMe(GetID());

	mov	edx, DWORD PTR _iMinorCivLoop$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232716[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	ecx, DWORD PTR $T232716[ebp]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?DoTeamDeclaredWarOnMe@CvMinorCivAI@@QAEXW4TeamTypes@@@Z ; CvMinorCivAI::DoTeamDeclaredWarOnMe
$LN3@DoDeclareW:

; 1478 : 								}
; 1479 : 							}
; 1480 : 						}
; 1481 : 					}

	jmp	$LN5@DoDeclareW
$LN16@DoDeclareW:

; 1482 : 				}
; 1483 : 			}
; 1484 : 		}

	jmp	$LN18@DoDeclareW
$LN20@DoDeclareW:

; 1485 : 	}
; 1486 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _locString$[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN59@DoDeclareW:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$0:
	lea	ecx, DWORD PTR _locString$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$1:
	lea	ecx, DWORD PTR _args$222932[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$2:
	lea	ecx, DWORD PTR $T232262[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$3:
	lea	ecx, DWORD PTR $T232264[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$4:
	lea	ecx, DWORD PTR $T232265[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$5:
	lea	ecx, DWORD PTR $T232267[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$6:
	lea	ecx, DWORD PTR $T232268[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$7:
	lea	ecx, DWORD PTR $T232270[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$8:
	lea	ecx, DWORD PTR $T232272[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$9:
	lea	ecx, DWORD PTR $T232273[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$10:
	lea	ecx, DWORD PTR $T232275[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$11:
	lea	ecx, DWORD PTR $T232277[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$12:
	lea	ecx, DWORD PTR $T232278[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1060]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z ENDP	; CvTeam::DoDeclareWar
PUBLIC	??1?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum PlayerTypes,63,1,297,0>::~FStaticVector<enum PlayerTypes,63,1,297,0>
PUBLIC	??_C@_09ODCIJKAA@?$FLNEWLINE?$FN?$AA@		; `string'
PUBLIC	??_C@_0CO@IPNHMNOP@TXT_KEY_MISC_MINOR_ALLIES_DECLAR@ ; `string'
PUBLIC	??_C@_0DG@PIFENIBB@TXT_KEY_MISC_MINOR_ALLIES_DECLAR@ ; `string'
PUBLIC	??_C@_0CM@MDLFPNAG@TXT_KEY_MISC_YOUR_MINOR_ALLIES_D@ ; `string'
PUBLIC	??_C@_0DE@BEJHFIBA@TXT_KEY_MISC_YOUR_MINOR_ALLIES_D@ ; `string'
PUBLIC	?push_back@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAEIABW4PlayerTypes@@@Z ; FStaticVector<enum PlayerTypes,63,1,297,0>::push_back
PUBLIC	??0?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum PlayerTypes,63,1,297,0>::FStaticVector<enum PlayerTypes,63,1,297,0>
PUBLIC	__$ArrayPad$
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:PROC
EXTRN	?IsFriends@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z:PROC ; CvMinorCivAI::IsFriends
EXTRN	?IsNoMinorDOWIfFriends@CvPlayer@@QBE_NXZ:PROC	; CvPlayer::IsNoMinorDOWIfFriends
EXTRN	?IsAllies@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z:PROC ; CvMinorCivAI::IsAllies
EXTRN	?UpdateReligion@CvPlayer@@QAEXXZ:PROC		; CvPlayer::UpdateReligion
EXTRN	?SetDangerPlotsDirty@CvPlayer@@QAEXXZ:PROC	; CvPlayer::SetDangerPlotsDirty
EXTRN	?DoNowPeaceWithTeam@CvMinorCivAI@@QAEXW4TeamTypes@@@Z:PROC ; CvMinorCivAI::DoNowPeaceWithTeam
EXTRN	?DoNowAtWarWithTeam@CvMinorCivAI@@QAEXW4TeamTypes@@@Z:PROC ; CvMinorCivAI::DoNowAtWarWithTeam
;	COMDAT ??_C@_09ODCIJKAA@?$FLNEWLINE?$FN?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_09ODCIJKAA@?$FLNEWLINE?$FN?$AA@ DB '[NEWLINE]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@IPNHMNOP@TXT_KEY_MISC_MINOR_ALLIES_DECLAR@
CONST	SEGMENT
??_C@_0CO@IPNHMNOP@TXT_KEY_MISC_MINOR_ALLIES_DECLAR@ DB 'TXT_KEY_MISC_MIN'
	DB	'OR_ALLIES_DECLARED_WAR_ON_YOU', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@PIFENIBB@TXT_KEY_MISC_MINOR_ALLIES_DECLAR@
CONST	SEGMENT
??_C@_0DG@PIFENIBB@TXT_KEY_MISC_MINOR_ALLIES_DECLAR@ DB 'TXT_KEY_MISC_MIN'
	DB	'OR_ALLIES_DECLARED_WAR_ON_YOU_SUMMARY', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@MDLFPNAG@TXT_KEY_MISC_YOUR_MINOR_ALLIES_D@
CONST	SEGMENT
??_C@_0CM@MDLFPNAG@TXT_KEY_MISC_YOUR_MINOR_ALLIES_D@ DB 'TXT_KEY_MISC_YOU'
	DB	'R_MINOR_ALLIES_DECLARED_WAR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@BEJHFIBA@TXT_KEY_MISC_YOUR_MINOR_ALLIES_D@
CONST	SEGMENT
??_C@_0DE@BEJHFIBA@TXT_KEY_MISC_YOUR_MINOR_ALLIES_D@ DB 'TXT_KEY_MISC_YOU'
	DB	'R_MINOR_ALLIES_DECLARED_WAR_SUMMARY', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z DD 019930522H
	DD	010H
	DD	FLAT:__unwindtable$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$4
	DD	02H
	DD	FLAT:__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$7
	DD	06H
	DD	FLAT:__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$8
	DD	06H
	DD	FLAT:__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$9
	DD	09H
	DD	FLAT:__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$10
	DD	0aH
	DD	FLAT:__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$11
	DD	09H
	DD	FLAT:__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$12
	DD	0cH
	DD	FLAT:__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$13
	DD	09H
	DD	FLAT:__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$14
	DD	0eH
	DD	FLAT:__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$15
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z
_TEXT	SEGMENT
tv831 = -1352						; size = 4
tv561 = -1348						; size = 4
tv826 = -1344						; size = 4
tv827 = -1340						; size = 4
tv557 = -1336						; size = 4
tv828 = -1332						; size = 4
tv555 = -1328						; size = 4
tv680 = -1324						; size = 4
tv703 = -1320						; size = 4
tv737 = -1316						; size = 4
tv185 = -1312						; size = 4
tv548 = -1308						; size = 4
tv328 = -1304						; size = 4
tv682 = -1300						; size = 4
tv298 = -1296						; size = 4
tv542 = -1292						; size = 4
tv300 = -1288						; size = 4
_this$ = -1284						; size = 4
$T233050 = -1268					; size = 4
$T233046 = -1264					; size = 4
$T233042 = -1260					; size = 4
$T233030 = -1256					; size = 4
$T233026 = -1249					; size = 1
$T233017 = -1248					; size = 4
$T233013 = -1244					; size = 4
$T233009 = -1240					; size = 4
$T233005 = -1236					; size = 4
$T233001 = -1232					; size = 4
$T232997 = -1228					; size = 4
$T232989 = -1224					; size = 4
$T232988 = -1220					; size = 4
$T232984 = -1216					; size = 4
$T232980 = -1212					; size = 4
$T232971 = -1208					; size = 4
$T232964 = -1204					; size = 4
$T232960 = -1200					; size = 4
$T232947 = -1196					; size = 4
$T232943 = -1192					; size = 4
$T232930 = -1188					; size = 4
$T232926 = -1184					; size = 4
$T232922 = -1180					; size = 4
$T232914 = -1176					; size = 4
$T232899 = -1168					; size = 4
$T232890 = -1164					; size = 4
$T232886 = -1160					; size = 4
$T232882 = -1156					; size = 4
$T232870 = -1152					; size = 4
$T232866 = -1145					; size = 1
$T232857 = -1144					; size = 4
$T232845 = -1140					; size = 4
$T232841 = -1136					; size = 4
$T232837 = -1129					; size = 1
$T232828 = -1128					; size = 4
$T232813 = -1124					; size = 4
$T232804 = -1120					; size = 4
$T232800 = -1113					; size = 1
$T232791 = -1112					; size = 4
$T232787 = -1108					; size = 4
$T232783 = -1104					; size = 4
$T232779 = -1097					; size = 1
$T232770 = -1096					; size = 4
$T232766 = -1092					; size = 4
$T232757 = -1088					; size = 4
$T232737 = -1084					; size = 28
$T232736 = -1056					; size = 28
$T232735 = -1028					; size = 28
$T232734 = -1000					; size = 28
$T232733 = -972						; size = 80
$T232732 = -892						; size = 28
$T232731 = -864						; size = 28
$T232730 = -836						; size = 4
$T232729 = -832						; size = 80
$T232728 = -752						; size = 28
$T232727 = -724						; size = 4
$T232726 = -720						; size = 80
_eOtherPlayer$223252 = -640				; size = 4
_iOtherPlayerCivLoop$223248 = -636			; size = 4
_iMinorCivLoop$223237 = -632				; size = 4
_strOurAlliesSummary$223221 = -628			; size = 80
_strTemp$223220 = -548					; size = 80
_strOurAlliesMessage$223228 = -464			; size = 28
_strTheirEnemiesSummary$223229 = -436			; size = 80
_strTheirEnemiesMessage$223236 = -352			; size = 28
_iTargetTeamCivLoop$223210 = -324			; size = 4
_bFriendshipPreventsWar$223208 = -317			; size = 1
_eTargetPlayer$223209 = -316				; size = 4
_iMinorCivLoop$223200 = -312				; size = 4
_veMinorAllies$223199 = -308				; size = 268
__$ArrayPad$ = -36					; size = 4
_iPlayerCivLoop$223046 = -32				; size = 4
_ePlayer$223045 = -28					; size = 4
_eMinor$223044 = -24					; size = 4
_iMinorCivLoop$223034 = -20				; size = 4
_eMinor$223033 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_eTeam$ = 8						; size = 4
_bWar$ = 12						; size = 1
?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z PROC	; CvTeam::DoNowAtWarOrPeace, COMDAT
; _this$ = ecx

; 1490 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1340				; 0000053cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1491 : 	// Major is at war with a minor
; 1492 : 	if(isMinorCiv())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	movzx	eax, al
	test	eax, eax
	je	$LN36@DoNowAtWar

; 1493 : 	{
; 1494 : 		PlayerTypes eMinor;
; 1495 : 		for(int iMinorCivLoop = MAX_MAJOR_CIVS; iMinorCivLoop < MAX_CIV_PLAYERS; iMinorCivLoop++)

	mov	DWORD PTR _iMinorCivLoop$223034[ebp], 22 ; 00000016H
	jmp	SHORT $LN35@DoNowAtWar
$LN34@DoNowAtWar:
	mov	ecx, DWORD PTR _iMinorCivLoop$223034[ebp]
	add	ecx, 1
	mov	DWORD PTR _iMinorCivLoop$223034[ebp], ecx
$LN35@DoNowAtWar:
	cmp	DWORD PTR _iMinorCivLoop$223034[ebp], 63 ; 0000003fH
	jge	$LN36@DoNowAtWar

; 1496 : 		{
; 1497 : 			eMinor = (PlayerTypes) iMinorCivLoop;

	mov	edx, DWORD PTR _iMinorCivLoop$223034[ebp]
	mov	DWORD PTR _eMinor$223033[ebp], edx

; 1498 : 
; 1499 : 			if(GET_PLAYER(eMinor).getTeam() == GetID())

	mov	eax, DWORD PTR _eMinor$223033[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232757[ebp], eax
	mov	ecx, DWORD PTR $T232757[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T232766[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T232766[ebp], eax
	jne	$LN32@DoNowAtWar

; 1500 : 			{
; 1501 : 				if(GET_PLAYER(eMinor).isAlive())

	mov	eax, DWORD PTR _eMinor$223033[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232770[ebp], eax
	mov	ecx, DWORD PTR $T232770[ebp]
	mov	dl, BYTE PTR [ecx+2256]
	mov	BYTE PTR $T232779[ebp], dl
	movzx	eax, BYTE PTR $T232779[ebp]
	test	eax, eax
	je	SHORT $LN32@DoNowAtWar

; 1502 : 				{
; 1503 : 					if(bWar)

	movzx	ecx, BYTE PTR _bWar$[ebp]
	test	ecx, ecx
	je	SHORT $LN30@DoNowAtWar

; 1504 : 						GET_PLAYER(eMinor).GetMinorCivAI()->DoNowAtWarWithTeam(eTeam);

	mov	edx, DWORD PTR _eMinor$223033[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232783[ebp], edx
	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T232783[ebp]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?DoNowAtWarWithTeam@CvMinorCivAI@@QAEXW4TeamTypes@@@Z ; CvMinorCivAI::DoNowAtWarWithTeam

; 1505 : 					else

	jmp	SHORT $LN32@DoNowAtWar
$LN30@DoNowAtWar:

; 1506 : 						GET_PLAYER(eMinor).GetMinorCivAI()->DoNowPeaceWithTeam(eTeam);

	mov	ecx, DWORD PTR _eMinor$223033[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232787[ebp], ecx
	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T232787[ebp]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?DoNowPeaceWithTeam@CvMinorCivAI@@QAEXW4TeamTypes@@@Z ; CvMinorCivAI::DoNowPeaceWithTeam
$LN32@DoNowAtWar:

; 1507 : 				}
; 1508 : 			}
; 1509 : 		}

	jmp	$LN34@DoNowAtWar
$LN36@DoNowAtWar:

; 1510 : 	}
; 1511 : 
; 1512 : 	if(bWar)

	movzx	eax, BYTE PTR _bWar$[ebp]
	test	eax, eax
	je	$LN37@DoNowAtWar

; 1513 : 	{
; 1514 : 		PlayerTypes eMinor;
; 1515 : 		PlayerTypes ePlayer;
; 1516 : 
; 1517 : 		// Loop through players on this team
; 1518 : 		for(int iPlayerCivLoop = 0; iPlayerCivLoop < MAX_MAJOR_CIVS; iPlayerCivLoop++)

	mov	DWORD PTR _iPlayerCivLoop$223046[ebp], 0
	jmp	SHORT $LN27@DoNowAtWar
$LN26@DoNowAtWar:
	mov	ecx, DWORD PTR _iPlayerCivLoop$223046[ebp]
	add	ecx, 1
	mov	DWORD PTR _iPlayerCivLoop$223046[ebp], ecx
$LN27@DoNowAtWar:
	cmp	DWORD PTR _iPlayerCivLoop$223046[ebp], 22 ; 00000016H
	jge	$LN37@DoNowAtWar

; 1519 : 		{
; 1520 : 			ePlayer = (PlayerTypes) iPlayerCivLoop;

	mov	edx, DWORD PTR _iPlayerCivLoop$223046[ebp]
	mov	DWORD PTR _ePlayer$223045[ebp], edx

; 1521 : 
; 1522 : 			if(!GET_PLAYER(ePlayer).isAlive())

	mov	eax, DWORD PTR _ePlayer$223045[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232791[ebp], eax
	mov	ecx, DWORD PTR $T232791[ebp]
	mov	dl, BYTE PTR [ecx+2256]
	mov	BYTE PTR $T232800[ebp], dl
	movzx	eax, BYTE PTR $T232800[ebp]
	test	eax, eax
	jne	SHORT $LN24@DoNowAtWar

; 1523 : 				continue;

	jmp	SHORT $LN26@DoNowAtWar
$LN24@DoNowAtWar:

; 1524 : 
; 1525 : 			if(GET_PLAYER(ePlayer).getTeam() != GetID())

	mov	ecx, DWORD PTR _ePlayer$223045[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232804[ebp], ecx
	mov	edx, DWORD PTR $T232804[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T232813[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T232813[ebp], eax
	je	SHORT $LN83@DoNowAtWar

; 1526 : 				continue;

	jmp	$LN26@DoNowAtWar

; 1527 : 
; 1528 : 			GET_PLAYER(ePlayer).SetDangerPlotsDirty();

$LN83@DoNowAtWar:
	mov	ecx, DWORD PTR _ePlayer$223045[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?SetDangerPlotsDirty@CvPlayer@@QAEXXZ	; CvPlayer::SetDangerPlotsDirty

; 1529 : 			GET_PLAYER(ePlayer).UpdateReligion();

	mov	ecx, DWORD PTR _ePlayer$223045[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?UpdateReligion@CvPlayer@@QAEXXZ	; CvPlayer::UpdateReligion

; 1530 : #ifdef AUI_CITIZENS_MID_TURN_ASSIGN_RUNS_SELF_CONSISTENCY
; 1531 : 			GET_PLAYER(ePlayer).doSelfConsistencyCheckAllCities();
; 1532 : #endif
; 1533 : 
; 1534 : 			// ******************************
; 1535 : 			// Our minor civ allies declare war on eTeam
; 1536 : 			// ******************************
; 1537 : 
; 1538 : 			FStaticVector<PlayerTypes, MAX_CIV_PLAYERS, true, c_eCiv5GameplayDLL, 0> veMinorAllies;

	lea	ecx, DWORD PTR _veMinorAllies$223199[ebp]
	call	??0?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum PlayerTypes,63,1,297,0>::FStaticVector<enum PlayerTypes,63,1,297,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1539 : 			for(int iMinorCivLoop = MAX_MAJOR_CIVS; iMinorCivLoop < MAX_CIV_PLAYERS; iMinorCivLoop++)

	mov	DWORD PTR _iMinorCivLoop$223200[ebp], 22 ; 00000016H
	jmp	SHORT $LN22@DoNowAtWar
$LN21@DoNowAtWar:
	mov	ecx, DWORD PTR _iMinorCivLoop$223200[ebp]
	add	ecx, 1
	mov	DWORD PTR _iMinorCivLoop$223200[ebp], ecx
$LN22@DoNowAtWar:
	cmp	DWORD PTR _iMinorCivLoop$223200[ebp], 63 ; 0000003fH
	jge	$LN20@DoNowAtWar

; 1540 : 			{
; 1541 : 				eMinor = (PlayerTypes) iMinorCivLoop;

	mov	edx, DWORD PTR _iMinorCivLoop$223200[ebp]
	mov	DWORD PTR _eMinor$223044[ebp], edx

; 1542 : 
; 1543 : 				// Must be alive
; 1544 : 				if(!GET_PLAYER(eMinor).isAlive())

	mov	eax, DWORD PTR _eMinor$223044[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232828[ebp], eax
	mov	ecx, DWORD PTR $T232828[ebp]
	mov	dl, BYTE PTR [ecx+2256]
	mov	BYTE PTR $T232837[ebp], dl
	movzx	eax, BYTE PTR $T232837[ebp]
	test	eax, eax
	jne	SHORT $LN19@DoNowAtWar

; 1545 : 					continue;

	jmp	SHORT $LN21@DoNowAtWar
$LN19@DoNowAtWar:

; 1546 : 
; 1547 : 				if(GET_PLAYER(eMinor).GetMinorCivAI()->IsAllies(ePlayer))

	mov	ecx, DWORD PTR _eMinor$223044[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232841[ebp], ecx
	mov	edx, DWORD PTR _ePlayer$223045[ebp]
	push	edx
	mov	ecx, DWORD PTR $T232841[ebp]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?IsAllies@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsAllies
	movzx	eax, al
	test	eax, eax
	je	$LN18@DoNowAtWar

; 1548 : 				{
; 1549 : 					// Don't declare war on self! (just in case)
; 1550 : 					if(GET_PLAYER(eMinor).getTeam() != eTeam)

	mov	ecx, DWORD PTR _eMinor$223044[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232845[ebp], ecx
	mov	edx, DWORD PTR $T232845[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	eax, DWORD PTR _eTeam$[ebp]
	je	$LN18@DoNowAtWar

; 1551 : 					{
; 1552 : #ifdef NQ_POLICY_TOGGLE_NO_MINOR_DOW_IF_FRIENDS
; 1553 : 						// this = team that declared war
; 1554 : 						// eTeam = team that is targeted for war
; 1555 : 						// ePlayer = current position of iterator over every major civ in the game on this team
; 1556 : 						// eMinor = current position of iterator over every city state in the game
; 1557 : 
; 1558 : 						bool bFriendshipPreventsWar = false;

	mov	BYTE PTR _bFriendshipPreventsWar$223208[ebp], 0

; 1559 : 						PlayerTypes eTargetPlayer;
; 1560 : 						for (int iTargetTeamCivLoop = 0; iTargetTeamCivLoop < MAX_MAJOR_CIVS; iTargetTeamCivLoop++)

	mov	DWORD PTR _iTargetTeamCivLoop$223210[ebp], 0
	jmp	SHORT $LN16@DoNowAtWar
$LN15@DoNowAtWar:
	mov	ecx, DWORD PTR _iTargetTeamCivLoop$223210[ebp]
	add	ecx, 1
	mov	DWORD PTR _iTargetTeamCivLoop$223210[ebp], ecx
$LN16@DoNowAtWar:
	cmp	DWORD PTR _iTargetTeamCivLoop$223210[ebp], 22 ; 00000016H
	jge	$LN14@DoNowAtWar

; 1561 : 						{
; 1562 : 							eTargetPlayer = (PlayerTypes) iTargetTeamCivLoop;

	mov	edx, DWORD PTR _iTargetTeamCivLoop$223210[ebp]
	mov	DWORD PTR _eTargetPlayer$223209[ebp], edx

; 1563 : 
; 1564 : 							if(GET_PLAYER(eTargetPlayer).isAlive() && GET_PLAYER(eTargetPlayer).getTeam() == eTeam)

	mov	eax, DWORD PTR _eTargetPlayer$223209[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232857[ebp], eax
	mov	ecx, DWORD PTR $T232857[ebp]
	mov	dl, BYTE PTR [ecx+2256]
	mov	BYTE PTR $T232866[ebp], dl
	movzx	eax, BYTE PTR $T232866[ebp]
	test	eax, eax
	je	$LN13@DoNowAtWar
	mov	ecx, DWORD PTR _eTargetPlayer$223209[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232870[ebp], ecx
	mov	edx, DWORD PTR $T232870[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	eax, DWORD PTR _eTeam$[ebp]
	jne	SHORT $LN13@DoNowAtWar

; 1565 : 							{
; 1566 : 								if (GET_PLAYER(eTargetPlayer).IsNoMinorDOWIfFriends() && GET_PLAYER(eMinor).GetMinorCivAI()->IsFriends(eTargetPlayer))

	mov	ecx, DWORD PTR _eTargetPlayer$223209[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232882[ebp], ecx
	mov	ecx, DWORD PTR $T232882[ebp]
	call	?IsNoMinorDOWIfFriends@CvPlayer@@QBE_NXZ ; CvPlayer::IsNoMinorDOWIfFriends
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN13@DoNowAtWar
	mov	eax, DWORD PTR _eMinor$223044[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232886[ebp], eax
	mov	ecx, DWORD PTR _eTargetPlayer$223209[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T232886[ebp]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?IsFriends@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsFriends
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN13@DoNowAtWar

; 1567 : 								{
; 1568 : 									bFriendshipPreventsWar = true;

	mov	BYTE PTR _bFriendshipPreventsWar$223208[ebp], 1
$LN13@DoNowAtWar:

; 1569 : 								}
; 1570 : 							}
; 1571 : 						}

	jmp	$LN15@DoNowAtWar
$LN14@DoNowAtWar:

; 1572 : 
; 1573 : 						if (!bFriendshipPreventsWar)

	movzx	eax, BYTE PTR _bFriendshipPreventsWar$223208[ebp]
	test	eax, eax
	jne	SHORT $LN18@DoNowAtWar

; 1574 : 						{
; 1575 : 							// Match war state
; 1576 : 							GET_TEAM(GET_PLAYER(eMinor).getTeam()).DoDeclareWar(eTeam, /*bDefensivePact*/ false, /*bMinorAllyPact*/ true);

	mov	ecx, DWORD PTR _eMinor$223044[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232890[ebp], ecx
	mov	edx, DWORD PTR $T232890[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T232899[ebp], eax
	push	1
	push	0
	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T232899[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z ; CvTeam::DoDeclareWar

; 1577 : 
; 1578 : 							// Add to vector for notification sent out
; 1579 : 							veMinorAllies.push_back(eMinor);

	lea	edx, DWORD PTR _eMinor$223044[ebp]
	push	edx
	lea	ecx, DWORD PTR _veMinorAllies$223199[ebp]
	call	?push_back@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAEIABW4PlayerTypes@@@Z ; FStaticVector<enum PlayerTypes,63,1,297,0>::push_back
$LN18@DoNowAtWar:

; 1580 : 						}
; 1581 : 					
; 1582 : #else
; 1583 : 						// Match war state
; 1584 : 						GET_TEAM(GET_PLAYER(eMinor).getTeam()).DoDeclareWar(eTeam, /*bDefensivePact*/ false, /*bMinorAllyPact*/ true);
; 1585 : 
; 1586 : 						// Add to vector for notification sent out
; 1587 : 						veMinorAllies.push_back(eMinor);
; 1588 : #endif
; 1589 : 					}
; 1590 : 				}
; 1591 : 			}

	jmp	$LN21@DoNowAtWar
$LN20@DoNowAtWar:

; 1592 : 
; 1593 : 			// Notifications about minor allies that join the war against a major civ
; 1594 : 			if(!veMinorAllies.empty())

	mov	eax, DWORD PTR _veMinorAllies$223199[ebp+4]
	mov	DWORD PTR $T232914[ebp], eax
	xor	ecx, ecx
	cmp	DWORD PTR $T232914[ebp], 0
	sete	cl
	movzx	edx, cl
	test	edx, edx
	jne	$LN10@DoNowAtWar

; 1595 : 			{
; 1596 : 				if(!GET_TEAM(eTeam).isMinorCiv())

	mov	eax, DWORD PTR _eTeam$[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T232922[ebp], eax
	mov	ecx, DWORD PTR $T232922[ebp]
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN10@DoNowAtWar

; 1597 : 				{
; 1598 : 					Localization::String strTemp;

	lea	ecx, DWORD PTR _strTemp$223220[ebp]
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1599 : 
; 1600 : 					// Notification for us...allies got our back!
; 1601 : 					Localization::String strOurAlliesSummary = Localization::Lookup("TXT_KEY_MISC_YOUR_MINOR_ALLIES_DECLARED_WAR_SUMMARY");

	push	OFFSET ??_C@_0DE@BEJHFIBA@TXT_KEY_MISC_YOUR_MINOR_ALLIES_D@
	lea	edx, DWORD PTR _strOurAlliesSummary$223221[ebp]
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1602 : 					strTemp = Localization::Lookup("TXT_KEY_MISC_YOUR_MINOR_ALLIES_DECLARED_WAR");

	push	OFFSET ??_C@_0CM@MDLFPNAG@TXT_KEY_MISC_YOUR_MINOR_ALLIES_D@
	lea	eax, DWORD PTR $T232726[ebp]
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR tv300[ebp], eax
	mov	ecx, DWORD PTR tv300[ebp]
	mov	DWORD PTR tv542[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	edx, DWORD PTR tv542[ebp]
	push	edx
	lea	ecx, DWORD PTR _strTemp$223220[ebp]
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T232726[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1603 : 					strTemp << GET_TEAM(eTeam).getName().GetCString();

	mov	eax, DWORD PTR _eTeam$[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T232926[ebp], eax
	lea	ecx, DWORD PTR $T232728[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T232926[ebp]
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	DWORD PTR tv298[ebp], eax
	mov	edx, DWORD PTR tv298[ebp]
	mov	DWORD PTR $T232930[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR $T232930[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T232727[ebp], eax
	lea	eax, DWORD PTR $T232727[ebp]
	push	eax
	lea	ecx, DWORD PTR _strTemp$223220[ebp]
	push	ecx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T232728[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1604 : 					CvString strOurAlliesMessage = strTemp.toUTF8();

	lea	ecx, DWORD PTR _strTemp$223220[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	mov	DWORD PTR $T232943[ebp], eax
	cmp	DWORD PTR $T232943[ebp], 0
	je	SHORT $LN152@DoNowAtWar
	mov	edx, DWORD PTR $T232943[ebp]
	mov	DWORD PTR tv682[ebp], edx
	jmp	SHORT $LN153@DoNowAtWar
$LN152@DoNowAtWar:
	mov	DWORD PTR tv682[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN153@DoNowAtWar:
	mov	eax, DWORD PTR tv682[ebp]
	push	eax
	lea	ecx, DWORD PTR _strOurAlliesMessage$223228[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5

; 1605 : 
; 1606 : 					// Notification for players on the other team
; 1607 : 					Localization::String strTheirEnemiesSummary = Localization::Lookup("TXT_KEY_MISC_MINOR_ALLIES_DECLARED_WAR_ON_YOU_SUMMARY");

	push	OFFSET ??_C@_0DG@PIFENIBB@TXT_KEY_MISC_MINOR_ALLIES_DECLAR@
	lea	ecx, DWORD PTR _strTheirEnemiesSummary$223229[ebp]
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[ebp+8], 6

; 1608 : 					strTemp = Localization::Lookup("TXT_KEY_MISC_MINOR_ALLIES_DECLARED_WAR_ON_YOU");

	push	OFFSET ??_C@_0CO@IPNHMNOP@TXT_KEY_MISC_MINOR_ALLIES_DECLAR@
	lea	edx, DWORD PTR $T232729[ebp]
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR tv328[ebp], eax
	mov	eax, DWORD PTR tv328[ebp]
	mov	DWORD PTR tv548[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	ecx, DWORD PTR tv548[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strTemp$223220[ebp]
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR $T232729[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1609 : 					strTemp << getName().GetCString();

	lea	edx, DWORD PTR $T232731[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	DWORD PTR tv185[ebp], eax
	mov	eax, DWORD PTR tv185[ebp]
	mov	DWORD PTR $T232947[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	ecx, DWORD PTR $T232947[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T232730[ebp], eax
	lea	ecx, DWORD PTR $T232730[ebp]
	push	ecx
	lea	edx, DWORD PTR _strTemp$223220[ebp]
	push	edx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR $T232731[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1610 : 					CvString strTheirEnemiesMessage = strTemp.toUTF8();

	lea	ecx, DWORD PTR _strTemp$223220[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	mov	DWORD PTR $T232960[ebp], eax
	cmp	DWORD PTR $T232960[ebp], 0
	je	SHORT $LN162@DoNowAtWar
	mov	eax, DWORD PTR $T232960[ebp]
	mov	DWORD PTR tv737[ebp], eax
	jmp	SHORT $LN163@DoNowAtWar
$LN162@DoNowAtWar:
	mov	DWORD PTR tv737[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN163@DoNowAtWar:
	mov	ecx, DWORD PTR tv737[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strTheirEnemiesMessage$223236[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 9

; 1611 : 
; 1612 : 					for(uint iMinorCivLoop = 0; iMinorCivLoop < veMinorAllies.size(); iMinorCivLoop++)

	mov	DWORD PTR _iMinorCivLoop$223237[ebp], 0
	jmp	SHORT $LN8@DoNowAtWar
$LN7@DoNowAtWar:
	mov	edx, DWORD PTR _iMinorCivLoop$223237[ebp]
	add	edx, 1
	mov	DWORD PTR _iMinorCivLoop$223237[ebp], edx
$LN8@DoNowAtWar:
	mov	eax, DWORD PTR _veMinorAllies$223199[ebp+4]
	mov	DWORD PTR $T232964[ebp], eax
	mov	ecx, DWORD PTR _iMinorCivLoop$223237[ebp]
	cmp	ecx, DWORD PTR $T232964[ebp]
	jae	$LN6@DoNowAtWar

; 1613 : 					{
; 1614 : 						eMinor = veMinorAllies[iMinorCivLoop];

	mov	edx, DWORD PTR _iMinorCivLoop$223237[ebp]
	mov	eax, DWORD PTR _veMinorAllies$223199[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _eMinor$223044[ebp], ecx

; 1615 : 						strTemp = Localization::Lookup(GET_TEAM(GET_PLAYER(eMinor).getTeam()).getName().GetCString());

	mov	edx, DWORD PTR _eMinor$223044[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232971[ebp], edx
	mov	eax, DWORD PTR $T232971[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T232980[ebp], eax
	mov	edx, DWORD PTR $T232980[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T232984[ebp], edx
	lea	eax, DWORD PTR $T232732[ebp]
	push	eax
	mov	ecx, DWORD PTR $T232984[ebp]
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	DWORD PTR tv703[ebp], eax
	mov	ecx, DWORD PTR tv703[ebp]
	mov	DWORD PTR $T232988[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	ecx, DWORD PTR $T232988[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T232989[ebp], eax
	mov	edx, DWORD PTR $T232989[ebp]
	push	edx
	lea	eax, DWORD PTR $T232733[ebp]
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR tv680[ebp], eax
	mov	ecx, DWORD PTR tv680[ebp]
	mov	DWORD PTR tv555[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	mov	edx, DWORD PTR tv555[ebp]
	push	edx
	lea	ecx, DWORD PTR _strTemp$223220[ebp]
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	lea	ecx, DWORD PTR $T232733[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	lea	ecx, DWORD PTR $T232732[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1616 : 						strOurAlliesMessage = strOurAlliesMessage + "[NEWLINE]" + strTemp.toUTF8();

	push	OFFSET ??_C@_09ODCIJKAA@?$FLNEWLINE?$FN?$AA@
	lea	eax, DWORD PTR _strOurAlliesMessage$223228[ebp]
	push	eax
	lea	ecx, DWORD PTR $T232734[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv828[ebp], eax
	mov	edx, DWORD PTR tv828[ebp]
	mov	DWORD PTR tv557[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	lea	ecx, DWORD PTR _strTemp$223220[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	mov	eax, DWORD PTR tv557[ebp]
	push	eax
	lea	ecx, DWORD PTR $T232735[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv827[ebp], eax
	mov	edx, DWORD PTR tv827[ebp]
	mov	DWORD PTR $T232997[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH
	mov	ecx, DWORD PTR $T232997[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOurAlliesMessage$223228[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	lea	ecx, DWORD PTR $T232735[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	lea	ecx, DWORD PTR $T232734[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1617 : 						strTheirEnemiesMessage = strTheirEnemiesMessage + "[NEWLINE]" + strTemp.toUTF8();

	push	OFFSET ??_C@_09ODCIJKAA@?$FLNEWLINE?$FN?$AA@
	lea	eax, DWORD PTR _strTheirEnemiesMessage$223236[ebp]
	push	eax
	lea	ecx, DWORD PTR $T232736[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv826[ebp], eax
	mov	edx, DWORD PTR tv826[ebp]
	mov	DWORD PTR tv561[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH
	lea	ecx, DWORD PTR _strTemp$223220[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	mov	eax, DWORD PTR tv561[ebp]
	push	eax
	lea	ecx, DWORD PTR $T232737[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv831[ebp], eax
	mov	edx, DWORD PTR tv831[ebp]
	mov	DWORD PTR $T233001[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 15		; 0000000fH
	mov	ecx, DWORD PTR $T233001[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTheirEnemiesMessage$223236[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH
	lea	ecx, DWORD PTR $T232737[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	lea	ecx, DWORD PTR $T232736[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1618 : 					}

	jmp	$LN7@DoNowAtWar
$LN6@DoNowAtWar:

; 1619 : 
; 1620 : 					GET_PLAYER(ePlayer).GetNotifications()->Add(NOTIFICATION_WAR, strOurAlliesMessage, strOurAlliesSummary.toUTF8(), -1, -1, veMinorAllies.front(), eTeam);

	mov	eax, DWORD PTR _veMinorAllies$223199[ebp]
	mov	DWORD PTR $T233005[ebp], eax
	lea	ecx, DWORD PTR _strOurAlliesMessage$223228[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233009[ebp], eax
	mov	ecx, DWORD PTR _ePlayer$223045[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233013[ebp], ecx
	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	eax, DWORD PTR $T233005[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	-1
	push	-1
	lea	ecx, DWORD PTR _strOurAlliesSummary$223221[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	mov	edx, DWORD PTR $T233009[ebp]
	push	edx
	push	-958154983				; c6e3b719H
	mov	ecx, DWORD PTR $T233013[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ecx, eax
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 1621 : 
; 1622 : 					for(int iOtherPlayerCivLoop = 0; iOtherPlayerCivLoop < MAX_MAJOR_CIVS; iOtherPlayerCivLoop++)

	mov	DWORD PTR _iOtherPlayerCivLoop$223248[ebp], 0
	jmp	SHORT $LN5@DoNowAtWar
$LN4@DoNowAtWar:
	mov	eax, DWORD PTR _iOtherPlayerCivLoop$223248[ebp]
	add	eax, 1
	mov	DWORD PTR _iOtherPlayerCivLoop$223248[ebp], eax
$LN5@DoNowAtWar:
	cmp	DWORD PTR _iOtherPlayerCivLoop$223248[ebp], 22 ; 00000016H
	jge	$LN3@DoNowAtWar

; 1623 : 					{
; 1624 : 						PlayerTypes eOtherPlayer = (PlayerTypes) iOtherPlayerCivLoop;

	mov	ecx, DWORD PTR _iOtherPlayerCivLoop$223248[ebp]
	mov	DWORD PTR _eOtherPlayer$223252[ebp], ecx

; 1625 : 
; 1626 : 						if(!GET_PLAYER(eOtherPlayer).isAlive())

	mov	edx, DWORD PTR _eOtherPlayer$223252[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233017[ebp], edx
	mov	eax, DWORD PTR $T233017[ebp]
	mov	cl, BYTE PTR [eax+2256]
	mov	BYTE PTR $T233026[ebp], cl
	movzx	edx, BYTE PTR $T233026[ebp]
	test	edx, edx
	jne	SHORT $LN2@DoNowAtWar

; 1627 : 							continue;

	jmp	SHORT $LN4@DoNowAtWar
$LN2@DoNowAtWar:

; 1628 : 
; 1629 : 						if(GET_PLAYER(eOtherPlayer).getTeam() != eTeam)

	mov	eax, DWORD PTR _eOtherPlayer$223252[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233030[ebp], eax
	mov	ecx, DWORD PTR $T233030[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	eax, DWORD PTR _eTeam$[ebp]
	je	SHORT $LN1@DoNowAtWar

; 1630 : 							continue;

	jmp	$LN4@DoNowAtWar
$LN1@DoNowAtWar:

; 1631 : 
; 1632 : 						GET_PLAYER(eOtherPlayer).GetNotifications()->Add(NOTIFICATION_WAR_ACTIVE_PLAYER, strTheirEnemiesMessage, strTheirEnemiesSummary.toUTF8(), -1, -1, veMinorAllies.front());

	mov	eax, DWORD PTR _veMinorAllies$223199[ebp]
	mov	DWORD PTR $T233042[ebp], eax
	lea	ecx, DWORD PTR _strTheirEnemiesMessage$223236[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233046[ebp], eax
	mov	ecx, DWORD PTR _eOtherPlayer$223252[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233050[ebp], ecx
	push	-1
	mov	edx, DWORD PTR $T233042[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	-1
	push	-1
	lea	ecx, DWORD PTR _strTheirEnemiesSummary$223229[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	mov	ecx, DWORD PTR $T233046[ebp]
	push	ecx
	push	-190211195				; f4a99b85H
	mov	ecx, DWORD PTR $T233050[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ecx, eax
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 1633 : 					}

	jmp	$LN4@DoNowAtWar
$LN3@DoNowAtWar:

; 1634 : 
; 1635 : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR _strTheirEnemiesMessage$223236[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR _strTheirEnemiesSummary$223229[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _strOurAlliesMessage$223228[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strOurAlliesSummary$223221[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strTemp$223220[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN10@DoNowAtWar:

; 1636 : 			}
; 1637 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _veMinorAllies$223199[ebp]
	call	??1?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum PlayerTypes,63,1,297,0>::~FStaticVector<enum PlayerTypes,63,1,297,0>
	jmp	$LN26@DoNowAtWar
$LN37@DoNowAtWar:

; 1638 : 	}
; 1639 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$0:
	lea	ecx, DWORD PTR _veMinorAllies$223199[ebp]
	jmp	??1?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum PlayerTypes,63,1,297,0>::~FStaticVector<enum PlayerTypes,63,1,297,0>
__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$1:
	lea	ecx, DWORD PTR _strTemp$223220[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$2:
	lea	ecx, DWORD PTR _strOurAlliesSummary$223221[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$3:
	lea	ecx, DWORD PTR $T232726[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$4:
	lea	ecx, DWORD PTR $T232728[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$5:
	lea	ecx, DWORD PTR _strOurAlliesMessage$223228[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$6:
	lea	ecx, DWORD PTR _strTheirEnemiesSummary$223229[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$7:
	lea	ecx, DWORD PTR $T232729[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$8:
	lea	ecx, DWORD PTR $T232731[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$9:
	lea	ecx, DWORD PTR _strTheirEnemiesMessage$223236[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$10:
	lea	ecx, DWORD PTR $T232732[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$11:
	lea	ecx, DWORD PTR $T232733[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$12:
	lea	ecx, DWORD PTR $T232734[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$13:
	lea	ecx, DWORD PTR $T232735[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$14:
	lea	ecx, DWORD PTR $T232736[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$15:
	lea	ecx, DWORD PTR $T232737[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1344]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z ENDP	; CvTeam::DoNowAtWarOrPeace
PUBLIC	?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z	; CvTeam::DoMakePeace
PUBLIC	?makePeace@CvTeam@@QAEXW4TeamTypes@@_N1@Z	; CvTeam::makePeace
; Function compile flags: /Odtp
;	COMDAT ?makePeace@CvTeam@@QAEXW4TeamTypes@@_N1@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eTeam$ = 8						; size = 4
_bBumpUnits$ = 12					; size = 1
_bSuppressNotification$ = 16				; size = 1
?makePeace@CvTeam@@QAEXW4TeamTypes@@_N1@Z PROC		; CvTeam::makePeace, COMDAT
; _this$ = ecx

; 1643 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1644 : 	DoMakePeace(eTeam, bBumpUnits, bSuppressNotification);

	movzx	eax, BYTE PTR _bSuppressNotification$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _bBumpUnits$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z ; CvTeam::DoMakePeace

; 1645 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?makePeace@CvTeam@@QAEXW4TeamTypes@@_N1@Z ENDP		; CvTeam::makePeace
_TEXT	ENDS
PUBLIC	??_C@_0CA@PLFHIHOA@TXT_KEY_MISC_SOMEONE_MADE_PEACE?$AA@ ; `string'
PUBLIC	??_C@_0CB@PIHAMCD@TXT_KEY_MISC_YOU_MADE_PEACE_WITH@ ; `string'
PUBLIC	??_C@_0DC@ENNIBDOM@TXT_KEY_MISC_YOUR_MINOR_ALLIES_M@ ; `string'
PUBLIC	??_C@_0CK@DNBPPBFC@TXT_KEY_MISC_YOUR_MINOR_ALLIES_M@ ; `string'
PUBLIC	?SetTurnMadePeaceTreatyWithTeam@CvTeam@@QAEXW4TeamTypes@@H@Z ; CvTeam::SetTurnMadePeaceTreatyWithTeam
PUBLIC	??_C@_09OEPLNLOG@MakePeace?$AA@			; `string'
PUBLIC	__$ArrayPad$
EXTRN	?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z:PROC ; CvMilitaryAI::LogPeace
EXTRN	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ:PROC ; CvPlayer::GetMilitaryAI
EXTRN	?DoWeMadePeaceWithSomeone@CvDiplomacyAI@@QAEXW4TeamTypes@@@Z:PROC ; CvDiplomacyAI::DoWeMadePeaceWithSomeone
EXTRN	?IsPermanentWar@CvMinorCivAI@@QBE_NW4TeamTypes@@@Z:PROC ; CvMinorCivAI::IsPermanentWar
EXTRN	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ:PROC ; CvMinorCivAI::GetAlly
;	COMDAT ??_C@_0CA@PLFHIHOA@TXT_KEY_MISC_SOMEONE_MADE_PEACE?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0CA@PLFHIHOA@TXT_KEY_MISC_SOMEONE_MADE_PEACE?$AA@ DB 'TXT_KEY_MISC_'
	DB	'SOMEONE_MADE_PEACE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@PIHAMCD@TXT_KEY_MISC_YOU_MADE_PEACE_WITH@
CONST	SEGMENT
??_C@_0CB@PIHAMCD@TXT_KEY_MISC_YOU_MADE_PEACE_WITH@ DB 'TXT_KEY_MISC_YOU_'
	DB	'MADE_PEACE_WITH', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@ENNIBDOM@TXT_KEY_MISC_YOUR_MINOR_ALLIES_M@
CONST	SEGMENT
??_C@_0DC@ENNIBDOM@TXT_KEY_MISC_YOUR_MINOR_ALLIES_M@ DB 'TXT_KEY_MISC_YOU'
	DB	'R_MINOR_ALLIES_MADE_PEACE_SUMMARY', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@DNBPPBFC@TXT_KEY_MISC_YOUR_MINOR_ALLIES_M@
CONST	SEGMENT
??_C@_0CK@DNBPPBFC@TXT_KEY_MISC_YOUR_MINOR_ALLIES_M@ DB 'TXT_KEY_MISC_YOU'
	DB	'R_MINOR_ALLIES_MADE_PEACE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09OEPLNLOG@MakePeace?$AA@
CONST	SEGMENT
??_C@_09OEPLNLOG@MakePeace?$AA@ DB 'MakePeace', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z DD 019930522H
	DD	016H
	DD	FLAT:__unwindtable$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$5
	DD	04H
	DD	FLAT:__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$8
	DD	06H
	DD	FLAT:__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$9
	DD	09H
	DD	FLAT:__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$10
	DD	00H
	DD	FLAT:__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$11
	DD	0bH
	DD	FLAT:__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$12
	DD	0bH
	DD	FLAT:__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$13
	DD	0bH
	DD	FLAT:__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$14
	DD	0bH
	DD	FLAT:__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$15
	DD	0bH
	DD	FLAT:__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$16
	DD	0bH
	DD	FLAT:__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$17
	DD	011H
	DD	FLAT:__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$18
	DD	0bH
	DD	FLAT:__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$19
	DD	013H
	DD	FLAT:__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$20
	DD	014H
	DD	FLAT:__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$21
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z
_TEXT	SEGMENT
tv1218 = -1740						; size = 4
tv1217 = -1736						; size = 4
tv1216 = -1732						; size = 4
tv1215 = -1728						; size = 4
tv1214 = -1724						; size = 4
tv839 = -1720						; size = 4
tv1213 = -1716						; size = 4
tv1212 = -1712						; size = 4
tv835 = -1708						; size = 4
tv66 = -1704						; size = 4
tv855 = -1700						; size = 4
tv831 = -1696						; size = 4
tv555 = -1692						; size = 4
tv509 = -1688						; size = 4
tv497 = -1684						; size = 4
tv999 = -1680						; size = 4
tv826 = -1676						; size = 4
tv95 = -1672						; size = 4
tv824 = -1668						; size = 4
tv204 = -1664						; size = 4
tv327 = -1660						; size = 4
tv1001 = -1656						; size = 4
tv331 = -1652						; size = 4
tv141 = -1648						; size = 4
tv132 = -1644						; size = 4
tv89 = -1640						; size = 4
_this$ = -1636						; size = 4
$T233614 = -1632					; size = 4
$T233598 = -1628					; size = 4
$T233594 = -1624					; size = 4
$T233590 = -1620					; size = 4
$T233586 = -1616					; size = 4
$T233582 = -1612					; size = 4
$T233570 = -1608					; size = 4
$T233566 = -1604					; size = 4
$T233562 = -1600					; size = 4
$T233558 = -1596					; size = 4
$T233554 = -1592					; size = 4
$T233550 = -1588					; size = 4
$T233541 = -1584					; size = 4
$T233537 = -1580					; size = 4
$T233533 = -1576					; size = 4
$T233524 = -1572					; size = 4
$T233520 = -1568					; size = 4
$T233512 = -1564					; size = 4
$T233508 = -1560					; size = 4
$T233496 = -1556					; size = 4
$T233492 = -1552					; size = 4
$T233484 = -1548					; size = 4
$T233480 = -1544					; size = 4
$T233476 = -1540					; size = 4
$T233472 = -1536					; size = 4
$T233463 = -1532					; size = 4
$T233459 = -1525					; size = 1
$T233450 = -1524					; size = 4
$T233438 = -1520					; size = 4
$T233429 = -1513					; size = 1
$T233417 = -1512					; size = 4
$T233413 = -1508					; size = 4
$T233409 = -1504					; size = 4
$T233405 = -1500					; size = 4
$T233385 = -1488					; size = 4
$T233381 = -1484					; size = 4
$T233377 = -1480					; size = 4
$T233373 = -1476					; size = 4
$T233369 = -1472					; size = 4
$T233361 = -1468					; size = 4
$T233360 = -1464					; size = 4
$T233356 = -1460					; size = 4
$T233352 = -1456					; size = 4
$T233343 = -1452					; size = 4
$T233336 = -1448					; size = 4
$T233332 = -1444					; size = 4
$T233319 = -1440					; size = 4
$T233315 = -1436					; size = 4
$T233307 = -1432					; size = 4
$T233292 = -1424					; size = 4
$T233283 = -1420					; size = 4
$T233279 = -1416					; size = 4
$T233275 = -1412					; size = 4
$T233271 = -1408					; size = 4
$T233262 = -1404					; size = 4
$T233258 = -1400					; size = 4
$T233249 = -1396					; size = 4
$T233245 = -1392					; size = 4
$T233241 = -1385					; size = 1
$T233232 = -1384					; size = 4
$T233220 = -1380					; size = 4
$T233216 = -1376					; size = 4
$T233212 = -1369					; size = 1
$T233203 = -1368					; size = 4
$T233194 = -1364					; size = 4
$T233185 = -1360					; size = 4
$T233181 = -1356					; size = 4
$T233177 = -1352					; size = 4
$T233173 = -1348					; size = 4
$T233169 = -1344					; size = 4
$T233165 = -1340					; size = 4
$T233152 = -1336					; size = 4
$T233148 = -1332					; size = 4
$T233118 = -1328					; size = 28
$T233117 = -1300					; size = 28
$T233116 = -1272					; size = 4
$T233115 = -1268					; size = 28
$T233114 = -1240					; size = 4
$T233113 = -1236					; size = 28
$T233112 = -1208					; size = 4
$T233111 = -1204					; size = 28
$T233110 = -1176					; size = 4
$T233109 = -1172					; size = 80
$T233108 = -1092					; size = 28
$T233107 = -1064					; size = 4
$T233106 = -1060					; size = 80
$T233105 = -980						; size = 28
$T233104 = -952						; size = 4
$T233103 = -948						; size = 80
$T233102 = -868						; size = 28
$T233101 = -840						; size = 28
$T233100 = -812						; size = 80
$T233099 = -732						; size = 28
$T233098 = -704						; size = 28
$T233097 = -676						; size = 4
_ePlayer$223352 = -672					; size = 4
_iOurPlayerLoop$223341 = -668				; size = 4
_eMinor$223331 = -664					; size = 4
_iMinorCivLoop$223327 = -660				; size = 4
_strMessage$223326 = -656				; size = 28
_strSummary$223321 = -628				; size = 80
_strTemp$223318 = -548					; size = 80
_veMinorAllies$223296 = -468				; size = 268
_eOurMinor$223281 = -196				; size = 4
_iThirdPartyLoop$223286 = -192				; size = 4
_iMakingPeaceWithMinorLoop$223288 = -188		; size = 4
_iPlayerLoop$223284 = -184				; size = 4
_eThirdParty$223285 = -180				; size = 4
_bPeaceBlocked$223289 = -173				; size = 1
_iMinorLoop$223282 = -172				; size = 4
_eOurPlayer$223283 = -168				; size = 4
_eMakingPeaceWithMinor$223287 = -164			; size = 4
_bResult$223274 = -157					; size = 1
_args$223273 = -156					; size = 4
_iCurrentTurn$223277 = -152				; size = 4
_pOurPlayer$223339 = -148				; size = 4
_eTeamWeMadePeaceWith$223278 = -144			; size = 4
_locString$223350 = -140				; size = 80
_eOurPlayer$223340 = -56				; size = 4
_pkScriptSystem$223271 = -52				; size = 4
_strBuffer$ = -48					; size = 28
__$ArrayPad$ = -20					; size = 4
_iI$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_eTeam$ = 8						; size = 4
_bBumpUnits$ = 12					; size = 1
_bSuppressNotification$ = 16				; size = 1
?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z PROC	; CvTeam::DoMakePeace, COMDAT
; _this$ = ecx

; 1650 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1728				; 000006c0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1651 : 	CvString strBuffer;

	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1652 : 	int iI;
; 1653 : 
; 1654 : 	CvAssertMsg(eTeam != NO_TEAM, "eTeam is not assigned a valid value");
; 1655 : 	CvAssertMsg(eTeam != GetID(), "eTeam is not expected to be equal with GetID()");
; 1656 : 
; 1657 : 	if(isAtWar(eTeam))

	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	ecx, al
	test	ecx, ecx
	je	$LN53@DoMakePeac

; 1658 : 	{
; 1659 : 		setAtWar(eTeam, false);

	push	0
	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setAtWar@CvTeam@@QAEXW4TeamTypes@@_N@Z	; CvTeam::setAtWar

; 1660 : 		GET_TEAM(eTeam).setAtWar(GetID(), false);

	mov	eax, DWORD PTR _eTeam$[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T233148[ebp], eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	ecx, DWORD PTR $T233148[ebp]
	call	?setAtWar@CvTeam@@QAEXW4TeamTypes@@_N@Z	; CvTeam::setAtWar

; 1661 : 
; 1662 : 		ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR $T233152[ebp]
	mov	DWORD PTR tv89[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv89[ebp], edx
	mov	eax, DWORD PTR tv89[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv89[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pkScriptSystem$223271[ebp], eax

; 1663 : 		if (pkScriptSystem)

	cmp	DWORD PTR _pkScriptSystem$223271[ebp], 0
	je	$LN52@DoMakePeac

; 1664 : 		{
; 1665 : 			CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$223273[ebp]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1666 : 			args->Push(GetID());

	mov	ecx, DWORD PTR _args$223273[ebp]
	mov	DWORD PTR tv132[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	edx, DWORD PTR tv132[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv132[ebp]
	mov	edx, DWORD PTR [eax+8]
	call	edx

; 1667 : 			args->Push(eTeam);

	mov	eax, DWORD PTR _args$223273[ebp]
	mov	DWORD PTR tv141[ebp], eax
	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv141[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv141[ebp]
	mov	edx, DWORD PTR [eax+8]
	call	edx

; 1668 : 
; 1669 : 			bool bResult;
; 1670 : 			LuaSupport::CallHook(pkScriptSystem, "MakePeace", args.get(), bResult);

	lea	eax, DWORD PTR _bResult$223274[ebp]
	push	eax
	mov	ecx, DWORD PTR _args$223273[ebp]
	push	ecx
	push	OFFSET ??_C@_09OEPLNLOG@MakePeace?$AA@
	mov	edx, DWORD PTR _pkScriptSystem$223271[ebp]
	push	edx
	call	?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallHook
	add	esp, 16					; 00000010H

; 1671 : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _args$223273[ebp]
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN52@DoMakePeac:

; 1672 : 
; 1673 : 		// One shot things
; 1674 : 		DoNowAtWarOrPeace(eTeam, false);

	push	0
	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z ; CvTeam::DoNowAtWarOrPeace

; 1675 : 		GET_TEAM(eTeam).DoNowAtWarOrPeace(GetID(), false);

	mov	ecx, DWORD PTR _eTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T233165[ebp], ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	ecx, DWORD PTR $T233165[ebp]
	call	?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z ; CvTeam::DoNowAtWarOrPeace

; 1676 : 
; 1677 : 		// Move Units that shouldn't be in each others' territory any more
; 1678 : 		if(bBumpUnits)

	movzx	edx, BYTE PTR _bBumpUnits$[ebp]
	test	edx, edx
	je	SHORT $LN51@DoMakePeac

; 1679 : 		{
; 1680 : 			GC.getMap().verifyUnitValidPlot();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T233169[ebp], eax
	mov	ecx, DWORD PTR $T233169[ebp]
	call	?verifyUnitValidPlot@CvMap@@QAEXXZ	; CvMap::verifyUnitValidPlot
$LN51@DoMakePeac:

; 1681 : 		}
; 1682 : 
; 1683 : 		// Both of us have now made a peace treaty.  Keep track of this in case either one breaks the agreement
; 1684 : 		int iCurrentTurn = GC.getGame().getElapsedGameTurns();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T233173[ebp], ecx
	mov	ecx, DWORD PTR $T233173[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	mov	DWORD PTR _iCurrentTurn$223277[ebp], eax

; 1685 : 		SetTurnMadePeaceTreatyWithTeam(eTeam, iCurrentTurn);

	mov	edx, DWORD PTR _iCurrentTurn$223277[ebp]
	push	edx
	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTurnMadePeaceTreatyWithTeam@CvTeam@@QAEXW4TeamTypes@@H@Z ; CvTeam::SetTurnMadePeaceTreatyWithTeam

; 1686 : 		GET_TEAM(eTeam).SetTurnMadePeaceTreatyWithTeam(GetID(), iCurrentTurn);

	mov	ecx, DWORD PTR _eTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T233177[ebp], ecx
	mov	edx, DWORD PTR _iCurrentTurn$223277[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	ecx, DWORD PTR $T233177[ebp]
	call	?SetTurnMadePeaceTreatyWithTeam@CvTeam@@QAEXW4TeamTypes@@H@Z ; CvTeam::SetTurnMadePeaceTreatyWithTeam

; 1687 : 
; 1688 : 		TeamTypes eTeamWeMadePeaceWith = eTeam;

	mov	eax, DWORD PTR _eTeam$[ebp]
	mov	DWORD PTR _eTeamWeMadePeaceWith$223278[ebp], eax

; 1689 : 
; 1690 : 		if(!isMinorCiv())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN50@DoMakePeac

; 1691 : 		{
; 1692 : 			// Made peace with a minor - see if we have allied minors which should also make peace
; 1693 : 			if(GET_TEAM(eTeamWeMadePeaceWith).isMinorCiv())

	mov	edx, DWORD PTR _eTeamWeMadePeaceWith$223278[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T233181[ebp], edx
	mov	ecx, DWORD PTR $T233181[ebp]
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	movzx	eax, al
	test	eax, eax
	je	$LN50@DoMakePeac

; 1694 : 			{
; 1695 : 				PlayerTypes eOurMinor;
; 1696 : 				int iMinorLoop;
; 1697 : 
; 1698 : 				PlayerTypes eOurPlayer;
; 1699 : 				int iPlayerLoop;
; 1700 : 
; 1701 : 				PlayerTypes eThirdParty;
; 1702 : 				int iThirdPartyLoop;
; 1703 : 
; 1704 : 				PlayerTypes eMakingPeaceWithMinor;
; 1705 : 				int iMakingPeaceWithMinorLoop;
; 1706 : 
; 1707 : 				bool bPeaceBlocked;
; 1708 : 
; 1709 : 				// Loop through all players to see if they're on our team
; 1710 : 				for(iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	mov	DWORD PTR _iPlayerLoop$223284[ebp], 0
	jmp	SHORT $LN48@DoMakePeac
$LN47@DoMakePeac:
	mov	ecx, DWORD PTR _iPlayerLoop$223284[ebp]
	add	ecx, 1
	mov	DWORD PTR _iPlayerLoop$223284[ebp], ecx
$LN48@DoMakePeac:
	cmp	DWORD PTR _iPlayerLoop$223284[ebp], 22	; 00000016H
	jge	$LN50@DoMakePeac

; 1711 : 				{
; 1712 : 					eOurPlayer = (PlayerTypes) iPlayerLoop;

	mov	edx, DWORD PTR _iPlayerLoop$223284[ebp]
	mov	DWORD PTR _eOurPlayer$223283[ebp], edx

; 1713 : 
; 1714 : 					// Not on this team
; 1715 : 					if(GET_PLAYER(eOurPlayer).getTeam() != GetID())

	mov	eax, DWORD PTR _eOurPlayer$223283[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233185[ebp], eax
	mov	ecx, DWORD PTR $T233185[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T233194[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T233194[ebp], eax
	je	SHORT $LN45@DoMakePeac

; 1716 : 						continue;

	jmp	SHORT $LN47@DoMakePeac
$LN45@DoMakePeac:

; 1717 : 
; 1718 : 					FStaticVector<PlayerTypes, MAX_CIV_PLAYERS, true, c_eCiv5GameplayDLL, 0> veMinorAllies;

	lea	ecx, DWORD PTR _veMinorAllies$223296[ebp]
	call	??0?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum PlayerTypes,63,1,297,0>::FStaticVector<enum PlayerTypes,63,1,297,0>
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1719 : 
; 1720 : 					// Loop through minors to see if they're allied with us
; 1721 : 					for(iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)

	mov	DWORD PTR _iMinorLoop$223282[ebp], 22	; 00000016H
	jmp	SHORT $LN44@DoMakePeac
$LN43@DoMakePeac:
	mov	eax, DWORD PTR _iMinorLoop$223282[ebp]
	add	eax, 1
	mov	DWORD PTR _iMinorLoop$223282[ebp], eax
$LN44@DoMakePeac:
	cmp	DWORD PTR _iMinorLoop$223282[ebp], 63	; 0000003fH
	jge	$LN42@DoMakePeac

; 1722 : 					{
; 1723 : 						eOurMinor = (PlayerTypes) iMinorLoop;

	mov	ecx, DWORD PTR _iMinorLoop$223282[ebp]
	mov	DWORD PTR _eOurMinor$223281[ebp], ecx

; 1724 : 
; 1725 : 						// Minor not alive
; 1726 : 						if(!GET_PLAYER(eOurMinor).isAlive())

	mov	edx, DWORD PTR _eOurMinor$223281[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233203[ebp], edx
	mov	eax, DWORD PTR $T233203[ebp]
	mov	cl, BYTE PTR [eax+2256]
	mov	BYTE PTR $T233212[ebp], cl
	movzx	edx, BYTE PTR $T233212[ebp]
	test	edx, edx
	jne	SHORT $LN41@DoMakePeac

; 1727 : 							continue;

	jmp	SHORT $LN43@DoMakePeac
$LN41@DoMakePeac:

; 1728 : 
; 1729 : 						// Allied with us
; 1730 : 						if(GET_PLAYER(eOurMinor).GetMinorCivAI()->GetAlly() == eOurPlayer)

	mov	eax, DWORD PTR _eOurMinor$223281[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233216[ebp], eax
	mov	ecx, DWORD PTR $T233216[ebp]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetAlly
	cmp	eax, DWORD PTR _eOurPlayer$223283[ebp]
	jne	$LN40@DoMakePeac

; 1731 : 						{
; 1732 : 							bPeaceBlocked = false;

	mov	BYTE PTR _bPeaceBlocked$223289[ebp], 0

; 1733 : 
; 1734 : 							// Now... see if there's another major allied to the minor we just made peace with, which would block OUR allied minor from making peace with him
; 1735 : 							for(iThirdPartyLoop = 0; iThirdPartyLoop < MAX_MAJOR_CIVS; iThirdPartyLoop++)

	mov	DWORD PTR _iThirdPartyLoop$223286[ebp], 0
	jmp	SHORT $LN39@DoMakePeac
$LN38@DoMakePeac:
	mov	ecx, DWORD PTR _iThirdPartyLoop$223286[ebp]
	add	ecx, 1
	mov	DWORD PTR _iThirdPartyLoop$223286[ebp], ecx
$LN39@DoMakePeac:
	cmp	DWORD PTR _iThirdPartyLoop$223286[ebp], 22 ; 00000016H
	jge	$LN37@DoMakePeac

; 1736 : 							{
; 1737 : 								eThirdParty = (PlayerTypes) iThirdPartyLoop;

	mov	edx, DWORD PTR _iThirdPartyLoop$223286[ebp]
	mov	DWORD PTR _eThirdParty$223285[ebp], edx

; 1738 : 
; 1739 : 								for(iMakingPeaceWithMinorLoop = MAX_MAJOR_CIVS; iMakingPeaceWithMinorLoop < MAX_CIV_PLAYERS; iMakingPeaceWithMinorLoop++)

	mov	DWORD PTR _iMakingPeaceWithMinorLoop$223288[ebp], 22 ; 00000016H
	jmp	SHORT $LN36@DoMakePeac
$LN35@DoMakePeac:
	mov	eax, DWORD PTR _iMakingPeaceWithMinorLoop$223288[ebp]
	add	eax, 1
	mov	DWORD PTR _iMakingPeaceWithMinorLoop$223288[ebp], eax
$LN36@DoMakePeac:
	cmp	DWORD PTR _iMakingPeaceWithMinorLoop$223288[ebp], 63 ; 0000003fH
	jge	$LN34@DoMakePeac

; 1740 : 								{
; 1741 : 									eMakingPeaceWithMinor = (PlayerTypes) iMakingPeaceWithMinorLoop;

	mov	ecx, DWORD PTR _iMakingPeaceWithMinorLoop$223288[ebp]
	mov	DWORD PTR _eMakingPeaceWithMinor$223287[ebp], ecx

; 1742 : 
; 1743 : 									// Not on the team we're making peace with
; 1744 : 									if(!GET_PLAYER(eMakingPeaceWithMinor).getTeam() == eTeamWeMadePeaceWith)

	mov	edx, DWORD PTR _eMakingPeaceWithMinor$223287[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233220[ebp], edx
	mov	eax, DWORD PTR $T233220[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	neg	eax
	sbb	eax, eax
	add	eax, 1
	cmp	eax, DWORD PTR _eTeamWeMadePeaceWith$223278[ebp]
	jne	SHORT $LN33@DoMakePeac

; 1745 : 										continue;

	jmp	SHORT $LN35@DoMakePeac
$LN33@DoMakePeac:

; 1746 : 
; 1747 : 									// Minor not alive
; 1748 : 									if(!GET_PLAYER(eMakingPeaceWithMinor).isAlive())

	mov	edx, DWORD PTR _eMakingPeaceWithMinor$223287[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233232[ebp], edx
	mov	eax, DWORD PTR $T233232[ebp]
	mov	cl, BYTE PTR [eax+2256]
	mov	BYTE PTR $T233241[ebp], cl
	movzx	edx, BYTE PTR $T233241[ebp]
	test	edx, edx
	jne	SHORT $LN32@DoMakePeac

; 1749 : 										continue;

	jmp	$LN35@DoMakePeac
$LN32@DoMakePeac:

; 1750 : 
; 1751 : 									if(GET_PLAYER(eMakingPeaceWithMinor).GetMinorCivAI()->GetAlly() == eThirdParty)

	mov	eax, DWORD PTR _eMakingPeaceWithMinor$223287[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233245[ebp], eax
	mov	ecx, DWORD PTR $T233245[ebp]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetAlly
	cmp	eax, DWORD PTR _eThirdParty$223285[ebp]
	jne	$LN31@DoMakePeac

; 1752 : 									{
; 1753 : 										if(GET_TEAM(GET_PLAYER(eThirdParty).getTeam()).isAtWar(GET_PLAYER(eOurMinor).getTeam()))

	mov	ecx, DWORD PTR _eOurMinor$223281[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233249[ebp], ecx
	mov	edx, DWORD PTR $T233249[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T233258[ebp], eax
	mov	ecx, DWORD PTR _eThirdParty$223285[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233262[ebp], ecx
	mov	edx, DWORD PTR $T233262[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T233271[ebp], eax
	mov	ecx, DWORD PTR $T233271[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T233275[ebp], ecx
	mov	edx, DWORD PTR $T233258[ebp]
	push	edx
	mov	ecx, DWORD PTR $T233275[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN31@DoMakePeac

; 1754 : 										{
; 1755 : 											bPeaceBlocked = true;

	mov	BYTE PTR _bPeaceBlocked$223289[ebp], 1

; 1756 : 											break;

	jmp	SHORT $LN34@DoMakePeac
$LN31@DoMakePeac:

; 1757 : 										}
; 1758 : 									}
; 1759 : 								}

	jmp	$LN35@DoMakePeac
$LN34@DoMakePeac:

; 1760 : 							}

	jmp	$LN38@DoMakePeac
$LN37@DoMakePeac:

; 1761 : 
; 1762 : 							// Not at permanent war with this team
; 1763 : 							if(!bPeaceBlocked)

	movzx	ecx, BYTE PTR _bPeaceBlocked$223289[ebp]
	test	ecx, ecx
	jne	$LN40@DoMakePeac

; 1764 : 							{
; 1765 : 								if(!GET_PLAYER(eOurMinor).GetMinorCivAI()->IsPermanentWar(eTeamWeMadePeaceWith))

	mov	edx, DWORD PTR _eOurMinor$223281[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233279[ebp], edx
	mov	eax, DWORD PTR _eTeamWeMadePeaceWith$223278[ebp]
	push	eax
	mov	ecx, DWORD PTR $T233279[ebp]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?IsPermanentWar@CvMinorCivAI@@QBE_NW4TeamTypes@@@Z ; CvMinorCivAI::IsPermanentWar
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN40@DoMakePeac

; 1766 : 								{
; 1767 : 									GET_TEAM(GET_PLAYER(eOurMinor).getTeam()).DoMakePeace(eTeamWeMadePeaceWith, /*bBumpUnits*/ true, /*bSuppressNotification*/ true);

	mov	edx, DWORD PTR _eOurMinor$223281[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233283[ebp], edx
	mov	eax, DWORD PTR $T233283[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T233292[ebp], eax
	push	1
	push	1
	mov	edx, DWORD PTR _eTeamWeMadePeaceWith$223278[ebp]
	push	edx
	mov	ecx, DWORD PTR $T233292[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z ; CvTeam::DoMakePeace

; 1768 : 									veMinorAllies.push_back(eOurMinor);

	lea	eax, DWORD PTR _eOurMinor$223281[ebp]
	push	eax
	lea	ecx, DWORD PTR _veMinorAllies$223296[ebp]
	call	?push_back@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAEIABW4PlayerTypes@@@Z ; FStaticVector<enum PlayerTypes,63,1,297,0>::push_back
$LN40@DoMakePeac:

; 1769 : 								}
; 1770 : 							}
; 1771 : 						}
; 1772 : 					}

	jmp	$LN43@DoMakePeac
$LN42@DoMakePeac:

; 1773 : 
; 1774 : 					// Send out a notification to us telling which of our minor allies made peace
; 1775 : 					if(!veMinorAllies.empty())

	mov	ecx, DWORD PTR _veMinorAllies$223296[ebp+4]
	mov	DWORD PTR $T233307[ebp], ecx
	xor	edx, edx
	cmp	DWORD PTR $T233307[ebp], 0
	sete	dl
	movzx	eax, dl
	test	eax, eax
	jne	$LN27@DoMakePeac

; 1776 : 					{
; 1777 : 						Localization::String strTemp = Localization::Lookup("TXT_KEY_MISC_YOUR_MINOR_ALLIES_MADE_PEACE");

	push	OFFSET ??_C@_0CK@DNBPPBFC@TXT_KEY_MISC_YOUR_MINOR_ALLIES_M@
	lea	ecx, DWORD PTR _strTemp$223318[ebp]
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 1778 : 						Localization::String strSummary = Localization::Lookup("TXT_KEY_MISC_YOUR_MINOR_ALLIES_MADE_PEACE_SUMMARY");

	push	OFFSET ??_C@_0DC@ENNIBDOM@TXT_KEY_MISC_YOUR_MINOR_ALLIES_M@
	lea	edx, DWORD PTR _strSummary$223321[ebp]
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 1779 : 						strTemp << GET_TEAM(eTeam).getName().GetCString();

	mov	eax, DWORD PTR _eTeam$[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T233315[ebp], eax
	lea	ecx, DWORD PTR $T233098[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T233315[ebp]
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	DWORD PTR tv331[ebp], eax
	mov	edx, DWORD PTR tv331[ebp]
	mov	DWORD PTR $T233319[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR $T233319[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233097[ebp], eax
	lea	eax, DWORD PTR $T233097[ebp]
	push	eax
	lea	ecx, DWORD PTR _strTemp$223318[ebp]
	push	ecx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T233098[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1780 : 						CvString strMessage = strTemp.toUTF8();

	lea	ecx, DWORD PTR _strTemp$223318[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	mov	DWORD PTR $T233332[ebp], eax
	cmp	DWORD PTR $T233332[ebp], 0
	je	SHORT $LN178@DoMakePeac
	mov	edx, DWORD PTR $T233332[ebp]
	mov	DWORD PTR tv1001[ebp], edx
	jmp	SHORT $LN179@DoMakePeac
$LN178@DoMakePeac:
	mov	DWORD PTR tv1001[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN179@DoMakePeac:
	mov	eax, DWORD PTR tv1001[ebp]
	push	eax
	lea	ecx, DWORD PTR _strMessage$223326[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 6

; 1781 : 
; 1782 : 						for(uint iMinorCivLoop = 0; iMinorCivLoop < veMinorAllies.size(); iMinorCivLoop++)

	mov	DWORD PTR _iMinorCivLoop$223327[ebp], 0
	jmp	SHORT $LN26@DoMakePeac
$LN25@DoMakePeac:
	mov	ecx, DWORD PTR _iMinorCivLoop$223327[ebp]
	add	ecx, 1
	mov	DWORD PTR _iMinorCivLoop$223327[ebp], ecx
$LN26@DoMakePeac:
	mov	edx, DWORD PTR _veMinorAllies$223296[ebp+4]
	mov	DWORD PTR $T233336[ebp], edx
	mov	eax, DWORD PTR _iMinorCivLoop$223327[ebp]
	cmp	eax, DWORD PTR $T233336[ebp]
	jae	$LN24@DoMakePeac

; 1783 : 						{
; 1784 : 							PlayerTypes eMinor = veMinorAllies[iMinorCivLoop];

	mov	ecx, DWORD PTR _iMinorCivLoop$223327[ebp]
	mov	edx, DWORD PTR _veMinorAllies$223296[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _eMinor$223331[ebp], eax

; 1785 : 							strTemp = Localization::Lookup(GET_TEAM(GET_PLAYER(eMinor).getTeam()).getName().GetCString());

	mov	ecx, DWORD PTR _eMinor$223331[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233343[ebp], ecx
	mov	edx, DWORD PTR $T233343[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T233352[ebp], eax
	mov	ecx, DWORD PTR $T233352[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T233356[ebp], ecx
	lea	edx, DWORD PTR $T233099[ebp]
	push	edx
	mov	ecx, DWORD PTR $T233356[ebp]
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	DWORD PTR tv327[ebp], eax
	mov	eax, DWORD PTR tv327[ebp]
	mov	DWORD PTR $T233360[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	ecx, DWORD PTR $T233360[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233361[ebp], eax
	mov	ecx, DWORD PTR $T233361[ebp]
	push	ecx
	lea	edx, DWORD PTR $T233100[ebp]
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR tv204[ebp], eax
	mov	eax, DWORD PTR tv204[ebp]
	mov	DWORD PTR tv824[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	ecx, DWORD PTR tv824[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strTemp$223318[ebp]
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	lea	ecx, DWORD PTR $T233100[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR $T233099[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1786 : 							strMessage = strMessage + "[NEWLINE]" + strTemp.toUTF8();

	push	OFFSET ??_C@_09ODCIJKAA@?$FLNEWLINE?$FN?$AA@
	lea	edx, DWORD PTR _strMessage$223326[ebp]
	push	edx
	lea	eax, DWORD PTR $T233101[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv95[ebp], eax
	mov	ecx, DWORD PTR tv95[ebp]
	mov	DWORD PTR tv826[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	lea	ecx, DWORD PTR _strTemp$223318[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	mov	edx, DWORD PTR tv826[ebp]
	push	edx
	lea	eax, DWORD PTR $T233102[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv999[ebp], eax
	mov	ecx, DWORD PTR tv999[ebp]
	mov	DWORD PTR $T233369[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	ecx, DWORD PTR $T233369[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strMessage$223326[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	lea	ecx, DWORD PTR $T233102[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR $T233101[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1787 : 						}

	jmp	$LN25@DoMakePeac
$LN24@DoMakePeac:

; 1788 : 
; 1789 : 						if(GET_PLAYER(eOurPlayer).GetNotifications())

	mov	edx, DWORD PTR _eOurPlayer$223283[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233373[ebp], edx
	mov	ecx, DWORD PTR $T233373[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	test	eax, eax
	je	SHORT $LN23@DoMakePeac

; 1790 : 							GET_PLAYER(eOurPlayer).GetNotifications()->Add(NOTIFICATION_PEACE, strMessage, strSummary.toUTF8(), -1, -1, veMinorAllies.front(), eTeam);

	mov	eax, DWORD PTR _veMinorAllies$223296[ebp]
	mov	DWORD PTR $T233377[ebp], eax
	lea	ecx, DWORD PTR _strMessage$223326[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233381[ebp], eax
	mov	ecx, DWORD PTR _eOurPlayer$223283[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233385[ebp], ecx
	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	eax, DWORD PTR $T233377[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	-1
	push	-1
	lea	ecx, DWORD PTR _strSummary$223321[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	mov	edx, DWORD PTR $T233381[ebp]
	push	edx
	push	818263651				; 30c5b663H
	mov	ecx, DWORD PTR $T233385[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ecx, eax
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN23@DoMakePeac:

; 1791 : 					}

	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR _strMessage$223326[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _strSummary$223321[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _strTemp$223318[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN27@DoMakePeac:

; 1792 : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _veMinorAllies$223296[ebp]
	call	??1?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum PlayerTypes,63,1,297,0>::~FStaticVector<enum PlayerTypes,63,1,297,0>
	jmp	$LN47@DoMakePeac
$LN50@DoMakePeac:

; 1793 : 			}
; 1794 : 		}
; 1795 : 
; 1796 : 		// Update Interface
; 1797 : 		if((GetID() == GC.getGame().getActiveTeam()) || (eTeam == GC.getGame().getActiveTeam()))

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T233405[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	mov	esi, eax
	mov	ecx, DWORD PTR $T233405[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	esi, eax
	je	SHORT $LN21@DoMakePeac
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T233409[ebp], ecx
	mov	ecx, DWORD PTR $T233409[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	DWORD PTR _eTeam$[ebp], eax
	jne	SHORT $LN22@DoMakePeac
$LN21@DoMakePeac:

; 1798 : 		{
; 1799 : 			DLLUI->setDirty(Score_DIRTY_BIT, true);

	mov	edx, DWORD PTR $T233413[ebp]
	mov	DWORD PTR tv497[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv497[ebp], eax
	push	1
	push	12					; 0000000cH
	mov	ecx, DWORD PTR tv497[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv497[ebp]
	mov	eax, DWORD PTR [edx+260]
	call	eax

; 1800 : 			DLLUI->setDirty(CityInfo_DIRTY_BIT, true);

	mov	ecx, DWORD PTR $T233417[ebp]
	mov	DWORD PTR tv509[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv509[ebp], edx
	push	1
	push	18					; 00000012H
	mov	eax, DWORD PTR tv509[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv509[ebp]
	mov	eax, DWORD PTR [edx+260]
	call	eax
$LN22@DoMakePeac:

; 1801 : 		}
; 1802 : 
; 1803 : 		// What does it mean when we make peace
; 1804 : 		CvPlayer* pOurPlayer;
; 1805 : 		PlayerTypes eOurPlayer;
; 1806 : 		for(int iOurPlayerLoop = 0; iOurPlayerLoop < MAX_CIV_PLAYERS; iOurPlayerLoop++)

	mov	DWORD PTR _iOurPlayerLoop$223341[ebp], 0
	jmp	SHORT $LN20@DoMakePeac
$LN19@DoMakePeac:
	mov	ecx, DWORD PTR _iOurPlayerLoop$223341[ebp]
	add	ecx, 1
	mov	DWORD PTR _iOurPlayerLoop$223341[ebp], ecx
$LN20@DoMakePeac:
	cmp	DWORD PTR _iOurPlayerLoop$223341[ebp], 63 ; 0000003fH
	jge	$LN18@DoMakePeac

; 1807 : 		{
; 1808 : 			eOurPlayer = (PlayerTypes) iOurPlayerLoop;

	mov	edx, DWORD PTR _iOurPlayerLoop$223341[ebp]
	mov	DWORD PTR _eOurPlayer$223340[ebp], edx

; 1809 : 			pOurPlayer = &GET_PLAYER(eOurPlayer);

	mov	eax, DWORD PTR _eOurPlayer$223340[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _pOurPlayer$223339[ebp], eax

; 1810 : 
; 1811 : 			if(pOurPlayer->isAlive())

	mov	ecx, DWORD PTR _pOurPlayer$223339[ebp]
	mov	dl, BYTE PTR [ecx+2256]
	mov	BYTE PTR $T233429[ebp], dl
	movzx	eax, BYTE PTR $T233429[ebp]
	test	eax, eax
	je	$LN17@DoMakePeac

; 1812 : 			{
; 1813 : 				// Our Team
; 1814 : 				if(pOurPlayer->getTeam() == GetID())

	mov	ecx, DWORD PTR _pOurPlayer$223339[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T233438[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T233438[ebp], eax
	jne	SHORT $LN238@DoMakePeac

; 1815 : 				{
; 1816 : 					pOurPlayer->GetDiplomacyAI()->DoWeMadePeaceWithSomeone(eTeam);

	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pOurPlayer$223339[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?DoWeMadePeaceWithSomeone@CvDiplomacyAI@@QAEXW4TeamTypes@@@Z ; CvDiplomacyAI::DoWeMadePeaceWithSomeone

; 1817 : 					pOurPlayer->GetMilitaryAI()->LogPeace(eTeam);	// This is not quite correct, but it'll work well enough for AI testing

	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pOurPlayer$223339[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z ; CvMilitaryAI::LogPeace
	jmp	SHORT $LN17@DoMakePeac

; 1818 : 				}
; 1819 : 				// Their Team
; 1820 : 				else if(pOurPlayer->getTeam() == eTeam)

$LN238@DoMakePeac:
	mov	edx, DWORD PTR _pOurPlayer$223339[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	eax, DWORD PTR _eTeam$[ebp]
	jne	SHORT $LN17@DoMakePeac

; 1821 : 				{
; 1822 : 					pOurPlayer->GetDiplomacyAI()->DoWeMadePeaceWithSomeone(GetID());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	ecx, DWORD PTR _pOurPlayer$223339[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?DoWeMadePeaceWithSomeone@CvDiplomacyAI@@QAEXW4TeamTypes@@@Z ; CvDiplomacyAI::DoWeMadePeaceWithSomeone

; 1823 : 					pOurPlayer->GetMilitaryAI()->LogPeace(GetID());	// This is not quite correct, but it'll work well enough for AI testing

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	ecx, DWORD PTR _pOurPlayer$223339[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z ; CvMilitaryAI::LogPeace
$LN17@DoMakePeac:

; 1824 : 				}
; 1825 : 			}
; 1826 : 		}

	jmp	$LN19@DoMakePeac
$LN18@DoMakePeac:

; 1827 : 
; 1828 : 		Localization::String locString;

	lea	ecx, DWORD PTR _locString$223350[ebp]
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH

; 1829 : 
; 1830 : 		// Text stuff
; 1831 : 		if(!bSuppressNotification)

	movzx	ecx, BYTE PTR _bSuppressNotification$[ebp]
	test	ecx, ecx
	jne	$LN13@DoMakePeac

; 1832 : 		{
; 1833 : 			PlayerTypes ePlayer;
; 1834 : 			for(iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN12@DoMakePeac
$LN11@DoMakePeac:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN12@DoMakePeac:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	$LN13@DoMakePeac

; 1835 : 			{
; 1836 : 				ePlayer = (PlayerTypes) iI;

	mov	eax, DWORD PTR _iI$[ebp]
	mov	DWORD PTR _ePlayer$223352[ebp], eax

; 1837 : 
; 1838 : 				if(GET_PLAYER(ePlayer).isAlive())

	mov	ecx, DWORD PTR _ePlayer$223352[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233450[ebp], ecx
	mov	edx, DWORD PTR $T233450[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T233459[ebp], al
	movzx	ecx, BYTE PTR $T233459[ebp]
	test	ecx, ecx
	je	$LN9@DoMakePeac

; 1839 : 				{
; 1840 : 					if(GET_PLAYER(ePlayer).getTeam() == GetID())

	mov	edx, DWORD PTR _ePlayer$223352[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233463[ebp], edx
	mov	eax, DWORD PTR $T233463[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T233472[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T233472[ebp], eax
	jne	$LN8@DoMakePeac

; 1841 : 					{
; 1842 : 						if(GET_PLAYER(ePlayer).GetNotifications())

	mov	edx, DWORD PTR _ePlayer$223352[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233476[ebp], edx
	mov	ecx, DWORD PTR $T233476[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	test	eax, eax
	je	$LN7@DoMakePeac

; 1843 : 						{
; 1844 : 							locString = Localization::Lookup("TXT_KEY_MISC_YOU_MADE_PEACE_WITH");

	push	OFFSET ??_C@_0CB@PIHAMCD@TXT_KEY_MISC_YOU_MADE_PEACE_WITH@
	lea	eax, DWORD PTR $T233103[ebp]
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR tv555[ebp], eax
	mov	ecx, DWORD PTR tv555[ebp]
	mov	DWORD PTR tv831[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	mov	edx, DWORD PTR tv831[ebp]
	push	edx
	lea	ecx, DWORD PTR _locString$223350[ebp]
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	lea	ecx, DWORD PTR $T233103[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1845 : 							locString << GET_TEAM(eTeam).getName().GetCString();

	mov	eax, DWORD PTR _eTeam$[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T233480[ebp], eax
	lea	ecx, DWORD PTR $T233105[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T233480[ebp]
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	DWORD PTR tv855[ebp], eax
	mov	edx, DWORD PTR tv855[ebp]
	mov	DWORD PTR $T233484[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH
	mov	ecx, DWORD PTR $T233484[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233104[ebp], eax
	lea	eax, DWORD PTR $T233104[ebp]
	push	eax
	lea	ecx, DWORD PTR _locString$223350[ebp]
	push	ecx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	lea	ecx, DWORD PTR $T233105[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1846 : 							GET_PLAYER(ePlayer).GetNotifications()->Add(NOTIFICATION_PEACE_ACTIVE_PLAYER, locString.toUTF8(), locString.toUTF8(), -1, -1, this->getLeaderID());

	mov	edx, DWORD PTR _ePlayer$223352[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233492[ebp], edx
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	push	eax
	push	-1
	push	-1
	lea	ecx, DWORD PTR _locString$223350[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _locString$223350[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	push	-2028078871				; 871df8e9H
	mov	ecx, DWORD PTR $T233492[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ecx, eax
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN7@DoMakePeac:

; 1847 : 						}
; 1848 : 					}

	jmp	$LN9@DoMakePeac
$LN8@DoMakePeac:

; 1849 : 					else if(GET_PLAYER(ePlayer).getTeam() == eTeam)

	mov	eax, DWORD PTR _ePlayer$223352[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233496[ebp], eax
	mov	ecx, DWORD PTR $T233496[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	eax, DWORD PTR _eTeam$[ebp]
	jne	$LN5@DoMakePeac

; 1850 : 					{
; 1851 : 						if(GET_PLAYER(ePlayer).GetNotifications())

	mov	eax, DWORD PTR _ePlayer$223352[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233508[ebp], eax
	mov	ecx, DWORD PTR $T233508[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	test	eax, eax
	je	$LN4@DoMakePeac

; 1852 : 						{
; 1853 : 							locString = Localization::Lookup("TXT_KEY_MISC_YOU_MADE_PEACE_WITH");

	push	OFFSET ??_C@_0CB@PIHAMCD@TXT_KEY_MISC_YOU_MADE_PEACE_WITH@
	lea	ecx, DWORD PTR $T233106[ebp]
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR tv66[ebp], eax
	mov	edx, DWORD PTR tv66[ebp]
	mov	DWORD PTR tv835[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH
	mov	eax, DWORD PTR tv835[ebp]
	push	eax
	lea	ecx, DWORD PTR _locString$223350[ebp]
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	lea	ecx, DWORD PTR $T233106[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1854 : 							locString << getName().GetCString();

	lea	ecx, DWORD PTR $T233108[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	DWORD PTR tv1212[ebp], eax
	mov	edx, DWORD PTR tv1212[ebp]
	mov	DWORD PTR $T233512[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 15		; 0000000fH
	mov	ecx, DWORD PTR $T233512[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233107[ebp], eax
	lea	eax, DWORD PTR $T233107[ebp]
	push	eax
	lea	ecx, DWORD PTR _locString$223350[ebp]
	push	ecx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	lea	ecx, DWORD PTR $T233108[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1855 : 							GET_PLAYER(ePlayer).GetNotifications()->Add(NOTIFICATION_PEACE_ACTIVE_PLAYER, locString.toUTF8(), locString.toUTF8(), -1, -1, this->getLeaderID());

	mov	edx, DWORD PTR _ePlayer$223352[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233520[ebp], edx
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	push	eax
	push	-1
	push	-1
	lea	ecx, DWORD PTR _locString$223350[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _locString$223350[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	push	-2028078871				; 871df8e9H
	mov	ecx, DWORD PTR $T233520[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ecx, eax
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN4@DoMakePeac:

; 1856 : 						}
; 1857 : 					}

	jmp	$LN9@DoMakePeac
$LN5@DoMakePeac:

; 1858 : 					else if(GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isHasMet(GetID()) && GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isHasMet(eTeam))

	mov	eax, DWORD PTR _ePlayer$223352[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233524[ebp], eax
	mov	ecx, DWORD PTR $T233524[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T233533[ebp], eax
	mov	eax, DWORD PTR $T233533[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T233537[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	ecx, DWORD PTR $T233537[ebp]
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	movzx	ecx, al
	test	ecx, ecx
	je	$LN9@DoMakePeac
	mov	edx, DWORD PTR _ePlayer$223352[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233541[ebp], edx
	mov	eax, DWORD PTR $T233541[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T233550[ebp], eax
	mov	edx, DWORD PTR $T233550[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T233554[ebp], edx
	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T233554[ebp]
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	movzx	ecx, al
	test	ecx, ecx
	je	$LN9@DoMakePeac

; 1859 : 					{
; 1860 : 						if(GET_PLAYER(ePlayer).GetNotifications())

	mov	edx, DWORD PTR _ePlayer$223352[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233558[ebp], edx
	mov	ecx, DWORD PTR $T233558[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	test	eax, eax
	je	$LN9@DoMakePeac

; 1861 : 						{
; 1862 : 							locString = Localization::Lookup("TXT_KEY_MISC_SOMEONE_MADE_PEACE");

	push	OFFSET ??_C@_0CA@PLFHIHOA@TXT_KEY_MISC_SOMEONE_MADE_PEACE?$AA@
	lea	eax, DWORD PTR $T233109[ebp]
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR tv1213[ebp], eax
	mov	ecx, DWORD PTR tv1213[ebp]
	mov	DWORD PTR tv839[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 16		; 00000010H
	mov	edx, DWORD PTR tv839[ebp]
	push	edx
	lea	ecx, DWORD PTR _locString$223350[ebp]
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	lea	ecx, DWORD PTR $T233109[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1863 : 							locString << getName().GetCString() << GET_TEAM(eTeam).getName().GetCString();

	mov	eax, DWORD PTR _eTeam$[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T233562[ebp], eax
	lea	ecx, DWORD PTR $T233111[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T233562[ebp]
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	DWORD PTR tv1214[ebp], eax
	mov	edx, DWORD PTR tv1214[ebp]
	mov	DWORD PTR $T233566[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 17		; 00000011H
	mov	ecx, DWORD PTR $T233566[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233110[ebp], eax
	lea	eax, DWORD PTR $T233113[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	DWORD PTR tv1215[ebp], eax
	mov	ecx, DWORD PTR tv1215[ebp]
	mov	DWORD PTR $T233570[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 18		; 00000012H
	mov	ecx, DWORD PTR $T233570[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233112[ebp], eax
	lea	edx, DWORD PTR $T233110[ebp]
	push	edx
	lea	eax, DWORD PTR $T233112[ebp]
	push	eax
	lea	ecx, DWORD PTR _locString$223350[ebp]
	push	ecx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8
	push	eax
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8
	mov	BYTE PTR __$EHRec$[ebp+8], 17		; 00000011H
	lea	ecx, DWORD PTR $T233113[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	lea	ecx, DWORD PTR $T233111[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1864 : 							GET_PLAYER(ePlayer).GetNotifications()->Add(NOTIFICATION_PEACE, locString.toUTF8(), locString.toUTF8(), -1, -1, this->getLeaderID(), eTeam);

	mov	edx, DWORD PTR _ePlayer$223352[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233582[ebp], edx
	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	push	eax
	push	-1
	push	-1
	lea	ecx, DWORD PTR _locString$223350[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _locString$223350[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	push	818263651				; 30c5b663H
	mov	ecx, DWORD PTR $T233582[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ecx, eax
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN9@DoMakePeac:

; 1865 : 						}
; 1866 : 					}
; 1867 : 				}
; 1868 : 			}

	jmp	$LN11@DoMakePeac
$LN13@DoMakePeac:

; 1869 : 		}
; 1870 : 
; 1871 : 		strBuffer = GetLocalizedText("TXT_KEY_MISC_SOMEONE_MADE_PEACE", getName().GetCString(), GET_TEAM(eTeam).getName().GetCString());

	mov	ecx, DWORD PTR _eTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T233586[ebp], ecx
	lea	edx, DWORD PTR $T233115[ebp]
	push	edx
	mov	ecx, DWORD PTR $T233586[ebp]
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	DWORD PTR tv1216[ebp], eax
	mov	eax, DWORD PTR tv1216[ebp]
	mov	DWORD PTR $T233590[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 19		; 00000013H
	mov	ecx, DWORD PTR $T233590[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233114[ebp], eax
	lea	ecx, DWORD PTR $T233117[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	DWORD PTR tv1217[ebp], eax
	mov	edx, DWORD PTR tv1217[ebp]
	mov	DWORD PTR $T233594[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 20		; 00000014H
	mov	ecx, DWORD PTR $T233594[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T233116[ebp], eax
	lea	eax, DWORD PTR $T233114[ebp]
	push	eax
	lea	ecx, DWORD PTR $T233116[ebp]
	push	ecx
	push	OFFSET ??_C@_0CA@PLFHIHOA@TXT_KEY_MISC_SOMEONE_MADE_PEACE?$AA@
	lea	edx, DWORD PTR $T233118[ebp]
	push	edx
	call	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv1218[ebp], eax
	mov	eax, DWORD PTR tv1218[ebp]
	mov	DWORD PTR $T233598[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 21		; 00000015H
	mov	ecx, DWORD PTR $T233598[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 20		; 00000014H
	lea	ecx, DWORD PTR $T233118[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 19		; 00000013H
	lea	ecx, DWORD PTR $T233117[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	lea	ecx, DWORD PTR $T233115[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1872 : 		GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, getLeaderID(), strBuffer, -1, -1);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T233614[ebp], edx
	push	-1
	push	-1
	lea	eax, DWORD PTR _strBuffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	push	eax
	push	0
	mov	ecx, DWORD PTR $T233614[ebp]
	call	?addReplayMessage@CvGame@@QAEXW4ReplayMessageTypes@@W4PlayerTypes@@ABVCvString@@HH@Z ; CvGame::addReplayMessage

; 1873 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _locString$223350[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN53@DoMakePeac:

; 1874 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$0:
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$1:
	lea	ecx, DWORD PTR _args$223273[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$2:
	lea	ecx, DWORD PTR _veMinorAllies$223296[ebp]
	jmp	??1?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum PlayerTypes,63,1,297,0>::~FStaticVector<enum PlayerTypes,63,1,297,0>
__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$3:
	lea	ecx, DWORD PTR _strTemp$223318[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$4:
	lea	ecx, DWORD PTR _strSummary$223321[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$5:
	lea	ecx, DWORD PTR $T233098[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$6:
	lea	ecx, DWORD PTR _strMessage$223326[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$7:
	lea	ecx, DWORD PTR $T233099[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$8:
	lea	ecx, DWORD PTR $T233100[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$9:
	lea	ecx, DWORD PTR $T233101[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$10:
	lea	ecx, DWORD PTR $T233102[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$11:
	lea	ecx, DWORD PTR _locString$223350[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$12:
	lea	ecx, DWORD PTR $T233103[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$13:
	lea	ecx, DWORD PTR $T233105[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$14:
	lea	ecx, DWORD PTR $T233106[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$15:
	lea	ecx, DWORD PTR $T233108[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$16:
	lea	ecx, DWORD PTR $T233109[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$17:
	lea	ecx, DWORD PTR $T233111[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$18:
	lea	ecx, DWORD PTR $T233113[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$19:
	lea	ecx, DWORD PTR $T233115[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$20:
	lea	ecx, DWORD PTR $T233117[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$21:
	lea	ecx, DWORD PTR $T233118[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1736]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z ENDP	; CvTeam::DoMakePeace
PUBLIC	??_C@_08JODMCANB@TeamMeet?$AA@			; `string'
PUBLIC	?makeHasMet@CvTeam@@QAEXW4TeamTypes@@_N@Z	; CvTeam::makeHasMet
;	COMDAT ??_C@_08JODMCANB@TeamMeet?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaargshandle.h
CONST	SEGMENT
??_C@_08JODMCANB@TeamMeet?$AA@ DB 'TeamMeet', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?meet@CvTeam@@QAEXW4TeamTypes@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?meet@CvTeam@@QAEXW4TeamTypes@@_N@Z$0
__ehfuncinfo$?meet@CvTeam@@QAEXW4TeamTypes@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?meet@CvTeam@@QAEXW4TeamTypes@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?meet@CvTeam@@QAEXW4TeamTypes@@_N@Z
_TEXT	SEGMENT
tv137 = -48						; size = 4
tv130 = -44						; size = 4
tv86 = -40						; size = 4
_this$ = -36						; size = 4
$T233635 = -32						; size = 4
$T233631 = -28						; size = 4
_bResult$223393 = -21					; size = 1
_args$223392 = -20					; size = 4
_pkScriptSystem$223390 = -16				; size = 4
__$EHRec$ = -12						; size = 12
_eTeam$ = 8						; size = 4
_bSuppressMessages$ = 12				; size = 1
?meet@CvTeam@@QAEXW4TeamTypes@@_N@Z PROC		; CvTeam::meet, COMDAT
; _this$ = ecx

; 1878 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?meet@CvTeam@@QAEXW4TeamTypes@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1879 : 	if(!isHasMet(eTeam))

	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN3@meet

; 1880 : 	{
; 1881 : 		makeHasMet(eTeam, bSuppressMessages);

	movzx	edx, BYTE PTR _bSuppressMessages$[ebp]
	push	edx
	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?makeHasMet@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::makeHasMet

; 1882 : 		GET_TEAM(eTeam).makeHasMet(GetID(), bSuppressMessages);

	mov	ecx, DWORD PTR _eTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T233631[ebp], ecx
	movzx	edx, BYTE PTR _bSuppressMessages$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	ecx, DWORD PTR $T233631[ebp]
	call	?makeHasMet@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::makeHasMet

; 1883 : 
; 1884 : 		ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	eax, DWORD PTR $T233635[ebp]
	mov	DWORD PTR tv86[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv86[ebp], ecx
	mov	edx, DWORD PTR tv86[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv86[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	DWORD PTR _pkScriptSystem$223390[ebp], eax

; 1885 : 		if(pkScriptSystem)

	cmp	DWORD PTR _pkScriptSystem$223390[ebp], 0
	je	SHORT $LN3@meet

; 1886 : 		{
; 1887 : 			CvLuaArgsHandle args(2);

	push	2
	lea	ecx, DWORD PTR _args$223392[ebp]
	call	??0CvLuaArgsHandle@@QAE@I@Z		; CvLuaArgsHandle::CvLuaArgsHandle
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1888 : 			args->Push(eTeam);

	mov	eax, DWORD PTR _args$223392[ebp]
	mov	DWORD PTR tv130[ebp], eax
	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv130[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv130[ebp]
	mov	edx, DWORD PTR [eax+8]
	call	edx

; 1889 : 			args->Push(GetID());

	mov	eax, DWORD PTR _args$223392[ebp]
	mov	DWORD PTR tv137[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	ecx, DWORD PTR tv137[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv137[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 1890 : 
; 1891 : 			bool bResult;
; 1892 : 			LuaSupport::CallHook(pkScriptSystem, "TeamMeet", args.get(), bResult);

	lea	ecx, DWORD PTR _bResult$223393[ebp]
	push	ecx
	mov	edx, DWORD PTR _args$223392[ebp]
	push	edx
	push	OFFSET ??_C@_08JODMCANB@TeamMeet?$AA@
	mov	eax, DWORD PTR _pkScriptSystem$223390[ebp]
	push	eax
	call	?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallHook
	add	esp, 16					; 00000010H

; 1893 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _args$223392[ebp]
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN3@meet:

; 1894 : 	}
; 1895 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?meet@CvTeam@@QAEXW4TeamTypes@@_N@Z$0:
	lea	ecx, DWORD PTR _args$223392[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__ehhandler$?meet@CvTeam@@QAEXW4TeamTypes@@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?meet@CvTeam@@QAEXW4TeamTypes@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?meet@CvTeam@@QAEXW4TeamTypes@@_N@Z ENDP		; CvTeam::meet
PUBLIC	?getPower@CvTeam@@QBEHXZ			; CvTeam::getPower
EXTRN	?getPower@CvPlayer@@QBEHXZ:PROC			; CvPlayer::getPower
; Function compile flags: /Odtp
;	COMDAT ?getPower@CvTeam@@QBEHXZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T233673 = -20						; size = 4
$T233664 = -13						; size = 1
_kLoopPlayer$223403 = -12				; size = 4
_iCount$ = -8						; size = 4
_iI$ = -4						; size = 4
?getPower@CvTeam@@QBEHXZ PROC				; CvTeam::getPower, COMDAT
; _this$ = ecx

; 1900 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1901 : 	int iCount;
; 1902 : 	int iI;
; 1903 : 
; 1904 : 	iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0

; 1905 : 
; 1906 : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN5@getPower
$LN4@getPower:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN5@getPower:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	SHORT $LN3@getPower

; 1907 : 	{
; 1908 : 		CvPlayer& kLoopPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kLoopPlayer$223403[ebp], ecx

; 1909 : 		if(kLoopPlayer.isAlive())

	mov	edx, DWORD PTR _kLoopPlayer$223403[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T233664[ebp], al
	movzx	ecx, BYTE PTR $T233664[ebp]
	test	ecx, ecx
	je	SHORT $LN2@getPower

; 1910 : 		{
; 1911 : 			if(kLoopPlayer.getTeam() == GetID())

	mov	edx, DWORD PTR _kLoopPlayer$223403[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T233673[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T233673[ebp], eax
	jne	SHORT $LN2@getPower

; 1912 : 			{
; 1913 : 				iCount += kLoopPlayer.getPower();

	mov	ecx, DWORD PTR _kLoopPlayer$223403[ebp]
	call	?getPower@CvPlayer@@QBEHXZ		; CvPlayer::getPower
	add	eax, DWORD PTR _iCount$[ebp]
	mov	DWORD PTR _iCount$[ebp], eax
$LN2@getPower:

; 1914 : 			}
; 1915 : 		}
; 1916 : 	}

	jmp	SHORT $LN4@getPower
$LN3@getPower:

; 1917 : 
; 1918 : 	return iCount;

	mov	eax, DWORD PTR _iCount$[ebp]

; 1919 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getPower@CvTeam@@QBEHXZ ENDP				; CvTeam::getPower
_TEXT	ENDS
PUBLIC	?getDefensivePower@CvTeam@@QBEHXZ		; CvTeam::getDefensivePower
; Function compile flags: /Odtp
;	COMDAT ?getDefensivePower@CvTeam@@QBEHXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
_kLoopTeam$223415 = -12					; size = 4
_iCount$ = -8						; size = 4
_iI$ = -4						; size = 4
?getDefensivePower@CvTeam@@QBEHXZ PROC			; CvTeam::getDefensivePower, COMDAT
; _this$ = ecx

; 1924 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1925 : 	int iCount;
; 1926 : 	int iI;
; 1927 : 
; 1928 : 	iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0

; 1929 : 
; 1930 : 	for(iI = 0; iI < MAX_CIV_TEAMS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN6@getDefensi
$LN5@getDefensi:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN6@getDefensi:
	cmp	DWORD PTR _iI$[ebp], 63			; 0000003fH
	jge	SHORT $LN4@getDefensi

; 1931 : 	{
; 1932 : 		CvTeam& kLoopTeam = GET_TEAM((TeamTypes)iI);

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR _kLoopTeam$223415[ebp], ecx

; 1933 : 		if(kLoopTeam.isAlive())

	mov	edx, DWORD PTR _kLoopTeam$223415[ebp]
	xor	eax, eax
	cmp	DWORD PTR [edx+12], 0
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@getDefensi

; 1934 : 		{
; 1935 : 			if(GetID() == iI || IsHasDefensivePact((TeamTypes)iI))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	eax, DWORD PTR _iI$[ebp]
	je	SHORT $LN1@getDefensi
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHasDefensivePact@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsHasDefensivePact
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@getDefensi
$LN1@getDefensi:

; 1936 : 			{
; 1937 : 				iCount += kLoopTeam.getPower();

	mov	ecx, DWORD PTR _kLoopTeam$223415[ebp]
	call	?getPower@CvTeam@@QBEHXZ		; CvTeam::getPower
	add	eax, DWORD PTR _iCount$[ebp]
	mov	DWORD PTR _iCount$[ebp], eax
$LN3@getDefensi:

; 1938 : 			}
; 1939 : 		}
; 1940 : 	}

	jmp	SHORT $LN5@getDefensi
$LN4@getDefensi:

; 1941 : 
; 1942 : 	return iCount;

	mov	eax, DWORD PTR _iCount$[ebp]

; 1943 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getDefensivePower@CvTeam@@QBEHXZ ENDP			; CvTeam::getDefensivePower
_TEXT	ENDS
PUBLIC	?getEnemyPower@CvTeam@@QBEHXZ			; CvTeam::getEnemyPower
; Function compile flags: /Odtp
;	COMDAT ?getEnemyPower@CvTeam@@QBEHXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
_kLoopTeam$223429 = -12					; size = 4
_iI$223425 = -8						; size = 4
_iCount$ = -4						; size = 4
?getEnemyPower@CvTeam@@QBEHXZ PROC			; CvTeam::getEnemyPower, COMDAT
; _this$ = ecx

; 1948 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1949 : 	int iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0

; 1950 : 
; 1951 : 	for(int iI = 0; iI < MAX_CIV_TEAMS; iI++)

	mov	DWORD PTR _iI$223425[ebp], 0
	jmp	SHORT $LN5@getEnemyPo
$LN4@getEnemyPo:
	mov	eax, DWORD PTR _iI$223425[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$223425[ebp], eax
$LN5@getEnemyPo:
	cmp	DWORD PTR _iI$223425[ebp], 63		; 0000003fH
	jge	SHORT $LN3@getEnemyPo

; 1952 : 	{
; 1953 : 		CvTeam& kLoopTeam = GET_TEAM((TeamTypes)iI);

	mov	ecx, DWORD PTR _iI$223425[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR _kLoopTeam$223429[ebp], ecx

; 1954 : 		if(kLoopTeam.isAlive())

	mov	edx, DWORD PTR _kLoopTeam$223429[ebp]
	xor	eax, eax
	cmp	DWORD PTR [edx+12], 0
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@getEnemyPo

; 1955 : 		{
; 1956 : 			if(GetID() != iI && isAtWar((TeamTypes)iI))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	eax, DWORD PTR _iI$223425[ebp]
	je	SHORT $LN2@getEnemyPo
	mov	edx, DWORD PTR _iI$223425[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@getEnemyPo

; 1957 : 			{
; 1958 : 				iCount += kLoopTeam.getPower();

	mov	ecx, DWORD PTR _kLoopTeam$223429[ebp]
	call	?getPower@CvTeam@@QBEHXZ		; CvTeam::getPower
	add	eax, DWORD PTR _iCount$[ebp]
	mov	DWORD PTR _iCount$[ebp], eax
$LN2@getEnemyPo:

; 1959 : 			}
; 1960 : 		}
; 1961 : 	}

	jmp	SHORT $LN4@getEnemyPo
$LN3@getEnemyPo:

; 1962 : 
; 1963 : 	return iCount;

	mov	eax, DWORD PTR _iCount$[ebp]

; 1964 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getEnemyPower@CvTeam@@QBEHXZ ENDP			; CvTeam::getEnemyPower
_TEXT	ENDS
PUBLIC	?getNumNukeUnits@CvTeam@@QBEHXZ			; CvTeam::getNumNukeUnits
EXTRN	?getNumNukeUnits@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getNumNukeUnits
; Function compile flags: /Odtp
;	COMDAT ?getNumNukeUnits@CvTeam@@QBEHXZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T233712 = -20						; size = 4
$T233703 = -13						; size = 1
_kLoopPlayer$223442 = -12				; size = 4
_iCount$ = -8						; size = 4
_iI$ = -4						; size = 4
?getNumNukeUnits@CvTeam@@QBEHXZ PROC			; CvTeam::getNumNukeUnits, COMDAT
; _this$ = ecx

; 1969 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1970 : 	int iCount;
; 1971 : 	int iI;
; 1972 : 
; 1973 : 	iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0

; 1974 : 
; 1975 : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN5@getNumNuke
$LN4@getNumNuke:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN5@getNumNuke:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	SHORT $LN3@getNumNuke

; 1976 : 	{
; 1977 : 		CvPlayer& kLoopPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kLoopPlayer$223442[ebp], ecx

; 1978 : 		if(kLoopPlayer.isAlive())

	mov	edx, DWORD PTR _kLoopPlayer$223442[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T233703[ebp], al
	movzx	ecx, BYTE PTR $T233703[ebp]
	test	ecx, ecx
	je	SHORT $LN2@getNumNuke

; 1979 : 		{
; 1980 : 			if(kLoopPlayer.getTeam() == GetID())

	mov	edx, DWORD PTR _kLoopPlayer$223442[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T233712[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T233712[ebp], eax
	jne	SHORT $LN2@getNumNuke

; 1981 : 			{
; 1982 : 				iCount += kLoopPlayer.getNumNukeUnits();

	mov	ecx, DWORD PTR _kLoopPlayer$223442[ebp]
	call	?getNumNukeUnits@CvPlayer@@QBEHXZ	; CvPlayer::getNumNukeUnits
	add	eax, DWORD PTR _iCount$[ebp]
	mov	DWORD PTR _iCount$[ebp], eax
$LN2@getNumNuke:

; 1983 : 			}
; 1984 : 		}
; 1985 : 	}

	jmp	SHORT $LN4@getNumNuke
$LN3@getNumNuke:

; 1986 : 
; 1987 : 	return iCount;

	mov	eax, DWORD PTR _iCount$[ebp]

; 1988 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getNumNukeUnits@CvTeam@@QBEHXZ ENDP			; CvTeam::getNumNukeUnits
_TEXT	ENDS
PUBLIC	??1?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE@XZ ; CvWeightedVector<enum TeamTypes,63,1>::~CvWeightedVector<enum TeamTypes,63,1>
PUBLIC	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::~FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>
PUBLIC	?ChooseFromTopChoices@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE?AW4TeamTypes@@HPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ; CvWeightedVector<enum TeamTypes,63,1>::ChooseFromTopChoices
PUBLIC	??_C@_0EA@NIFDCODH@Tie?5for?5most?5favored?5other?5team?5@ ; `string'
PUBLIC	??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>
PUBLIC	?SortItems@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAEXXZ ; CvWeightedVector<enum TeamTypes,63,1>::SortItems
PUBLIC	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@Z ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::push_back
PUBLIC	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>
PUBLIC	?GetLiberatedByTeam@CvTeam@@QBE?AW4TeamTypes@@XZ ; CvTeam::GetLiberatedByTeam
PUBLIC	__$ArrayPad$
PUBLIC	?GetTeamVotingForInDiplo@CvTeam@@QBE?AW4TeamTypes@@XZ ; CvTeam::GetTeamVotingForInDiplo
EXTRN	?getJonRandNum@CvGame@@QAEHHPBD@Z:PROC		; CvGame::getJonRandNum
EXTRN	?GetMajorCivOpinionWeight@CvDiplomacyAI@@QAEHW4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetMajorCivOpinionWeight
;	COMDAT ??_C@_0EA@NIFDCODH@Tie?5for?5most?5favored?5other?5team?5@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0EA@NIFDCODH@Tie?5for?5most?5favored?5other?5team?5@ DB 'Tie for mo'
	DB	'st favored other team to vote for. Rolling to choose.', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetTeamVotingForInDiplo@CvTeam@@QBE?AW4TeamTypes@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetTeamVotingForInDiplo@CvTeam@@QBE?AW4TeamTypes@@XZ$0
__ehfuncinfo$?GetTeamVotingForInDiplo@CvTeam@@QBE?AW4TeamTypes@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetTeamVotingForInDiplo@CvTeam@@QBE?AW4TeamTypes@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?GetTeamVotingForInDiplo@CvTeam@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
_this$ = -748						; size = 4
$T233862 = -696						; size = 4
$T233854 = -692						; size = 4
_elem$233849 = -688					; size = 8
$T233831 = -680						; size = 4
_elem$233826 = -676					; size = 8
$T233796 = -660						; size = 4
_weightedElem$233791 = -656				; size = 8
$T233782 = -648						; size = 4
$T233781 = -644						; size = 4
$T233777 = -640						; size = 4
$T233773 = -636						; size = 4
$T233769 = -632						; size = 4
$T233762 = -628						; size = 4
$T233746 = -624						; size = 4
$T233742 = -617						; size = 1
$T233733 = -616						; size = 4
$T233729 = -612						; size = 4
$T233728 = -608						; size = 4
$T233721 = -604						; size = 4
$T233720 = -600						; size = 4
_randFn$223823 = -596					; size = 8
_iWeight$223696 = -588					; size = 4
_iIndex$223692 = -584					; size = 4
_iNumAtTop$223691 = -580				; size = 4
_iTopWeight$223690 = -576				; size = 4
_iWeight$223687 = -572					; size = 4
_iOpinion$223685 = -568					; size = 4
_kiBase$223684 = -564					; size = 4
_eLeaderLoop$223681 = -560				; size = 4
_eTeamLoop$223678 = -556				; size = 4
_iTeamLoop$223674 = -552				; size = 4
_veVoteCandidates$223673 = -548				; size = 520
__$ArrayPad$ = -24					; size = 4
_eAlly$223455 = -20					; size = 4
_eVoteTeam$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?GetTeamVotingForInDiplo@CvTeam@@QBE?AW4TeamTypes@@XZ PROC ; CvTeam::GetTeamVotingForInDiplo, COMDAT
; _this$ = ecx

; 1993 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetTeamVotingForInDiplo@CvTeam@@QBE?AW4TeamTypes@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 736				; 000002e0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1994 : 	TeamTypes eVoteTeam = NO_TEAM;

	mov	DWORD PTR _eVoteTeam$[ebp], -1

; 1995 : 	
; 1996 : 	if(isBarbarian())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isBarbarian@CvTeam@@QBE_NXZ		; CvTeam::isBarbarian
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN22@GetTeamVot
	jmp	$LN21@GetTeamVot
$LN22@GetTeamVot:

; 1997 : 	{
; 1998 : 		// Barbarians do not vote!
; 1999 : 		CvAssertMsg(false, "Barbarian team should not be voting for diplo victory. Please send Anton your save file and verison.");
; 2000 : 	}
; 2001 : 	else if(isMinorCiv())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	movzx	ecx, al
	test	ecx, ecx
	je	$LN20@GetTeamVot

; 2002 : 	{
; 2003 : 		// Minor civs vote for their favored nation (liberator or ally)
; 2004 : 		if(GetLiberatedByTeam() != NO_TEAM && GET_TEAM(GetLiberatedByTeam()).isAlive())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLiberatedByTeam@CvTeam@@QBE?AW4TeamTypes@@XZ ; CvTeam::GetLiberatedByTeam
	cmp	eax, -1
	je	SHORT $LN19@GetTeamVot
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLiberatedByTeam@CvTeam@@QBE?AW4TeamTypes@@XZ ; CvTeam::GetLiberatedByTeam
	mov	DWORD PTR $T233720[ebp], eax
	mov	edx, DWORD PTR $T233720[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T233721[ebp], edx
	mov	eax, DWORD PTR $T233721[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+12], 0
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN19@GetTeamVot

; 2005 : 		{
; 2006 : 			eVoteTeam = GetLiberatedByTeam();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLiberatedByTeam@CvTeam@@QBE?AW4TeamTypes@@XZ ; CvTeam::GetLiberatedByTeam
	mov	DWORD PTR _eVoteTeam$[ebp], eax

; 2007 : 		}
; 2008 : 		else

	jmp	$LN18@GetTeamVot
$LN19@GetTeamVot:

; 2009 : 		{
; 2010 : 			PlayerTypes eAlly = GET_PLAYER(getLeaderID()).GetMinorCivAI()->GetAlly();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	mov	DWORD PTR $T233728[ebp], eax
	mov	eax, DWORD PTR $T233728[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233729[ebp], eax
	mov	ecx, DWORD PTR $T233729[ebp]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetAlly
	mov	DWORD PTR _eAlly$223455[ebp], eax

; 2011 : 			if(eAlly != NO_PLAYER && GET_PLAYER(eAlly).isAlive())

	cmp	DWORD PTR _eAlly$223455[ebp], -1
	je	SHORT $LN18@GetTeamVot
	mov	ecx, DWORD PTR _eAlly$223455[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233733[ebp], ecx
	mov	edx, DWORD PTR $T233733[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T233742[ebp], al
	movzx	ecx, BYTE PTR $T233742[ebp]
	test	ecx, ecx
	je	SHORT $LN18@GetTeamVot

; 2012 : 				eVoteTeam = GET_PLAYER(eAlly).getTeam();

	mov	edx, DWORD PTR _eAlly$223455[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233746[ebp], edx
	mov	eax, DWORD PTR $T233746[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eVoteTeam$[ebp], eax
$LN18@GetTeamVot:

; 2013 : 		}
; 2014 : 	}
; 2015 : 	else

	jmp	$LN21@GetTeamVot
$LN20@GetTeamVot:

; 2016 : 	{
; 2017 : 		// Major civs vote for other majors based on opinion weight (our team leader towards their team leader)
; 2018 : 		CvWeightedVector<TeamTypes, MAX_CIV_TEAMS, true> veVoteCandidates;

	lea	ecx, DWORD PTR _veVoteCandidates$223673[ebp]
	call	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2019 : 		for (int iTeamLoop = 0; iTeamLoop < MAX_CIV_TEAMS; iTeamLoop++)

	mov	DWORD PTR _iTeamLoop$223674[ebp], 0
	jmp	SHORT $LN15@GetTeamVot
$LN14@GetTeamVot:
	mov	edx, DWORD PTR _iTeamLoop$223674[ebp]
	add	edx, 1
	mov	DWORD PTR _iTeamLoop$223674[ebp], edx
$LN15@GetTeamVot:
	cmp	DWORD PTR _iTeamLoop$223674[ebp], 63	; 0000003fH
	jge	$LN13@GetTeamVot

; 2020 : 		{
; 2021 : 			TeamTypes eTeamLoop = (TeamTypes) iTeamLoop;

	mov	eax, DWORD PTR _iTeamLoop$223674[ebp]
	mov	DWORD PTR _eTeamLoop$223678[ebp], eax

; 2022 : 			if (GetID() != eTeamLoop && GET_TEAM(eTeamLoop).isAlive() && !GET_TEAM(eTeamLoop).isMinorCiv() && !GET_TEAM(eTeamLoop).isBarbarian() && isHasMet(eTeamLoop))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	eax, DWORD PTR _eTeamLoop$223678[ebp]
	je	$LN12@GetTeamVot
	mov	ecx, DWORD PTR _eTeamLoop$223678[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T233762[ebp], ecx
	mov	edx, DWORD PTR $T233762[ebp]
	xor	eax, eax
	cmp	DWORD PTR [edx+12], 0
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	$LN12@GetTeamVot
	mov	edx, DWORD PTR _eTeamLoop$223678[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T233769[ebp], edx
	mov	ecx, DWORD PTR $T233769[ebp]
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	movzx	eax, al
	test	eax, eax
	jne	$LN12@GetTeamVot
	mov	ecx, DWORD PTR _eTeamLoop$223678[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T233773[ebp], ecx
	mov	ecx, DWORD PTR $T233773[ebp]
	call	?isBarbarian@CvTeam@@QBE_NXZ		; CvTeam::isBarbarian
	movzx	edx, al
	test	edx, edx
	jne	$LN12@GetTeamVot
	mov	eax, DWORD PTR _eTeamLoop$223678[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	movzx	ecx, al
	test	ecx, ecx
	je	$LN12@GetTeamVot

; 2023 : 			{
; 2024 : 				PlayerTypes eLeaderLoop = (PlayerTypes) GET_TEAM(eTeamLoop).getLeaderID();

	mov	edx, DWORD PTR _eTeamLoop$223678[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T233777[ebp], edx
	mov	ecx, DWORD PTR $T233777[ebp]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	mov	DWORD PTR _eLeaderLoop$223681[ebp], eax

; 2025 : 				CvAssertMsg(getLeaderID() != NO_PLAYER, "Our team leader ID should not be NO_PLAYER. Please send Anton your save file and version.");
; 2026 : 				CvAssertMsg(eLeaderLoop != NO_PLAYER, "Other team leader ID should not be NO_PLAYER. Please send Anton your save file and version.");
; 2027 : 				if (getLeaderID() != NO_PLAYER && eLeaderLoop != NO_PLAYER)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	cmp	eax, -1
	je	$LN12@GetTeamVot
	cmp	DWORD PTR _eLeaderLoop$223681[ebp], -1
	je	$LN12@GetTeamVot

; 2028 : 				{
; 2029 : 					int kiBase = 10000;

	mov	DWORD PTR _kiBase$223684[ebp], 10000	; 00002710H

; 2030 : 					
; 2031 : 					// What is our leader's opinion of the other team's leader? Remember, bad opinion is positive, good opinion is negative.
; 2032 : 					int iOpinion = GET_PLAYER(getLeaderID()).GetDiplomacyAI()->GetMajorCivOpinionWeight(eLeaderLoop);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	mov	DWORD PTR $T233781[ebp], eax
	mov	eax, DWORD PTR $T233781[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233782[ebp], eax
	mov	ecx, DWORD PTR _eLeaderLoop$223681[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T233782[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMajorCivOpinionWeight@CvDiplomacyAI@@QAEHW4PlayerTypes@@@Z ; CvDiplomacyAI::GetMajorCivOpinionWeight
	mov	DWORD PTR _iOpinion$223685[ebp], eax

; 2033 : 					if (isAtWar(eTeamLoop))

	mov	edx, DWORD PTR _eTeamLoop$223678[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN10@GetTeamVot

; 2034 : 						iOpinion = kiBase; // Don't vote for someone we are at war with, if we can help it

	mov	ecx, DWORD PTR _kiBase$223684[ebp]
	mov	DWORD PTR _iOpinion$223685[ebp], ecx
$LN10@GetTeamVot:

; 2035 : 
; 2036 : 					// Weight cannot be negative. This calculation makes good opinions > 10000 and bad opinions < 10000.
; 2037 : 					int iWeight = kiBase - iOpinion;

	mov	edx, DWORD PTR _kiBase$223684[ebp]
	sub	edx, DWORD PTR _iOpinion$223685[ebp]
	mov	DWORD PTR _iWeight$223687[ebp], edx

; 2038 : 					if (iWeight < 0)

	jns	SHORT $LN9@GetTeamVot

; 2039 : 						iWeight = 0;

	mov	DWORD PTR _iWeight$223687[ebp], 0
$LN9@GetTeamVot:

; 2040 : 
; 2041 : 					veVoteCandidates.push_back(eTeamLoop, iWeight);

	mov	DWORD PTR _weightedElem$233791[ebp], 0
	mov	DWORD PTR _weightedElem$233791[ebp+4], 0
	mov	eax, DWORD PTR _eTeamLoop$223678[ebp]
	mov	DWORD PTR _weightedElem$233791[ebp], eax
	mov	ecx, DWORD PTR _iWeight$223687[ebp]
	mov	DWORD PTR _weightedElem$233791[ebp+4], ecx
	lea	edx, DWORD PTR _weightedElem$233791[ebp]
	push	edx
	lea	ecx, DWORD PTR _veVoteCandidates$223673[ebp]
	call	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@Z ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::push_back
$LN12@GetTeamVot:

; 2042 : 				}
; 2043 : 			}
; 2044 : 		}

	jmp	$LN14@GetTeamVot
$LN13@GetTeamVot:

; 2045 : 
; 2046 : 		if (veVoteCandidates.size() > 0)

	mov	eax, DWORD PTR _veVoteCandidates$223673[ebp+4]
	mov	DWORD PTR $T233796[ebp], eax
	cmp	DWORD PTR $T233796[ebp], 0
	jle	$LN8@GetTeamVot

; 2047 : 		{
; 2048 : 			// Our most favored other team ends up at the top after sorting
; 2049 : 			veVoteCandidates.SortItems();

	lea	ecx, DWORD PTR _veVoteCandidates$223673[ebp]
	call	?SortItems@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAEXXZ ; CvWeightedVector<enum TeamTypes,63,1>::SortItems

; 2050 : 			int iTopWeight = veVoteCandidates.GetWeight(0);

	mov	DWORD PTR _elem$233826[ebp], 0
	mov	DWORD PTR _elem$233826[ebp+4], 0
	xor	ecx, ecx
	shl	ecx, 3
	mov	edx, DWORD PTR _veVoteCandidates$223673[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR [edx+ecx+4]
	mov	DWORD PTR _elem$233826[ebp], eax
	mov	DWORD PTR _elem$233826[ebp+4], ecx
	mov	edx, DWORD PTR _elem$233826[ebp+4]
	mov	DWORD PTR _iTopWeight$223690[ebp], edx

; 2051 : 
; 2052 : 			// If there is a tie at the top, choose randomly from those that tied
; 2053 : 			int iNumAtTop = 0;

	mov	DWORD PTR _iNumAtTop$223691[ebp], 0

; 2054 : 			for (int iIndex = 0; iIndex < veVoteCandidates.size(); iIndex++)

	mov	DWORD PTR _iIndex$223692[ebp], 0
	jmp	SHORT $LN7@GetTeamVot
$LN6@GetTeamVot:
	mov	eax, DWORD PTR _iIndex$223692[ebp]
	add	eax, 1
	mov	DWORD PTR _iIndex$223692[ebp], eax
$LN7@GetTeamVot:
	mov	ecx, DWORD PTR _veVoteCandidates$223673[ebp+4]
	mov	DWORD PTR $T233831[ebp], ecx
	mov	edx, DWORD PTR _iIndex$223692[ebp]
	cmp	edx, DWORD PTR $T233831[ebp]
	jge	SHORT $LN5@GetTeamVot

; 2055 : 			{
; 2056 : 				int iWeight = veVoteCandidates.GetWeight(iIndex);

	mov	DWORD PTR _elem$233849[ebp], 0
	mov	DWORD PTR _elem$233849[ebp+4], 0
	mov	eax, DWORD PTR _iIndex$223692[ebp]
	mov	ecx, DWORD PTR _veVoteCandidates$223673[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR [ecx+eax*8+4]
	mov	DWORD PTR _elem$233849[ebp], edx
	mov	DWORD PTR _elem$233849[ebp+4], eax
	mov	ecx, DWORD PTR _elem$233849[ebp+4]
	mov	DWORD PTR _iWeight$223696[ebp], ecx

; 2057 : 				CvAssertMsg(iWeight <= iTopWeight, "Vote opinion weight should not be higher than the top team's weight! Please send Anton your save file and version.");
; 2058 : 				if (iWeight >= iTopWeight)

	mov	edx, DWORD PTR _iWeight$223696[ebp]
	cmp	edx, DWORD PTR _iTopWeight$223690[ebp]
	jl	SHORT $LN4@GetTeamVot

; 2059 : 				{
; 2060 : 					iNumAtTop++;

	mov	eax, DWORD PTR _iNumAtTop$223691[ebp]
	add	eax, 1
	mov	DWORD PTR _iNumAtTop$223691[ebp], eax

; 2061 : 				}
; 2062 : 				else

	jmp	SHORT $LN3@GetTeamVot
$LN4@GetTeamVot:

; 2063 : 				{
; 2064 : 					break;

	jmp	SHORT $LN5@GetTeamVot
$LN3@GetTeamVot:

; 2065 : 				}
; 2066 : 			}

	jmp	$LN6@GetTeamVot
$LN5@GetTeamVot:

; 2067 : 			CvAssertMsg(iNumAtTop > 0, "Should have at least one vote candidate at the top of the list for consideration. Please send Anton your save file and version.");
; 2068 : 			CvAssertMsg(iNumAtTop <= veVoteCandidates.size(), "Should not have more top vote candidates than there are total candidates. Please send Anton your save file and version.");
; 2069 : 			if (iNumAtTop > 0 && iNumAtTop <= veVoteCandidates.size())

	cmp	DWORD PTR _iNumAtTop$223691[ebp], 0
	jle	SHORT $LN8@GetTeamVot
	mov	ecx, DWORD PTR _veVoteCandidates$223673[ebp+4]
	mov	DWORD PTR $T233854[ebp], ecx
	mov	edx, DWORD PTR _iNumAtTop$223691[ebp]
	cmp	edx, DWORD PTR $T233854[ebp]
	jg	SHORT $LN8@GetTeamVot

; 2070 : 			{
; 2071 : 				RandomNumberDelegate randFn = MakeDelegate(&GC.getGame(), &CvGame::getJonRandNum);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T233862[ebp], eax
	push	OFFSET ?getJonRandNum@CvGame@@QAEHHPBD@Z ; CvGame::getJonRandNum
	mov	ecx, DWORD PTR $T233862[ebp]
	push	ecx
	lea	edx, DWORD PTR _randFn$223823[ebp]
	push	edx
	call	??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>
	add	esp, 12					; 0000000cH

; 2072 : 				eVoteTeam = veVoteCandidates.ChooseFromTopChoices(iNumAtTop, &randFn, "Tie for most favored other team to vote for. Rolling to choose.");

	push	OFFSET ??_C@_0EA@NIFDCODH@Tie?5for?5most?5favored?5other?5team?5@
	lea	eax, DWORD PTR _randFn$223823[ebp]
	push	eax
	mov	ecx, DWORD PTR _iNumAtTop$223691[ebp]
	push	ecx
	lea	ecx, DWORD PTR _veVoteCandidates$223673[ebp]
	call	?ChooseFromTopChoices@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE?AW4TeamTypes@@HPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ; CvWeightedVector<enum TeamTypes,63,1>::ChooseFromTopChoices
	mov	DWORD PTR _eVoteTeam$[ebp], eax
$LN8@GetTeamVot:

; 2073 : 			}
; 2074 : 		}
; 2075 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _veVoteCandidates$223673[ebp]
	call	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::~FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>
$LN21@GetTeamVot:

; 2076 : 
; 2077 : 	// If all else fails, vote for ourselves
; 2078 : 	if (eVoteTeam == NO_TEAM)

	cmp	DWORD PTR _eVoteTeam$[ebp], -1
	jne	SHORT $LN1@GetTeamVot

; 2079 : 		eVoteTeam = GetID();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	mov	DWORD PTR _eVoteTeam$[ebp], eax
$LN1@GetTeamVot:

; 2080 : 
; 2081 : 	return eVoteTeam;

	mov	eax, DWORD PTR _eVoteTeam$[ebp]

; 2082 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetTeamVotingForInDiplo@CvTeam@@QBE?AW4TeamTypes@@XZ$0:
	lea	ecx, DWORD PTR _veVoteCandidates$223673[ebp]
	jmp	??1?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE@XZ ; CvWeightedVector<enum TeamTypes,63,1>::~CvWeightedVector<enum TeamTypes,63,1>
__ehhandler$?GetTeamVotingForInDiplo@CvTeam@@QBE?AW4TeamTypes@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-740]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetTeamVotingForInDiplo@CvTeam@@QBE?AW4TeamTypes@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetTeamVotingForInDiplo@CvTeam@@QBE?AW4TeamTypes@@XZ ENDP ; CvTeam::GetTeamVotingForInDiplo
PUBLIC	?GetProjectedVotesFromMinorAllies@CvTeam@@QBEHXZ ; CvTeam::GetProjectedVotesFromMinorAllies
; Function compile flags: /Odtp
;	COMDAT ?GetProjectedVotesFromMinorAllies@CvTeam@@QBEHXZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T233947 = -20						; size = 4
_pTeamLoop$223866 = -16					; size = 4
_eTeamLoop$223864 = -12					; size = 4
_iTeamLoop$223860 = -8					; size = 4
_iVotes$ = -4						; size = 4
?GetProjectedVotesFromMinorAllies@CvTeam@@QBEHXZ PROC	; CvTeam::GetProjectedVotesFromMinorAllies, COMDAT
; _this$ = ecx

; 2087 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2088 : 	int iVotes = 0;

	mov	DWORD PTR _iVotes$[ebp], 0

; 2089 : 	if (isAlive())

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+12], 0
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	$LN7@GetProject

; 2090 : 	{
; 2091 : 		for (int iTeamLoop = 0; iTeamLoop < MAX_CIV_TEAMS; iTeamLoop++)

	mov	DWORD PTR _iTeamLoop$223860[ebp], 0
	jmp	SHORT $LN6@GetProject
$LN5@GetProject:
	mov	eax, DWORD PTR _iTeamLoop$223860[ebp]
	add	eax, 1
	mov	DWORD PTR _iTeamLoop$223860[ebp], eax
$LN6@GetProject:
	cmp	DWORD PTR _iTeamLoop$223860[ebp], 63	; 0000003fH
	jge	$LN7@GetProject

; 2092 : 		{
; 2093 : 			TeamTypes eTeamLoop = (TeamTypes) iTeamLoop;

	mov	ecx, DWORD PTR _iTeamLoop$223860[ebp]
	mov	DWORD PTR _eTeamLoop$223864[ebp], ecx

; 2094 : 			CvTeam* pTeamLoop = &GET_TEAM(eTeamLoop);

	mov	edx, DWORD PTR _eTeamLoop$223864[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR _pTeamLoop$223866[ebp], edx

; 2095 : 			if (pTeamLoop->isAlive() && pTeamLoop->isMinorCiv() && !pTeamLoop->isBarbarian())

	mov	eax, DWORD PTR _pTeamLoop$223866[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+12], 0
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN3@GetProject
	mov	ecx, DWORD PTR _pTeamLoop$223866[ebp]
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@GetProject
	mov	ecx, DWORD PTR _pTeamLoop$223866[ebp]
	call	?isBarbarian@CvTeam@@QBE_NXZ		; CvTeam::isBarbarian
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@GetProject

; 2096 : 			{
; 2097 : 				// Minor civ team votes are definite things, given the situation doesn't change
; 2098 : 				if (GET_TEAM(eTeamLoop).GetTeamVotingForInDiplo() == GetID())

	mov	edx, DWORD PTR _eTeamLoop$223864[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T233947[ebp], edx
	mov	ecx, DWORD PTR $T233947[ebp]
	call	?GetTeamVotingForInDiplo@CvTeam@@QBE?AW4TeamTypes@@XZ ; CvTeam::GetTeamVotingForInDiplo
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	esi, eax
	jne	SHORT $LN3@GetProject

; 2099 : 				{
; 2100 : 					// Liberated minors are handled elsewhere				
; 2101 : 					if (GetLiberatedByTeam() != GetID())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLiberatedByTeam@CvTeam@@QBE?AW4TeamTypes@@XZ ; CvTeam::GetLiberatedByTeam
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	esi, eax
	je	SHORT $LN3@GetProject

; 2102 : 					{
; 2103 : 						iVotes++;

	mov	eax, DWORD PTR _iVotes$[ebp]
	add	eax, 1
	mov	DWORD PTR _iVotes$[ebp], eax
$LN3@GetProject:

; 2104 : 					}
; 2105 : 				}
; 2106 : 			}
; 2107 : 		}

	jmp	$LN5@GetProject
$LN7@GetProject:

; 2108 : 	}
; 2109 : 
; 2110 : 	return iVotes;

	mov	eax, DWORD PTR _iVotes$[ebp]

; 2111 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?GetProjectedVotesFromMinorAllies@CvTeam@@QBEHXZ ENDP	; CvTeam::GetProjectedVotesFromMinorAllies
_TEXT	ENDS
PUBLIC	?GetProjectedVotesFromLiberatedMinors@CvTeam@@QBEHXZ ; CvTeam::GetProjectedVotesFromLiberatedMinors
; Function compile flags: /Odtp
;	COMDAT ?GetProjectedVotesFromLiberatedMinors@CvTeam@@QBEHXZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T233962 = -20						; size = 4
_pTeamLoop$223881 = -16					; size = 4
_eTeamLoop$223879 = -12					; size = 4
_iTeamLoop$223875 = -8					; size = 4
_iVotes$ = -4						; size = 4
?GetProjectedVotesFromLiberatedMinors@CvTeam@@QBEHXZ PROC ; CvTeam::GetProjectedVotesFromLiberatedMinors, COMDAT
; _this$ = ecx

; 2116 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2117 : 	int iVotes = 0;

	mov	DWORD PTR _iVotes$[ebp], 0

; 2118 : 	if (isAlive())

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+12], 0
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	$LN7@GetProject@2

; 2119 : 	{
; 2120 : 		for (int iTeamLoop = 0; iTeamLoop < MAX_CIV_TEAMS; iTeamLoop++)

	mov	DWORD PTR _iTeamLoop$223875[ebp], 0
	jmp	SHORT $LN6@GetProject@2
$LN5@GetProject@2:
	mov	eax, DWORD PTR _iTeamLoop$223875[ebp]
	add	eax, 1
	mov	DWORD PTR _iTeamLoop$223875[ebp], eax
$LN6@GetProject@2:
	cmp	DWORD PTR _iTeamLoop$223875[ebp], 63	; 0000003fH
	jge	$LN7@GetProject@2

; 2121 : 		{
; 2122 : 			TeamTypes eTeamLoop = (TeamTypes) iTeamLoop;

	mov	ecx, DWORD PTR _iTeamLoop$223875[ebp]
	mov	DWORD PTR _eTeamLoop$223879[ebp], ecx

; 2123 : 			CvTeam* pTeamLoop = &GET_TEAM(eTeamLoop);

	mov	edx, DWORD PTR _eTeamLoop$223879[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR _pTeamLoop$223881[ebp], edx

; 2124 : 			if (pTeamLoop->isAlive() && pTeamLoop->isMinorCiv() && !pTeamLoop->isBarbarian())

	mov	eax, DWORD PTR _pTeamLoop$223881[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+12], 0
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN3@GetProject@2
	mov	ecx, DWORD PTR _pTeamLoop$223881[ebp]
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@GetProject@2
	mov	ecx, DWORD PTR _pTeamLoop$223881[ebp]
	call	?isBarbarian@CvTeam@@QBE_NXZ		; CvTeam::isBarbarian
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@GetProject@2

; 2125 : 			{
; 2126 : 				// Minor civ team votes are definite things, given the situation doesn't change
; 2127 : 				if (GET_TEAM(eTeamLoop).GetTeamVotingForInDiplo() == GetID())

	mov	edx, DWORD PTR _eTeamLoop$223879[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T233962[ebp], edx
	mov	ecx, DWORD PTR $T233962[ebp]
	call	?GetTeamVotingForInDiplo@CvTeam@@QBE?AW4TeamTypes@@XZ ; CvTeam::GetTeamVotingForInDiplo
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	esi, eax
	jne	SHORT $LN3@GetProject@2

; 2128 : 				{
; 2129 : 					// Liberated by us?
; 2130 : 					if (GetLiberatedByTeam() == GetID())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLiberatedByTeam@CvTeam@@QBE?AW4TeamTypes@@XZ ; CvTeam::GetLiberatedByTeam
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	esi, eax
	jne	SHORT $LN3@GetProject@2

; 2131 : 					{
; 2132 : 						iVotes++;

	mov	eax, DWORD PTR _iVotes$[ebp]
	add	eax, 1
	mov	DWORD PTR _iVotes$[ebp], eax
$LN3@GetProject@2:

; 2133 : 					}
; 2134 : 				}
; 2135 : 			}
; 2136 : 		}

	jmp	$LN5@GetProject@2
$LN7@GetProject@2:

; 2137 : 	}
; 2138 : 
; 2139 : 	return iVotes;

	mov	eax, DWORD PTR _iVotes$[ebp]

; 2140 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?GetProjectedVotesFromLiberatedMinors@CvTeam@@QBEHXZ ENDP ; CvTeam::GetProjectedVotesFromLiberatedMinors
_TEXT	ENDS
PUBLIC	?GetProjectedVotesFromCivs@CvTeam@@QBEHXZ	; CvTeam::GetProjectedVotesFromCivs
EXTRN	?GetPreviousVoteCast@CvGame@@QBE?AW4TeamTypes@@W42@@Z:PROC ; CvGame::GetPreviousVoteCast
; Function compile flags: /Odtp
;	COMDAT ?GetProjectedVotesFromCivs@CvTeam@@QBEHXZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T233977 = -20						; size = 4
_pTeamLoop$223896 = -16					; size = 4
_eTeamLoop$223894 = -12					; size = 4
_iTeamLoop$223890 = -8					; size = 4
_iVotes$ = -4						; size = 4
?GetProjectedVotesFromCivs@CvTeam@@QBEHXZ PROC		; CvTeam::GetProjectedVotesFromCivs, COMDAT
; _this$ = ecx

; 2145 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2146 : 	int iVotes = 0;

	mov	DWORD PTR _iVotes$[ebp], 0

; 2147 : 
; 2148 : 	if (isAlive())

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+12], 0
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	$LN6@GetProject@3

; 2149 : 	{
; 2150 : 		for (int iTeamLoop = 0; iTeamLoop < MAX_CIV_TEAMS; iTeamLoop++)

	mov	DWORD PTR _iTeamLoop$223890[ebp], 0
	jmp	SHORT $LN5@GetProject@3
$LN4@GetProject@3:
	mov	eax, DWORD PTR _iTeamLoop$223890[ebp]
	add	eax, 1
	mov	DWORD PTR _iTeamLoop$223890[ebp], eax
$LN5@GetProject@3:
	cmp	DWORD PTR _iTeamLoop$223890[ebp], 63	; 0000003fH
	jge	SHORT $LN6@GetProject@3

; 2151 : 		{
; 2152 : 			TeamTypes eTeamLoop = (TeamTypes) iTeamLoop;

	mov	ecx, DWORD PTR _iTeamLoop$223890[ebp]
	mov	DWORD PTR _eTeamLoop$223894[ebp], ecx

; 2153 : 			CvTeam* pTeamLoop = &GET_TEAM(eTeamLoop);

	mov	edx, DWORD PTR _eTeamLoop$223894[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR _pTeamLoop$223896[ebp], edx

; 2154 : 			if (pTeamLoop->isAlive() && !pTeamLoop->isMinorCiv() && !pTeamLoop->isBarbarian())

	mov	eax, DWORD PTR _pTeamLoop$223896[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+12], 0
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@GetProject@3
	mov	ecx, DWORD PTR _pTeamLoop$223896[ebp]
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@GetProject@3
	mov	ecx, DWORD PTR _pTeamLoop$223896[ebp]
	call	?isBarbarian@CvTeam@@QBE_NXZ		; CvTeam::isBarbarian
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@GetProject@3

; 2155 : 			{
; 2156 : 				// Did they vote for us last time?
; 2157 : 				if (GC.getGame().GetPreviousVoteCast(eTeamLoop) == GetID())

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T233977[ebp], edx
	mov	eax, DWORD PTR _eTeamLoop$223894[ebp]
	push	eax
	mov	ecx, DWORD PTR $T233977[ebp]
	call	?GetPreviousVoteCast@CvGame@@QBE?AW4TeamTypes@@W42@@Z ; CvGame::GetPreviousVoteCast
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	esi, eax
	jne	SHORT $LN2@GetProject@3

; 2158 : 					iVotes++;

	mov	ecx, DWORD PTR _iVotes$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iVotes$[ebp], ecx
$LN2@GetProject@3:

; 2159 : 			}
; 2160 : 		}

	jmp	$LN4@GetProject@3
$LN6@GetProject@3:

; 2161 : 	}
; 2162 : 
; 2163 : 	return iVotes;

	mov	eax, DWORD PTR _iVotes$[ebp]

; 2164 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?GetProjectedVotesFromCivs@CvTeam@@QBEHXZ ENDP		; CvTeam::GetProjectedVotesFromCivs
_TEXT	ENDS
PUBLIC	?IsHomeOfUnitedNations@CvTeam@@QBE_NXZ		; CvTeam::IsHomeOfUnitedNations
PUBLIC	?GetTotalProjectedVotes@CvTeam@@QBEHXZ		; CvTeam::GetTotalProjectedVotes
; Function compile flags: /Odtp
;	COMDAT ?GetTotalProjectedVotes@CvTeam@@QBEHXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_iVotesFromUN$223905 = -8				; size = 4
_iVotes$ = -4						; size = 4
?GetTotalProjectedVotes@CvTeam@@QBEHXZ PROC		; CvTeam::GetTotalProjectedVotes, COMDAT
; _this$ = ecx

; 2169 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2170 : 	int iVotes = 0;

	mov	DWORD PTR _iVotes$[ebp], 0

; 2171 : 
; 2172 : 	if (isAlive())

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+12], 0
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@GetTotalPr

; 2173 : 	{
; 2174 : 		// Majors
; 2175 : 		iVotes += GetProjectedVotesFromCivs();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetProjectedVotesFromCivs@CvTeam@@QBEHXZ ; CvTeam::GetProjectedVotesFromCivs
	add	eax, DWORD PTR _iVotes$[ebp]
	mov	DWORD PTR _iVotes$[ebp], eax

; 2176 : 
; 2177 : 		// Minor Allies
; 2178 : 		iVotes += GetProjectedVotesFromMinorAllies();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetProjectedVotesFromMinorAllies@CvTeam@@QBEHXZ ; CvTeam::GetProjectedVotesFromMinorAllies
	add	eax, DWORD PTR _iVotes$[ebp]
	mov	DWORD PTR _iVotes$[ebp], eax

; 2179 : 
; 2180 : 		// Liberated Minors
; 2181 : 		iVotes += GetProjectedVotesFromLiberatedMinors();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetProjectedVotesFromLiberatedMinors@CvTeam@@QBEHXZ ; CvTeam::GetProjectedVotesFromLiberatedMinors
	add	eax, DWORD PTR _iVotes$[ebp]
	mov	DWORD PTR _iVotes$[ebp], eax

; 2182 : 
; 2183 : 		// UN
; 2184 : 		if (IsHomeOfUnitedNations())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHomeOfUnitedNations@CvTeam@@QBE_NXZ	; CvTeam::IsHomeOfUnitedNations
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@GetTotalPr

; 2185 : 		{
; 2186 : 			int iVotesFromUN = /*1*/ GC.getOWN_UNITED_NATIONS_VOTE_BONUS();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7728
	mov	DWORD PTR _iVotesFromUN$223905[ebp], ecx

; 2187 : 			iVotes += iVotesFromUN;

	mov	edx, DWORD PTR _iVotes$[ebp]
	add	edx, DWORD PTR _iVotesFromUN$223905[ebp]
	mov	DWORD PTR _iVotes$[ebp], edx
$LN2@GetTotalPr:

; 2188 : 		}
; 2189 : 	}
; 2190 : 
; 2191 : 	return iVotes;

	mov	eax, DWORD PTR _iVotes$[ebp]

; 2192 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTotalProjectedVotes@CvTeam@@QBEHXZ ENDP		; CvTeam::GetTotalProjectedVotes
_TEXT	ENDS
PUBLIC	?GetTotalSecuredVotes@CvTeam@@QBEHXZ		; CvTeam::GetTotalSecuredVotes
; Function compile flags: /Odtp
;	COMDAT ?GetTotalSecuredVotes@CvTeam@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTotalSecuredVotes@CvTeam@@QBEHXZ PROC		; CvTeam::GetTotalSecuredVotes, COMDAT
; _this$ = ecx

; 2198 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2199 : 	return GetTotalProjectedVotes();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTotalProjectedVotes@CvTeam@@QBEHXZ	; CvTeam::GetTotalProjectedVotes

; 2200 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTotalSecuredVotes@CvTeam@@QBEHXZ ENDP		; CvTeam::GetTotalSecuredVotes
_TEXT	ENDS
PUBLIC	?getAtWarCount@CvTeam@@QBEH_N@Z			; CvTeam::getAtWarCount
; Function compile flags: /Odtp
;	COMDAT ?getAtWarCount@CvTeam@@QBEH_N@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T234000 = -16						; size = 4
$T233993 = -12						; size = 4
_iCount$ = -8						; size = 4
_iI$ = -4						; size = 4
_bIgnoreMinors$ = 8					; size = 1
?getAtWarCount@CvTeam@@QBEH_N@Z PROC			; CvTeam::getAtWarCount, COMDAT
; _this$ = ecx

; 2204 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 2205 : 	int iCount;
; 2206 : 	int iI;
; 2207 : 
; 2208 : 	iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0

; 2209 : 
; 2210 : 	for(iI = 0; iI < MAX_CIV_TEAMS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN7@getAtWarCo
$LN6@getAtWarCo:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN7@getAtWarCo:
	cmp	DWORD PTR _iI$[ebp], 63			; 0000003fH
	jge	SHORT $LN5@getAtWarCo

; 2211 : 	{
; 2212 : 		if(GET_TEAM((TeamTypes)iI).isAlive())

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T233993[ebp], ecx
	mov	edx, DWORD PTR $T233993[ebp]
	xor	eax, eax
	cmp	DWORD PTR [edx+12], 0
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@getAtWarCo

; 2213 : 		{
; 2214 : 			if(!bIgnoreMinors || !(GET_TEAM((TeamTypes)iI).isMinorCiv()))

	movzx	edx, BYTE PTR _bIgnoreMinors$[ebp]
	test	edx, edx
	je	SHORT $LN2@getAtWarCo
	mov	eax, DWORD PTR _iI$[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T234000[ebp], eax
	mov	ecx, DWORD PTR $T234000[ebp]
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN4@getAtWarCo
$LN2@getAtWarCo:

; 2215 : 			{
; 2216 : 				if(isAtWar((TeamTypes)iI))

	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@getAtWarCo

; 2217 : 				{
; 2218 : 					CvAssert(iI != GetID());
; 2219 : 					iCount++;

	mov	ecx, DWORD PTR _iCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iCount$[ebp], ecx
$LN4@getAtWarCo:

; 2220 : 				}
; 2221 : 			}
; 2222 : 		}
; 2223 : 	}

	jmp	SHORT $LN6@getAtWarCo
$LN5@getAtWarCo:

; 2224 : 
; 2225 : 	return iCount;

	mov	eax, DWORD PTR _iCount$[ebp]

; 2226 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getAtWarCount@CvTeam@@QBEH_N@Z ENDP			; CvTeam::getAtWarCount
_TEXT	ENDS
PUBLIC	?getHasMetCivCount@CvTeam@@QBEH_N@Z		; CvTeam::getHasMetCivCount
; Function compile flags: /Odtp
;	COMDAT ?getHasMetCivCount@CvTeam@@QBEH_N@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T234013 = -16						; size = 4
$T234006 = -12						; size = 4
_iCount$ = -8						; size = 4
_iI$ = -4						; size = 4
_bIgnoreMinors$ = 8					; size = 1
?getHasMetCivCount@CvTeam@@QBEH_N@Z PROC		; CvTeam::getHasMetCivCount, COMDAT
; _this$ = ecx

; 2231 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 2232 : 	int iCount;
; 2233 : 	int iI;
; 2234 : 
; 2235 : 	iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0

; 2236 : 
; 2237 : 	for(iI = 0; iI < MAX_CIV_TEAMS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN8@getHasMetC
$LN7@getHasMetC:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN8@getHasMetC:
	cmp	DWORD PTR _iI$[ebp], 63			; 0000003fH
	jge	SHORT $LN6@getHasMetC

; 2238 : 	{
; 2239 : 		if(GET_TEAM((TeamTypes)iI).isAlive())

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T234006[ebp], ecx
	mov	edx, DWORD PTR $T234006[ebp]
	xor	eax, eax
	cmp	DWORD PTR [edx+12], 0
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@getHasMetC

; 2240 : 		{
; 2241 : 			if(iI != GetID())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR _iI$[ebp], eax
	je	SHORT $LN5@getHasMetC

; 2242 : 			{
; 2243 : 				if(!bIgnoreMinors || !(GET_TEAM((TeamTypes)iI).isMinorCiv()))

	movzx	edx, BYTE PTR _bIgnoreMinors$[ebp]
	test	edx, edx
	je	SHORT $LN2@getHasMetC
	mov	eax, DWORD PTR _iI$[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T234013[ebp], eax
	mov	ecx, DWORD PTR $T234013[ebp]
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN5@getHasMetC
$LN2@getHasMetC:

; 2244 : 				{
; 2245 : 					if(isHasMet((TeamTypes)iI))

	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@getHasMetC

; 2246 : 					{
; 2247 : 						CvAssert(iI != GetID());
; 2248 : 						iCount++;

	mov	ecx, DWORD PTR _iCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iCount$[ebp], ecx
$LN5@getHasMetC:

; 2249 : 					}
; 2250 : 				}
; 2251 : 			}
; 2252 : 		}
; 2253 : 	}

	jmp	$LN7@getHasMetC
$LN6@getHasMetC:

; 2254 : 
; 2255 : 	return iCount;

	mov	eax, DWORD PTR _iCount$[ebp]

; 2256 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getHasMetCivCount@CvTeam@@QBEH_N@Z ENDP		; CvTeam::getHasMetCivCount
_TEXT	ENDS
PUBLIC	?hasMetHuman@CvTeam@@QBE_NXZ			; CvTeam::hasMetHuman
; Function compile flags: /Odtp
;	COMDAT ?hasMetHuman@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T234026 = -12						; size = 4
$T234019 = -8						; size = 4
_iI$ = -4						; size = 4
?hasMetHuman@CvTeam@@QBE_NXZ PROC			; CvTeam::hasMetHuman, COMDAT
; _this$ = ecx

; 2261 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2262 : 	int iI;
; 2263 : 
; 2264 : 	for(iI = 0; iI < MAX_CIV_TEAMS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN7@hasMetHuma
$LN6@hasMetHuma:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN7@hasMetHuma:
	cmp	DWORD PTR _iI$[ebp], 63			; 0000003fH
	jge	SHORT $LN5@hasMetHuma

; 2265 : 	{
; 2266 : 		if(GET_TEAM((TeamTypes)iI).isAlive())

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T234019[ebp], ecx
	mov	edx, DWORD PTR $T234019[ebp]
	xor	eax, eax
	cmp	DWORD PTR [edx+12], 0
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@hasMetHuma

; 2267 : 		{
; 2268 : 			if(iI != GetID())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR _iI$[ebp], eax
	je	SHORT $LN4@hasMetHuma

; 2269 : 			{
; 2270 : 				if(GET_TEAM((TeamTypes)iI).isHuman())

	mov	edx, DWORD PTR _iI$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T234026[ebp], edx
	mov	ecx, DWORD PTR $T234026[ebp]
	call	?isHuman@CvTeam@@QBE_NXZ		; CvTeam::isHuman
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@hasMetHuma

; 2271 : 				{
; 2272 : 					if(isHasMet((TeamTypes)iI))

	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN4@hasMetHuma

; 2273 : 					{
; 2274 : 						CvAssert(iI != GetID());
; 2275 : 						return true;

	mov	al, 1
	jmp	SHORT $LN8@hasMetHuma
$LN4@hasMetHuma:

; 2276 : 					}
; 2277 : 				}
; 2278 : 			}
; 2279 : 		}
; 2280 : 	}

	jmp	SHORT $LN6@hasMetHuma
$LN5@hasMetHuma:

; 2281 : 
; 2282 : 	return false;

	xor	al, al
$LN8@hasMetHuma:

; 2283 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?hasMetHuman@CvTeam@@QBE_NXZ ENDP			; CvTeam::hasMetHuman
_TEXT	ENDS
PUBLIC	?getDefensivePactCount@CvTeam@@QBEHW4TeamTypes@@@Z ; CvTeam::getDefensivePactCount
; Function compile flags: /Odtp
;	COMDAT ?getDefensivePactCount@CvTeam@@QBEHW4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T234039 = -16						; size = 4
$T234032 = -12						; size = 4
_iCount$ = -8						; size = 4
_iI$ = -4						; size = 4
_eTeam$ = 8						; size = 4
?getDefensivePactCount@CvTeam@@QBEHW4TeamTypes@@@Z PROC	; CvTeam::getDefensivePactCount, COMDAT
; _this$ = ecx

; 2288 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 2289 : 	int iCount;
; 2290 : 	int iI;
; 2291 : 
; 2292 : 	iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0

; 2293 : 
; 2294 : 	for(iI = 0; iI < MAX_CIV_TEAMS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN8@getDefensi@2
$LN7@getDefensi@2:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN8@getDefensi@2:
	cmp	DWORD PTR _iI$[ebp], 63			; 0000003fH
	jge	SHORT $LN6@getDefensi@2

; 2295 : 	{
; 2296 : 		if(GET_TEAM((TeamTypes)iI).isAlive())

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T234032[ebp], ecx
	mov	edx, DWORD PTR $T234032[ebp]
	xor	eax, eax
	cmp	DWORD PTR [edx+12], 0
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@getDefensi@2

; 2297 : 		{
; 2298 : 			if(iI != m_eID)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iI$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	je	SHORT $LN5@getDefensi@2

; 2299 : 			{
; 2300 : 				if(IsHasDefensivePact((TeamTypes)iI))

	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHasDefensivePact@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsHasDefensivePact
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN5@getDefensi@2

; 2301 : 				{
; 2302 : 					if(NO_TEAM == eTeam || GET_TEAM(eTeam).isHasMet((TeamTypes)iI))

	cmp	DWORD PTR _eTeam$[ebp], -1
	je	SHORT $LN1@getDefensi@2
	mov	eax, DWORD PTR _eTeam$[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T234039[ebp], eax
	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T234039[ebp]
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN5@getDefensi@2
$LN1@getDefensi@2:

; 2303 : 					{
; 2304 : 						iCount++;

	mov	eax, DWORD PTR _iCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCount$[ebp], eax
$LN5@getDefensi@2:

; 2305 : 					}
; 2306 : 				}
; 2307 : 			}
; 2308 : 		}
; 2309 : 	}

	jmp	$LN7@getDefensi@2
$LN6@getDefensi@2:

; 2310 : 
; 2311 : 	return iCount;

	mov	eax, DWORD PTR _iCount$[ebp]

; 2312 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getDefensivePactCount@CvTeam@@QBEHW4TeamTypes@@@Z ENDP	; CvTeam::getDefensivePactCount
_TEXT	ENDS
PUBLIC	?getUnitClassMaking@CvTeam@@QBEHW4UnitClassTypes@@@Z ; CvTeam::getUnitClassMaking
EXTRN	?getUnitClassMaking@CvPlayer@@QBEHW4UnitClassTypes@@@Z:PROC ; CvPlayer::getUnitClassMaking
; Function compile flags: /Odtp
;	COMDAT ?getUnitClassMaking@CvTeam@@QBEHW4UnitClassTypes@@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T234062 = -20						; size = 4
$T234053 = -13						; size = 1
_kPlayer$223982 = -12					; size = 4
_iCount$ = -8						; size = 4
_iI$ = -4						; size = 4
_eUnitClass$ = 8					; size = 4
?getUnitClassMaking@CvTeam@@QBEHW4UnitClassTypes@@@Z PROC ; CvTeam::getUnitClassMaking, COMDAT
; _this$ = ecx

; 2316 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 2317 : 	int iCount;
; 2318 : 	int iI;
; 2319 : 
; 2320 : 	iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0

; 2321 : 
; 2322 : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN5@getUnitCla
$LN4@getUnitCla:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN5@getUnitCla:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	SHORT $LN3@getUnitCla

; 2323 : 	{
; 2324 : 		CvPlayerAI& kPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$223982[ebp], ecx

; 2325 : 		if(kPlayer.isAlive())

	mov	edx, DWORD PTR _kPlayer$223982[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T234053[ebp], al
	movzx	ecx, BYTE PTR $T234053[ebp]
	test	ecx, ecx
	je	SHORT $LN2@getUnitCla

; 2326 : 		{
; 2327 : 			if(kPlayer.getTeam() == m_eID)

	mov	edx, DWORD PTR _kPlayer$223982[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T234062[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T234062[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN2@getUnitCla

; 2328 : 			{
; 2329 : 				iCount += kPlayer.getUnitClassMaking(eUnitClass);

	mov	eax, DWORD PTR _eUnitClass$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kPlayer$223982[ebp]
	call	?getUnitClassMaking@CvPlayer@@QBEHW4UnitClassTypes@@@Z ; CvPlayer::getUnitClassMaking
	add	eax, DWORD PTR _iCount$[ebp]
	mov	DWORD PTR _iCount$[ebp], eax
$LN2@getUnitCla:

; 2330 : 			}
; 2331 : 		}
; 2332 : 	}

	jmp	SHORT $LN4@getUnitCla
$LN3@getUnitCla:

; 2333 : 
; 2334 : 	return iCount;

	mov	eax, DWORD PTR _iCount$[ebp]

; 2335 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getUnitClassMaking@CvTeam@@QBEHW4UnitClassTypes@@@Z ENDP ; CvTeam::getUnitClassMaking
_TEXT	ENDS
PUBLIC	?getUnitClassCountPlusMaking@CvTeam@@QBEHW4UnitClassTypes@@@Z ; CvTeam::getUnitClassCountPlusMaking
; Function compile flags: /Odtp
;	COMDAT ?getUnitClassCountPlusMaking@CvTeam@@QBEHW4UnitClassTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?getUnitClassCountPlusMaking@CvTeam@@QBEHW4UnitClassTypes@@@Z PROC ; CvTeam::getUnitClassCountPlusMaking, COMDAT
; _this$ = ecx

; 2340 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2341 : 	return (getUnitClassCount(eIndex) + getUnitClassMaking(eIndex));

	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getUnitClassCount@CvTeam@@QBEHW4UnitClassTypes@@@Z ; CvTeam::getUnitClassCount
	mov	esi, eax
	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getUnitClassMaking@CvTeam@@QBEHW4UnitClassTypes@@@Z ; CvTeam::getUnitClassMaking
	add	eax, esi

; 2342 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?getUnitClassCountPlusMaking@CvTeam@@QBEHW4UnitClassTypes@@@Z ENDP ; CvTeam::getUnitClassCountPlusMaking
_TEXT	ENDS
PUBLIC	?getBuildingClassMaking@CvTeam@@QBEHW4BuildingClassTypes@@@Z ; CvTeam::getBuildingClassMaking
EXTRN	?getBuildingClassMaking@CvPlayer@@QBEHW4BuildingClassTypes@@@Z:PROC ; CvPlayer::getBuildingClassMaking
; Function compile flags: /Odtp
;	COMDAT ?getBuildingClassMaking@CvTeam@@QBEHW4BuildingClassTypes@@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T234087 = -20						; size = 4
$T234078 = -13						; size = 1
_kPlayer$223999 = -12					; size = 4
_iCount$ = -8						; size = 4
_iI$ = -4						; size = 4
_eBuildingClass$ = 8					; size = 4
?getBuildingClassMaking@CvTeam@@QBEHW4BuildingClassTypes@@@Z PROC ; CvTeam::getBuildingClassMaking, COMDAT
; _this$ = ecx

; 2347 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 2348 : 	int iCount;
; 2349 : 	int iI;
; 2350 : 
; 2351 : 	iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0

; 2352 : 
; 2353 : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN5@getBuildin
$LN4@getBuildin:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN5@getBuildin:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	SHORT $LN3@getBuildin

; 2354 : 	{
; 2355 : 		CvPlayerAI& kPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$223999[ebp], ecx

; 2356 : 		if(kPlayer.isAlive())

	mov	edx, DWORD PTR _kPlayer$223999[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T234078[ebp], al
	movzx	ecx, BYTE PTR $T234078[ebp]
	test	ecx, ecx
	je	SHORT $LN2@getBuildin

; 2357 : 		{
; 2358 : 			if(kPlayer.getTeam() == m_eID)

	mov	edx, DWORD PTR _kPlayer$223999[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T234087[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T234087[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN2@getBuildin

; 2359 : 			{
; 2360 : 				iCount += kPlayer.getBuildingClassMaking(eBuildingClass);

	mov	eax, DWORD PTR _eBuildingClass$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kPlayer$223999[ebp]
	call	?getBuildingClassMaking@CvPlayer@@QBEHW4BuildingClassTypes@@@Z ; CvPlayer::getBuildingClassMaking
	add	eax, DWORD PTR _iCount$[ebp]
	mov	DWORD PTR _iCount$[ebp], eax
$LN2@getBuildin:

; 2361 : 			}
; 2362 : 		}
; 2363 : 	}

	jmp	SHORT $LN4@getBuildin
$LN3@getBuildin:

; 2364 : 
; 2365 : 	return iCount;

	mov	eax, DWORD PTR _iCount$[ebp]

; 2366 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getBuildingClassMaking@CvTeam@@QBEHW4BuildingClassTypes@@@Z ENDP ; CvTeam::getBuildingClassMaking
_TEXT	ENDS
PUBLIC	?getBuildingClassCountPlusMaking@CvTeam@@QBEHW4BuildingClassTypes@@@Z ; CvTeam::getBuildingClassCountPlusMaking
; Function compile flags: /Odtp
;	COMDAT ?getBuildingClassCountPlusMaking@CvTeam@@QBEHW4BuildingClassTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?getBuildingClassCountPlusMaking@CvTeam@@QBEHW4BuildingClassTypes@@@Z PROC ; CvTeam::getBuildingClassCountPlusMaking, COMDAT
; _this$ = ecx

; 2371 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2372 : 	return (getBuildingClassCount(eIndex) + getBuildingClassMaking(eIndex));

	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getBuildingClassCount@CvTeam@@QBEHW4BuildingClassTypes@@@Z ; CvTeam::getBuildingClassCount
	mov	esi, eax
	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getBuildingClassMaking@CvTeam@@QBEHW4BuildingClassTypes@@@Z ; CvTeam::getBuildingClassMaking
	add	eax, esi

; 2373 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?getBuildingClassCountPlusMaking@CvTeam@@QBEHW4BuildingClassTypes@@@Z ENDP ; CvTeam::getBuildingClassCountPlusMaking
_TEXT	ENDS
PUBLIC	?countNumUnitsByArea@CvTeam@@QBEHPAVCvArea@@@Z	; CvTeam::countNumUnitsByArea
EXTRN	?getUnitsPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z:PROC ; CvArea::getUnitsPerPlayer
; Function compile flags: /Odtp
;	COMDAT ?countNumUnitsByArea@CvTeam@@QBEHPAVCvArea@@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T234112 = -20						; size = 4
$T234103 = -13						; size = 1
_kPlayer$224016 = -12					; size = 4
_iCount$ = -8						; size = 4
_iI$ = -4						; size = 4
_pArea$ = 8						; size = 4
?countNumUnitsByArea@CvTeam@@QBEHPAVCvArea@@@Z PROC	; CvTeam::countNumUnitsByArea, COMDAT
; _this$ = ecx

; 2377 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 2378 : 	int iCount;
; 2379 : 	int iI;
; 2380 : 
; 2381 : 	iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0

; 2382 : 
; 2383 : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN5@countNumUn
$LN4@countNumUn:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN5@countNumUn:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	SHORT $LN3@countNumUn

; 2384 : 	{
; 2385 : 		CvPlayerAI& kPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$224016[ebp], ecx

; 2386 : 		if(kPlayer.isAlive())

	mov	edx, DWORD PTR _kPlayer$224016[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T234103[ebp], al
	movzx	ecx, BYTE PTR $T234103[ebp]
	test	ecx, ecx
	je	SHORT $LN2@countNumUn

; 2387 : 		{
; 2388 : 			if(kPlayer.getTeam() == m_eID)

	mov	edx, DWORD PTR _kPlayer$224016[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T234112[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T234112[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN2@countNumUn

; 2389 : 			{
; 2390 : 				iCount += pArea->getUnitsPerPlayer((PlayerTypes)iI);

	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pArea$[ebp]
	call	?getUnitsPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z ; CvArea::getUnitsPerPlayer
	add	eax, DWORD PTR _iCount$[ebp]
	mov	DWORD PTR _iCount$[ebp], eax
$LN2@countNumUn:

; 2391 : 			}
; 2392 : 		}
; 2393 : 	}

	jmp	SHORT $LN4@countNumUn
$LN3@countNumUn:

; 2394 : 
; 2395 : 	return iCount;

	mov	eax, DWORD PTR _iCount$[ebp]

; 2396 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?countNumUnitsByArea@CvTeam@@QBEHPAVCvArea@@@Z ENDP	; CvTeam::countNumUnitsByArea
_TEXT	ENDS
PUBLIC	?countNumCitiesByArea@CvTeam@@QBEHPAVCvArea@@@Z	; CvTeam::countNumCitiesByArea
EXTRN	?getCitiesPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z:PROC ; CvArea::getCitiesPerPlayer
; Function compile flags: /Odtp
;	COMDAT ?countNumCitiesByArea@CvTeam@@QBEHPAVCvArea@@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T234135 = -20						; size = 4
$T234126 = -13						; size = 1
_kPlayer$224030 = -12					; size = 4
_iCount$ = -8						; size = 4
_iI$ = -4						; size = 4
_pArea$ = 8						; size = 4
?countNumCitiesByArea@CvTeam@@QBEHPAVCvArea@@@Z PROC	; CvTeam::countNumCitiesByArea, COMDAT
; _this$ = ecx

; 2401 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 2402 : 	int iCount;
; 2403 : 	int iI;
; 2404 : 
; 2405 : 	iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0

; 2406 : 
; 2407 : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN5@countNumCi
$LN4@countNumCi:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN5@countNumCi:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	SHORT $LN3@countNumCi

; 2408 : 	{
; 2409 : 		CvPlayerAI& kPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$224030[ebp], ecx

; 2410 : 		if(kPlayer.isAlive())

	mov	edx, DWORD PTR _kPlayer$224030[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T234126[ebp], al
	movzx	ecx, BYTE PTR $T234126[ebp]
	test	ecx, ecx
	je	SHORT $LN2@countNumCi

; 2411 : 		{
; 2412 : 			if(kPlayer.getTeam() == m_eID)

	mov	edx, DWORD PTR _kPlayer$224030[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T234135[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T234135[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN2@countNumCi

; 2413 : 			{
; 2414 : 				iCount += pArea->getCitiesPerPlayer((PlayerTypes)iI);

	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pArea$[ebp]
	call	?getCitiesPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z ; CvArea::getCitiesPerPlayer
	add	eax, DWORD PTR _iCount$[ebp]
	mov	DWORD PTR _iCount$[ebp], eax
$LN2@countNumCi:

; 2415 : 			}
; 2416 : 		}
; 2417 : 	}

	jmp	SHORT $LN4@countNumCi
$LN3@countNumCi:

; 2418 : 
; 2419 : 	return iCount;

	mov	eax, DWORD PTR _iCount$[ebp]

; 2420 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?countNumCitiesByArea@CvTeam@@QBEHPAVCvArea@@@Z ENDP	; CvTeam::countNumCitiesByArea
_TEXT	ENDS
PUBLIC	?countTotalPopulationByArea@CvTeam@@QBEHPAVCvArea@@@Z ; CvTeam::countTotalPopulationByArea
EXTRN	?getPopulationPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z:PROC ; CvArea::getPopulationPerPlayer
; Function compile flags: /Odtp
;	COMDAT ?countTotalPopulationByArea@CvTeam@@QBEHPAVCvArea@@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T234158 = -20						; size = 4
$T234149 = -13						; size = 1
_kPlayer$224044 = -12					; size = 4
_iCount$ = -8						; size = 4
_iI$ = -4						; size = 4
_pArea$ = 8						; size = 4
?countTotalPopulationByArea@CvTeam@@QBEHPAVCvArea@@@Z PROC ; CvTeam::countTotalPopulationByArea, COMDAT
; _this$ = ecx

; 2425 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 2426 : 	int iCount;
; 2427 : 	int iI;
; 2428 : 
; 2429 : 	iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0

; 2430 : 
; 2431 : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN5@countTotal
$LN4@countTotal:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN5@countTotal:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	SHORT $LN3@countTotal

; 2432 : 	{
; 2433 : 		CvPlayerAI& kPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$224044[ebp], ecx

; 2434 : 		if(kPlayer.isAlive())

	mov	edx, DWORD PTR _kPlayer$224044[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T234149[ebp], al
	movzx	ecx, BYTE PTR $T234149[ebp]
	test	ecx, ecx
	je	SHORT $LN2@countTotal

; 2435 : 		{
; 2436 : 			if(kPlayer.getTeam() == m_eID)

	mov	edx, DWORD PTR _kPlayer$224044[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T234158[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T234158[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN2@countTotal

; 2437 : 			{
; 2438 : 				iCount += pArea->getPopulationPerPlayer((PlayerTypes)iI);

	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pArea$[ebp]
	call	?getPopulationPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z ; CvArea::getPopulationPerPlayer
	add	eax, DWORD PTR _iCount$[ebp]
	mov	DWORD PTR _iCount$[ebp], eax
$LN2@countTotal:

; 2439 : 			}
; 2440 : 		}
; 2441 : 	}

	jmp	SHORT $LN4@countTotal
$LN3@countTotal:

; 2442 : 
; 2443 : 	return iCount;

	mov	eax, DWORD PTR _iCount$[ebp]

; 2444 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?countTotalPopulationByArea@CvTeam@@QBEHPAVCvArea@@@Z ENDP ; CvTeam::countTotalPopulationByArea
_TEXT	ENDS
PUBLIC	?countEnemyDangerByArea@CvTeam@@QBEHPAVCvArea@@@Z ; CvTeam::countEnemyDangerByArea
EXTRN	?plotCount@CvPlot@@QBEHP6A_NPBVCvUnit@@HH@ZHHW4PlayerTypes@@W4TeamTypes@@1HH@Z:PROC ; CvPlot::plotCount
EXTRN	?PUF_canDefendEnemy@@YA_NPBVCvUnit@@HH@Z:PROC	; PUF_canDefendEnemy
EXTRN	?PUF_isVisible@@YA_NPBVCvUnit@@HH@Z:PROC	; PUF_isVisible
EXTRN	?area@CvPlot@@QBEPAVCvArea@@XZ:PROC		; CvPlot::area
; Function compile flags: /Odtp
;	COMDAT ?countEnemyDangerByArea@CvTeam@@QBEHPAVCvArea@@@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T234192 = -32						; size = 4
_playerID$234184 = -28					; size = 4
$T234172 = -24						; size = 4
$T234168 = -20						; size = 4
$T234164 = -16						; size = 4
_iCount$ = -12						; size = 4
_iI$ = -8						; size = 4
_pLoopPlot$ = -4					; size = 4
_pArea$ = 8						; size = 4
?countEnemyDangerByArea@CvTeam@@QBEHPAVCvArea@@@Z PROC	; CvTeam::countEnemyDangerByArea, COMDAT
; _this$ = ecx

; 2449 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 2450 : 	CvPlot* pLoopPlot;
; 2451 : 	int iCount;
; 2452 : #ifdef AUI_WARNING_FIXES
; 2453 : 	uint iI;
; 2454 : #else
; 2455 : 	int iI;
; 2456 : #endif
; 2457 : 
; 2458 : 	iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0

; 2459 : 
; 2460 : 	for(iI = 0; iI < GC.getMap().numPlots(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN6@countEnemy
$LN5@countEnemy:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN6@countEnemy:
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T234164[ebp], ecx
	mov	edx, DWORD PTR $T234164[ebp]
	mov	eax, DWORD PTR [edx+4028]
	mov	DWORD PTR $T234168[ebp], eax
	mov	ecx, DWORD PTR _iI$[ebp]
	cmp	ecx, DWORD PTR $T234168[ebp]
	jge	$LN4@countEnemy

; 2461 : 	{
; 2462 : 		pLoopPlot = GC.getMap().plotByIndexUnchecked(iI);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T234172[ebp], edx
	mov	eax, DWORD PTR _iI$[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T234172[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR _pLoopPlot$[ebp], eax

; 2463 : 
; 2464 : 		if(pLoopPlot != NULL)

	je	SHORT $LN3@countEnemy

; 2465 : 		{
; 2466 : 			if(pLoopPlot->area() == pArea)

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	cmp	eax, DWORD PTR _pArea$[ebp]
	jne	SHORT $LN3@countEnemy

; 2467 : 			{
; 2468 : 				if(pLoopPlot->getTeam() == GetID())

	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR _playerID$234184[ebp], eax
	cmp	DWORD PTR _playerID$234184[ebp], -1
	je	SHORT $LN18@countEnemy
	mov	ecx, DWORD PTR _playerID$234184[ebp]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T234192[ebp], eax
	jmp	SHORT $LN19@countEnemy
	jmp	SHORT $LN19@countEnemy
$LN18@countEnemy:
	mov	DWORD PTR $T234192[ebp], -1
$LN19@countEnemy:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T234192[ebp], eax
	jne	SHORT $LN3@countEnemy

; 2469 : 				{
; 2470 : #ifdef AUI_WARNING_FIXES
; 2471 : 					iCount += pLoopPlot->plotCount(PUF_canDefendEnemy, getLeaderID(), -1, NO_PLAYER, NO_TEAM, PUF_isVisible, getLeaderID());
; 2472 : #else
; 2473 : 					iCount += pLoopPlot->plotCount(PUF_canDefendEnemy, getLeaderID(), false, NO_PLAYER, NO_TEAM, PUF_isVisible, getLeaderID());

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	push	eax
	push	OFFSET ?PUF_isVisible@@YA_NPBVCvUnit@@HH@Z ; PUF_isVisible
	push	-1
	push	-1
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	push	eax
	push	OFFSET ?PUF_canDefendEnemy@@YA_NPBVCvUnit@@HH@Z ; PUF_canDefendEnemy
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?plotCount@CvPlot@@QBEHP6A_NPBVCvUnit@@HH@ZHHW4PlayerTypes@@W4TeamTypes@@1HH@Z ; CvPlot::plotCount
	add	eax, DWORD PTR _iCount$[ebp]
	mov	DWORD PTR _iCount$[ebp], eax
$LN3@countEnemy:

; 2474 : #endif
; 2475 : 				}
; 2476 : 			}
; 2477 : 		}
; 2478 : 	}

	jmp	$LN5@countEnemy
$LN4@countEnemy:

; 2479 : 
; 2480 : 	return iCount;

	mov	eax, DWORD PTR _iCount$[ebp]

; 2481 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?countEnemyDangerByArea@CvTeam@@QBEHPAVCvArea@@@Z ENDP	; CvTeam::countEnemyDangerByArea
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ PROC	; CvTeam::GetTeamTechs, COMDAT
; _this$ = ecx

; 2485 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2486 : 	return m_pTeamTechs;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+2980]

; 2487 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ENDP	; CvTeam::GetTeamTechs
_TEXT	ENDS
EXTRN	?isHuman@CvPlayer@@QBE_NXZ:PROC			; CvPlayer::isHuman
; Function compile flags: /Odtp
;	COMDAT ?isHuman@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T234226 = -24						; size = 4
$T234222 = -20						; size = 4
$T234213 = -16						; size = 4
$T234209 = -9						; size = 1
$T234200 = -8						; size = 4
_iI$ = -4						; size = 4
?isHuman@CvTeam@@QBE_NXZ PROC				; CvTeam::isHuman, COMDAT
; _this$ = ecx

; 2491 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 2492 : 	int iI;
; 2493 : 
; 2494 : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN5@isHuman
$LN4@isHuman:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN5@isHuman:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	$LN3@isHuman

; 2495 : 	{
; 2496 : 		if(GET_PLAYER((PlayerTypes)iI).isAlive() && GET_PLAYER((PlayerTypes)iI).getTeam() == GetID())

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T234200[ebp], ecx
	mov	edx, DWORD PTR $T234200[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T234209[ebp], al
	movzx	ecx, BYTE PTR $T234209[ebp]
	test	ecx, ecx
	je	SHORT $LN2@isHuman
	mov	edx, DWORD PTR _iI$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T234213[ebp], edx
	mov	eax, DWORD PTR $T234213[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T234222[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T234222[ebp], eax
	jne	SHORT $LN2@isHuman

; 2497 : 		{
; 2498 : 			if(GET_PLAYER((PlayerTypes)iI).isHuman())

	mov	edx, DWORD PTR _iI$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T234226[ebp], edx
	mov	ecx, DWORD PTR $T234226[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@isHuman

; 2499 : 			{
; 2500 : 				return true;

	mov	al, 1
	jmp	SHORT $LN6@isHuman
$LN2@isHuman:

; 2501 : 			}
; 2502 : 		}
; 2503 : 	}

	jmp	$LN4@isHuman
$LN3@isHuman:

; 2504 : 
; 2505 : 	return false;

	xor	al, al
$LN6@isHuman:

; 2506 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isHuman@CvTeam@@QBE_NXZ ENDP				; CvTeam::isHuman
_TEXT	ENDS
PUBLIC	?isObserver@CvTeam@@QBE_NXZ			; CvTeam::isObserver
EXTRN	?isObserver@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isObserver
; Function compile flags: /Odtp
;	COMDAT ?isObserver@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T234240 = -12						; size = 4
_player$224084 = -8					; size = 4
_iI$ = -4						; size = 4
?isObserver@CvTeam@@QBE_NXZ PROC			; CvTeam::isObserver, COMDAT
; _this$ = ecx

; 2510 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2511 : 	int iI;
; 2512 : 	for(iI = 0; iI < MAX_PLAYERS; iI++){

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN4@isObserver
$LN3@isObserver:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN4@isObserver:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	SHORT $LN2@isObserver

; 2513 : 		CvPlayer &player = GET_PLAYER((PlayerTypes)iI);

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _player$224084[ebp], ecx

; 2514 : 		if(player.getTeam() == GetID() && player.isObserver()){

	mov	edx, DWORD PTR _player$224084[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T234240[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T234240[ebp], eax
	jne	SHORT $LN1@isObserver
	mov	ecx, DWORD PTR _player$224084[ebp]
	call	?isObserver@CvPlayer@@QBE_NXZ		; CvPlayer::isObserver
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@isObserver

; 2515 : 			return true;

	mov	al, 1
	jmp	SHORT $LN5@isObserver
$LN1@isObserver:

; 2516 : 		}
; 2517 : 	}

	jmp	SHORT $LN3@isObserver
$LN2@isObserver:

; 2518 : 	return false;

	xor	al, al
$LN5@isObserver:

; 2519 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isObserver@CvTeam@@QBE_NXZ ENDP			; CvTeam::isObserver
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isBarbarian@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isBarbarian@CvTeam@@QBE_NXZ PROC			; CvTeam::isBarbarian, COMDAT
; _this$ = ecx

; 2524 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2525 : 	return (m_eID == BARBARIAN_TEAM);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+4], 63			; 0000003fH
	sete	cl
	mov	al, cl

; 2526 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isBarbarian@CvTeam@@QBE_NXZ ENDP			; CvTeam::isBarbarian
_TEXT	ENDS
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
; Function compile flags: /Odtp
;	COMDAT ?isMinorCiv@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T234265 = -20						; size = 4
$T234256 = -13						; size = 1
_kPlayer$224099 = -12					; size = 4
_bValid$ = -5						; size = 1
_iI$ = -4						; size = 4
?isMinorCiv@CvTeam@@QBE_NXZ PROC			; CvTeam::isMinorCiv, COMDAT
; _this$ = ecx

; 2531 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 2532 : 	bool bValid;
; 2533 : 	int iI;
; 2534 : 
; 2535 : 	bValid = false;

	mov	BYTE PTR _bValid$[ebp], 0

; 2536 : 
; 2537 : 	for(iI = MAX_MAJOR_CIVS; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$[ebp], 22			; 00000016H
	jmp	SHORT $LN7@isMinorCiv
$LN6@isMinorCiv:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN7@isMinorCiv:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	SHORT $LN5@isMinorCiv

; 2538 : 	{
; 2539 : 		CvPlayer& kPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$224099[ebp], ecx

; 2540 : 		if(kPlayer.isAlive())

	mov	edx, DWORD PTR _kPlayer$224099[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T234256[ebp], al
	movzx	ecx, BYTE PTR $T234256[ebp]
	test	ecx, ecx
	je	SHORT $LN4@isMinorCiv

; 2541 : 		{
; 2542 : 			if(kPlayer.getTeam() == GetID())

	mov	edx, DWORD PTR _kPlayer$224099[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T234265[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T234265[ebp], eax
	jne	SHORT $LN4@isMinorCiv

; 2543 : 			{
; 2544 : 				if(kPlayer.isMinorCiv())

	mov	ecx, DWORD PTR _kPlayer$224099[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@isMinorCiv

; 2545 : 				{
; 2546 : 					bValid = true;

	mov	BYTE PTR _bValid$[ebp], 1

; 2547 : 					break;

	jmp	SHORT $LN5@isMinorCiv

; 2548 : 				}
; 2549 : 				else

	jmp	SHORT $LN4@isMinorCiv
$LN2@isMinorCiv:

; 2550 : 				{
; 2551 : 					return false;

	xor	al, al
	jmp	SHORT $LN8@isMinorCiv
$LN4@isMinorCiv:

; 2552 : 				}
; 2553 : 			}
; 2554 : 		}
; 2555 : 	}

	jmp	SHORT $LN6@isMinorCiv
$LN5@isMinorCiv:

; 2556 : 
; 2557 : 	return bValid;

	mov	al, BYTE PTR _bValid$[ebp]
$LN8@isMinorCiv:

; 2558 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isMinorCiv@CvTeam@@QBE_NXZ ENDP			; CvTeam::isMinorCiv
_TEXT	ENDS
PUBLIC	?isMajorCiv@CvTeam@@QBE_NXZ			; CvTeam::isMajorCiv
; Function compile flags: /Odtp
;	COMDAT ?isMajorCiv@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
tv76 = -8						; size = 4
_this$ = -4						; size = 4
?isMajorCiv@CvTeam@@QBE_NXZ PROC			; CvTeam::isMajorCiv, COMDAT
; _this$ = ecx

; 2561 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2562 : 	return !(isMinorCiv() || isBarbarian() || isObserver());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@isMajorCiv
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isBarbarian@CvTeam@@QBE_NXZ		; CvTeam::isBarbarian
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@isMajorCiv
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isObserver@CvTeam@@QBE_NXZ		; CvTeam::isObserver
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN3@isMajorCiv
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN4@isMajorCiv
$LN3@isMajorCiv:
	mov	DWORD PTR tv76[ebp], 0
$LN4@isMajorCiv:
	mov	al, BYTE PTR tv76[ebp]

; 2563 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isMajorCiv@CvTeam@@QBE_NXZ ENDP			; CvTeam::isMajorCiv
_TEXT	ENDS
PUBLIC	?GetNumMinorCivsAttacked@CvTeam@@QBEHXZ		; CvTeam::GetNumMinorCivsAttacked
; Function compile flags: /Odtp
;	COMDAT ?GetNumMinorCivsAttacked@CvTeam@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumMinorCivsAttacked@CvTeam@@QBEHXZ PROC		; CvTeam::GetNumMinorCivsAttacked, COMDAT
; _this$ = ecx

; 2568 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2569 : 	return m_iNumMinorCivsAttacked;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+124]

; 2570 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumMinorCivsAttacked@CvTeam@@QBEHXZ ENDP		; CvTeam::GetNumMinorCivsAttacked
_TEXT	ENDS
PUBLIC	?SetNumMinorCivsAttacked@CvTeam@@QAEXH@Z	; CvTeam::SetNumMinorCivsAttacked
; Function compile flags: /Odtp
;	COMDAT ?SetNumMinorCivsAttacked@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iValue$ = 8						; size = 4
?SetNumMinorCivsAttacked@CvTeam@@QAEXH@Z PROC		; CvTeam::SetNumMinorCivsAttacked, COMDAT
; _this$ = ecx

; 2575 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2576 : 	if(GetNumMinorCivsAttacked() != iValue)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumMinorCivsAttacked@CvTeam@@QBEHXZ	; CvTeam::GetNumMinorCivsAttacked
	cmp	eax, DWORD PTR _iValue$[ebp]
	je	SHORT $LN2@SetNumMino

; 2577 : 	{
; 2578 : 		m_iNumMinorCivsAttacked = iValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iValue$[ebp]
	mov	DWORD PTR [eax+124], ecx
$LN2@SetNumMino:

; 2579 : 	}
; 2580 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetNumMinorCivsAttacked@CvTeam@@QAEXH@Z ENDP		; CvTeam::SetNumMinorCivsAttacked
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ChangeNumMinorCivsAttacked@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?ChangeNumMinorCivsAttacked@CvTeam@@QAEXH@Z PROC	; CvTeam::ChangeNumMinorCivsAttacked, COMDAT
; _this$ = ecx

; 2585 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2586 : 	if(iChange != 0)

	cmp	DWORD PTR _iChange$[ebp], 0
	je	SHORT $LN2@ChangeNumM

; 2587 : 		SetNumMinorCivsAttacked(GetNumMinorCivsAttacked() + iChange);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumMinorCivsAttacked@CvTeam@@QBEHXZ	; CvTeam::GetNumMinorCivsAttacked
	add	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetNumMinorCivsAttacked@CvTeam@@QAEXH@Z ; CvTeam::SetNumMinorCivsAttacked
$LN2@ChangeNumM:

; 2588 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ChangeNumMinorCivsAttacked@CvTeam@@QAEXH@Z ENDP	; CvTeam::ChangeNumMinorCivsAttacked
_TEXT	ENDS
PUBLIC	?IsMinorCivAggressor@CvTeam@@QBE_NXZ		; CvTeam::IsMinorCivAggressor
; Function compile flags: /Odtp
;	COMDAT ?IsMinorCivAggressor@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T234281 = -4						; size = 4
?IsMinorCivAggressor@CvTeam@@QBE_NXZ PROC		; CvTeam::IsMinorCivAggressor, COMDAT
; _this$ = ecx

; 2593 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2594 : 	// Player has attacked enough Minors that they're getting antsy
; 2595 : 	if(GetNumMinorCivsAttacked() >= /*2*/ GC.getMINOR_CIV_AGGRESSOR_THRESHOLD())

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2772
	mov	DWORD PTR $T234281[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumMinorCivsAttacked@CvTeam@@QBEHXZ	; CvTeam::GetNumMinorCivsAttacked
	cmp	eax, DWORD PTR $T234281[ebp]
	jl	SHORT $LN1@IsMinorCiv

; 2596 : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@IsMinorCiv
$LN1@IsMinorCiv:

; 2597 : 
; 2598 : 	return false;

	xor	al, al
$LN2@IsMinorCiv:

; 2599 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsMinorCivAggressor@CvTeam@@QBE_NXZ ENDP		; CvTeam::IsMinorCivAggressor
_TEXT	ENDS
PUBLIC	?IsMinorCivWarmonger@CvTeam@@QBE_NXZ		; CvTeam::IsMinorCivWarmonger
; Function compile flags: /Odtp
;	COMDAT ?IsMinorCivWarmonger@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T234287 = -4						; size = 4
?IsMinorCivWarmonger@CvTeam@@QBE_NXZ PROC		; CvTeam::IsMinorCivWarmonger, COMDAT
; _this$ = ecx

; 2604 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2605 : 	// Player has attacked enough Minors that an Alliance has formed
; 2606 : 	if(GetNumMinorCivsAttacked() >= /*4*/ GC.getMINOR_CIV_WARMONGER_THRESHOLD())

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2776
	mov	DWORD PTR $T234287[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumMinorCivsAttacked@CvTeam@@QBEHXZ	; CvTeam::GetNumMinorCivsAttacked
	cmp	eax, DWORD PTR $T234287[ebp]
	jl	SHORT $LN1@IsMinorCiv@2

; 2607 : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@IsMinorCiv@2
$LN1@IsMinorCiv@2:

; 2608 : 
; 2609 : 	return false;

	xor	al, al
$LN2@IsMinorCiv@2:

; 2610 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsMinorCivWarmonger@CvTeam@@QBE_NXZ ENDP		; CvTeam::IsMinorCivWarmonger
_TEXT	ENDS
PUBLIC	?IsBrokenMilitaryPromise@CvTeam@@QBE_NXZ	; CvTeam::IsBrokenMilitaryPromise
; Function compile flags: /Odtp
;	COMDAT ?IsBrokenMilitaryPromise@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsBrokenMilitaryPromise@CvTeam@@QBE_NXZ PROC		; CvTeam::IsBrokenMilitaryPromise, COMDAT
; _this$ = ecx

; 2615 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2616 : 	return m_bBrokenMilitaryPromise;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+132]

; 2617 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsBrokenMilitaryPromise@CvTeam@@QBE_NXZ ENDP		; CvTeam::IsBrokenMilitaryPromise
_TEXT	ENDS
PUBLIC	?SetBrokenMilitaryPromise@CvTeam@@QAEX_N@Z	; CvTeam::SetBrokenMilitaryPromise
; Function compile flags: /Odtp
;	COMDAT ?SetBrokenMilitaryPromise@CvTeam@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bValue$ = 8						; size = 1
?SetBrokenMilitaryPromise@CvTeam@@QAEX_N@Z PROC		; CvTeam::SetBrokenMilitaryPromise, COMDAT
; _this$ = ecx

; 2621 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2622 : 	if(IsBrokenMilitaryPromise() != bValue)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsBrokenMilitaryPromise@CvTeam@@QBE_NXZ ; CvTeam::IsBrokenMilitaryPromise
	movzx	eax, al
	movzx	ecx, BYTE PTR _bValue$[ebp]
	cmp	eax, ecx
	je	SHORT $LN2@SetBrokenM@2

; 2623 : 		m_bBrokenMilitaryPromise = bValue;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR _bValue$[ebp]
	mov	BYTE PTR [edx+132], al
$LN2@SetBrokenM@2:

; 2624 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetBrokenMilitaryPromise@CvTeam@@QAEX_N@Z ENDP		; CvTeam::SetBrokenMilitaryPromise
_TEXT	ENDS
PUBLIC	?IsBrokenExpansionPromise@CvTeam@@QBE_NXZ	; CvTeam::IsBrokenExpansionPromise
; Function compile flags: /Odtp
;	COMDAT ?IsBrokenExpansionPromise@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsBrokenExpansionPromise@CvTeam@@QBE_NXZ PROC		; CvTeam::IsBrokenExpansionPromise, COMDAT
; _this$ = ecx

; 2628 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2629 : 	return m_bBrokenExpansionPromise;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+133]

; 2630 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsBrokenExpansionPromise@CvTeam@@QBE_NXZ ENDP		; CvTeam::IsBrokenExpansionPromise
_TEXT	ENDS
PUBLIC	?SetBrokenExpansionPromise@CvTeam@@QAEX_N@Z	; CvTeam::SetBrokenExpansionPromise
; Function compile flags: /Odtp
;	COMDAT ?SetBrokenExpansionPromise@CvTeam@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bValue$ = 8						; size = 1
?SetBrokenExpansionPromise@CvTeam@@QAEX_N@Z PROC	; CvTeam::SetBrokenExpansionPromise, COMDAT
; _this$ = ecx

; 2634 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2635 : 	if(IsBrokenExpansionPromise() != bValue)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsBrokenExpansionPromise@CvTeam@@QBE_NXZ ; CvTeam::IsBrokenExpansionPromise
	movzx	eax, al
	movzx	ecx, BYTE PTR _bValue$[ebp]
	cmp	eax, ecx
	je	SHORT $LN2@SetBrokenE

; 2636 : 		m_bBrokenExpansionPromise = bValue;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR _bValue$[ebp]
	mov	BYTE PTR [edx+133], al
$LN2@SetBrokenE:

; 2637 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetBrokenExpansionPromise@CvTeam@@QAEX_N@Z ENDP	; CvTeam::SetBrokenExpansionPromise
_TEXT	ENDS
PUBLIC	?IsBrokenBorderPromise@CvTeam@@QBE_NXZ		; CvTeam::IsBrokenBorderPromise
; Function compile flags: /Odtp
;	COMDAT ?IsBrokenBorderPromise@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsBrokenBorderPromise@CvTeam@@QBE_NXZ PROC		; CvTeam::IsBrokenBorderPromise, COMDAT
; _this$ = ecx

; 2641 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2642 : 	return m_bBrokenBorderPromise;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+134]

; 2643 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsBrokenBorderPromise@CvTeam@@QBE_NXZ ENDP		; CvTeam::IsBrokenBorderPromise
_TEXT	ENDS
PUBLIC	?SetBrokenBorderPromise@CvTeam@@QAEX_N@Z	; CvTeam::SetBrokenBorderPromise
; Function compile flags: /Odtp
;	COMDAT ?SetBrokenBorderPromise@CvTeam@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bValue$ = 8						; size = 1
?SetBrokenBorderPromise@CvTeam@@QAEX_N@Z PROC		; CvTeam::SetBrokenBorderPromise, COMDAT
; _this$ = ecx

; 2647 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2648 : 	if(IsBrokenBorderPromise() != bValue)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsBrokenBorderPromise@CvTeam@@QBE_NXZ	; CvTeam::IsBrokenBorderPromise
	movzx	eax, al
	movzx	ecx, BYTE PTR _bValue$[ebp]
	cmp	eax, ecx
	je	SHORT $LN2@SetBrokenB

; 2649 : 		m_bBrokenBorderPromise = bValue;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR _bValue$[ebp]
	mov	BYTE PTR [edx+134], al
$LN2@SetBrokenB:

; 2650 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetBrokenBorderPromise@CvTeam@@QAEX_N@Z ENDP		; CvTeam::SetBrokenBorderPromise
_TEXT	ENDS
PUBLIC	?IsBrokenCityStatePromise@CvTeam@@QBE_NXZ	; CvTeam::IsBrokenCityStatePromise
; Function compile flags: /Odtp
;	COMDAT ?IsBrokenCityStatePromise@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsBrokenCityStatePromise@CvTeam@@QBE_NXZ PROC		; CvTeam::IsBrokenCityStatePromise, COMDAT
; _this$ = ecx

; 2655 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2656 : 	return m_bBrokenCityStatePromise;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+135]

; 2657 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsBrokenCityStatePromise@CvTeam@@QBE_NXZ ENDP		; CvTeam::IsBrokenCityStatePromise
_TEXT	ENDS
PUBLIC	?SetBrokenCityStatePromise@CvTeam@@QAEX_N@Z	; CvTeam::SetBrokenCityStatePromise
; Function compile flags: /Odtp
;	COMDAT ?SetBrokenCityStatePromise@CvTeam@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bValue$ = 8						; size = 1
?SetBrokenCityStatePromise@CvTeam@@QAEX_N@Z PROC	; CvTeam::SetBrokenCityStatePromise, COMDAT
; _this$ = ecx

; 2661 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2662 : 	if(IsBrokenCityStatePromise() != bValue)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsBrokenCityStatePromise@CvTeam@@QBE_NXZ ; CvTeam::IsBrokenCityStatePromise
	movzx	eax, al
	movzx	ecx, BYTE PTR _bValue$[ebp]
	cmp	eax, ecx
	je	SHORT $LN2@SetBrokenC

; 2663 : 		m_bBrokenCityStatePromise = bValue;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR _bValue$[ebp]
	mov	BYTE PTR [edx+135], al
$LN2@SetBrokenC:

; 2664 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetBrokenCityStatePromise@CvTeam@@QAEX_N@Z ENDP	; CvTeam::SetBrokenCityStatePromise
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T234338 = -24						; size = 4
$T234326 = -20						; size = 4
$T234317 = -13						; size = 1
_thisPlayer$224176 = -12				; size = 4
_thisPlayer$224168 = -8					; size = 4
_iI$ = -4						; size = 4
?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ PROC	; CvTeam::getLeaderID, COMDAT
; _this$ = ecx

; 2668 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 2669 : 	int iI;
; 2670 : 
; 2671 : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN9@getLeaderI
$LN8@getLeaderI:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN9@getLeaderI:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	SHORT $LN7@getLeaderI

; 2672 : 	{
; 2673 : 		CvPlayerAI& thisPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _thisPlayer$224168[ebp], ecx

; 2674 : 		if(thisPlayer.isAlive())

	mov	edx, DWORD PTR _thisPlayer$224168[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T234317[ebp], al
	movzx	ecx, BYTE PTR $T234317[ebp]
	test	ecx, ecx
	je	SHORT $LN6@getLeaderI

; 2675 : 		{
; 2676 : 			if(thisPlayer.getTeam() == m_eID)

	mov	edx, DWORD PTR _thisPlayer$224168[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T234326[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T234326[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN6@getLeaderI

; 2677 : 			{
; 2678 : 				return ((PlayerTypes)iI);

	mov	eax, DWORD PTR _iI$[ebp]
	jmp	SHORT $LN10@getLeaderI
$LN6@getLeaderI:

; 2679 : 			}
; 2680 : 		}
; 2681 : 	}

	jmp	SHORT $LN8@getLeaderI
$LN7@getLeaderI:

; 2682 : 
; 2683 : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN4@getLeaderI
$LN3@getLeaderI:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN4@getLeaderI:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	SHORT $LN2@getLeaderI

; 2684 : 	{
; 2685 : 		CvPlayerAI& thisPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _thisPlayer$224176[ebp], ecx

; 2686 : 		if(thisPlayer.getTeam() == m_eID)

	mov	edx, DWORD PTR _thisPlayer$224176[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T234338[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T234338[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN1@getLeaderI

; 2687 : 		{
; 2688 : 			return ((PlayerTypes)iI);

	mov	eax, DWORD PTR _iI$[ebp]
	jmp	SHORT $LN10@getLeaderI
$LN1@getLeaderI:

; 2689 : 		}
; 2690 : 	}

	jmp	SHORT $LN3@getLeaderI
$LN2@getLeaderI:

; 2691 : 
; 2692 : 	return NO_PLAYER;

	or	eax, -1
$LN10@getLeaderI:

; 2693 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ENDP	; CvTeam::getLeaderID
_TEXT	ENDS
PUBLIC	?getSecretaryID@CvTeam@@QBE?AW4PlayerTypes@@XZ	; CvTeam::getSecretaryID
; Function compile flags: /Odtp
;	COMDAT ?getSecretaryID@CvTeam@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T234370 = -24						; size = 4
$T234361 = -20						; size = 4
$T234357 = -16						; size = 4
$T234353 = -9						; size = 1
$T234344 = -8						; size = 4
_iI$ = -4						; size = 4
?getSecretaryID@CvTeam@@QBE?AW4PlayerTypes@@XZ PROC	; CvTeam::getSecretaryID, COMDAT
; _this$ = ecx

; 2698 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 2699 : 	int iI;
; 2700 : 
; 2701 : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN6@getSecreta
$LN5@getSecreta:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN6@getSecreta:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	$LN4@getSecreta

; 2702 : 	{
; 2703 : 		if(GET_PLAYER((PlayerTypes)iI).isAlive())

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T234344[ebp], ecx
	mov	edx, DWORD PTR $T234344[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T234353[ebp], al
	movzx	ecx, BYTE PTR $T234353[ebp]
	test	ecx, ecx
	je	SHORT $LN3@getSecreta

; 2704 : 		{
; 2705 : 			if(GET_PLAYER((PlayerTypes)iI).isHuman())

	mov	edx, DWORD PTR _iI$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T234357[ebp], edx
	mov	ecx, DWORD PTR $T234357[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@getSecreta

; 2706 : 			{
; 2707 : 				if(GET_PLAYER((PlayerTypes)iI).getTeam() == GetID())

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T234361[ebp], ecx
	mov	edx, DWORD PTR $T234361[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T234370[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T234370[ebp], eax
	jne	SHORT $LN3@getSecreta

; 2708 : 				{
; 2709 : 					return ((PlayerTypes)iI);

	mov	eax, DWORD PTR _iI$[ebp]
	jmp	SHORT $LN7@getSecreta
$LN3@getSecreta:

; 2710 : 				}
; 2711 : 			}
; 2712 : 		}
; 2713 : 	}

	jmp	$LN5@getSecreta
$LN4@getSecreta:

; 2714 : 
; 2715 : 	return getLeaderID();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
$LN7@getSecreta:

; 2716 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getSecretaryID@CvTeam@@QBE?AW4PlayerTypes@@XZ ENDP	; CvTeam::getSecretaryID
_TEXT	ENDS
PUBLIC	?getHandicapType@CvTeam@@QBE?AW4HandicapTypes@@XZ ; CvTeam::getHandicapType
EXTRN	?getHandicapType@CvPlayer@@QBE?AW4HandicapTypes@@XZ:PROC ; CvPlayer::getHandicapType
; Function compile flags: /Odtp
;	COMDAT ?getHandicapType@CvTeam@@QBE?AW4HandicapTypes@@XZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T234401 = -32						; size = 4
$T234397 = -28						; size = 4
$T234393 = -24						; size = 4
$T234384 = -17						; size = 1
_thisPlayer$224203 = -16				; size = 4
_iCount$ = -12						; size = 4
_iI$ = -8						; size = 4
_iGameHandicap$ = -4					; size = 4
?getHandicapType@CvTeam@@QBE?AW4HandicapTypes@@XZ PROC	; CvTeam::getHandicapType, COMDAT
; _this$ = ecx

; 2721 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 2722 : 	int iGameHandicap;
; 2723 : 	int iCount;
; 2724 : 	int iI;
; 2725 : 
; 2726 : 	iGameHandicap = 0;

	mov	DWORD PTR _iGameHandicap$[ebp], 0

; 2727 : 	iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0

; 2728 : 
; 2729 : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN7@getHandica
$LN6@getHandica:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN7@getHandica:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	SHORT $LN5@getHandica

; 2730 : 	{
; 2731 : 		CvPlayerAI& thisPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _thisPlayer$224203[ebp], ecx

; 2732 : 		if(thisPlayer.isAlive())

	mov	edx, DWORD PTR _thisPlayer$224203[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T234384[ebp], al
	movzx	ecx, BYTE PTR $T234384[ebp]
	test	ecx, ecx
	je	SHORT $LN4@getHandica

; 2733 : 		{
; 2734 : 			if(thisPlayer.getTeam() == m_eID)

	mov	edx, DWORD PTR _thisPlayer$224203[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T234393[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T234393[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN4@getHandica

; 2735 : 			{
; 2736 : 				iGameHandicap += GET_PLAYER((PlayerTypes)iI).getHandicapType();

	mov	eax, DWORD PTR _iI$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T234397[ebp], eax
	mov	ecx, DWORD PTR $T234397[ebp]
	call	?getHandicapType@CvPlayer@@QBE?AW4HandicapTypes@@XZ ; CvPlayer::getHandicapType
	add	eax, DWORD PTR _iGameHandicap$[ebp]
	mov	DWORD PTR _iGameHandicap$[ebp], eax

; 2737 : 				iCount++;

	mov	ecx, DWORD PTR _iCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iCount$[ebp], ecx
$LN4@getHandica:

; 2738 : 			}
; 2739 : 		}
; 2740 : 	}

	jmp	SHORT $LN6@getHandica
$LN5@getHandica:

; 2741 : 
; 2742 : 	if(iCount > 0)

	cmp	DWORD PTR _iCount$[ebp], 0
	jle	SHORT $LN2@getHandica

; 2743 : 	{
; 2744 : 		CvAssertMsg((iGameHandicap / iCount) >= 0, "(iGameHandicap / iCount) is expected to be non-negative (invalid Index)");
; 2745 : 		return ((HandicapTypes)(iGameHandicap / iCount));

	mov	eax, DWORD PTR _iGameHandicap$[ebp]
	cdq
	idiv	DWORD PTR _iCount$[ebp]
	jmp	SHORT $LN8@getHandica

; 2746 : 	}
; 2747 : 	else

	jmp	SHORT $LN8@getHandica
$LN2@getHandica:

; 2748 : 	{
; 2749 : 		return ((HandicapTypes)(GC.getSTANDARD_HANDICAP()));

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8452
	mov	DWORD PTR $T234401[ebp], edx
	mov	eax, DWORD PTR $T234401[ebp]
$LN8@getHandica:

; 2750 : 	}
; 2751 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getHandicapType@CvTeam@@QBE?AW4HandicapTypes@@XZ ENDP	; CvTeam::getHandicapType
_TEXT	ENDS
PUBLIC	??_C@_01KMDKNFGN@?1?$AA@			; `string'
PUBLIC	__$ArrayPad$
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	?getName@CvPlayer@@QBEPBDXZ:PROC		; CvPlayer::getName
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
;	COMDAT ??_C@_01KMDKNFGN@?1?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_01KMDKNFGN@?1?$AA@ DB '/', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?getName@CvTeam@@QBE?AVCvString@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getName@CvTeam@@QBE?AVCvString@@XZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?getName@CvTeam@@QBE?AVCvString@@XZ$0
__ehfuncinfo$?getName@CvTeam@@QBE?AVCvString@@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?getName@CvTeam@@QBE?AVCvString@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?getName@CvTeam@@QBE?AVCvString@@XZ
_TEXT	SEGMENT
_this$ = -76						; size = 4
$T234428 = -70						; size = 1
$T234424 = -69						; size = 1
$T234407 = -68						; size = 4
_ePlayer$224224 = -64					; size = 4
_kPlayer$224225 = -60					; size = 4
_iI$224219 = -56					; size = 4
_eID$ = -52						; size = 4
_strBuffer$ = -48					; size = 28
__$ArrayPad$ = -20					; size = 4
_bFirst$ = -13						; size = 1
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?getName@CvTeam@@QBE?AVCvString@@XZ PROC		; CvTeam::getName, COMDAT
; _this$ = ecx

; 2756 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?getName@CvTeam@@QBE?AVCvString@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T234407[ebp], 0

; 2757 : 	CvString strBuffer;

	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 2758 : 	bool bFirst = true;

	mov	BYTE PTR _bFirst$[ebp], 1

; 2759 : 	const TeamTypes eID(GetID());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	mov	DWORD PTR _eID$[ebp], eax

; 2760 : 
; 2761 : 	for(int iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$224219[ebp], 0
	jmp	SHORT $LN7@getName
$LN6@getName:
	mov	eax, DWORD PTR _iI$224219[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$224219[ebp], eax
$LN7@getName:
	cmp	DWORD PTR _iI$224219[ebp], 64		; 00000040H
	jge	$LN5@getName

; 2762 : 	{
; 2763 : 		const PlayerTypes ePlayer(static_cast<PlayerTypes>(iI));

	mov	ecx, DWORD PTR _iI$224219[ebp]
	mov	DWORD PTR _ePlayer$224224[ebp], ecx

; 2764 : 		CvPlayerAI& kPlayer(GET_PLAYER(ePlayer));

	mov	edx, DWORD PTR _ePlayer$224224[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$224225[ebp], edx

; 2765 : 
; 2766 : 		if(kPlayer.isAlive() || kPlayer.isBeingResurrected())

	mov	eax, DWORD PTR _kPlayer$224225[ebp]
	mov	cl, BYTE PTR [eax+2256]
	mov	BYTE PTR $T234424[ebp], cl
	movzx	edx, BYTE PTR $T234424[ebp]
	test	edx, edx
	jne	SHORT $LN24@getName
	mov	eax, DWORD PTR _kPlayer$224225[ebp]
	mov	cl, BYTE PTR [eax+2276]
	mov	BYTE PTR $T234428[ebp], cl
	movzx	edx, BYTE PTR $T234428[ebp]
	test	edx, edx
	je	SHORT $LN4@getName

; 2767 : 		{
; 2768 : 			if(kPlayer.getTeam() == eID)

$LN24@getName:
	mov	eax, DWORD PTR _kPlayer$224225[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	eax, DWORD PTR _eID$[ebp]
	jne	SHORT $LN4@getName

; 2769 : 			{
; 2770 : 				if(!bFirst)

	movzx	edx, BYTE PTR _bFirst$[ebp]
	test	edx, edx
	jne	SHORT $LN1@getName

; 2771 : 				{
; 2772 : 					strBuffer += "/";

	push	OFFSET ??_C@_01KMDKNFGN@?1?$AA@
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN1@getName:

; 2773 : 				}
; 2774 : 
; 2775 : 				strBuffer += kPlayer.getName();

	mov	ecx, DWORD PTR _kPlayer$224225[ebp]
	call	?getName@CvPlayer@@QBEPBDXZ		; CvPlayer::getName
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 2776 : 
; 2777 : 				bFirst = false;

	mov	BYTE PTR _bFirst$[ebp], 0
$LN4@getName:

; 2778 : 			}
; 2779 : 		}
; 2780 : 	}

	jmp	$LN6@getName
$LN5@getName:

; 2781 : 
; 2782 : 	return strBuffer;

	lea	eax, DWORD PTR _strBuffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T234407[ebp]
	or	ecx, 1
	mov	DWORD PTR $T234407[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2783 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getName@CvTeam@@QBE?AVCvString@@XZ$0:
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?getName@CvTeam@@QBE?AVCvString@@XZ$1:
	mov	eax, DWORD PTR $T234407[ebp]
	and	eax, 1
	je	$LN12@getName
	and	DWORD PTR $T234407[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN12@getName:
	ret	0
__ehhandler$?getName@CvTeam@@QBE?AVCvString@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-68]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?getName@CvTeam@@QBE?AVCvString@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?getName@CvTeam@@QBE?AVCvString@@XZ ENDP		; CvTeam::getName
PUBLIC	?getNumMembers@CvTeam@@QBEHXZ			; CvTeam::getNumMembers
PUBLIC	__$ArrayPad$
PUBLIC	?getNameKey@CvTeam@@QBE?AVCvString@@XZ		; CvTeam::getNameKey
EXTRN	?getNameKey@CvPlayer@@QBEPBDXZ:PROC		; CvPlayer::getNameKey
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?getNameKey@CvTeam@@QBE?AVCvString@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getNameKey@CvTeam@@QBE?AVCvString@@XZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?getNameKey@CvTeam@@QBE?AVCvString@@XZ$0
__ehfuncinfo$?getNameKey@CvTeam@@QBE?AVCvString@@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?getNameKey@CvTeam@@QBE?AVCvString@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?getNameKey@CvTeam@@QBE?AVCvString@@XZ
_TEXT	SEGMENT
_this$ = -80						; size = 4
$T234473 = -73						; size = 1
$T234456 = -72						; size = 4
_ePlayer$224244 = -68					; size = 4
_kPlayer$224245 = -64					; size = 4
_iI$224239 = -60					; size = 4
_bOneManTeam$ = -53					; size = 1
_eID$ = -52						; size = 4
_strBuffer$ = -48					; size = 28
__$ArrayPad$ = -20					; size = 4
_bFirst$ = -13						; size = 1
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?getNameKey@CvTeam@@QBE?AVCvString@@XZ PROC		; CvTeam::getNameKey, COMDAT
; _this$ = ecx

; 2787 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?getNameKey@CvTeam@@QBE?AVCvString@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T234456[ebp], 0

; 2788 : 	CvString strBuffer;

	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 2789 : 	bool bFirst = true;

	mov	BYTE PTR _bFirst$[ebp], 1

; 2790 : 	const TeamTypes eID(GetID());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	mov	DWORD PTR _eID$[ebp], eax

; 2791 : 	bool bOneManTeam = (this->getNumMembers() == 1);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNumMembers@CvTeam@@QBEHXZ		; CvTeam::getNumMembers
	sub	eax, 1
	neg	eax
	sbb	eax, eax
	add	eax, 1
	mov	BYTE PTR _bOneManTeam$[ebp], al

; 2792 : 
; 2793 : 
; 2794 : 	for(int iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$224239[ebp], 0
	jmp	SHORT $LN8@getNameKey
$LN7@getNameKey:
	mov	eax, DWORD PTR _iI$224239[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$224239[ebp], eax
$LN8@getNameKey:
	cmp	DWORD PTR _iI$224239[ebp], 64		; 00000040H
	jge	$LN6@getNameKey

; 2795 : 	{
; 2796 : 		const PlayerTypes ePlayer(static_cast<PlayerTypes>(iI));

	mov	ecx, DWORD PTR _iI$224239[ebp]
	mov	DWORD PTR _ePlayer$224244[ebp], ecx

; 2797 : 		CvPlayerAI& kPlayer(GET_PLAYER(ePlayer));

	mov	edx, DWORD PTR _ePlayer$224244[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$224245[ebp], edx

; 2798 : 
; 2799 : 		if(kPlayer.isAlive())

	mov	eax, DWORD PTR _kPlayer$224245[ebp]
	mov	cl, BYTE PTR [eax+2256]
	mov	BYTE PTR $T234473[ebp], cl
	movzx	edx, BYTE PTR $T234473[ebp]
	test	edx, edx
	je	SHORT $LN5@getNameKey

; 2800 : 		{
; 2801 : 			if(kPlayer.getTeam() == eID)

	mov	eax, DWORD PTR _kPlayer$224245[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	eax, DWORD PTR _eID$[ebp]
	jne	SHORT $LN5@getNameKey

; 2802 : 			{
; 2803 : 				if(!bFirst)

	movzx	edx, BYTE PTR _bFirst$[ebp]
	test	edx, edx
	jne	SHORT $LN3@getNameKey

; 2804 : 				{
; 2805 : 					strBuffer += "/";

	push	OFFSET ??_C@_01KMDKNFGN@?1?$AA@
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN3@getNameKey:

; 2806 : 				}
; 2807 : 				
; 2808 : 				if(bOneManTeam)

	movzx	eax, BYTE PTR _bOneManTeam$[ebp]
	test	eax, eax
	je	SHORT $LN2@getNameKey

; 2809 : 					strBuffer += kPlayer.getNameKey();

	mov	ecx, DWORD PTR _kPlayer$224245[ebp]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 2810 : 				else

	jmp	SHORT $LN1@getNameKey
$LN2@getNameKey:

; 2811 : 					strBuffer += kPlayer.getName();

	mov	ecx, DWORD PTR _kPlayer$224245[ebp]
	call	?getName@CvPlayer@@QBEPBDXZ		; CvPlayer::getName
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN1@getNameKey:

; 2812 : 
; 2813 : 				bFirst = false;

	mov	BYTE PTR _bFirst$[ebp], 0
$LN5@getNameKey:

; 2814 : 			}
; 2815 : 		}
; 2816 : 	}

	jmp	$LN7@getNameKey
$LN6@getNameKey:

; 2817 : 
; 2818 : 	return strBuffer;

	lea	ecx, DWORD PTR _strBuffer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	edx, DWORD PTR $T234456[ebp]
	or	edx, 1
	mov	DWORD PTR $T234456[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2819 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getNameKey@CvTeam@@QBE?AVCvString@@XZ$0:
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?getNameKey@CvTeam@@QBE?AVCvString@@XZ$1:
	mov	eax, DWORD PTR $T234456[ebp]
	and	eax, 1
	je	$LN13@getNameKey
	and	DWORD PTR $T234456[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN13@getNameKey:
	ret	0
__ehhandler$?getNameKey@CvTeam@@QBE?AVCvString@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?getNameKey@CvTeam@@QBE?AVCvString@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?getNameKey@CvTeam@@QBE?AVCvString@@XZ ENDP		; CvTeam::getNameKey
; Function compile flags: /Odtp
;	COMDAT ?getNumMembers@CvTeam@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getNumMembers@CvTeam@@QBEHXZ PROC			; CvTeam::getNumMembers, COMDAT
; _this$ = ecx

; 2824 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2825 : 	return m_iNumMembers;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 2826 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getNumMembers@CvTeam@@QBEHXZ ENDP			; CvTeam::getNumMembers
_TEXT	ENDS
PUBLIC	?changeNumMembers@CvTeam@@QAEXH@Z		; CvTeam::changeNumMembers
; Function compile flags: /Odtp
;	COMDAT ?changeNumMembers@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?changeNumMembers@CvTeam@@QAEXH@Z PROC			; CvTeam::changeNumMembers, COMDAT
; _this$ = ecx

; 2831 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2832 : 	m_iNumMembers = (m_iNumMembers + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 2833 : 	CvAssert(getNumMembers() >= 0);
; 2834 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?changeNumMembers@CvTeam@@QAEXH@Z ENDP			; CvTeam::changeNumMembers
_TEXT	ENDS
PUBLIC	?getAliveCount@CvTeam@@QBEHXZ			; CvTeam::getAliveCount
; Function compile flags: /Odtp
;	COMDAT ?getAliveCount@CvTeam@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getAliveCount@CvTeam@@QBEHXZ PROC			; CvTeam::getAliveCount, COMDAT
; _this$ = ecx

; 2839 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2840 : 	return m_iAliveCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]

; 2841 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getAliveCount@CvTeam@@QBEHXZ ENDP			; CvTeam::getAliveCount
_TEXT	ENDS
PUBLIC	?changeAliveCount@CvTeam@@QAEXH@Z		; CvTeam::changeAliveCount
; Function compile flags: /Odtp
;	COMDAT ?changeAliveCount@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?changeAliveCount@CvTeam@@QAEXH@Z PROC			; CvTeam::changeAliveCount, COMDAT
; _this$ = ecx

; 2845 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2846 : 	m_iAliveCount = (m_iAliveCount + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 2847 : 	CvAssert(getAliveCount() >= 0);
; 2848 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?changeAliveCount@CvTeam@@QAEXH@Z ENDP			; CvTeam::changeAliveCount
_TEXT	ENDS
PUBLIC	?getEverAliveCount@CvTeam@@QBEHXZ		; CvTeam::getEverAliveCount
; Function compile flags: /Odtp
;	COMDAT ?getEverAliveCount@CvTeam@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getEverAliveCount@CvTeam@@QBEHXZ PROC			; CvTeam::getEverAliveCount, COMDAT
; _this$ = ecx

; 2853 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2854 : 	return m_iEverAliveCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 2855 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getEverAliveCount@CvTeam@@QBEHXZ ENDP			; CvTeam::getEverAliveCount
_TEXT	ENDS
PUBLIC	?isEverAlive@CvTeam@@QBEHXZ			; CvTeam::isEverAlive
; Function compile flags: /Odtp
;	COMDAT ?isEverAlive@CvTeam@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isEverAlive@CvTeam@@QBEHXZ PROC			; CvTeam::isEverAlive, COMDAT
; _this$ = ecx

; 2860 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2861 : 	return (getEverAliveCount() > 0);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getEverAliveCount@CvTeam@@QBEHXZ	; CvTeam::getEverAliveCount
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	mov	eax, ecx

; 2862 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isEverAlive@CvTeam@@QBEHXZ ENDP			; CvTeam::isEverAlive
_TEXT	ENDS
PUBLIC	?changeEverAliveCount@CvTeam@@QAEXH@Z		; CvTeam::changeEverAliveCount
; Function compile flags: /Odtp
;	COMDAT ?changeEverAliveCount@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?changeEverAliveCount@CvTeam@@QAEXH@Z PROC		; CvTeam::changeEverAliveCount, COMDAT
; _this$ = ecx

; 2867 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2868 : 	m_iEverAliveCount = (m_iEverAliveCount + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 2869 : 	CvAssert(getEverAliveCount() >= 0);
; 2870 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?changeEverAliveCount@CvTeam@@QAEXH@Z ENDP		; CvTeam::changeEverAliveCount
_TEXT	ENDS
PUBLIC	?getNumCities@CvTeam@@QBEHXZ			; CvTeam::getNumCities
; Function compile flags: /Odtp
;	COMDAT ?getNumCities@CvTeam@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getNumCities@CvTeam@@QBEHXZ PROC			; CvTeam::getNumCities, COMDAT
; _this$ = ecx

; 2875 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2876 : 	return m_iNumCities;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]

; 2877 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getNumCities@CvTeam@@QBEHXZ ENDP			; CvTeam::getNumCities
_TEXT	ENDS
PUBLIC	?changeNumCities@CvTeam@@QAEXH@Z		; CvTeam::changeNumCities
; Function compile flags: /Odtp
;	COMDAT ?changeNumCities@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?changeNumCities@CvTeam@@QAEXH@Z PROC			; CvTeam::changeNumCities, COMDAT
; _this$ = ecx

; 2882 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2883 : 	m_iNumCities = (m_iNumCities + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 2884 : 	CvAssert(getNumCities() >= 0);
; 2885 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?changeNumCities@CvTeam@@QAEXH@Z ENDP			; CvTeam::changeNumCities
_TEXT	ENDS
PUBLIC	?getTotalPopulation@CvTeam@@QBEHXZ		; CvTeam::getTotalPopulation
; Function compile flags: /Odtp
;	COMDAT ?getTotalPopulation@CvTeam@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getTotalPopulation@CvTeam@@QBEHXZ PROC			; CvTeam::getTotalPopulation, COMDAT
; _this$ = ecx

; 2890 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2891 : 	return (m_iTotalPopulation);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+24]

; 2892 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getTotalPopulation@CvTeam@@QBEHXZ ENDP			; CvTeam::getTotalPopulation
_TEXT	ENDS
PUBLIC	?changeTotalPopulation@CvTeam@@QAEXH@Z		; CvTeam::changeTotalPopulation
; Function compile flags: /Odtp
;	COMDAT ?changeTotalPopulation@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?changeTotalPopulation@CvTeam@@QAEXH@Z PROC		; CvTeam::changeTotalPopulation, COMDAT
; _this$ = ecx

; 2897 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2898 : 	m_iTotalPopulation = (m_iTotalPopulation + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 2899 : 	CvAssert(getTotalPopulation() >= 0);
; 2900 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?changeTotalPopulation@CvTeam@@QAEXH@Z ENDP		; CvTeam::changeTotalPopulation
_TEXT	ENDS
PUBLIC	?getTotalLand@CvTeam@@QBEHXZ			; CvTeam::getTotalLand
; Function compile flags: /Odtp
;	COMDAT ?getTotalLand@CvTeam@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getTotalLand@CvTeam@@QBEHXZ PROC			; CvTeam::getTotalLand, COMDAT
; _this$ = ecx

; 2905 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2906 : 	return (m_iTotalLand);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+28]

; 2907 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getTotalLand@CvTeam@@QBEHXZ ENDP			; CvTeam::getTotalLand
_TEXT	ENDS
PUBLIC	?changeTotalLand@CvTeam@@QAEXH@Z		; CvTeam::changeTotalLand
; Function compile flags: /Odtp
;	COMDAT ?changeTotalLand@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?changeTotalLand@CvTeam@@QAEXH@Z PROC			; CvTeam::changeTotalLand, COMDAT
; _this$ = ecx

; 2912 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2913 : 	m_iTotalLand = (m_iTotalLand + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], ecx

; 2914 : 	CvAssert(getTotalLand() >= 0);
; 2915 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?changeTotalLand@CvTeam@@QAEXH@Z ENDP			; CvTeam::changeTotalLand
_TEXT	ENDS
PUBLIC	?getNukeInterception@CvTeam@@QBEHXZ		; CvTeam::getNukeInterception
; Function compile flags: /Odtp
;	COMDAT ?getNukeInterception@CvTeam@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getNukeInterception@CvTeam@@QBEHXZ PROC		; CvTeam::getNukeInterception, COMDAT
; _this$ = ecx

; 2920 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2921 : 	return m_iNukeInterception;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+32]

; 2922 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getNukeInterception@CvTeam@@QBEHXZ ENDP		; CvTeam::getNukeInterception
_TEXT	ENDS
PUBLIC	?changeNukeInterception@CvTeam@@QAEXH@Z		; CvTeam::changeNukeInterception
; Function compile flags: /Odtp
;	COMDAT ?changeNukeInterception@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?changeNukeInterception@CvTeam@@QAEXH@Z PROC		; CvTeam::changeNukeInterception, COMDAT
; _this$ = ecx

; 2927 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2928 : 	m_iNukeInterception = (m_iNukeInterception + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], ecx

; 2929 : 	CvAssert(getNukeInterception() >= 0);
; 2930 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?changeNukeInterception@CvTeam@@QAEXH@Z ENDP		; CvTeam::changeNukeInterception
_TEXT	ENDS
PUBLIC	?getForceTeamVoteEligibilityCount@CvTeam@@QBEHW4VoteSourceTypes@@@Z ; CvTeam::getForceTeamVoteEligibilityCount
; Function compile flags: /Odtp
;	COMDAT ?getForceTeamVoteEligibilityCount@CvTeam@@QBEHW4VoteSourceTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eVoteSource$ = 8					; size = 4
?getForceTeamVoteEligibilityCount@CvTeam@@QBEHW4VoteSourceTypes@@@Z PROC ; CvTeam::getForceTeamVoteEligibilityCount, COMDAT
; _this$ = ecx

; 2935 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2936 : 	return m_aiForceTeamVoteEligibilityCount[eVoteSource];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2892]
	mov	edx, DWORD PTR _eVoteSource$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 2937 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getForceTeamVoteEligibilityCount@CvTeam@@QBEHW4VoteSourceTypes@@@Z ENDP ; CvTeam::getForceTeamVoteEligibilityCount
_TEXT	ENDS
PUBLIC	?isForceTeamVoteEligible@CvTeam@@QBE_NW4VoteSourceTypes@@@Z ; CvTeam::isForceTeamVoteEligible
; Function compile flags: /Odtp
;	COMDAT ?isForceTeamVoteEligible@CvTeam@@QBE_NW4VoteSourceTypes@@@Z
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
_eVoteSource$ = 8					; size = 4
?isForceTeamVoteEligible@CvTeam@@QBE_NW4VoteSourceTypes@@@Z PROC ; CvTeam::isForceTeamVoteEligible, COMDAT
; _this$ = ecx

; 2942 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2943 : 	return ((getForceTeamVoteEligibilityCount(eVoteSource) > 0) && !isMinorCiv());

	mov	eax, DWORD PTR _eVoteSource$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getForceTeamVoteEligibilityCount@CvTeam@@QBEHW4VoteSourceTypes@@@Z ; CvTeam::getForceTeamVoteEligibilityCount
	test	eax, eax
	jle	SHORT $LN3@isForceTea
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@isForceTea
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN4@isForceTea
$LN3@isForceTea:
	mov	DWORD PTR tv72[ebp], 0
$LN4@isForceTea:
	mov	al, BYTE PTR tv72[ebp]

; 2944 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isForceTeamVoteEligible@CvTeam@@QBE_NW4VoteSourceTypes@@@Z ENDP ; CvTeam::isForceTeamVoteEligible
_TEXT	ENDS
PUBLIC	?changeForceTeamVoteEligibilityCount@CvTeam@@QAEXW4VoteSourceTypes@@H@Z ; CvTeam::changeForceTeamVoteEligibilityCount
; Function compile flags: /Odtp
;	COMDAT ?changeForceTeamVoteEligibilityCount@CvTeam@@QAEXW4VoteSourceTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eVoteSource$ = 8					; size = 4
_iChange$ = 12						; size = 4
?changeForceTeamVoteEligibilityCount@CvTeam@@QAEXW4VoteSourceTypes@@H@Z PROC ; CvTeam::changeForceTeamVoteEligibilityCount, COMDAT
; _this$ = ecx

; 2949 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2950 : 	m_aiForceTeamVoteEligibilityCount[eVoteSource] += iChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2892]
	mov	edx, DWORD PTR _eVoteSource$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	add	eax, DWORD PTR _iChange$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2892]
	mov	ecx, DWORD PTR _eVoteSource$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 2951 : 	CvAssert(getForceTeamVoteEligibilityCount(eVoteSource) >= 0);
; 2952 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?changeForceTeamVoteEligibilityCount@CvTeam@@QAEXW4VoteSourceTypes@@H@Z ENDP ; CvTeam::changeForceTeamVoteEligibilityCount
_TEXT	ENDS
PUBLIC	?getExtraWaterSeeFromCount@CvTeam@@QBEHXZ	; CvTeam::getExtraWaterSeeFromCount
; Function compile flags: /Odtp
;	COMDAT ?getExtraWaterSeeFromCount@CvTeam@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getExtraWaterSeeFromCount@CvTeam@@QBEHXZ PROC		; CvTeam::getExtraWaterSeeFromCount, COMDAT
; _this$ = ecx

; 2957 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2958 : 	return m_iExtraWaterSeeFromCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+36]

; 2959 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getExtraWaterSeeFromCount@CvTeam@@QBEHXZ ENDP		; CvTeam::getExtraWaterSeeFromCount
_TEXT	ENDS
PUBLIC	?isExtraWaterSeeFrom@CvTeam@@QBE_NXZ		; CvTeam::isExtraWaterSeeFrom
; Function compile flags: /Odtp
;	COMDAT ?isExtraWaterSeeFrom@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isExtraWaterSeeFrom@CvTeam@@QBE_NXZ PROC		; CvTeam::isExtraWaterSeeFrom, COMDAT
; _this$ = ecx

; 2964 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2965 : 	return (getExtraWaterSeeFromCount() > 0);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getExtraWaterSeeFromCount@CvTeam@@QBEHXZ ; CvTeam::getExtraWaterSeeFromCount
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	mov	al, cl

; 2966 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isExtraWaterSeeFrom@CvTeam@@QBE_NXZ ENDP		; CvTeam::isExtraWaterSeeFrom
_TEXT	ENDS
PUBLIC	?changeExtraWaterSeeFromCount@CvTeam@@QAEXH@Z	; CvTeam::changeExtraWaterSeeFromCount
EXTRN	?updateSight@CvMap@@QAEX_N@Z:PROC		; CvMap::updateSight
; Function compile flags: /Odtp
;	COMDAT ?changeExtraWaterSeeFromCount@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T234547 = -8						; size = 4
$T234543 = -4						; size = 4
_iChange$ = 8						; size = 4
?changeExtraWaterSeeFromCount@CvTeam@@QAEXH@Z PROC	; CvTeam::changeExtraWaterSeeFromCount, COMDAT
; _this$ = ecx

; 2971 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2972 : 	if(iChange != 0)

	cmp	DWORD PTR _iChange$[ebp], 0
	je	SHORT $LN2@changeExtr

; 2973 : 	{
; 2974 : 		GC.getMap().updateSight(false);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T234543[ebp], eax
	push	0
	mov	ecx, DWORD PTR $T234543[ebp]
	call	?updateSight@CvMap@@QAEX_N@Z		; CvMap::updateSight

; 2975 : 
; 2976 : 		m_iExtraWaterSeeFromCount = (m_iExtraWaterSeeFromCount + iChange);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	add	edx, DWORD PTR _iChange$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+36], edx

; 2977 : 		CvAssert(getExtraWaterSeeFromCount() >= 0);
; 2978 : 
; 2979 : 		GC.getMap().updateSight(true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T234547[ebp], ecx
	push	1
	mov	ecx, DWORD PTR $T234547[ebp]
	call	?updateSight@CvMap@@QAEX_N@Z		; CvMap::updateSight
$LN2@changeExtr:

; 2980 : 	}
; 2981 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?changeExtraWaterSeeFromCount@CvTeam@@QAEXH@Z ENDP	; CvTeam::changeExtraWaterSeeFromCount
_TEXT	ENDS
PUBLIC	?getMapTradingCount@CvTeam@@QBEHXZ		; CvTeam::getMapTradingCount
; Function compile flags: /Odtp
;	COMDAT ?getMapTradingCount@CvTeam@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getMapTradingCount@CvTeam@@QBEHXZ PROC			; CvTeam::getMapTradingCount, COMDAT
; _this$ = ecx

; 2986 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2987 : 	return m_iMapTradingCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+40]

; 2988 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getMapTradingCount@CvTeam@@QBEHXZ ENDP			; CvTeam::getMapTradingCount
_TEXT	ENDS
PUBLIC	?isMapTrading@CvTeam@@QBE_NXZ			; CvTeam::isMapTrading
; Function compile flags: /Odtp
;	COMDAT ?isMapTrading@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isMapTrading@CvTeam@@QBE_NXZ PROC			; CvTeam::isMapTrading, COMDAT
; _this$ = ecx

; 2993 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2994 : 	return (getMapTradingCount() > 0);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getMapTradingCount@CvTeam@@QBEHXZ	; CvTeam::getMapTradingCount
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	mov	al, cl

; 2995 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isMapTrading@CvTeam@@QBE_NXZ ENDP			; CvTeam::isMapTrading
_TEXT	ENDS
PUBLIC	?changeMapTradingCount@CvTeam@@QAEXH@Z		; CvTeam::changeMapTradingCount
; Function compile flags: /Odtp
;	COMDAT ?changeMapTradingCount@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?changeMapTradingCount@CvTeam@@QAEXH@Z PROC		; CvTeam::changeMapTradingCount, COMDAT
; _this$ = ecx

; 3000 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3001 : 	m_iMapTradingCount = (m_iMapTradingCount + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+40], ecx

; 3002 : 	CvAssert(getMapTradingCount() >= 0);
; 3003 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?changeMapTradingCount@CvTeam@@QAEXH@Z ENDP		; CvTeam::changeMapTradingCount
_TEXT	ENDS
PUBLIC	?getTechTradingCount@CvTeam@@QBEHXZ		; CvTeam::getTechTradingCount
; Function compile flags: /Odtp
;	COMDAT ?getTechTradingCount@CvTeam@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getTechTradingCount@CvTeam@@QBEHXZ PROC		; CvTeam::getTechTradingCount, COMDAT
; _this$ = ecx

; 3008 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3009 : 	return m_iTechTradingCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+44]

; 3010 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getTechTradingCount@CvTeam@@QBEHXZ ENDP		; CvTeam::getTechTradingCount
_TEXT	ENDS
PUBLIC	?isTechTrading@CvTeam@@QBE_NXZ			; CvTeam::isTechTrading
; Function compile flags: /Odtp
;	COMDAT ?isTechTrading@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isTechTrading@CvTeam@@QBE_NXZ PROC			; CvTeam::isTechTrading, COMDAT
; _this$ = ecx

; 3015 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3016 : 	return (getTechTradingCount() > 0);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getTechTradingCount@CvTeam@@QBEHXZ	; CvTeam::getTechTradingCount
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	mov	al, cl

; 3017 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isTechTrading@CvTeam@@QBE_NXZ ENDP			; CvTeam::isTechTrading
_TEXT	ENDS
PUBLIC	?changeTechTradingCount@CvTeam@@QAEXH@Z		; CvTeam::changeTechTradingCount
; Function compile flags: /Odtp
;	COMDAT ?changeTechTradingCount@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?changeTechTradingCount@CvTeam@@QAEXH@Z PROC		; CvTeam::changeTechTradingCount, COMDAT
; _this$ = ecx

; 3022 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3023 : 	m_iTechTradingCount = (m_iTechTradingCount + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+44], ecx

; 3024 : 	CvAssert(getTechTradingCount() >= 0);
; 3025 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?changeTechTradingCount@CvTeam@@QAEXH@Z ENDP		; CvTeam::changeTechTradingCount
_TEXT	ENDS
PUBLIC	?getGoldTradingCount@CvTeam@@QBEHXZ		; CvTeam::getGoldTradingCount
; Function compile flags: /Odtp
;	COMDAT ?getGoldTradingCount@CvTeam@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getGoldTradingCount@CvTeam@@QBEHXZ PROC		; CvTeam::getGoldTradingCount, COMDAT
; _this$ = ecx

; 3030 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3031 : 	return m_iGoldTradingCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+48]

; 3032 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getGoldTradingCount@CvTeam@@QBEHXZ ENDP		; CvTeam::getGoldTradingCount
_TEXT	ENDS
PUBLIC	?isGoldTrading@CvTeam@@QBE_NXZ			; CvTeam::isGoldTrading
; Function compile flags: /Odtp
;	COMDAT ?isGoldTrading@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isGoldTrading@CvTeam@@QBE_NXZ PROC			; CvTeam::isGoldTrading, COMDAT
; _this$ = ecx

; 3037 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3038 : 	return (getGoldTradingCount() > 0);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getGoldTradingCount@CvTeam@@QBEHXZ	; CvTeam::getGoldTradingCount
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	mov	al, cl

; 3039 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isGoldTrading@CvTeam@@QBE_NXZ ENDP			; CvTeam::isGoldTrading
_TEXT	ENDS
PUBLIC	?changeGoldTradingCount@CvTeam@@QAEXH@Z		; CvTeam::changeGoldTradingCount
; Function compile flags: /Odtp
;	COMDAT ?changeGoldTradingCount@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?changeGoldTradingCount@CvTeam@@QAEXH@Z PROC		; CvTeam::changeGoldTradingCount, COMDAT
; _this$ = ecx

; 3044 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3045 : 	m_iGoldTradingCount = (m_iGoldTradingCount + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+48], ecx

; 3046 : 	CvAssert(getGoldTradingCount() >= 0);
; 3047 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?changeGoldTradingCount@CvTeam@@QAEXH@Z ENDP		; CvTeam::changeGoldTradingCount
_TEXT	ENDS
PUBLIC	?HavePolicyInTeam@CvTeam@@QAE_NW4PolicyTypes@@@Z ; CvTeam::HavePolicyInTeam
EXTRN	?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z:PROC ; CvPlayerPolicies::HasPolicy
EXTRN	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ:PROC ; CvPlayer::GetPlayerPolicies
; Function compile flags: /Odtp
;	COMDAT ?HavePolicyInTeam@CvTeam@@QAE_NW4PolicyTypes@@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T234579 = -17						; size = 1
_ePlayer$224367 = -16					; size = 4
_kPlayer$224368 = -12					; size = 4
_iI$224362 = -8						; size = 4
_eID$ = -4						; size = 4
_ePolicy$ = 8						; size = 4
?HavePolicyInTeam@CvTeam@@QAE_NW4PolicyTypes@@@Z PROC	; CvTeam::HavePolicyInTeam, COMDAT
; _this$ = ecx

; 3051 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 3052 : 	const TeamTypes eID(GetID());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	mov	DWORD PTR _eID$[ebp], eax

; 3053 : 
; 3054 : 	for(int iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$224362[ebp], 0
	jmp	SHORT $LN6@HavePolicy
$LN5@HavePolicy:
	mov	eax, DWORD PTR _iI$224362[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$224362[ebp], eax
$LN6@HavePolicy:
	cmp	DWORD PTR _iI$224362[ebp], 64		; 00000040H
	jge	SHORT $LN4@HavePolicy

; 3055 : 	{
; 3056 : 		const PlayerTypes ePlayer(static_cast<PlayerTypes>(iI));

	mov	ecx, DWORD PTR _iI$224362[ebp]
	mov	DWORD PTR _ePlayer$224367[ebp], ecx

; 3057 : 		CvPlayerAI& kPlayer(GET_PLAYER(ePlayer));

	mov	edx, DWORD PTR _ePlayer$224367[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$224368[ebp], edx

; 3058 : 
; 3059 : 		if(kPlayer.isAlive())

	mov	eax, DWORD PTR _kPlayer$224368[ebp]
	mov	cl, BYTE PTR [eax+2256]
	mov	BYTE PTR $T234579[ebp], cl
	movzx	edx, BYTE PTR $T234579[ebp]
	test	edx, edx
	je	SHORT $LN3@HavePolicy

; 3060 : 		{
; 3061 : 			if(kPlayer.getTeam() == eID)

	mov	eax, DWORD PTR _kPlayer$224368[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	eax, DWORD PTR _eID$[ebp]
	jne	SHORT $LN3@HavePolicy

; 3062 : 			{
; 3063 : 				if (kPlayer.GetPlayerPolicies()->HasPolicy(ePolicy))

	mov	edx, DWORD PTR _ePolicy$[ebp]
	push	edx
	mov	ecx, DWORD PTR _kPlayer$224368[ebp]
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::HasPolicy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@HavePolicy

; 3064 : 				{
; 3065 : 					return true;

	mov	al, 1
	jmp	SHORT $LN7@HavePolicy
$LN3@HavePolicy:

; 3066 : 				}
; 3067 : 			}
; 3068 : 		}
; 3069 : 	}

	jmp	SHORT $LN5@HavePolicy
$LN4@HavePolicy:

; 3070 : 	return false;

	xor	al, al
$LN7@HavePolicy:

; 3071 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?HavePolicyInTeam@CvTeam@@QAE_NW4PolicyTypes@@@Z ENDP	; CvTeam::HavePolicyInTeam
_TEXT	ENDS
PUBLIC	?getAllowEmbassyTradingAllowedCount@CvTeam@@QBEHXZ ; CvTeam::getAllowEmbassyTradingAllowedCount
; Function compile flags: /Odtp
;	COMDAT ?getAllowEmbassyTradingAllowedCount@CvTeam@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getAllowEmbassyTradingAllowedCount@CvTeam@@QBEHXZ PROC	; CvTeam::getAllowEmbassyTradingAllowedCount, COMDAT
; _this$ = ecx

; 3075 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3076 : 	return m_iAllowEmbassyTradingAllowedCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+52]

; 3077 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getAllowEmbassyTradingAllowedCount@CvTeam@@QBEHXZ ENDP	; CvTeam::getAllowEmbassyTradingAllowedCount
_TEXT	ENDS
PUBLIC	?isAllowEmbassyTradingAllowed@CvTeam@@QBE_NXZ	; CvTeam::isAllowEmbassyTradingAllowed
; Function compile flags: /Odtp
;	COMDAT ?isAllowEmbassyTradingAllowed@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isAllowEmbassyTradingAllowed@CvTeam@@QBE_NXZ PROC	; CvTeam::isAllowEmbassyTradingAllowed, COMDAT
; _this$ = ecx

; 3081 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3082 : 	return (getAllowEmbassyTradingAllowedCount() > 0);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getAllowEmbassyTradingAllowedCount@CvTeam@@QBEHXZ ; CvTeam::getAllowEmbassyTradingAllowedCount
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	mov	al, cl

; 3083 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isAllowEmbassyTradingAllowed@CvTeam@@QBE_NXZ ENDP	; CvTeam::isAllowEmbassyTradingAllowed
_TEXT	ENDS
PUBLIC	?changeAllowEmbassyTradingAllowedCount@CvTeam@@QAEXH@Z ; CvTeam::changeAllowEmbassyTradingAllowedCount
; Function compile flags: /Odtp
;	COMDAT ?changeAllowEmbassyTradingAllowedCount@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?changeAllowEmbassyTradingAllowedCount@CvTeam@@QAEXH@Z PROC ; CvTeam::changeAllowEmbassyTradingAllowedCount, COMDAT
; _this$ = ecx

; 3087 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3088 : 	m_iAllowEmbassyTradingAllowedCount = (m_iAllowEmbassyTradingAllowedCount + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+52], ecx

; 3089 : 	CvAssert(getAllowEmbassyTradingAllowedCount() >= 0);
; 3090 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?changeAllowEmbassyTradingAllowedCount@CvTeam@@QAEXH@Z ENDP ; CvTeam::changeAllowEmbassyTradingAllowedCount
_TEXT	ENDS
PUBLIC	?getOpenBordersTradingAllowedCount@CvTeam@@QBEHXZ ; CvTeam::getOpenBordersTradingAllowedCount
; Function compile flags: /Odtp
;	COMDAT ?getOpenBordersTradingAllowedCount@CvTeam@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getOpenBordersTradingAllowedCount@CvTeam@@QBEHXZ PROC	; CvTeam::getOpenBordersTradingAllowedCount, COMDAT
; _this$ = ecx

; 3095 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3096 : 	return m_iOpenBordersTradingAllowedCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+56]

; 3097 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getOpenBordersTradingAllowedCount@CvTeam@@QBEHXZ ENDP	; CvTeam::getOpenBordersTradingAllowedCount
_TEXT	ENDS
PUBLIC	?isOpenBordersTradingAllowed@CvTeam@@QBE_NXZ	; CvTeam::isOpenBordersTradingAllowed
; Function compile flags: /Odtp
;	COMDAT ?isOpenBordersTradingAllowed@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isOpenBordersTradingAllowed@CvTeam@@QBE_NXZ PROC	; CvTeam::isOpenBordersTradingAllowed, COMDAT
; _this$ = ecx

; 3102 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3103 : 	return (getOpenBordersTradingAllowedCount() > 0);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getOpenBordersTradingAllowedCount@CvTeam@@QBEHXZ ; CvTeam::getOpenBordersTradingAllowedCount
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	mov	al, cl

; 3104 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isOpenBordersTradingAllowed@CvTeam@@QBE_NXZ ENDP	; CvTeam::isOpenBordersTradingAllowed
_TEXT	ENDS
PUBLIC	?isOpenBordersTradingAllowedWithTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::isOpenBordersTradingAllowedWithTeam
; Function compile flags: /Odtp
;	COMDAT ?isOpenBordersTradingAllowedWithTeam@CvTeam@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
tv73 = -8						; size = 4
_this$ = -4						; size = 4
_eTeam$ = 8						; size = 4
?isOpenBordersTradingAllowedWithTeam@CvTeam@@QBE_NW4TeamTypes@@@Z PROC ; CvTeam::isOpenBordersTradingAllowedWithTeam, COMDAT
; _this$ = ecx

; 3108 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 3109 : 	return HasEmbassyAtTeam(eTeam) && isOpenBordersTradingAllowed();

	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasEmbassyAtTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::HasEmbassyAtTeam
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@isOpenBord
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isOpenBordersTradingAllowed@CvTeam@@QBE_NXZ ; CvTeam::isOpenBordersTradingAllowed
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@isOpenBord
	mov	DWORD PTR tv73[ebp], 1
	jmp	SHORT $LN4@isOpenBord
$LN3@isOpenBord:
	mov	DWORD PTR tv73[ebp], 0
$LN4@isOpenBord:
	mov	al, BYTE PTR tv73[ebp]

; 3110 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isOpenBordersTradingAllowedWithTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ENDP ; CvTeam::isOpenBordersTradingAllowedWithTeam
_TEXT	ENDS
PUBLIC	?changeOpenBordersTradingAllowedCount@CvTeam@@QAEXH@Z ; CvTeam::changeOpenBordersTradingAllowedCount
; Function compile flags: /Odtp
;	COMDAT ?changeOpenBordersTradingAllowedCount@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?changeOpenBordersTradingAllowedCount@CvTeam@@QAEXH@Z PROC ; CvTeam::changeOpenBordersTradingAllowedCount, COMDAT
; _this$ = ecx

; 3114 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3115 : 	m_iOpenBordersTradingAllowedCount = (m_iOpenBordersTradingAllowedCount + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], ecx

; 3116 : 	CvAssert(getOpenBordersTradingAllowedCount() >= 0);
; 3117 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?changeOpenBordersTradingAllowedCount@CvTeam@@QAEXH@Z ENDP ; CvTeam::changeOpenBordersTradingAllowedCount
_TEXT	ENDS
PUBLIC	?getDefensivePactTradingAllowedCount@CvTeam@@QBEHXZ ; CvTeam::getDefensivePactTradingAllowedCount
; Function compile flags: /Odtp
;	COMDAT ?getDefensivePactTradingAllowedCount@CvTeam@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getDefensivePactTradingAllowedCount@CvTeam@@QBEHXZ PROC ; CvTeam::getDefensivePactTradingAllowedCount, COMDAT
; _this$ = ecx

; 3122 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3123 : 	return m_iDefensivePactTradingAllowedCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+60]

; 3124 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getDefensivePactTradingAllowedCount@CvTeam@@QBEHXZ ENDP ; CvTeam::getDefensivePactTradingAllowedCount
_TEXT	ENDS
PUBLIC	?isDefensivePactTradingAllowed@CvTeam@@QBE_NXZ	; CvTeam::isDefensivePactTradingAllowed
; Function compile flags: /Odtp
;	COMDAT ?isDefensivePactTradingAllowed@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isDefensivePactTradingAllowed@CvTeam@@QBE_NXZ PROC	; CvTeam::isDefensivePactTradingAllowed, COMDAT
; _this$ = ecx

; 3129 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3130 : 	return (getDefensivePactTradingAllowedCount() > 0);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getDefensivePactTradingAllowedCount@CvTeam@@QBEHXZ ; CvTeam::getDefensivePactTradingAllowedCount
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	mov	al, cl

; 3131 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isDefensivePactTradingAllowed@CvTeam@@QBE_NXZ ENDP	; CvTeam::isDefensivePactTradingAllowed
_TEXT	ENDS
PUBLIC	?isDefensivePactTradingAllowedWithTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::isDefensivePactTradingAllowedWithTeam
; Function compile flags: /Odtp
;	COMDAT ?isDefensivePactTradingAllowedWithTeam@CvTeam@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
tv81 = -12						; size = 4
_this$ = -8						; size = 4
$T234615 = -4						; size = 4
_eTeam$ = 8						; size = 4
?isDefensivePactTradingAllowedWithTeam@CvTeam@@QBE_NW4TeamTypes@@@Z PROC ; CvTeam::isDefensivePactTradingAllowedWithTeam, COMDAT
; _this$ = ecx

; 3135 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 3136 : 	return HasEmbassyAtTeam(eTeam) && GET_TEAM(eTeam).HasEmbassyAtTeam(m_eID) && isDefensivePactTradingAllowed();

	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasEmbassyAtTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::HasEmbassyAtTeam
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@isDefensiv
	mov	edx, DWORD PTR _eTeam$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T234615[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR $T234615[ebp]
	call	?HasEmbassyAtTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::HasEmbassyAtTeam
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@isDefensiv
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isDefensivePactTradingAllowed@CvTeam@@QBE_NXZ ; CvTeam::isDefensivePactTradingAllowed
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@isDefensiv
	mov	DWORD PTR tv81[ebp], 1
	jmp	SHORT $LN4@isDefensiv
$LN3@isDefensiv:
	mov	DWORD PTR tv81[ebp], 0
$LN4@isDefensiv:
	mov	al, BYTE PTR tv81[ebp]

; 3137 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isDefensivePactTradingAllowedWithTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ENDP ; CvTeam::isDefensivePactTradingAllowedWithTeam
_TEXT	ENDS
PUBLIC	?changeDefensivePactTradingAllowedCount@CvTeam@@QAEXH@Z ; CvTeam::changeDefensivePactTradingAllowedCount
; Function compile flags: /Odtp
;	COMDAT ?changeDefensivePactTradingAllowedCount@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?changeDefensivePactTradingAllowedCount@CvTeam@@QAEXH@Z PROC ; CvTeam::changeDefensivePactTradingAllowedCount, COMDAT
; _this$ = ecx

; 3141 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3142 : 	m_iDefensivePactTradingAllowedCount = (m_iDefensivePactTradingAllowedCount + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+60], ecx

; 3143 : 	CvAssert(getDefensivePactTradingAllowedCount() >= 0);
; 3144 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?changeDefensivePactTradingAllowedCount@CvTeam@@QAEXH@Z ENDP ; CvTeam::changeDefensivePactTradingAllowedCount
_TEXT	ENDS
PUBLIC	?GetResearchAgreementTradingAllowedCount@CvTeam@@QBEHXZ ; CvTeam::GetResearchAgreementTradingAllowedCount
; Function compile flags: /Odtp
;	COMDAT ?GetResearchAgreementTradingAllowedCount@CvTeam@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetResearchAgreementTradingAllowedCount@CvTeam@@QBEHXZ PROC ; CvTeam::GetResearchAgreementTradingAllowedCount, COMDAT
; _this$ = ecx

; 3149 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3150 : 	return m_iResearchAgreementTradingAllowedCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+64]

; 3151 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetResearchAgreementTradingAllowedCount@CvTeam@@QBEHXZ ENDP ; CvTeam::GetResearchAgreementTradingAllowedCount
_TEXT	ENDS
PUBLIC	?IsResearchAgreementTradingAllowed@CvTeam@@QBE_NXZ ; CvTeam::IsResearchAgreementTradingAllowed
; Function compile flags: /Odtp
;	COMDAT ?IsResearchAgreementTradingAllowed@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsResearchAgreementTradingAllowed@CvTeam@@QBE_NXZ PROC	; CvTeam::IsResearchAgreementTradingAllowed, COMDAT
; _this$ = ecx

; 3156 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3157 : 	return (GetResearchAgreementTradingAllowedCount() > 0);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetResearchAgreementTradingAllowedCount@CvTeam@@QBEHXZ ; CvTeam::GetResearchAgreementTradingAllowedCount
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	mov	al, cl

; 3158 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsResearchAgreementTradingAllowed@CvTeam@@QBE_NXZ ENDP	; CvTeam::IsResearchAgreementTradingAllowed
_TEXT	ENDS
PUBLIC	?IsResearchAgreementTradingAllowedWithTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsResearchAgreementTradingAllowedWithTeam
; Function compile flags: /Odtp
;	COMDAT ?IsResearchAgreementTradingAllowedWithTeam@CvTeam@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
tv73 = -8						; size = 4
_this$ = -4						; size = 4
_eTeam$ = 8						; size = 4
?IsResearchAgreementTradingAllowedWithTeam@CvTeam@@QBE_NW4TeamTypes@@@Z PROC ; CvTeam::IsResearchAgreementTradingAllowedWithTeam, COMDAT
; _this$ = ecx

; 3162 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 3163 : 	return HasEmbassyAtTeam(eTeam) && IsResearchAgreementTradingAllowed();

	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasEmbassyAtTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::HasEmbassyAtTeam
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@IsResearch
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsResearchAgreementTradingAllowed@CvTeam@@QBE_NXZ ; CvTeam::IsResearchAgreementTradingAllowed
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@IsResearch
	mov	DWORD PTR tv73[ebp], 1
	jmp	SHORT $LN4@IsResearch
$LN3@IsResearch:
	mov	DWORD PTR tv73[ebp], 0
$LN4@IsResearch:
	mov	al, BYTE PTR tv73[ebp]

; 3164 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsResearchAgreementTradingAllowedWithTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ENDP ; CvTeam::IsResearchAgreementTradingAllowedWithTeam
_TEXT	ENDS
PUBLIC	?ChangeResearchAgreementTradingAllowedCount@CvTeam@@QAEXH@Z ; CvTeam::ChangeResearchAgreementTradingAllowedCount
; Function compile flags: /Odtp
;	COMDAT ?ChangeResearchAgreementTradingAllowedCount@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?ChangeResearchAgreementTradingAllowedCount@CvTeam@@QAEXH@Z PROC ; CvTeam::ChangeResearchAgreementTradingAllowedCount, COMDAT
; _this$ = ecx

; 3168 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3169 : 	m_iResearchAgreementTradingAllowedCount = (m_iResearchAgreementTradingAllowedCount + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+64], ecx

; 3170 : 	CvAssert(GetResearchAgreementTradingAllowedCount() >= 0);
; 3171 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ChangeResearchAgreementTradingAllowedCount@CvTeam@@QAEXH@Z ENDP ; CvTeam::ChangeResearchAgreementTradingAllowedCount
_TEXT	ENDS
PUBLIC	?GetTradeAgreementTradingAllowedCount@CvTeam@@QBEHXZ ; CvTeam::GetTradeAgreementTradingAllowedCount
; Function compile flags: /Odtp
;	COMDAT ?GetTradeAgreementTradingAllowedCount@CvTeam@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTradeAgreementTradingAllowedCount@CvTeam@@QBEHXZ PROC ; CvTeam::GetTradeAgreementTradingAllowedCount, COMDAT
; _this$ = ecx

; 3176 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3177 : 	return m_iTradeAgreementTradingAllowedCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+68]

; 3178 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTradeAgreementTradingAllowedCount@CvTeam@@QBEHXZ ENDP ; CvTeam::GetTradeAgreementTradingAllowedCount
_TEXT	ENDS
PUBLIC	?IsTradeAgreementTradingAllowed@CvTeam@@QBE_NXZ	; CvTeam::IsTradeAgreementTradingAllowed
; Function compile flags: /Odtp
;	COMDAT ?IsTradeAgreementTradingAllowed@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsTradeAgreementTradingAllowed@CvTeam@@QBE_NXZ PROC	; CvTeam::IsTradeAgreementTradingAllowed, COMDAT
; _this$ = ecx

; 3183 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3184 : 	return (GetTradeAgreementTradingAllowedCount() > 0);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTradeAgreementTradingAllowedCount@CvTeam@@QBEHXZ ; CvTeam::GetTradeAgreementTradingAllowedCount
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	mov	al, cl

; 3185 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTradeAgreementTradingAllowed@CvTeam@@QBE_NXZ ENDP	; CvTeam::IsTradeAgreementTradingAllowed
_TEXT	ENDS
PUBLIC	?ChangeTradeAgreementTradingAllowedCount@CvTeam@@QAEXH@Z ; CvTeam::ChangeTradeAgreementTradingAllowedCount
; Function compile flags: /Odtp
;	COMDAT ?ChangeTradeAgreementTradingAllowedCount@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?ChangeTradeAgreementTradingAllowedCount@CvTeam@@QAEXH@Z PROC ; CvTeam::ChangeTradeAgreementTradingAllowedCount, COMDAT
; _this$ = ecx

; 3190 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3191 : 	m_iTradeAgreementTradingAllowedCount = (m_iTradeAgreementTradingAllowedCount + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+68], ecx

; 3192 : 	CvAssert(GetTradeAgreementTradingAllowedCount() >= 0);
; 3193 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ChangeTradeAgreementTradingAllowedCount@CvTeam@@QAEXH@Z ENDP ; CvTeam::ChangeTradeAgreementTradingAllowedCount
_TEXT	ENDS
PUBLIC	?getPermanentAllianceTradingCount@CvTeam@@QBEHXZ ; CvTeam::getPermanentAllianceTradingCount
; Function compile flags: /Odtp
;	COMDAT ?getPermanentAllianceTradingCount@CvTeam@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getPermanentAllianceTradingCount@CvTeam@@QBEHXZ PROC	; CvTeam::getPermanentAllianceTradingCount, COMDAT
; _this$ = ecx

; 3198 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3199 : 	return m_iPermanentAllianceTradingCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+72]

; 3200 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getPermanentAllianceTradingCount@CvTeam@@QBEHXZ ENDP	; CvTeam::getPermanentAllianceTradingCount
_TEXT	ENDS
PUBLIC	?isPermanentAllianceTrading@CvTeam@@QBE_NXZ	; CvTeam::isPermanentAllianceTrading
; Function compile flags: /Odtp
;	COMDAT ?isPermanentAllianceTrading@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isPermanentAllianceTrading@CvTeam@@QBE_NXZ PROC	; CvTeam::isPermanentAllianceTrading, COMDAT
; _this$ = ecx

; 3205 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3206 : 	return false;

	xor	al, al

; 3207 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isPermanentAllianceTrading@CvTeam@@QBE_NXZ ENDP	; CvTeam::isPermanentAllianceTrading
_TEXT	ENDS
PUBLIC	?changePermanentAllianceTradingCount@CvTeam@@QAEXH@Z ; CvTeam::changePermanentAllianceTradingCount
; Function compile flags: /Odtp
;	COMDAT ?changePermanentAllianceTradingCount@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?changePermanentAllianceTradingCount@CvTeam@@QAEXH@Z PROC ; CvTeam::changePermanentAllianceTradingCount, COMDAT
; _this$ = ecx

; 3212 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3213 : 	m_iPermanentAllianceTradingCount = (m_iPermanentAllianceTradingCount + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+72], ecx

; 3214 : 	CvAssert(getPermanentAllianceTradingCount() >= 0);
; 3215 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?changePermanentAllianceTradingCount@CvTeam@@QAEXH@Z ENDP ; CvTeam::changePermanentAllianceTradingCount
_TEXT	ENDS
PUBLIC	?getBridgeBuildingCount@CvTeam@@QBEHXZ		; CvTeam::getBridgeBuildingCount
; Function compile flags: /Odtp
;	COMDAT ?getBridgeBuildingCount@CvTeam@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getBridgeBuildingCount@CvTeam@@QBEHXZ PROC		; CvTeam::getBridgeBuildingCount, COMDAT
; _this$ = ecx

; 3219 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3220 : 	return m_iBridgeBuildingCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+76]

; 3221 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getBridgeBuildingCount@CvTeam@@QBEHXZ ENDP		; CvTeam::getBridgeBuildingCount
_TEXT	ENDS
PUBLIC	?isBridgeBuilding@CvTeam@@QBE_NXZ		; CvTeam::isBridgeBuilding
; Function compile flags: /Odtp
;	COMDAT ?isBridgeBuilding@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isBridgeBuilding@CvTeam@@QBE_NXZ PROC			; CvTeam::isBridgeBuilding, COMDAT
; _this$ = ecx

; 3226 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3227 : 	return (getBridgeBuildingCount() > 0);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getBridgeBuildingCount@CvTeam@@QBEHXZ	; CvTeam::getBridgeBuildingCount
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	mov	al, cl

; 3228 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isBridgeBuilding@CvTeam@@QBE_NXZ ENDP			; CvTeam::isBridgeBuilding
_TEXT	ENDS
PUBLIC	?GetCurrentEra@CvTeam@@QBE?AW4EraTypes@@XZ	; CvTeam::GetCurrentEra
PUBLIC	?changeBridgeBuildingCount@CvTeam@@QAEXH@Z	; CvTeam::changeBridgeBuildingCount
EXTRN	?IsGraphicsInitialized@CvGlobals@@QBE_NXZ:PROC	; CvGlobals::IsGraphicsInitialized
; Function compile flags: /Odtp
;	COMDAT ?changeBridgeBuildingCount@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
tv134 = -28						; size = 4
tv90 = -24						; size = 4
_this$ = -20						; size = 4
$T234661 = -16						; size = 4
$T234657 = -12						; size = 4
$T234653 = -8						; size = 4
$T234649 = -4						; size = 4
_iChange$ = 8						; size = 4
?changeBridgeBuildingCount@CvTeam@@QAEXH@Z PROC		; CvTeam::changeBridgeBuildingCount, COMDAT
; _this$ = ecx

; 3233 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 3234 : 	if(iChange != 0)

	cmp	DWORD PTR _iChange$[ebp], 0
	je	$LN6@changeBrid

; 3235 : 	{
; 3236 : 		m_iBridgeBuildingCount = (m_iBridgeBuildingCount + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+76], ecx

; 3237 : 		CvAssert(getBridgeBuildingCount() >= 0);
; 3238 : 
; 3239 : 		if(m_eID == GC.getGame().getActiveTeam())

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T234649[ebp], eax
	mov	ecx, DWORD PTR $T234649[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], eax
	jne	SHORT $LN6@changeBrid

; 3240 : 		{
; 3241 : 			if(GC.IsGraphicsInitialized())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?IsGraphicsInitialized@CvGlobals@@QBE_NXZ ; CvGlobals::IsGraphicsInitialized
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN6@changeBrid

; 3242 : 			{
; 3243 : 				if(GetCurrentEra() >= GC.getLAST_BRIDGE_ART_ERA())

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8496
	mov	DWORD PTR $T234653[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCurrentEra@CvTeam@@QBE?AW4EraTypes@@XZ ; CvTeam::GetCurrentEra
	cmp	eax, DWORD PTR $T234653[ebp]
	jl	SHORT $LN2@changeBrid

; 3244 : 				{
; 3245 : 					gDLL->GameplayBridgeChanged(true, 1);

	mov	ecx, DWORD PTR $T234657[ebp]
	mov	DWORD PTR tv90[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv90[ebp], edx
	push	1
	push	1
	mov	eax, DWORD PTR tv90[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv90[ebp]
	mov	eax, DWORD PTR [edx+580]
	call	eax

; 3246 : 				}
; 3247 : 				else

	jmp	SHORT $LN6@changeBrid
$LN2@changeBrid:

; 3248 : 				{
; 3249 : 					gDLL->GameplayBridgeChanged(true, 0);

	mov	ecx, DWORD PTR $T234661[ebp]
	mov	DWORD PTR tv134[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv134[ebp], edx
	push	0
	push	1
	mov	eax, DWORD PTR tv134[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv134[ebp]
	mov	eax, DWORD PTR [edx+580]
	call	eax
$LN6@changeBrid:

; 3250 : 				}
; 3251 : 			}
; 3252 : 		}
; 3253 : 	}
; 3254 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?changeBridgeBuildingCount@CvTeam@@QAEXH@Z ENDP		; CvTeam::changeBridgeBuildingCount
_TEXT	ENDS
PUBLIC	?getWaterWorkCount@CvTeam@@QBEHXZ		; CvTeam::getWaterWorkCount
; Function compile flags: /Odtp
;	COMDAT ?getWaterWorkCount@CvTeam@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getWaterWorkCount@CvTeam@@QBEHXZ PROC			; CvTeam::getWaterWorkCount, COMDAT
; _this$ = ecx

; 3259 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3260 : 	return m_iWaterWorkCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+80]

; 3261 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getWaterWorkCount@CvTeam@@QBEHXZ ENDP			; CvTeam::getWaterWorkCount
_TEXT	ENDS
PUBLIC	?isWaterWork@CvTeam@@QBE_NXZ			; CvTeam::isWaterWork
; Function compile flags: /Odtp
;	COMDAT ?isWaterWork@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isWaterWork@CvTeam@@QBE_NXZ PROC			; CvTeam::isWaterWork, COMDAT
; _this$ = ecx

; 3266 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3267 : 	return (getWaterWorkCount() > 0);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getWaterWorkCount@CvTeam@@QBEHXZ	; CvTeam::getWaterWorkCount
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	mov	al, cl

; 3268 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isWaterWork@CvTeam@@QBE_NXZ ENDP			; CvTeam::isWaterWork
_TEXT	ENDS
PUBLIC	?changeWaterWorkCount@CvTeam@@QAEXH@Z		; CvTeam::changeWaterWorkCount
; Function compile flags: /Odtp
;	COMDAT ?changeWaterWorkCount@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?changeWaterWorkCount@CvTeam@@QAEXH@Z PROC		; CvTeam::changeWaterWorkCount, COMDAT
; _this$ = ecx

; 3273 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3274 : 	if(iChange != 0)

	cmp	DWORD PTR _iChange$[ebp], 0
	je	SHORT $LN2@changeWate

; 3275 : 	{
; 3276 : 		m_iWaterWorkCount = (m_iWaterWorkCount + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+80], ecx
$LN2@changeWate:

; 3277 : 		CvAssert(getWaterWorkCount() >= 0);
; 3278 : 	}
; 3279 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?changeWaterWorkCount@CvTeam@@QAEXH@Z ENDP		; CvTeam::changeWaterWorkCount
_TEXT	ENDS
PUBLIC	?getBorderObstacleCount@CvTeam@@QBEHXZ		; CvTeam::getBorderObstacleCount
; Function compile flags: /Odtp
;	COMDAT ?getBorderObstacleCount@CvTeam@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getBorderObstacleCount@CvTeam@@QBEHXZ PROC		; CvTeam::getBorderObstacleCount, COMDAT
; _this$ = ecx

; 3283 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3284 : 	return m_iBorderObstacleCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+88]

; 3285 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getBorderObstacleCount@CvTeam@@QBEHXZ ENDP		; CvTeam::getBorderObstacleCount
_TEXT	ENDS
PUBLIC	?isBorderObstacle@CvTeam@@QBE_NXZ		; CvTeam::isBorderObstacle
; Function compile flags: /Odtp
;	COMDAT ?isBorderObstacle@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isBorderObstacle@CvTeam@@QBE_NXZ PROC			; CvTeam::isBorderObstacle, COMDAT
; _this$ = ecx

; 3289 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3290 : 	return (getBorderObstacleCount() > 0);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getBorderObstacleCount@CvTeam@@QBEHXZ	; CvTeam::getBorderObstacleCount
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	mov	al, cl

; 3291 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isBorderObstacle@CvTeam@@QBE_NXZ ENDP			; CvTeam::isBorderObstacle
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?changeBorderObstacleCount@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?changeBorderObstacleCount@CvTeam@@QAEXH@Z PROC		; CvTeam::changeBorderObstacleCount, COMDAT
; _this$ = ecx

; 3295 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3296 : 	if(iChange != 0)

	cmp	DWORD PTR _iChange$[ebp], 0
	je	SHORT $LN2@changeBord

; 3297 : 	{
; 3298 : 		m_iBorderObstacleCount = (m_iBorderObstacleCount + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+88], ecx
$LN2@changeBord:

; 3299 : 		CvAssert(getBorderObstacleCount() >= 0);
; 3300 : 	}
; 3301 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?changeBorderObstacleCount@CvTeam@@QAEXH@Z ENDP		; CvTeam::changeBorderObstacleCount
_TEXT	ENDS
PUBLIC	?isMapCentering@CvTeam@@QBE_NXZ			; CvTeam::isMapCentering
; Function compile flags: /Odtp
;	COMDAT ?isMapCentering@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isMapCentering@CvTeam@@QBE_NXZ PROC			; CvTeam::isMapCentering, COMDAT
; _this$ = ecx

; 3306 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3307 : 	return m_bMapCentering;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+128]

; 3308 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isMapCentering@CvTeam@@QBE_NXZ ENDP			; CvTeam::isMapCentering
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?setMapCentering@CvTeam@@QAEX_N@Z
_TEXT	SEGMENT
tv84 = -16						; size = 4
_this$ = -12						; size = 4
$T234685 = -8						; size = 4
$T234681 = -4						; size = 4
_bNewValue$ = 8						; size = 1
?setMapCentering@CvTeam@@QAEX_N@Z PROC			; CvTeam::setMapCentering, COMDAT
; _this$ = ecx

; 3313 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 3314 : 	if(isMapCentering() != bNewValue)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isMapCentering@CvTeam@@QBE_NXZ		; CvTeam::isMapCentering
	movzx	eax, al
	movzx	ecx, BYTE PTR _bNewValue$[ebp]
	cmp	eax, ecx
	je	SHORT $LN3@setMapCent

; 3315 : 	{
; 3316 : 		m_bMapCentering = bNewValue;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR _bNewValue$[ebp]
	mov	BYTE PTR [edx+128], al

; 3317 : 
; 3318 : 		if(GetID() == GC.getGame().getActiveTeam())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T234681[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	mov	esi, eax
	mov	ecx, DWORD PTR $T234681[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	esi, eax
	jne	SHORT $LN3@setMapCent

; 3319 : 		{
; 3320 : 			DLLUI->setDirty(MinimapSection_DIRTY_BIT, true);

	mov	edx, DWORD PTR $T234685[ebp]
	mov	DWORD PTR tv84[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv84[ebp], eax
	push	1
	push	15					; 0000000fH
	mov	ecx, DWORD PTR tv84[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv84[ebp]
	mov	eax, DWORD PTR [edx+260]
	call	eax
$LN3@setMapCent:

; 3321 : 		}
; 3322 : 	}
; 3323 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?setMapCentering@CvTeam@@QAEX_N@Z ENDP			; CvTeam::setMapCentering
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ PROC		; CvTeam::GetID, COMDAT
; _this$ = ecx

; 3328 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3329 : 	return m_eID;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 3330 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ ENDP		; CvTeam::GetID
_TEXT	ENDS
PUBLIC	?getTechShareCount@CvTeam@@QBEHH@Z		; CvTeam::getTechShareCount
; Function compile flags: /Odtp
;	COMDAT ?getTechShareCount@CvTeam@@QBEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
?getTechShareCount@CvTeam@@QBEHH@Z PROC			; CvTeam::getTechShareCount, COMDAT
; _this$ = ecx

; 3335 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3336 : 	CvAssertMsg(iIndex >= 0, "iIndex is expected to be non-negative (invalid Index)");
; 3337 : 	CvAssertMsg(iIndex < MAX_TEAMS, "iIndex is expected to be within maximum bounds (invalid Index)");
; 3338 : 	if(iIndex < 0 || iIndex >= MAX_TEAMS) return 0; // as set in reset()

	cmp	DWORD PTR _iIndex$[ebp], 0
	jl	SHORT $LN1@getTechSha
	cmp	DWORD PTR _iIndex$[ebp], 64		; 00000040H
	jl	SHORT $LN5@getTechSha
$LN1@getTechSha:
	xor	eax, eax
	jmp	SHORT $LN3@getTechSha

; 3339 : 	return m_aiTechShareCount[iIndex];

$LN5@getTechSha:
	mov	eax, DWORD PTR _iIndex$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4+148]
$LN3@getTechSha:

; 3340 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getTechShareCount@CvTeam@@QBEHH@Z ENDP			; CvTeam::getTechShareCount
_TEXT	ENDS
PUBLIC	?isTechShare@CvTeam@@QBE_NH@Z			; CvTeam::isTechShare
; Function compile flags: /Odtp
;	COMDAT ?isTechShare@CvTeam@@QBE_NH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
?isTechShare@CvTeam@@QBE_NH@Z PROC			; CvTeam::isTechShare, COMDAT
; _this$ = ecx

; 3345 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3346 : 	return (getTechShareCount(iIndex) > 0);

	mov	eax, DWORD PTR _iIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getTechShareCount@CvTeam@@QBEHH@Z	; CvTeam::getTechShareCount
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	mov	al, cl

; 3347 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isTechShare@CvTeam@@QBE_NH@Z ENDP			; CvTeam::isTechShare
_TEXT	ENDS
PUBLIC	?updateTechShare@CvTeam@@IAEXXZ			; CvTeam::updateTechShare
; Function compile flags: /Odtp
;	COMDAT ?changeTechShareCount@CvTeam@@QAEXHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?changeTechShareCount@CvTeam@@QAEXHH@Z PROC		; CvTeam::changeTechShareCount, COMDAT
; _this$ = ecx

; 3352 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3353 : 	CvAssertMsg(iIndex >= 0, "iIndex is expected to be non-negative (invalid Index)");
; 3354 : 	CvAssertMsg(iIndex < MAX_TEAMS, "iIndex is expected to be within maximum bounds (invalid Index)");
; 3355 : 	if(iIndex < 0 || iIndex >= MAX_TEAMS) return;

	cmp	DWORD PTR _iIndex$[ebp], 0
	jl	SHORT $LN3@changeTech
	cmp	DWORD PTR _iIndex$[ebp], 64		; 00000040H
	jl	SHORT $LN4@changeTech
$LN3@changeTech:
	jmp	SHORT $LN5@changeTech
$LN4@changeTech:

; 3356 : 	if(iChange != 0)

	cmp	DWORD PTR _iChange$[ebp], 0
	je	SHORT $LN5@changeTech

; 3357 : 	{
; 3358 : 		m_aiTechShareCount[iIndex] = (m_aiTechShareCount[iIndex] + iChange);

	mov	eax, DWORD PTR _iIndex$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+148]
	add	edx, DWORD PTR _iChange$[ebp]
	mov	eax, DWORD PTR _iIndex$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+148], edx

; 3359 : 		CvAssert(getTechShareCount(iIndex) >= 0);
; 3360 : 
; 3361 : 		if(isTechShare(iIndex))

	mov	edx, DWORD PTR _iIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isTechShare@CvTeam@@QBE_NH@Z		; CvTeam::isTechShare
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@changeTech

; 3362 : 		{
; 3363 : 			updateTechShare();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateTechShare@CvTeam@@IAEXXZ		; CvTeam::updateTechShare
$LN5@changeTech:

; 3364 : 		}
; 3365 : 	}
; 3366 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?changeTechShareCount@CvTeam@@QAEXHH@Z ENDP		; CvTeam::changeTechShareCount
_TEXT	ENDS
PUBLIC	?getExtraMoves@CvTeam@@QBEHW4DomainTypes@@@Z	; CvTeam::getExtraMoves
; Function compile flags: /Odtp
;	COMDAT ?getExtraMoves@CvTeam@@QBEHW4DomainTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?getExtraMoves@CvTeam@@QBEHW4DomainTypes@@@Z PROC	; CvTeam::getExtraMoves, COMDAT
; _this$ = ecx

; 3371 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3372 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 3373 : 	CvAssertMsg(eIndex < NUM_DOMAIN_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
; 3374 : 	return m_aiExtraMoves[eIndex];

	mov	eax, DWORD PTR _eIndex$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4+1108]

; 3375 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getExtraMoves@CvTeam@@QBEHW4DomainTypes@@@Z ENDP	; CvTeam::getExtraMoves
_TEXT	ENDS
PUBLIC	?changeExtraMoves@CvTeam@@QAEXW4DomainTypes@@H@Z ; CvTeam::changeExtraMoves
; Function compile flags: /Odtp
;	COMDAT ?changeExtraMoves@CvTeam@@QAEXW4DomainTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?changeExtraMoves@CvTeam@@QAEXW4DomainTypes@@H@Z PROC	; CvTeam::changeExtraMoves, COMDAT
; _this$ = ecx

; 3380 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3381 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 3382 : 	CvAssertMsg(eIndex < NUM_DOMAIN_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
; 3383 : 	m_aiExtraMoves[eIndex] = (m_aiExtraMoves[eIndex] + iChange);

	mov	eax, DWORD PTR _eIndex$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+1108]
	add	edx, DWORD PTR _iChange$[ebp]
	mov	eax, DWORD PTR _eIndex$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+1108], edx

; 3384 : 	CvAssert(getExtraMoves(eIndex) >= 0);
; 3385 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?changeExtraMoves@CvTeam@@QAEXW4DomainTypes@@H@Z ENDP	; CvTeam::changeExtraMoves
_TEXT	ENDS
PUBLIC	?canEmbark@CvTeam@@QBE_NXZ			; CvTeam::canEmbark
; Function compile flags: /Odtp
;	COMDAT ?canEmbark@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?canEmbark@CvTeam@@QBE_NXZ PROC				; CvTeam::canEmbark, COMDAT
; _this$ = ecx

; 3390 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3391 : 	return m_iCanEmbarkCount > 0 ? true : false;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+104], 0
	setg	al

; 3392 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?canEmbark@CvTeam@@QBE_NXZ ENDP				; CvTeam::canEmbark
_TEXT	ENDS
PUBLIC	?getCanEmbarkCount@CvTeam@@QBEHXZ		; CvTeam::getCanEmbarkCount
; Function compile flags: /Odtp
;	COMDAT ?getCanEmbarkCount@CvTeam@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCanEmbarkCount@CvTeam@@QBEHXZ PROC			; CvTeam::getCanEmbarkCount, COMDAT
; _this$ = ecx

; 3396 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3397 : 	return m_iCanEmbarkCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+104]

; 3398 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getCanEmbarkCount@CvTeam@@QBEHXZ ENDP			; CvTeam::getCanEmbarkCount
_TEXT	ENDS
PUBLIC	?changeCanEmbarkCount@CvTeam@@QAEXH@Z		; CvTeam::changeCanEmbarkCount
EXTRN	?setHasPromotion@CvUnit@@QAEXW4PromotionTypes@@_N@Z:PROC ; CvUnit::setHasPromotion
EXTRN	?IsPromotionValidForUnitCombatType@@YA_NW4PromotionTypes@@W4UnitTypes@@@Z:PROC ; IsPromotionValidForUnitCombatType
EXTRN	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ:PROC	; CvUnit::getUnitType
EXTRN	?GetEmbarkationPromotion@CvPlayer@@QBE?AW4PromotionTypes@@XZ:PROC ; CvPlayer::GetEmbarkationPromotion
EXTRN	?IsFriendlyTerritory@CvPlot@@QBE_NW4PlayerTypes@@@Z:PROC ; CvPlot::IsFriendlyTerritory
EXTRN	?plot@CvUnit@@QBEPAVCvPlot@@XZ:PROC		; CvUnit::plot
EXTRN	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ:PROC ; CvUnit::getDomainType
EXTRN	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::nextUnit
EXTRN	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::firstUnit
; Function compile flags: /Odtp
;	COMDAT ?changeCanEmbarkCount@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T234759 = -44						; size = 4
$T234755 = -40						; size = 4
$T234751 = -36						; size = 4
$T234747 = -32						; size = 4
$T234738 = -28						; size = 4
$T234734 = -21						; size = 1
$T234725 = -20						; size = 4
_ePromotionEmbarkation$224550 = -16			; size = 4
_iI$224535 = -12					; size = 4
_pLoopUnit$224534 = -8					; size = 4
_iLoop$224533 = -4					; size = 4
_iChange$ = 8						; size = 4
?changeCanEmbarkCount@CvTeam@@QAEXH@Z PROC		; CvTeam::changeCanEmbarkCount, COMDAT
; _this$ = ecx

; 3402 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 3403 : 	if(iChange != 0)

	cmp	DWORD PTR _iChange$[ebp], 0
	je	$LN14@changeCanE

; 3404 : 	{
; 3405 : 		m_iCanEmbarkCount += iChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+104], ecx

; 3406 : 
; 3407 : 		if(canEmbark())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?canEmbark@CvTeam@@QBE_NXZ		; CvTeam::canEmbark
	movzx	eax, al
	test	eax, eax
	je	$LN14@changeCanE

; 3408 : 		{
; 3409 : 			int iLoop;
; 3410 : 			CvUnit* pLoopUnit;
; 3411 : 
; 3412 : 			// Give embarkation promotion to all civilians, because they have no way to earn it later
; 3413 : 			for(int iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$224535[ebp], 0
	jmp	SHORT $LN11@changeCanE
$LN10@changeCanE:
	mov	ecx, DWORD PTR _iI$224535[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$224535[ebp], ecx
$LN11@changeCanE:
	cmp	DWORD PTR _iI$224535[ebp], 64		; 00000040H
	jge	$LN14@changeCanE

; 3414 : 			{
; 3415 : 				if(GET_PLAYER((PlayerTypes)iI).isAlive() && GET_PLAYER((PlayerTypes)iI).getTeam() == GetID())

	mov	edx, DWORD PTR _iI$224535[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T234725[ebp], edx
	mov	eax, DWORD PTR $T234725[ebp]
	mov	cl, BYTE PTR [eax+2256]
	mov	BYTE PTR $T234734[ebp], cl
	movzx	edx, BYTE PTR $T234734[ebp]
	test	edx, edx
	je	$LN8@changeCanE
	mov	eax, DWORD PTR _iI$224535[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T234738[ebp], eax
	mov	ecx, DWORD PTR $T234738[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T234747[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T234747[ebp], eax
	jne	$LN8@changeCanE

; 3416 : 				{
; 3417 : 					for(pLoopUnit = GET_PLAYER((PlayerTypes)iI).firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = GET_PLAYER((PlayerTypes)iI).nextUnit(&iLoop))

	mov	eax, DWORD PTR _iI$224535[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T234751[ebp], eax
	push	0
	lea	ecx, DWORD PTR _iLoop$224533[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T234751[ebp]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$224534[ebp], eax
	jmp	SHORT $LN7@changeCanE
$LN6@changeCanE:
	mov	edx, DWORD PTR _iI$224535[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T234755[ebp], edx
	push	0
	lea	eax, DWORD PTR _iLoop$224533[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234755[ebp]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$224534[ebp], eax
$LN7@changeCanE:
	cmp	DWORD PTR _pLoopUnit$224534[ebp], 0
	je	$LN8@changeCanE

; 3418 : 					{
; 3419 : 						// Land Unit
; 3420 : 						if(pLoopUnit->getDomainType() == DOMAIN_LAND)

	mov	ecx, DWORD PTR _pLoopUnit$224534[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN4@changeCanE

; 3421 : 						{
; 3422 : 							// If we're in friendly territory and we can embark, give the promotion for free
; 3423 : 							if(pLoopUnit->plot()->IsFriendlyTerritory((PlayerTypes)iI))

	mov	ecx, DWORD PTR _iI$224535[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopUnit$224534[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, eax
	call	?IsFriendlyTerritory@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::IsFriendlyTerritory
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN4@changeCanE

; 3424 : 							{
; 3425 : 								// Civilian unit or the unit can acquire this promotion
; 3426 : 								PromotionTypes ePromotionEmbarkation = GET_PLAYER((PlayerTypes)iI).GetEmbarkationPromotion();

	mov	eax, DWORD PTR _iI$224535[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T234759[ebp], eax
	mov	ecx, DWORD PTR $T234759[ebp]
	call	?GetEmbarkationPromotion@CvPlayer@@QBE?AW4PromotionTypes@@XZ ; CvPlayer::GetEmbarkationPromotion
	mov	DWORD PTR _ePromotionEmbarkation$224550[ebp], eax

; 3427 : 								if(!pLoopUnit->IsCombatUnit() || ::IsPromotionValidForUnitCombatType(ePromotionEmbarkation, pLoopUnit->getUnitType()))

	mov	ecx, DWORD PTR _pLoopUnit$224534[ebp]
	xor	edx, edx
	cmp	DWORD PTR [ecx+1044], 0
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN1@changeCanE
	mov	ecx, DWORD PTR _pLoopUnit$224534[ebp]
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, DWORD PTR _ePromotionEmbarkation$224550[ebp]
	push	ecx
	call	?IsPromotionValidForUnitCombatType@@YA_NW4PromotionTypes@@W4UnitTypes@@@Z ; IsPromotionValidForUnitCombatType
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN4@changeCanE
$LN1@changeCanE:

; 3428 : 								{
; 3429 : 									pLoopUnit->setHasPromotion(ePromotionEmbarkation, true);

	push	1
	mov	eax, DWORD PTR _ePromotionEmbarkation$224550[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopUnit$224534[ebp]
	call	?setHasPromotion@CvUnit@@QAEXW4PromotionTypes@@_N@Z ; CvUnit::setHasPromotion
$LN4@changeCanE:

; 3430 : 								}
; 3431 : 									
; 3432 : 							}
; 3433 : 						}
; 3434 : 					}

	jmp	$LN6@changeCanE
$LN8@changeCanE:

; 3435 : 				}
; 3436 : 			}

	jmp	$LN10@changeCanE
$LN14@changeCanE:

; 3437 : 		}
; 3438 : 	}
; 3439 : 
; 3440 : 	CvAssert(getCanEmbarkCount() >= 0);
; 3441 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?changeCanEmbarkCount@CvTeam@@QAEXH@Z ENDP		; CvTeam::changeCanEmbarkCount
_TEXT	ENDS
PUBLIC	?canDefensiveEmbark@CvTeam@@QBE_NXZ		; CvTeam::canDefensiveEmbark
; Function compile flags: /Odtp
;	COMDAT ?canDefensiveEmbark@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?canDefensiveEmbark@CvTeam@@QBE_NXZ PROC		; CvTeam::canDefensiveEmbark, COMDAT
; _this$ = ecx

; 3450 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3451 : 	return m_iDefensiveEmbarkCount > 0 ? true : false;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+108], 0
	setg	al

; 3452 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?canDefensiveEmbark@CvTeam@@QBE_NXZ ENDP		; CvTeam::canDefensiveEmbark
_TEXT	ENDS
PUBLIC	?getDefensiveEmbarkCount@CvTeam@@QBEHXZ		; CvTeam::getDefensiveEmbarkCount
; Function compile flags: /Odtp
;	COMDAT ?getDefensiveEmbarkCount@CvTeam@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getDefensiveEmbarkCount@CvTeam@@QBEHXZ PROC		; CvTeam::getDefensiveEmbarkCount, COMDAT
; _this$ = ecx

; 3456 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3457 : 	return m_iDefensiveEmbarkCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+108]

; 3458 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getDefensiveEmbarkCount@CvTeam@@QBEHXZ ENDP		; CvTeam::getDefensiveEmbarkCount
_TEXT	ENDS
PUBLIC	?changeDefensiveEmbarkCount@CvTeam@@QAEXH@Z	; CvTeam::changeDefensiveEmbarkCount
EXTRN	?isHasPromotion@CvUnit@@QBE_NW4PromotionTypes@@@Z:PROC ; CvUnit::isHasPromotion
; Function compile flags: /Odtp
;	COMDAT ?changeDefensiveEmbarkCount@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -64						; size = 4
$T234827 = -60						; size = 4
$T234823 = -56						; size = 4
$T234819 = -52						; size = 4
$T234815 = -48						; size = 4
$T234811 = -44						; size = 4
$T234807 = -40						; size = 4
$T234803 = -36						; size = 4
$T234799 = -32						; size = 4
$T234790 = -28						; size = 4
$T234786 = -21						; size = 1
$T234777 = -20						; size = 4
_ePromotionDefensiveEmbarkation$224575 = -16		; size = 4
_iI$224568 = -12					; size = 4
_pLoopUnit$224567 = -8					; size = 4
_iLoop$224566 = -4					; size = 4
_iChange$ = 8						; size = 4
?changeDefensiveEmbarkCount@CvTeam@@QAEXH@Z PROC	; CvTeam::changeDefensiveEmbarkCount, COMDAT
; _this$ = ecx

; 3462 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 3463 : 	if(iChange != 0)

	cmp	DWORD PTR _iChange$[ebp], 0
	je	$LN13@changeDefe

; 3464 : 	{
; 3465 : 		m_iDefensiveEmbarkCount += iChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+108], ecx

; 3466 : 
; 3467 : 		if(canDefensiveEmbark())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?canDefensiveEmbark@CvTeam@@QBE_NXZ	; CvTeam::canDefensiveEmbark
	movzx	eax, al
	test	eax, eax
	je	$LN13@changeDefe

; 3468 : 		{
; 3469 : 			int iLoop;
; 3470 : 			CvUnit* pLoopUnit;
; 3471 : 
; 3472 : 			// Give embarkation promotion to all units who can currently embark
; 3473 : 			for(int iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$224568[ebp], 0
	jmp	SHORT $LN10@changeDefe
$LN9@changeDefe:
	mov	ecx, DWORD PTR _iI$224568[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$224568[ebp], ecx
$LN10@changeDefe:
	cmp	DWORD PTR _iI$224568[ebp], 64		; 00000040H
	jge	$LN13@changeDefe

; 3474 : 			{
; 3475 : 				if(GET_PLAYER((PlayerTypes)iI).isAlive() && GET_PLAYER((PlayerTypes)iI).getTeam() == GetID())

	mov	edx, DWORD PTR _iI$224568[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T234777[ebp], edx
	mov	eax, DWORD PTR $T234777[ebp]
	mov	cl, BYTE PTR [eax+2256]
	mov	BYTE PTR $T234786[ebp], cl
	movzx	edx, BYTE PTR $T234786[ebp]
	test	edx, edx
	je	$LN7@changeDefe
	mov	eax, DWORD PTR _iI$224568[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T234790[ebp], eax
	mov	ecx, DWORD PTR $T234790[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T234799[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T234799[ebp], eax
	jne	$LN7@changeDefe

; 3476 : 				{
; 3477 : 					PromotionTypes ePromotionDefensiveEmbarkation = GET_PLAYER((PlayerTypes)iI).GetEmbarkationPromotion();

	mov	eax, DWORD PTR _iI$224568[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T234803[ebp], eax
	mov	ecx, DWORD PTR $T234803[ebp]
	call	?GetEmbarkationPromotion@CvPlayer@@QBE?AW4PromotionTypes@@XZ ; CvPlayer::GetEmbarkationPromotion
	mov	DWORD PTR _ePromotionDefensiveEmbarkation$224575[ebp], eax

; 3478 : 
; 3479 : 					for(pLoopUnit = GET_PLAYER((PlayerTypes)iI).firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = GET_PLAYER((PlayerTypes)iI).nextUnit(&iLoop))

	mov	ecx, DWORD PTR _iI$224568[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T234807[ebp], ecx
	push	0
	lea	edx, DWORD PTR _iLoop$224566[ebp]
	push	edx
	mov	ecx, DWORD PTR $T234807[ebp]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$224567[ebp], eax
	jmp	SHORT $LN6@changeDefe
$LN5@changeDefe:
	mov	eax, DWORD PTR _iI$224568[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T234811[ebp], eax
	push	0
	lea	ecx, DWORD PTR _iLoop$224566[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T234811[ebp]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$224567[ebp], eax
$LN6@changeDefe:
	cmp	DWORD PTR _pLoopUnit$224567[ebp], 0
	je	$LN7@changeDefe

; 3480 : 					{
; 3481 : 						// Land Unit
; 3482 : 						if(pLoopUnit->getDomainType() == DOMAIN_LAND)

	mov	ecx, DWORD PTR _pLoopUnit$224567[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	$LN3@changeDefe

; 3483 : 						{
; 3484 : 							// Take away old promotion and give the new one instead
; 3485 : 							if(pLoopUnit->isHasPromotion((PromotionTypes)GC.getPROMOTION_EMBARKATION()))

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8524
	mov	DWORD PTR $T234815[ebp], edx
	mov	eax, DWORD PTR $T234815[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopUnit$224567[ebp]
	call	?isHasPromotion@CvUnit@@QBE_NW4PromotionTypes@@@Z ; CvUnit::isHasPromotion
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@changeDefe

; 3486 : 							{
; 3487 : 								pLoopUnit->setHasPromotion((PromotionTypes)GC.getPROMOTION_EMBARKATION(), false);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8524
	mov	DWORD PTR $T234819[ebp], edx
	push	0
	mov	eax, DWORD PTR $T234819[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopUnit$224567[ebp]
	call	?setHasPromotion@CvUnit@@QAEXW4PromotionTypes@@_N@Z ; CvUnit::setHasPromotion

; 3488 : 								pLoopUnit->setHasPromotion(ePromotionDefensiveEmbarkation, true);

	push	1
	mov	ecx, DWORD PTR _ePromotionDefensiveEmbarkation$224575[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopUnit$224567[ebp]
	call	?setHasPromotion@CvUnit@@QAEXW4PromotionTypes@@_N@Z ; CvUnit::setHasPromotion
$LN2@changeDefe:

; 3489 : 							}
; 3490 : 							// Could be cleaner if add "allwater defensive promotion".  Luckily for now the only way you can get
; 3491 : 							// both is in the Polynesia scenario and this works for that
; 3492 : 							if(pLoopUnit->isHasPromotion((PromotionTypes)GC.getPROMOTION_ALLWATER_EMBARKATION()))

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8532
	mov	DWORD PTR $T234823[ebp], edx
	mov	eax, DWORD PTR $T234823[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopUnit$224567[ebp]
	call	?isHasPromotion@CvUnit@@QBE_NW4PromotionTypes@@@Z ; CvUnit::isHasPromotion
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@changeDefe

; 3493 : 							{
; 3494 : 								pLoopUnit->setHasPromotion((PromotionTypes)GC.getPROMOTION_ALLWATER_EMBARKATION(), false);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8532
	mov	DWORD PTR $T234827[ebp], edx
	push	0
	mov	eax, DWORD PTR $T234827[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopUnit$224567[ebp]
	call	?setHasPromotion@CvUnit@@QAEXW4PromotionTypes@@_N@Z ; CvUnit::setHasPromotion

; 3495 : 								pLoopUnit->setHasPromotion(ePromotionDefensiveEmbarkation, true);

	push	1
	mov	ecx, DWORD PTR _ePromotionDefensiveEmbarkation$224575[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopUnit$224567[ebp]
	call	?setHasPromotion@CvUnit@@QAEXW4PromotionTypes@@_N@Z ; CvUnit::setHasPromotion
$LN3@changeDefe:

; 3496 : 							}
; 3497 : 						}
; 3498 : 					}

	jmp	$LN5@changeDefe
$LN7@changeDefe:

; 3499 : 				}
; 3500 : 			}

	jmp	$LN9@changeDefe
$LN13@changeDefe:

; 3501 : 		}
; 3502 : 	}
; 3503 : 	CvAssert(getDefensiveEmbarkCount() >= 0);
; 3504 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?changeDefensiveEmbarkCount@CvTeam@@QAEXH@Z ENDP	; CvTeam::changeDefensiveEmbarkCount
_TEXT	ENDS
PUBLIC	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ		; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
PUBLIC	?UpdateEmbarkGraphics@CvTeam@@QAEXXZ		; CvTeam::UpdateEmbarkGraphics
EXTRN	??3CvDllUnit@@SAXPAX@Z:PROC			; CvDllUnit::operator delete
EXTRN	??0CvDllUnit@@QAE@PAVCvUnit@@@Z:PROC		; CvDllUnit::CvDllUnit
EXTRN	??2CvDllUnit@@SAPAXI@Z:PROC			; CvDllUnit::operator new
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
xdata$x	SEGMENT
__unwindtable$?UpdateEmbarkGraphics@CvTeam@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdateEmbarkGraphics@CvTeam@@QAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdateEmbarkGraphics@CvTeam@@QAEXXZ$1
__ehfuncinfo$?UpdateEmbarkGraphics@CvTeam@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?UpdateEmbarkGraphics@CvTeam@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?UpdateEmbarkGraphics@CvTeam@@QAEXXZ
_TEXT	SEGMENT
tv164 = -76						; size = 4
tv154 = -72						; size = 4
_this$ = -68						; size = 4
_inst$234888 = -64					; size = 4
$T234884 = -60						; size = 4
$T234872 = -56						; size = 4
$T234865 = -49						; size = 1
$T234856 = -48						; size = 4
$T234847 = -41						; size = 1
$T234831 = -40						; size = 4
$T234830 = -36						; size = 4
_pDllUnit$224657 = -32					; size = 4
_pLoopUnit$224600 = -28					; size = 4
_iLoop$224599 = -24					; size = 4
_kPlayer$224596 = -20					; size = 4
_iI$224592 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?UpdateEmbarkGraphics@CvTeam@@QAEXXZ PROC		; CvTeam::UpdateEmbarkGraphics, COMDAT
; _this$ = ecx

; 3508 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?UpdateEmbarkGraphics@CvTeam@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3509 : 	for(int iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$224592[ebp], 0
	jmp	SHORT $LN9@UpdateEmba
$LN8@UpdateEmba:
	mov	eax, DWORD PTR _iI$224592[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$224592[ebp], eax
$LN9@UpdateEmba:
	cmp	DWORD PTR _iI$224592[ebp], 64		; 00000040H
	jge	$LN10@UpdateEmba

; 3510 : 	{
; 3511 : 		CvPlayerAI& kPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	ecx, DWORD PTR _iI$224592[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$224596[ebp], ecx

; 3512 : 		if(kPlayer.isAlive() && kPlayer.getTeam() == GetID())

	mov	edx, DWORD PTR _kPlayer$224596[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T234847[ebp], al
	movzx	ecx, BYTE PTR $T234847[ebp]
	test	ecx, ecx
	je	$LN6@UpdateEmba
	mov	edx, DWORD PTR _kPlayer$224596[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T234856[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T234856[ebp], eax
	jne	$LN6@UpdateEmba

; 3513 : 		{
; 3514 : 			int iLoop;
; 3515 : 			for(CvUnit* pLoopUnit = kPlayer.firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = kPlayer.nextUnit(&iLoop))

	push	0
	lea	ecx, DWORD PTR _iLoop$224599[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kPlayer$224596[ebp]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$224600[ebp], eax
	jmp	SHORT $LN5@UpdateEmba
$LN4@UpdateEmba:
	push	0
	lea	edx, DWORD PTR _iLoop$224599[ebp]
	push	edx
	mov	ecx, DWORD PTR _kPlayer$224596[ebp]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$224600[ebp], eax
$LN5@UpdateEmba:
	cmp	DWORD PTR _pLoopUnit$224600[ebp], 0
	je	$LN6@UpdateEmba

; 3516 : 			{
; 3517 : 				// Land Unit
; 3518 : 				if(pLoopUnit->getDomainType() == DOMAIN_LAND)

	mov	ecx, DWORD PTR _pLoopUnit$224600[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	$LN2@UpdateEmba

; 3519 : 				{
; 3520 : 					// At sea so its graphic look needs to change too?
; 3521 : 					if(pLoopUnit->isEmbarked())

	mov	eax, DWORD PTR _pLoopUnit$224600[ebp]
	mov	cl, BYTE PTR [eax+1652]
	mov	BYTE PTR $T234865[ebp], cl
	movzx	edx, BYTE PTR $T234865[ebp]
	test	edx, edx
	je	$LN2@UpdateEmba

; 3522 : 					{
; 3523 : 						auto_ptr<ICvUnit1> pDllUnit(new CvDllUnit(pLoopUnit));

	push	12					; 0000000cH
	call	??2CvDllUnit@@SAPAXI@Z			; CvDllUnit::operator new
	add	esp, 4
	mov	DWORD PTR $T234831[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T234831[ebp], 0
	je	SHORT $LN12@UpdateEmba
	mov	eax, DWORD PTR _pLoopUnit$224600[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234831[ebp]
	call	??0CvDllUnit@@QAE@PAVCvUnit@@@Z		; CvDllUnit::CvDllUnit
	mov	DWORD PTR tv154[ebp], eax
	jmp	SHORT $LN13@UpdateEmba
$LN12@UpdateEmba:
	mov	DWORD PTR tv154[ebp], 0
$LN13@UpdateEmba:
	mov	ecx, DWORD PTR tv154[ebp]
	mov	DWORD PTR $T234830[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T234830[ebp]
	mov	DWORD PTR _pDllUnit$224657[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 3524 : 						gDLL->GameplayUnitEmbark(pDllUnit.get(), true);

	mov	eax, DWORD PTR $T234872[ebp]
	mov	DWORD PTR tv164[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv164[ebp], ecx
	push	1
	mov	edx, DWORD PTR _pDllUnit$224657[ebp]
	push	edx
	mov	eax, DWORD PTR tv164[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv164[ebp]
	mov	eax, DWORD PTR [edx+624]
	call	eax

; 3525 : 					}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _pDllUnit$224657[ebp]
	mov	DWORD PTR $T234884[ebp], ecx
	cmp	DWORD PTR $T234884[ebp], 0
	je	SHORT $LN2@UpdateEmba
	mov	edx, DWORD PTR $T234884[ebp]
	mov	DWORD PTR _inst$234888[ebp], edx
	mov	eax, DWORD PTR _inst$234888[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _inst$234888[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+4]
	call	eax
$LN2@UpdateEmba:

; 3526 : 				}

	jmp	$LN4@UpdateEmba
$LN6@UpdateEmba:

; 3527 : 			}

	jmp	$LN8@UpdateEmba
$LN10@UpdateEmba:

; 3528 : 		}
; 3529 : 	}
; 3530 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?UpdateEmbarkGraphics@CvTeam@@QAEXXZ$0:
	mov	eax, DWORD PTR $T234831[ebp]
	push	eax
	call	??3CvDllUnit@@SAXPAX@Z			; CvDllUnit::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?UpdateEmbarkGraphics@CvTeam@@QAEXXZ$1:
	lea	ecx, DWORD PTR _pDllUnit$224657[ebp]
	jmp	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ	; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
__ehhandler$?UpdateEmbarkGraphics@CvTeam@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-68]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?UpdateEmbarkGraphics@CvTeam@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?UpdateEmbarkGraphics@CvTeam@@QAEXXZ ENDP		; CvTeam::UpdateEmbarkGraphics
PUBLIC	?canEmbarkAllWaterPassage@CvTeam@@QBE_NXZ	; CvTeam::canEmbarkAllWaterPassage
; Function compile flags: /Odtp
;	COMDAT ?canEmbarkAllWaterPassage@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?canEmbarkAllWaterPassage@CvTeam@@QBE_NXZ PROC		; CvTeam::canEmbarkAllWaterPassage, COMDAT
; _this$ = ecx

; 3534 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3535 : 	return m_iEmbarkedAllWaterPassageCount > 0 ? true : false;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+112], 0
	setg	al

; 3536 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?canEmbarkAllWaterPassage@CvTeam@@QBE_NXZ ENDP		; CvTeam::canEmbarkAllWaterPassage
_TEXT	ENDS
PUBLIC	?getEmbarkedAllWaterPassage@CvTeam@@QBEHXZ	; CvTeam::getEmbarkedAllWaterPassage
; Function compile flags: /Odtp
;	COMDAT ?getEmbarkedAllWaterPassage@CvTeam@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getEmbarkedAllWaterPassage@CvTeam@@QBEHXZ PROC		; CvTeam::getEmbarkedAllWaterPassage, COMDAT
; _this$ = ecx

; 3540 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3541 : 	return m_iEmbarkedAllWaterPassageCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+112]

; 3542 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getEmbarkedAllWaterPassage@CvTeam@@QBEHXZ ENDP		; CvTeam::getEmbarkedAllWaterPassage
_TEXT	ENDS
PUBLIC	?changeEmbarkedAllWaterPassage@CvTeam@@QAEXH@Z	; CvTeam::changeEmbarkedAllWaterPassage
; Function compile flags: /Odtp
;	COMDAT ?changeEmbarkedAllWaterPassage@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?changeEmbarkedAllWaterPassage@CvTeam@@QAEXH@Z PROC	; CvTeam::changeEmbarkedAllWaterPassage, COMDAT
; _this$ = ecx

; 3546 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3547 : 	if(iChange != 0)

	cmp	DWORD PTR _iChange$[ebp], 0
	je	SHORT $LN2@changeEmba

; 3548 : 	{
; 3549 : 		m_iEmbarkedAllWaterPassageCount += iChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+112], ecx
$LN2@changeEmba:

; 3550 : 	}
; 3551 : 	CvAssert(getEmbarkedAllWaterPassage() >= 0);
; 3552 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?changeEmbarkedAllWaterPassage@CvTeam@@QAEXH@Z ENDP	; CvTeam::changeEmbarkedAllWaterPassage
_TEXT	ENDS
PUBLIC	?GetNumNaturalWondersDiscovered@CvTeam@@QBEHXZ	; CvTeam::GetNumNaturalWondersDiscovered
; Function compile flags: /Odtp
;	COMDAT ?GetNumNaturalWondersDiscovered@CvTeam@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumNaturalWondersDiscovered@CvTeam@@QBEHXZ PROC	; CvTeam::GetNumNaturalWondersDiscovered, COMDAT
; _this$ = ecx

; 3556 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3557 : 	return m_iNumNaturalWondersDiscovered;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+116]

; 3558 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumNaturalWondersDiscovered@CvTeam@@QBEHXZ ENDP	; CvTeam::GetNumNaturalWondersDiscovered
_TEXT	ENDS
PUBLIC	?ChangeNumNaturalWondersDiscovered@CvTeam@@QAEXH@Z ; CvTeam::ChangeNumNaturalWondersDiscovered
; Function compile flags: /Odtp
;	COMDAT ?ChangeNumNaturalWondersDiscovered@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?ChangeNumNaturalWondersDiscovered@CvTeam@@QAEXH@Z PROC	; CvTeam::ChangeNumNaturalWondersDiscovered, COMDAT
; _this$ = ecx

; 3562 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3563 : 	if(iChange != 0)

	cmp	DWORD PTR _iChange$[ebp], 0
	je	SHORT $LN2@ChangeNumN

; 3564 : 	{
; 3565 : 		m_iNumNaturalWondersDiscovered += iChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+116], ecx
$LN2@ChangeNumN:

; 3566 : 	}
; 3567 : 	CvAssert(GetNumNaturalWondersDiscovered() >= 0);
; 3568 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ChangeNumNaturalWondersDiscovered@CvTeam@@QAEXH@Z ENDP	; CvTeam::ChangeNumNaturalWondersDiscovered
_TEXT	ENDS
PUBLIC	?getEmbarkedExtraMoves@CvTeam@@QBEHXZ		; CvTeam::getEmbarkedExtraMoves
; Function compile flags: /Odtp
;	COMDAT ?getEmbarkedExtraMoves@CvTeam@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getEmbarkedExtraMoves@CvTeam@@QBEHXZ PROC		; CvTeam::getEmbarkedExtraMoves, COMDAT
; _this$ = ecx

; 3573 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3574 : 	return m_iEmbarkedExtraMoves;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+96]

; 3575 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getEmbarkedExtraMoves@CvTeam@@QBEHXZ ENDP		; CvTeam::getEmbarkedExtraMoves
_TEXT	ENDS
PUBLIC	?changeEmbarkedExtraMoves@CvTeam@@QAEXH@Z	; CvTeam::changeEmbarkedExtraMoves
; Function compile flags: /Odtp
;	COMDAT ?changeEmbarkedExtraMoves@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?changeEmbarkedExtraMoves@CvTeam@@QAEXH@Z PROC		; CvTeam::changeEmbarkedExtraMoves, COMDAT
; _this$ = ecx

; 3579 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3580 : 	m_iEmbarkedExtraMoves = (m_iEmbarkedExtraMoves + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+96], ecx

; 3581 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?changeEmbarkedExtraMoves@CvTeam@@QAEXH@Z ENDP		; CvTeam::changeEmbarkedExtraMoves
_TEXT	ENDS
PUBLIC	?getEmbarkedExtraSight@CvTeam@@QBEHXZ		; CvTeam::getEmbarkedExtraSight
; Function compile flags: /Odtp
;	COMDAT ?getEmbarkedExtraSight@CvTeam@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getEmbarkedExtraSight@CvTeam@@QBEHXZ PROC		; CvTeam::getEmbarkedExtraSight, COMDAT
; _this$ = ecx

; 3586 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3587 : 	return m_iEmbarkedExtraSight;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+100]

; 3588 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getEmbarkedExtraSight@CvTeam@@QBEHXZ ENDP		; CvTeam::getEmbarkedExtraSight
_TEXT	ENDS
PUBLIC	?changeEmbarkedExtraSight@CvTeam@@QAEXH@Z	; CvTeam::changeEmbarkedExtraSight
; Function compile flags: /Odtp
;	COMDAT ?changeEmbarkedExtraSight@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?changeEmbarkedExtraSight@CvTeam@@QAEXH@Z PROC		; CvTeam::changeEmbarkedExtraSight, COMDAT
; _this$ = ecx

; 3593 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3594 : 	m_iEmbarkedExtraSight = (m_iEmbarkedExtraSight + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+100], ecx

; 3595 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?changeEmbarkedExtraSight@CvTeam@@QAEXH@Z ENDP		; CvTeam::changeEmbarkedExtraSight
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z PROC		; CvTeam::isHasMet, COMDAT
; _this$ = ecx

; 3600 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3601 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 3602 : 	CvAssertMsg(eIndex < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 3603 : 	return m_abHasMet[eIndex];

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _eIndex$[ebp]
	mov	al, BYTE PTR [eax+1848]

; 3604 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z ENDP		; CvTeam::isHasMet
_TEXT	ENDS
PUBLIC	?AddNotification@CvTeam@@QAEXW4NotificationTypes@@PBD1HHHH@Z ; CvTeam::AddNotification
PUBLIC	??_C@_0CL@EBOJENKG@TXT_KEY_NOTIFICATION_SUMMARY_MET@ ; `string'
PUBLIC	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z	; GetLocalizedText<char const *>
PUBLIC	??_C@_0CD@GAIHIHBJ@TXT_KEY_NOTIFICATION_MET_MINOR_C@ ; `string'
PUBLIC	?SetTurnTeamMet@CvTeam@@QAEXW4TeamTypes@@H@Z	; CvTeam::SetTurnTeamMet
PUBLIC	__$ArrayPad$
EXTRN	?DoFirstContactWithMajor@CvMinorCivAI@@QAEXW4TeamTypes@@_N@Z:PROC ; CvMinorCivAI::DoFirstContactWithMajor
EXTRN	?updateDeferredFog@CvMap@@QAEXXZ:PROC		; CvMap::updateDeferredFog
EXTRN	?plot@CvCity@@QBEPAVCvPlot@@XZ:PROC		; CvCity::plot
EXTRN	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ:PROC	; CvPlayer::getCapitalCity
EXTRN	?clearResearchQueue@CvPlayer@@QAEXXZ:PROC	; CvPlayer::clearResearchQueue
EXTRN	?DoPlayerMetSomeone@CvDiplomacyAI@@QAEXW4PlayerTypes@@0@Z:PROC ; CvDiplomacyAI::DoPlayerMetSomeone
EXTRN	?DoFirstContact@CvDiplomacyAI@@QAEXW4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::DoFirstContact
EXTRN	?DoUpdateProximityToPlayer@CvPlayer@@QAEXW4PlayerTypes@@@Z:PROC ; CvPlayer::DoUpdateProximityToPlayer
EXTRN	?getGameTurn@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurn
;	COMDAT ??_C@_0CL@EBOJENKG@TXT_KEY_NOTIFICATION_SUMMARY_MET@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
CONST	SEGMENT
??_C@_0CL@EBOJENKG@TXT_KEY_NOTIFICATION_SUMMARY_MET@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_SUMMARY_MET_MINOR_CIV', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@GAIHIHBJ@TXT_KEY_NOTIFICATION_MET_MINOR_C@
CONST	SEGMENT
??_C@_0CD@GAIHIHBJ@TXT_KEY_NOTIFICATION_MET_MINOR_C@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_MET_MINOR_CIV', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?makeHasMet@CvTeam@@QAEXW4TeamTypes@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?makeHasMet@CvTeam@@QAEXW4TeamTypes@@_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?makeHasMet@CvTeam@@QAEXW4TeamTypes@@_N@Z$1
__ehfuncinfo$?makeHasMet@CvTeam@@QAEXW4TeamTypes@@_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?makeHasMet@CvTeam@@QAEXW4TeamTypes@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?makeHasMet@CvTeam@@QAEXW4TeamTypes@@_N@Z
_TEXT	SEGMENT
tv422 = -284						; size = 4
tv295 = -280						; size = 4
_this$ = -276						; size = 4
$T235148 = -272						; size = 4
$T235133 = -268						; size = 4
$T235129 = -264						; size = 4
$T235128 = -260						; size = 4
$T235124 = -256						; size = 4
$T235120 = -252						; size = 4
$T235119 = -248						; size = 4
$T235115 = -244						; size = 4
$T235111 = -240						; size = 4
$T235110 = -236						; size = 4
$T235106 = -232						; size = 4
$T235102 = -228						; size = 4
$T235074 = -224						; size = 4
$T235073 = -220						; size = 4
$T235069 = -216						; size = 4
$T235065 = -212						; size = 4
$T235061 = -208						; size = 4
$T235057 = -204						; size = 4
$T235053 = -200						; size = 4
$T235046 = -196						; size = 4
$T235042 = -192						; size = 4
$T235033 = -188						; size = 4
$T235029 = -181						; size = 1
$T235020 = -180						; size = 4
$T235016 = -176						; size = 4
$T235012 = -172						; size = 4
$T235008 = -165						; size = 1
$T234999 = -164						; size = 4
$T234995 = -160						; size = 4
$T234977 = -156						; size = 4
$T234973 = -149						; size = 1
$T234964 = -148						; size = 4
$T234960 = -144						; size = 4
$T234951 = -140						; size = 4
$T234947 = -133						; size = 1
$T234938 = -132						; size = 4
$T234934 = -128						; size = 4
$T234930 = -124						; size = 4
_strBuffer$224764 = -120				; size = 28
_strSummary$224772 = -92				; size = 28
__$ArrayPad$ = -64					; size = 4
_pCapPlot$224759 = -60					; size = 4
_pCap$224757 = -56					; size = 4
_iCapitalX$224754 = -52					; size = 4
_iCapitalY$224755 = -48					; size = 4
_iCapitalID$224756 = -44				; size = 4
_iThirdPlayersLoop$224718 = -40				; size = 4
_eTheirPlayer$224717 = -36				; size = 4
_eMyPlayer$224715 = -32					; size = 4
_eThirdPlayer$224719 = -28				; size = 4
_iMyPlayersLoop$224714 = -24				; size = 4
_iTheirPlayersLoop$224716 = -20				; size = 4
_iI$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_eIndex$ = 8						; size = 4
_bSuppressMessages$ = 12				; size = 1
?makeHasMet@CvTeam@@QAEXW4TeamTypes@@_N@Z PROC		; CvTeam::makeHasMet, COMDAT
; _this$ = ecx

; 3613 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?makeHasMet@CvTeam@@QAEXW4TeamTypes@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 272				; 00000110H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3614 : 	int iI;
; 3615 : 
; 3616 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 3617 : 	CvAssertMsg(eIndex < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 3618 : 
; 3619 : 	if(!isHasMet(eIndex))

	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN37@makeHasMet

; 3620 : 	{
; 3621 : 		m_abHasMet[eIndex] = true;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR _eIndex$[ebp]
	mov	BYTE PTR [edx+1848], 1

; 3622 : 
; 3623 : 		SetTurnTeamMet(eIndex, GC.getGame().getGameTurn());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T234930[ebp], eax
	mov	ecx, DWORD PTR $T234930[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	push	eax
	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTurnTeamMet@CvTeam@@QAEXW4TeamTypes@@H@Z ; CvTeam::SetTurnTeamMet

; 3624 : 
; 3625 : 		updateTechShare();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateTechShare@CvTeam@@IAEXXZ		; CvTeam::updateTechShare

; 3626 : 
; 3627 : #ifdef AUI_GAME_OBSERVER_MEET_ALL_TEAMS
; 3628 : 		if (bForObserver)
; 3629 : 		{
; 3630 : 			if ((GetID() == GC.getGame().getActiveTeam()) || (eIndex == GC.getGame().getActiveTeam()))
; 3631 : 			{
; 3632 : 				DLLUI->setDirty(Score_DIRTY_BIT, true);
; 3633 : 			}
; 3634 : 			// Report event
; 3635 : 			gDLL->GameplayMetTeam(GetID(), eIndex);
; 3636 : 			return;
; 3637 : 		}
; 3638 : #endif
; 3639 : 
; 3640 : 		if(GC.getGame().isOption(GAMEOPTION_ALWAYS_WAR))

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T234934[ebp], edx
	push	3
	mov	ecx, DWORD PTR $T234934[ebp]
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN35@makeHasMet

; 3641 : 		{
; 3642 : 			if(isHuman())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isHuman@CvTeam@@QBE_NXZ		; CvTeam::isHuman
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN35@makeHasMet

; 3643 : 			{
; 3644 : 				if(GetID() != eIndex)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	eax, DWORD PTR _eIndex$[ebp]
	je	SHORT $LN35@makeHasMet

; 3645 : 				{
; 3646 : 					declareWar(eIndex);

	push	0
	mov	edx, DWORD PTR _eIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?declareWar@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::declareWar
$LN35@makeHasMet:

; 3647 : 				}
; 3648 : 			}
; 3649 : 		}
; 3650 : 
; 3651 : 		int iMyPlayersLoop;
; 3652 : 		PlayerTypes eMyPlayer;
; 3653 : 
; 3654 : 		int iTheirPlayersLoop;
; 3655 : 		PlayerTypes eTheirPlayer;
; 3656 : 
; 3657 : 		int iThirdPlayersLoop;
; 3658 : 		PlayerTypes eThirdPlayer;
; 3659 : 
; 3660 : 		// First Contact in Diplo AI (Civ 5)
; 3661 : 		for(iMyPlayersLoop = 0; iMyPlayersLoop < MAX_CIV_PLAYERS; iMyPlayersLoop++)

	mov	DWORD PTR _iMyPlayersLoop$224714[ebp], 0
	jmp	SHORT $LN32@makeHasMet
$LN31@makeHasMet:
	mov	eax, DWORD PTR _iMyPlayersLoop$224714[ebp]
	add	eax, 1
	mov	DWORD PTR _iMyPlayersLoop$224714[ebp], eax
$LN32@makeHasMet:
	cmp	DWORD PTR _iMyPlayersLoop$224714[ebp], 63 ; 0000003fH
	jge	$LN30@makeHasMet

; 3662 : 		{
; 3663 : 			eMyPlayer = (PlayerTypes) iMyPlayersLoop;

	mov	ecx, DWORD PTR _iMyPlayersLoop$224714[ebp]
	mov	DWORD PTR _eMyPlayer$224715[ebp], ecx

; 3664 : 
; 3665 : 			if(GET_PLAYER(eMyPlayer).isAlive())

	mov	edx, DWORD PTR _eMyPlayer$224715[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T234938[ebp], edx
	mov	eax, DWORD PTR $T234938[ebp]
	mov	cl, BYTE PTR [eax+2256]
	mov	BYTE PTR $T234947[ebp], cl
	movzx	edx, BYTE PTR $T234947[ebp]
	test	edx, edx
	je	$LN29@makeHasMet

; 3666 : 			{
; 3667 : 				if(GET_PLAYER(eMyPlayer).getTeam() == GetID())

	mov	eax, DWORD PTR _eMyPlayer$224715[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T234951[ebp], eax
	mov	ecx, DWORD PTR $T234951[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T234960[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T234960[ebp], eax
	jne	$LN29@makeHasMet

; 3668 : 				{
; 3669 : 					// Now loop through players on Their team
; 3670 : 					for(iTheirPlayersLoop = 0; iTheirPlayersLoop < MAX_CIV_PLAYERS; iTheirPlayersLoop++)

	mov	DWORD PTR _iTheirPlayersLoop$224716[ebp], 0
	jmp	SHORT $LN27@makeHasMet
$LN26@makeHasMet:
	mov	eax, DWORD PTR _iTheirPlayersLoop$224716[ebp]
	add	eax, 1
	mov	DWORD PTR _iTheirPlayersLoop$224716[ebp], eax
$LN27@makeHasMet:
	cmp	DWORD PTR _iTheirPlayersLoop$224716[ebp], 63 ; 0000003fH
	jge	$LN29@makeHasMet

; 3671 : 					{
; 3672 : 						eTheirPlayer = (PlayerTypes) iTheirPlayersLoop;

	mov	ecx, DWORD PTR _iTheirPlayersLoop$224716[ebp]
	mov	DWORD PTR _eTheirPlayer$224717[ebp], ecx

; 3673 : 
; 3674 : 						// Don't calculate proximity to oneself!
; 3675 : 						if(eMyPlayer != eTheirPlayer)

	mov	edx, DWORD PTR _eMyPlayer$224715[ebp]
	cmp	edx, DWORD PTR _eTheirPlayer$224717[ebp]
	je	$LN24@makeHasMet

; 3676 : 						{
; 3677 : 							if(GET_PLAYER(eTheirPlayer).isAlive())

	mov	eax, DWORD PTR _eTheirPlayer$224717[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T234964[ebp], eax
	mov	ecx, DWORD PTR $T234964[ebp]
	mov	dl, BYTE PTR [ecx+2256]
	mov	BYTE PTR $T234973[ebp], dl
	movzx	eax, BYTE PTR $T234973[ebp]
	test	eax, eax
	je	$LN24@makeHasMet

; 3678 : 							{
; 3679 : 								if(GET_PLAYER(eTheirPlayer).getTeam() == eIndex)

	mov	ecx, DWORD PTR _eTheirPlayer$224717[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T234977[ebp], ecx
	mov	edx, DWORD PTR $T234977[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	eax, DWORD PTR _eIndex$[ebp]
	jne	$LN24@makeHasMet

; 3680 : 								{
; 3681 : 									// Begin contact stuff here
; 3682 : 
; 3683 : 									// Update Proximity between players
; 3684 : 									GET_PLAYER(eMyPlayer).DoUpdateProximityToPlayer(eTheirPlayer);

	mov	ecx, DWORD PTR _eTheirPlayer$224717[ebp]
	push	ecx
	mov	ecx, DWORD PTR _eMyPlayer$224715[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?DoUpdateProximityToPlayer@CvPlayer@@QAEXW4PlayerTypes@@@Z ; CvPlayer::DoUpdateProximityToPlayer

; 3685 : 									GET_PLAYER(eTheirPlayer).DoUpdateProximityToPlayer(eMyPlayer);

	mov	edx, DWORD PTR _eMyPlayer$224715[ebp]
	push	edx
	mov	ecx, DWORD PTR _eTheirPlayer$224717[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?DoUpdateProximityToPlayer@CvPlayer@@QAEXW4PlayerTypes@@@Z ; CvPlayer::DoUpdateProximityToPlayer

; 3686 : 
; 3687 : 									// First contact Diplo changes (no Minors)
; 3688 : 									if(!isMinorCiv())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN21@makeHasMet

; 3689 : 									{
; 3690 : 										GET_PLAYER(eMyPlayer).GetDiplomacyAI()->DoFirstContact(eTheirPlayer);

	mov	ecx, DWORD PTR _eMyPlayer$224715[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T234995[ebp], ecx
	mov	edx, DWORD PTR _eTheirPlayer$224717[ebp]
	push	edx
	mov	ecx, DWORD PTR $T234995[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?DoFirstContact@CvDiplomacyAI@@QAEXW4PlayerTypes@@@Z ; CvDiplomacyAI::DoFirstContact
$LN21@makeHasMet:

; 3691 : 									}
; 3692 : 
; 3693 : 									// THIRD party loop - let everyone else know that someone met someone!
; 3694 : 									for(iThirdPlayersLoop = 0; iThirdPlayersLoop < MAX_CIV_PLAYERS; iThirdPlayersLoop++)

	mov	DWORD PTR _iThirdPlayersLoop$224718[ebp], 0
	jmp	SHORT $LN20@makeHasMet
$LN19@makeHasMet:
	mov	eax, DWORD PTR _iThirdPlayersLoop$224718[ebp]
	add	eax, 1
	mov	DWORD PTR _iThirdPlayersLoop$224718[ebp], eax
$LN20@makeHasMet:
	cmp	DWORD PTR _iThirdPlayersLoop$224718[ebp], 63 ; 0000003fH
	jge	SHORT $LN24@makeHasMet

; 3695 : 									{
; 3696 : 										eThirdPlayer = (PlayerTypes) iThirdPlayersLoop;

	mov	ecx, DWORD PTR _iThirdPlayersLoop$224718[ebp]
	mov	DWORD PTR _eThirdPlayer$224719[ebp], ecx

; 3697 : 
; 3698 : 										if(GET_PLAYER(eThirdPlayer).isAlive())

	mov	edx, DWORD PTR _eThirdPlayer$224719[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T234999[ebp], edx
	mov	eax, DWORD PTR $T234999[ebp]
	mov	cl, BYTE PTR [eax+2256]
	mov	BYTE PTR $T235008[ebp], cl
	movzx	edx, BYTE PTR $T235008[ebp]
	test	edx, edx
	je	SHORT $LN17@makeHasMet

; 3699 : 										{
; 3700 : 											// Don't notify diplo AI if we're the one meeting or the one being met
; 3701 : 											if(eThirdPlayer != eMyPlayer && eThirdPlayer != eTheirPlayer)

	mov	eax, DWORD PTR _eThirdPlayer$224719[ebp]
	cmp	eax, DWORD PTR _eMyPlayer$224715[ebp]
	je	SHORT $LN17@makeHasMet
	mov	ecx, DWORD PTR _eThirdPlayer$224719[ebp]
	cmp	ecx, DWORD PTR _eTheirPlayer$224717[ebp]
	je	SHORT $LN17@makeHasMet

; 3702 : 											{
; 3703 : 												GET_PLAYER(eThirdPlayer).GetDiplomacyAI()->DoPlayerMetSomeone(eMyPlayer, eTheirPlayer);

	mov	edx, DWORD PTR _eThirdPlayer$224719[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235012[ebp], edx
	mov	eax, DWORD PTR _eTheirPlayer$224717[ebp]
	push	eax
	mov	ecx, DWORD PTR _eMyPlayer$224715[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T235012[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?DoPlayerMetSomeone@CvDiplomacyAI@@QAEXW4PlayerTypes@@0@Z ; CvDiplomacyAI::DoPlayerMetSomeone
$LN17@makeHasMet:

; 3704 : 											}
; 3705 : 										}
; 3706 : 									}

	jmp	$LN19@makeHasMet
$LN24@makeHasMet:

; 3707 : 								}
; 3708 : 							}
; 3709 : 						}
; 3710 : 					}

	jmp	$LN26@makeHasMet
$LN29@makeHasMet:

; 3711 : 				}
; 3712 : 			}
; 3713 : 		}

	jmp	$LN31@makeHasMet
$LN30@makeHasMet:

; 3714 : 
; 3715 : 		if(GET_TEAM(eIndex).isHuman())

	mov	edx, DWORD PTR _eIndex$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T235016[ebp], edx
	mov	ecx, DWORD PTR $T235016[ebp]
	call	?isHuman@CvTeam@@QBE_NXZ		; CvTeam::isHuman
	movzx	eax, al
	test	eax, eax
	je	$LN15@makeHasMet

; 3716 : 		{
; 3717 : 			for(iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN14@makeHasMet
$LN13@makeHasMet:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN14@makeHasMet:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	$LN15@makeHasMet

; 3718 : 			{
; 3719 : 				if(GET_PLAYER((PlayerTypes)iI).isAlive())

	mov	edx, DWORD PTR _iI$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235020[ebp], edx
	mov	eax, DWORD PTR $T235020[ebp]
	mov	cl, BYTE PTR [eax+2256]
	mov	BYTE PTR $T235029[ebp], cl
	movzx	edx, BYTE PTR $T235029[ebp]
	test	edx, edx
	je	SHORT $LN11@makeHasMet

; 3720 : 				{
; 3721 : 					if(GET_PLAYER((PlayerTypes)iI).getTeam() == GetID())

	mov	eax, DWORD PTR _iI$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235033[ebp], eax
	mov	ecx, DWORD PTR $T235033[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T235042[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T235042[ebp], eax
	jne	SHORT $LN11@makeHasMet

; 3722 : 					{
; 3723 : 						if(!(GET_PLAYER((PlayerTypes)iI).isHuman()))

	mov	eax, DWORD PTR _iI$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235046[ebp], eax
	mov	ecx, DWORD PTR $T235046[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN11@makeHasMet

; 3724 : 						{
; 3725 : 							GET_PLAYER((PlayerTypes)iI).clearResearchQueue();

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?clearResearchQueue@CvPlayer@@QAEXXZ	; CvPlayer::clearResearchQueue
$LN11@makeHasMet:

; 3726 : 							//GET_PLAYER((PlayerTypes)iI).AI_makeProductionDirty();
; 3727 : 						}
; 3728 : 					}
; 3729 : 				}
; 3730 : 			}

	jmp	$LN13@makeHasMet
$LN15@makeHasMet:

; 3731 : 		}
; 3732 : 
; 3733 : 		if((GetID() == GC.getGame().getActiveTeam()) || (eIndex == GC.getGame().getActiveTeam()))

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235053[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	mov	esi, eax
	mov	ecx, DWORD PTR $T235053[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	esi, eax
	je	SHORT $LN7@makeHasMet
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235057[ebp], eax
	mov	ecx, DWORD PTR $T235057[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	DWORD PTR _eIndex$[ebp], eax
	jne	SHORT $LN8@makeHasMet
$LN7@makeHasMet:

; 3734 : 		{
; 3735 : 			DLLUI->setDirty(Score_DIRTY_BIT, true);

	mov	ecx, DWORD PTR $T235061[ebp]
	mov	DWORD PTR tv295[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv295[ebp], edx
	push	1
	push	12					; 0000000cH
	mov	eax, DWORD PTR tv295[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv295[ebp]
	mov	eax, DWORD PTR [edx+260]
	call	eax
$LN8@makeHasMet:

; 3736 : 		}
; 3737 : 
; 3738 : 		if(GET_TEAM(eIndex).isMinorCiv())

	mov	ecx, DWORD PTR _eIndex$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T235065[ebp], ecx
	mov	ecx, DWORD PTR $T235065[ebp]
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	movzx	edx, al
	test	edx, edx
	je	$LN6@makeHasMet

; 3739 : 		{
; 3740 : 			int iCapitalX = -1;

	mov	DWORD PTR _iCapitalX$224754[ebp], -1

; 3741 : 			int iCapitalY = -1;

	mov	DWORD PTR _iCapitalY$224755[ebp], -1

; 3742 : 			int iCapitalID = -1;

	mov	DWORD PTR _iCapitalID$224756[ebp], -1

; 3743 : 
; 3744 : 			// Minor reveals his capital to the player so that he can click on the City to contact
; 3745 : 			CvCity* pCap = GET_PLAYER(GET_TEAM(eIndex).getLeaderID()).getCapitalCity();

	mov	eax, DWORD PTR _eIndex$[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T235069[ebp], eax
	mov	ecx, DWORD PTR $T235069[ebp]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	mov	DWORD PTR $T235073[ebp], eax
	mov	ecx, DWORD PTR $T235073[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235074[ebp], ecx
	mov	ecx, DWORD PTR $T235074[ebp]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	DWORD PTR _pCap$224757[ebp], eax

; 3746 : 			if(pCap)

	cmp	DWORD PTR _pCap$224757[ebp], 0
	je	SHORT $LN5@makeHasMet

; 3747 : 			{
; 3748 : 				iCapitalX  = pCap->getX();

	mov	edx, DWORD PTR _pCap$224757[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR _iCapitalX$224754[ebp], eax

; 3749 : 				iCapitalY  = pCap->getY();

	mov	ecx, DWORD PTR _pCap$224757[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR _iCapitalY$224755[ebp], edx

; 3750 : 				iCapitalID = pCap->GetID();

	mov	eax, DWORD PTR _pCap$224757[ebp]
	mov	ecx, DWORD PTR [eax+120]
	mov	DWORD PTR _iCapitalID$224756[ebp], ecx

; 3751 : 				CvPlot* pCapPlot = pCap->plot();

	mov	ecx, DWORD PTR _pCap$224757[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	DWORD PTR _pCapPlot$224759[ebp], eax

; 3752 : 				if(pCapPlot)

	cmp	DWORD PTR _pCapPlot$224759[ebp], 0
	je	SHORT $LN5@makeHasMet

; 3753 : 				{
; 3754 : 					pCapPlot->setRevealed(GetID(), true);

	push	-1
	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	ecx, DWORD PTR _pCapPlot$224759[ebp]
	call	?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z ; CvPlot::setRevealed

; 3755 : 					GC.getMap().updateDeferredFog();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T235102[ebp], edx
	mov	ecx, DWORD PTR $T235102[ebp]
	call	?updateDeferredFog@CvMap@@QAEXXZ	; CvMap::updateDeferredFog
$LN5@makeHasMet:

; 3756 : 				}
; 3757 : 			}
; 3758 : 
; 3759 : 			// First contact with major stuff
; 3760 : 			if(!isMinorCiv())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@makeHasMet

; 3761 : 			{
; 3762 : 				GET_PLAYER(GET_TEAM(eIndex).getLeaderID()).GetMinorCivAI()->DoFirstContactWithMajor(GetID(), /*bSuppressMessages*/ isAtWar(eIndex));

	mov	ecx, DWORD PTR _eIndex$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T235106[ebp], ecx
	mov	ecx, DWORD PTR $T235106[ebp]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	mov	DWORD PTR $T235110[ebp], eax
	mov	edx, DWORD PTR $T235110[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235111[ebp], edx
	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	ecx, al
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	ecx, DWORD PTR $T235111[ebp]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?DoFirstContactWithMajor@CvMinorCivAI@@QAEXW4TeamTypes@@_N@Z ; CvMinorCivAI::DoFirstContactWithMajor
$LN3@makeHasMet:

; 3763 : 			}
; 3764 : 
; 3765 : 			if(!isAtWar(eIndex))

	mov	edx, DWORD PTR _eIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	eax, al
	test	eax, eax
	jne	$LN6@makeHasMet

; 3766 : 			{
; 3767 : 				// Notify the Team that they met someone
; 3768 : 				if(!bSuppressMessages)

	movzx	ecx, BYTE PTR _bSuppressMessages$[ebp]
	test	ecx, ecx
	jne	$LN6@makeHasMet

; 3769 : 				{
; 3770 : 					CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_MET_MINOR_CIV", GET_PLAYER(GET_TEAM(eIndex).getLeaderID()).getNameKey());

	mov	edx, DWORD PTR _eIndex$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T235115[ebp], edx
	mov	ecx, DWORD PTR $T235115[ebp]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	mov	DWORD PTR $T235119[ebp], eax
	mov	eax, DWORD PTR $T235119[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235120[ebp], eax
	mov	ecx, DWORD PTR $T235120[ebp]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	push	OFFSET ??_C@_0CD@GAIHIHBJ@TXT_KEY_NOTIFICATION_MET_MINOR_C@
	lea	ecx, DWORD PTR _strBuffer$224764[ebp]
	push	ecx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3771 : 					CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_MET_MINOR_CIV", GET_PLAYER(GET_TEAM(eIndex).getLeaderID()).getNameKey());

	mov	edx, DWORD PTR _eIndex$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T235124[ebp], edx
	mov	ecx, DWORD PTR $T235124[ebp]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	mov	DWORD PTR $T235128[ebp], eax
	mov	eax, DWORD PTR $T235128[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235129[ebp], eax
	mov	ecx, DWORD PTR $T235129[ebp]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	push	OFFSET ??_C@_0CL@EBOJENKG@TXT_KEY_NOTIFICATION_SUMMARY_MET@
	lea	ecx, DWORD PTR _strSummary$224772[ebp]
	push	ecx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 3772 : 
; 3773 : 					AddNotification(NOTIFICATION_MET_MINOR, strBuffer, strSummary, iCapitalX, iCapitalY, iCapitalID);

	lea	ecx, DWORD PTR _strSummary$224772[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T235133[ebp], eax
	push	-1
	mov	edx, DWORD PTR _iCapitalID$224756[ebp]
	push	edx
	mov	eax, DWORD PTR _iCapitalY$224755[ebp]
	push	eax
	mov	ecx, DWORD PTR _iCapitalX$224754[ebp]
	push	ecx
	mov	edx, DWORD PTR $T235133[ebp]
	push	edx
	lea	ecx, DWORD PTR _strBuffer$224764[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	981828329				; 3a8582e9H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddNotification@CvTeam@@QAEXW4NotificationTypes@@PBD1HHHH@Z ; CvTeam::AddNotification

; 3774 : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strSummary$224772[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strBuffer$224764[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN6@makeHasMet:

; 3775 : 			}
; 3776 : 		}
; 3777 : 
; 3778 : 		// Report event
; 3779 : 		gDLL->GameplayMetTeam(GetID(), eIndex);

	mov	eax, DWORD PTR $T235148[ebp]
	mov	DWORD PTR tv422[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv422[ebp], ecx
	mov	edx, DWORD PTR _eIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	eax, DWORD PTR tv422[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv422[ebp]
	mov	eax, DWORD PTR [edx+740]
	call	eax
$LN37@makeHasMet:

; 3780 : 	}
; 3781 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?makeHasMet@CvTeam@@QAEXW4TeamTypes@@_N@Z$0:
	lea	ecx, DWORD PTR _strBuffer$224764[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?makeHasMet@CvTeam@@QAEXW4TeamTypes@@_N@Z$1:
	lea	ecx, DWORD PTR _strSummary$224772[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?makeHasMet@CvTeam@@QAEXW4TeamTypes@@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-280]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?makeHasMet@CvTeam@@QAEXW4TeamTypes@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?makeHasMet@CvTeam@@QAEXW4TeamTypes@@_N@Z ENDP		; CvTeam::makeHasMet
PUBLIC	?GetTurnsSinceMeetingTeam@CvTeam@@QBEHW4TeamTypes@@@Z ; CvTeam::GetTurnsSinceMeetingTeam
; Function compile flags: /Odtp
;	COMDAT ?GetTurnsSinceMeetingTeam@CvTeam@@QBEHW4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T235160 = -4						; size = 4
_eTeam$ = 8						; size = 4
?GetTurnsSinceMeetingTeam@CvTeam@@QBEHW4TeamTypes@@@Z PROC ; CvTeam::GetTurnsSinceMeetingTeam, COMDAT
; _this$ = ecx

; 3785 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 3786 : 	CvAssertMsg(eTeam >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 3787 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 3788 : 	return GC.getGame().getGameTurn() - m_aiTurnTeamMet[eTeam];

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235160[ebp], eax
	mov	ecx, DWORD PTR $T235160[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, DWORD PTR _eTeam$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	sub	eax, DWORD PTR [edx+ecx*4+2568]

; 3789 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetTurnsSinceMeetingTeam@CvTeam@@QBEHW4TeamTypes@@@Z ENDP ; CvTeam::GetTurnsSinceMeetingTeam
_TEXT	ENDS
PUBLIC	?GetTurnTeamMet@CvTeam@@QBEHW4TeamTypes@@@Z	; CvTeam::GetTurnTeamMet
; Function compile flags: /Odtp
;	COMDAT ?GetTurnTeamMet@CvTeam@@QBEHW4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eTeam$ = 8						; size = 4
?GetTurnTeamMet@CvTeam@@QBEHW4TeamTypes@@@Z PROC	; CvTeam::GetTurnTeamMet, COMDAT
; _this$ = ecx

; 3793 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3794 : 	CvAssertMsg(eTeam >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 3795 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 3796 : 	return m_aiTurnTeamMet[eTeam];

	mov	eax, DWORD PTR _eTeam$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4+2568]

; 3797 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetTurnTeamMet@CvTeam@@QBEHW4TeamTypes@@@Z ENDP	; CvTeam::GetTurnTeamMet
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?SetTurnTeamMet@CvTeam@@QAEXW4TeamTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eTeam$ = 8						; size = 4
_iTurn$ = 12						; size = 4
?SetTurnTeamMet@CvTeam@@QAEXW4TeamTypes@@H@Z PROC	; CvTeam::SetTurnTeamMet, COMDAT
; _this$ = ecx

; 3801 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3802 : 	CvAssertMsg(eTeam >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 3803 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 3804 : 	m_aiTurnTeamMet[eTeam] = iTurn;

	mov	eax, DWORD PTR _eTeam$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _iTurn$[ebp]
	mov	DWORD PTR [ecx+eax*4+2568], edx

; 3805 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetTurnTeamMet@CvTeam@@QAEXW4TeamTypes@@H@Z ENDP	; CvTeam::SetTurnTeamMet
_TEXT	ENDS
PUBLIC	?IsHasFoundPlayersTerritory@CvTeam@@QBE_NW4PlayerTypes@@@Z ; CvTeam::IsHasFoundPlayersTerritory
; Function compile flags: /Odtp
;	COMDAT ?IsHasFoundPlayersTerritory@CvTeam@@QBE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ePlayer$ = 8						; size = 4
?IsHasFoundPlayersTerritory@CvTeam@@QBE_NW4PlayerTypes@@@Z PROC ; CvTeam::IsHasFoundPlayersTerritory, COMDAT
; _this$ = ecx

; 3810 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3811 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 3812 : 	CvAssertMsg(ePlayer < MAX_PLAYERS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 3813 : 	return m_abHasFoundPlayersTerritory[ePlayer];

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _ePlayer$[ebp]
	mov	al, BYTE PTR [eax+1768]

; 3814 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsHasFoundPlayersTerritory@CvTeam@@QBE_NW4PlayerTypes@@@Z ENDP ; CvTeam::IsHasFoundPlayersTerritory
_TEXT	ENDS
PUBLIC	?SetHasFoundPlayersTerritory@CvTeam@@QAE_NW4PlayerTypes@@_N@Z ; CvTeam::SetHasFoundPlayersTerritory
; Function compile flags: /Odtp
;	COMDAT ?SetHasFoundPlayersTerritory@CvTeam@@QAE_NW4PlayerTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ePlayer$ = 8						; size = 4
_bValue$ = 12						; size = 1
?SetHasFoundPlayersTerritory@CvTeam@@QAE_NW4PlayerTypes@@_N@Z PROC ; CvTeam::SetHasFoundPlayersTerritory, COMDAT
; _this$ = ecx

; 3819 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3820 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 3821 : 	CvAssertMsg(ePlayer < MAX_PLAYERS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 3822 : 
; 3823 : 	if(IsHasFoundPlayersTerritory(ePlayer) != bValue)

	mov	eax, DWORD PTR _ePlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHasFoundPlayersTerritory@CvTeam@@QBE_NW4PlayerTypes@@@Z ; CvTeam::IsHasFoundPlayersTerritory
	movzx	ecx, al
	movzx	edx, BYTE PTR _bValue$[ebp]
	cmp	ecx, edx
	je	SHORT $LN1@SetHasFoun

; 3824 : 	{
; 3825 : 		m_abHasFoundPlayersTerritory[ePlayer] = bValue;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _ePlayer$[ebp]
	mov	cl, BYTE PTR _bValue$[ebp]
	mov	BYTE PTR [eax+1768], cl

; 3826 : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@SetHasFoun
$LN1@SetHasFoun:

; 3827 : 	}
; 3828 : 	return false;

	xor	al, al
$LN2@SetHasFoun:

; 3829 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetHasFoundPlayersTerritory@CvTeam@@QAE_NW4PlayerTypes@@_N@Z ENDP ; CvTeam::SetHasFoundPlayersTerritory
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z PROC		; CvTeam::isAtWar, COMDAT
; _this$ = ecx

; 3833 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3834 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 3835 : 	CvAssertMsg(eIndex < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 3836 : 	return m_abAtWar[eIndex];

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _eIndex$[ebp]
	mov	al, BYTE PTR [eax+1928]

; 3837 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z ENDP		; CvTeam::isAtWar
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?setAtWar@CvTeam@@QAEXW4TeamTypes@@_N@Z
_TEXT	SEGMENT
tv80 = -12						; size = 4
_this$ = -8						; size = 4
$T235197 = -4						; size = 4
_eIndex$ = 8						; size = 4
_bNewValue$ = 12					; size = 1
?setAtWar@CvTeam@@QAEXW4TeamTypes@@_N@Z PROC		; CvTeam::setAtWar, COMDAT
; _this$ = ecx

; 3842 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 3843 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 3844 : 	CvAssertMsg(eIndex < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 3845 : 	CvAssertMsg(eIndex != GetID() || bNewValue == false, "Team is setting war with itself!");
; 3846 : 	if(eIndex != GetID() || bNewValue == false)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR _eIndex$[ebp], eax
	jne	SHORT $LN5@setAtWar
	movzx	eax, BYTE PTR _bNewValue$[ebp]
	test	eax, eax
	jne	SHORT $LN2@setAtWar

; 3847 : 		m_abAtWar[eIndex] = bNewValue;

$LN5@setAtWar:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR _eIndex$[ebp]
	mov	dl, BYTE PTR _bNewValue$[ebp]
	mov	BYTE PTR [ecx+1928], dl
$LN2@setAtWar:

; 3848 : 
; 3849 : 	gDLL->GameplayWarStateChanged(GetID(), eIndex, bNewValue);

	mov	eax, DWORD PTR $T235197[ebp]
	mov	DWORD PTR tv80[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv80[ebp], ecx
	movzx	edx, BYTE PTR _bNewValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	ecx, DWORD PTR tv80[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv80[ebp]
	mov	eax, DWORD PTR [edx+728]
	call	eax

; 3850 : 
; 3851 : #ifndef FINAL_RELEASE
; 3852 : 	for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
; 3853 : 	{
; 3854 : 		CvPlayerAI& kPlayer = GET_PLAYER((PlayerTypes) iMinorLoop);
; 3855 : 		if(kPlayer.getTeam() == eIndex && kPlayer.isAlive())
; 3856 : 			CvAssertMsg(GET_PLAYER((PlayerTypes) iMinorLoop).GetMinorCivAI()->GetAlly() != getLeaderID(), "Major civ is now at war with a minor it is allied with! This is dumb and bad. If you didn't do this on purpose, please send Jon this along with your last 5 autosaves and a changelist #.");
; 3857 : 	}
; 3858 : #endif
; 3859 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?setAtWar@CvTeam@@QAEXW4TeamTypes@@_N@Z ENDP		; CvTeam::setAtWar
_TEXT	ENDS
PUBLIC	?HasCommonEnemy@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::HasCommonEnemy
; Function compile flags: /Odtp
;	COMDAT ?HasCommonEnemy@CvTeam@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T235222 = -17						; size = 1
_kEnemyPlayer$224818 = -16				; size = 4
_eEnemyTeam$224820 = -12				; size = 4
_iI$ = -8						; size = 4
_kOtherTeam$ = -4					; size = 4
_eOtherTeam$ = 8					; size = 4
?HasCommonEnemy@CvTeam@@QBE_NW4TeamTypes@@@Z PROC	; CvTeam::HasCommonEnemy, COMDAT
; _this$ = ecx

; 3864 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 3865 : 	CvTeam& kOtherTeam = GET_TEAM(eOtherTeam);

	mov	eax, DWORD PTR _eOtherTeam$[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR _kOtherTeam$[ebp], eax

; 3866 : 	int iI;
; 3867 : 
; 3868 : 	for(iI = 0; iI < MAX_MAJOR_CIVS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN6@HasCommonE
$LN5@HasCommonE:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN6@HasCommonE:
	cmp	DWORD PTR _iI$[ebp], 22			; 00000016H
	jge	SHORT $LN4@HasCommonE

; 3869 : 	{
; 3870 : 		CvPlayerAI& kEnemyPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	edx, DWORD PTR _iI$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kEnemyPlayer$224818[ebp], edx

; 3871 : 		TeamTypes eEnemyTeam = kEnemyPlayer.getTeam();

	mov	eax, DWORD PTR _kEnemyPlayer$224818[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eEnemyTeam$224820[ebp], eax

; 3872 : 		if(eEnemyTeam != m_eID && eEnemyTeam != eOtherTeam)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _eEnemyTeam$224820[ebp]
	cmp	eax, DWORD PTR [edx+4]
	je	SHORT $LN3@HasCommonE
	mov	ecx, DWORD PTR _eEnemyTeam$224820[ebp]
	cmp	ecx, DWORD PTR _eOtherTeam$[ebp]
	je	SHORT $LN3@HasCommonE

; 3873 : 		{
; 3874 : 			if(kEnemyPlayer.isAlive())

	mov	edx, DWORD PTR _kEnemyPlayer$224818[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T235222[ebp], al
	movzx	ecx, BYTE PTR $T235222[ebp]
	test	ecx, ecx
	je	SHORT $LN3@HasCommonE

; 3875 : 			{
; 3876 : 				if(kOtherTeam.isAtWar(eEnemyTeam) && isAtWar(eEnemyTeam))

	mov	edx, DWORD PTR _eEnemyTeam$224820[ebp]
	push	edx
	mov	ecx, DWORD PTR _kOtherTeam$[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@HasCommonE
	mov	ecx, DWORD PTR _eEnemyTeam$224820[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@HasCommonE

; 3877 : 				{
; 3878 : 					return true;

	mov	al, 1
	jmp	SHORT $LN7@HasCommonE
$LN3@HasCommonE:

; 3879 : 				}
; 3880 : 			}
; 3881 : 		}
; 3882 : 	}

	jmp	$LN5@HasCommonE
$LN4@HasCommonE:

; 3883 : 
; 3884 : 	return false;

	xor	al, al
$LN7@HasCommonE:

; 3885 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?HasCommonEnemy@CvTeam@@QBE_NW4TeamTypes@@@Z ENDP	; CvTeam::HasCommonEnemy
_TEXT	ENDS
PUBLIC	?GetNumTurnsAtWar@CvTeam@@QBEHW4TeamTypes@@@Z	; CvTeam::GetNumTurnsAtWar
; Function compile flags: /Odtp
;	COMDAT ?GetNumTurnsAtWar@CvTeam@@QBEHW4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eTeam$ = 8						; size = 4
?GetNumTurnsAtWar@CvTeam@@QBEHW4TeamTypes@@@Z PROC	; CvTeam::GetNumTurnsAtWar, COMDAT
; _this$ = ecx

; 3890 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3891 : 	CvAssertMsg(eTeam >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 3892 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 3893 : 	return m_aiNumTurnsAtWar[eTeam];

	mov	eax, DWORD PTR _eTeam$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4+468]

; 3894 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetNumTurnsAtWar@CvTeam@@QBEHW4TeamTypes@@@Z ENDP	; CvTeam::GetNumTurnsAtWar
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?SetNumTurnsAtWar@CvTeam@@QAEXW4TeamTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eTeam$ = 8						; size = 4
_iValue$ = 12						; size = 4
?SetNumTurnsAtWar@CvTeam@@QAEXW4TeamTypes@@H@Z PROC	; CvTeam::SetNumTurnsAtWar, COMDAT
; _this$ = ecx

; 3899 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3900 : 	CvAssertMsg(eTeam >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 3901 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 3902 : 	CvAssertMsg(eTeam != GetID() || iValue == 0, "Team is setting war turns with itself!");
; 3903 : 	if(eTeam != GetID() || iValue == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR _eTeam$[ebp], eax
	jne	SHORT $LN5@SetNumTurn
	cmp	DWORD PTR _iValue$[ebp], 0
	jne	SHORT $LN3@SetNumTurn

; 3904 : 		m_aiNumTurnsAtWar[eTeam] = iValue;

$LN5@SetNumTurn:
	mov	eax, DWORD PTR _eTeam$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _iValue$[ebp]
	mov	DWORD PTR [ecx+eax*4+468], edx
$LN3@SetNumTurn:

; 3905 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetNumTurnsAtWar@CvTeam@@QAEXW4TeamTypes@@H@Z ENDP	; CvTeam::SetNumTurnsAtWar
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ChangeNumTurnsAtWar@CvTeam@@QAEXW4TeamTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eTeam$ = 8						; size = 4
_iChange$ = 12						; size = 4
?ChangeNumTurnsAtWar@CvTeam@@QAEXW4TeamTypes@@H@Z PROC	; CvTeam::ChangeNumTurnsAtWar, COMDAT
; _this$ = ecx

; 3910 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3911 : 	SetNumTurnsAtWar(eTeam, GetNumTurnsAtWar(eTeam) + iChange);

	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumTurnsAtWar@CvTeam@@QBEHW4TeamTypes@@@Z ; CvTeam::GetNumTurnsAtWar
	add	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetNumTurnsAtWar@CvTeam@@QAEXW4TeamTypes@@H@Z ; CvTeam::SetNumTurnsAtWar

; 3912 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ChangeNumTurnsAtWar@CvTeam@@QAEXW4TeamTypes@@H@Z ENDP	; CvTeam::ChangeNumTurnsAtWar
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetNumTurnsLockedIntoWar@CvTeam@@QBEHW4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eTeam$ = 8						; size = 4
?GetNumTurnsLockedIntoWar@CvTeam@@QBEHW4TeamTypes@@@Z PROC ; CvTeam::GetNumTurnsLockedIntoWar, COMDAT
; _this$ = ecx

; 3917 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3918 : 	CvAssertMsg(eTeam >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 3919 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 3920 : 	return m_aiNumTurnsLockedIntoWar[eTeam];

	mov	eax, DWORD PTR _eTeam$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4+788]

; 3921 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetNumTurnsLockedIntoWar@CvTeam@@QBEHW4TeamTypes@@@Z ENDP ; CvTeam::GetNumTurnsLockedIntoWar
_TEXT	ENDS
PUBLIC	?SetNumTurnsLockedIntoWar@CvTeam@@QAEXW4TeamTypes@@H@Z ; CvTeam::SetNumTurnsLockedIntoWar
; Function compile flags: /Odtp
;	COMDAT ?SetNumTurnsLockedIntoWar@CvTeam@@QAEXW4TeamTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eTeam$ = 8						; size = 4
_iValue$ = 12						; size = 4
?SetNumTurnsLockedIntoWar@CvTeam@@QAEXW4TeamTypes@@H@Z PROC ; CvTeam::SetNumTurnsLockedIntoWar, COMDAT
; _this$ = ecx

; 3926 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3927 : 	CvAssertMsg(eTeam >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 3928 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 3929 : 	CvAssertMsg(iValue >= 0, "Num turns locked into war should always be 0 or greater. Please show Jon this and send your last 5 autosaves and what changelist # you were playing.");
; 3930 : 	CvAssertMsg(eTeam != GetID() || iValue == 0, "Team is setting locked war turns with itself!");
; 3931 : 	if(eTeam != GetID() || iValue == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR _eTeam$[ebp], eax
	jne	SHORT $LN5@SetNumTurn@2
	cmp	DWORD PTR _iValue$[ebp], 0
	jne	SHORT $LN3@SetNumTurn@2

; 3932 : 		m_aiNumTurnsLockedIntoWar[eTeam] = iValue;

$LN5@SetNumTurn@2:
	mov	eax, DWORD PTR _eTeam$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _iValue$[ebp]
	mov	DWORD PTR [ecx+eax*4+788], edx
$LN3@SetNumTurn@2:

; 3933 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetNumTurnsLockedIntoWar@CvTeam@@QAEXW4TeamTypes@@H@Z ENDP ; CvTeam::SetNumTurnsLockedIntoWar
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ChangeNumTurnsLockedIntoWar@CvTeam@@QAEXW4TeamTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eTeam$ = 8						; size = 4
_iChange$ = 12						; size = 4
?ChangeNumTurnsLockedIntoWar@CvTeam@@QAEXW4TeamTypes@@H@Z PROC ; CvTeam::ChangeNumTurnsLockedIntoWar, COMDAT
; _this$ = ecx

; 3938 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3939 : 	SetNumTurnsLockedIntoWar(eTeam, GetNumTurnsLockedIntoWar(eTeam) + iChange);

	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumTurnsLockedIntoWar@CvTeam@@QBEHW4TeamTypes@@@Z ; CvTeam::GetNumTurnsLockedIntoWar
	add	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetNumTurnsLockedIntoWar@CvTeam@@QAEXW4TeamTypes@@H@Z ; CvTeam::SetNumTurnsLockedIntoWar

; 3940 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ChangeNumTurnsLockedIntoWar@CvTeam@@QAEXW4TeamTypes@@H@Z ENDP ; CvTeam::ChangeNumTurnsLockedIntoWar
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetTurnMadePeaceTreatyWithTeam@CvTeam@@QBEHW4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?GetTurnMadePeaceTreatyWithTeam@CvTeam@@QBEHW4TeamTypes@@@Z PROC ; CvTeam::GetTurnMadePeaceTreatyWithTeam, COMDAT
; _this$ = ecx

; 3944 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3945 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 3946 : 	CvAssertMsg(eIndex < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 3947 : 	return m_paiTurnMadePeaceTreatyWithTeam[eIndex];

	mov	eax, DWORD PTR _eIndex$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4+1128]

; 3948 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetTurnMadePeaceTreatyWithTeam@CvTeam@@QBEHW4TeamTypes@@@Z ENDP ; CvTeam::GetTurnMadePeaceTreatyWithTeam
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?SetTurnMadePeaceTreatyWithTeam@CvTeam@@QAEXW4TeamTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
_iNewValue$ = 12					; size = 4
?SetTurnMadePeaceTreatyWithTeam@CvTeam@@QAEXW4TeamTypes@@H@Z PROC ; CvTeam::SetTurnMadePeaceTreatyWithTeam, COMDAT
; _this$ = ecx

; 3953 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3954 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 3955 : 	CvAssertMsg(eIndex < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 3956 : 	m_paiTurnMadePeaceTreatyWithTeam[eIndex] = iNewValue;

	mov	eax, DWORD PTR _eIndex$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _iNewValue$[ebp]
	mov	DWORD PTR [ecx+eax*4+1128], edx

; 3957 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetTurnMadePeaceTreatyWithTeam@CvTeam@@QAEXW4TeamTypes@@H@Z ENDP ; CvTeam::SetTurnMadePeaceTreatyWithTeam
_TEXT	ENDS
PUBLIC	?IsHasBrokenPeaceTreaty@CvTeam@@QBE_NXZ		; CvTeam::IsHasBrokenPeaceTreaty
; Function compile flags: /Odtp
;	COMDAT ?IsHasBrokenPeaceTreaty@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsHasBrokenPeaceTreaty@CvTeam@@QBE_NXZ PROC		; CvTeam::IsHasBrokenPeaceTreaty, COMDAT
; _this$ = ecx

; 3961 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3962 : 	return m_bHasBrokenPeaceTreaty;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+129]

; 3963 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsHasBrokenPeaceTreaty@CvTeam@@QBE_NXZ ENDP		; CvTeam::IsHasBrokenPeaceTreaty
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?SetHasBrokenPeaceTreaty@CvTeam@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bValue$ = 8						; size = 1
?SetHasBrokenPeaceTreaty@CvTeam@@QAEX_N@Z PROC		; CvTeam::SetHasBrokenPeaceTreaty, COMDAT
; _this$ = ecx

; 3967 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3968 : 	m_bHasBrokenPeaceTreaty = bValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _bValue$[ebp]
	mov	BYTE PTR [eax+129], cl

; 3969 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetHasBrokenPeaceTreaty@CvTeam@@QAEX_N@Z ENDP		; CvTeam::SetHasBrokenPeaceTreaty
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isPermanentWarPeace@CvTeam@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?isPermanentWarPeace@CvTeam@@QBE_NW4TeamTypes@@@Z PROC	; CvTeam::isPermanentWarPeace, COMDAT
; _this$ = ecx

; 3973 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3974 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 3975 : 	CvAssertMsg(eIndex < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 3976 : 	return m_abPermanentWarPeace[eIndex];

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _eIndex$[ebp]
	mov	al, BYTE PTR [eax+2008]

; 3977 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isPermanentWarPeace@CvTeam@@QBE_NW4TeamTypes@@@Z ENDP	; CvTeam::isPermanentWarPeace
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?setPermanentWarPeace@CvTeam@@QAEXW4TeamTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
_bNewValue$ = 12					; size = 1
?setPermanentWarPeace@CvTeam@@QAEXW4TeamTypes@@_N@Z PROC ; CvTeam::setPermanentWarPeace, COMDAT
; _this$ = ecx

; 3982 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3983 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 3984 : 	CvAssertMsg(eIndex < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 3985 : 	m_abPermanentWarPeace[eIndex] = bNewValue;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _eIndex$[ebp]
	mov	cl, BYTE PTR _bNewValue$[ebp]
	mov	BYTE PTR [eax+2008], cl

; 3986 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?setPermanentWarPeace@CvTeam@@QAEXW4TeamTypes@@_N@Z ENDP ; CvTeam::setPermanentWarPeace
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetLiberatedByTeam@CvTeam@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLiberatedByTeam@CvTeam@@QBE?AW4TeamTypes@@XZ PROC	; CvTeam::GetLiberatedByTeam, COMDAT
; _this$ = ecx

; 3990 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3991 : 	return m_eLiberatedByTeam;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+140]

; 3992 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetLiberatedByTeam@CvTeam@@QBE?AW4TeamTypes@@XZ ENDP	; CvTeam::GetLiberatedByTeam
_TEXT	ENDS
PUBLIC	?SetLiberatedByTeam@CvTeam@@QAEXW4TeamTypes@@@Z	; CvTeam::SetLiberatedByTeam
; Function compile flags: /Odtp
;	COMDAT ?SetLiberatedByTeam@CvTeam@@QAEXW4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?SetLiberatedByTeam@CvTeam@@QAEXW4TeamTypes@@@Z PROC	; CvTeam::SetLiberatedByTeam, COMDAT
; _this$ = ecx

; 3997 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3998 : 	if(GetLiberatedByTeam() != eIndex)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLiberatedByTeam@CvTeam@@QBE?AW4TeamTypes@@XZ ; CvTeam::GetLiberatedByTeam
	cmp	eax, DWORD PTR _eIndex$[ebp]
	je	SHORT $LN2@SetLiberat

; 3999 : 	{
; 4000 : 		m_eLiberatedByTeam = eIndex;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _eIndex$[ebp]
	mov	DWORD PTR [eax+140], ecx
$LN2@SetLiberat:

; 4001 : 	}
; 4002 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetLiberatedByTeam@CvTeam@@QAEXW4TeamTypes@@@Z ENDP	; CvTeam::SetLiberatedByTeam
_TEXT	ENDS
PUBLIC	?GetKilledByTeam@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetKilledByTeam
; Function compile flags: /Odtp
;	COMDAT ?GetKilledByTeam@CvTeam@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetKilledByTeam@CvTeam@@QBE?AW4TeamTypes@@XZ PROC	; CvTeam::GetKilledByTeam, COMDAT
; _this$ = ecx

; 4007 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4008 : 	return m_eKilledByTeam;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+144]

; 4009 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetKilledByTeam@CvTeam@@QBE?AW4TeamTypes@@XZ ENDP	; CvTeam::GetKilledByTeam
_TEXT	ENDS
PUBLIC	?SetKilledByTeam@CvTeam@@QAEXW4TeamTypes@@@Z	; CvTeam::SetKilledByTeam
; Function compile flags: /Odtp
;	COMDAT ?SetKilledByTeam@CvTeam@@QAEXW4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?SetKilledByTeam@CvTeam@@QAEXW4TeamTypes@@@Z PROC	; CvTeam::SetKilledByTeam, COMDAT
; _this$ = ecx

; 4014 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4015 : 	if(GetKilledByTeam() != eIndex)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetKilledByTeam@CvTeam@@QBE?AW4TeamTypes@@XZ ; CvTeam::GetKilledByTeam
	cmp	eax, DWORD PTR _eIndex$[ebp]
	je	SHORT $LN2@SetKilledB

; 4016 : 	{
; 4017 : 		m_eKilledByTeam = eIndex;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _eIndex$[ebp]
	mov	DWORD PTR [eax+144], ecx
$LN2@SetKilledB:

; 4018 : 	}
; 4019 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetKilledByTeam@CvTeam@@QAEXW4TeamTypes@@@Z ENDP	; CvTeam::SetKilledByTeam
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?CloseEmbassyAtTeam@CvTeam@@QAEXW4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?CloseEmbassyAtTeam@CvTeam@@QAEXW4TeamTypes@@@Z PROC	; CvTeam::CloseEmbassyAtTeam, COMDAT
; _this$ = ecx

; 4023 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4024 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4025 : 	CvAssertMsg(eIndex < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 4026 : 
; 4027 : 	SetHasEmbassyAtTeam(eIndex, false);

	push	0
	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetHasEmbassyAtTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasEmbassyAtTeam

; 4028 : 	SetAllowsOpenBordersToTeam(m_eID, false);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAllowsOpenBordersToTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetAllowsOpenBordersToTeam

; 4029 : 	SetHasDefensivePact(m_eID, false);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasDefensivePact

; 4030 : 	GET_TEAM(eIndex).SetHasDefensivePact(m_eID, false);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _eIndex$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasDefensivePact

; 4031 : 
; 4032 : 	//SetHasResearchAgreement(m_eID, false);
; 4033 : 	//GET_TEAM(eIndex).SetHasResearchAgreement(m_eID, false);
; 4034 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?CloseEmbassyAtTeam@CvTeam@@QAEXW4TeamTypes@@@Z ENDP	; CvTeam::CloseEmbassyAtTeam
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?HasEmbassyAtTeam@CvTeam@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?HasEmbassyAtTeam@CvTeam@@QBE_NW4TeamTypes@@@Z PROC	; CvTeam::HasEmbassyAtTeam, COMDAT
; _this$ = ecx

; 4038 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4039 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4040 : 	CvAssertMsg(eIndex < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 4041 : 
; 4042 : 	return m_abEmbassy[eIndex];

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _eIndex$[ebp]
	mov	al, BYTE PTR [eax+2088]

; 4043 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?HasEmbassyAtTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ENDP	; CvTeam::HasEmbassyAtTeam
_TEXT	ENDS
PUBLIC	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z	; plotXYWithRangeCheck
EXTRN	?LogCloseEmbassy@CvDiplomacyAI@@QAEXW4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::LogCloseEmbassy
EXTRN	?LogOpenEmbassy@CvDiplomacyAI@@QAEXW4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::LogOpenEmbassy
; Function compile flags: /Odtp
;	COMDAT ?SetHasEmbassyAtTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z
_TEXT	SEGMENT
tv178 = -188						; size = 4
_this$ = -184						; size = 4
$T235457 = -180						; size = 4
$T235453 = -176						; size = 4
$T235449 = -169						; size = 1
$T235429 = -168						; size = 4
$T235420 = -164						; size = 4
$T235416 = -160						; size = 4
$T235412 = -156						; size = 4
$T235408 = -152						; size = 4
$T235404 = -148						; size = 4
$T235400 = -144						; size = 4
$T235317 = -72						; size = 4
$T235313 = -68						; size = 4
$T235309 = -64						; size = 4
$T235297 = -60						; size = 4
_eOtherPlayer$224948 = -56				; size = 4
_kOtherPlayer$224950 = -52				; size = 4
_uiOtherPlayer$224944 = -48				; size = 4
_eMyPlayer$224941 = -44					; size = 4
_uiMyPlayer$224937 = -40				; size = 4
_pLoopPlot$224932 = -36					; size = 4
_iDY$224928 = -32					; size = 4
_iDX$224924 = -28					; size = 4
_iPopRange$224923 = -24					; size = 4
_pPlot$224921 = -20					; size = 4
_pCity$224919 = -16					; size = 4
_ePlayer$224916 = -12					; size = 4
_iPlayer$224912 = -8					; size = 4
_bRevealPlots$224911 = -1				; size = 1
_eIndex$ = 8						; size = 4
_bNewValue$ = 12					; size = 1
?SetHasEmbassyAtTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z PROC	; CvTeam::SetHasEmbassyAtTeam, COMDAT
; _this$ = ecx

; 4047 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 188				; 000000bcH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 4048 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4049 : 	CvAssertMsg(eIndex < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 4050 : 
; 4051 : 	if(HasEmbassyAtTeam(eIndex) != bNewValue)

	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasEmbassyAtTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::HasEmbassyAtTeam
	movzx	ecx, al
	movzx	edx, BYTE PTR _bNewValue$[ebp]
	cmp	ecx, edx
	je	$LN28@SetHasEmba

; 4052 : 	{
; 4053 : 		m_abEmbassy[eIndex] = bNewValue;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _eIndex$[ebp]
	mov	cl, BYTE PTR _bNewValue$[ebp]
	mov	BYTE PTR [eax+2088], cl

; 4054 : 		bool bRevealPlots = false;

	mov	BYTE PTR _bRevealPlots$224911[ebp], 0

; 4055 : 
; 4056 : 		// find capital of team
; 4057 : 		// reveal hexes around capital
; 4058 : 		for(int iPlayer = 0; iPlayer < MAX_MAJOR_CIVS; iPlayer++)

	mov	DWORD PTR _iPlayer$224912[ebp], 0
	jmp	SHORT $LN26@SetHasEmba
$LN25@SetHasEmba:
	mov	edx, DWORD PTR _iPlayer$224912[ebp]
	add	edx, 1
	mov	DWORD PTR _iPlayer$224912[ebp], edx
$LN26@SetHasEmba:
	cmp	DWORD PTR _iPlayer$224912[ebp], 22	; 00000016H
	jge	$LN24@SetHasEmba

; 4059 : 		{
; 4060 : 			PlayerTypes ePlayer = (PlayerTypes)iPlayer;

	mov	eax, DWORD PTR _iPlayer$224912[ebp]
	mov	DWORD PTR _ePlayer$224916[ebp], eax

; 4061 : 			if(GET_PLAYER(ePlayer).getTeam() == eIndex)

	mov	ecx, DWORD PTR _ePlayer$224916[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235297[ebp], ecx
	mov	edx, DWORD PTR $T235297[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	eax, DWORD PTR _eIndex$[ebp]
	jne	$LN23@SetHasEmba

; 4062 : 			{
; 4063 : 				CvCity* pCity = GET_PLAYER(ePlayer).getCapitalCity();

	mov	ecx, DWORD PTR _ePlayer$224916[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235309[ebp], ecx
	mov	ecx, DWORD PTR $T235309[ebp]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	DWORD PTR _pCity$224919[ebp], eax

; 4064 : 				if(pCity)

	cmp	DWORD PTR _pCity$224919[ebp], 0
	je	$LN23@SetHasEmba

; 4065 : 				{
; 4066 : 					CvPlot* pPlot = pCity->plot();

	mov	ecx, DWORD PTR _pCity$224919[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	DWORD PTR _pPlot$224921[ebp], eax

; 4067 : 					CvAssertMsg(pPlot, "Capital city lacks plot? How'd that happen?");
; 4068 : 					if(pPlot)

	cmp	DWORD PTR _pPlot$224921[ebp], 0
	je	$LN23@SetHasEmba

; 4069 : 					{
; 4070 : 						const int iPopRange = 2;

	mov	DWORD PTR _iPopRange$224923[ebp], 2

; 4071 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 4072 : 						int iMaxDX, iDX;
; 4073 : 						CvPlot* pLoopPlot;
; 4074 : 						for (int iDY = -iPopRange; iDY <= iPopRange; iDY++)
; 4075 : 						{
; 4076 : 							iMaxDX = iPopRange - MAX(0, iDY);
; 4077 : 							for (iDX = -iPopRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 4078 : 							{
; 4079 : 								// No need for range check because loops are set up properly
; 4080 : 								pLoopPlot = plotXY(pPlot->getX(), pPlot->getY(), iDX, iDY);
; 4081 : #else
; 4082 : 						for(int iDX = -(iPopRange); iDX <= iPopRange; iDX++)

	mov	DWORD PTR _iDX$224924[ebp], -2		; fffffffeH
	jmp	SHORT $LN20@SetHasEmba
$LN19@SetHasEmba:
	mov	edx, DWORD PTR _iDX$224924[ebp]
	add	edx, 1
	mov	DWORD PTR _iDX$224924[ebp], edx
$LN20@SetHasEmba:
	cmp	DWORD PTR _iDX$224924[ebp], 2
	jg	SHORT $LN18@SetHasEmba

; 4083 : 						{
; 4084 : 							for(int iDY = -(iPopRange); iDY <= iPopRange; iDY++)

	mov	DWORD PTR _iDY$224928[ebp], -2		; fffffffeH
	jmp	SHORT $LN17@SetHasEmba
$LN16@SetHasEmba:
	mov	eax, DWORD PTR _iDY$224928[ebp]
	add	eax, 1
	mov	DWORD PTR _iDY$224928[ebp], eax
$LN17@SetHasEmba:
	cmp	DWORD PTR _iDY$224928[ebp], 2
	jg	SHORT $LN15@SetHasEmba

; 4085 : 							{
; 4086 : 								CvPlot* pLoopPlot = plotXYWithRangeCheck(pPlot->getX(), pPlot->getY(), iDX, iDY, iPopRange);

	mov	ecx, DWORD PTR _pPlot$224921[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T235313[ebp], edx
	mov	eax, DWORD PTR _pPlot$224921[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T235317[ebp], ecx
	push	2
	mov	edx, DWORD PTR _iDY$224928[ebp]
	push	edx
	mov	eax, DWORD PTR _iDX$224924[ebp]
	push	eax
	mov	ecx, DWORD PTR $T235313[ebp]
	push	ecx
	mov	edx, DWORD PTR $T235317[ebp]
	push	edx
	call	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ; plotXYWithRangeCheck
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pLoopPlot$224932[ebp], eax

; 4087 : #endif
; 4088 : 								if(pLoopPlot == NULL)

	cmp	DWORD PTR _pLoopPlot$224932[ebp], 0
	jne	SHORT $LN14@SetHasEmba

; 4089 : 								{
; 4090 : 									continue;

	jmp	SHORT $LN16@SetHasEmba
$LN14@SetHasEmba:

; 4091 : 								}
; 4092 : 
; 4093 : 								pLoopPlot->setRevealed(GetID(), true);

	push	-1
	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	ecx, DWORD PTR _pLoopPlot$224932[ebp]
	call	?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z ; CvPlot::setRevealed

; 4094 : 							}

	jmp	SHORT $LN16@SetHasEmba
$LN15@SetHasEmba:

; 4095 : 						}

	jmp	SHORT $LN19@SetHasEmba
$LN18@SetHasEmba:

; 4096 : 						bRevealPlots = true;

	mov	BYTE PTR _bRevealPlots$224911[ebp], 1
$LN23@SetHasEmba:

; 4097 : 					}
; 4098 : 				}
; 4099 : 			}
; 4100 : 		}

	jmp	$LN25@SetHasEmba
$LN24@SetHasEmba:

; 4101 : 
; 4102 : 		if(bRevealPlots)

	movzx	eax, BYTE PTR _bRevealPlots$224911[ebp]
	test	eax, eax
	je	SHORT $LN13@SetHasEmba

; 4103 : 		{
; 4104 : 			GC.getMap().updateDeferredFog();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T235400[ebp], ecx
	mov	ecx, DWORD PTR $T235400[ebp]
	call	?updateDeferredFog@CvMap@@QAEXXZ	; CvMap::updateDeferredFog
$LN13@SetHasEmba:

; 4105 : 		}
; 4106 : 
; 4107 : 		GC.getMap().verifyUnitValidPlot();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T235404[ebp], edx
	mov	ecx, DWORD PTR $T235404[ebp]
	call	?verifyUnitValidPlot@CvMap@@QAEXXZ	; CvMap::verifyUnitValidPlot

; 4108 : 
; 4109 : 		if((GetID() == GC.getGame().getActiveTeam()) || (eIndex == GC.getGame().getActiveTeam()))

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235408[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	mov	esi, eax
	mov	ecx, DWORD PTR $T235408[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	esi, eax
	je	SHORT $LN11@SetHasEmba
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235412[ebp], ecx
	mov	ecx, DWORD PTR $T235412[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	DWORD PTR _eIndex$[ebp], eax
	jne	SHORT $LN12@SetHasEmba
$LN11@SetHasEmba:

; 4110 : 		{
; 4111 : 			DLLUI->setDirty(Score_DIRTY_BIT, true);

	mov	edx, DWORD PTR $T235416[ebp]
	mov	DWORD PTR tv178[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv178[ebp], eax
	push	1
	push	12					; 0000000cH
	mov	ecx, DWORD PTR tv178[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv178[ebp]
	mov	eax, DWORD PTR [edx+260]
	call	eax
$LN12@SetHasEmba:

; 4112 : 		}
; 4113 : 
; 4114 : 		// logging
; 4115 : 		for (uint uiMyPlayer = 0; uiMyPlayer < MAX_MAJOR_CIVS; uiMyPlayer++)

	mov	DWORD PTR _uiMyPlayer$224937[ebp], 0
	jmp	SHORT $LN10@SetHasEmba
$LN9@SetHasEmba:
	mov	ecx, DWORD PTR _uiMyPlayer$224937[ebp]
	add	ecx, 1
	mov	DWORD PTR _uiMyPlayer$224937[ebp], ecx
$LN10@SetHasEmba:
	cmp	DWORD PTR _uiMyPlayer$224937[ebp], 22	; 00000016H
	jae	$LN28@SetHasEmba

; 4116 : 		{
; 4117 : 			PlayerTypes eMyPlayer = (PlayerTypes)uiMyPlayer;

	mov	edx, DWORD PTR _uiMyPlayer$224937[ebp]
	mov	DWORD PTR _eMyPlayer$224941[ebp], edx

; 4118 : 			if (GET_PLAYER(eMyPlayer).getTeam() == m_eID)

	mov	eax, DWORD PTR _eMyPlayer$224941[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235420[ebp], eax
	mov	ecx, DWORD PTR $T235420[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T235429[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T235429[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	$LN7@SetHasEmba

; 4119 : 			{
; 4120 : 				for (uint uiOtherPlayer = 0; uiOtherPlayer < MAX_MAJOR_CIVS; uiOtherPlayer++)

	mov	DWORD PTR _uiOtherPlayer$224944[ebp], 0
	jmp	SHORT $LN6@SetHasEmba
$LN5@SetHasEmba:
	mov	edx, DWORD PTR _uiOtherPlayer$224944[ebp]
	add	edx, 1
	mov	DWORD PTR _uiOtherPlayer$224944[ebp], edx
$LN6@SetHasEmba:
	cmp	DWORD PTR _uiOtherPlayer$224944[ebp], 22 ; 00000016H
	jae	$LN7@SetHasEmba

; 4121 : 				{
; 4122 : 					PlayerTypes eOtherPlayer = (PlayerTypes)uiOtherPlayer;

	mov	eax, DWORD PTR _uiOtherPlayer$224944[ebp]
	mov	DWORD PTR _eOtherPlayer$224948[ebp], eax

; 4123 : 					CvPlayer& kOtherPlayer = GET_PLAYER(eOtherPlayer);

	mov	ecx, DWORD PTR _eOtherPlayer$224948[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kOtherPlayer$224950[ebp], ecx

; 4124 : 					if (kOtherPlayer.getTeam() == eIndex && kOtherPlayer.isAlive())

	mov	edx, DWORD PTR _kOtherPlayer$224950[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	eax, DWORD PTR _eIndex$[ebp]
	jne	SHORT $LN3@SetHasEmba
	mov	ecx, DWORD PTR _kOtherPlayer$224950[ebp]
	mov	dl, BYTE PTR [ecx+2256]
	mov	BYTE PTR $T235449[ebp], dl
	movzx	eax, BYTE PTR $T235449[ebp]
	test	eax, eax
	je	SHORT $LN3@SetHasEmba

; 4125 : 					{
; 4126 : 						if (bNewValue)

	movzx	ecx, BYTE PTR _bNewValue$[ebp]
	test	ecx, ecx
	je	SHORT $LN2@SetHasEmba

; 4127 : 						{
; 4128 : 							GET_PLAYER(eMyPlayer).GetDiplomacyAI()->LogOpenEmbassy(eOtherPlayer);

	mov	edx, DWORD PTR _eMyPlayer$224941[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235453[ebp], edx
	mov	eax, DWORD PTR _eOtherPlayer$224948[ebp]
	push	eax
	mov	ecx, DWORD PTR $T235453[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?LogOpenEmbassy@CvDiplomacyAI@@QAEXW4PlayerTypes@@@Z ; CvDiplomacyAI::LogOpenEmbassy

; 4129 : 						}
; 4130 : 						else

	jmp	SHORT $LN3@SetHasEmba
$LN2@SetHasEmba:

; 4131 : 						{
; 4132 : 							GET_PLAYER(eMyPlayer).GetDiplomacyAI()->LogCloseEmbassy(eOtherPlayer);

	mov	ecx, DWORD PTR _eMyPlayer$224941[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235457[ebp], ecx
	mov	edx, DWORD PTR _eOtherPlayer$224948[ebp]
	push	edx
	mov	ecx, DWORD PTR $T235457[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?LogCloseEmbassy@CvDiplomacyAI@@QAEXW4PlayerTypes@@@Z ; CvDiplomacyAI::LogCloseEmbassy
$LN3@SetHasEmba:

; 4133 : 						}
; 4134 : 					}
; 4135 : 				}

	jmp	$LN5@SetHasEmba
$LN7@SetHasEmba:

; 4136 : 			}
; 4137 : 		}

	jmp	$LN9@SetHasEmba
$LN28@SetHasEmba:

; 4138 : 	}
; 4139 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?SetHasEmbassyAtTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z ENDP	; CvTeam::SetHasEmbassyAtTeam
_TEXT	ENDS
PUBLIC	?plotXY@@YAPAVCvPlot@@HHHH@Z			; plotXY
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z
_TEXT	SEGMENT
tv83 = -96						; size = 4
tv81 = -92						; size = 4
tv78 = -88						; size = 4
tv74 = -84						; size = 4
tv71 = -80						; size = 4
_iAbsDY$216767 = -20					; size = 4
_iAbsDX$216766 = -16					; size = 4
_iAbsDY$216764 = -12					; size = 4
_iAbsDX$216763 = -8					; size = 4
_hexRange$ = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
_iRange$ = 24						; size = 4
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z PROC	; plotXYWithRangeCheck, COMDAT

; 233  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H

; 234  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 235  : 	// I'm assuming iDX and iDY are in hex-space
; 236  : 	if (hexDistance(iDX, iDY) > iRange)
; 237  : #else
; 238  : 	int hexRange;
; 239  : 
; 240  : 	// I'm assuming iDX and iDY are in hex-space
; 241  : 	if((iDX >= 0) == (iDY >= 0))  // the signs match

	xor	eax, eax
	cmp	DWORD PTR _iDX$[ebp], 0
	setge	al
	xor	ecx, ecx
	cmp	DWORD PTR _iDY$[ebp], 0
	setge	cl
	cmp	eax, ecx
	jne	SHORT $LN3@plotXYWith

; 242  : 	{
; 243  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	cmp	DWORD PTR _iDX$[ebp], 0
	jl	SHORT $LN6@plotXYWith
	mov	edx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv71[ebp], edx
	jmp	SHORT $LN7@plotXYWith
$LN6@plotXYWith:
	mov	eax, DWORD PTR _iDX$[ebp]
	neg	eax
	mov	DWORD PTR tv71[ebp], eax
$LN7@plotXYWith:
	mov	ecx, DWORD PTR tv71[ebp]
	mov	DWORD PTR _iAbsDX$216763[ebp], ecx

; 244  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	cmp	DWORD PTR _iDY$[ebp], 0
	jl	SHORT $LN8@plotXYWith
	mov	edx, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv74[ebp], edx
	jmp	SHORT $LN9@plotXYWith
$LN8@plotXYWith:
	mov	eax, DWORD PTR _iDY$[ebp]
	neg	eax
	mov	DWORD PTR tv74[ebp], eax
$LN9@plotXYWith:
	mov	ecx, DWORD PTR tv74[ebp]
	mov	DWORD PTR _iAbsDY$216764[ebp], ecx

; 245  : 		hexRange = iAbsDX + iAbsDY;

	mov	edx, DWORD PTR _iAbsDX$216763[ebp]
	add	edx, DWORD PTR _iAbsDY$216764[ebp]
	mov	DWORD PTR _hexRange$[ebp], edx

; 246  : 	}
; 247  : 	else

	jmp	SHORT $LN2@plotXYWith
$LN3@plotXYWith:

; 248  : 	{
; 249  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	cmp	DWORD PTR _iDX$[ebp], 0
	jl	SHORT $LN10@plotXYWith
	mov	eax, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $LN11@plotXYWith
$LN10@plotXYWith:
	mov	ecx, DWORD PTR _iDX$[ebp]
	neg	ecx
	mov	DWORD PTR tv78[ebp], ecx
$LN11@plotXYWith:
	mov	edx, DWORD PTR tv78[ebp]
	mov	DWORD PTR _iAbsDX$216766[ebp], edx

; 250  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	cmp	DWORD PTR _iDY$[ebp], 0
	jl	SHORT $LN12@plotXYWith
	mov	eax, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv81[ebp], eax
	jmp	SHORT $LN13@plotXYWith
$LN12@plotXYWith:
	mov	ecx, DWORD PTR _iDY$[ebp]
	neg	ecx
	mov	DWORD PTR tv81[ebp], ecx
$LN13@plotXYWith:
	mov	edx, DWORD PTR tv81[ebp]
	mov	DWORD PTR _iAbsDY$216767[ebp], edx

; 251  : 		hexRange = iAbsDX >= iAbsDY ? iAbsDX : iAbsDY;

	mov	eax, DWORD PTR _iAbsDX$216766[ebp]
	cmp	eax, DWORD PTR _iAbsDY$216767[ebp]
	jl	SHORT $LN14@plotXYWith
	mov	ecx, DWORD PTR _iAbsDX$216766[ebp]
	mov	DWORD PTR tv83[ebp], ecx
	jmp	SHORT $LN15@plotXYWith
$LN14@plotXYWith:
	mov	edx, DWORD PTR _iAbsDY$216767[ebp]
	mov	DWORD PTR tv83[ebp], edx
$LN15@plotXYWith:
	mov	eax, DWORD PTR tv83[ebp]
	mov	DWORD PTR _hexRange$[ebp], eax
$LN2@plotXYWith:

; 252  : 	}
; 253  : 
; 254  : 	if(hexRange > iRange)

	mov	ecx, DWORD PTR _hexRange$[ebp]
	cmp	ecx, DWORD PTR _iRange$[ebp]
	jle	SHORT $LN1@plotXYWith

; 255  : #endif
; 256  : 	{
; 257  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN4@plotXYWith
$LN1@plotXYWith:

; 258  : 	}
; 259  : 
; 260  : 	return plotXY(iX, iY, iDX, iDY);

	mov	edx, DWORD PTR _iDY$[ebp]
	push	edx
	mov	eax, DWORD PTR _iDX$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iX$[ebp]
	push	edx
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	add	esp, 16					; 00000010H
$LN4@plotXYWith:

; 261  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ENDP	; plotXYWithRangeCheck
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?plotXY@@YAPAVCvPlot@@HHHH@Z
_TEXT	SEGMENT
tv148 = -72						; size = 4
tv163 = -68						; size = 4
tv86 = -64						; size = 4
tv82 = -60						; size = 4
$T235712 = -56						; size = 4
$T235667 = -52						; size = 4
$T235654 = -48						; size = 4
$T235650 = -44						; size = 4
$T235636 = -40						; size = 4
$T235632 = -33						; size = 1
$T235621 = -32						; size = 4
$T235617 = -25						; size = 1
_iMapY$235711 = -24					; size = 4
_iMapX$235710 = -20					; size = 4
$T235610 = -16						; size = 4
_iPlotHexX$ = -12					; size = 4
_iPlotY$ = -8						; size = 4
_iStartHexX$ = -4					; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
?plotXY@@YAPAVCvPlot@@HHHH@Z PROC			; plotXY, COMDAT

; 213  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H

; 214  : 	// convert the start coord to hex-space coordinates
; 215  : 	int iStartHexX = xToHexspaceX(iX, iY);

	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN5@plotXY
	mov	eax, DWORD PTR _iY$[ebp]
	sar	eax, 1
	mov	DWORD PTR tv82[ebp], eax
	jmp	SHORT $LN3@plotXY
$LN5@plotXY:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv82[ebp], eax
$LN3@plotXY:
	mov	ecx, DWORD PTR _iX$[ebp]
	sub	ecx, DWORD PTR tv82[ebp]
	mov	DWORD PTR _iStartHexX$[ebp], ecx

; 216  : 
; 217  : 	int iPlotHexX = iStartHexX + iDX;

	mov	edx, DWORD PTR _iStartHexX$[ebp]
	add	edx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR _iPlotHexX$[ebp], edx

; 218  : 	int iPlotY = iY + iDY; // Y is the same in both coordinate systems

	mov	eax, DWORD PTR _iY$[ebp]
	add	eax, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR _iPlotY$[ebp], eax

; 219  : 
; 220  : 	// convert from hex-space coordinates to the storage array
; 221  : 	iPlotHexX = hexspaceXToX(iPlotHexX, iPlotY);

	js	SHORT $LN9@plotXY
	mov	ecx, DWORD PTR _iPlotY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv86[ebp], ecx
	jmp	SHORT $LN7@plotXY
$LN9@plotXY:
	mov	eax, DWORD PTR _iPlotY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv86[ebp], eax
$LN7@plotXY:
	mov	edx, DWORD PTR _iPlotHexX$[ebp]
	add	edx, DWORD PTR tv86[ebp]
	mov	DWORD PTR _iPlotHexX$[ebp], edx

; 222  : 
; 223  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T235610[ebp], eax
	cmp	DWORD PTR _iPlotHexX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN13@plotXY
	cmp	DWORD PTR _iPlotY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN14@plotXY
$LN13@plotXY:
	mov	DWORD PTR $T235712[ebp], 0
	jmp	$LN15@plotXY
$LN14@plotXY:
	mov	ecx, DWORD PTR $T235610[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T235617[ebp], dl
	mov	eax, DWORD PTR $T235610[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T235621[ebp], ecx
	movzx	edx, BYTE PTR $T235617[ebp]
	test	edx, edx
	je	SHORT $LN26@plotXY
	cmp	DWORD PTR _iPlotHexX$[ebp], 0
	jge	SHORT $LN25@plotXY
	mov	eax, DWORD PTR _iPlotHexX$[ebp]
	cdq
	idiv	DWORD PTR $T235621[ebp]
	add	edx, DWORD PTR $T235621[ebp]
	mov	DWORD PTR _iMapX$235710[ebp], edx
	jmp	SHORT $LN27@plotXY
	jmp	SHORT $LN26@plotXY
$LN25@plotXY:
	mov	eax, DWORD PTR _iPlotHexX$[ebp]
	cmp	eax, DWORD PTR $T235621[ebp]
	jl	SHORT $LN26@plotXY
	mov	eax, DWORD PTR _iPlotHexX$[ebp]
	cdq
	idiv	DWORD PTR $T235621[ebp]
	mov	DWORD PTR _iMapX$235710[ebp], edx
	jmp	SHORT $LN27@plotXY
$LN26@plotXY:
	mov	ecx, DWORD PTR _iPlotHexX$[ebp]
	mov	DWORD PTR _iMapX$235710[ebp], ecx
$LN27@plotXY:
	mov	edx, DWORD PTR $T235610[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T235632[ebp], al
	mov	ecx, DWORD PTR $T235610[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T235636[ebp], edx
	movzx	eax, BYTE PTR $T235632[ebp]
	test	eax, eax
	je	SHORT $LN36@plotXY
	cmp	DWORD PTR _iPlotY$[ebp], 0
	jge	SHORT $LN35@plotXY
	mov	eax, DWORD PTR _iPlotY$[ebp]
	cdq
	idiv	DWORD PTR $T235636[ebp]
	add	edx, DWORD PTR $T235636[ebp]
	mov	DWORD PTR _iMapY$235711[ebp], edx
	jmp	SHORT $LN37@plotXY
	jmp	SHORT $LN36@plotXY
$LN35@plotXY:
	mov	ecx, DWORD PTR _iPlotY$[ebp]
	cmp	ecx, DWORD PTR $T235636[ebp]
	jl	SHORT $LN36@plotXY
	mov	eax, DWORD PTR _iPlotY$[ebp]
	cdq
	idiv	DWORD PTR $T235636[ebp]
	mov	DWORD PTR _iMapY$235711[ebp], edx
	jmp	SHORT $LN37@plotXY
$LN36@plotXY:
	mov	edx, DWORD PTR _iPlotY$[ebp]
	mov	DWORD PTR _iMapY$235711[ebp], edx
$LN37@plotXY:
	cmp	DWORD PTR _iMapX$235710[ebp], 0
	jl	SHORT $LN41@plotXY
	mov	eax, DWORD PTR $T235610[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T235650[ebp], ecx
	mov	edx, DWORD PTR _iMapX$235710[ebp]
	cmp	edx, DWORD PTR $T235650[ebp]
	jge	SHORT $LN41@plotXY
	cmp	DWORD PTR _iMapY$235711[ebp], 0
	jl	SHORT $LN41@plotXY
	mov	eax, DWORD PTR $T235610[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T235654[ebp], ecx
	mov	edx, DWORD PTR _iMapY$235711[ebp]
	cmp	edx, DWORD PTR $T235654[ebp]
	jge	SHORT $LN41@plotXY
	mov	DWORD PTR tv163[ebp], 1
	jmp	SHORT $LN39@plotXY
$LN41@plotXY:
	mov	DWORD PTR tv163[ebp], 0
$LN39@plotXY:
	cmp	DWORD PTR tv163[ebp], 0
	je	SHORT $LN17@plotXY
	mov	eax, DWORD PTR $T235610[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T235667[ebp], ecx
	mov	edx, DWORD PTR _iMapY$235711[ebp]
	imul	edx, DWORD PTR $T235667[ebp]
	add	edx, DWORD PTR _iMapX$235710[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T235610[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv148[ebp], edx
	jmp	SHORT $LN18@plotXY
$LN17@plotXY:
	mov	DWORD PTR tv148[ebp], 0
$LN18@plotXY:
	mov	ecx, DWORD PTR tv148[ebp]
	mov	DWORD PTR $T235712[ebp], ecx
$LN15@plotXY:
	mov	eax, DWORD PTR $T235712[ebp]

; 224  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotXY@@YAPAVCvPlot@@HHHH@Z ENDP			; plotXY
_TEXT	ENDS
PUBLIC	??_C@_0CJ@LPCKKMJK@TXT_KEY_NOTIFICATION_DIPLOMAT_EJ@ ; `string'
PUBLIC	??_C@_0CG@JNHLKBIN@TXT_KEY_NOTIFICATION_DIPLOMAT_EJ@ ; `string'
EXTRN	?MoveSpyTo@CvPlayerEspionage@@QAE_NPAVCvCity@@I_N@Z:PROC ; CvPlayerEspionage::MoveSpyTo
EXTRN	?getNameKey@CvCity@@QBEPBDXZ:PROC		; CvCity::getNameKey
EXTRN	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z:PROC	; CvCivilizationInfo::getSpyNames
EXTRN	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ:PROC ; CvPlayer::getCivilizationInfo
EXTRN	?GetSpyRankName@CvPlayerEspionage@@QBEPBDH@Z:PROC ; CvPlayerEspionage::GetSpyRankName
EXTRN	?GetSpyIndexInCity@CvPlayerEspionage@@QAEHPAVCvCity@@@Z:PROC ; CvPlayerEspionage::GetSpyIndexInCity
EXTRN	?IsMyDiplomatVisitingThem@CvPlayerEspionage@@QAE_NW4PlayerTypes@@_N@Z:PROC ; CvPlayerEspionage::IsMyDiplomatVisitingThem
EXTRN	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ:PROC ; CvPlayer::GetEspionage
;	COMDAT ??_C@_0CJ@LPCKKMJK@TXT_KEY_NOTIFICATION_DIPLOMAT_EJ@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
CONST	SEGMENT
??_C@_0CJ@LPCKKMJK@TXT_KEY_NOTIFICATION_DIPLOMAT_EJ@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_DIPLOMAT_EJECTED_TT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@JNHLKBIN@TXT_KEY_NOTIFICATION_DIPLOMAT_EJ@
CONST	SEGMENT
??_C@_0CG@JNHLKBIN@TXT_KEY_NOTIFICATION_DIPLOMAT_EJ@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_DIPLOMAT_EJECTED', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?EvacuateDiplomatsAtTeam@CvTeam@@QAEXW4TeamTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?EvacuateDiplomatsAtTeam@CvTeam@@QAEXW4TeamTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?EvacuateDiplomatsAtTeam@CvTeam@@QAEXW4TeamTypes@@@Z$1
__ehfuncinfo$?EvacuateDiplomatsAtTeam@CvTeam@@QAEXW4TeamTypes@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?EvacuateDiplomatsAtTeam@CvTeam@@QAEXW4TeamTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?EvacuateDiplomatsAtTeam@CvTeam@@QAEXW4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -268						; size = 4
$T235778 = -264						; size = 4
$T235774 = -260						; size = 4
$T235764 = -256						; size = 4
$T235760 = -252						; size = 4
$T235756 = -248						; size = 4
$T235752 = -244						; size = 4
$T235748 = -240						; size = 4
$T235736 = -236						; size = 4
$T235732 = -232						; size = 4
$T235723 = -228						; size = 4
$T235717 = -224						; size = 4
$T235716 = -220						; size = 4
$T235715 = -216						; size = 4
_strNotification$224984 = -212				; size = 80
_strSummary$224981 = -132				; size = 80
_pEspionage$224978 = -52				; size = 4
_eSpyRank$224980 = -48					; size = 4
_iSpyName$224979 = -44					; size = 4
_pNotifications$224976 = -40				; size = 4
_pCapitalCity$224973 = -36				; size = 4
_iSpyIndex$224974 = -32					; size = 4
_ePlayer2$224969 = -28					; size = 4
_iPlayer2$224965 = -24					; size = 4
_ePlayer1$224962 = -20					; size = 4
_iPlayer$224958 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_eIndex$ = 8						; size = 4
?EvacuateDiplomatsAtTeam@CvTeam@@QAEXW4TeamTypes@@@Z PROC ; CvTeam::EvacuateDiplomatsAtTeam, COMDAT
; _this$ = ecx

; 4143 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?EvacuateDiplomatsAtTeam@CvTeam@@QAEXW4TeamTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 256				; 00000100H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 4144 : 	for (int iPlayer = 0; iPlayer < MAX_MAJOR_CIVS; iPlayer++)

	mov	DWORD PTR _iPlayer$224958[ebp], 0
	jmp	SHORT $LN11@EvacuateDi
$LN10@EvacuateDi:
	mov	eax, DWORD PTR _iPlayer$224958[ebp]
	add	eax, 1
	mov	DWORD PTR _iPlayer$224958[ebp], eax
$LN11@EvacuateDi:
	cmp	DWORD PTR _iPlayer$224958[ebp], 22	; 00000016H
	jge	$LN12@EvacuateDi

; 4145 : 	{
; 4146 : 		PlayerTypes ePlayer1 = (PlayerTypes)iPlayer;

	mov	ecx, DWORD PTR _iPlayer$224958[ebp]
	mov	DWORD PTR _ePlayer1$224962[ebp], ecx

; 4147 : 		if (GET_PLAYER(ePlayer1).getTeam() == m_eID)

	mov	edx, DWORD PTR _ePlayer1$224962[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235723[ebp], edx
	mov	eax, DWORD PTR $T235723[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T235732[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T235732[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jne	$LN8@EvacuateDi

; 4148 : 		{
; 4149 : 			for (int iPlayer2 = 0; iPlayer2 < MAX_MAJOR_CIVS; iPlayer2++)

	mov	DWORD PTR _iPlayer2$224965[ebp], 0
	jmp	SHORT $LN7@EvacuateDi
$LN6@EvacuateDi:
	mov	ecx, DWORD PTR _iPlayer2$224965[ebp]
	add	ecx, 1
	mov	DWORD PTR _iPlayer2$224965[ebp], ecx
$LN7@EvacuateDi:
	cmp	DWORD PTR _iPlayer2$224965[ebp], 22	; 00000016H
	jge	$LN8@EvacuateDi

; 4150 : 			{
; 4151 : 				PlayerTypes ePlayer2 = (PlayerTypes)iPlayer2;

	mov	edx, DWORD PTR _iPlayer2$224965[ebp]
	mov	DWORD PTR _ePlayer2$224969[ebp], edx

; 4152 : 				if (GET_PLAYER(ePlayer2).getTeam() != eIndex)

	mov	eax, DWORD PTR _ePlayer2$224969[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235736[ebp], eax
	mov	ecx, DWORD PTR $T235736[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	eax, DWORD PTR _eIndex$[ebp]
	je	SHORT $LN4@EvacuateDi

; 4153 : 				{
; 4154 : 					continue;

	jmp	SHORT $LN6@EvacuateDi
$LN4@EvacuateDi:

; 4155 : 				}
; 4156 : 
; 4157 : 				if (GET_PLAYER(ePlayer1).GetEspionage()->IsMyDiplomatVisitingThem(ePlayer2, true))

	mov	eax, DWORD PTR _ePlayer1$224962[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235748[ebp], eax
	push	1
	mov	ecx, DWORD PTR _ePlayer2$224969[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T235748[ebp]
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	ecx, eax
	call	?IsMyDiplomatVisitingThem@CvPlayerEspionage@@QAE_NW4PlayerTypes@@_N@Z ; CvPlayerEspionage::IsMyDiplomatVisitingThem
	movzx	edx, al
	test	edx, edx
	je	$LN3@EvacuateDi

; 4158 : 				{
; 4159 : 					CvCity* pCapitalCity = GET_PLAYER(ePlayer2).getCapitalCity();

	mov	eax, DWORD PTR _ePlayer2$224969[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235752[ebp], eax
	mov	ecx, DWORD PTR $T235752[ebp]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	DWORD PTR _pCapitalCity$224973[ebp], eax

; 4160 : 					int iSpyIndex = GET_PLAYER(ePlayer1).GetEspionage()->GetSpyIndexInCity(pCapitalCity);

	mov	ecx, DWORD PTR _ePlayer1$224962[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235756[ebp], ecx
	mov	edx, DWORD PTR _pCapitalCity$224973[ebp]
	push	edx
	mov	ecx, DWORD PTR $T235756[ebp]
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	ecx, eax
	call	?GetSpyIndexInCity@CvPlayerEspionage@@QAEHPAVCvCity@@@Z ; CvPlayerEspionage::GetSpyIndexInCity
	mov	DWORD PTR _iSpyIndex$224974[ebp], eax

; 4161 : 					if (iSpyIndex != -1)

	cmp	DWORD PTR _iSpyIndex$224974[ebp], -1
	je	$LN3@EvacuateDi

; 4162 : 					{
; 4163 : 						CvNotifications* pNotifications = GET_PLAYER(ePlayer1).GetNotifications();

	mov	eax, DWORD PTR _ePlayer1$224962[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235760[ebp], eax
	mov	ecx, DWORD PTR $T235760[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotifications$224976[ebp], eax

; 4164 : 						if(pNotifications)

	cmp	DWORD PTR _pNotifications$224976[ebp], 0
	je	$LN1@EvacuateDi

; 4165 : 						{
; 4166 : 							CvPlayerEspionage* pEspionage = GET_PLAYER(ePlayer1).GetEspionage();

	mov	ecx, DWORD PTR _ePlayer1$224962[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235764[ebp], ecx
	mov	ecx, DWORD PTR $T235764[ebp]
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	DWORD PTR _pEspionage$224978[ebp], eax

; 4167 : 							int iSpyName = pEspionage->m_aSpyList[iSpyIndex].m_iName;

	mov	edx, DWORD PTR _iSpyIndex$224974[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR _pEspionage$224978[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _iSpyName$224979[ebp], edx

; 4168 : 							CvSpyRank eSpyRank = pEspionage->m_aSpyList[iSpyIndex].m_eRank;

	mov	eax, DWORD PTR _iSpyIndex$224974[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _pEspionage$224978[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax+12]
	mov	DWORD PTR _eSpyRank$224980[ebp], eax

; 4169 : 							Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_DIPLOMAT_EJECTED");

	push	OFFSET ??_C@_0CG@JNHLKBIN@TXT_KEY_NOTIFICATION_DIPLOMAT_EJ@
	lea	ecx, DWORD PTR _strSummary$224981[ebp]
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4170 : 							Localization::String strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_DIPLOMAT_EJECTED_TT");

	push	OFFSET ??_C@_0CJ@LPCKKMJK@TXT_KEY_NOTIFICATION_DIPLOMAT_EJ@
	lea	edx, DWORD PTR _strNotification$224984[ebp]
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 4171 : 							strNotification << pEspionage->GetSpyRankName(eSpyRank);

	mov	eax, DWORD PTR _eSpyRank$224980[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEspionage$224978[ebp]
	call	?GetSpyRankName@CvPlayerEspionage@@QBEPBDH@Z ; CvPlayerEspionage::GetSpyRankName
	mov	DWORD PTR $T235715[ebp], eax
	lea	ecx, DWORD PTR $T235715[ebp]
	push	ecx
	lea	edx, DWORD PTR _strNotification$224984[ebp]
	push	edx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 4172 : 							strNotification << GET_PLAYER(ePlayer1).getCivilizationInfo().getSpyNames(iSpyName);

	mov	eax, DWORD PTR _ePlayer1$224962[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235774[ebp], eax
	mov	ecx, DWORD PTR _iSpyName$224979[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T235774[ebp]
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames
	mov	DWORD PTR $T235716[ebp], eax
	lea	edx, DWORD PTR $T235716[ebp]
	push	edx
	lea	eax, DWORD PTR _strNotification$224984[ebp]
	push	eax
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 4173 : 							strNotification << pCapitalCity->getNameKey();

	mov	ecx, DWORD PTR _pCapitalCity$224973[ebp]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	mov	DWORD PTR $T235717[ebp], eax
	lea	ecx, DWORD PTR $T235717[ebp]
	push	ecx
	lea	edx, DWORD PTR _strNotification$224984[ebp]
	push	edx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 4174 : 							pNotifications->Add(NOTIFICATION_SPY_CANT_STEAL_TECH, strNotification.toUTF8(), strSummary.toUTF8(), -1, -1, -1);

	push	-1
	push	-1
	push	-1
	push	-1
	lea	ecx, DWORD PTR _strSummary$224981[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strNotification$224984[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	push	240697813				; 0e58c1d5H
	mov	ecx, DWORD PTR _pNotifications$224976[ebp]
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 4175 : 						}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strNotification$224984[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strSummary$224981[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN1@EvacuateDi:

; 4176 : 						GET_PLAYER(ePlayer1).GetEspionage()->MoveSpyTo(NULL, iSpyIndex, false);

	mov	eax, DWORD PTR _ePlayer1$224962[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235778[ebp], eax
	push	0
	mov	ecx, DWORD PTR _iSpyIndex$224974[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR $T235778[ebp]
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	ecx, eax
	call	?MoveSpyTo@CvPlayerEspionage@@QAE_NPAVCvCity@@I_N@Z ; CvPlayerEspionage::MoveSpyTo
$LN3@EvacuateDi:

; 4177 : 					}
; 4178 : 				}

	jmp	$LN6@EvacuateDi
$LN8@EvacuateDi:

; 4179 : 			}

	jmp	$LN10@EvacuateDi
$LN12@EvacuateDi:

; 4180 : 		}
; 4181 : 	}
; 4182 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?EvacuateDiplomatsAtTeam@CvTeam@@QAEXW4TeamTypes@@@Z$0:
	lea	ecx, DWORD PTR _strSummary$224981[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?EvacuateDiplomatsAtTeam@CvTeam@@QAEXW4TeamTypes@@@Z$1:
	lea	ecx, DWORD PTR _strNotification$224984[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__ehhandler$?EvacuateDiplomatsAtTeam@CvTeam@@QAEXW4TeamTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-260]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?EvacuateDiplomatsAtTeam@CvTeam@@QAEXW4TeamTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?EvacuateDiplomatsAtTeam@CvTeam@@QAEXW4TeamTypes@@@Z ENDP ; CvTeam::EvacuateDiplomatsAtTeam
; Function compile flags: /Odtp
;	COMDAT ?IsAllowsOpenBordersToTeam@CvTeam@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?IsAllowsOpenBordersToTeam@CvTeam@@QBE_NW4TeamTypes@@@Z PROC ; CvTeam::IsAllowsOpenBordersToTeam, COMDAT
; _this$ = ecx

; 4186 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4187 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4188 : 	CvAssertMsg(eIndex < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 4189 : 
; 4190 : 	if(GetLiberatedByTeam() == eIndex && !isAtWar(eIndex))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLiberatedByTeam@CvTeam@@QBE?AW4TeamTypes@@XZ ; CvTeam::GetLiberatedByTeam
	cmp	eax, DWORD PTR _eIndex$[ebp]
	jne	SHORT $LN4@IsAllowsOp
	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN4@IsAllowsOp

; 4191 : 	{
; 4192 : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@IsAllowsOp

; 4193 : 	}
; 4194 : 
; 4195 : 	return m_abOpenBorders[eIndex];

$LN4@IsAllowsOp:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR _eIndex$[ebp]
	mov	al, BYTE PTR [edx+2168]
$LN2@IsAllowsOp:

; 4196 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsAllowsOpenBordersToTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ENDP ; CvTeam::IsAllowsOpenBordersToTeam
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?SetAllowsOpenBordersToTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z
_TEXT	SEGMENT
tv128 = -24						; size = 4
_this$ = -20						; size = 4
$T235810 = -16						; size = 4
$T235806 = -12						; size = 4
$T235802 = -8						; size = 4
$T235798 = -4						; size = 4
_eIndex$ = 8						; size = 4
_bNewValue$ = 12					; size = 1
?SetAllowsOpenBordersToTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z PROC ; CvTeam::SetAllowsOpenBordersToTeam, COMDAT
; _this$ = ecx

; 4201 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 4202 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4203 : 	CvAssertMsg(eIndex < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 4204 : 
; 4205 : 	if(IsAllowsOpenBordersToTeam(eIndex) != bNewValue)

	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsAllowsOpenBordersToTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsAllowsOpenBordersToTeam
	movzx	ecx, al
	movzx	edx, BYTE PTR _bNewValue$[ebp]
	cmp	ecx, edx
	je	SHORT $LN4@SetAllowsO

; 4206 : 	{
; 4207 : 		m_abOpenBorders[eIndex] = bNewValue;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _eIndex$[ebp]
	mov	cl, BYTE PTR _bNewValue$[ebp]
	mov	BYTE PTR [eax+2168], cl

; 4208 : 
; 4209 : 		GC.getMap().verifyUnitValidPlot();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T235798[ebp], edx
	mov	ecx, DWORD PTR $T235798[ebp]
	call	?verifyUnitValidPlot@CvMap@@QAEXXZ	; CvMap::verifyUnitValidPlot

; 4210 : 
; 4211 : 		if((GetID() == GC.getGame().getActiveTeam()) || (eIndex == GC.getGame().getActiveTeam()))

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235802[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	mov	esi, eax
	mov	ecx, DWORD PTR $T235802[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	esi, eax
	je	SHORT $LN1@SetAllowsO
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235806[ebp], ecx
	mov	ecx, DWORD PTR $T235806[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	DWORD PTR _eIndex$[ebp], eax
	jne	SHORT $LN4@SetAllowsO
$LN1@SetAllowsO:

; 4212 : 		{
; 4213 : 			DLLUI->setDirty(Score_DIRTY_BIT, true);

	mov	edx, DWORD PTR $T235810[ebp]
	mov	DWORD PTR tv128[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv128[ebp], eax
	push	1
	push	12					; 0000000cH
	mov	ecx, DWORD PTR tv128[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv128[ebp]
	mov	eax, DWORD PTR [edx+260]
	call	eax
$LN4@SetAllowsO:

; 4214 : 		}
; 4215 : 	}
; 4216 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?SetAllowsOpenBordersToTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z ENDP ; CvTeam::SetAllowsOpenBordersToTeam
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsHasDefensivePact@CvTeam@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?IsHasDefensivePact@CvTeam@@QBE_NW4TeamTypes@@@Z PROC	; CvTeam::IsHasDefensivePact, COMDAT
; _this$ = ecx

; 4221 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4222 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4223 : 	CvAssertMsg(eIndex < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 4224 : 	return m_abDefensivePact[eIndex];

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _eIndex$[ebp]
	mov	al, BYTE PTR [eax+2248]

; 4225 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsHasDefensivePact@CvTeam@@QBE_NW4TeamTypes@@@Z ENDP	; CvTeam::IsHasDefensivePact
_TEXT	ENDS
PUBLIC	??_C@_0CJ@FFPMPLHJ@TXT_KEY_MISC_PLAYERS_SIGN_DEFENS@ ; `string'
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_0CJ@FFPMPLHJ@TXT_KEY_MISC_PLAYERS_SIGN_DEFENS@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0CJ@FFPMPLHJ@TXT_KEY_MISC_PLAYERS_SIGN_DEFENS@ DB 'TXT_KEY_MISC_PLA'
	DB	'YERS_SIGN_DEFENSIVE_PACT', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z$2
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z
_TEXT	SEGMENT
tv204 = -156						; size = 4
tv162 = -152						; size = 4
tv93 = -148						; size = 4
_this$ = -144						; size = 4
$T235868 = -140						; size = 4
$T235856 = -136						; size = 4
$T235852 = -132						; size = 4
$T235848 = -128						; size = 4
$T235844 = -124						; size = 4
$T235840 = -120						; size = 4
$T235836 = -116						; size = 4
$T235832 = -112						; size = 4
$T235822 = -108						; size = 28
$T235821 = -80						; size = 4
$T235820 = -76						; size = 28
$T235819 = -48						; size = 4
_strBuffer$225016 = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_eIndex$ = 8						; size = 4
_bNewValue$ = 12					; size = 1
?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z PROC	; CvTeam::SetHasDefensivePact, COMDAT
; _this$ = ecx

; 4230 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 144				; 00000090H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 4231 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4232 : 	CvAssertMsg(eIndex < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 4233 : 
; 4234 : 	if(IsHasDefensivePact(eIndex) != bNewValue)

	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHasDefensivePact@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsHasDefensivePact
	movzx	ecx, al
	movzx	edx, BYTE PTR _bNewValue$[ebp]
	cmp	ecx, edx
	je	$LN5@SetHasDefe

; 4235 : 	{
; 4236 : 		m_abDefensivePact[eIndex] = bNewValue;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _eIndex$[ebp]
	mov	cl, BYTE PTR _bNewValue$[ebp]
	mov	BYTE PTR [eax+2248], cl

; 4237 : 
; 4238 : 		if((GetID() == GC.getGame().getActiveTeam()) || (eIndex == GC.getGame().getActiveTeam()))

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235832[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	mov	esi, eax
	mov	ecx, DWORD PTR $T235832[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	esi, eax
	je	SHORT $LN2@SetHasDefe
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235836[ebp], eax
	mov	ecx, DWORD PTR $T235836[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	DWORD PTR _eIndex$[ebp], eax
	jne	SHORT $LN3@SetHasDefe
$LN2@SetHasDefe:

; 4239 : 		{
; 4240 : 			DLLUI->setDirty(Score_DIRTY_BIT, true);

	mov	ecx, DWORD PTR $T235840[ebp]
	mov	DWORD PTR tv93[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv93[ebp], edx
	push	1
	push	12					; 0000000cH
	mov	eax, DWORD PTR tv93[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv93[ebp]
	mov	eax, DWORD PTR [edx+260]
	call	eax
$LN3@SetHasDefe:

; 4241 : 		}
; 4242 : 
; 4243 : 		if(bNewValue && !GET_TEAM(eIndex).IsHasDefensivePact(GetID()))

	movzx	ecx, BYTE PTR _bNewValue$[ebp]
	test	ecx, ecx
	je	$LN5@SetHasDefe
	mov	edx, DWORD PTR _eIndex$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T235844[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	ecx, DWORD PTR $T235844[ebp]
	call	?IsHasDefensivePact@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsHasDefensivePact
	movzx	eax, al
	test	eax, eax
	jne	$LN5@SetHasDefe

; 4244 : 		{
; 4245 : 			CvString strBuffer = GetLocalizedText("TXT_KEY_MISC_PLAYERS_SIGN_DEFENSIVE_PACT", getName().GetCString(), GET_TEAM(eIndex).getName().GetCString());

	mov	ecx, DWORD PTR _eIndex$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T235848[ebp], ecx
	lea	edx, DWORD PTR $T235820[ebp]
	push	edx
	mov	ecx, DWORD PTR $T235848[ebp]
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	DWORD PTR tv162[ebp], eax
	mov	eax, DWORD PTR tv162[ebp]
	mov	DWORD PTR $T235852[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR $T235852[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T235819[ebp], eax
	lea	ecx, DWORD PTR $T235822[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	DWORD PTR tv204[ebp], eax
	mov	edx, DWORD PTR tv204[ebp]
	mov	DWORD PTR $T235856[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR $T235856[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T235821[ebp], eax
	lea	eax, DWORD PTR $T235819[ebp]
	push	eax
	lea	ecx, DWORD PTR $T235821[ebp]
	push	ecx
	push	OFFSET ??_C@_0CJ@FFPMPLHJ@TXT_KEY_MISC_PLAYERS_SIGN_DEFENS@
	lea	edx, DWORD PTR _strBuffer$225016[ebp]
	push	edx
	call	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
	add	esp, 16					; 00000010H
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T235822[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T235820[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4246 : 			GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, getLeaderID(), strBuffer, -1, -1);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235868[ebp], eax
	push	-1
	push	-1
	lea	ecx, DWORD PTR _strBuffer$225016[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	push	eax
	push	0
	mov	ecx, DWORD PTR $T235868[ebp]
	call	?addReplayMessage@CvGame@@QAEXW4ReplayMessageTypes@@W4PlayerTypes@@ABVCvString@@HH@Z ; CvGame::addReplayMessage

; 4247 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strBuffer$225016[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN5@SetHasDefe:

; 4248 : 	}
; 4249 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z$0:
	lea	ecx, DWORD PTR $T235820[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z$1:
	lea	ecx, DWORD PTR $T235822[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z$2:
	lea	ecx, DWORD PTR _strBuffer$225016[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-152]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z ENDP	; CvTeam::SetHasDefensivePact
PUBLIC	?IsHasResearchAgreement@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsHasResearchAgreement
PUBLIC	?GetTotalNumResearchAgreements@CvTeam@@QBEHXZ	; CvTeam::GetTotalNumResearchAgreements
; Function compile flags: /Odtp
;	COMDAT ?GetTotalNumResearchAgreements@CvTeam@@QBEHXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T235884 = -16						; size = 4
_iTeamLoop$225028 = -12					; size = 4
_iCount$ = -8						; size = 4
_eLoopTeam$ = -4					; size = 4
?GetTotalNumResearchAgreements@CvTeam@@QBEHXZ PROC	; CvTeam::GetTotalNumResearchAgreements, COMDAT
; _this$ = ecx

; 4253 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 4254 : 	int iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0

; 4255 : 
; 4256 : 	TeamTypes eLoopTeam;
; 4257 : 	for(int iTeamLoop = 0; iTeamLoop < MAX_CIV_TEAMS; iTeamLoop++)

	mov	DWORD PTR _iTeamLoop$225028[ebp], 0
	jmp	SHORT $LN5@GetTotalNu
$LN4@GetTotalNu:
	mov	eax, DWORD PTR _iTeamLoop$225028[ebp]
	add	eax, 1
	mov	DWORD PTR _iTeamLoop$225028[ebp], eax
$LN5@GetTotalNu:
	cmp	DWORD PTR _iTeamLoop$225028[ebp], 63	; 0000003fH
	jge	SHORT $LN3@GetTotalNu

; 4258 : 	{
; 4259 : 		eLoopTeam = (TeamTypes) iTeamLoop;

	mov	ecx, DWORD PTR _iTeamLoop$225028[ebp]
	mov	DWORD PTR _eLoopTeam$[ebp], ecx

; 4260 : 
; 4261 : 		if(GET_TEAM(eLoopTeam).isAlive())

	mov	edx, DWORD PTR _eLoopTeam$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T235884[ebp], edx
	mov	eax, DWORD PTR $T235884[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+12], 0
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@GetTotalNu

; 4262 : 		{
; 4263 : 			if(IsHasResearchAgreement(eLoopTeam))

	mov	eax, DWORD PTR _eLoopTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHasResearchAgreement@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsHasResearchAgreement
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@GetTotalNu

; 4264 : 			{
; 4265 : 				iCount++;

	mov	edx, DWORD PTR _iCount$[ebp]
	add	edx, 1
	mov	DWORD PTR _iCount$[ebp], edx
$LN2@GetTotalNu:

; 4266 : 			}
; 4267 : 		}
; 4268 : 	}

	jmp	SHORT $LN4@GetTotalNu
$LN3@GetTotalNu:

; 4269 : 
; 4270 : 	return iCount;

	mov	eax, DWORD PTR _iCount$[ebp]

; 4271 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTotalNumResearchAgreements@CvTeam@@QBEHXZ ENDP	; CvTeam::GetTotalNumResearchAgreements
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsHasResearchAgreement@CvTeam@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?IsHasResearchAgreement@CvTeam@@QBE_NW4TeamTypes@@@Z PROC ; CvTeam::IsHasResearchAgreement, COMDAT
; _this$ = ecx

; 4275 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4276 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4277 : 	CvAssertMsg(eIndex < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 4278 : 	return m_abResearchAgreement[eIndex];

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _eIndex$[ebp]
	mov	al, BYTE PTR [eax+2328]

; 4279 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsHasResearchAgreement@CvTeam@@QBE_NW4TeamTypes@@@Z ENDP ; CvTeam::IsHasResearchAgreement
_TEXT	ENDS
PUBLIC	??_C@_0CI@IOPOPOLG@TXT_KEY_NOTIFICATION_RESEARCH_AG@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?SetHasResearchAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasResearchAgreement
EXTRN	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationShortDescriptionKey
;	COMDAT ??_C@_0CI@IOPOPOLG@TXT_KEY_NOTIFICATION_RESEARCH_AG@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0CI@IOPOPOLG@TXT_KEY_NOTIFICATION_RESEARCH_AG@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_RESEARCH_AGREEMENT', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SetHasResearchAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetHasResearchAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z$0
__ehfuncinfo$?SetHasResearchAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SetHasResearchAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?SetHasResearchAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z
_TEXT	SEGMENT
tv93 = -100						; size = 4
_this$ = -96						; size = 4
$T235933 = -92						; size = 4
$T235929 = -88						; size = 4
$T235928 = -84						; size = 4
$T235924 = -80						; size = 4
$T235920 = -76						; size = 4
$T235919 = -72						; size = 4
$T235915 = -68						; size = 4
$T235911 = -64						; size = 4
$T235907 = -60						; size = 4
$T235903 = -56						; size = 4
_strBuffer$225050 = -52					; size = 28
__$ArrayPad$ = -24					; size = 4
_strLeaderName$225048 = -20				; size = 4
_strOtherLeaderName$225049 = -16			; size = 4
__$EHRec$ = -12						; size = 12
_eIndex$ = 8						; size = 4
_bNewValue$ = 12					; size = 1
?SetHasResearchAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z PROC ; CvTeam::SetHasResearchAgreement, COMDAT
; _this$ = ecx

; 4284 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetHasResearchAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 4285 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4286 : 	CvAssertMsg(eIndex < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 4287 : 
; 4288 : 	if(IsHasResearchAgreement(eIndex) != bNewValue)

	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHasResearchAgreement@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsHasResearchAgreement
	movzx	ecx, al
	movzx	edx, BYTE PTR _bNewValue$[ebp]
	cmp	ecx, edx
	je	$LN5@SetHasRese

; 4289 : 	{
; 4290 : 		m_abResearchAgreement[eIndex] = bNewValue;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _eIndex$[ebp]
	mov	cl, BYTE PTR _bNewValue$[ebp]
	mov	BYTE PTR [eax+2328], cl

; 4291 : 
; 4292 : 		if((GetID() == GC.getGame().getActiveTeam()) || (eIndex == GC.getGame().getActiveTeam()))

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235903[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	mov	esi, eax
	mov	ecx, DWORD PTR $T235903[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	esi, eax
	je	SHORT $LN2@SetHasRese
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235907[ebp], eax
	mov	ecx, DWORD PTR $T235907[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	DWORD PTR _eIndex$[ebp], eax
	jne	SHORT $LN3@SetHasRese
$LN2@SetHasRese:

; 4293 : 		{
; 4294 : 			DLLUI->setDirty(Score_DIRTY_BIT, true);

	mov	ecx, DWORD PTR $T235911[ebp]
	mov	DWORD PTR tv93[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv93[ebp], edx
	push	1
	push	12					; 0000000cH
	mov	eax, DWORD PTR tv93[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv93[ebp]
	mov	eax, DWORD PTR [edx+260]
	call	eax
$LN3@SetHasRese:

; 4295 : 		}
; 4296 : 
; 4297 : 		if(bNewValue && !GET_TEAM(eIndex).IsHasResearchAgreement(GetID()))

	movzx	ecx, BYTE PTR _bNewValue$[ebp]
	test	ecx, ecx
	je	$LN5@SetHasRese
	mov	edx, DWORD PTR _eIndex$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T235915[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	ecx, DWORD PTR $T235915[ebp]
	call	?IsHasResearchAgreement@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsHasResearchAgreement
	movzx	eax, al
	test	eax, eax
	jne	$LN5@SetHasRese

; 4298 : 		{
; 4299 : 			const char* strLeaderName = GET_PLAYER(getLeaderID()).getCivilizationShortDescriptionKey();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	mov	DWORD PTR $T235919[ebp], eax
	mov	ecx, DWORD PTR $T235919[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235920[ebp], ecx
	mov	ecx, DWORD PTR $T235920[ebp]
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey
	mov	DWORD PTR _strLeaderName$225048[ebp], eax

; 4300 : 			const char* strOtherLeaderName = GET_PLAYER(GET_TEAM(eIndex).getLeaderID()).getCivilizationShortDescriptionKey();

	mov	edx, DWORD PTR _eIndex$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T235924[ebp], edx
	mov	ecx, DWORD PTR $T235924[ebp]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	mov	DWORD PTR $T235928[ebp], eax
	mov	eax, DWORD PTR $T235928[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235929[ebp], eax
	mov	ecx, DWORD PTR $T235929[ebp]
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey
	mov	DWORD PTR _strOtherLeaderName$225049[ebp], eax

; 4301 : 
; 4302 : 			CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_RESEARCH_AGREEMENT", strLeaderName, strOtherLeaderName);

	lea	ecx, DWORD PTR _strOtherLeaderName$225049[ebp]
	push	ecx
	lea	edx, DWORD PTR _strLeaderName$225048[ebp]
	push	edx
	push	OFFSET ??_C@_0CI@IOPOPOLG@TXT_KEY_NOTIFICATION_RESEARCH_AG@
	lea	eax, DWORD PTR _strBuffer$225050[ebp]
	push	eax
	call	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
	add	esp, 16					; 00000010H
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4303 : 			GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, getLeaderID(), strBuffer, -1, -1);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235933[ebp], ecx
	push	-1
	push	-1
	lea	edx, DWORD PTR _strBuffer$225050[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	push	eax
	push	0
	mov	ecx, DWORD PTR $T235933[ebp]
	call	?addReplayMessage@CvGame@@QAEXW4ReplayMessageTypes@@W4PlayerTypes@@ABVCvString@@HH@Z ; CvGame::addReplayMessage

; 4304 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strBuffer$225050[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN5@SetHasRese:

; 4305 : 	}
; 4306 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetHasResearchAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z$0:
	lea	ecx, DWORD PTR _strBuffer$225050[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?SetHasResearchAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetHasResearchAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetHasResearchAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z ENDP ; CvTeam::SetHasResearchAgreement
PUBLIC	?IsHasTradeAgreement@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsHasTradeAgreement
; Function compile flags: /Odtp
;	COMDAT ?IsHasTradeAgreement@CvTeam@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?IsHasTradeAgreement@CvTeam@@QBE_NW4TeamTypes@@@Z PROC	; CvTeam::IsHasTradeAgreement, COMDAT
; _this$ = ecx

; 4311 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4312 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4313 : 	CvAssertMsg(eIndex < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 4314 : 	return m_abTradeAgreement[eIndex];

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _eIndex$[ebp]
	mov	al, BYTE PTR [eax+2408]

; 4315 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsHasTradeAgreement@CvTeam@@QBE_NW4TeamTypes@@@Z ENDP	; CvTeam::IsHasTradeAgreement
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?CancelResearchAgreement@CvTeam@@QAEXW4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?CancelResearchAgreement@CvTeam@@QAEXW4TeamTypes@@@Z PROC ; CvTeam::CancelResearchAgreement, COMDAT
; _this$ = ecx

; 4319 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4320 : 	if (IsHasResearchAgreement(eIndex))

	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHasResearchAgreement@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsHasResearchAgreement
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@CancelRese

; 4321 : 	{
; 4322 : 		m_abResearchAgreement[eIndex] = false;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR _eIndex$[ebp]
	mov	BYTE PTR [edx+2328], 0
$LN2@CancelRese:

; 4323 : 	}
; 4324 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?CancelResearchAgreement@CvTeam@@QAEXW4TeamTypes@@@Z ENDP ; CvTeam::CancelResearchAgreement
_TEXT	ENDS
PUBLIC	??_C@_0CK@LCEBKMFD@TXT_KEY_MISC_PLAYERS_SIGN_TRADE_@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?SetHasTradeAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasTradeAgreement
;	COMDAT ??_C@_0CK@LCEBKMFD@TXT_KEY_MISC_PLAYERS_SIGN_TRADE_@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0CK@LCEBKMFD@TXT_KEY_MISC_PLAYERS_SIGN_TRADE_@ DB 'TXT_KEY_MISC_PLA'
	DB	'YERS_SIGN_TRADE_AGREEMENT', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?SetHasTradeAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?SetHasTradeAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?SetHasTradeAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetHasTradeAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SetHasTradeAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?SetHasTradeAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?SetHasTradeAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SetHasTradeAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z$2
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?SetHasTradeAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z
_TEXT	SEGMENT
tv204 = -156						; size = 4
tv162 = -152						; size = 4
tv93 = -148						; size = 4
_this$ = -144						; size = 4
$T236006 = -140						; size = 4
$T235994 = -136						; size = 4
$T235990 = -132						; size = 4
$T235986 = -128						; size = 4
$T235982 = -124						; size = 4
$T235978 = -120						; size = 4
$T235974 = -116						; size = 4
$T235970 = -112						; size = 4
$T235960 = -108						; size = 28
$T235959 = -80						; size = 4
$T235958 = -76						; size = 28
$T235957 = -48						; size = 4
_strBuffer$225071 = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_eIndex$ = 8						; size = 4
_bNewValue$ = 12					; size = 1
?SetHasTradeAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z PROC ; CvTeam::SetHasTradeAgreement, COMDAT
; _this$ = ecx

; 4328 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetHasTradeAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 144				; 00000090H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 4329 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4330 : 	CvAssertMsg(eIndex < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 4331 : 
; 4332 : 	if(IsHasTradeAgreement(eIndex) != bNewValue)

	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHasTradeAgreement@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsHasTradeAgreement
	movzx	ecx, al
	movzx	edx, BYTE PTR _bNewValue$[ebp]
	cmp	ecx, edx
	je	$LN5@SetHasTrad

; 4333 : 	{
; 4334 : 		m_abTradeAgreement[eIndex] = bNewValue;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _eIndex$[ebp]
	mov	cl, BYTE PTR _bNewValue$[ebp]
	mov	BYTE PTR [eax+2408], cl

; 4335 : 
; 4336 : 		if((GetID() == GC.getGame().getActiveTeam()) || (eIndex == GC.getGame().getActiveTeam()))

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235970[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	mov	esi, eax
	mov	ecx, DWORD PTR $T235970[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	esi, eax
	je	SHORT $LN2@SetHasTrad
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235974[ebp], eax
	mov	ecx, DWORD PTR $T235974[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	DWORD PTR _eIndex$[ebp], eax
	jne	SHORT $LN3@SetHasTrad
$LN2@SetHasTrad:

; 4337 : 		{
; 4338 : 			DLLUI->setDirty(Score_DIRTY_BIT, true);

	mov	ecx, DWORD PTR $T235978[ebp]
	mov	DWORD PTR tv93[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv93[ebp], edx
	push	1
	push	12					; 0000000cH
	mov	eax, DWORD PTR tv93[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv93[ebp]
	mov	eax, DWORD PTR [edx+260]
	call	eax
$LN3@SetHasTrad:

; 4339 : 		}
; 4340 : 
; 4341 : 		if(bNewValue && !GET_TEAM(eIndex).IsHasTradeAgreement(GetID()))

	movzx	ecx, BYTE PTR _bNewValue$[ebp]
	test	ecx, ecx
	je	$LN5@SetHasTrad
	mov	edx, DWORD PTR _eIndex$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T235982[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	ecx, DWORD PTR $T235982[ebp]
	call	?IsHasTradeAgreement@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsHasTradeAgreement
	movzx	eax, al
	test	eax, eax
	jne	$LN5@SetHasTrad

; 4342 : 		{
; 4343 : 			CvString strBuffer = GetLocalizedText("TXT_KEY_MISC_PLAYERS_SIGN_TRADE_AGREEMENT", getName().GetCString(), GET_TEAM(eIndex).getName().GetCString());

	mov	ecx, DWORD PTR _eIndex$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T235986[ebp], ecx
	lea	edx, DWORD PTR $T235958[ebp]
	push	edx
	mov	ecx, DWORD PTR $T235986[ebp]
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	DWORD PTR tv162[ebp], eax
	mov	eax, DWORD PTR tv162[ebp]
	mov	DWORD PTR $T235990[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR $T235990[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T235957[ebp], eax
	lea	ecx, DWORD PTR $T235960[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	DWORD PTR tv204[ebp], eax
	mov	edx, DWORD PTR tv204[ebp]
	mov	DWORD PTR $T235994[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR $T235994[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T235959[ebp], eax
	lea	eax, DWORD PTR $T235957[ebp]
	push	eax
	lea	ecx, DWORD PTR $T235959[ebp]
	push	ecx
	push	OFFSET ??_C@_0CK@LCEBKMFD@TXT_KEY_MISC_PLAYERS_SIGN_TRADE_@
	lea	edx, DWORD PTR _strBuffer$225071[ebp]
	push	edx
	call	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
	add	esp, 16					; 00000010H
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T235960[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T235958[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4344 : 			GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, getLeaderID(), strBuffer, -1, -1);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T236006[ebp], eax
	push	-1
	push	-1
	lea	ecx, DWORD PTR _strBuffer$225071[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	push	eax
	push	0
	mov	ecx, DWORD PTR $T236006[ebp]
	call	?addReplayMessage@CvGame@@QAEXW4ReplayMessageTypes@@W4PlayerTypes@@ABVCvString@@HH@Z ; CvGame::addReplayMessage

; 4345 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strBuffer$225071[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN5@SetHasTrad:

; 4346 : 	}
; 4347 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetHasTradeAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z$0:
	lea	ecx, DWORD PTR $T235958[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?SetHasTradeAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z$1:
	lea	ecx, DWORD PTR $T235960[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?SetHasTradeAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z$2:
	lea	ecx, DWORD PTR _strBuffer$225071[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?SetHasTradeAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-152]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetHasTradeAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetHasTradeAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z ENDP ; CvTeam::SetHasTradeAgreement
; Function compile flags: /Odtp
;	COMDAT ?isForcePeace@CvTeam@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?isForcePeace@CvTeam@@QBE_NW4TeamTypes@@@Z PROC		; CvTeam::isForcePeace, COMDAT
; _this$ = ecx

; 4351 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4352 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4353 : 	CvAssertMsg(eIndex < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 4354 : 	return m_abForcePeace[eIndex];

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _eIndex$[ebp]
	mov	al, BYTE PTR [eax+2488]

; 4355 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isForcePeace@CvTeam@@QBE_NW4TeamTypes@@@Z ENDP		; CvTeam::isForcePeace
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?setForcePeace@CvTeam@@QAEXW4TeamTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
_bNewValue$ = 12					; size = 1
?setForcePeace@CvTeam@@QAEXW4TeamTypes@@_N@Z PROC	; CvTeam::setForcePeace, COMDAT
; _this$ = ecx

; 4360 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4361 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4362 : 	CvAssertMsg(eIndex < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 4363 : 	m_abForcePeace[eIndex] = bNewValue;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _eIndex$[ebp]
	mov	cl, BYTE PTR _bNewValue$[ebp]
	mov	BYTE PTR [eax+2488], cl

; 4364 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?setForcePeace@CvTeam@@QAEXW4TeamTypes@@_N@Z ENDP	; CvTeam::setForcePeace
_TEXT	ENDS
PUBLIC	?getRouteChange@CvTeam@@QBEHW4RouteTypes@@@Z	; CvTeam::getRouteChange
; Function compile flags: /Odtp
;	COMDAT ?getRouteChange@CvTeam@@QBEHW4RouteTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?getRouteChange@CvTeam@@QBEHW4RouteTypes@@@Z PROC	; CvTeam::getRouteChange, COMDAT
; _this$ = ecx

; 4369 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4370 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4371 : 	CvAssertMsg(eIndex < GC.getNumRouteInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4372 : 	return m_paiRouteChange[eIndex];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2908]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 4373 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getRouteChange@CvTeam@@QBEHW4RouteTypes@@@Z ENDP	; CvTeam::getRouteChange
_TEXT	ENDS
PUBLIC	?changeRouteChange@CvTeam@@QAEXW4RouteTypes@@H@Z ; CvTeam::changeRouteChange
; Function compile flags: /Odtp
;	COMDAT ?changeRouteChange@CvTeam@@QAEXW4RouteTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?changeRouteChange@CvTeam@@QAEXW4RouteTypes@@H@Z PROC	; CvTeam::changeRouteChange, COMDAT
; _this$ = ecx

; 4377 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4378 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4379 : 	CvAssertMsg(eIndex < GC.getNumRouteInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4380 : 	m_paiRouteChange[eIndex] = (m_paiRouteChange[eIndex] + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2908]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	add	eax, DWORD PTR _iChange$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2908]
	mov	ecx, DWORD PTR _eIndex$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 4381 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?changeRouteChange@CvTeam@@QAEXW4RouteTypes@@H@Z ENDP	; CvTeam::changeRouteChange
_TEXT	ENDS
PUBLIC	?getBuildTimeChange@CvTeam@@QBEHW4BuildTypes@@@Z ; CvTeam::getBuildTimeChange
; Function compile flags: /Odtp
;	COMDAT ?getBuildTimeChange@CvTeam@@QBEHW4BuildTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?getBuildTimeChange@CvTeam@@QBEHW4BuildTypes@@@Z PROC	; CvTeam::getBuildTimeChange, COMDAT
; _this$ = ecx

; 4385 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4386 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4387 : 	CvAssertMsg(eIndex < GC.getNumBuildInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4388 : 	return m_paiBuildTimeChange[eIndex];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2912]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 4389 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getBuildTimeChange@CvTeam@@QBEHW4BuildTypes@@@Z ENDP	; CvTeam::getBuildTimeChange
_TEXT	ENDS
PUBLIC	?changeBuildTimeChange@CvTeam@@QAEXW4BuildTypes@@H@Z ; CvTeam::changeBuildTimeChange
; Function compile flags: /Odtp
;	COMDAT ?changeBuildTimeChange@CvTeam@@QAEXW4BuildTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?changeBuildTimeChange@CvTeam@@QAEXW4BuildTypes@@H@Z PROC ; CvTeam::changeBuildTimeChange, COMDAT
; _this$ = ecx

; 4393 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4394 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4395 : 	CvAssertMsg(eIndex < GC.getNumBuildInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4396 : 	if (iChange != 0)

	cmp	DWORD PTR _iChange$[ebp], 0
	je	SHORT $LN2@changeBuil

; 4397 : 	{
; 4398 : 		m_paiBuildTimeChange[eIndex] = (m_paiBuildTimeChange[eIndex] + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2912]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	add	eax, DWORD PTR _iChange$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2912]
	mov	ecx, DWORD PTR _eIndex$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
$LN2@changeBuil:

; 4399 : 	}
; 4400 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?changeBuildTimeChange@CvTeam@@QAEXW4BuildTypes@@H@Z ENDP ; CvTeam::changeBuildTimeChange
_TEXT	ENDS
PUBLIC	?GetBestPossibleRoute@CvTeam@@QAE?AW4RouteTypes@@XZ ; CvTeam::GetBestPossibleRoute
; Function compile flags: /Odtp
;	COMDAT ?GetBestPossibleRoute@CvTeam@@QAE?AW4RouteTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBestPossibleRoute@CvTeam@@QAE?AW4RouteTypes@@XZ PROC ; CvTeam::GetBestPossibleRoute, COMDAT
; _this$ = ecx

; 4405 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4406 : 	return (RouteTypes) m_iBestPossibleRoute;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+120]

; 4407 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetBestPossibleRoute@CvTeam@@QAE?AW4RouteTypes@@XZ ENDP ; CvTeam::GetBestPossibleRoute
_TEXT	ENDS
PUBLIC	?SetBestPossibleRoute@CvTeam@@QAEXW4RouteTypes@@@Z ; CvTeam::SetBestPossibleRoute
; Function compile flags: /Odtp
;	COMDAT ?SetBestPossibleRoute@CvTeam@@QAEXW4RouteTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eRoute$ = 8						; size = 4
?SetBestPossibleRoute@CvTeam@@QAEXW4RouteTypes@@@Z PROC	; CvTeam::SetBestPossibleRoute, COMDAT
; _this$ = ecx

; 4412 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4413 : 	CvAssertMsg(eRoute >= NO_ROUTE, "eIndex is expected to be non-negative (invalid Index)");
; 4414 : 	CvAssertMsg(eRoute < GC.getNumRouteInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4415 : 
; 4416 : 	if(GetBestPossibleRoute() != eRoute)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBestPossibleRoute@CvTeam@@QAE?AW4RouteTypes@@XZ ; CvTeam::GetBestPossibleRoute
	cmp	eax, DWORD PTR _eRoute$[ebp]
	je	SHORT $LN2@SetBestPos

; 4417 : 	{
; 4418 : 		m_iBestPossibleRoute = eRoute;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _eRoute$[ebp]
	mov	DWORD PTR [eax+120], ecx
$LN2@SetBestPos:

; 4419 : 	}
; 4420 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetBestPossibleRoute@CvTeam@@QAEXW4RouteTypes@@@Z ENDP	; CvTeam::SetBestPossibleRoute
_TEXT	ENDS
PUBLIC	?DoUpdateBestRoute@CvTeam@@QAEXXZ		; CvTeam::DoUpdateBestRoute
EXTRN	?GetResearchCost@CvTechEntry@@QBEHXZ:PROC	; CvTechEntry::GetResearchCost
EXTRN	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z:PROC ; CvGlobals::getTechInfo
EXTRN	?getTechPrereq@CvBuildInfo@@QBEHXZ:PROC		; CvBuildInfo::getTechPrereq
EXTRN	?getRoute@CvBuildInfo@@QBEHXZ:PROC		; CvBuildInfo::getRoute
EXTRN	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z:PROC ; CvGlobals::getBuildInfo
; Function compile flags: /Odtp
;	COMDAT ?DoUpdateBestRoute@CvTeam@@QAEXXZ
_TEXT	SEGMENT
tv81 = -44						; size = 4
_this$ = -40						; size = 4
_eTech$225132 = -36					; size = 4
_pkTechInfo$225134 = -32				; size = 4
_iRouteValue$225131 = -28				; size = 4
_eRoute$225128 = -24					; size = 4
_eBuild$225124 = -20					; size = 4
_pkBuildInfo$225126 = -16				; size = 4
_iBuildLoop$225120 = -12				; size = 4
_iBestRouteValue$ = -8					; size = 4
_eBestRoute$ = -4					; size = 4
?DoUpdateBestRoute@CvTeam@@QAEXXZ PROC			; CvTeam::DoUpdateBestRoute, COMDAT
; _this$ = ecx

; 4425 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 4426 : 	RouteTypes eBestRoute = NO_ROUTE;

	mov	DWORD PTR _eBestRoute$[ebp], -1

; 4427 : 	int iBestRouteValue = 0;

	mov	DWORD PTR _iBestRouteValue$[ebp], 0

; 4428 : 
; 4429 : 	// Loop through all builds to see if it allows us to build a Route
; 4430 : #ifdef AUI_WARNING_FIXES
; 4431 : 	for (uint iBuildLoop = 0; iBuildLoop < GC.getNumBuildInfos(); iBuildLoop++)
; 4432 : #else
; 4433 : 	for(int iBuildLoop = 0; iBuildLoop < GC.getNumBuildInfos(); iBuildLoop++)

	mov	DWORD PTR _iBuildLoop$225120[ebp], 0
	jmp	SHORT $LN10@DoUpdateBe
$LN9@DoUpdateBe:
	mov	eax, DWORD PTR _iBuildLoop$225120[ebp]
	add	eax, 1
	mov	DWORD PTR _iBuildLoop$225120[ebp], eax
$LN10@DoUpdateBe:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	DWORD PTR _iBuildLoop$225120[ebp], eax
	jge	$LN8@DoUpdateBe

; 4434 : #endif
; 4435 : 	{
; 4436 : 		const BuildTypes eBuild = static_cast<BuildTypes>(iBuildLoop);

	mov	ecx, DWORD PTR _iBuildLoop$225120[ebp]
	mov	DWORD PTR _eBuild$225124[ebp], ecx

; 4437 : 		CvBuildInfo* pkBuildInfo = GC.getBuildInfo(eBuild);

	mov	edx, DWORD PTR _eBuild$225124[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	DWORD PTR _pkBuildInfo$225126[ebp], eax

; 4438 : 		if(pkBuildInfo)

	cmp	DWORD PTR _pkBuildInfo$225126[ebp], 0
	je	$LN7@DoUpdateBe

; 4439 : 		{
; 4440 : 			const RouteTypes eRoute = (RouteTypes) pkBuildInfo->getRoute();

	mov	ecx, DWORD PTR _pkBuildInfo$225126[ebp]
	call	?getRoute@CvBuildInfo@@QBEHXZ		; CvBuildInfo::getRoute
	mov	DWORD PTR _eRoute$225128[ebp], eax

; 4441 : 			if(eRoute != NO_ROUTE)

	cmp	DWORD PTR _eRoute$225128[ebp], -1
	je	$LN7@DoUpdateBe

; 4442 : 			{
; 4443 : 				int iRouteValue = -1;

	mov	DWORD PTR _iRouteValue$225131[ebp], -1

; 4444 : 
; 4445 : 				// If this route requires a tech, it's value is the cost of the tech
; 4446 : 				const TechTypes eTech = (TechTypes) pkBuildInfo->getTechPrereq();

	mov	ecx, DWORD PTR _pkBuildInfo$225126[ebp]
	call	?getTechPrereq@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getTechPrereq
	mov	DWORD PTR _eTech$225132[ebp], eax

; 4447 : 				CvTechEntry* pkTechInfo = (eTech != NO_TECH)? GC.getTechInfo(eTech) : NULL;

	cmp	DWORD PTR _eTech$225132[ebp], -1
	je	SHORT $LN13@DoUpdateBe
	mov	eax, DWORD PTR _eTech$225132[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo
	mov	DWORD PTR tv81[ebp], eax
	jmp	SHORT $LN14@DoUpdateBe
$LN13@DoUpdateBe:
	mov	DWORD PTR tv81[ebp], 0
$LN14@DoUpdateBe:
	mov	ecx, DWORD PTR tv81[ebp]
	mov	DWORD PTR _pkTechInfo$225134[ebp], ecx

; 4448 : 				if(pkTechInfo)

	cmp	DWORD PTR _pkTechInfo$225134[ebp], 0
	je	SHORT $LN5@DoUpdateBe

; 4449 : 				{
; 4450 : 					if(GetTeamTechs()->HasTech(eTech))

	mov	edx, DWORD PTR _eTech$225132[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@DoUpdateBe

; 4451 : 					{
; 4452 : 						iRouteValue = pkTechInfo->GetResearchCost();

	mov	ecx, DWORD PTR _pkTechInfo$225134[ebp]
	call	?GetResearchCost@CvTechEntry@@QBEHXZ	; CvTechEntry::GetResearchCost
	mov	DWORD PTR _iRouteValue$225131[ebp], eax
$LN4@DoUpdateBe:

; 4453 : 					}
; 4454 : 				}
; 4455 : 				// Route requires no tech, so it's value is simply 1
; 4456 : 				else

	jmp	SHORT $LN3@DoUpdateBe
$LN5@DoUpdateBe:

; 4457 : 				{
; 4458 : 					iRouteValue = 1;

	mov	DWORD PTR _iRouteValue$225131[ebp], 1
$LN3@DoUpdateBe:

; 4459 : 				}
; 4460 : 
; 4461 : 				// Most valuable route found so far? (note we use greater than OR equal to so that we'll pick up the LAST entry in Builds - this is most likely to be the most advanced if there are ties)
; 4462 : 				if(iRouteValue >= iBestRouteValue)

	mov	ecx, DWORD PTR _iRouteValue$225131[ebp]
	cmp	ecx, DWORD PTR _iBestRouteValue$[ebp]
	jl	SHORT $LN7@DoUpdateBe

; 4463 : 				{
; 4464 : 					iBestRouteValue = iRouteValue;

	mov	edx, DWORD PTR _iRouteValue$225131[ebp]
	mov	DWORD PTR _iBestRouteValue$[ebp], edx

; 4465 : 					eBestRoute = eRoute;

	mov	eax, DWORD PTR _eRoute$225128[ebp]
	mov	DWORD PTR _eBestRoute$[ebp], eax
$LN7@DoUpdateBe:

; 4466 : 				}
; 4467 : 			}
; 4468 : 		}
; 4469 : 	}

	jmp	$LN9@DoUpdateBe
$LN8@DoUpdateBe:

; 4470 : 
; 4471 : #ifdef AUI_ASTAR_TWEAKED_OPTIMIZED_BUT_CAN_STILL_USE_ROADS
; 4472 : 	CvRouteInfo* pRouteInfo = NULL;
; 4473 : 	if (eBestRoute > NO_ROUTE)
; 4474 : #else
; 4475 : 	if(iBestRouteValue > -1)

	cmp	DWORD PTR _iBestRouteValue$[ebp], -1
	jle	SHORT $LN11@DoUpdateBe

; 4476 : #endif
; 4477 : 	{
; 4478 : 		SetBestPossibleRoute(eBestRoute);

	mov	ecx, DWORD PTR _eBestRoute$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetBestPossibleRoute@CvTeam@@QAEXW4RouteTypes@@@Z ; CvTeam::SetBestPossibleRoute
$LN11@DoUpdateBe:

; 4479 : #ifdef AUI_ASTAR_TWEAKED_OPTIMIZED_BUT_CAN_STILL_USE_ROADS
; 4480 : 		pRouteInfo = GC.getRouteInfo(eBestRoute);
; 4481 : #endif
; 4482 : 	}
; 4483 : #ifdef AUI_ASTAR_TWEAKED_OPTIMIZED_BUT_CAN_STILL_USE_ROADS
; 4484 : 	if (pRouteInfo)
; 4485 : 	{
; 4486 : 		m_iBestRouteNormalCostMultiplier = GC.getMOVE_DENOMINATOR() / (pRouteInfo->getMovementCost() + getRouteChange(eBestRoute));
; 4487 : 		m_iBestRouteFlatCostMultiplier = GC.getMOVE_DENOMINATOR() / pRouteInfo->getFlatMovementCost();
; 4488 : 		// Extra pRouteInfo->getFlatMovementCost() - 1 is to make sure value is always rounded up
; 4489 : 		m_iUseFlatCostIfBelowThis = (pRouteInfo->getMovementCost() + getRouteChange(eBestRoute) + pRouteInfo->getFlatMovementCost() - 1) / pRouteInfo->getFlatMovementCost();
; 4490 : 	}
; 4491 : 	else
; 4492 : 	{
; 4493 : 		m_iBestRouteFlatCostMultiplier = 0;
; 4494 : 		m_iBestRouteNormalCostMultiplier = 1;
; 4495 : 		m_iUseFlatCostIfBelowThis = -1;
; 4496 : 	}
; 4497 : #endif
; 4498 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DoUpdateBestRoute@CvTeam@@QAEXXZ ENDP			; CvTeam::DoUpdateBestRoute
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getProjectCount@CvTeam@@QBEHW4ProjectTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?getProjectCount@CvTeam@@QBEHW4ProjectTypes@@@Z PROC	; CvTeam::getProjectCount, COMDAT
; _this$ = ecx

; 4521 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4522 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4523 : 	CvAssertMsg(eIndex < GC.getNumProjectInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4524 : 	return m_paiProjectCount[eIndex];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2916]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 4525 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getProjectCount@CvTeam@@QBEHW4ProjectTypes@@@Z ENDP	; CvTeam::getProjectCount
_TEXT	ENDS
PUBLIC	?getProjectDefaultArtType@CvTeam@@QBEHW4ProjectTypes@@@Z ; CvTeam::getProjectDefaultArtType
; Function compile flags: /Odtp
;	COMDAT ?getProjectDefaultArtType@CvTeam@@QBEHW4ProjectTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?getProjectDefaultArtType@CvTeam@@QBEHW4ProjectTypes@@@Z PROC ; CvTeam::getProjectDefaultArtType, COMDAT
; _this$ = ecx

; 4529 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4530 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4531 : 	CvAssertMsg(eIndex < GC.getNumProjectInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4532 : 	return m_paiProjectDefaultArtTypes[eIndex];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2920]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 4533 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getProjectDefaultArtType@CvTeam@@QBEHW4ProjectTypes@@@Z ENDP ; CvTeam::getProjectDefaultArtType
_TEXT	ENDS
PUBLIC	?setProjectDefaultArtType@CvTeam@@QAEXW4ProjectTypes@@H@Z ; CvTeam::setProjectDefaultArtType
; Function compile flags: /Odtp
;	COMDAT ?setProjectDefaultArtType@CvTeam@@QAEXW4ProjectTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
_value$ = 12						; size = 4
?setProjectDefaultArtType@CvTeam@@QAEXW4ProjectTypes@@H@Z PROC ; CvTeam::setProjectDefaultArtType, COMDAT
; _this$ = ecx

; 4537 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4538 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4539 : 	CvAssertMsg(eIndex < GC.getNumProjectInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4540 : 	m_paiProjectDefaultArtTypes[eIndex] = value;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2920]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 4541 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?setProjectDefaultArtType@CvTeam@@QAEXW4ProjectTypes@@H@Z ENDP ; CvTeam::setProjectDefaultArtType
_TEXT	ENDS
PUBLIC	?getProjectArtType@CvTeam@@QBEHW4ProjectTypes@@H@Z ; CvTeam::getProjectArtType
; Function compile flags: /Odtp
;	COMDAT ?getProjectArtType@CvTeam@@QBEHW4ProjectTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
_number$ = 12						; size = 4
?getProjectArtType@CvTeam@@QBEHW4ProjectTypes@@H@Z PROC	; CvTeam::getProjectArtType, COMDAT
; _this$ = ecx

; 4545 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4546 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4547 : 	CvAssertMsg(eIndex < GC.getNumProjectInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4548 : 	CvAssertMsg(number >= 0, "number is expected to be non-negative (invalid Index)");
; 4549 : 	CvAssertMsg(number < getProjectCount(eIndex), "number is expected to be within maximum bounds (invalid Index)");
; 4550 : 	return m_pavProjectArtTypes[eIndex][number];

	mov	eax, DWORD PTR _eIndex$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2960]
	mov	eax, DWORD PTR [edx+eax+4]
	mov	ecx, DWORD PTR _number$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]

; 4551 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?getProjectArtType@CvTeam@@QBEHW4ProjectTypes@@H@Z ENDP	; CvTeam::getProjectArtType
_TEXT	ENDS
PUBLIC	?setProjectArtType@CvTeam@@QAEXW4ProjectTypes@@HH@Z ; CvTeam::setProjectArtType
; Function compile flags: /Odtp
;	COMDAT ?setProjectArtType@CvTeam@@QAEXW4ProjectTypes@@HH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
_number$ = 12						; size = 4
_value$ = 16						; size = 4
?setProjectArtType@CvTeam@@QAEXW4ProjectTypes@@HH@Z PROC ; CvTeam::setProjectArtType, COMDAT
; _this$ = ecx

; 4555 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4556 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4557 : 	CvAssertMsg(eIndex < GC.getNumProjectInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4558 : 	CvAssertMsg(number >= 0, "number is expected to be non-negative (invalid Index)");
; 4559 : 	CvAssertMsg(number < getProjectCount(eIndex), "number is expected to be within maximum bounds (invalid Index)");
; 4560 : 	m_pavProjectArtTypes[eIndex][number] = value;

	mov	eax, DWORD PTR _eIndex$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2960]
	mov	eax, DWORD PTR [edx+eax+4]
	mov	ecx, DWORD PTR _number$[ebp]
	mov	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 4561 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?setProjectArtType@CvTeam@@QAEXW4ProjectTypes@@HH@Z ENDP ; CvTeam::setProjectArtType
_TEXT	ENDS
PUBLIC	?isProjectMaxedOut@CvTeam@@QBE_NW4ProjectTypes@@H@Z ; CvTeam::isProjectMaxedOut
EXTRN	?GetMaxTeamInstances@CvProjectEntry@@QBEHXZ:PROC ; CvProjectEntry::GetMaxTeamInstances
EXTRN	?getProjectInfo@CvGlobals@@QAEPAVCvProjectEntry@@W4ProjectTypes@@@Z:PROC ; CvGlobals::getProjectInfo
EXTRN	?isTeamProject@@YA_NW4ProjectTypes@@@Z:PROC	; isTeamProject
; Function compile flags: /Odtp
;	COMDAT ?isProjectMaxedOut@CvTeam@@QBE_NW4ProjectTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
_iExtra$ = 12						; size = 4
?isProjectMaxedOut@CvTeam@@QBE_NW4ProjectTypes@@H@Z PROC ; CvTeam::isProjectMaxedOut, COMDAT
; _this$ = ecx

; 4565 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 4566 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4567 : 	CvAssertMsg(eIndex < GC.getNumProjectInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4568 : 
; 4569 : 	if(!isTeamProject(eIndex))

	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	call	?isTeamProject@@YA_NW4ProjectTypes@@@Z	; isTeamProject
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@isProjectM

; 4570 : 	{
; 4571 : 		return false;

	xor	al, al
	jmp	SHORT $LN2@isProjectM
$LN1@isProjectM:

; 4572 : 	}
; 4573 : 
; 4574 : 	CvAssertMsg(getProjectCount(eIndex) <= GC.getProjectInfo(eIndex)->GetMaxTeamInstances(), "Current Project count is expected to not exceed the maximum number of instances for this project");
; 4575 : 
; 4576 : 	return ((getProjectCount(eIndex) + iExtra) >= GC.getProjectInfo(eIndex)->GetMaxTeamInstances());

	mov	edx, DWORD PTR _eIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getProjectCount@CvTeam@@QBEHW4ProjectTypes@@@Z ; CvTeam::getProjectCount
	mov	esi, eax
	add	esi, DWORD PTR _iExtra$[ebp]
	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getProjectInfo@CvGlobals@@QAEPAVCvProjectEntry@@W4ProjectTypes@@@Z ; CvGlobals::getProjectInfo
	mov	ecx, eax
	call	?GetMaxTeamInstances@CvProjectEntry@@QBEHXZ ; CvProjectEntry::GetMaxTeamInstances
	xor	ecx, ecx
	cmp	esi, eax
	setge	cl
	mov	al, cl
$LN2@isProjectM:

; 4577 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?isProjectMaxedOut@CvTeam@@QBE_NW4ProjectTypes@@H@Z ENDP ; CvTeam::isProjectMaxedOut
_TEXT	ENDS
PUBLIC	?isProjectAndArtMaxedOut@CvTeam@@QBE_NW4ProjectTypes@@@Z ; CvTeam::isProjectAndArtMaxedOut
; Function compile flags: /Odtp
;	COMDAT ?isProjectAndArtMaxedOut@CvTeam@@QBE_NW4ProjectTypes@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_i$225176 = -8						; size = 4
_count$225175 = -4					; size = 4
_eIndex$ = 8						; size = 4
?isProjectAndArtMaxedOut@CvTeam@@QBE_NW4ProjectTypes@@@Z PROC ; CvTeam::isProjectAndArtMaxedOut, COMDAT
; _this$ = ecx

; 4581 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 4582 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4583 : 	CvAssertMsg(eIndex < GC.getNumProjectInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4584 : 
; 4585 : 	if(getProjectCount(eIndex) >= GC.getProjectInfo(eIndex)->GetMaxTeamInstances())

	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getProjectCount@CvTeam@@QBEHW4ProjectTypes@@@Z ; CvTeam::getProjectCount
	mov	esi, eax
	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getProjectInfo@CvGlobals@@QAEPAVCvProjectEntry@@W4ProjectTypes@@@Z ; CvGlobals::getProjectInfo
	mov	ecx, eax
	call	?GetMaxTeamInstances@CvProjectEntry@@QBEHXZ ; CvProjectEntry::GetMaxTeamInstances
	cmp	esi, eax
	jl	SHORT $LN6@isProjectA

; 4586 : 	{
; 4587 : 		int count = getProjectCount(eIndex);

	mov	edx, DWORD PTR _eIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getProjectCount@CvTeam@@QBEHW4ProjectTypes@@@Z ; CvTeam::getProjectCount
	mov	DWORD PTR _count$225175[ebp], eax

; 4588 : 		for(int i=0; i<count; i++)

	mov	DWORD PTR _i$225176[ebp], 0
	jmp	SHORT $LN5@isProjectA
$LN4@isProjectA:
	mov	eax, DWORD PTR _i$225176[ebp]
	add	eax, 1
	mov	DWORD PTR _i$225176[ebp], eax
$LN5@isProjectA:
	mov	ecx, DWORD PTR _i$225176[ebp]
	cmp	ecx, DWORD PTR _count$225175[ebp]
	jge	SHORT $LN3@isProjectA

; 4589 : 		{
; 4590 : 			if(getProjectArtType(eIndex, i) == -1) //undefined

	mov	edx, DWORD PTR _i$225176[ebp]
	push	edx
	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getProjectArtType@CvTeam@@QBEHW4ProjectTypes@@H@Z ; CvTeam::getProjectArtType
	cmp	eax, -1
	jne	SHORT $LN2@isProjectA

; 4591 : 				return false;

	xor	al, al
	jmp	SHORT $LN7@isProjectA
$LN2@isProjectA:

; 4592 : 		}

	jmp	SHORT $LN4@isProjectA
$LN3@isProjectA:

; 4593 : 
; 4594 : 		return true;

	mov	al, 1
	jmp	SHORT $LN7@isProjectA

; 4595 : 	}
; 4596 : 	else

	jmp	SHORT $LN7@isProjectA
$LN6@isProjectA:

; 4597 : 	{
; 4598 : 		return false;

	xor	al, al
$LN7@isProjectA:

; 4599 : 	}
; 4600 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?isProjectAndArtMaxedOut@CvTeam@@QBE_NW4ProjectTypes@@@Z ENDP ; CvTeam::isProjectAndArtMaxedOut
_TEXT	ENDS
PUBLIC	?finalizeProjectArtTypes@CvTeam@@QAEXXZ		; CvTeam::finalizeProjectArtTypes
; Function compile flags: /Odtp
;	COMDAT ?finalizeProjectArtTypes@CvTeam@@QAEXXZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_defaultArtType$225198 = -24				; size = 4
_projectArtType$225196 = -20				; size = 4
_j$225192 = -16						; size = 4
_projectType$225189 = -12				; size = 4
_projectCount$225191 = -8				; size = 4
_i$225185 = -4						; size = 4
?finalizeProjectArtTypes@CvTeam@@QAEXXZ PROC		; CvTeam::finalizeProjectArtTypes, COMDAT
; _this$ = ecx

; 4604 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 4605 : 	//loop through each project and fill in default art values
; 4606 : #ifdef AUI_WARNING_FIXES
; 4607 : 	for (uint i = 0; i<GC.getNumProjectInfos(); i++)
; 4608 : #else
; 4609 : 	for(int i=0; i<GC.getNumProjectInfos(); i++)

	mov	DWORD PTR _i$225185[ebp], 0
	jmp	SHORT $LN7@finalizePr
$LN6@finalizePr:
	mov	eax, DWORD PTR _i$225185[ebp]
	add	eax, 1
	mov	DWORD PTR _i$225185[ebp], eax
$LN7@finalizePr:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumProjectInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumProjectInfos
	cmp	DWORD PTR _i$225185[ebp], eax
	jge	SHORT $LN8@finalizePr

; 4610 : #endif
; 4611 : 	{
; 4612 : 		ProjectTypes projectType = (ProjectTypes) i;

	mov	ecx, DWORD PTR _i$225185[ebp]
	mov	DWORD PTR _projectType$225189[ebp], ecx

; 4613 : 		int projectCount = getProjectCount(projectType);

	mov	edx, DWORD PTR _projectType$225189[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getProjectCount@CvTeam@@QBEHW4ProjectTypes@@@Z ; CvTeam::getProjectCount
	mov	DWORD PTR _projectCount$225191[ebp], eax

; 4614 : 		for(int j=0; j<projectCount; j++)

	mov	DWORD PTR _j$225192[ebp], 0
	jmp	SHORT $LN4@finalizePr
$LN3@finalizePr:
	mov	eax, DWORD PTR _j$225192[ebp]
	add	eax, 1
	mov	DWORD PTR _j$225192[ebp], eax
$LN4@finalizePr:
	mov	ecx, DWORD PTR _j$225192[ebp]
	cmp	ecx, DWORD PTR _projectCount$225191[ebp]
	jge	SHORT $LN2@finalizePr

; 4615 : 		{
; 4616 : 			int projectArtType = getProjectArtType(projectType, j);

	mov	edx, DWORD PTR _j$225192[ebp]
	push	edx
	mov	eax, DWORD PTR _projectType$225189[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getProjectArtType@CvTeam@@QBEHW4ProjectTypes@@H@Z ; CvTeam::getProjectArtType
	mov	DWORD PTR _projectArtType$225196[ebp], eax

; 4617 : 			if(projectArtType == -1) //undefined

	cmp	DWORD PTR _projectArtType$225196[ebp], -1
	jne	SHORT $LN1@finalizePr

; 4618 : 			{
; 4619 : 				int defaultArtType = getProjectDefaultArtType(projectType);

	mov	ecx, DWORD PTR _projectType$225189[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getProjectDefaultArtType@CvTeam@@QBEHW4ProjectTypes@@@Z ; CvTeam::getProjectDefaultArtType
	mov	DWORD PTR _defaultArtType$225198[ebp], eax

; 4620 : 				setProjectArtType(projectType, j, defaultArtType);

	mov	edx, DWORD PTR _defaultArtType$225198[ebp]
	push	edx
	mov	eax, DWORD PTR _j$225192[ebp]
	push	eax
	mov	ecx, DWORD PTR _projectType$225189[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setProjectArtType@CvTeam@@QAEXW4ProjectTypes@@HH@Z ; CvTeam::setProjectArtType
$LN1@finalizePr:

; 4621 : 			}
; 4622 : 		}

	jmp	SHORT $LN3@finalizePr
$LN2@finalizePr:

; 4623 : 	}

	jmp	$LN6@finalizePr
$LN8@finalizePr:

; 4624 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?finalizeProjectArtTypes@CvTeam@@QAEXXZ ENDP		; CvTeam::finalizeProjectArtTypes
_TEXT	ENDS
PUBLIC	??_C@_0CG@NCAKKGBJ@TXT_KEY_MISC_WONDER_COMPLETED_UN@ ; `string'
PUBLIC	??_C@_0CD@JDIPGDNC@TXT_KEY_MISC_SOMEONE_HAS_COMPLET@ ; `string'
PUBLIC	??_C@_0BP@LEBLICFB@TXT_KEY_MISC_COMPLETES_PROJECT?$AA@ ; `string'
PUBLIC	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
PUBLIC	__$ArrayPad$
EXTRN	?changeNumResourceUsed@CvPlayer@@QAEXW4ResourceTypes@@H@Z:PROC ; CvPlayer::changeNumResourceUsed
EXTRN	?GetResourceQuantityRequirement@CvProjectEntry@@QBEHH@Z:PROC ; CvProjectEntry::GetResourceQuantityRequirement
EXTRN	?GetIDInfo@CvCity@@QBE?AUIDInfo@@XZ:PROC	; CvCity::GetIDInfo
EXTRN	?GetTextKey@CvBaseInfo@@QBEPBDXZ:PROC		; CvBaseInfo::GetTextKey
EXTRN	?GetProjectsNeeded@CvProjectEntry@@QBEHH@Z:PROC	; CvProjectEntry::GetProjectsNeeded
EXTRN	?makeNukesValid@CvGame@@QAEX_N@Z:PROC		; CvGame::makeNukesValid
EXTRN	?IsAllowsNukes@CvProjectEntry@@QBE_NXZ:PROC	; CvProjectEntry::IsAllowsNukes
EXTRN	?makeSpecialUnitValid@CvGame@@QAEXW4SpecialUnitTypes@@@Z:PROC ; CvGame::makeSpecialUnitValid
EXTRN	?GetEveryoneSpecialUnit@CvProjectEntry@@QBEHXZ:PROC ; CvProjectEntry::GetEveryoneSpecialUnit
EXTRN	?testVictory@CvGame@@QAEXXZ:PROC		; CvGame::testVictory
EXTRN	?testVictory@CvGame@@QBE_NW4VictoryTypes@@W4TeamTypes@@PA_N@Z:PROC ; CvGame::testVictory
EXTRN	?GetVictoryThreshold@CvProjectEntry@@QBEHH@Z:PROC ; CvProjectEntry::GetVictoryThreshold
EXTRN	?GetTechShare@CvProjectEntry@@QBEHXZ:PROC	; CvProjectEntry::GetTechShare
EXTRN	?GetNukeInterception@CvProjectEntry@@QBEHXZ:PROC ; CvProjectEntry::GetNukeInterception
EXTRN	?isNetworkMultiPlayer@CvGame@@QBE_NXZ:PROC	; CvGame::isNetworkMultiPlayer
;	COMDAT ??_C@_0CG@NCAKKGBJ@TXT_KEY_MISC_WONDER_COMPLETED_UN@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fautovariable.h
CONST	SEGMENT
??_C@_0CG@NCAKKGBJ@TXT_KEY_MISC_WONDER_COMPLETED_UN@ DB 'TXT_KEY_MISC_WON'
	DB	'DER_COMPLETED_UNKNOWN', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@JDIPGDNC@TXT_KEY_MISC_SOMEONE_HAS_COMPLET@
CONST	SEGMENT
??_C@_0CD@JDIPGDNC@TXT_KEY_MISC_SOMEONE_HAS_COMPLET@ DB 'TXT_KEY_MISC_SOM'
	DB	'EONE_HAS_COMPLETED', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@LEBLICFB@TXT_KEY_MISC_COMPLETES_PROJECT?$AA@
CONST	SEGMENT
??_C@_0BP@LEBLICFB@TXT_KEY_MISC_COMPLETES_PROJECT?$AA@ DB 'TXT_KEY_MISC_C'
	DB	'OMPLETES_PROJECT', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z$1
	DD	02H
	DD	FLAT:__unwindfunclet$?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z$2
	DD	03H
	DD	FLAT:__unwindfunclet$?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z$3
	DD	05H
	DD	FLAT:__unwindfunclet$?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z$4
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z
_TEXT	SEGMENT
tv424 = -460						; size = 4
tv360 = -456						; size = 4
tv258 = -452						; size = 4
tv525 = -448						; size = 4
_this$ = -444						; size = 4
$T236382 = -440						; size = 4
$T236373 = -433						; size = 1
$T236346 = -432						; size = 4
$T236342 = -428						; size = 4
$T236338 = -424						; size = 4
$T236334 = -420						; size = 4
$T236330 = -416						; size = 4
$T236323 = -412						; size = 4
$T236319 = -408						; size = 4
$T236310 = -404						; size = 4
$T236301 = -400						; size = 4
$T236292 = -396						; size = 4
$T236288 = -392						; size = 4
$T236284 = -388						; size = 4
$T236280 = -384						; size = 4
$T236276 = -380						; size = 4
$T236267 = -373						; size = 1
$T236252 = -372						; size = 4
$T236244 = -368						; size = 4
$T236236 = -364						; size = 4
$T236232 = -360						; size = 4
$T236228 = -356						; size = 4
$T236224 = -352						; size = 4
$T236215 = -348						; size = 4
$T236211 = -341						; size = 1
$T236202 = -340						; size = 4
$T236198 = -336						; size = 4
$T236194 = -332						; size = 4
$T236190 = -328						; size = 4
$T236186 = -324						; size = 4
$T236182 = -320						; size = 4
$T236164 = -316						; size = 4
$T236163 = -312						; size = 4
$T236152 = -308						; size = 4
$T236151 = -304						; size = 4
__Cat$236176 = -298					; size = 1
$T236173 = -297						; size = 1
$T236088 = -272						; size = 4
$T236084 = -268						; size = 4
$T236075 = -264						; size = 8
$T236074 = -256						; size = 8
$T236073 = -248						; size = 28
$T236072 = -220						; size = 4
$T236071 = -216						; size = 4
$T236070 = -212						; size = 28
$T236069 = -184						; size = 4
$T236068 = -180						; size = 4
_kPlayer$225292 = -176					; size = 4
_iPlayerLoop$225288 = -172				; size = 4
_iResourceLoop$225283 = -168				; size = 4
_pNotifications$225282 = -164				; size = 4
_pNotifications$225278 = -160				; size = 4
_ePlayer$225271 = -156					; size = 4
_kPlayer$225273 = -152					; size = 4
_playerWhoLeadsTeam$225266 = -148			; size = 4
_strSomeoneCompletesProject$225250 = -144		; size = 28
_eTeamLeader$225265 = -116				; size = 4
_pLeadersCapital$225267 = -112				; size = 4
_strUnknownCompletesProject$225262 = -108		; size = 28
_strSomeoneCompletedProject$225256 = -80		; size = 28
__$ArrayPad$ = -52					; size = 4
_iVictory$225223 = -48					; size = 4
_i$225217 = -44						; size = 4
_i$225212 = -40						; size = 4
_defaultType$225210 = -36				; size = 4
_pkProject$225221 = -32					; size = 4
_iJ$ = -28						; size = 4
_iI$ = -24						; size = 4
_iOldProjectCount$ = -20				; size = 4
_bChangeProduction$ = -13				; size = 1
__$EHRec$ = -12						; size = 12
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z PROC ; CvTeam::changeProjectCount, COMDAT
; _this$ = ecx

; 4629 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 448				; 000001c0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 4630 : 	bool bChangeProduction;
; 4631 : 	int iOldProjectCount;
; 4632 : #ifdef AUI_WARNING_FIXES
; 4633 : 	int iI;
; 4634 : 	uint iJ;
; 4635 : #else
; 4636 : 	int iI, iJ;
; 4637 : #endif
; 4638 : 
; 4639 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4640 : 	CvAssertMsg(eIndex < GC.getNumProjectInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4641 : 
; 4642 : 	if(iChange != 0)

	cmp	DWORD PTR _iChange$[ebp], 0
	je	$LN46@changeProj

; 4643 : 	{
; 4644 : 		GC.getGame().incrementProjectCreatedCount(eIndex, iChange);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T236084[ebp], eax
	mov	ecx, DWORD PTR _iChange$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T236084[ebp]
	call	?incrementProjectCreatedCount@CvGame@@QAEXW4ProjectTypes@@H@Z ; CvGame::incrementProjectCreatedCount

; 4645 : 
; 4646 : 		iOldProjectCount = getProjectCount(eIndex);

	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getProjectCount@CvTeam@@QBEHW4ProjectTypes@@@Z ; CvTeam::getProjectCount
	mov	DWORD PTR _iOldProjectCount$[ebp], eax

; 4647 : 
; 4648 : 		m_paiProjectCount[eIndex] = (m_paiProjectCount[eIndex] + iChange);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2916]
	mov	eax, DWORD PTR _eIndex$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2916]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 4649 : 		CvAssert(getProjectCount(eIndex) >= 0);
; 4650 : 
; 4651 : 		//adjust default art types
; 4652 : 		if(iChange >= 0)

	cmp	DWORD PTR _iChange$[ebp], 0
	jl	SHORT $LN45@changeProj

; 4653 : 		{
; 4654 : 			//multiplayer games default to first art type
; 4655 : 			int defaultType = -1;

	mov	DWORD PTR _defaultType$225210[ebp], -1

; 4656 : 			if(GC.getGame().isNetworkMultiPlayer())

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T236088[ebp], eax
	mov	ecx, DWORD PTR $T236088[ebp]
	call	?isNetworkMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isNetworkMultiPlayer
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN44@changeProj

; 4657 : 				defaultType = getProjectDefaultArtType(eIndex);

	mov	edx, DWORD PTR _eIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getProjectDefaultArtType@CvTeam@@QBEHW4ProjectTypes@@@Z ; CvTeam::getProjectDefaultArtType
	mov	DWORD PTR _defaultType$225210[ebp], eax
$LN44@changeProj:

; 4658 : 
; 4659 : 			for(int i=0; i<iChange; i++)

	mov	DWORD PTR _i$225212[ebp], 0
	jmp	SHORT $LN43@changeProj
$LN42@changeProj:
	mov	eax, DWORD PTR _i$225212[ebp]
	add	eax, 1
	mov	DWORD PTR _i$225212[ebp], eax
$LN43@changeProj:
	mov	ecx, DWORD PTR _i$225212[ebp]
	cmp	ecx, DWORD PTR _iChange$[ebp]
	jge	SHORT $LN41@changeProj

; 4660 : 				m_pavProjectArtTypes[eIndex].push_back(defaultType);

	lea	edx, DWORD PTR _defaultType$225210[ebp]
	push	edx
	mov	ecx, DWORD PTR _eIndex$[ebp]
	shl	ecx, 4
	mov	eax, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [eax+2960]
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
	jmp	SHORT $LN42@changeProj
$LN41@changeProj:

; 4661 : 		}
; 4662 : 		else

	jmp	$LN40@changeProj
$LN45@changeProj:

; 4663 : 		{
; 4664 : 			for(int i=0; i<-iChange; i++)

	mov	DWORD PTR _i$225217[ebp], 0
	jmp	SHORT $LN39@changeProj
$LN38@changeProj:
	mov	ecx, DWORD PTR _i$225217[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$225217[ebp], ecx
$LN39@changeProj:
	mov	edx, DWORD PTR _iChange$[ebp]
	neg	edx
	cmp	DWORD PTR _i$225217[ebp], edx
	jge	$LN40@changeProj

; 4665 : 				m_pavProjectArtTypes[eIndex].pop_back();

	mov	eax, DWORD PTR _eIndex$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+2960]
	mov	DWORD PTR $T236182[ebp], eax
	mov	edx, DWORD PTR $T236182[ebp]
	mov	eax, DWORD PTR $T236182[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN77@changeProj
	mov	eax, DWORD PTR $T236182[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T236164[ebp], ecx
	mov	edx, DWORD PTR $T236182[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, 4
	mov	DWORD PTR $T236163[ebp], eax
	mov	ecx, DWORD PTR $T236164[ebp]
	mov	DWORD PTR $T236152[ebp], ecx
	mov	edx, DWORD PTR $T236163[ebp]
	mov	DWORD PTR $T236151[ebp], edx
	mov	al, BYTE PTR __Cat$236176[ebp]
	mov	BYTE PTR $T236173[ebp], al
	mov	ecx, DWORD PTR $T236182[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, 4
	mov	eax, DWORD PTR $T236182[ebp]
	mov	DWORD PTR [eax+8], edx
$LN77@changeProj:
	jmp	$LN38@changeProj
$LN40@changeProj:

; 4666 : 		}
; 4667 : 		CvAssertMsg(getProjectCount(eIndex) == (int)m_pavProjectArtTypes[eIndex].size(), "[Jason] Unbalanced project art types.");
; 4668 : 
; 4669 : 		CvProjectEntry* pkProject = GC.getProjectInfo(eIndex);

	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getProjectInfo@CvGlobals@@QAEPAVCvProjectEntry@@W4ProjectTypes@@@Z ; CvGlobals::getProjectInfo
	mov	DWORD PTR _pkProject$225221[ebp], eax

; 4670 : 
; 4671 : 		changeNukeInterception(pkProject->GetNukeInterception() * iChange);

	mov	ecx, DWORD PTR _pkProject$225221[ebp]
	call	?GetNukeInterception@CvProjectEntry@@QBEHXZ ; CvProjectEntry::GetNukeInterception
	imul	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeNukeInterception@CvTeam@@QAEXH@Z	; CvTeam::changeNukeInterception

; 4672 : 
; 4673 : 		if((pkProject->GetTechShare() > 0) && (pkProject->GetTechShare() <= MAX_TEAMS))

	mov	ecx, DWORD PTR _pkProject$225221[ebp]
	call	?GetTechShare@CvProjectEntry@@QBEHXZ	; CvProjectEntry::GetTechShare
	test	eax, eax
	jle	SHORT $LN36@changeProj
	mov	ecx, DWORD PTR _pkProject$225221[ebp]
	call	?GetTechShare@CvProjectEntry@@QBEHXZ	; CvProjectEntry::GetTechShare
	cmp	eax, 64					; 00000040H
	jg	SHORT $LN36@changeProj

; 4674 : 		{
; 4675 : 			changeTechShareCount((pkProject->GetTechShare() - 1), iChange);

	mov	edx, DWORD PTR _iChange$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkProject$225221[ebp]
	call	?GetTechShare@CvProjectEntry@@QBEHXZ	; CvProjectEntry::GetTechShare
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeTechShareCount@CvTeam@@QAEXHH@Z	; CvTeam::changeTechShareCount
$LN36@changeProj:

; 4676 : 		}
; 4677 : 
; 4678 : #ifdef AUI_WARNING_FIXES
; 4679 : 		for (uint iVictory = 0; iVictory < GC.getNumVictoryInfos(); ++iVictory)
; 4680 : #else
; 4681 : 		for(int iVictory = 0; iVictory < GC.getNumVictoryInfos(); ++iVictory)

	mov	DWORD PTR _iVictory$225223[ebp], 0
	jmp	SHORT $LN35@changeProj
$LN34@changeProj:
	mov	eax, DWORD PTR _iVictory$225223[ebp]
	add	eax, 1
	mov	DWORD PTR _iVictory$225223[ebp], eax
$LN35@changeProj:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumVictoryInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumVictoryInfos
	cmp	DWORD PTR _iVictory$225223[ebp], eax
	jge	SHORT $LN33@changeProj

; 4682 : #endif
; 4683 : 		{
; 4684 : 			if(pkProject->GetVictoryThreshold(iVictory) > 0)

	mov	ecx, DWORD PTR _iVictory$225223[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkProject$225221[ebp]
	call	?GetVictoryThreshold@CvProjectEntry@@QBEHH@Z ; CvProjectEntry::GetVictoryThreshold
	test	eax, eax
	jle	SHORT $LN32@changeProj

; 4685 : 			{
; 4686 : 				m_abCanLaunch[iVictory] = GC.getGame().testVictory((VictoryTypes)iVictory, GetID());

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T236186[ebp], edx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	eax, DWORD PTR _iVictory$225223[ebp]
	push	eax
	mov	ecx, DWORD PTR $T236186[ebp]
	call	?testVictory@CvGame@@QBE_NW4VictoryTypes@@W4TeamTypes@@PA_N@Z ; CvGame::testVictory
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2896]
	mov	ecx, DWORD PTR _iVictory$225223[ebp]
	mov	BYTE PTR [edx+ecx], al

; 4687 : 				GC.getGame().testVictory();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T236190[ebp], edx
	mov	ecx, DWORD PTR $T236190[ebp]
	call	?testVictory@CvGame@@QAEXXZ		; CvGame::testVictory
$LN32@changeProj:

; 4688 : 			}
; 4689 : 		}

	jmp	SHORT $LN34@changeProj
$LN33@changeProj:

; 4690 : 
; 4691 : 		if(iChange > 0)

	cmp	DWORD PTR _iChange$[ebp], 0
	jle	$LN46@changeProj

; 4692 : 		{
; 4693 : 			if(pkProject->GetEveryoneSpecialUnit() != NO_SPECIALUNIT)

	mov	ecx, DWORD PTR _pkProject$225221[ebp]
	call	?GetEveryoneSpecialUnit@CvProjectEntry@@QBEHXZ ; CvProjectEntry::GetEveryoneSpecialUnit
	cmp	eax, -1
	je	SHORT $LN30@changeProj

; 4694 : 			{
; 4695 : 				GC.getGame().makeSpecialUnitValid((SpecialUnitTypes)(pkProject->GetEveryoneSpecialUnit()));

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T236194[ebp], eax
	mov	ecx, DWORD PTR _pkProject$225221[ebp]
	call	?GetEveryoneSpecialUnit@CvProjectEntry@@QBEHXZ ; CvProjectEntry::GetEveryoneSpecialUnit
	push	eax
	mov	ecx, DWORD PTR $T236194[ebp]
	call	?makeSpecialUnitValid@CvGame@@QAEXW4SpecialUnitTypes@@@Z ; CvGame::makeSpecialUnitValid
$LN30@changeProj:

; 4696 : 			}
; 4697 : 
; 4698 : 			if(pkProject->IsAllowsNukes())

	mov	ecx, DWORD PTR _pkProject$225221[ebp]
	call	?IsAllowsNukes@CvProjectEntry@@QBE_NXZ	; CvProjectEntry::IsAllowsNukes
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN29@changeProj

; 4699 : 			{
; 4700 : 				GC.getGame().makeNukesValid(true);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T236198[ebp], edx
	push	1
	mov	ecx, DWORD PTR $T236198[ebp]
	call	?makeNukesValid@CvGame@@QAEX_N@Z	; CvGame::makeNukesValid
$LN29@changeProj:

; 4701 : 			}
; 4702 : 
; 4703 : 			for(iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN28@changeProj
$LN27@changeProj:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN28@changeProj:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	$LN26@changeProj

; 4704 : 			{
; 4705 : 				if(GET_PLAYER((PlayerTypes)iI).isAlive())

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T236202[ebp], ecx
	mov	edx, DWORD PTR $T236202[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T236211[ebp], al
	movzx	ecx, BYTE PTR $T236211[ebp]
	test	ecx, ecx
	je	$LN25@changeProj

; 4706 : 				{
; 4707 : 					if(GET_PLAYER((PlayerTypes)iI).getTeam() == GetID())

	mov	edx, DWORD PTR _iI$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T236215[ebp], edx
	mov	eax, DWORD PTR $T236215[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T236224[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T236224[ebp], eax
	jne	$LN25@changeProj

; 4708 : 					{
; 4709 : 						if(!(GET_PLAYER((PlayerTypes)iI).isHuman()))

	mov	edx, DWORD PTR _iI$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T236228[ebp], edx
	mov	ecx, DWORD PTR $T236228[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN25@changeProj

; 4710 : 						{
; 4711 : 							bChangeProduction = false;

	mov	BYTE PTR _bChangeProduction$[ebp], 0

; 4712 : 
; 4713 : 							for(iJ = 0; iJ < GC.getNumProjectInfos(); iJ++)

	mov	DWORD PTR _iJ$[ebp], 0
	jmp	SHORT $LN22@changeProj
$LN21@changeProj:
	mov	ecx, DWORD PTR _iJ$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iJ$[ebp], ecx
$LN22@changeProj:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumProjectInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumProjectInfos
	cmp	DWORD PTR _iJ$[ebp], eax
	jge	SHORT $LN25@changeProj

; 4714 : 							{
; 4715 : 								if((getProjectCount(eIndex) >= GC.getProjectInfo((ProjectTypes)iJ)->GetProjectsNeeded(eIndex)) &&
; 4716 : 								        (iOldProjectCount < GC.getProjectInfo((ProjectTypes)iJ)->GetProjectsNeeded(eIndex)))

	mov	edx, DWORD PTR _eIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getProjectCount@CvTeam@@QBEHW4ProjectTypes@@@Z ; CvTeam::getProjectCount
	mov	esi, eax
	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iJ$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getProjectInfo@CvGlobals@@QAEPAVCvProjectEntry@@W4ProjectTypes@@@Z ; CvGlobals::getProjectInfo
	mov	ecx, eax
	call	?GetProjectsNeeded@CvProjectEntry@@QBEHH@Z ; CvProjectEntry::GetProjectsNeeded
	cmp	esi, eax
	jl	SHORT $LN19@changeProj
	mov	edx, DWORD PTR _eIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR _iJ$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getProjectInfo@CvGlobals@@QAEPAVCvProjectEntry@@W4ProjectTypes@@@Z ; CvGlobals::getProjectInfo
	mov	ecx, eax
	call	?GetProjectsNeeded@CvProjectEntry@@QBEHH@Z ; CvProjectEntry::GetProjectsNeeded
	cmp	DWORD PTR _iOldProjectCount$[ebp], eax
	jge	SHORT $LN19@changeProj

; 4717 : 								{
; 4718 : 									bChangeProduction = true;

	mov	BYTE PTR _bChangeProduction$[ebp], 1

; 4719 : 									break;

	jmp	SHORT $LN25@changeProj
$LN19@changeProj:

; 4720 : 								}
; 4721 : 							}

	jmp	SHORT $LN21@changeProj
$LN25@changeProj:

; 4722 : 
; 4723 : 							if(bChangeProduction)
; 4724 : 							{
; 4725 : 								//GET_PLAYER((PlayerTypes)iI).AI_makeProductionDirty();
; 4726 : 							}
; 4727 : 						}
; 4728 : 					}
; 4729 : 				}
; 4730 : 			}

	jmp	$LN27@changeProj
$LN26@changeProj:

; 4731 : 
; 4732 : 			if(GC.getGame().isFinalInitialized())

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T236232[ebp], edx
	mov	ecx, DWORD PTR $T236232[ebp]
	call	?isFinalInitialized@CvGame@@QBE_NXZ	; CvGame::isFinalInitialized
	movzx	eax, al
	test	eax, eax
	je	$LN46@changeProj

; 4733 : 			{
; 4734 : 				CvString strSomeoneCompletesProject = GetLocalizedText("TXT_KEY_MISC_COMPLETES_PROJECT", getName().GetCString(), pkProject->GetTextKey());

	mov	ecx, DWORD PTR _pkProject$225221[ebp]
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	mov	DWORD PTR $T236068[ebp], eax
	lea	ecx, DWORD PTR $T236070[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	DWORD PTR tv525[ebp], eax
	mov	edx, DWORD PTR tv525[ebp]
	mov	DWORD PTR $T236236[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR $T236236[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T236069[ebp], eax
	lea	eax, DWORD PTR $T236068[ebp]
	push	eax
	lea	ecx, DWORD PTR $T236069[ebp]
	push	ecx
	push	OFFSET ??_C@_0BP@LEBLICFB@TXT_KEY_MISC_COMPLETES_PROJECT?$AA@
	lea	edx, DWORD PTR _strSomeoneCompletesProject$225250[ebp]
	push	edx
	call	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
	add	esp, 16					; 00000010H
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T236070[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4735 : 				CvString strSomeoneCompletedProject = GetLocalizedText("TXT_KEY_MISC_SOMEONE_HAS_COMPLETED", getName().GetCString(), pkProject->GetTextKey());

	mov	ecx, DWORD PTR _pkProject$225221[ebp]
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	mov	DWORD PTR $T236071[ebp], eax
	lea	eax, DWORD PTR $T236073[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	DWORD PTR tv258[ebp], eax
	mov	ecx, DWORD PTR tv258[ebp]
	mov	DWORD PTR $T236244[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR $T236244[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T236072[ebp], eax
	lea	edx, DWORD PTR $T236071[ebp]
	push	edx
	lea	eax, DWORD PTR $T236072[ebp]
	push	eax
	push	OFFSET ??_C@_0CD@JDIPGDNC@TXT_KEY_MISC_SOMEONE_HAS_COMPLET@
	lea	ecx, DWORD PTR _strSomeoneCompletedProject$225256[ebp]
	push	ecx
	call	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
	add	esp, 16					; 00000010H
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T236073[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4736 : 				CvString strUnknownCompletesProject = GetLocalizedText("TXT_KEY_MISC_WONDER_COMPLETED_UNKNOWN", pkProject->GetTextKey());

	mov	ecx, DWORD PTR _pkProject$225221[ebp]
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	push	eax
	push	OFFSET ??_C@_0CG@NCAKKGBJ@TXT_KEY_MISC_WONDER_COMPLETED_UN@
	lea	edx, DWORD PTR _strUnknownCompletesProject$225262[ebp]
	push	edx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	BYTE PTR __$EHRec$[ebp+8], 6

; 4737 : 
; 4738 : 				const PlayerTypes eTeamLeader = getLeaderID();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	mov	DWORD PTR _eTeamLeader$225265[ebp], eax

; 4739 : 				GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, eTeamLeader, strSomeoneCompletesProject);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T236252[ebp], eax
	push	-1
	push	-1
	lea	ecx, DWORD PTR _strSomeoneCompletesProject$225250[ebp]
	push	ecx
	mov	edx, DWORD PTR _eTeamLeader$225265[ebp]
	push	edx
	push	0
	mov	ecx, DWORD PTR $T236252[ebp]
	call	?addReplayMessage@CvGame@@QAEXW4ReplayMessageTypes@@W4PlayerTypes@@ABVCvString@@HH@Z ; CvGame::addReplayMessage

; 4740 : 
; 4741 : 				CvPlayerAI& playerWhoLeadsTeam = GET_PLAYER(eTeamLeader);

	mov	eax, DWORD PTR _eTeamLeader$225265[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _playerWhoLeadsTeam$225266[ebp], eax

; 4742 : 				CvCity* pLeadersCapital = playerWhoLeadsTeam.getCapitalCity();

	mov	ecx, DWORD PTR _playerWhoLeadsTeam$225266[ebp]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	DWORD PTR _pLeadersCapital$225267[ebp], eax

; 4743 : 
; 4744 : 
; 4745 : 				for(iI = 0; iI < MAX_MAJOR_CIVS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN16@changeProj
$LN15@changeProj:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN16@changeProj:
	cmp	DWORD PTR _iI$[ebp], 22			; 00000016H
	jge	$LN14@changeProj

; 4746 : 				{
; 4747 : 					const PlayerTypes ePlayer = static_cast<PlayerTypes>(iI);

	mov	edx, DWORD PTR _iI$[ebp]
	mov	DWORD PTR _ePlayer$225271[ebp], edx

; 4748 : 					CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);

	mov	eax, DWORD PTR _ePlayer$225271[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$225273[ebp], eax

; 4749 : 
; 4750 : 					if(kPlayer.isAlive())

	mov	ecx, DWORD PTR _kPlayer$225273[ebp]
	mov	dl, BYTE PTR [ecx+2256]
	mov	BYTE PTR $T236267[ebp], dl
	movzx	eax, BYTE PTR $T236267[ebp]
	test	eax, eax
	je	$LN13@changeProj

; 4751 : 					{
; 4752 : 						if(isHasMet(kPlayer.getTeam()))

	mov	ecx, DWORD PTR _kPlayer$225273[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T236276[ebp], eax
	mov	eax, DWORD PTR $T236276[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	movzx	ecx, al
	test	ecx, ecx
	je	$LN12@changeProj

; 4753 : 						{
; 4754 : 							if(ePlayer == GC.getGame().getActivePlayer())

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T236280[ebp], edx
	mov	ecx, DWORD PTR $T236280[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	DWORD PTR _ePlayer$225271[ebp], eax
	jne	$LN11@changeProj

; 4755 : 							{
; 4756 : 								DLLUI->AddCityMessage(0, pLeadersCapital->GetIDInfo(), ePlayer, false, GC.getEVENT_MESSAGE_TIME(), strSomeoneCompletedProject);

	mov	eax, DWORD PTR $T236284[ebp]
	mov	DWORD PTR tv360[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv360[ebp], ecx
	lea	ecx, DWORD PTR _strSomeoneCompletedProject$225256[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T236288[ebp], eax
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	mov	DWORD PTR $T236292[ebp], edx
	push	0
	push	0
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR $T236288[ebp]
	push	eax
	mov	ecx, DWORD PTR $T236292[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _ePlayer$225271[ebp]
	push	edx
	lea	eax, DWORD PTR $T236074[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLeadersCapital$225267[ebp]
	call	?GetIDInfo@CvCity@@QBE?AUIDInfo@@XZ	; CvCity::GetIDInfo
	push	eax
	push	0
	mov	ecx, DWORD PTR tv360[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv360[ebp]
	mov	eax, DWORD PTR [edx+172]
	call	eax
$LN11@changeProj:

; 4757 : 							}
; 4758 : 							CvNotifications* pNotifications = kPlayer.GetNotifications();

	mov	ecx, DWORD PTR _kPlayer$225273[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotifications$225278[ebp], eax

; 4759 : 							pNotifications->Add(NOTIFICATION_PROJECT_COMPLETED, strSomeoneCompletedProject, strSomeoneCompletedProject, pLeadersCapital->getX(), pLeadersCapital->getY(), eIndex, playerWhoLeadsTeam.GetID());

	mov	ecx, DWORD PTR _playerWhoLeadsTeam$225266[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T236301[ebp], edx
	mov	eax, DWORD PTR _pLeadersCapital$225267[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR $T236310[ebp], ecx
	mov	edx, DWORD PTR _pLeadersCapital$225267[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR $T236319[ebp], eax
	lea	ecx, DWORD PTR _strSomeoneCompletedProject$225256[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T236323[ebp], eax
	mov	ecx, DWORD PTR $T236301[ebp]
	push	ecx
	mov	edx, DWORD PTR _eIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR $T236310[ebp]
	push	eax
	mov	ecx, DWORD PTR $T236319[ebp]
	push	ecx
	mov	edx, DWORD PTR $T236323[ebp]
	push	edx
	lea	ecx, DWORD PTR _strSomeoneCompletedProject$225256[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	1595436701				; 5f186e9dH
	mov	ecx, DWORD PTR _pNotifications$225278[ebp]
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 4760 : 						}
; 4761 : 						else

	jmp	$LN13@changeProj
$LN12@changeProj:

; 4762 : 						{
; 4763 : 							if(ePlayer == GC.getGame().getActivePlayer())

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T236330[ebp], eax
	mov	ecx, DWORD PTR $T236330[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	DWORD PTR _ePlayer$225271[ebp], eax
	jne	$LN9@changeProj

; 4764 : 							{
; 4765 : 								DLLUI->AddCityMessage(0, pLeadersCapital->GetIDInfo(), ePlayer, false, GC.getEVENT_MESSAGE_TIME(), strUnknownCompletesProject);

	mov	ecx, DWORD PTR $T236334[ebp]
	mov	DWORD PTR tv424[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv424[ebp], edx
	lea	ecx, DWORD PTR _strUnknownCompletesProject$225262[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T236338[ebp], eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	mov	DWORD PTR $T236342[ebp], eax
	push	0
	push	0
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR $T236338[ebp]
	push	ecx
	mov	edx, DWORD PTR $T236342[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _ePlayer$225271[ebp]
	push	eax
	lea	ecx, DWORD PTR $T236075[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLeadersCapital$225267[ebp]
	call	?GetIDInfo@CvCity@@QBE?AUIDInfo@@XZ	; CvCity::GetIDInfo
	push	eax
	push	0
	mov	edx, DWORD PTR tv424[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv424[ebp]
	mov	edx, DWORD PTR [eax+172]
	call	edx
$LN9@changeProj:

; 4766 : 							}
; 4767 : 							CvNotifications* pNotifications = kPlayer.GetNotifications();

	mov	ecx, DWORD PTR _kPlayer$225273[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotifications$225282[ebp], eax

; 4768 : 							pNotifications->Add(NOTIFICATION_PROJECT_COMPLETED, strUnknownCompletesProject, strUnknownCompletesProject, -1, -1, eIndex, NO_PLAYER);

	lea	ecx, DWORD PTR _strUnknownCompletesProject$225262[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T236346[ebp], eax
	push	-1
	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	push	-1
	push	-1
	mov	ecx, DWORD PTR $T236346[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strUnknownCompletesProject$225262[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	1595436701				; 5f186e9dH
	mov	ecx, DWORD PTR _pNotifications$225282[ebp]
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN13@changeProj:

; 4769 : 						}
; 4770 : 					}
; 4771 : 				}

	jmp	$LN15@changeProj
$LN14@changeProj:

; 4772 : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR _strUnknownCompletesProject$225262[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _strSomeoneCompletedProject$225256[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strSomeoneCompletesProject$225250[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN46@changeProj:

; 4773 : 		}
; 4774 : 	}
; 4775 : 
; 4776 : 	// Update the amount of a Resource used up by this Project
; 4777 : #ifdef AUI_WARNING_FIXES
; 4778 : 	for (uint iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
; 4779 : #else
; 4780 : 	for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)

	mov	DWORD PTR _iResourceLoop$225283[ebp], 0
	jmp	SHORT $LN8@changeProj
$LN7@changeProj:
	mov	edx, DWORD PTR _iResourceLoop$225283[ebp]
	add	edx, 1
	mov	DWORD PTR _iResourceLoop$225283[ebp], edx
$LN8@changeProj:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	DWORD PTR _iResourceLoop$225283[ebp], eax
	jge	$LN47@changeProj

; 4781 : #endif
; 4782 : 	{
; 4783 : 		if(GC.getProjectInfo(eIndex)->GetResourceQuantityRequirement(iResourceLoop) > 0)

	mov	eax, DWORD PTR _iResourceLoop$225283[ebp]
	push	eax
	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getProjectInfo@CvGlobals@@QAEPAVCvProjectEntry@@W4ProjectTypes@@@Z ; CvGlobals::getProjectInfo
	mov	ecx, eax
	call	?GetResourceQuantityRequirement@CvProjectEntry@@QBEHH@Z ; CvProjectEntry::GetResourceQuantityRequirement
	test	eax, eax
	jle	$LN5@changeProj

; 4784 : 		{
; 4785 : 			for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)

	mov	DWORD PTR _iPlayerLoop$225288[ebp], 0
	jmp	SHORT $LN4@changeProj
$LN3@changeProj:
	mov	edx, DWORD PTR _iPlayerLoop$225288[ebp]
	add	edx, 1
	mov	DWORD PTR _iPlayerLoop$225288[ebp], edx
$LN4@changeProj:
	cmp	DWORD PTR _iPlayerLoop$225288[ebp], 63	; 0000003fH
	jge	$LN5@changeProj

; 4786 : 			{
; 4787 : 				CvPlayerAI& kPlayer = GET_PLAYER((PlayerTypes) iPlayerLoop);

	mov	eax, DWORD PTR _iPlayerLoop$225288[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$225292[ebp], eax

; 4788 : 				if(kPlayer.isAlive() && kPlayer.getTeam() == GetID())

	mov	ecx, DWORD PTR _kPlayer$225292[ebp]
	mov	dl, BYTE PTR [ecx+2256]
	mov	BYTE PTR $T236373[ebp], dl
	movzx	eax, BYTE PTR $T236373[ebp]
	test	eax, eax
	je	SHORT $LN1@changeProj
	mov	ecx, DWORD PTR _kPlayer$225292[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T236382[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T236382[ebp], eax
	jne	SHORT $LN1@changeProj

; 4789 : 				{
; 4790 : 					kPlayer.changeNumResourceUsed((ResourceTypes) iResourceLoop, iChange * GC.getProjectInfo(eIndex)->GetResourceQuantityRequirement(iResourceLoop));

	mov	eax, DWORD PTR _iResourceLoop$225283[ebp]
	push	eax
	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getProjectInfo@CvGlobals@@QAEPAVCvProjectEntry@@W4ProjectTypes@@@Z ; CvGlobals::getProjectInfo
	mov	ecx, eax
	call	?GetResourceQuantityRequirement@CvProjectEntry@@QBEHH@Z ; CvProjectEntry::GetResourceQuantityRequirement
	imul	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	edx, DWORD PTR _iResourceLoop$225283[ebp]
	push	edx
	mov	ecx, DWORD PTR _kPlayer$225292[ebp]
	call	?changeNumResourceUsed@CvPlayer@@QAEXW4ResourceTypes@@H@Z ; CvPlayer::changeNumResourceUsed
$LN1@changeProj:

; 4791 : 				}

	jmp	$LN3@changeProj
$LN5@changeProj:

; 4792 : 			}

	jmp	$LN7@changeProj
$LN47@changeProj:

; 4793 : 		}
; 4794 : 	}
; 4795 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z$0:
	lea	ecx, DWORD PTR $T236070[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z$1:
	lea	ecx, DWORD PTR _strSomeoneCompletesProject$225250[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z$2:
	lea	ecx, DWORD PTR $T236073[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z$3:
	lea	ecx, DWORD PTR _strSomeoneCompletedProject$225256[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z$4:
	lea	ecx, DWORD PTR _strUnknownCompletesProject$225262[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-456]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z ENDP ; CvTeam::changeProjectCount
; Function compile flags: /Odtp
;	COMDAT ?getProjectMaking@CvTeam@@QBEHW4ProjectTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?getProjectMaking@CvTeam@@QBEHW4ProjectTypes@@@Z PROC	; CvTeam::getProjectMaking, COMDAT
; _this$ = ecx

; 4800 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4801 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4802 : 	CvAssertMsg(eIndex < GC.getNumProjectInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4803 : 	return m_paiProjectMaking[eIndex];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2924]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 4804 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getProjectMaking@CvTeam@@QBEHW4ProjectTypes@@@Z ENDP	; CvTeam::getProjectMaking
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?changeProjectMaking@CvTeam@@QAEXW4ProjectTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?changeProjectMaking@CvTeam@@QAEXW4ProjectTypes@@H@Z PROC ; CvTeam::changeProjectMaking, COMDAT
; _this$ = ecx

; 4809 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4810 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4811 : 	CvAssertMsg(eIndex < GC.getNumProjectInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4812 : 	m_paiProjectMaking[eIndex] = (m_paiProjectMaking[eIndex] + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2924]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	add	eax, DWORD PTR _iChange$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2924]
	mov	ecx, DWORD PTR _eIndex$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 4813 : 	CvAssert(getProjectMaking(eIndex) >= 0);
; 4814 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?changeProjectMaking@CvTeam@@QAEXW4ProjectTypes@@H@Z ENDP ; CvTeam::changeProjectMaking
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getUnitClassCount@CvTeam@@QBEHW4UnitClassTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?getUnitClassCount@CvTeam@@QBEHW4UnitClassTypes@@@Z PROC ; CvTeam::getUnitClassCount, COMDAT
; _this$ = ecx

; 4819 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4820 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4821 : 	CvAssertMsg(eIndex < GC.getNumUnitClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4822 : 	return m_paiUnitClassCount[eIndex];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2928]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 4823 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getUnitClassCount@CvTeam@@QBEHW4UnitClassTypes@@@Z ENDP ; CvTeam::getUnitClassCount
_TEXT	ENDS
PUBLIC	?isUnitClassMaxedOut@CvTeam@@QBE_NW4UnitClassTypes@@H@Z ; CvTeam::isUnitClassMaxedOut
EXTRN	?getMaxTeamInstances@CvUnitClassInfo@@QBEHXZ:PROC ; CvUnitClassInfo::getMaxTeamInstances
EXTRN	?isTeamUnitClass@@YA_NW4UnitClassTypes@@@Z:PROC	; isTeamUnitClass
; Function compile flags: /Odtp
;	COMDAT ?isUnitClassMaxedOut@CvTeam@@QBE_NW4UnitClassTypes@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pkUnitClassInfo$ = -4					; size = 4
_eIndex$ = 8						; size = 4
_iExtra$ = 12						; size = 4
?isUnitClassMaxedOut@CvTeam@@QBE_NW4UnitClassTypes@@H@Z PROC ; CvTeam::isUnitClassMaxedOut, COMDAT
; _this$ = ecx

; 4828 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 4829 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4830 : 	CvAssertMsg(eIndex < GC.getNumUnitClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4831 : 
; 4832 : 	CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eIndex);

	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitClassInfo@CvGlobals@@QAEPAVCvUnitClassInfo@@W4UnitClassTypes@@@Z ; CvGlobals::getUnitClassInfo
	mov	DWORD PTR _pkUnitClassInfo$[ebp], eax

; 4833 : 	if(pkUnitClassInfo == NULL)

	cmp	DWORD PTR _pkUnitClassInfo$[ebp], 0
	jne	SHORT $LN2@isUnitClas

; 4834 : 	{
; 4835 : 		return false;

	xor	al, al
	jmp	SHORT $LN3@isUnitClas
$LN2@isUnitClas:

; 4836 : 	}
; 4837 : 
; 4838 : 	if(!isTeamUnitClass(eIndex))

	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	call	?isTeamUnitClass@@YA_NW4UnitClassTypes@@@Z ; isTeamUnitClass
	add	esp, 4
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN1@isUnitClas

; 4839 : 	{
; 4840 : 		return false;

	xor	al, al
	jmp	SHORT $LN3@isUnitClas
$LN1@isUnitClas:

; 4841 : 	}
; 4842 : 
; 4843 : 	CvAssertMsg(getUnitClassCount(eIndex) <= pkUnitClassInfo->getMaxTeamInstances(), "The current unit class count is expected not to exceed the maximum number of instances allowed for this team");
; 4844 : 
; 4845 : 	return ((getUnitClassCount(eIndex) + iExtra) >= pkUnitClassInfo->getMaxTeamInstances());

	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getUnitClassCount@CvTeam@@QBEHW4UnitClassTypes@@@Z ; CvTeam::getUnitClassCount
	mov	esi, eax
	add	esi, DWORD PTR _iExtra$[ebp]
	mov	ecx, DWORD PTR _pkUnitClassInfo$[ebp]
	call	?getMaxTeamInstances@CvUnitClassInfo@@QBEHXZ ; CvUnitClassInfo::getMaxTeamInstances
	xor	ecx, ecx
	cmp	esi, eax
	setge	cl
	mov	al, cl
$LN3@isUnitClas:

; 4846 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?isUnitClassMaxedOut@CvTeam@@QBE_NW4UnitClassTypes@@H@Z ENDP ; CvTeam::isUnitClassMaxedOut
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?changeUnitClassCount@CvTeam@@QAEXW4UnitClassTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?changeUnitClassCount@CvTeam@@QAEXW4UnitClassTypes@@H@Z PROC ; CvTeam::changeUnitClassCount, COMDAT
; _this$ = ecx

; 4851 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4852 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4853 : 	CvAssertMsg(eIndex < GC.getNumUnitClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4854 : 	m_paiUnitClassCount[eIndex] = (m_paiUnitClassCount[eIndex] + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2928]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	add	eax, DWORD PTR _iChange$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2928]
	mov	ecx, DWORD PTR _eIndex$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 4855 : 	CvAssert(getUnitClassCount(eIndex) >= 0);
; 4856 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?changeUnitClassCount@CvTeam@@QAEXW4UnitClassTypes@@H@Z ENDP ; CvTeam::changeUnitClassCount
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getBuildingClassCount@CvTeam@@QBEHW4BuildingClassTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?getBuildingClassCount@CvTeam@@QBEHW4BuildingClassTypes@@@Z PROC ; CvTeam::getBuildingClassCount, COMDAT
; _this$ = ecx

; 4861 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4862 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4863 : 	CvAssertMsg(eIndex < GC.getNumBuildingClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4864 : 	return m_paiBuildingClassCount[eIndex];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2932]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 4865 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getBuildingClassCount@CvTeam@@QBEHW4BuildingClassTypes@@@Z ENDP ; CvTeam::getBuildingClassCount
_TEXT	ENDS
PUBLIC	?isBuildingClassMaxedOut@CvTeam@@QBE_NW4BuildingClassTypes@@H@Z ; CvTeam::isBuildingClassMaxedOut
EXTRN	?getMaxTeamInstances@CvBuildingClassInfo@@QBEHXZ:PROC ; CvBuildingClassInfo::getMaxTeamInstances
EXTRN	?isTeamWonderClass@@YA_NABVCvBuildingClassInfo@@@Z:PROC ; isTeamWonderClass
; Function compile flags: /Odtp
;	COMDAT ?isBuildingClassMaxedOut@CvTeam@@QBE_NW4BuildingClassTypes@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pkBuildingClassInfo$ = -4				; size = 4
_eIndex$ = 8						; size = 4
_iExtra$ = 12						; size = 4
?isBuildingClassMaxedOut@CvTeam@@QBE_NW4BuildingClassTypes@@H@Z PROC ; CvTeam::isBuildingClassMaxedOut, COMDAT
; _this$ = ecx

; 4870 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 4871 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4872 : 	CvAssertMsg(eIndex < GC.getNumBuildingClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4873 : 
; 4874 : 	CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eIndex);

	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z ; CvGlobals::getBuildingClassInfo
	mov	DWORD PTR _pkBuildingClassInfo$[ebp], eax

; 4875 : 	if(pkBuildingClassInfo == NULL)

	cmp	DWORD PTR _pkBuildingClassInfo$[ebp], 0
	jne	SHORT $LN2@isBuilding

; 4876 : 	{
; 4877 : 		CvAssertMsg(false, "Could not find BuildingClassInfo for BuildingClassType.");
; 4878 : 		return false;

	xor	al, al
	jmp	SHORT $LN3@isBuilding
$LN2@isBuilding:

; 4879 : 	}
; 4880 : 
; 4881 : 	if(!isTeamWonderClass(*pkBuildingClassInfo))

	mov	ecx, DWORD PTR _pkBuildingClassInfo$[ebp]
	push	ecx
	call	?isTeamWonderClass@@YA_NABVCvBuildingClassInfo@@@Z ; isTeamWonderClass
	add	esp, 4
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN1@isBuilding

; 4882 : 	{
; 4883 : 		return false;

	xor	al, al
	jmp	SHORT $LN3@isBuilding
$LN1@isBuilding:

; 4884 : 	}
; 4885 : 
; 4886 : 	CvAssertMsg(getBuildingClassCount(eIndex) <= pkBuildingClassInfo->getMaxTeamInstances(), "The current building class count is expected not to exceed the maximum number of instances allowed for this team");
; 4887 : 
; 4888 : 	return ((getBuildingClassCount(eIndex) + iExtra) >= pkBuildingClassInfo->getMaxTeamInstances());

	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getBuildingClassCount@CvTeam@@QBEHW4BuildingClassTypes@@@Z ; CvTeam::getBuildingClassCount
	mov	esi, eax
	add	esi, DWORD PTR _iExtra$[ebp]
	mov	ecx, DWORD PTR _pkBuildingClassInfo$[ebp]
	call	?getMaxTeamInstances@CvBuildingClassInfo@@QBEHXZ ; CvBuildingClassInfo::getMaxTeamInstances
	xor	ecx, ecx
	cmp	esi, eax
	setge	cl
	mov	al, cl
$LN3@isBuilding:

; 4889 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?isBuildingClassMaxedOut@CvTeam@@QBE_NW4BuildingClassTypes@@H@Z ENDP ; CvTeam::isBuildingClassMaxedOut
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?changeBuildingClassCount@CvTeam@@QAEXW4BuildingClassTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?changeBuildingClassCount@CvTeam@@QAEXW4BuildingClassTypes@@H@Z PROC ; CvTeam::changeBuildingClassCount, COMDAT
; _this$ = ecx

; 4894 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4895 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4896 : 	CvAssertMsg(eIndex < GC.getNumBuildingClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4897 : 	m_paiBuildingClassCount[eIndex] = (m_paiBuildingClassCount[eIndex] + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2932]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	add	eax, DWORD PTR _iChange$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2932]
	mov	ecx, DWORD PTR _eIndex$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 4898 : 	CvAssert(getBuildingClassCount(eIndex) >= 0);
; 4899 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?changeBuildingClassCount@CvTeam@@QAEXW4BuildingClassTypes@@H@Z ENDP ; CvTeam::changeBuildingClassCount
_TEXT	ENDS
PUBLIC	?getObsoleteBuildingCount@CvTeam@@QBEHW4BuildingTypes@@@Z ; CvTeam::getObsoleteBuildingCount
; Function compile flags: /Odtp
;	COMDAT ?getObsoleteBuildingCount@CvTeam@@QBEHW4BuildingTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?getObsoleteBuildingCount@CvTeam@@QBEHW4BuildingTypes@@@Z PROC ; CvTeam::getObsoleteBuildingCount, COMDAT
; _this$ = ecx

; 4904 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4905 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4906 : 	CvAssertMsg(eIndex < GC.getNumBuildingInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4907 : 	return m_paiObsoleteBuildingCount[eIndex];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2936]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 4908 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getObsoleteBuildingCount@CvTeam@@QBEHW4BuildingTypes@@@Z ENDP ; CvTeam::getObsoleteBuildingCount
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isObsoleteBuilding@CvTeam@@QBE_NW4BuildingTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?isObsoleteBuilding@CvTeam@@QBE_NW4BuildingTypes@@@Z PROC ; CvTeam::isObsoleteBuilding, COMDAT
; _this$ = ecx

; 4913 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4914 : 	return (getObsoleteBuildingCount(eIndex) > 0);

	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getObsoleteBuildingCount@CvTeam@@QBEHW4BuildingTypes@@@Z ; CvTeam::getObsoleteBuildingCount
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	mov	al, cl

; 4915 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isObsoleteBuilding@CvTeam@@QBE_NW4BuildingTypes@@@Z ENDP ; CvTeam::isObsoleteBuilding
_TEXT	ENDS
PUBLIC	?changeObsoleteBuildingCount@CvTeam@@QAEXW4BuildingTypes@@H@Z ; CvTeam::changeObsoleteBuildingCount
EXTRN	?processBuilding@CvCity@@QAEXW4BuildingTypes@@H_N11@Z:PROC ; CvCity::processBuilding
; Function compile flags: /Odtp
;	COMDAT ?changeObsoleteBuildingCount@CvTeam@@QAEXW4BuildingTypes@@H@Z
_TEXT	SEGMENT
tv183 = -48						; size = 4
_this$ = -44						; size = 4
$T236446 = -40						; size = 4
$T236442 = -36						; size = 4
$T236438 = -32						; size = 4
$T236429 = -28						; size = 4
$T236425 = -21						; size = 1
$T236416 = -20						; size = 4
_iI$ = -16						; size = 4
_bOldObsoleteBuilding$ = -9				; size = 1
_pLoopCity$ = -8					; size = 4
_iLoop$ = -4						; size = 4
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?changeObsoleteBuildingCount@CvTeam@@QAEXW4BuildingTypes@@H@Z PROC ; CvTeam::changeObsoleteBuildingCount, COMDAT
; _this$ = ecx

; 4920 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 4921 : 	CvCity* pLoopCity;
; 4922 : 	bool bOldObsoleteBuilding;
; 4923 : 	int iLoop;
; 4924 : 	int iI;
; 4925 : 
; 4926 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4927 : 	CvAssertMsg(eIndex < GC.getNumBuildingInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4928 : 
; 4929 : 	if(iChange != 0)

	cmp	DWORD PTR _iChange$[ebp], 0
	je	$LN12@changeObso

; 4930 : 	{
; 4931 : 		bOldObsoleteBuilding = isObsoleteBuilding(eIndex);

	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isObsoleteBuilding@CvTeam@@QBE_NW4BuildingTypes@@@Z ; CvTeam::isObsoleteBuilding
	mov	BYTE PTR _bOldObsoleteBuilding$[ebp], al

; 4932 : 
; 4933 : 		m_paiObsoleteBuildingCount[eIndex] = (m_paiObsoleteBuildingCount[eIndex] + iChange);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2936]
	mov	eax, DWORD PTR _eIndex$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2936]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 4934 : 		CvAssert(getObsoleteBuildingCount(eIndex) >= 0);
; 4935 : 
; 4936 : 		if(bOldObsoleteBuilding != isObsoleteBuilding(eIndex))

	movzx	esi, BYTE PTR _bOldObsoleteBuilding$[ebp]
	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isObsoleteBuilding@CvTeam@@QBE_NW4BuildingTypes@@@Z ; CvTeam::isObsoleteBuilding
	movzx	ecx, al
	cmp	esi, ecx
	je	$LN12@changeObso

; 4937 : 		{
; 4938 : 			for(iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN9@changeObso
$LN8@changeObso:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN9@changeObso:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	$LN12@changeObso

; 4939 : 			{
; 4940 : 				if(GET_PLAYER((PlayerTypes)iI).isAlive())

	mov	eax, DWORD PTR _iI$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T236416[ebp], eax
	mov	ecx, DWORD PTR $T236416[ebp]
	mov	dl, BYTE PTR [ecx+2256]
	mov	BYTE PTR $T236425[ebp], dl
	movzx	eax, BYTE PTR $T236425[ebp]
	test	eax, eax
	je	$LN6@changeObso

; 4941 : 				{
; 4942 : 					if(GET_PLAYER((PlayerTypes)iI).getTeam() == GetID())

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T236429[ebp], ecx
	mov	edx, DWORD PTR $T236429[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T236438[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T236438[ebp], eax
	jne	$LN6@changeObso

; 4943 : 					{
; 4944 : 						for(pLoopCity = GET_PLAYER((PlayerTypes)iI).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER((PlayerTypes)iI).nextCity(&iLoop))

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T236442[ebp], ecx
	push	0
	lea	edx, DWORD PTR _iLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T236442[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
	jmp	SHORT $LN4@changeObso
$LN3@changeObso:
	mov	eax, DWORD PTR _iI$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T236446[ebp], eax
	push	0
	lea	ecx, DWORD PTR _iLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T236446[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
$LN4@changeObso:
	cmp	DWORD PTR _pLoopCity$[ebp], 0
	je	SHORT $LN6@changeObso

; 4945 : 						{
; 4946 : 							if(pLoopCity->GetCityBuildings()->GetNumBuilding(eIndex) > 0)

	mov	edx, DWORD PTR _eIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN1@changeObso

; 4947 : 							{
; 4948 : 								pLoopCity->processBuilding(eIndex, ((isObsoleteBuilding(eIndex)) ? -pLoopCity->GetCityBuildings()->GetNumBuilding(eIndex) : pLoopCity->GetCityBuildings()->GetNumBuilding(eIndex)), /*bFirst*/ false, /*bObsolete*/ true);

	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isObsoleteBuilding@CvTeam@@QBE_NW4BuildingTypes@@@Z ; CvTeam::isObsoleteBuilding
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN14@changeObso
	mov	edx, DWORD PTR _eIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	neg	eax
	mov	DWORD PTR tv183[ebp], eax
	jmp	SHORT $LN15@changeObso
$LN14@changeObso:
	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	mov	DWORD PTR tv183[ebp], eax
$LN15@changeObso:
	push	0
	push	1
	push	0
	mov	ecx, DWORD PTR tv183[ebp]
	push	ecx
	mov	edx, DWORD PTR _eIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?processBuilding@CvCity@@QAEXW4BuildingTypes@@H_N11@Z ; CvCity::processBuilding
$LN1@changeObso:

; 4949 : 							}
; 4950 : 						}

	jmp	$LN3@changeObso
$LN6@changeObso:

; 4951 : 					}
; 4952 : 				}
; 4953 : 			}

	jmp	$LN8@changeObso
$LN12@changeObso:

; 4954 : 		}
; 4955 : 	}
; 4956 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?changeObsoleteBuildingCount@CvTeam@@QAEXW4BuildingTypes@@H@Z ENDP ; CvTeam::changeObsoleteBuildingCount
_TEXT	ENDS
PUBLIC	?enhanceBuilding@CvTeam@@QAEXW4BuildingTypes@@H@Z ; CvTeam::enhanceBuilding
EXTRN	?ChangeBaseYieldRateFromBuildings@CvCity@@QAEXW4YieldTypes@@H@Z:PROC ; CvCity::ChangeBaseYieldRateFromBuildings
EXTRN	?ChangeFaithPerTurnFromBuildings@CvCity@@QAEXH@Z:PROC ; CvCity::ChangeFaithPerTurnFromBuildings
EXTRN	?ChangeJONSCulturePerTurnFromBuildings@CvCity@@QAEXH@Z:PROC ; CvCity::ChangeJONSCulturePerTurnFromBuildings
EXTRN	?GetTechEnhancedYieldChange@CvBuildingEntry@@QBEHH@Z:PROC ; CvBuildingEntry::GetTechEnhancedYieldChange
; Function compile flags: /Odtp
;	COMDAT ?enhanceBuilding@CvTeam@@QAEXW4BuildingTypes@@H@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T236469 = -32						; size = 4
$T236460 = -25						; size = 1
_k$225393 = -24						; size = 4
_kPlayer$225385 = -20					; size = 4
_i$225381 = -16						; size = 4
_thisBuildingEntry$ = -12				; size = 4
_pLoopCity$ = -8					; size = 4
_iLoop$ = -4						; size = 4
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?enhanceBuilding@CvTeam@@QAEXW4BuildingTypes@@H@Z PROC	; CvTeam::enhanceBuilding, COMDAT
; _this$ = ecx

; 4961 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 4962 : 	CvCity* pLoopCity;
; 4963 : 	int iLoop;
; 4964 : 
; 4965 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4966 : 	CvAssertMsg(eIndex < GC.getNumBuildingInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4967 : 
; 4968 : 	CvBuildingEntry* thisBuildingEntry = GC.getBuildingInfo(eIndex);

	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	DWORD PTR _thisBuildingEntry$[ebp], eax

; 4969 : 	if(thisBuildingEntry == NULL)

	cmp	DWORD PTR _thisBuildingEntry$[ebp], 0
	jne	SHORT $LN18@enhanceBui

; 4970 : 		return;

	jmp	$LN19@enhanceBui
$LN18@enhanceBui:

; 4971 : 
; 4972 : 	if(iChange != 0)

	cmp	DWORD PTR _iChange$[ebp], 0
	je	$LN19@enhanceBui

; 4973 : 	{
; 4974 : 		for(int i = 0; i < MAX_PLAYERS; i++)

	mov	DWORD PTR _i$225381[ebp], 0
	jmp	SHORT $LN16@enhanceBui
$LN15@enhanceBui:
	mov	ecx, DWORD PTR _i$225381[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$225381[ebp], ecx
$LN16@enhanceBui:
	cmp	DWORD PTR _i$225381[ebp], 64		; 00000040H
	jge	$LN19@enhanceBui

; 4975 : 		{
; 4976 : 			CvPlayerAI& kPlayer = GET_PLAYER(static_cast<PlayerTypes>(i));

	mov	edx, DWORD PTR _i$225381[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$225385[ebp], edx

; 4977 : 
; 4978 : 			if(kPlayer.isAlive())

	mov	eax, DWORD PTR _kPlayer$225385[ebp]
	mov	cl, BYTE PTR [eax+2256]
	mov	BYTE PTR $T236460[ebp], cl
	movzx	edx, BYTE PTR $T236460[ebp]
	test	edx, edx
	je	$LN13@enhanceBui

; 4979 : 			{
; 4980 : 				if(kPlayer.getTeam() == GetID())

	mov	eax, DWORD PTR _kPlayer$225385[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T236469[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T236469[ebp], eax
	jne	$LN13@enhanceBui

; 4981 : 				{
; 4982 : 					for(pLoopCity = kPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kPlayer.nextCity(&iLoop))

	push	0
	lea	edx, DWORD PTR _iLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR _kPlayer$225385[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
	jmp	SHORT $LN11@enhanceBui
$LN10@enhanceBui:
	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kPlayer$225385[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
$LN11@enhanceBui:
	cmp	DWORD PTR _pLoopCity$[ebp], 0
	je	$LN13@enhanceBui

; 4983 : 					{
; 4984 : 						if(pLoopCity->GetCityBuildings()->GetNumBuilding(eIndex) > 0)

	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN8@enhanceBui

; 4985 : 						{
; 4986 : 							for(int k = 0; k < NUM_YIELD_TYPES; k++)

	mov	DWORD PTR _k$225393[ebp], 0
	jmp	SHORT $LN7@enhanceBui
$LN6@enhanceBui:
	mov	edx, DWORD PTR _k$225393[ebp]
	add	edx, 1
	mov	DWORD PTR _k$225393[ebp], edx
$LN7@enhanceBui:
	cmp	DWORD PTR _k$225393[ebp], 6
	jge	SHORT $LN8@enhanceBui

; 4987 : 							{
; 4988 : 								if((YieldTypes)k == YIELD_CULTURE)

	cmp	DWORD PTR _k$225393[ebp], 4
	jne	SHORT $LN4@enhanceBui

; 4989 : 								{
; 4990 : 									pLoopCity->ChangeJONSCulturePerTurnFromBuildings(thisBuildingEntry->GetTechEnhancedYieldChange(k) * iChange);

	mov	eax, DWORD PTR _k$225393[ebp]
	push	eax
	mov	ecx, DWORD PTR _thisBuildingEntry$[ebp]
	call	?GetTechEnhancedYieldChange@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetTechEnhancedYieldChange
	imul	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?ChangeJONSCulturePerTurnFromBuildings@CvCity@@QAEXH@Z ; CvCity::ChangeJONSCulturePerTurnFromBuildings
	jmp	SHORT $LN3@enhanceBui
$LN4@enhanceBui:

; 4991 : 								}
; 4992 : 								else if((YieldTypes)k == YIELD_FAITH)

	cmp	DWORD PTR _k$225393[ebp], 5
	jne	SHORT $LN2@enhanceBui

; 4993 : 								{
; 4994 : 									pLoopCity->ChangeFaithPerTurnFromBuildings(thisBuildingEntry->GetTechEnhancedYieldChange(k) * iChange);

	mov	ecx, DWORD PTR _k$225393[ebp]
	push	ecx
	mov	ecx, DWORD PTR _thisBuildingEntry$[ebp]
	call	?GetTechEnhancedYieldChange@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetTechEnhancedYieldChange
	imul	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?ChangeFaithPerTurnFromBuildings@CvCity@@QAEXH@Z ; CvCity::ChangeFaithPerTurnFromBuildings

; 4995 : 								}
; 4996 : 								else

	jmp	SHORT $LN3@enhanceBui
$LN2@enhanceBui:

; 4997 : 								{
; 4998 : 									pLoopCity->ChangeBaseYieldRateFromBuildings(((YieldTypes)k), thisBuildingEntry->GetTechEnhancedYieldChange(k) * iChange);

	mov	edx, DWORD PTR _k$225393[ebp]
	push	edx
	mov	ecx, DWORD PTR _thisBuildingEntry$[ebp]
	call	?GetTechEnhancedYieldChange@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetTechEnhancedYieldChange
	imul	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	eax, DWORD PTR _k$225393[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?ChangeBaseYieldRateFromBuildings@CvCity@@QAEXW4YieldTypes@@H@Z ; CvCity::ChangeBaseYieldRateFromBuildings
$LN3@enhanceBui:

; 4999 : 								}
; 5000 : 							}

	jmp	SHORT $LN6@enhanceBui
$LN8@enhanceBui:

; 5001 : 						}
; 5002 : 					}

	jmp	$LN10@enhanceBui
$LN13@enhanceBui:

; 5003 : 				}
; 5004 : 			}
; 5005 : 		}

	jmp	$LN15@enhanceBui
$LN19@enhanceBui:

; 5006 : 	}
; 5007 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?enhanceBuilding@CvTeam@@QAEXW4BuildingTypes@@H@Z ENDP	; CvTeam::enhanceBuilding
_TEXT	ENDS
PUBLIC	?getTerrainTradeCount@CvTeam@@QBEHW4TerrainTypes@@@Z ; CvTeam::getTerrainTradeCount
; Function compile flags: /Odtp
;	COMDAT ?getTerrainTradeCount@CvTeam@@QBEHW4TerrainTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?getTerrainTradeCount@CvTeam@@QBEHW4TerrainTypes@@@Z PROC ; CvTeam::getTerrainTradeCount, COMDAT
; _this$ = ecx

; 5012 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5013 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 5014 : 	CvAssertMsg(eIndex < GC.getNumTerrainInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 5015 : 	return m_paiTerrainTradeCount[eIndex];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2940]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 5016 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getTerrainTradeCount@CvTeam@@QBEHW4TerrainTypes@@@Z ENDP ; CvTeam::getTerrainTradeCount
_TEXT	ENDS
PUBLIC	?isTerrainTrade@CvTeam@@QBE_NW4TerrainTypes@@@Z	; CvTeam::isTerrainTrade
; Function compile flags: /Odtp
;	COMDAT ?isTerrainTrade@CvTeam@@QBE_NW4TerrainTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?isTerrainTrade@CvTeam@@QBE_NW4TerrainTypes@@@Z PROC	; CvTeam::isTerrainTrade, COMDAT
; _this$ = ecx

; 5021 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5022 : 	return (getTerrainTradeCount(eIndex) > 0);

	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getTerrainTradeCount@CvTeam@@QBEHW4TerrainTypes@@@Z ; CvTeam::getTerrainTradeCount
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	mov	al, cl

; 5023 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isTerrainTrade@CvTeam@@QBE_NW4TerrainTypes@@@Z ENDP	; CvTeam::isTerrainTrade
_TEXT	ENDS
PUBLIC	?changeTerrainTradeCount@CvTeam@@QAEXW4TerrainTypes@@H@Z ; CvTeam::changeTerrainTradeCount
; Function compile flags: /Odtp
;	COMDAT ?changeTerrainTradeCount@CvTeam@@QAEXW4TerrainTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?changeTerrainTradeCount@CvTeam@@QAEXW4TerrainTypes@@H@Z PROC ; CvTeam::changeTerrainTradeCount, COMDAT
; _this$ = ecx

; 5028 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5029 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 5030 : 	CvAssertMsg(eIndex < GC.getNumTerrainInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 5031 : 
; 5032 : 	if(iChange != 0)

	cmp	DWORD PTR _iChange$[ebp], 0
	je	SHORT $LN2@changeTerr

; 5033 : 	{
; 5034 : 		m_paiTerrainTradeCount[eIndex] = (m_paiTerrainTradeCount[eIndex] + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2940]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	add	eax, DWORD PTR _iChange$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2940]
	mov	ecx, DWORD PTR _eIndex$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
$LN2@changeTerr:

; 5035 : 		CvAssert(getTerrainTradeCount(eIndex) >= 0);
; 5036 : 	}
; 5037 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?changeTerrainTradeCount@CvTeam@@QAEXW4TerrainTypes@@H@Z ENDP ; CvTeam::changeTerrainTradeCount
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsHomeOfUnitedNations@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsHomeOfUnitedNations@CvTeam@@QBE_NXZ PROC		; CvTeam::IsHomeOfUnitedNations, COMDAT
; _this$ = ecx

; 5042 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5043 : 	return m_bHomeOfUnitedNations;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+130]

; 5044 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsHomeOfUnitedNations@CvTeam@@QBE_NXZ ENDP		; CvTeam::IsHomeOfUnitedNations
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?SetHomeOfUnitedNations@CvTeam@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bValue$ = 8						; size = 1
?SetHomeOfUnitedNations@CvTeam@@QAEX_N@Z PROC		; CvTeam::SetHomeOfUnitedNations, COMDAT
; _this$ = ecx

; 5049 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 5050 : 	if(bValue != IsHomeOfUnitedNations())

	movzx	esi, BYTE PTR _bValue$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHomeOfUnitedNations@CvTeam@@QBE_NXZ	; CvTeam::IsHomeOfUnitedNations
	movzx	eax, al
	cmp	esi, eax
	je	SHORT $LN2@SetHomeOfU

; 5051 : 	{
; 5052 : 		m_bHomeOfUnitedNations = bValue;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR _bValue$[ebp]
	mov	BYTE PTR [ecx+130], dl
$LN2@SetHomeOfU:

; 5053 : 	}
; 5054 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?SetHomeOfUnitedNations@CvTeam@@QAEX_N@Z ENDP		; CvTeam::SetHomeOfUnitedNations
_TEXT	ENDS
PUBLIC	?getVictoryCountdown@CvTeam@@QBEHW4VictoryTypes@@@Z ; CvTeam::getVictoryCountdown
; Function compile flags: /Odtp
;	COMDAT ?getVictoryCountdown@CvTeam@@QBEHW4VictoryTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?getVictoryCountdown@CvTeam@@QBEHW4VictoryTypes@@@Z PROC ; CvTeam::getVictoryCountdown, COMDAT
; _this$ = ecx

; 5058 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5059 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 5060 : 	CvAssertMsg(eIndex < GC.getNumVictoryInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 5061 : 	return m_aiVictoryCountdown[eIndex];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2944]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 5062 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getVictoryCountdown@CvTeam@@QBEHW4VictoryTypes@@@Z ENDP ; CvTeam::getVictoryCountdown
_TEXT	ENDS
PUBLIC	?setVictoryCountdown@CvTeam@@QAEXW4VictoryTypes@@H@Z ; CvTeam::setVictoryCountdown
; Function compile flags: /Odtp
;	COMDAT ?setVictoryCountdown@CvTeam@@QAEXW4VictoryTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
_iTurnsLeft$ = 12					; size = 4
?setVictoryCountdown@CvTeam@@QAEXW4VictoryTypes@@H@Z PROC ; CvTeam::setVictoryCountdown, COMDAT
; _this$ = ecx

; 5066 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5067 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 5068 : 	CvAssertMsg(eIndex < GC.getNumVictoryInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 5069 : 	m_aiVictoryCountdown[eIndex] = iTurnsLeft;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2944]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR _iTurnsLeft$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 5070 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?setVictoryCountdown@CvTeam@@QAEXW4VictoryTypes@@H@Z ENDP ; CvTeam::setVictoryCountdown
_TEXT	ENDS
PUBLIC	?changeVictoryCountdown@CvTeam@@QAEXW4VictoryTypes@@H@Z ; CvTeam::changeVictoryCountdown
; Function compile flags: /Odtp
;	COMDAT ?changeVictoryCountdown@CvTeam@@QAEXW4VictoryTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?changeVictoryCountdown@CvTeam@@QAEXW4VictoryTypes@@H@Z PROC ; CvTeam::changeVictoryCountdown, COMDAT
; _this$ = ecx

; 5075 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5076 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 5077 : 	CvAssertMsg(eIndex < GC.getNumVictoryInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 5078 : 
; 5079 : 	if(iChange != 0)

	cmp	DWORD PTR _iChange$[ebp], 0
	je	SHORT $LN2@changeVict

; 5080 : 	{
; 5081 : 		m_aiVictoryCountdown[eIndex] += iChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2944]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	add	eax, DWORD PTR _iChange$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2944]
	mov	ecx, DWORD PTR _eIndex$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
$LN2@changeVict:

; 5082 : 		CvAssert(m_aiVictoryCountdown[eIndex] >= 0);
; 5083 : 	}
; 5084 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?changeVictoryCountdown@CvTeam@@QAEXW4VictoryTypes@@H@Z ENDP ; CvTeam::changeVictoryCountdown
_TEXT	ENDS
PUBLIC	?getVictoryDelay@CvTeam@@QBEHW4VictoryTypes@@@Z	; CvTeam::getVictoryDelay
EXTRN	?victoryDelay@CvGame@@QBEHW4VictoryTypes@@@Z:PROC ; CvGame::victoryDelay
EXTRN	?GetVictoryDelayPercent@CvProjectEntry@@QBEHXZ:PROC ; CvProjectEntry::GetVictoryDelayPercent
EXTRN	?GetVictoryMinThreshold@CvProjectEntry@@QBEHH@Z:PROC ; CvProjectEntry::GetVictoryMinThreshold
; Function compile flags: /Odtp
;	COMDAT ?getVictoryDelay@CvTeam@@QBEHW4VictoryTypes@@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T236491 = -20						; size = 4
_iCount$225452 = -16					; size = 4
_pkProject$225450 = -12					; size = 4
_iProject$225446 = -8					; size = 4
_iExtraDelayPercent$ = -4				; size = 4
_eVictory$ = 8						; size = 4
?getVictoryDelay@CvTeam@@QBEHW4VictoryTypes@@@Z PROC	; CvTeam::getVictoryDelay, COMDAT
; _this$ = ecx

; 5088 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 5089 : 	int iExtraDelayPercent = 0;

	mov	DWORD PTR _iExtraDelayPercent$[ebp], 0

; 5090 : #ifdef AUI_WARNING_FIXES
; 5091 : 	for (uint iProject = 0; iProject < GC.getNumProjectInfos(); ++iProject)
; 5092 : #else
; 5093 : 	for(int iProject = 0; iProject < GC.getNumProjectInfos(); ++iProject)

	mov	DWORD PTR _iProject$225446[ebp], 0
	jmp	SHORT $LN5@getVictory
$LN4@getVictory:
	mov	eax, DWORD PTR _iProject$225446[ebp]
	add	eax, 1
	mov	DWORD PTR _iProject$225446[ebp], eax
$LN5@getVictory:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumProjectInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumProjectInfos
	cmp	DWORD PTR _iProject$225446[ebp], eax
	jge	$LN3@getVictory

; 5094 : #endif
; 5095 : 	{
; 5096 : 		CvProjectEntry* pkProject = GC.getProjectInfo((ProjectTypes)iProject);

	mov	ecx, DWORD PTR _iProject$225446[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getProjectInfo@CvGlobals@@QAEPAVCvProjectEntry@@W4ProjectTypes@@@Z ; CvGlobals::getProjectInfo
	mov	DWORD PTR _pkProject$225450[ebp], eax

; 5097 : 		int iCount = getProjectCount((ProjectTypes)iProject);

	mov	edx, DWORD PTR _iProject$225446[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getProjectCount@CvTeam@@QBEHW4ProjectTypes@@@Z ; CvTeam::getProjectCount
	mov	DWORD PTR _iCount$225452[ebp], eax

; 5098 : 
; 5099 : 		if(iCount < pkProject->GetVictoryMinThreshold(eVictory))

	mov	eax, DWORD PTR _eVictory$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkProject$225450[ebp]
	call	?GetVictoryMinThreshold@CvProjectEntry@@QBEHH@Z ; CvProjectEntry::GetVictoryMinThreshold
	cmp	DWORD PTR _iCount$225452[ebp], eax
	jge	SHORT $LN2@getVictory

; 5100 : 		{
; 5101 : 			CvAssert(false);
; 5102 : 			return -1;

	or	eax, -1
	jmp	SHORT $LN6@getVictory
$LN2@getVictory:

; 5103 : 		}
; 5104 : 
; 5105 : 		if(iCount < pkProject->GetVictoryThreshold(eVictory))

	mov	ecx, DWORD PTR _eVictory$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkProject$225450[ebp]
	call	?GetVictoryThreshold@CvProjectEntry@@QBEHH@Z ; CvProjectEntry::GetVictoryThreshold
	cmp	DWORD PTR _iCount$225452[ebp], eax
	jge	SHORT $LN1@getVictory

; 5106 : 		{
; 5107 : 			iExtraDelayPercent += ((pkProject->GetVictoryThreshold(eVictory)  - iCount) * pkProject->GetVictoryDelayPercent()) / pkProject->GetVictoryThreshold(eVictory);

	mov	edx, DWORD PTR _eVictory$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkProject$225450[ebp]
	call	?GetVictoryThreshold@CvProjectEntry@@QBEHH@Z ; CvProjectEntry::GetVictoryThreshold
	mov	esi, eax
	sub	esi, DWORD PTR _iCount$225452[ebp]
	mov	ecx, DWORD PTR _pkProject$225450[ebp]
	call	?GetVictoryDelayPercent@CvProjectEntry@@QBEHXZ ; CvProjectEntry::GetVictoryDelayPercent
	imul	esi, eax
	mov	eax, DWORD PTR _eVictory$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkProject$225450[ebp]
	call	?GetVictoryThreshold@CvProjectEntry@@QBEHH@Z ; CvProjectEntry::GetVictoryThreshold
	mov	ecx, eax
	mov	eax, esi
	cdq
	idiv	ecx
	add	eax, DWORD PTR _iExtraDelayPercent$[ebp]
	mov	DWORD PTR _iExtraDelayPercent$[ebp], eax
$LN1@getVictory:

; 5108 : 		}
; 5109 : 	}

	jmp	$LN4@getVictory
$LN3@getVictory:

; 5110 : 
; 5111 : 	return (GC.getGame().victoryDelay(eVictory)  * (100 + iExtraDelayPercent)) / 100;

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T236491[ebp], edx
	mov	eax, DWORD PTR _eVictory$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T236491[ebp]
	call	?victoryDelay@CvGame@@QBEHW4VictoryTypes@@@Z ; CvGame::victoryDelay
	mov	ecx, DWORD PTR _iExtraDelayPercent$[ebp]
	add	ecx, 100				; 00000064H
	imul	eax, ecx
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
$LN6@getVictory:

; 5112 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?getVictoryDelay@CvTeam@@QBEHW4VictoryTypes@@@Z ENDP	; CvTeam::getVictoryDelay
_TEXT	ENDS
PUBLIC	?setCanLaunch@CvTeam@@QAEXW4VictoryTypes@@_N@Z	; CvTeam::setCanLaunch
; Function compile flags: /Odtp
;	COMDAT ?setCanLaunch@CvTeam@@QAEXW4VictoryTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eVictory$ = 8						; size = 4
_bCan$ = 12						; size = 1
?setCanLaunch@CvTeam@@QAEXW4VictoryTypes@@_N@Z PROC	; CvTeam::setCanLaunch, COMDAT
; _this$ = ecx

; 5116 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5117 : 	m_abCanLaunch[eVictory] = bCan;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2896]
	mov	edx, DWORD PTR _eVictory$[ebp]
	mov	al, BYTE PTR _bCan$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 5118 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?setCanLaunch@CvTeam@@QAEXW4VictoryTypes@@_N@Z ENDP	; CvTeam::setCanLaunch
_TEXT	ENDS
PUBLIC	?canLaunch@CvTeam@@QBE_NW4VictoryTypes@@@Z	; CvTeam::canLaunch
; Function compile flags: /Odtp
;	COMDAT ?canLaunch@CvTeam@@QBE_NW4VictoryTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eVictory$ = 8						; size = 4
?canLaunch@CvTeam@@QBE_NW4VictoryTypes@@@Z PROC		; CvTeam::canLaunch, COMDAT
; _this$ = ecx

; 5122 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5123 : 	return m_abCanLaunch[eVictory];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2896]
	mov	edx, DWORD PTR _eVictory$[ebp]
	mov	al, BYTE PTR [ecx+edx]

; 5124 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?canLaunch@CvTeam@@QBE_NW4VictoryTypes@@@Z ENDP		; CvTeam::canLaunch
_TEXT	ENDS
PUBLIC	??_C@_0O@KDDHEFFK@AS2D_MELTDOWN?$AA@		; `string'
PUBLIC	??_C@_0BG@DDHPLFEF@TXT_KEY_VICTORY_RESET?$AA@	; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?resetVictoryProgress@CvTeam@@QAEXXZ		; CvTeam::resetVictoryProgress
EXTRN	?getGameState@CvGame@@QAE?AW4GameStateTypes@@XZ:PROC ; CvGame::getGameState
EXTRN	?getVictoryInfo@CvGlobals@@QAEPAVCvVictoryInfo@@W4VictoryTypes@@@Z:PROC ; CvGlobals::getVictoryInfo
;	COMDAT ??_C@_0O@KDDHEFFK@AS2D_MELTDOWN?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0O@KDDHEFFK@AS2D_MELTDOWN?$AA@ DB 'AS2D_MELTDOWN', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DDHPLFEF@TXT_KEY_VICTORY_RESET?$AA@
CONST	SEGMENT
??_C@_0BG@DDHPLFEF@TXT_KEY_VICTORY_RESET?$AA@ DB 'TXT_KEY_VICTORY_RESET', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?resetVictoryProgress@CvTeam@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?resetVictoryProgress@CvTeam@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?resetVictoryProgress@CvTeam@@QAEXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?resetVictoryProgress@CvTeam@@QAEXXZ$1
__ehfuncinfo$?resetVictoryProgress@CvTeam@@QAEXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?resetVictoryProgress@CvTeam@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?resetVictoryProgress@CvTeam@@QAEXXZ
_TEXT	SEGMENT
tv173 = -152						; size = 4
tv153 = -148						; size = 4
_this$ = -144						; size = 4
$T236544 = -140						; size = 4
$T236540 = -136						; size = 4
$T236536 = -132						; size = 4
$T236532 = -128						; size = 4
$T236528 = -121						; size = 1
$T236519 = -120						; size = 4
$T236511 = -116						; size = 4
$T236507 = -112						; size = 4
$T236501 = -108						; size = 28
$T236500 = -80						; size = 4
$T236499 = -76						; size = 4
_iJ$225493 = -72					; size = 4
_eProject$225482 = -68					; size = 4
_pkProjectInfo$225484 = -64				; size = 4
_iK$225478 = -60					; size = 4
_strBuffer$225487 = -56					; size = 28
__$ArrayPad$ = -28					; size = 4
_pkVictoryInfo$225474 = -24				; size = 4
_eVictory$225472 = -20					; size = 4
_iI$225468 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?resetVictoryProgress@CvTeam@@QAEXXZ PROC		; CvTeam::resetVictoryProgress, COMDAT
; _this$ = ecx

; 5128 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?resetVictoryProgress@CvTeam@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 140				; 0000008cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 5129 : #ifdef AUI_WARNING_FIXES
; 5130 : 	for (uint iI = 0; iI < GC.getNumVictoryInfos(); ++iI)
; 5131 : #else
; 5132 : 	for(int iI = 0; iI < GC.getNumVictoryInfos(); ++iI)

	mov	DWORD PTR _iI$225468[ebp], 0
	jmp	SHORT $LN14@resetVicto
$LN13@resetVicto:
	mov	eax, DWORD PTR _iI$225468[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$225468[ebp], eax
$LN14@resetVicto:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumVictoryInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumVictoryInfos
	cmp	DWORD PTR _iI$225468[ebp], eax
	jge	$LN15@resetVicto

; 5133 : #endif
; 5134 : 	{
; 5135 : 		VictoryTypes eVictory = static_cast<VictoryTypes>(iI);

	mov	ecx, DWORD PTR _iI$225468[ebp]
	mov	DWORD PTR _eVictory$225472[ebp], ecx

; 5136 : 		CvVictoryInfo* pkVictoryInfo = GC.getVictoryInfo((VictoryTypes)iI);

	mov	edx, DWORD PTR _iI$225468[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getVictoryInfo@CvGlobals@@QAEPAVCvVictoryInfo@@W4VictoryTypes@@@Z ; CvGlobals::getVictoryInfo
	mov	DWORD PTR _pkVictoryInfo$225474[ebp], eax

; 5137 : 		if(pkVictoryInfo)

	cmp	DWORD PTR _pkVictoryInfo$225474[ebp], 0
	je	$LN11@resetVicto

; 5138 : 		{
; 5139 : 			if(getVictoryCountdown(eVictory) >= 0 && GC.getGame().getGameState() == GAMESTATE_ON)

	mov	eax, DWORD PTR _eVictory$225472[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getVictoryCountdown@CvTeam@@QBEHW4VictoryTypes@@@Z ; CvTeam::getVictoryCountdown
	test	eax, eax
	jl	$LN11@resetVicto
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T236507[ebp], ecx
	mov	ecx, DWORD PTR $T236507[ebp]
	call	?getGameState@CvGame@@QAE?AW4GameStateTypes@@XZ ; CvGame::getGameState
	test	eax, eax
	jne	$LN11@resetVicto

; 5140 : 			{
; 5141 : 				setVictoryCountdown(eVictory, -1);

	push	-1
	mov	edx, DWORD PTR _eVictory$225472[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setVictoryCountdown@CvTeam@@QAEXW4VictoryTypes@@H@Z ; CvTeam::setVictoryCountdown

; 5142 : 
; 5143 : #ifdef AUI_WARNING_FIXES
; 5144 : 				for (uint iK = 0; iK < GC.getNumProjectInfos(); iK++)
; 5145 : #else
; 5146 : 				for(int iK = 0; iK < GC.getNumProjectInfos(); iK++)

	mov	DWORD PTR _iK$225478[ebp], 0
	jmp	SHORT $LN9@resetVicto
$LN8@resetVicto:
	mov	eax, DWORD PTR _iK$225478[ebp]
	add	eax, 1
	mov	DWORD PTR _iK$225478[ebp], eax
$LN9@resetVicto:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumProjectInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumProjectInfos
	cmp	DWORD PTR _iK$225478[ebp], eax
	jge	SHORT $LN7@resetVicto

; 5147 : #endif
; 5148 : 				{
; 5149 : 					ProjectTypes eProject = static_cast<ProjectTypes>(iK);

	mov	ecx, DWORD PTR _iK$225478[ebp]
	mov	DWORD PTR _eProject$225482[ebp], ecx

; 5150 : 					CvProjectEntry* pkProjectInfo = GC.getProjectInfo(eProject);

	mov	edx, DWORD PTR _eProject$225482[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getProjectInfo@CvGlobals@@QAEPAVCvProjectEntry@@W4ProjectTypes@@@Z ; CvGlobals::getProjectInfo
	mov	DWORD PTR _pkProjectInfo$225484[ebp], eax

; 5151 : 					if(pkProjectInfo)

	cmp	DWORD PTR _pkProjectInfo$225484[ebp], 0
	je	SHORT $LN6@resetVicto

; 5152 : 					{
; 5153 : 						if(pkProjectInfo->GetVictoryMinThreshold(eVictory) > 0)

	mov	eax, DWORD PTR _eVictory$225472[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkProjectInfo$225484[ebp]
	call	?GetVictoryMinThreshold@CvProjectEntry@@QBEHH@Z ; CvProjectEntry::GetVictoryMinThreshold
	test	eax, eax
	jle	SHORT $LN6@resetVicto

; 5154 : 						{
; 5155 : 							changeProjectCount(eProject, -getProjectCount(eProject));

	mov	ecx, DWORD PTR _eProject$225482[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getProjectCount@CvTeam@@QBEHW4ProjectTypes@@@Z ; CvTeam::getProjectCount
	neg	eax
	push	eax
	mov	edx, DWORD PTR _eProject$225482[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z ; CvTeam::changeProjectCount
$LN6@resetVicto:

; 5156 : 						}
; 5157 : 					}
; 5158 : 				}

	jmp	SHORT $LN8@resetVicto
$LN7@resetVicto:

; 5159 : 
; 5160 : 				CvString strBuffer = GetLocalizedText("TXT_KEY_VICTORY_RESET", getName().GetCString(), pkVictoryInfo->GetTextKey());

	mov	ecx, DWORD PTR _pkVictoryInfo$225474[ebp]
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	mov	DWORD PTR $T236499[ebp], eax
	lea	eax, DWORD PTR $T236501[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	DWORD PTR tv153[ebp], eax
	mov	ecx, DWORD PTR tv153[ebp]
	mov	DWORD PTR $T236511[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR $T236511[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T236500[ebp], eax
	lea	edx, DWORD PTR $T236499[ebp]
	push	edx
	lea	eax, DWORD PTR $T236500[ebp]
	push	eax
	push	OFFSET ??_C@_0BG@DDHPLFEF@TXT_KEY_VICTORY_RESET?$AA@
	lea	ecx, DWORD PTR _strBuffer$225487[ebp]
	push	ecx
	call	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
	add	esp, 16					; 00000010H
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T236501[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5161 : 
; 5162 : 				for(int iJ = 0; iJ < MAX_PLAYERS; ++iJ)

	mov	DWORD PTR _iJ$225493[ebp], 0
	jmp	SHORT $LN4@resetVicto
$LN3@resetVicto:
	mov	edx, DWORD PTR _iJ$225493[ebp]
	add	edx, 1
	mov	DWORD PTR _iJ$225493[ebp], edx
$LN4@resetVicto:
	cmp	DWORD PTR _iJ$225493[ebp], 64		; 00000040H
	jge	$LN2@resetVicto

; 5163 : 				{
; 5164 : 					if(GET_PLAYER((PlayerTypes)iJ).isAlive())

	mov	eax, DWORD PTR _iJ$225493[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T236519[ebp], eax
	mov	ecx, DWORD PTR $T236519[ebp]
	mov	dl, BYTE PTR [ecx+2256]
	mov	BYTE PTR $T236528[ebp], dl
	movzx	eax, BYTE PTR $T236528[ebp]
	test	eax, eax
	je	SHORT $LN1@resetVicto

; 5165 : 					{
; 5166 : 						DLLUI->AddMessage(0, ((PlayerTypes)iJ), false, GC.getEVENT_MESSAGE_TIME(), strBuffer, "AS2D_MELTDOWN", MESSAGE_TYPE_MAJOR_EVENT);

	mov	ecx, DWORD PTR $T236532[ebp]
	mov	DWORD PTR tv173[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv173[ebp], edx
	lea	ecx, DWORD PTR _strBuffer$225487[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T236536[ebp], eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	mov	DWORD PTR $T236540[ebp], eax
	push	0
	push	0
	push	-1
	push	-1
	push	-1
	push	0
	push	2
	push	OFFSET ??_C@_0O@KDDHEFFK@AS2D_MELTDOWN?$AA@
	mov	ecx, DWORD PTR $T236536[ebp]
	push	ecx
	mov	edx, DWORD PTR $T236540[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _iJ$225493[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR tv173[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv173[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN1@resetVicto:

; 5167 : 					}
; 5168 : 				}

	jmp	$LN3@resetVicto
$LN2@resetVicto:

; 5169 : 
; 5170 : 				GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, getLeaderID(), strBuffer, -1, -1);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T236544[ebp], ecx
	push	-1
	push	-1
	lea	edx, DWORD PTR _strBuffer$225487[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	push	eax
	push	0
	mov	ecx, DWORD PTR $T236544[ebp]
	call	?addReplayMessage@CvGame@@QAEXW4ReplayMessageTypes@@W4PlayerTypes@@ABVCvString@@HH@Z ; CvGame::addReplayMessage

; 5171 : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strBuffer$225487[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN11@resetVicto:

; 5172 : 		}

	jmp	$LN13@resetVicto
$LN15@resetVicto:

; 5173 : 	}
; 5174 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?resetVictoryProgress@CvTeam@@QAEXXZ$0:
	lea	ecx, DWORD PTR $T236501[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?resetVictoryProgress@CvTeam@@QAEXXZ$1:
	lea	ecx, DWORD PTR _strBuffer$225487[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?resetVictoryProgress@CvTeam@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-144]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?resetVictoryProgress@CvTeam@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?resetVictoryProgress@CvTeam@@QAEXXZ ENDP		; CvTeam::resetVictoryProgress
PUBLIC	?isVictoryAchieved@CvTeam@@QBE_NW4VictoryTypes@@@Z ; CvTeam::isVictoryAchieved
; Function compile flags: /Odtp
;	COMDAT ?isVictoryAchieved@CvTeam@@QBE_NW4VictoryTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eVictory$ = 8						; size = 4
?isVictoryAchieved@CvTeam@@QBE_NW4VictoryTypes@@@Z PROC	; CvTeam::isVictoryAchieved, COMDAT
; _this$ = ecx

; 5179 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5180 : 	return m_abVictoryAchieved[eVictory];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2900]
	mov	edx, DWORD PTR _eVictory$[ebp]
	mov	al, BYTE PTR [ecx+edx]

; 5181 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isVictoryAchieved@CvTeam@@QBE_NW4VictoryTypes@@@Z ENDP	; CvTeam::isVictoryAchieved
_TEXT	ENDS
PUBLIC	?setVictoryAchieved@CvTeam@@QAEXW4VictoryTypes@@_N@Z ; CvTeam::setVictoryAchieved
; Function compile flags: /Odtp
;	COMDAT ?setVictoryAchieved@CvTeam@@QAEXW4VictoryTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eVictory$ = 8						; size = 4
_bValue$ = 12						; size = 1
?setVictoryAchieved@CvTeam@@QAEXW4VictoryTypes@@_N@Z PROC ; CvTeam::setVictoryAchieved, COMDAT
; _this$ = ecx

; 5185 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5186 : 	if(m_abVictoryAchieved[eVictory] != bValue)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2900]
	mov	edx, DWORD PTR _eVictory$[ebp]
	movzx	eax, BYTE PTR [ecx+edx]
	movzx	ecx, BYTE PTR _bValue$[ebp]
	cmp	eax, ecx
	je	SHORT $LN2@setVictory

; 5187 : 	{
; 5188 : 		m_abVictoryAchieved[eVictory] = bValue;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2900]
	mov	ecx, DWORD PTR _eVictory$[ebp]
	mov	dl, BYTE PTR _bValue$[ebp]
	mov	BYTE PTR [eax+ecx], dl
$LN2@setVictory:

; 5189 : 	}
; 5190 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?setVictoryAchieved@CvTeam@@QAEXW4VictoryTypes@@_N@Z ENDP ; CvTeam::setVictoryAchieved
_TEXT	ENDS
PUBLIC	?getVictoryPoints@CvTeam@@QBEHXZ		; CvTeam::getVictoryPoints
; Function compile flags: /Odtp
;	COMDAT ?getVictoryPoints@CvTeam@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getVictoryPoints@CvTeam@@QBEHXZ PROC			; CvTeam::getVictoryPoints, COMDAT
; _this$ = ecx

; 5194 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5195 : 	return m_iVictoryPoints;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+92]

; 5196 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getVictoryPoints@CvTeam@@QBEHXZ ENDP			; CvTeam::getVictoryPoints
_TEXT	ENDS
PUBLIC	?GetScore@CvTeam@@QBEHXZ			; CvTeam::GetScore
EXTRN	?GetScore@CvPlayer@@QBEH_N0@Z:PROC		; CvPlayer::GetScore
; Function compile flags: /Odtp
;	COMDAT ?GetScore@CvTeam@@QBEHXZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T236579 = -24						; size = 4
$T236575 = -20						; size = 4
$T236566 = -16						; size = 4
_iPlayerLoop$225519 = -12				; size = 4
_ePlayer$ = -8						; size = 4
_iScore$ = -4						; size = 4
?GetScore@CvTeam@@QBEHXZ PROC				; CvTeam::GetScore, COMDAT
; _this$ = ecx

; 5200 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 5201 : 	int iScore = 0;

	mov	DWORD PTR _iScore$[ebp], 0

; 5202 : 
; 5203 : 	// Sum up score for all players
; 5204 : 	PlayerTypes ePlayer;
; 5205 : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	mov	DWORD PTR _iPlayerLoop$225519[ebp], 0
	jmp	SHORT $LN4@GetScore
$LN3@GetScore:
	mov	eax, DWORD PTR _iPlayerLoop$225519[ebp]
	add	eax, 1
	mov	DWORD PTR _iPlayerLoop$225519[ebp], eax
$LN4@GetScore:
	cmp	DWORD PTR _iPlayerLoop$225519[ebp], 22	; 00000016H
	jge	SHORT $LN2@GetScore

; 5206 : 	{
; 5207 : 		ePlayer = (PlayerTypes) iPlayerLoop;

	mov	ecx, DWORD PTR _iPlayerLoop$225519[ebp]
	mov	DWORD PTR _ePlayer$[ebp], ecx

; 5208 : 
; 5209 : 		if(GET_PLAYER(ePlayer).getTeam() == GetID())

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T236566[ebp], edx
	mov	eax, DWORD PTR $T236566[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T236575[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T236575[ebp], eax
	jne	SHORT $LN1@GetScore

; 5210 : 		{
; 5211 : 			iScore += GET_PLAYER(ePlayer).GetScore();

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T236579[ebp], edx
	push	0
	push	0
	mov	ecx, DWORD PTR $T236579[ebp]
	call	?GetScore@CvPlayer@@QBEH_N0@Z		; CvPlayer::GetScore
	add	eax, DWORD PTR _iScore$[ebp]
	mov	DWORD PTR _iScore$[ebp], eax
$LN1@GetScore:

; 5212 : 		}
; 5213 : 	}

	jmp	SHORT $LN3@GetScore
$LN2@GetScore:

; 5214 : 
; 5215 : 	return iScore;

	mov	eax, DWORD PTR _iScore$[ebp]

; 5216 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetScore@CvTeam@@QBEHXZ ENDP				; CvTeam::GetScore
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?changeVictoryPoints@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?changeVictoryPoints@CvTeam@@QAEXH@Z PROC		; CvTeam::changeVictoryPoints, COMDAT
; _this$ = ecx

; 5220 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5221 : 	if(iChange != 0)

	cmp	DWORD PTR _iChange$[ebp], 0
	je	SHORT $LN2@changeVict@2

; 5222 : 	{
; 5223 : 		m_iVictoryPoints += iChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+92], ecx
$LN2@changeVict@2:

; 5224 : 	}
; 5225 : 
; 5226 : 	// Right now there's no reason VPs should ever be negative
; 5227 : 	CvAssert(m_iVictoryPoints >= 0);
; 5228 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?changeVictoryPoints@CvTeam@@QAEXH@Z ENDP		; CvTeam::changeVictoryPoints
_TEXT	ENDS
PUBLIC	?GetLocalizedText@@YA?AVCvString@@PBD@Z		; GetLocalizedText
PUBLIC	??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z ; GetLocalizedText<int,int>
PUBLIC	?SetSmallAwardAchieved@CvTeam@@QAEXW4SmallAwardTypes@@_N@Z ; CvTeam::SetSmallAwardAchieved
PUBLIC	?IsSmallAwardAchieved@CvTeam@@QBE_NW4SmallAwardTypes@@@Z ; CvTeam::IsSmallAwardAchieved
PUBLIC	__$ArrayPad$
EXTRN	?GetTeamNotificationString@CvSmallAwardInfo@@QBE?AVCvString@@XZ:PROC ; CvSmallAwardInfo::GetTeamNotificationString
EXTRN	?GetNotificationString@CvSmallAwardInfo@@QBE?AVCvString@@XZ:PROC ; CvSmallAwardInfo::GetNotificationString
EXTRN	?getPopulation@CvCity@@QBEHXZ:PROC		; CvCity::getPopulation
EXTRN	?GetCityPopulation@CvSmallAwardInfo@@QBEHXZ:PROC ; CvSmallAwardInfo::GetCityPopulation
EXTRN	?GetNumVictoryPoints@CvSmallAwardInfo@@QBEHXZ:PROC ; CvSmallAwardInfo::GetNumVictoryPoints
EXTRN	?getNumCities@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getNumCities
EXTRN	?GetNumCities@CvSmallAwardInfo@@QBEHXZ:PROC	; CvSmallAwardInfo::GetNumCities
EXTRN	?getSmallAwardInfo@CvGlobals@@QAEPAVCvSmallAwardInfo@@W4SmallAwardTypes@@@Z:PROC ; CvGlobals::getSmallAwardInfo
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?DoTestSmallAwards@CvTeam@@QAEXXZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?DoTestSmallAwards@CvTeam@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?DoTestSmallAwards@CvTeam@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoTestSmallAwards@CvTeam@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoTestSmallAwards@CvTeam@@QAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?DoTestSmallAwards@CvTeam@@QAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?DoTestSmallAwards@CvTeam@@QAEXXZ$3
	DD	01H
	DD	FLAT:__unwindfunclet$?DoTestSmallAwards@CvTeam@@QAEXXZ$4
	DD	01H
	DD	FLAT:__unwindfunclet$?DoTestSmallAwards@CvTeam@@QAEXXZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$?DoTestSmallAwards@CvTeam@@QAEXXZ$6
	DD	01H
	DD	FLAT:__unwindfunclet$?DoTestSmallAwards@CvTeam@@QAEXXZ$7
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?DoTestSmallAwards@CvTeam@@QAEXXZ
_TEXT	SEGMENT
tv546 = -432						; size = 4
tv545 = -428						; size = 4
tv544 = -424						; size = 4
tv239 = -420						; size = 4
tv416 = -416						; size = 4
tv427 = -412						; size = 4
_this$ = -408						; size = 4
$T236774 = -404						; size = 4
$T236766 = -400						; size = 4
$T236762 = -396						; size = 4
$T236750 = -392						; size = 4
$T236746 = -388						; size = 4
$T236745 = -384						; size = 4
$T236737 = -380						; size = 4
$T236733 = -376						; size = 4
$T236721 = -372						; size = 4
$T236717 = -368						; size = 4
$T236716 = -364						; size = 4
$T236712 = -360						; size = 4
$T236708 = -356						; size = 4
$T236699 = -352						; size = 4
$T236671 = -348						; size = 4
$T236667 = -344						; size = 4
$T236663 = -340						; size = 4
$T236654 = -336						; size = 4
$T236650 = -332						; size = 4
$T236641 = -328						; size = 4
$T236637 = -324						; size = 4
$T236628 = -320						; size = 4
$T236624 = -316						; size = 4
$T236620 = -312						; size = 4
$T236616 = -308						; size = 4
$T236607 = -304						; size = 4
$T236592 = -300						; size = 28
$T236591 = -272						; size = 28
$T236590 = -244						; size = 28
$T236589 = -216						; size = 4
$T236588 = -212						; size = 28
$T236587 = -184						; size = 28
$T236586 = -156						; size = 28
$T236585 = -128						; size = 4
_pNotifications$225579 = -124				; size = 4
_strBuffer$225572 = -120				; size = 28
_strSummary$225573 = -92				; size = 28
__$ArrayPad$ = -64					; size = 4
_eAward$225548 = -60					; size = 4
_pkSmallAwardInfo$225550 = -56				; size = 4
_iSmallAwardLoop$225544 = -52				; size = 4
_iNotificationData$ = -48				; size = 4
_ePlayer$ = -44						; size = 4
_iNotificationX$ = -40					; size = 4
_iPlayerLoop$ = -36					; size = 4
_iCityLoop$ = -32					; size = 4
_bShouldShowNotification$ = -25				; size = 1
_iAwardRequirement$ = -24				; size = 4
_iNotificationY$ = -20					; size = 4
_pLoopCity$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?DoTestSmallAwards@CvTeam@@QAEXXZ PROC			; CvTeam::DoTestSmallAwards, COMDAT
; _this$ = ecx

; 5233 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DoTestSmallAwards@CvTeam@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 420				; 000001a4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 5234 : 	if(!isAlive() || isMinorCiv())

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+12], 0
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN30@DoTestSmal
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN31@DoTestSmal
$LN30@DoTestSmal:

; 5235 : 	{
; 5236 : 		return;

	jmp	$LN32@DoTestSmal
$LN31@DoTestSmal:

; 5237 : 	}
; 5238 : 
; 5239 : 	int iPlayerLoop;
; 5240 : 	PlayerTypes ePlayer;
; 5241 : 
; 5242 : 	CvCity* pLoopCity;
; 5243 : 	int iCityLoop;
; 5244 : 
; 5245 : 	int iAwardRequirement;
; 5246 : 
; 5247 : 	bool bShouldShowNotification;
; 5248 : 	int iNotificationData;
; 5249 : 	int iNotificationX, iNotificationY;
; 5250 : 
; 5251 : #ifdef AUI_WARNING_FIXES
; 5252 : 	for (uint iSmallAwardLoop = 0; iSmallAwardLoop < GC.getNumSmallAwardInfos(); iSmallAwardLoop++)
; 5253 : #else
; 5254 : 	for(int iSmallAwardLoop = 0; iSmallAwardLoop < GC.getNumSmallAwardInfos(); iSmallAwardLoop++)

	mov	DWORD PTR _iSmallAwardLoop$225544[ebp], 0
	jmp	SHORT $LN29@DoTestSmal
$LN28@DoTestSmal:
	mov	ecx, DWORD PTR _iSmallAwardLoop$225544[ebp]
	add	ecx, 1
	mov	DWORD PTR _iSmallAwardLoop$225544[ebp], ecx
$LN29@DoTestSmal:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumSmallAwardInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumSmallAwardInfos
	cmp	DWORD PTR _iSmallAwardLoop$225544[ebp], eax
	jge	$LN32@DoTestSmal

; 5255 : #endif
; 5256 : 	{
; 5257 : 		SmallAwardTypes eAward = static_cast<SmallAwardTypes>(iSmallAwardLoop);

	mov	edx, DWORD PTR _iSmallAwardLoop$225544[ebp]
	mov	DWORD PTR _eAward$225548[ebp], edx

; 5258 : 		CvSmallAwardInfo* pkSmallAwardInfo = GC.getSmallAwardInfo(eAward);

	mov	eax, DWORD PTR _eAward$225548[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getSmallAwardInfo@CvGlobals@@QAEPAVCvSmallAwardInfo@@W4SmallAwardTypes@@@Z ; CvGlobals::getSmallAwardInfo
	mov	DWORD PTR _pkSmallAwardInfo$225550[ebp], eax

; 5259 : 		if(pkSmallAwardInfo)

	cmp	DWORD PTR _pkSmallAwardInfo$225550[ebp], 0
	je	$LN26@DoTestSmal

; 5260 : 		{
; 5261 : 			bShouldShowNotification = false;

	mov	BYTE PTR _bShouldShowNotification$[ebp], 0

; 5262 : 			iNotificationX = -1;

	mov	DWORD PTR _iNotificationX$[ebp], -1

; 5263 : 			iNotificationY = -1;

	mov	DWORD PTR _iNotificationY$[ebp], -1

; 5264 : 
; 5265 : 			if(!IsSmallAwardAchieved(eAward))

	mov	ecx, DWORD PTR _eAward$225548[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSmallAwardAchieved@CvTeam@@QBE_NW4SmallAwardTypes@@@Z ; CvTeam::IsSmallAwardAchieved
	movzx	edx, al
	test	edx, edx
	jne	$LN26@DoTestSmal

; 5266 : 			{
; 5267 : 				// Cities
; 5268 : #ifdef AUI_WARNING_FIXES
; 5269 : 				iAwardRequirement = pkSmallAwardInfo->GetNumCities();
; 5270 : #else
; 5271 : 				iAwardRequirement = GC.getSmallAwardInfo(eAward)->GetNumCities();

	mov	eax, DWORD PTR _eAward$225548[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getSmallAwardInfo@CvGlobals@@QAEPAVCvSmallAwardInfo@@W4SmallAwardTypes@@@Z ; CvGlobals::getSmallAwardInfo
	mov	ecx, eax
	call	?GetNumCities@CvSmallAwardInfo@@QBEHXZ	; CvSmallAwardInfo::GetNumCities
	mov	DWORD PTR _iAwardRequirement$[ebp], eax

; 5272 : #endif
; 5273 : 				if(iAwardRequirement > 0)

	cmp	DWORD PTR _iAwardRequirement$[ebp], 0
	jle	$LN24@DoTestSmal

; 5274 : 				{
; 5275 : 					for(iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	mov	DWORD PTR _iPlayerLoop$[ebp], 0
	jmp	SHORT $LN23@DoTestSmal
$LN22@DoTestSmal:
	mov	ecx, DWORD PTR _iPlayerLoop$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iPlayerLoop$[ebp], ecx
$LN23@DoTestSmal:
	cmp	DWORD PTR _iPlayerLoop$[ebp], 22	; 00000016H
	jge	$LN24@DoTestSmal

; 5276 : 					{
; 5277 : 						ePlayer = (PlayerTypes) iPlayerLoop;

	mov	edx, DWORD PTR _iPlayerLoop$[ebp]
	mov	DWORD PTR _ePlayer$[ebp], edx

; 5278 : 
; 5279 : 						if(GET_PLAYER(ePlayer).getTeam() == GetID())

	mov	eax, DWORD PTR _ePlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T236607[ebp], eax
	mov	ecx, DWORD PTR $T236607[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T236616[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T236616[ebp], eax
	jne	$LN20@DoTestSmal

; 5280 : 						{
; 5281 : 							if(GET_PLAYER(ePlayer).getNumCities() >= iAwardRequirement)

	mov	eax, DWORD PTR _ePlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T236620[ebp], eax
	mov	ecx, DWORD PTR $T236620[ebp]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	cmp	eax, DWORD PTR _iAwardRequirement$[ebp]
	jl	$LN20@DoTestSmal

; 5282 : 							{
; 5283 : 								SetSmallAwardAchieved(eAward, true);

	push	1
	mov	ecx, DWORD PTR _eAward$225548[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSmallAwardAchieved@CvTeam@@QAEXW4SmallAwardTypes@@_N@Z ; CvTeam::SetSmallAwardAchieved

; 5284 : #ifdef AUI_WARNING_FIXES
; 5285 : 								changeVictoryPoints(pkSmallAwardInfo->GetNumVictoryPoints());
; 5286 : #else
; 5287 : 								changeVictoryPoints(GC.getSmallAwardInfo(eAward)->GetNumVictoryPoints());

	mov	edx, DWORD PTR _eAward$225548[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getSmallAwardInfo@CvGlobals@@QAEPAVCvSmallAwardInfo@@W4SmallAwardTypes@@@Z ; CvGlobals::getSmallAwardInfo
	mov	ecx, eax
	call	?GetNumVictoryPoints@CvSmallAwardInfo@@QBEHXZ ; CvSmallAwardInfo::GetNumVictoryPoints
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeVictoryPoints@CvTeam@@QAEXH@Z	; CvTeam::changeVictoryPoints

; 5288 : #endif
; 5289 : 
; 5290 : 								bShouldShowNotification = true;

	mov	BYTE PTR _bShouldShowNotification$[ebp], 1

; 5291 : 								iNotificationData = iAwardRequirement;

	mov	eax, DWORD PTR _iAwardRequirement$[ebp]
	mov	DWORD PTR _iNotificationData$[ebp], eax

; 5292 : 
; 5293 : 								if(GET_PLAYER(ePlayer).getCapitalCity() != NULL)

	mov	ecx, DWORD PTR _ePlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T236624[ebp], ecx
	mov	ecx, DWORD PTR $T236624[ebp]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	test	eax, eax
	je	SHORT $LN20@DoTestSmal

; 5294 : 								{
; 5295 : 									iNotificationX = GET_PLAYER(ePlayer).getCapitalCity()->getX();

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T236628[ebp], edx
	mov	ecx, DWORD PTR $T236628[ebp]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	DWORD PTR $T236637[ebp], eax
	mov	eax, DWORD PTR $T236637[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR _iNotificationX$[ebp], ecx

; 5296 : 									iNotificationY = GET_PLAYER(ePlayer).getCapitalCity()->getY();

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T236641[ebp], edx
	mov	ecx, DWORD PTR $T236641[ebp]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	DWORD PTR $T236650[ebp], eax
	mov	eax, DWORD PTR $T236650[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR _iNotificationY$[ebp], ecx
$LN20@DoTestSmal:

; 5297 : 								}
; 5298 : 							}
; 5299 : 						}
; 5300 : 					}

	jmp	$LN22@DoTestSmal
$LN24@DoTestSmal:

; 5301 : 				}
; 5302 : 
; 5303 : 				// Population
; 5304 : 				iAwardRequirement = pkSmallAwardInfo->GetCityPopulation();

	mov	ecx, DWORD PTR _pkSmallAwardInfo$225550[ebp]
	call	?GetCityPopulation@CvSmallAwardInfo@@QBEHXZ ; CvSmallAwardInfo::GetCityPopulation
	mov	DWORD PTR _iAwardRequirement$[ebp], eax

; 5305 : 				if(iAwardRequirement > 0)

	cmp	DWORD PTR _iAwardRequirement$[ebp], 0
	jle	$LN17@DoTestSmal

; 5306 : 				{
; 5307 : 					for(iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	mov	DWORD PTR _iPlayerLoop$[ebp], 0
	jmp	SHORT $LN16@DoTestSmal
$LN15@DoTestSmal:
	mov	edx, DWORD PTR _iPlayerLoop$[ebp]
	add	edx, 1
	mov	DWORD PTR _iPlayerLoop$[ebp], edx
$LN16@DoTestSmal:
	cmp	DWORD PTR _iPlayerLoop$[ebp], 22	; 00000016H
	jge	$LN17@DoTestSmal

; 5308 : 					{
; 5309 : 						ePlayer = (PlayerTypes) iPlayerLoop;

	mov	eax, DWORD PTR _iPlayerLoop$[ebp]
	mov	DWORD PTR _ePlayer$[ebp], eax

; 5310 : 
; 5311 : 						if(GET_PLAYER(ePlayer).getTeam() == GetID())

	mov	ecx, DWORD PTR _ePlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T236654[ebp], ecx
	mov	edx, DWORD PTR $T236654[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T236663[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T236663[ebp], eax
	jne	$LN13@DoTestSmal

; 5312 : 						{
; 5313 : 							// Check all Cities
; 5314 : 							for(pLoopCity = GET_PLAYER(ePlayer).firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iCityLoop))

	mov	ecx, DWORD PTR _ePlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T236667[ebp], ecx
	push	0
	lea	edx, DWORD PTR _iCityLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T236667[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
	jmp	SHORT $LN12@DoTestSmal
$LN11@DoTestSmal:
	mov	eax, DWORD PTR _ePlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T236671[ebp], eax
	push	0
	lea	ecx, DWORD PTR _iCityLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T236671[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
$LN12@DoTestSmal:
	cmp	DWORD PTR _pLoopCity$[ebp], 0
	je	SHORT $LN13@DoTestSmal

; 5315 : 							{
; 5316 : 								if(pLoopCity->getPopulation() >= iAwardRequirement)

	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cmp	eax, DWORD PTR _iAwardRequirement$[ebp]
	jl	SHORT $LN9@DoTestSmal

; 5317 : 								{
; 5318 : 									SetSmallAwardAchieved(eAward, true);

	push	1
	mov	edx, DWORD PTR _eAward$225548[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSmallAwardAchieved@CvTeam@@QAEXW4SmallAwardTypes@@_N@Z ; CvTeam::SetSmallAwardAchieved

; 5319 : 									changeVictoryPoints(pkSmallAwardInfo->GetNumVictoryPoints());

	mov	ecx, DWORD PTR _pkSmallAwardInfo$225550[ebp]
	call	?GetNumVictoryPoints@CvSmallAwardInfo@@QBEHXZ ; CvSmallAwardInfo::GetNumVictoryPoints
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeVictoryPoints@CvTeam@@QAEXH@Z	; CvTeam::changeVictoryPoints

; 5320 : 
; 5321 : 									bShouldShowNotification = true;

	mov	BYTE PTR _bShouldShowNotification$[ebp], 1

; 5322 : 									iNotificationData = iAwardRequirement;

	mov	eax, DWORD PTR _iAwardRequirement$[ebp]
	mov	DWORD PTR _iNotificationData$[ebp], eax

; 5323 : 									iNotificationX = pLoopCity->getX();

	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR _iNotificationX$[ebp], edx

; 5324 : 									iNotificationY = pLoopCity->getY();

	mov	eax, DWORD PTR _pLoopCity$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR _iNotificationY$[ebp], ecx
$LN9@DoTestSmal:

; 5325 : 								}
; 5326 : 							}

	jmp	SHORT $LN11@DoTestSmal
$LN13@DoTestSmal:

; 5327 : 						}
; 5328 : 					}

	jmp	$LN15@DoTestSmal
$LN17@DoTestSmal:

; 5329 : 				}
; 5330 : 
; 5331 : 				// Give notification to all players on this team
; 5332 : 				if(bShouldShowNotification)

	movzx	edx, BYTE PTR _bShouldShowNotification$[ebp]
	test	edx, edx
	je	$LN26@DoTestSmal

; 5333 : 				{
; 5334 : 					CvString strBuffer;

	lea	ecx, DWORD PTR _strBuffer$225572[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5335 : 					CvString strSummary;

	lea	ecx, DWORD PTR _strSummary$225573[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 5336 : 					for(iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	mov	DWORD PTR _iPlayerLoop$[ebp], 0
	jmp	SHORT $LN7@DoTestSmal
$LN6@DoTestSmal:
	mov	eax, DWORD PTR _iPlayerLoop$[ebp]
	add	eax, 1
	mov	DWORD PTR _iPlayerLoop$[ebp], eax
$LN7@DoTestSmal:
	cmp	DWORD PTR _iPlayerLoop$[ebp], 22	; 00000016H
	jge	$LN5@DoTestSmal

; 5337 : 					{
; 5338 : 						ePlayer = (PlayerTypes) iPlayerLoop;

	mov	ecx, DWORD PTR _iPlayerLoop$[ebp]
	mov	DWORD PTR _ePlayer$[ebp], ecx

; 5339 : 
; 5340 : 						if(GET_PLAYER(ePlayer).getTeam() == GetID())

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T236699[ebp], edx
	mov	eax, DWORD PTR $T236699[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T236708[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T236708[ebp], eax
	jne	$LN4@DoTestSmal

; 5341 : 						{
; 5342 : 							CvNotifications* pNotifications = GET_PLAYER(ePlayer).GetNotifications();

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T236712[ebp], edx
	mov	ecx, DWORD PTR $T236712[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotifications$225579[ebp], eax

; 5343 : 							if(pNotifications)

	cmp	DWORD PTR _pNotifications$225579[ebp], 0
	je	$LN4@DoTestSmal

; 5344 : 							{
; 5345 : 								if(getNumMembers() == 1)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNumMembers@CvTeam@@QBEHXZ		; CvTeam::getNumMembers
	cmp	eax, 1
	jne	$LN2@DoTestSmal

; 5346 : 								{
; 5347 : 									strBuffer = GetLocalizedText(pkSmallAwardInfo->GetNotificationString(), iNotificationData, pkSmallAwardInfo->GetNumVictoryPoints());

	mov	ecx, DWORD PTR _pkSmallAwardInfo$225550[ebp]
	call	?GetNumVictoryPoints@CvSmallAwardInfo@@QBEHXZ ; CvSmallAwardInfo::GetNumVictoryPoints
	mov	DWORD PTR $T236585[ebp], eax
	lea	eax, DWORD PTR $T236586[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkSmallAwardInfo$225550[ebp]
	call	?GetNotificationString@CvSmallAwardInfo@@QBE?AVCvString@@XZ ; CvSmallAwardInfo::GetNotificationString
	mov	DWORD PTR tv427[ebp], eax
	mov	ecx, DWORD PTR tv427[ebp]
	mov	DWORD PTR $T236716[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR $T236716[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T236717[ebp], eax
	lea	edx, DWORD PTR $T236585[ebp]
	push	edx
	lea	eax, DWORD PTR _iNotificationData$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T236717[ebp]
	push	ecx
	lea	edx, DWORD PTR $T236587[ebp]
	push	edx
	call	??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z ; GetLocalizedText<int,int>
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv416[ebp], eax
	mov	eax, DWORD PTR tv416[ebp]
	mov	DWORD PTR $T236721[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR $T236721[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strBuffer$225572[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T236587[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T236586[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5348 : 									strSummary = GetLocalizedText(pkSmallAwardInfo->GetDescription());

	mov	ecx, DWORD PTR _pkSmallAwardInfo$225550[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T236733[ebp], eax
	mov	edx, DWORD PTR $T236733[ebp]
	push	edx
	lea	eax, DWORD PTR $T236588[ebp]
	push	eax
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	mov	DWORD PTR tv239[ebp], eax
	mov	ecx, DWORD PTR tv239[ebp]
	mov	DWORD PTR $T236737[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	edx, DWORD PTR $T236737[ebp]
	push	edx
	lea	ecx, DWORD PTR _strSummary$225573[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T236588[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5349 : 								}
; 5350 : 								// Team game, different string
; 5351 : 								else

	jmp	$LN1@DoTestSmal
$LN2@DoTestSmal:

; 5352 : 								{
; 5353 : 									strBuffer = GetLocalizedText(pkSmallAwardInfo->GetTeamNotificationString(), iNotificationData, pkSmallAwardInfo->GetNumVictoryPoints());

	mov	ecx, DWORD PTR _pkSmallAwardInfo$225550[ebp]
	call	?GetNumVictoryPoints@CvSmallAwardInfo@@QBEHXZ ; CvSmallAwardInfo::GetNumVictoryPoints
	mov	DWORD PTR $T236589[ebp], eax
	lea	eax, DWORD PTR $T236590[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkSmallAwardInfo$225550[ebp]
	call	?GetTeamNotificationString@CvSmallAwardInfo@@QBE?AVCvString@@XZ ; CvSmallAwardInfo::GetTeamNotificationString
	mov	DWORD PTR tv544[ebp], eax
	mov	ecx, DWORD PTR tv544[ebp]
	mov	DWORD PTR $T236745[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR $T236745[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T236746[ebp], eax
	lea	edx, DWORD PTR $T236589[ebp]
	push	edx
	lea	eax, DWORD PTR _iNotificationData$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T236746[ebp]
	push	ecx
	lea	edx, DWORD PTR $T236591[ebp]
	push	edx
	call	??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z ; GetLocalizedText<int,int>
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv545[ebp], eax
	mov	eax, DWORD PTR tv545[ebp]
	mov	DWORD PTR $T236750[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR $T236750[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strBuffer$225572[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T236591[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T236590[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5354 : 									strSummary = GetLocalizedText(pkSmallAwardInfo->GetDescription());

	mov	ecx, DWORD PTR _pkSmallAwardInfo$225550[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T236762[ebp], eax
	mov	edx, DWORD PTR $T236762[ebp]
	push	edx
	lea	eax, DWORD PTR $T236592[ebp]
	push	eax
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	mov	DWORD PTR tv546[ebp], eax
	mov	ecx, DWORD PTR tv546[ebp]
	mov	DWORD PTR $T236766[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	edx, DWORD PTR $T236766[ebp]
	push	edx
	lea	ecx, DWORD PTR _strSummary$225573[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T236592[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@DoTestSmal:

; 5355 : 								}
; 5356 : 								pNotifications->Add(NOTIFICATION_VICTORY, strBuffer, strSummary, iNotificationX, iNotificationY, -1);

	lea	ecx, DWORD PTR _strSummary$225573[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T236774[ebp], eax
	push	-1
	push	-1
	mov	eax, DWORD PTR _iNotificationY$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iNotificationX$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T236774[ebp]
	push	edx
	lea	ecx, DWORD PTR _strBuffer$225572[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	1482916943				; 5863844fH
	mov	ecx, DWORD PTR _pNotifications$225579[ebp]
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN4@DoTestSmal:

; 5357 : 							}
; 5358 : 						}
; 5359 : 					}

	jmp	$LN6@DoTestSmal
$LN5@DoTestSmal:

; 5360 : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strSummary$225573[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strBuffer$225572[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN26@DoTestSmal:

; 5361 : 			}
; 5362 : 		}

	jmp	$LN28@DoTestSmal
$LN32@DoTestSmal:

; 5363 : 	}
; 5364 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoTestSmallAwards@CvTeam@@QAEXXZ$0:
	lea	ecx, DWORD PTR _strBuffer$225572[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoTestSmallAwards@CvTeam@@QAEXXZ$1:
	lea	ecx, DWORD PTR _strSummary$225573[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoTestSmallAwards@CvTeam@@QAEXXZ$2:
	lea	ecx, DWORD PTR $T236586[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoTestSmallAwards@CvTeam@@QAEXXZ$3:
	lea	ecx, DWORD PTR $T236587[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoTestSmallAwards@CvTeam@@QAEXXZ$4:
	lea	ecx, DWORD PTR $T236588[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoTestSmallAwards@CvTeam@@QAEXXZ$5:
	lea	ecx, DWORD PTR $T236590[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoTestSmallAwards@CvTeam@@QAEXXZ$6:
	lea	ecx, DWORD PTR $T236591[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoTestSmallAwards@CvTeam@@QAEXXZ$7:
	lea	ecx, DWORD PTR $T236592[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?DoTestSmallAwards@CvTeam@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-424]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DoTestSmallAwards@CvTeam@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoTestSmallAwards@CvTeam@@QAEXXZ ENDP			; CvTeam::DoTestSmallAwards
PUBLIC	__$ArrayPad$
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z:PROC
EXTRN	__imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z:PROC
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?GetLocalizedText@@YA?AVCvString@@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$1
__ehfuncinfo$?GetLocalizedText@@YA?AVCvString@@PBD@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ?GetLocalizedText@@YA?AVCvString@@PBD@Z
_TEXT	SEGMENT
$T236798 = -140						; size = 4
_str$ = -136						; size = 28
__$ArrayPad$ = -108					; size = 4
_bytes$ = -104						; size = 4
_text$ = -100						; size = 80
_szComposedString$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
?GetLocalizedText@@YA?AVCvString@@PBD@Z PROC		; GetLocalizedText, COMDAT

; 489  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 128				; 00000080H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T236798[ebp], 0

; 490  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[ebp]
	push	eax
	lea	ecx, DWORD PTR _text$[ebp]
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 491  : 
; 492  : 	size_t bytes = 0;

	mov	DWORD PTR _bytes$[ebp], 0

; 493  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	edx, DWORD PTR _bytes$[ebp]
	push	edx
	lea	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z
	mov	DWORD PTR _szComposedString$[ebp], eax

; 494  : 	CvString str;

	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 495  : 	str.assign(szComposedString, bytes);

	mov	eax, DWORD PTR _bytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szComposedString$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z

; 496  : 	return str;

	lea	edx, DWORD PTR _str$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T236798[ebp]
	or	eax, 1
	mov	DWORD PTR $T236798[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 497  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$1:
	lea	ecx, DWORD PTR _str$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$2:
	mov	eax, DWORD PTR $T236798[ebp]
	and	eax, 1
	je	$LN6@GetLocaliz
	and	DWORD PTR $T236798[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN6@GetLocaliz:
	ret	0
__ehhandler$?GetLocalizedText@@YA?AVCvString@@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-132]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetLocalizedText@@YA?AVCvString@@PBD@Z ENDP		; GetLocalizedText
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
;	COMDAT ?IsSmallAwardAchieved@CvTeam@@QBE_NW4SmallAwardTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eAward$ = 8						; size = 4
?IsSmallAwardAchieved@CvTeam@@QBE_NW4SmallAwardTypes@@@Z PROC ; CvTeam::IsSmallAwardAchieved, COMDAT
; _this$ = ecx

; 5369 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5370 : 	FAssert(eAward >= 0);
; 5371 : 	FAssert(eAward < GC.getNumSmallAwardInfos());
; 5372 : 
; 5373 : 	return m_abSmallAwardAchieved[eAward];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2904]
	mov	edx, DWORD PTR _eAward$[ebp]
	mov	al, BYTE PTR [ecx+edx]

; 5374 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsSmallAwardAchieved@CvTeam@@QBE_NW4SmallAwardTypes@@@Z ENDP ; CvTeam::IsSmallAwardAchieved
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?SetSmallAwardAchieved@CvTeam@@QAEXW4SmallAwardTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eAward$ = 8						; size = 4
_bValue$ = 12						; size = 1
?SetSmallAwardAchieved@CvTeam@@QAEXW4SmallAwardTypes@@_N@Z PROC ; CvTeam::SetSmallAwardAchieved, COMDAT
; _this$ = ecx

; 5379 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5380 : 	FAssert(eAward >= 0);
; 5381 : 	FAssert(eAward < GC.getNumSmallAwardInfos());
; 5382 : 
; 5383 : 	m_abSmallAwardAchieved[eAward] = bValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2904]
	mov	edx, DWORD PTR _eAward$[ebp]
	mov	al, BYTE PTR _bValue$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 5384 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetSmallAwardAchieved@CvTeam@@QAEXW4SmallAwardTypes@@_N@Z ENDP ; CvTeam::SetSmallAwardAchieved
_TEXT	ENDS
PUBLIC	??_C@_0CB@LLAIKMKO@TXT_KEY_MISC_YOU_DISCOVERED_TECH@ ; `string'
PUBLIC	??_C@_0CD@JJHNCAJE@TXT_KEY_MISC_PROGRESS_TOWARDS_TE@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?announceTechToPlayers@CvTeam@@IAEXW4TechTypes@@_N@Z ; CvTeam::announceTechToPlayers
;	COMDAT ??_C@_0CB@LLAIKMKO@TXT_KEY_MISC_YOU_DISCOVERED_TECH@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0CB@LLAIKMKO@TXT_KEY_MISC_YOU_DISCOVERED_TECH@ DB 'TXT_KEY_MISC_YOU'
	DB	'_DISCOVERED_TECH', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@JJHNCAJE@TXT_KEY_MISC_PROGRESS_TOWARDS_TE@
CONST	SEGMENT
??_C@_0CD@JJHNCAJE@TXT_KEY_MISC_PROGRESS_TOWARDS_TE@ DB 'TXT_KEY_MISC_PRO'
	DB	'GRESS_TOWARDS_TECH', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?announceTechToPlayers@CvTeam@@IAEXW4TechTypes@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?announceTechToPlayers@CvTeam@@IAEXW4TechTypes@@_N@Z$0
__ehfuncinfo$?announceTechToPlayers@CvTeam@@IAEXW4TechTypes@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?announceTechToPlayers@CvTeam@@IAEXW4TechTypes@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?announceTechToPlayers@CvTeam@@IAEXW4TechTypes@@_N@Z
_TEXT	SEGMENT
tv157 = -116						; size = 4
tv176 = -112						; size = 4
tv146 = -108						; size = 4
tv82 = -104						; size = 4
_this$ = -100						; size = 4
$T236872 = -96						; size = 4
$T236868 = -92						; size = 4
$T236864 = -88						; size = 4
$T236860 = -84						; size = 4
$T236856 = -80						; size = 4
$T236847 = -73						; size = 1
$T236835 = -72						; size = 4
_strBuffer$225625 = -68					; size = 28
__$ArrayPad$ = -40					; size = 4
_ePlayer$225620 = -36					; size = 4
_kPlayer$225622 = -32					; size = 4
_iI$225616 = -28					; size = 4
_szTechTextKey$ = -24					; size = 4
_bSound$ = -17						; size = 1
_pkTechInfo$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_eIndex$ = 8						; size = 4
_bPartial$ = 12						; size = 1
?announceTechToPlayers@CvTeam@@IAEXW4TechTypes@@_N@Z PROC ; CvTeam::announceTechToPlayers, COMDAT
; _this$ = ecx

; 5388 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?announceTechToPlayers@CvTeam@@IAEXW4TechTypes@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 5389 : 	CvTechEntry* pkTechInfo = GC.getTechInfo(eIndex);

	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo
	mov	DWORD PTR _pkTechInfo$[ebp], eax

; 5390 : 	if(pkTechInfo == NULL)

	cmp	DWORD PTR _pkTechInfo$[ebp], 0
	jne	SHORT $LN6@announceTe

; 5391 : 		return;

	jmp	$LN7@announceTe
$LN6@announceTe:

; 5392 : 
; 5393 : 	const char* szTechTextKey = pkTechInfo->GetTextKey();

	mov	ecx, DWORD PTR _pkTechInfo$[ebp]
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	mov	DWORD PTR _szTechTextKey$[ebp], eax

; 5394 : 
; 5395 : 	bool bSound = (GC.getGame().isNetworkMultiPlayer() && !bPartial);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T236835[ebp], ecx
	mov	ecx, DWORD PTR $T236835[ebp]
	call	?isNetworkMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isNetworkMultiPlayer
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN9@announceTe
	movzx	eax, BYTE PTR _bPartial$[ebp]
	test	eax, eax
	jne	SHORT $LN9@announceTe
	mov	DWORD PTR tv82[ebp], 1
	jmp	SHORT $LN10@announceTe
$LN9@announceTe:
	mov	DWORD PTR tv82[ebp], 0
$LN10@announceTe:
	mov	cl, BYTE PTR tv82[ebp]
	mov	BYTE PTR _bSound$[ebp], cl

; 5396 : 	for(int iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$225616[ebp], 0
	jmp	SHORT $LN5@announceTe
$LN4@announceTe:
	mov	edx, DWORD PTR _iI$225616[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$225616[ebp], edx
$LN5@announceTe:
	cmp	DWORD PTR _iI$225616[ebp], 64		; 00000040H
	jge	$LN7@announceTe

; 5397 : 	{
; 5398 : 		const PlayerTypes ePlayer = static_cast<PlayerTypes>(iI);

	mov	eax, DWORD PTR _iI$225616[ebp]
	mov	DWORD PTR _ePlayer$225620[ebp], eax

; 5399 : 		CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);

	mov	ecx, DWORD PTR _ePlayer$225620[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$225622[ebp], ecx

; 5400 : 
; 5401 : 		if(kPlayer.isAlive() && kPlayer.getTeam() == GetID())

	mov	edx, DWORD PTR _kPlayer$225622[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T236847[ebp], al
	movzx	ecx, BYTE PTR $T236847[ebp]
	test	ecx, ecx
	je	$LN2@announceTe
	mov	edx, DWORD PTR _kPlayer$225622[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T236856[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T236856[ebp], eax
	jne	$LN2@announceTe

; 5402 : 		{
; 5403 : 			if(ePlayer == GC.getGame().getActivePlayer())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T236860[ebp], ecx
	mov	ecx, DWORD PTR $T236860[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	DWORD PTR _ePlayer$225620[ebp], eax
	jne	$LN2@announceTe

; 5404 : 			{
; 5405 : 				CvString strBuffer = GetLocalizedText((bPartial ? "TXT_KEY_MISC_PROGRESS_TOWARDS_TECH" : "TXT_KEY_MISC_YOU_DISCOVERED_TECH"), szTechTextKey);

	movzx	edx, BYTE PTR _bPartial$[ebp]
	test	edx, edx
	je	SHORT $LN11@announceTe
	mov	DWORD PTR tv146[ebp], OFFSET ??_C@_0CD@JJHNCAJE@TXT_KEY_MISC_PROGRESS_TOWARDS_TE@
	jmp	SHORT $LN12@announceTe
$LN11@announceTe:
	mov	DWORD PTR tv146[ebp], OFFSET ??_C@_0CB@LLAIKMKO@TXT_KEY_MISC_YOU_DISCOVERED_TECH@
$LN12@announceTe:
	mov	eax, DWORD PTR _szTechTextKey$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv146[ebp]
	push	ecx
	lea	edx, DWORD PTR _strBuffer$225625[ebp]
	push	edx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5406 : 				DLLUI->AddMessage(0, ePlayer, false, (bSound ? GC.getEVENT_MESSAGE_TIME() : -1), strBuffer/*, (bSound ? GC.getTechInfo(eIndex)->GetSoundMP() : NULL), MESSAGE_TYPE_MAJOR_EVENT, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_TECH_TEXT")*/);

	movzx	eax, BYTE PTR _bSound$[ebp]
	test	eax, eax
	je	SHORT $LN13@announceTe
	mov	ecx, DWORD PTR $T236864[ebp]
	mov	DWORD PTR tv176[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	mov	DWORD PTR tv176[ebp], edx
	jmp	SHORT $LN14@announceTe
$LN13@announceTe:
	mov	DWORD PTR tv176[ebp], -1
$LN14@announceTe:
	mov	eax, DWORD PTR $T236868[ebp]
	mov	DWORD PTR tv157[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv157[ebp], ecx
	lea	ecx, DWORD PTR _strBuffer$225625[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T236872[ebp], eax
	push	0
	push	0
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR $T236872[ebp]
	push	edx
	mov	eax, DWORD PTR tv176[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _ePlayer$225620[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR tv157[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv157[ebp]
	mov	edx, DWORD PTR [eax+160]
	call	edx

; 5407 : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strBuffer$225625[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@announceTe:

; 5408 : 		}

	jmp	$LN4@announceTe
$LN7@announceTe:

; 5409 : 	}
; 5410 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?announceTechToPlayers@CvTeam@@IAEXW4TechTypes@@_N@Z$0:
	lea	ecx, DWORD PTR _strBuffer$225625[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?announceTechToPlayers@CvTeam@@IAEXW4TechTypes@@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-108]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?announceTechToPlayers@CvTeam@@IAEXW4TechTypes@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?announceTechToPlayers@CvTeam@@IAEXW4TechTypes@@_N@Z ENDP ; CvTeam::announceTechToPlayers
PUBLIC	??_C@_0CD@CKJNKGCB@TXT_KEY_MISC_WHAT_TO_RESEARCH_NE@ ; `string'
PUBLIC	?updateTechShare@CvTeam@@IAEXW4TechTypes@@@Z	; CvTeam::updateTechShare
PUBLIC	??_C@_0CO@GNDPPHJN@TXT_KEY_MISC_RESOURCE_DISCOVERED@ ; `string'
PUBLIC	??_C@_0CF@IOFIPAIJ@TXT_KEY_MISC_YOU_DISCOVERED_RESO@ ; `string'
PUBLIC	??_C@_0CO@ODOBJOOJ@TXT_KEY_MISC_DISCOVERED_HIDDEN_A@ ; `string'
PUBLIC	??_C@_0CH@BOBAFPHE@TXT_KEY_MISC_DISCOVERED_ARTIFACT@ ; `string'
PUBLIC	??_C@_0CD@HPOEABOJ@TXT_KEY_MISC_UNKNOWN_FIRST_TO_TE@ ; `string'
PUBLIC	??_C@_0CD@JACHOIBD@TXT_KEY_MISC_SOMEONE_FIRST_TO_TE@ ; `string'
PUBLIC	??_C@_0CE@BFHEGKPF@TXT_KEY_MISC_FIRST_TECH_CHOOSE_F@ ; `string'
PUBLIC	?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z	; CvTeam::SetCurrentEra
PUBLIC	??_C@_0CM@OPMEONLG@TXT_KEY_NOTIFICATION_FOUND_HIDDE@ ; `string'
PUBLIC	??_C@_0CF@GJMAIIHL@TXT_KEY_NOTIFICATION_FOUND_ARTIF@ ; `string'
PUBLIC	??_C@_0BK@GEJOKJMD@RESOURCE_HIDDEN_ARTIFACTS?$AA@ ; `string'
PUBLIC	??_C@_0BD@DCOOKOLP@RESOURCE_ARTIFACTS?$AA@	; `string'
PUBLIC	?processTech@CvTeam@@IAEXW4TechTypes@@H@Z	; CvTeam::processTech
PUBLIC	?isCity@CvPlot@@QBE_NXZ				; CvPlot::isCity
PUBLIC	??_C@_0CM@KJCPOICM@TXT_KEY_NOTIFICATION_SUMMARY_FOU@ ; `string'
PUBLIC	??_C@_0CE@PCNACIPL@TXT_KEY_NOTIFICATION_FOUND_RESOU@ ; `string'
PUBLIC	??_C@_0BL@KBKANIAP@GAMEOPTION_TWEAKED_SCORING?$AA@ ; `string'
PUBLIC	??_C@_0P@HDCDANOJ@WORLDSIZE_HUGE?$AA@		; `string'
PUBLIC	??_C@_0BC@OHNNINLK@CIVILIZATION_HUNS?$AA@	; `string'
PUBLIC	??_C@_0BA@LBHEJNAN@TECH_SATELLITES?$AA@		; `string'
PUBLIC	__$ArrayPad$
EXTRN	?DoUpdateHappiness@CvPlayer@@QAEXXZ:PROC	; CvPlayer::DoUpdateHappiness
EXTRN	?BuildStealableTechList@CvPlayerEspionage@@QAEXW4PlayerTypes@@@Z:PROC ; CvPlayerEspionage::BuildStealableTechList
EXTRN	?isBarbarian@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isBarbarian
EXTRN	?GetCurrentResearch@CvPlayerTechs@@QBE?AW4TechTypes@@XZ:PROC ; CvPlayerTechs::GetCurrentResearch
EXTRN	?IsResearch@CvPlayerTechs@@QBE_NXZ:PROC		; CvPlayerTechs::IsResearch
EXTRN	?SetOwedCultureBuilding@CvCity@@QAEX_N@Z:PROC	; CvCity::SetOwedCultureBuilding
EXTRN	?SetNumFreeBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z:PROC ; CvCityBuildings::SetNumFreeBuilding
EXTRN	?ChooseFreeCultureBuilding@CvCity@@QBE?AW4BuildingTypes@@XZ:PROC ; CvCity::ChooseFreeCultureBuilding
EXTRN	?IsOwedCultureBuilding@CvCity@@QBE_NXZ:PROC	; CvCity::IsOwedCultureBuilding
EXTRN	?GetResourceDemanded@CvCity@@QBE?AW4ResourceTypes@@_N@Z:PROC ; CvCity::GetResourceDemanded
EXTRN	?GetPlotIndex@CvPlot@@QBEHXZ:PROC		; CvPlot::GetPlotIndex
EXTRN	?findCity@CvMap@@QAEPAVCvCity@@HHW4PlayerTypes@@W4TeamTypes@@_N21W4DirectionTypes@@PBV2@@Z:PROC ; CvMap::findCity
EXTRN	?chooseTech@CvPlayer@@QAEXHPBDW4TechTypes@@@Z:PROC ; CvPlayer::chooseTech
EXTRN	?GetFirstFreeTechs@CvTechEntry@@QBEHXZ:PROC	; CvTechEntry::GetFirstFreeTechs
EXTRN	?DoSpawnGreatPerson@CvCityCitizens@@QAEXW4UnitTypes@@_N1@Z:PROC ; CvCityCitizens::DoSpawnGreatPerson
EXTRN	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ:PROC ; CvCity::GetCityCitizens
EXTRN	?getCivilizationUnits@CvCivilizationInfo@@QBEHH@Z:PROC ; CvCivilizationInfo::getCivilizationUnits
EXTRN	?GetFirstFreeUnitClass@CvTechEntry@@QBEHXZ:PROC	; CvTechEntry::GetFirstFreeUnitClass
EXTRN	?countKnownTechNumTeams@CvGame@@QAEHW4TechTypes@@@Z:PROC ; CvGame::countKnownTechNumTeams
EXTRN	?invalidateYieldRankCache@CvPlayer@@QAEXW4YieldTypes@@@Z:PROC ; CvPlayer::invalidateYieldRankCache
EXTRN	?popResearch@CvPlayer@@QAEXW4TechTypes@@@Z:PROC	; CvPlayer::popResearch
EXTRN	?IsResearchingTech@CvPlayerTechs@@QBE_NW4TechTypes@@@Z:PROC ; CvPlayerTechs::IsResearchingTech
EXTRN	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ:PROC ; CvPlayer::GetPlayerTechs
EXTRN	?setRevealedPlots@CvMap@@QAEXW4TeamTypes@@_N1@Z:PROC ; CvMap::setRevealedPlots
EXTRN	?IsMapVisible@CvTechEntry@@QBE_NXZ:PROC		; CvTechEntry::IsMapVisible
EXTRN	?getEraInfo@CvGlobals@@QAEPAVCvEraInfo@@W4EraTypes@@@Z:PROC ; CvGlobals::getEraInfo
EXTRN	?getNumEraInfos@CvGlobals@@QAEHXZ:PROC		; CvGlobals::getNumEraInfos
EXTRN	?GetEra@CvTechEntry@@QBEHXZ:PROC		; CvTechEntry::GetEra
EXTRN	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z:PROC ; CvGlobals::getInfoTypeForString
EXTRN	?SetResourceLinkedCityActive@CvPlot@@QAEX_N@Z:PROC ; CvPlot::SetResourceLinkedCityActive
EXTRN	?GetResourceLinkedCity@CvPlot@@QBEPAVCvCity@@XZ:PROC ; CvPlot::GetResourceLinkedCity
EXTRN	?changeNumResourceTotal@CvPlayer@@QAEXW4ResourceTypes@@H_N@Z:PROC ; CvPlayer::changeNumResourceTotal
EXTRN	?getNumResourceForPlayer@CvPlot@@QBEHW4PlayerTypes@@@Z:PROC ; CvPlot::getNumResourceForPlayer
EXTRN	?IsImprovedByGiftFromMajor@CvPlot@@QBE_NXZ:PROC	; CvPlot::IsImprovedByGiftFromMajor
EXTRN	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z:PROC ; CvImprovementEntry::IsImprovementResourceTrade
EXTRN	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z:PROC ; CvGlobals::getImprovementInfo
EXTRN	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ:PROC ; CvPlot::getImprovementType
EXTRN	?getTechCityTrade@CvResourceInfo@@QBEHXZ:PROC	; CvResourceInfo::getTechCityTrade
EXTRN	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ:PROC ; CvResourceInfo::getResourceUsage
EXTRN	?loadWBScenario@CvPreGame@@YA_NXZ:PROC		; CvPreGame::loadWBScenario
EXTRN	?setLayoutDirty@CvPlot@@QAEX_N@Z:PROC		; CvPlot::setLayoutDirty
EXTRN	?IsResourceForceReveal@CvPlot@@QBE_NW4TeamTypes@@@Z:PROC ; CvPlot::IsResourceForceReveal
EXTRN	?DoFindCityToLinkResourceTo@CvPlot@@QAEXPAVCvCity@@@Z:PROC ; CvPlot::DoFindCityToLinkResourceTo
EXTRN	?isOwned@CvPlot@@QBE_NXZ:PROC			; CvPlot::isOwned
EXTRN	?getTechReveal@CvResourceInfo@@QBEHXZ:PROC	; CvResourceInfo::getTechReveal
EXTRN	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z:PROC ; CvGlobals::getResourceInfo
EXTRN	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::getResourceType
EXTRN	?updateStrengthValue@CvCity@@QAEXXZ:PROC	; CvCity::updateStrengthValue
EXTRN	?SetHasTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z:PROC ; CvTeamTechs::SetHasTech
EXTRN	?GetTechCount@CvTeamTechs@@QBEHW4TechTypes@@@Z:PROC ; CvTeamTechs::GetTechCount
EXTRN	?ChangeScoreFromFutureTech@CvPlayer@@QAEXH@Z:PROC ; CvPlayer::ChangeScoreFromFutureTech
EXTRN	?IncrementTechCount@CvTeamTechs@@QAEXW4TechTypes@@@Z:PROC ; CvTeamTechs::IncrementTechCount
EXTRN	?IsRepeat@CvTechEntry@@QBE_NXZ:PROC		; CvTechEntry::IsRepeat
EXTRN	?getWorldInfo@CvMap@@QBEABVCvWorldInfo@@XZ:PROC	; CvMap::getWorldInfo
EXTRN	?getCivilizationTypeKey@CvPlayer@@QBEPBDXZ:PROC	; CvPlayer::getCivilizationTypeKey
;	COMDAT ??_C@_0CD@CKJNKGCB@TXT_KEY_MISC_WHAT_TO_RESEARCH_NE@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0CD@CKJNKGCB@TXT_KEY_MISC_WHAT_TO_RESEARCH_NE@ DB 'TXT_KEY_MISC_WHA'
	DB	'T_TO_RESEARCH_NEXT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@GNDPPHJN@TXT_KEY_MISC_RESOURCE_DISCOVERED@
CONST	SEGMENT
??_C@_0CO@GNDPPHJN@TXT_KEY_MISC_RESOURCE_DISCOVERED@ DB 'TXT_KEY_MISC_RES'
	DB	'OURCE_DISCOVERED_CITY_DEMANDS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@IOFIPAIJ@TXT_KEY_MISC_YOU_DISCOVERED_RESO@
CONST	SEGMENT
??_C@_0CF@IOFIPAIJ@TXT_KEY_MISC_YOU_DISCOVERED_RESO@ DB 'TXT_KEY_MISC_YOU'
	DB	'_DISCOVERED_RESOURCE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@ODOBJOOJ@TXT_KEY_MISC_DISCOVERED_HIDDEN_A@
CONST	SEGMENT
??_C@_0CO@ODOBJOOJ@TXT_KEY_MISC_DISCOVERED_HIDDEN_A@ DB 'TXT_KEY_MISC_DIS'
	DB	'COVERED_HIDDEN_ARTIFACTS_NEAR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@BOBAFPHE@TXT_KEY_MISC_DISCOVERED_ARTIFACT@
CONST	SEGMENT
??_C@_0CH@BOBAFPHE@TXT_KEY_MISC_DISCOVERED_ARTIFACT@ DB 'TXT_KEY_MISC_DIS'
	DB	'COVERED_ARTIFACTS_NEAR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HPOEABOJ@TXT_KEY_MISC_UNKNOWN_FIRST_TO_TE@
CONST	SEGMENT
??_C@_0CD@HPOEABOJ@TXT_KEY_MISC_UNKNOWN_FIRST_TO_TE@ DB 'TXT_KEY_MISC_UNK'
	DB	'NOWN_FIRST_TO_TECH', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@JACHOIBD@TXT_KEY_MISC_SOMEONE_FIRST_TO_TE@
CONST	SEGMENT
??_C@_0CD@JACHOIBD@TXT_KEY_MISC_SOMEONE_FIRST_TO_TE@ DB 'TXT_KEY_MISC_SOM'
	DB	'EONE_FIRST_TO_TECH', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@BFHEGKPF@TXT_KEY_MISC_FIRST_TECH_CHOOSE_F@
CONST	SEGMENT
??_C@_0CE@BFHEGKPF@TXT_KEY_MISC_FIRST_TECH_CHOOSE_F@ DB 'TXT_KEY_MISC_FIR'
	DB	'ST_TECH_CHOOSE_FREE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@OPMEONLG@TXT_KEY_NOTIFICATION_FOUND_HIDDE@
CONST	SEGMENT
??_C@_0CM@OPMEONLG@TXT_KEY_NOTIFICATION_FOUND_HIDDE@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_FOUND_HIDDEN_ARTIFACTS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GJMAIIHL@TXT_KEY_NOTIFICATION_FOUND_ARTIF@
CONST	SEGMENT
??_C@_0CF@GJMAIIHL@TXT_KEY_NOTIFICATION_FOUND_ARTIF@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_FOUND_ARTIFACTS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GEJOKJMD@RESOURCE_HIDDEN_ARTIFACTS?$AA@
CONST	SEGMENT
??_C@_0BK@GEJOKJMD@RESOURCE_HIDDEN_ARTIFACTS?$AA@ DB 'RESOURCE_HIDDEN_ART'
	DB	'IFACTS', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DCOOKOLP@RESOURCE_ARTIFACTS?$AA@
CONST	SEGMENT
??_C@_0BD@DCOOKOLP@RESOURCE_ARTIFACTS?$AA@ DB 'RESOURCE_ARTIFACTS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@KJCPOICM@TXT_KEY_NOTIFICATION_SUMMARY_FOU@
CONST	SEGMENT
??_C@_0CM@KJCPOICM@TXT_KEY_NOTIFICATION_SUMMARY_FOU@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_SUMMARY_FOUND_RESOURCE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@PCNACIPL@TXT_KEY_NOTIFICATION_FOUND_RESOU@
CONST	SEGMENT
??_C@_0CE@PCNACIPL@TXT_KEY_NOTIFICATION_FOUND_RESOU@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_FOUND_RESOURCE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KBKANIAP@GAMEOPTION_TWEAKED_SCORING?$AA@
CONST	SEGMENT
??_C@_0BL@KBKANIAP@GAMEOPTION_TWEAKED_SCORING?$AA@ DB 'GAMEOPTION_TWEAKED'
	DB	'_SCORING', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HDCDANOJ@WORLDSIZE_HUGE?$AA@
CONST	SEGMENT
??_C@_0P@HDCDANOJ@WORLDSIZE_HUGE?$AA@ DB 'WORLDSIZE_HUGE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OHNNINLK@CIVILIZATION_HUNS?$AA@
CONST	SEGMENT
??_C@_0BC@OHNNINLK@CIVILIZATION_HUNS?$AA@ DB 'CIVILIZATION_HUNS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LBHEJNAN@TECH_SATELLITES?$AA@
CONST	SEGMENT
??_C@_0BA@LBHEJNAN@TECH_SATELLITES?$AA@ DB 'TECH_SATELLITES', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z DD 019930522H
	DD	012H
	DD	FLAT:__unwindtable$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$4
	DD	03H
	DD	FLAT:__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$5
	DD	03H
	DD	FLAT:__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$6
	DD	03H
	DD	FLAT:__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$7
	DD	00H
	DD	FLAT:__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$8
	DD	00H
	DD	FLAT:__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$9
	DD	00H
	DD	FLAT:__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$10
	DD	00H
	DD	FLAT:__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$11
	DD	00H
	DD	FLAT:__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$12
	DD	00H
	DD	FLAT:__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$13
	DD	00H
	DD	FLAT:__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$14
	DD	00H
	DD	FLAT:__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$15
	DD	00H
	DD	FLAT:__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$16
	DD	00H
	DD	FLAT:__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$17
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z
_TEXT	SEGMENT
tv1761 = -2212						; size = 4
tv1748 = -2208						; size = 4
tv1686 = -2204						; size = 4
tv1671 = -2200						; size = 4
tv1659 = -2196						; size = 4
tv1647 = -2192						; size = 4
tv2352 = -2188						; size = 4
tv1394 = -2184						; size = 4
tv2351 = -2180						; size = 4
tv1261 = -2176						; size = 4
tv2350 = -2172						; size = 4
tv2349 = -2168						; size = 4
tv1225 = -2164						; size = 4
tv2925 = -2160						; size = 4
tv2920 = -2154						; size = 1
tv2913 = -2153						; size = 1
tv2909 = -2152						; size = 4
tv2910 = -2148						; size = 4
tv2348 = -2144						; size = 4
tv1204 = -2140						; size = 4
tv2896 = -2136						; size = 4
tv2891 = -2130						; size = 1
tv2884 = -2129						; size = 1
tv2880 = -2128						; size = 4
tv2881 = -2124						; size = 4
tv2347 = -2120						; size = 4
tv1031 = -2116						; size = 4
tv1729 = -2112						; size = 4
tv1741 = -2108						; size = 4
tv1740 = -2104						; size = 4
tv922 = -2100						; size = 4
tv688 = -2096						; size = 4
tv1735 = -2092						; size = 4
tv66 = -2088						; size = 4
tv1808 = -2084						; size = 4
tv364 = -2080						; size = 4
tv390 = -2076						; size = 4
tv1985 = -2072						; size = 4
tv167 = -2068						; size = 4
tv158 = -2064						; size = 4
tv2474 = -2060						; size = 4
tv2469 = -2054						; size = 1
tv2462 = -2053						; size = 1
tv2458 = -2052						; size = 4
tv2459 = -2048						; size = 4
tv143 = -2044						; size = 4
tv2449 = -2040						; size = 4
tv2444 = -2034						; size = 1
tv2437 = -2033						; size = 1
tv2433 = -2032						; size = 4
tv2434 = -2028						; size = 4
tv132 = -2024						; size = 4
tv2427 = -2020						; size = 4
tv2422 = -2014						; size = 1
tv2415 = -2013						; size = 1
tv2411 = -2012						; size = 4
tv2412 = -2008						; size = 4
_this$ = -2004						; size = 4
$T237731 = -2000					; size = 4
$T237727 = -1996					; size = 4
$T237723 = -1992					; size = 4
$T237719 = -1988					; size = 4
$T237715 = -1984					; size = 4
$T237711 = -1980					; size = 4
$T237707 = -1976					; size = 4
$T237703 = -1972					; size = 4
$T237699 = -1968					; size = 4
$T237695 = -1964					; size = 4
$T237691 = -1960					; size = 4
$T237687 = -1956					; size = 4
$T237680 = -1952					; size = 4
$T237671 = -1948					; size = 4
$T237667 = -1941					; size = 1
$T237658 = -1940					; size = 4
$T237651 = -1936					; size = 4
$T237647 = -1932					; size = 4
$T237643 = -1928					; size = 4
$T237639 = -1924					; size = 4
$T237635 = -1920					; size = 4
$T237628 = -1916					; size = 4
$T237620 = -1912					; size = 4
$T237616 = -1908					; size = 4
$T237612 = -1904					; size = 4
$T237608 = -1900					; size = 4
$T237604 = -1896					; size = 4
$T237600 = -1892					; size = 4
$T237596 = -1888					; size = 4
$T237592 = -1884					; size = 4
$T237583 = -1880					; size = 4
$T237573 = -1876					; size = 4
$T237569 = -1872					; size = 4
$T237565 = -1868					; size = 4
$T237557 = -1864					; size = 4
$T237553 = -1860					; size = 4
$T237549 = -1856					; size = 4
$T237545 = -1852					; size = 4
$T237541 = -1848					; size = 4
$T237532 = -1844					; size = 4
$T237528 = -1840					; size = 4
$T237524 = -1836					; size = 4
$T237520 = -1832					; size = 4
$T237516 = -1828					; size = 4
$T237508 = -1824					; size = 4
$T237500 = -1820					; size = 4
$T237489 = -1816					; size = 4
$T237482 = -1812					; size = 4
$T237478 = -1808					; size = 4
$T237474 = -1804					; size = 4
$T237470 = -1800					; size = 4
$T237466 = -1796					; size = 4
$T237462 = -1792					; size = 4
_playerID$237454 = -1788				; size = 4
$T237442 = -1784					; size = 4
$T237438 = -1780					; size = 4
$T237434 = -1776					; size = 4
$T237430 = -1772					; size = 4
$T237426 = -1765					; size = 1
$T237414 = -1764					; size = 4
$T237406 = -1760					; size = 4
$T237402 = -1756					; size = 4
$T237398 = -1752					; size = 4
$T237394 = -1748					; size = 4
$T237390 = -1744					; size = 4
$T237382 = -1740					; size = 4
$T237374 = -1736					; size = 4
$T237370 = -1732					; size = 4
$T237366 = -1728					; size = 4
$T237357 = -1724					; size = 4
$T237353 = -1717					; size = 1
$T237341 = -1716					; size = 4
$T237337 = -1712					; size = 4
$T237329 = -1708					; size = 4
$T237322 = -1704					; size = 4
$T237318 = -1700					; size = 4
$T237314 = -1696					; size = 4
$T237310 = -1692					; size = 4
$T237301 = -1685					; size = 1
$T237289 = -1684					; size = 4
$T237285 = -1680					; size = 4
$T237274 = -1676					; size = 4
$T237270 = -1672					; size = 4
$T237266 = -1668					; size = 4
$T237262 = -1664					; size = 4
$T237258 = -1660					; size = 4
$T237250 = -1656					; size = 4
$T237242 = -1652					; size = 4
$T237234 = -1648					; size = 4
$T237226 = -1644					; size = 4
$T237218 = -1640					; size = 4
_uiOffset$237216 = -1636				; size = 4
$T237207 = -1632					; size = 4
_playerID$237199 = -1628				; size = 4
$T237184 = -1624					; size = 4
$T237177 = -1620					; size = 4
$T237173 = -1616					; size = 4
$T237169 = -1612					; size = 4
$T237162 = -1608					; size = 4
$T237153 = -1601					; size = 1
$T237131 = -1592					; size = 4
_playerID$237123 = -1588				; size = 4
$T237107 = -1584					; size = 4
$T237103 = -1580					; size = 4
$T237099 = -1576					; size = 4
$T237095 = -1572					; size = 4
$T237091 = -1568					; size = 4
$T237083 = -1564					; size = 4
$T237079 = -1560					; size = 4
$T237075 = -1556					; size = 4
_playerID$237069 = -1552				; size = 4
$T237058 = -1548					; size = 4
$T237054 = -1544					; size = 4
$T237050 = -1540					; size = 4
_uiOffset$237048 = -1536				; size = 4
$T237036 = -1532					; size = 4
$T237029 = -1528					; size = 4
$T237025 = -1524					; size = 4
$T237021 = -1520					; size = 4
$T237012 = -1513					; size = 1
$T237000 = -1512					; size = 4
$T236996 = -1508					; size = 4
$T236987 = -1501					; size = 1
$T236972 = -1500					; size = 4
$T236965 = -1496					; size = 4
$T236961 = -1492					; size = 4
$T236957 = -1488					; size = 4
$T236950 = -1484					; size = 4
$T236909 = -1480					; size = 4
$T236908 = -1476					; size = 28
$T236907 = -1448					; size = 8
$T236906 = -1440					; size = 28
$T236905 = -1412					; size = 4
$T236904 = -1408					; size = 4
$T236903 = -1404					; size = 28
$T236902 = -1376					; size = 4
$T236901 = -1372					; size = 4
$T236900 = -1368					; size = 28
$T236899 = -1340					; size = 28
$T236898 = -1312					; size = 28
$T236897 = -1284					; size = 4
$T236896 = -1280					; size = 4
$T236895 = -1276					; size = 28
$T236894 = -1248					; size = 28
$T236893 = -1220					; size = 4
$T236892 = -1216					; size = 4
$T236891 = -1212					; size = 28
$T236890 = -1184					; size = 28
$T236889 = -1156					; size = 28
$T236888 = -1128					; size = 28
$T236887 = -1100					; size = 28
$T236886 = -1072					; size = 28
_kPopup$225975 = -1044					; size = 536
_localizedText$225969 = -508				; size = 80
_bDontShowRewardPopup$225966 = -421			; size = 1
_iPlayerLoop$225955 = -420				; size = 4
_ui$225949 = -416					; size = 4
_pEspionage$225947 = -412				; size = 4
_eFreeCultureBuilding$225937 = -408			; size = 4
_iPlayerLoop$225927 = -404				; size = 4
_eLoopTeam$225919 = -400				; size = 4
_kLoopTeam$225921 = -396				; size = 4
_iI$225915 = -392					; size = 4
_iPlayerLoop$225899 = -388				; size = 4
_pResourceInfo$225882 = -384				; size = 4
_eResource$225878 = -380				; size = 4
_pLoopPlot$225876 = -376				; size = 4
_iI$225872 = -372					; size = 4
_eLoopPlayer$225897 = -368				; size = 4
_eResourceDemanded$225898 = -364			; size = 4
_pLoopCity$225895 = -360				; size = 4
_iLoop$225896 = -356					; size = 4
_eLoopPlayer$225864 = -352				; size = 4
_kPlayer$225866 = -348					; size = 4
_iI$225860 = -344					; size = 4
_kLoopPLayer$225846 = -340				; size = 4
_eLoopPlayer$225844 = -336				; size = 4
_iI$225840 = -332					; size = 4
_iI$225833 = -328					; size = 4
_eLoopPlayer$225820 = -324				; size = 4
_kPlayer$225822 = -320					; size = 4
_iI$225816 = -316					; size = 4
_pkEraInfo$225813 = -312				; size = 4
_nextEra$225811 = -308					; size = 4
_iNextEra$225808 = -304					; size = 4
_currentEra$225807 = -300				; size = 4
_pkLoopTech$225802 = -296				; size = 4
_eLoopTech$225800 = -292				; size = 4
_iTechLoop$225796 = -288				; size = 4
_bHasAllEarlierTechs$225795 = -281			; size = 1
_eNewEra$225792 = -280					; size = 4
_eThisTechsEra$225789 = -276				; size = 4
_eLoopPlayer$225926 = -272				; size = 4
_pLoopCity$225924 = -268				; size = 4
_iLoop$225925 = -264					; size = 4
_pNotifications$225786 = -260				; size = 4
_strSummary$225767 = -256				; size = 28
_eNotificationType$225769 = -228			; size = 4
_eResourceUsage$225768 = -224				; size = 4
_ePlotResource$225763 = -220				; size = 4
_pLoopPlot$225761 = -216				; size = 4
_iPlotLoop$225757 = -212				; size = 4
_eActivePlayer$225755 = -208				; size = 4
_iNumPlots$225756 = -204				; size = 4
_eHiddenArtifactResource$225749 = -200			; size = 4
_bTechRevealsArtifacts$225742 = -194			; size = 1
_bTechRevealsHiddenArtifacts$225743 = -193		; size = 1
_eArtifactResource$225744 = -192			; size = 4
_pArtifactResource$225747 = -188			; size = 4
_pHiddenArtifactResource$225752 = -184			; size = 4
_kLoopPlayer$225731 = -180				; size = 4
_eLoopPlayer$225729 = -176				; size = 4
_iI$225725 = -172					; size = 4
_pNotifications$225717 = -168				; size = 4
_strSummary$225707 = -164				; size = 28
_eTechReveal$225694 = -136				; size = 4
_pResourceInfo$225692 = -132				; size = 4
_pLoopPlot$225689 = -128				; size = 4
_eResource$225690 = -124				; size = 4
_iPlotLoop$225685 = -120				; size = 4
_kLoopPlayer$225677 = -116				; size = 4
_eLoopPlayer$225675 = -112				; size = 4
_iI$225671 = -108					; size = 4
_bIsActiveTeam$225683 = -101				; size = 1
_eNotificationType$225682 = -100			; size = 4
_iNumPlots$225684 = -96					; size = 4
_pLoopCity$225669 = -92					; size = 4
_iLoop$225670 = -88					; size = 4
_kLoopPlayer$225663 = -84				; size = 4
_eLoopPlayer$225661 = -80				; size = 4
_iI$225657 = -76					; size = 4
_iScoreChange$225654 = -72				; size = 4
_kResearchingPlayer$225648 = -68			; size = 4
_strBuffer$ = -64					; size = 28
__$ArrayPad$ = -36					; size = 4
_pkTechInfo$ = -32					; size = 4
_pCapitalCity$ = -28					; size = 4
_pCity$ = -24						; size = 4
_bFirstResource$ = -17					; size = 1
_eFreeUnit$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_eIndex$ = 8						; size = 4
_bNewValue$ = 12					; size = 1
_ePlayer$ = 16						; size = 4
_bFirst$ = 20						; size = 1
_bAnnounce$ = 24					; size = 1
?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z PROC ; CvTeam::setHasTech, COMDAT
; _this$ = ecx

; 5414 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 2200				; 00000898H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 5415 : 	CvCity* pCapitalCity;
; 5416 : 	CvCity* pCity;
; 5417 : 	CvString strBuffer;

	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5418 : 	UnitTypes eFreeUnit;
; 5419 : 	bool bFirstResource;
; 5420 : 	
; 5421 : 	if(eIndex == NO_TECH)

	cmp	DWORD PTR _eIndex$[ebp], -1
	jne	SHORT $LN182@setHasTech

; 5422 : 	{
; 5423 : 		return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	$LN183@setHasTech
$LN182@setHasTech:

; 5424 : 	}
; 5425 : 
; 5426 : 	CvTechEntry* pkTechInfo = GC.getTechInfo(eIndex);

	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo
	mov	DWORD PTR _pkTechInfo$[ebp], eax

; 5427 : 	if(pkTechInfo == NULL)

	cmp	DWORD PTR _pkTechInfo$[ebp], 0
	jne	SHORT $LN181@setHasTech

; 5428 : 	{
; 5429 : 		return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	$LN183@setHasTech
$LN181@setHasTech:

; 5430 : 	}
; 5431 : 
; 5432 : 	if(ePlayer == NO_PLAYER)

	cmp	DWORD PTR _ePlayer$[ebp], -1
	jne	SHORT $LN180@setHasTech

; 5433 : 	{
; 5434 : 		ePlayer = getLeaderID();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	mov	DWORD PTR _ePlayer$[ebp], eax
$LN180@setHasTech:

; 5435 : 	}
; 5436 : 
; 5437 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 5438 : 	CvAssertMsg(eIndex < GC.getNumTechInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 5439 : 	CvAssertMsg(ePlayer >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 5440 : 	CvAssertMsg(ePlayer < MAX_PLAYERS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 5441 : 
; 5442 : 	if(ePlayer == NO_PLAYER)

	cmp	DWORD PTR _ePlayer$[ebp], -1
	jne	SHORT $LN179@setHasTech

; 5443 : 	{
; 5444 : 		return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	$LN183@setHasTech
$LN179@setHasTech:

; 5445 : 	}
; 5446 : 
; 5447 : 	if(GetTeamTechs()->HasTech(eIndex) != bNewValue)

	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	edx, al
	movzx	eax, BYTE PTR _bNewValue$[ebp]
	cmp	edx, eax
	je	$LN178@setHasTech

; 5448 : 	{
; 5449 : 		CvPlayerAI& kResearchingPlayer = GET_PLAYER(ePlayer);

	mov	ecx, DWORD PTR _ePlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kResearchingPlayer$225648[ebp], ecx

; 5450 : 
; 5451 : 		if(	GC.getGame().getActivePlayer() == ePlayer &&
; 5452 : 			strcmp(pkTechInfo->GetType(), "TECH_SATELLITES") == 0 &&
; 5453 : 			strcmp(kResearchingPlayer.getCivilizationTypeKey(), "CIVILIZATION_HUNS") == 0 &&
; 5454 : 			strcmp(GC.getMap().getWorldInfo().GetType(), "WORLDSIZE_HUGE") == 0)

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T236950[ebp], edx
	mov	ecx, DWORD PTR $T236950[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	eax, DWORD PTR _ePlayer$[ebp]
	jne	$LN177@setHasTech
	mov	DWORD PTR tv2412[ebp], OFFSET ??_C@_0BA@LBHEJNAN@TECH_SATELLITES?$AA@
	mov	ecx, DWORD PTR _pkTechInfo$[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR tv2411[ebp], eax
$LL635@setHasTech:
	mov	eax, DWORD PTR tv2411[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv2415[ebp], cl
	mov	edx, DWORD PTR tv2412[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN636@setHasTech
	cmp	BYTE PTR tv2415[ebp], 0
	je	SHORT $LN637@setHasTech
	mov	eax, DWORD PTR tv2411[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv2422[ebp], cl
	mov	edx, DWORD PTR tv2412[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN636@setHasTech
	add	DWORD PTR tv2411[ebp], 2
	add	DWORD PTR tv2412[ebp], 2
	cmp	BYTE PTR tv2422[ebp], 0
	jne	SHORT $LL635@setHasTech
$LN637@setHasTech:
	mov	DWORD PTR tv2427[ebp], 0
	jmp	SHORT $LN638@setHasTech
$LN636@setHasTech:
	sbb	eax, eax
	sbb	eax, -1
	mov	DWORD PTR tv2427[ebp], eax
$LN638@setHasTech:
	mov	ecx, DWORD PTR tv2427[ebp]
	mov	DWORD PTR tv132[ebp], ecx
	cmp	DWORD PTR tv132[ebp], 0
	jne	$LN177@setHasTech
	mov	DWORD PTR tv2434[ebp], OFFSET ??_C@_0BC@OHNNINLK@CIVILIZATION_HUNS?$AA@
	mov	ecx, DWORD PTR _kResearchingPlayer$225648[ebp]
	call	?getCivilizationTypeKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationTypeKey
	mov	DWORD PTR tv2433[ebp], eax
$LL639@setHasTech:
	mov	edx, DWORD PTR tv2433[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv2437[ebp], al
	mov	ecx, DWORD PTR tv2434[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN640@setHasTech
	cmp	BYTE PTR tv2437[ebp], 0
	je	SHORT $LN641@setHasTech
	mov	edx, DWORD PTR tv2433[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv2444[ebp], al
	mov	ecx, DWORD PTR tv2434[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN640@setHasTech
	add	DWORD PTR tv2433[ebp], 2
	add	DWORD PTR tv2434[ebp], 2
	cmp	BYTE PTR tv2444[ebp], 0
	jne	SHORT $LL639@setHasTech
$LN641@setHasTech:
	mov	DWORD PTR tv2449[ebp], 0
	jmp	SHORT $LN642@setHasTech
$LN640@setHasTech:
	sbb	edx, edx
	sbb	edx, -1
	mov	DWORD PTR tv2449[ebp], edx
$LN642@setHasTech:
	mov	eax, DWORD PTR tv2449[ebp]
	mov	DWORD PTR tv143[ebp], eax
	cmp	DWORD PTR tv143[ebp], 0
	jne	$LN177@setHasTech
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T236957[ebp], ecx
	mov	ecx, DWORD PTR $T236957[ebp]
	call	?getWorldInfo@CvMap@@QBEABVCvWorldInfo@@XZ ; CvMap::getWorldInfo
	mov	DWORD PTR $T236961[ebp], eax
	mov	DWORD PTR tv2459[ebp], OFFSET ??_C@_0P@HDCDANOJ@WORLDSIZE_HUGE?$AA@
	mov	ecx, DWORD PTR $T236961[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR tv2458[ebp], eax
$LL643@setHasTech:
	mov	edx, DWORD PTR tv2458[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv2462[ebp], al
	mov	ecx, DWORD PTR tv2459[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN644@setHasTech
	cmp	BYTE PTR tv2462[ebp], 0
	je	SHORT $LN645@setHasTech
	mov	edx, DWORD PTR tv2458[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv2469[ebp], al
	mov	ecx, DWORD PTR tv2459[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN644@setHasTech
	add	DWORD PTR tv2458[ebp], 2
	add	DWORD PTR tv2459[ebp], 2
	cmp	BYTE PTR tv2469[ebp], 0
	jne	SHORT $LL643@setHasTech
$LN645@setHasTech:
	mov	DWORD PTR tv2474[ebp], 0
	jmp	SHORT $LN646@setHasTech
$LN644@setHasTech:
	sbb	edx, edx
	sbb	edx, -1
	mov	DWORD PTR tv2474[ebp], edx
$LN646@setHasTech:
	mov	eax, DWORD PTR tv2474[ebp]
	mov	DWORD PTR tv158[ebp], eax
	cmp	DWORD PTR tv158[ebp], 0
	jne	SHORT $LN177@setHasTech

; 5455 : 		{
; 5456 : 			gDLL->UnlockAchievement(ACHIEVEMENT_XP1_30);

	mov	ecx, DWORD PTR $T236965[ebp]
	mov	DWORD PTR tv167[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv167[ebp], edx
	push	220					; 000000dcH
	mov	eax, DWORD PTR tv167[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv167[ebp]
	mov	eax, DWORD PTR [edx+828]
	call	eax
$LN177@setHasTech:

; 5457 : 		}
; 5458 : 
; 5459 : 		if(pkTechInfo->IsRepeat())

	mov	ecx, DWORD PTR _pkTechInfo$[ebp]
	call	?IsRepeat@CvTechEntry@@QBE_NXZ		; CvTechEntry::IsRepeat
	movzx	ecx, al
	test	ecx, ecx
	je	$LN176@setHasTech

; 5460 : 		{
; 5461 : 			GetTeamTechs()->IncrementTechCount(eIndex);

	mov	edx, DWORD PTR _eIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?IncrementTechCount@CvTeamTechs@@QAEXW4TechTypes@@@Z ; CvTeamTechs::IncrementTechCount

; 5462 : 
; 5463 : 			GetTeamTechs()->SetResearchProgress(eIndex, 0, ePlayer);

	mov	eax, DWORD PTR _ePlayer$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?SetResearchProgress@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z ; CvTeamTechs::SetResearchProgress

; 5464 : 
; 5465 : 			// Repeating techs are good for score!
; 5466 : 			int iScoreChange = /*10*/ GC.getSCORE_FUTURE_TECH_MULTIPLIER();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7764
	mov	DWORD PTR _iScoreChange$225654[ebp], edx

; 5467 : #ifdef NQM_OPTIONAL_SCORING_TWEAKS
; 5468 : 			if (GC.getGame().isOption("GAMEOPTION_TWEAKED_SCORING"))

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T236972[ebp], eax
	push	OFFSET ??_C@_0BL@KBKANIAP@GAMEOPTION_TWEAKED_SCORING?$AA@
	mov	ecx, DWORD PTR $T236972[ebp]
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN175@setHasTech

; 5469 : 				iScoreChange = GC.getNEW_SCORE_FUTURE_TECH_MULTIPLIER();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1792
	mov	DWORD PTR _iScoreChange$225654[ebp], edx
$LN175@setHasTech:

; 5470 : #endif
; 5471 : 			for(int iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$225657[ebp], 0
	jmp	SHORT $LN174@setHasTech
$LN173@setHasTech:
	mov	eax, DWORD PTR _iI$225657[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$225657[ebp], eax
$LN174@setHasTech:
	cmp	DWORD PTR _iI$225657[ebp], 64		; 00000040H
	jge	SHORT $LN172@setHasTech

; 5472 : 			{
; 5473 : 				const PlayerTypes eLoopPlayer = static_cast<PlayerTypes>(iI);

	mov	ecx, DWORD PTR _iI$225657[ebp]
	mov	DWORD PTR _eLoopPlayer$225661[ebp], ecx

; 5474 : 				CvPlayerAI& kLoopPlayer = GET_PLAYER(eLoopPlayer);

	mov	edx, DWORD PTR _eLoopPlayer$225661[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kLoopPlayer$225663[ebp], edx

; 5475 : 				if(kLoopPlayer.isAlive() && kLoopPlayer.getTeam() == GetID())

	mov	eax, DWORD PTR _kLoopPlayer$225663[ebp]
	mov	cl, BYTE PTR [eax+2256]
	mov	BYTE PTR $T236987[ebp], cl
	movzx	edx, BYTE PTR $T236987[ebp]
	test	edx, edx
	je	SHORT $LN171@setHasTech
	mov	eax, DWORD PTR _kLoopPlayer$225663[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T236996[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T236996[ebp], eax
	jne	SHORT $LN171@setHasTech

; 5476 : 				{
; 5477 : 					kLoopPlayer.ChangeScoreFromFutureTech(iScoreChange);

	mov	edx, DWORD PTR _iScoreChange$225654[ebp]
	push	edx
	mov	ecx, DWORD PTR _kLoopPlayer$225663[ebp]
	call	?ChangeScoreFromFutureTech@CvPlayer@@QAEXH@Z ; CvPlayer::ChangeScoreFromFutureTech
$LN171@setHasTech:

; 5478 : 				}
; 5479 : 			}

	jmp	SHORT $LN173@setHasTech
$LN172@setHasTech:

; 5480 : 
; 5481 : 			// report event to Python
; 5482 : 			////gDLL->getEventReporterIFace()->techAcquired(eIndex, GetID(), ePlayer, bAnnounce && 1 == GetTeamTechs()->GetTechCount(eIndex));
; 5483 : 
; 5484 : 			if(1 == GetTeamTechs()->GetTechCount(eIndex))

	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?GetTechCount@CvTeamTechs@@QBEHW4TechTypes@@@Z ; CvTeamTechs::GetTechCount
	cmp	eax, 1
	jne	SHORT $LN170@setHasTech

; 5485 : 			{
; 5486 : 				if(bAnnounce)

	movzx	ecx, BYTE PTR _bAnnounce$[ebp]
	test	ecx, ecx
	je	SHORT $LN170@setHasTech

; 5487 : 				{
; 5488 : 					if(GC.getGame().isFinalInitialized())

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237000[ebp], edx
	mov	ecx, DWORD PTR $T237000[ebp]
	call	?isFinalInitialized@CvGame@@QBE_NXZ	; CvGame::isFinalInitialized
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN170@setHasTech

; 5489 : 					{
; 5490 : 						announceTechToPlayers(eIndex);

	push	0
	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?announceTechToPlayers@CvTeam@@IAEXW4TechTypes@@_N@Z ; CvTeam::announceTechToPlayers
$LN170@setHasTech:

; 5491 : 					}
; 5492 : 				}
; 5493 : 			}
; 5494 : 		}
; 5495 : 		else

	jmp	$LN167@setHasTech
$LN176@setHasTech:

; 5496 : 		{
; 5497 : 			GetTeamTechs()->SetHasTech(eIndex, bNewValue);

	movzx	edx, BYTE PTR _bNewValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?SetHasTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z ; CvTeamTechs::SetHasTech

; 5498 : 
; 5499 : 			// Tech progress affects city strength, so update
; 5500 : 			CvCity* pLoopCity;
; 5501 : 			int iLoop;
; 5502 : 
; 5503 : 			for(int iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$225671[ebp], 0
	jmp	SHORT $LN166@setHasTech
$LN165@setHasTech:
	mov	ecx, DWORD PTR _iI$225671[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$225671[ebp], ecx
$LN166@setHasTech:
	cmp	DWORD PTR _iI$225671[ebp], 64		; 00000040H
	jge	$LN164@setHasTech

; 5504 : 			{
; 5505 : 				const PlayerTypes eLoopPlayer = static_cast<PlayerTypes>(iI);

	mov	edx, DWORD PTR _iI$225671[ebp]
	mov	DWORD PTR _eLoopPlayer$225675[ebp], edx

; 5506 : 				CvPlayerAI& kLoopPlayer = GET_PLAYER(eLoopPlayer);

	mov	eax, DWORD PTR _eLoopPlayer$225675[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kLoopPlayer$225677[ebp], eax

; 5507 : 				if(kLoopPlayer.isAlive() && kLoopPlayer.getTeam() == GetID())

	mov	ecx, DWORD PTR _kLoopPlayer$225677[ebp]
	mov	dl, BYTE PTR [ecx+2256]
	mov	BYTE PTR $T237012[ebp], dl
	movzx	eax, BYTE PTR $T237012[ebp]
	test	eax, eax
	je	SHORT $LN163@setHasTech
	mov	ecx, DWORD PTR _kLoopPlayer$225677[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T237021[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T237021[ebp], eax
	jne	SHORT $LN163@setHasTech

; 5508 : 				{
; 5509 : 					for(pLoopCity = kLoopPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kLoopPlayer.nextCity(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$225670[ebp]
	push	eax
	mov	ecx, DWORD PTR _kLoopPlayer$225677[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$225669[ebp], eax
	jmp	SHORT $LN162@setHasTech
$LN161@setHasTech:
	push	0
	lea	ecx, DWORD PTR _iLoop$225670[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kLoopPlayer$225677[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$225669[ebp], eax
$LN162@setHasTech:
	cmp	DWORD PTR _pLoopCity$225669[ebp], 0
	je	SHORT $LN163@setHasTech

; 5510 : 					{
; 5511 : 						pLoopCity->updateStrengthValue();

	mov	ecx, DWORD PTR _pLoopCity$225669[ebp]
	call	?updateStrengthValue@CvCity@@QAEXXZ	; CvCity::updateStrengthValue

; 5512 : 					}

	jmp	SHORT $LN161@setHasTech
$LN163@setHasTech:

; 5513 : 				}
; 5514 : 			}

	jmp	$LN165@setHasTech
$LN164@setHasTech:

; 5515 : 
; 5516 : 			NotificationTypes eNotificationType = NO_NOTIFICATION_TYPE;

	mov	DWORD PTR _eNotificationType$225682[ebp], -1

; 5517 : 
; 5518 : 			const bool bIsActiveTeam = (GetID() == GC.getGame().getActiveTeam());

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237025[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	mov	esi, eax
	mov	ecx, DWORD PTR $T237025[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	esi, eax
	sete	al
	mov	BYTE PTR _bIsActiveTeam$225683[ebp], al

; 5519 : 			const int iNumPlots = GC.getMap().numPlots();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T237029[ebp], ecx
	mov	edx, DWORD PTR $T237029[ebp]
	mov	eax, DWORD PTR [edx+4028]
	mov	DWORD PTR _iNumPlots$225684[ebp], eax

; 5520 : 			for(int iPlotLoop = 0; iPlotLoop < iNumPlots; iPlotLoop++)

	mov	DWORD PTR _iPlotLoop$225685[ebp], 0
	jmp	SHORT $LN159@setHasTech
$LN158@setHasTech:
	mov	ecx, DWORD PTR _iPlotLoop$225685[ebp]
	add	ecx, 1
	mov	DWORD PTR _iPlotLoop$225685[ebp], ecx
$LN159@setHasTech:
	mov	edx, DWORD PTR _iPlotLoop$225685[ebp]
	cmp	edx, DWORD PTR _iNumPlots$225684[ebp]
	jge	$LN167@setHasTech

; 5521 : 			{
; 5522 : 				CvPlot* pLoopPlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T237036[ebp], eax
	mov	ecx, DWORD PTR _iPlotLoop$225685[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T237036[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR _pLoopPlot$225689[ebp], ecx

; 5523 : 
; 5524 : 				const ResourceTypes eResource = pLoopPlot->getResourceType();

	push	-1
	mov	ecx, DWORD PTR _pLoopPlot$225689[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _eResource$225690[ebp], eax

; 5525 : 				if(eResource != NO_RESOURCE)

	cmp	DWORD PTR _eResource$225690[ebp], -1
	je	$LN156@setHasTech

; 5526 : 				{
; 5527 : 					CvResourceInfo* pResourceInfo = GC.getResourceInfo(eResource);

	mov	eax, DWORD PTR _eResource$225690[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	DWORD PTR _pResourceInfo$225692[ebp], eax

; 5528 : 					CvAssert(pResourceInfo);
; 5529 : 
; 5530 : 					if(bNewValue)

	movzx	ecx, BYTE PTR _bNewValue$[ebp]
	test	ecx, ecx
	je	$LN307@setHasTech

; 5531 : 					{
; 5532 : 						const TechTypes eTechReveal = static_cast<TechTypes>(pResourceInfo->getTechReveal());

	mov	ecx, DWORD PTR _pResourceInfo$225692[ebp]
	call	?getTechReveal@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getTechReveal
	mov	DWORD PTR _eTechReveal$225694[ebp], eax

; 5533 : 						// Resource Reveal
; 5534 : 						if(eTechReveal == eIndex)

	mov	edx, DWORD PTR _eTechReveal$225694[ebp]
	cmp	edx, DWORD PTR _eIndex$[ebp]
	jne	$LN307@setHasTech

; 5535 : 						{
; 5536 : 							// update the resources
; 5537 : 							if(pLoopPlot->isRevealed(m_eID))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T237050[ebp], ecx
	mov	edx, DWORD PTR $T237050[ebp]
	shr	edx, 5
	mov	DWORD PTR _uiOffset$237048[ebp], edx
	mov	eax, DWORD PTR _uiOffset$237048[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR $T237050[ebp]
	sub	ecx, eax
	mov	edx, 1
	shl	edx, cl
	mov	eax, DWORD PTR _uiOffset$237048[ebp]
	mov	ecx, DWORD PTR _pLoopPlot$225689[ebp]
	and	edx, DWORD PTR [ecx+eax*4+8]
	setne	dl
	movzx	eax, dl
	test	eax, eax
	je	$LN307@setHasTech

; 5538 : 							{
; 5539 : 								if(pLoopPlot->getResourceType(m_eID) != NO_RESOURCE)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _pLoopPlot$225689[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	cmp	eax, -1
	je	$LN307@setHasTech

; 5540 : 								{
; 5541 : 									// Create resource link
; 5542 : 									if(pLoopPlot->isOwned())

	mov	ecx, DWORD PTR _pLoopPlot$225689[ebp]
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN151@setHasTech

; 5543 : 										pLoopPlot->DoFindCityToLinkResourceTo();

	push	0
	mov	ecx, DWORD PTR _pLoopPlot$225689[ebp]
	call	?DoFindCityToLinkResourceTo@CvPlot@@QAEXPAVCvCity@@@Z ; CvPlot::DoFindCityToLinkResourceTo
$LN151@setHasTech:

; 5544 : 
; 5545 : 									// Only update for active team
; 5546 : 									if(bIsActiveTeam)

	movzx	ecx, BYTE PTR _bIsActiveTeam$225683[ebp]
	test	ecx, ecx
	je	$LN307@setHasTech

; 5547 : 									{
; 5548 : 										// If we've force revealed the resource for this team, then don't send another event
; 5549 : 										if(!pLoopPlot->IsResourceForceReveal(GetID()))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	ecx, DWORD PTR _pLoopPlot$225689[ebp]
	call	?IsResourceForceReveal@CvPlot@@QBE_NW4TeamTypes@@@Z ; CvPlot::IsResourceForceReveal
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN149@setHasTech

; 5550 : 										{
; 5551 : 											pLoopPlot->setLayoutDirty(true);

	push	1
	mov	ecx, DWORD PTR _pLoopPlot$225689[ebp]
	call	?setLayoutDirty@CvPlot@@QAEX_N@Z	; CvPlot::setLayoutDirty
$LN149@setHasTech:

; 5552 : 										}
; 5553 : 
; 5554 : 										// Notify the player that owns this Plot
; 5555 : 										if(pLoopPlot->getOwner() == GC.getGame().getActivePlayer() && pLoopPlot->getTeam() == GetID())

	mov	eax, DWORD PTR _pLoopPlot$225689[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR $T237054[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237058[ebp], edx
	mov	ecx, DWORD PTR $T237058[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	DWORD PTR $T237054[ebp], eax
	jne	$LN307@setHasTech
	mov	eax, DWORD PTR _pLoopPlot$225689[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR _playerID$237069[ebp], ecx
	cmp	DWORD PTR _playerID$237069[ebp], -1
	je	SHORT $LN274@setHasTech
	mov	edx, DWORD PTR _playerID$237069[ebp]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T237075[ebp], eax
	jmp	SHORT $LN275@setHasTech
	jmp	SHORT $LN275@setHasTech
$LN274@setHasTech:
	mov	DWORD PTR $T237075[ebp], -1
$LN275@setHasTech:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T237075[ebp], eax
	jne	$LN307@setHasTech

; 5556 : 										{
; 5557 : 											if(!CvPreGame::loadWBScenario() || GC.getGame().getGameTurn() > 0)

	call	?loadWBScenario@CvPreGame@@YA_NXZ	; CvPreGame::loadWBScenario
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN146@setHasTech
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237079[ebp], ecx
	mov	ecx, DWORD PTR $T237079[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	test	eax, eax
	jle	$LN307@setHasTech
$LN146@setHasTech:

; 5558 : 											{
; 5559 : 												strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_FOUND_RESOURCE", pResourceInfo->GetTextKey());

	mov	ecx, DWORD PTR _pResourceInfo$225692[ebp]
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	push	eax
	push	OFFSET ??_C@_0CE@PCNACIPL@TXT_KEY_NOTIFICATION_FOUND_RESOU@
	lea	edx, DWORD PTR $T236886[ebp]
	push	edx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv1985[ebp], eax
	mov	eax, DWORD PTR tv1985[ebp]
	mov	DWORD PTR $T237083[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR $T237083[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T236886[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5560 : 									
; 5561 : 												CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_FOUND_RESOURCE", pResourceInfo->GetTextKey());

	mov	ecx, DWORD PTR _pResourceInfo$225692[ebp]
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	push	eax
	push	OFFSET ??_C@_0CM@KJCPOICM@TXT_KEY_NOTIFICATION_SUMMARY_FOU@
	lea	edx, DWORD PTR _strSummary$225707[ebp]
	push	edx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 5562 : 
; 5563 : 												switch(pResourceInfo->getResourceUsage())

	mov	ecx, DWORD PTR _pResourceInfo$225692[ebp]
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	mov	DWORD PTR tv390[ebp], eax
	cmp	DWORD PTR tv390[ebp], 0
	je	SHORT $LN141@setHasTech
	cmp	DWORD PTR tv390[ebp], 1
	je	SHORT $LN142@setHasTech
	cmp	DWORD PTR tv390[ebp], 2
	je	SHORT $LN143@setHasTech
	jmp	SHORT $LN144@setHasTech
$LN143@setHasTech:

; 5564 : 												{
; 5565 : 												case RESOURCEUSAGE_LUXURY:
; 5566 : 													eNotificationType = NOTIFICATION_DISCOVERED_LUXURY_RESOURCE;

	mov	DWORD PTR _eNotificationType$225682[ebp], -1226075946 ; b6eb90d6H

; 5567 : 													break;

	jmp	SHORT $LN144@setHasTech
$LN142@setHasTech:

; 5568 : 												case RESOURCEUSAGE_STRATEGIC:
; 5569 : 													eNotificationType = NOTIFICATION_DISCOVERED_STRATEGIC_RESOURCE;

	mov	DWORD PTR _eNotificationType$225682[ebp], 2094204588 ; 7cd306acH

; 5570 : 													break;

	jmp	SHORT $LN144@setHasTech
$LN141@setHasTech:

; 5571 : 												case RESOURCEUSAGE_BONUS:
; 5572 : 													eNotificationType = NOTIFICATION_DISCOVERED_BONUS_RESOURCE;

	mov	DWORD PTR _eNotificationType$225682[ebp], 2117152609 ; 7e312f61H
$LN144@setHasTech:

; 5573 : 													break;
; 5574 : 												}
; 5575 : 
; 5576 : 												CvNotifications* pNotifications = GET_PLAYER(pLoopPlot->getOwner()).GetNotifications();

	mov	eax, DWORD PTR _pLoopPlot$225689[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR $T237091[ebp], ecx
	mov	edx, DWORD PTR $T237091[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T237095[ebp], edx
	mov	ecx, DWORD PTR $T237095[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotifications$225717[ebp], eax

; 5577 : 												if(pNotifications)

	cmp	DWORD PTR _pNotifications$225717[ebp], 0
	je	SHORT $LN140@setHasTech

; 5578 : 												{
; 5579 : 													pNotifications->Add(eNotificationType, strBuffer, strSummary, pLoopPlot->getX(), pLoopPlot->getY(), eResource);

	mov	eax, DWORD PTR _pLoopPlot$225689[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T237099[ebp], ecx
	mov	edx, DWORD PTR _pLoopPlot$225689[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T237103[ebp], eax
	lea	ecx, DWORD PTR _strSummary$225707[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T237107[ebp], eax
	push	-1
	mov	ecx, DWORD PTR _eResource$225690[ebp]
	push	ecx
	mov	edx, DWORD PTR $T237099[ebp]
	push	edx
	mov	eax, DWORD PTR $T237103[ebp]
	push	eax
	mov	ecx, DWORD PTR $T237107[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	edx, DWORD PTR _eNotificationType$225682[ebp]
	push	edx
	mov	ecx, DWORD PTR _pNotifications$225717[ebp]
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN140@setHasTech:

; 5580 : 												}
; 5581 : 											}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strSummary$225707[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5582 : 										}
; 5583 : 									}
; 5584 : 								}
; 5585 : 							}
; 5586 : 						}
; 5587 : 					}
; 5588 : 					// Resource Connection
; 5589 : 					if(pLoopPlot->getTeam() == GetID())

$LN307@setHasTech:
	mov	eax, DWORD PTR _pLoopPlot$225689[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR _playerID$237123[ebp], ecx
	cmp	DWORD PTR _playerID$237123[ebp], -1
	je	SHORT $LN304@setHasTech
	mov	edx, DWORD PTR _playerID$237123[ebp]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T237131[ebp], eax
	jmp	SHORT $LN305@setHasTech
	jmp	SHORT $LN305@setHasTech
$LN304@setHasTech:
	mov	DWORD PTR $T237131[ebp], -1
$LN305@setHasTech:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T237131[ebp], eax
	jne	$LN156@setHasTech

; 5590 : 					{
; 5591 : 						if(pResourceInfo->getTechCityTrade() == eIndex)

	mov	ecx, DWORD PTR _pResourceInfo$225692[ebp]
	call	?getTechCityTrade@CvResourceInfo@@QBEHXZ ; CvResourceInfo::getTechCityTrade
	cmp	eax, DWORD PTR _eIndex$[ebp]
	jne	$LN156@setHasTech

; 5592 : 						{
; 5593 : 							if(pLoopPlot->isCity() || pLoopPlot->getImprovementType() != NO_IMPROVEMENT)

	mov	ecx, DWORD PTR _pLoopPlot$225689[ebp]
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN136@setHasTech
	mov	ecx, DWORD PTR _pLoopPlot$225689[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	je	$LN156@setHasTech
$LN136@setHasTech:

; 5594 : 							{
; 5595 : 								// Appropriate Improvement on this Plot?
; 5596 : 								if(pLoopPlot->isCity() || GC.getImprovementInfo(pLoopPlot->getImprovementType())->IsImprovementResourceTrade(eResource))

	mov	ecx, DWORD PTR _pLoopPlot$225689[ebp]
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN134@setHasTech
	mov	edx, DWORD PTR _eResource$225690[ebp]
	push	edx
	mov	ecx, DWORD PTR _pLoopPlot$225689[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::IsImprovementResourceTrade
	movzx	eax, al
	test	eax, eax
	je	$LN156@setHasTech
$LN134@setHasTech:

; 5597 : 								{
; 5598 : 									for(int iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$225725[ebp], 0
	jmp	SHORT $LN133@setHasTech
$LN132@setHasTech:
	mov	ecx, DWORD PTR _iI$225725[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$225725[ebp], ecx
$LN133@setHasTech:
	cmp	DWORD PTR _iI$225725[ebp], 64		; 00000040H
	jge	$LN156@setHasTech

; 5599 : 									{
; 5600 : 										const PlayerTypes eLoopPlayer = static_cast<PlayerTypes>(iI);

	mov	edx, DWORD PTR _iI$225725[ebp]
	mov	DWORD PTR _eLoopPlayer$225729[ebp], edx

; 5601 : 										CvPlayerAI& kLoopPlayer = GET_PLAYER(eLoopPlayer);

	mov	eax, DWORD PTR _eLoopPlayer$225729[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kLoopPlayer$225731[ebp], eax

; 5602 : 										if(kLoopPlayer.isAlive() && kLoopPlayer.getTeam() == GetID() && pLoopPlot->getOwner() == eLoopPlayer)

	mov	ecx, DWORD PTR _kLoopPlayer$225731[ebp]
	mov	dl, BYTE PTR [ecx+2256]
	mov	BYTE PTR $T237153[ebp], dl
	movzx	eax, BYTE PTR $T237153[ebp]
	test	eax, eax
	je	$LN130@setHasTech
	mov	ecx, DWORD PTR _kLoopPlayer$225731[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T237162[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T237162[ebp], eax
	jne	$LN130@setHasTech
	mov	eax, DWORD PTR _pLoopPlot$225689[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	cmp	ecx, DWORD PTR _eLoopPlayer$225729[ebp]
	jne	$LN130@setHasTech

; 5603 : 										{
; 5604 : 											// We now have a new Tech
; 5605 : 											if(bNewValue)

	movzx	edx, BYTE PTR _bNewValue$[ebp]
	test	edx, edx
	je	SHORT $LN129@setHasTech

; 5606 : 											{
; 5607 : 												// slewis - added in so resources wouldn't be double counted when the minor civ researches the technology
; 5608 : 												if (!(kLoopPlayer.isMinorCiv() && pLoopPlot->IsImprovedByGiftFromMajor()))

	mov	ecx, DWORD PTR _kLoopPlayer$225731[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN127@setHasTech
	mov	ecx, DWORD PTR _pLoopPlot$225689[ebp]
	call	?IsImprovedByGiftFromMajor@CvPlot@@QBE_NXZ ; CvPlot::IsImprovedByGiftFromMajor
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN128@setHasTech
$LN127@setHasTech:

; 5609 : 												{
; 5610 : 													kLoopPlayer.changeNumResourceTotal(eResource, pLoopPlot->getNumResourceForPlayer(eLoopPlayer));

	push	0
	mov	edx, DWORD PTR _eLoopPlayer$225729[ebp]
	push	edx
	mov	ecx, DWORD PTR _pLoopPlot$225689[ebp]
	call	?getNumResourceForPlayer@CvPlot@@QBEHW4PlayerTypes@@@Z ; CvPlot::getNumResourceForPlayer
	push	eax
	mov	eax, DWORD PTR _eResource$225690[ebp]
	push	eax
	mov	ecx, DWORD PTR _kLoopPlayer$225731[ebp]
	call	?changeNumResourceTotal@CvPlayer@@QAEXW4ResourceTypes@@H_N@Z ; CvPlayer::changeNumResourceTotal
$LN128@setHasTech:

; 5611 : 												}
; 5612 : 
; 5613 : 												// Reconnect resource link
; 5614 : 												if(pLoopPlot->GetResourceLinkedCity() != NULL)

	mov	ecx, DWORD PTR _pLoopPlot$225689[ebp]
	call	?GetResourceLinkedCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::GetResourceLinkedCity
	test	eax, eax
	je	SHORT $LN126@setHasTech

; 5615 : 												{
; 5616 : 													pLoopPlot->SetResourceLinkedCityActive(true);

	push	1
	mov	ecx, DWORD PTR _pLoopPlot$225689[ebp]
	call	?SetResourceLinkedCityActive@CvPlot@@QAEX_N@Z ; CvPlot::SetResourceLinkedCityActive

; 5617 : 												}
; 5618 : 												// Create resource link
; 5619 : 												else

	jmp	SHORT $LN125@setHasTech
$LN126@setHasTech:

; 5620 : 												{
; 5621 : 													pLoopPlot->DoFindCityToLinkResourceTo();

	push	0
	mov	ecx, DWORD PTR _pLoopPlot$225689[ebp]
	call	?DoFindCityToLinkResourceTo@CvPlot@@QAEXPAVCvCity@@@Z ; CvPlot::DoFindCityToLinkResourceTo
$LN125@setHasTech:

; 5622 : 												}
; 5623 : 											}
; 5624 : 											// Removing Tech
; 5625 : 											else

	jmp	SHORT $LN130@setHasTech
$LN129@setHasTech:

; 5626 : 											{
; 5627 : 												kLoopPlayer.changeNumResourceTotal(eResource, -pLoopPlot->getNumResourceForPlayer(eLoopPlayer));

	push	0
	mov	ecx, DWORD PTR _eLoopPlayer$225729[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopPlot$225689[ebp]
	call	?getNumResourceForPlayer@CvPlot@@QBEHW4PlayerTypes@@@Z ; CvPlot::getNumResourceForPlayer
	neg	eax
	push	eax
	mov	edx, DWORD PTR _eResource$225690[ebp]
	push	edx
	mov	ecx, DWORD PTR _kLoopPlayer$225731[ebp]
	call	?changeNumResourceTotal@CvPlayer@@QAEXW4ResourceTypes@@H_N@Z ; CvPlayer::changeNumResourceTotal

; 5628 : 
; 5629 : 												// Disconnect resource link
; 5630 : 												if(pLoopPlot->GetResourceLinkedCity() != NULL)

	mov	ecx, DWORD PTR _pLoopPlot$225689[ebp]
	call	?GetResourceLinkedCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::GetResourceLinkedCity
	test	eax, eax
	je	SHORT $LN130@setHasTech

; 5631 : 													pLoopPlot->SetResourceLinkedCityActive(false);

	push	0
	mov	ecx, DWORD PTR _pLoopPlot$225689[ebp]
	call	?SetResourceLinkedCityActive@CvPlot@@QAEX_N@Z ; CvPlot::SetResourceLinkedCityActive
$LN130@setHasTech:

; 5632 : 											}
; 5633 : 										}
; 5634 : 									}

	jmp	$LN132@setHasTech
$LN156@setHasTech:

; 5635 : 								}
; 5636 : 							}
; 5637 : 						}
; 5638 : 					}
; 5639 : 				}
; 5640 : 			}

	jmp	$LN158@setHasTech
$LN167@setHasTech:

; 5641 : 		}
; 5642 : 
; 5643 : 		processTech(eIndex, ((bNewValue) ? 1 : -1));

	movzx	eax, BYTE PTR _bNewValue$[ebp]
	neg	eax
	sbb	eax, eax
	and	eax, 2
	add	eax, -1
	push	eax
	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?processTech@CvTeam@@IAEXW4TechTypes@@H@Z ; CvTeam::processTech

; 5644 : 
; 5645 : 		//Antiquity site notifications.
; 5646 : 		//Notifications for Artifacts and Hidden Artifacts have to come AFTER processTech because they may not have been spawned yet.
; 5647 : 		if(!CvPreGame::loadWBScenario() || GC.getGame().getGameTurn() > 0)

	call	?loadWBScenario@CvPreGame@@YA_NXZ	; CvPreGame::loadWBScenario
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN121@setHasTech
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237169[ebp], eax
	mov	ecx, DWORD PTR $T237169[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	test	eax, eax
	jle	$LN122@setHasTech
$LN121@setHasTech:

; 5648 : 		{
; 5649 : 			bool bTechRevealsArtifacts = false;

	mov	BYTE PTR _bTechRevealsArtifacts$225742[ebp], 0

; 5650 : 			bool bTechRevealsHiddenArtifacts = false;

	mov	BYTE PTR _bTechRevealsHiddenArtifacts$225743[ebp], 0

; 5651 : 
; 5652 : 			ResourceTypes eArtifactResource = (ResourceTypes)GC.getInfoTypeForString("RESOURCE_ARTIFACTS", true);

	push	1
	push	OFFSET ??_C@_0BD@DCOOKOLP@RESOURCE_ARTIFACTS?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eArtifactResource$225744[ebp], eax

; 5653 : 			CvResourceInfo* pArtifactResource = NULL;

	mov	DWORD PTR _pArtifactResource$225747[ebp], 0

; 5654 : 			if(eArtifactResource != NO_RESOURCE)

	cmp	DWORD PTR _eArtifactResource$225744[ebp], -1
	je	SHORT $LN120@setHasTech

; 5655 : 			{
; 5656 : 				pArtifactResource = GC.getResourceInfo(eArtifactResource);

	mov	ecx, DWORD PTR _eArtifactResource$225744[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	DWORD PTR _pArtifactResource$225747[ebp], eax

; 5657 : 				bTechRevealsArtifacts = pArtifactResource->getTechReveal() == eIndex;			

	mov	ecx, DWORD PTR _pArtifactResource$225747[ebp]
	call	?getTechReveal@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getTechReveal
	xor	edx, edx
	cmp	eax, DWORD PTR _eIndex$[ebp]
	sete	dl
	mov	BYTE PTR _bTechRevealsArtifacts$225742[ebp], dl
$LN120@setHasTech:

; 5658 : 			}
; 5659 : 
; 5660 : 			ResourceTypes eHiddenArtifactResource = (ResourceTypes)GC.getInfoTypeForString("RESOURCE_HIDDEN_ARTIFACTS", true);;

	push	1
	push	OFFSET ??_C@_0BK@GEJOKJMD@RESOURCE_HIDDEN_ARTIFACTS?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eHiddenArtifactResource$225749[ebp], eax

; 5661 : 			CvResourceInfo* pHiddenArtifactResource = NULL;

	mov	DWORD PTR _pHiddenArtifactResource$225752[ebp], 0

; 5662 : 			if(eHiddenArtifactResource != NO_RESOURCE)

	cmp	DWORD PTR _eHiddenArtifactResource$225749[ebp], -1
	je	SHORT $LN119@setHasTech

; 5663 : 			{
; 5664 : 				pHiddenArtifactResource = GC.getResourceInfo(eHiddenArtifactResource);

	mov	eax, DWORD PTR _eHiddenArtifactResource$225749[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	DWORD PTR _pHiddenArtifactResource$225752[ebp], eax

; 5665 : 				bTechRevealsHiddenArtifacts = pHiddenArtifactResource->getTechReveal() == eIndex;

	mov	ecx, DWORD PTR _pHiddenArtifactResource$225752[ebp]
	call	?getTechReveal@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getTechReveal
	xor	ecx, ecx
	cmp	eax, DWORD PTR _eIndex$[ebp]
	sete	cl
	mov	BYTE PTR _bTechRevealsHiddenArtifacts$225743[ebp], cl
$LN119@setHasTech:

; 5666 : 			}
; 5667 : 
; 5668 : 			if(bTechRevealsArtifacts | bTechRevealsHiddenArtifacts)

	movzx	edx, BYTE PTR _bTechRevealsArtifacts$225742[ebp]
	movzx	eax, BYTE PTR _bTechRevealsHiddenArtifacts$225743[ebp]
	or	edx, eax
	je	$LN122@setHasTech

; 5669 : 			{
; 5670 : 				const PlayerTypes eActivePlayer = GC.getGame().getActivePlayer();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237173[ebp], ecx
	mov	ecx, DWORD PTR $T237173[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	mov	DWORD PTR _eActivePlayer$225755[ebp], eax

; 5671 : #ifdef AUI_WARNING_FIXES
; 5672 : 				for (uint iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)
; 5673 : #else
; 5674 : 				const int iNumPlots = GC.getMap().numPlots();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T237177[ebp], edx
	mov	eax, DWORD PTR $T237177[ebp]
	mov	ecx, DWORD PTR [eax+4028]
	mov	DWORD PTR _iNumPlots$225756[ebp], ecx

; 5675 : 				for(int iPlotLoop = 0; iPlotLoop < iNumPlots; iPlotLoop++)

	mov	DWORD PTR _iPlotLoop$225757[ebp], 0
	jmp	SHORT $LN117@setHasTech
$LN116@setHasTech:
	mov	edx, DWORD PTR _iPlotLoop$225757[ebp]
	add	edx, 1
	mov	DWORD PTR _iPlotLoop$225757[ebp], edx
$LN117@setHasTech:
	mov	eax, DWORD PTR _iPlotLoop$225757[ebp]
	cmp	eax, DWORD PTR _iNumPlots$225756[ebp]
	jge	$LN122@setHasTech

; 5676 : #endif
; 5677 : 				{
; 5678 : 					CvPlot* pLoopPlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T237184[ebp], ecx
	mov	edx, DWORD PTR _iPlotLoop$225757[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T237184[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR _pLoopPlot$225761[ebp], edx

; 5679 : 
; 5680 : 					if(pLoopPlot->getOwner() == eActivePlayer && pLoopPlot->getTeam() == m_eID && pLoopPlot->isRevealed(m_eID))

	mov	ecx, DWORD PTR _pLoopPlot$225761[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	cmp	edx, DWORD PTR _eActivePlayer$225755[ebp]
	jne	$LN114@setHasTech
	mov	eax, DWORD PTR _pLoopPlot$225761[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR _playerID$237199[ebp], ecx
	cmp	DWORD PTR _playerID$237199[ebp], -1
	je	SHORT $LN348@setHasTech
	mov	edx, DWORD PTR _playerID$237199[ebp]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T237207[ebp], eax
	jmp	SHORT $LN349@setHasTech
	jmp	SHORT $LN349@setHasTech
$LN348@setHasTech:
	mov	DWORD PTR $T237207[ebp], -1
$LN349@setHasTech:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T237207[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	$LN114@setHasTech
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T237218[ebp], eax
	mov	ecx, DWORD PTR $T237218[ebp]
	shr	ecx, 5
	mov	DWORD PTR _uiOffset$237216[ebp], ecx
	mov	edx, DWORD PTR _uiOffset$237216[ebp]
	shl	edx, 5
	mov	ecx, DWORD PTR $T237218[ebp]
	sub	ecx, edx
	mov	eax, 1
	shl	eax, cl
	mov	ecx, DWORD PTR _uiOffset$237216[ebp]
	mov	edx, DWORD PTR _pLoopPlot$225761[ebp]
	and	eax, DWORD PTR [edx+ecx*4+8]
	setne	al
	movzx	ecx, al
	test	ecx, ecx
	je	$LN114@setHasTech

; 5681 : 					{
; 5682 : 						const ResourceTypes ePlotResource = pLoopPlot->getResourceType(m_eID);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _pLoopPlot$225761[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _ePlotResource$225763[ebp], eax

; 5683 : 						if( (bTechRevealsArtifacts && ePlotResource == eArtifactResource) || 
; 5684 : 							(bTechRevealsHiddenArtifacts && ePlotResource == eHiddenArtifactResource))

	movzx	ecx, BYTE PTR _bTechRevealsArtifacts$225742[ebp]
	test	ecx, ecx
	je	SHORT $LN111@setHasTech
	mov	edx, DWORD PTR _ePlotResource$225763[ebp]
	cmp	edx, DWORD PTR _eArtifactResource$225744[ebp]
	je	SHORT $LN112@setHasTech
$LN111@setHasTech:
	movzx	eax, BYTE PTR _bTechRevealsHiddenArtifacts$225743[ebp]
	test	eax, eax
	je	$LN114@setHasTech
	mov	ecx, DWORD PTR _ePlotResource$225763[ebp]
	cmp	ecx, DWORD PTR _eHiddenArtifactResource$225749[ebp]
	jne	$LN114@setHasTech
$LN112@setHasTech:

; 5685 : 						{
; 5686 : 							CvString strSummary;

	lea	ecx, DWORD PTR _strSummary$225767[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 5687 : 					//		CvString strBuffer;
; 5688 : 							ResourceUsageTypes eResourceUsage = RESOURCEUSAGE_LUXURY;

	mov	DWORD PTR _eResourceUsage$225768[ebp], 2

; 5689 : 							NotificationTypes eNotificationType = NO_NOTIFICATION_TYPE;

	mov	DWORD PTR _eNotificationType$225769[ebp], -1

; 5690 : 
; 5691 : 							if(ePlotResource == eArtifactResource)

	mov	edx, DWORD PTR _ePlotResource$225763[ebp]
	cmp	edx, DWORD PTR _eArtifactResource$225744[ebp]
	jne	$LN110@setHasTech

; 5692 : 							{
; 5693 : 								strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_FOUND_ARTIFACTS");

	push	OFFSET ??_C@_0CF@GJMAIIHL@TXT_KEY_NOTIFICATION_FOUND_ARTIF@
	lea	eax, DWORD PTR $T236887[ebp]
	push	eax
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	mov	DWORD PTR tv364[ebp], eax
	mov	ecx, DWORD PTR tv364[ebp]
	mov	DWORD PTR $T237226[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	edx, DWORD PTR $T237226[ebp]
	push	edx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T236887[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5694 : 								strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_FOUND_RESOURCE", pArtifactResource->GetTextKey());

	mov	ecx, DWORD PTR _pArtifactResource$225747[ebp]
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	push	eax
	push	OFFSET ??_C@_0CM@KJCPOICM@TXT_KEY_NOTIFICATION_SUMMARY_FOU@
	lea	eax, DWORD PTR $T236888[ebp]
	push	eax
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv1808[ebp], eax
	mov	ecx, DWORD PTR tv1808[ebp]
	mov	DWORD PTR $T237234[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	edx, DWORD PTR $T237234[ebp]
	push	edx
	lea	ecx, DWORD PTR _strSummary$225767[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T236888[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5695 : 								eResourceUsage = pArtifactResource->getResourceUsage();

	mov	ecx, DWORD PTR _pArtifactResource$225747[ebp]
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	mov	DWORD PTR _eResourceUsage$225768[ebp], eax
	jmp	$LN109@setHasTech
$LN110@setHasTech:

; 5696 : 							}
; 5697 : 							else if(ePlotResource == eHiddenArtifactResource)

	mov	eax, DWORD PTR _ePlotResource$225763[ebp]
	cmp	eax, DWORD PTR _eHiddenArtifactResource$225749[ebp]
	jne	$LN109@setHasTech

; 5698 : 							{
; 5699 : 								strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_FOUND_HIDDEN_ARTIFACTS");

	push	OFFSET ??_C@_0CM@OPMEONLG@TXT_KEY_NOTIFICATION_FOUND_HIDDE@
	lea	ecx, DWORD PTR $T236889[ebp]
	push	ecx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	mov	DWORD PTR tv66[ebp], eax
	mov	edx, DWORD PTR tv66[ebp]
	mov	DWORD PTR $T237242[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	eax, DWORD PTR $T237242[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T236889[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5700 : 								strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_FOUND_RESOURCE", pHiddenArtifactResource->GetTextKey());

	mov	ecx, DWORD PTR _pHiddenArtifactResource$225752[ebp]
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	push	eax
	push	OFFSET ??_C@_0CM@KJCPOICM@TXT_KEY_NOTIFICATION_SUMMARY_FOU@
	lea	ecx, DWORD PTR $T236890[ebp]
	push	ecx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv1735[ebp], eax
	mov	edx, DWORD PTR tv1735[ebp]
	mov	DWORD PTR $T237250[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	eax, DWORD PTR $T237250[ebp]
	push	eax
	lea	ecx, DWORD PTR _strSummary$225767[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T236890[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5701 : 								eResourceUsage = pHiddenArtifactResource->getResourceUsage();

	mov	ecx, DWORD PTR _pHiddenArtifactResource$225752[ebp]
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	mov	DWORD PTR _eResourceUsage$225768[ebp], eax
$LN109@setHasTech:

; 5702 : 							}
; 5703 : 
; 5704 : 							switch(eResourceUsage)

	mov	ecx, DWORD PTR _eResourceUsage$225768[ebp]
	mov	DWORD PTR tv688[ebp], ecx
	cmp	DWORD PTR tv688[ebp], 0
	je	SHORT $LN103@setHasTech
	cmp	DWORD PTR tv688[ebp], 1
	je	SHORT $LN104@setHasTech
	cmp	DWORD PTR tv688[ebp], 2
	je	SHORT $LN105@setHasTech
	jmp	SHORT $LN106@setHasTech
$LN105@setHasTech:

; 5705 : 							{
; 5706 : 							case RESOURCEUSAGE_LUXURY:
; 5707 : 								eNotificationType = NOTIFICATION_DISCOVERED_LUXURY_RESOURCE;

	mov	DWORD PTR _eNotificationType$225769[ebp], -1226075946 ; b6eb90d6H

; 5708 : 								break;

	jmp	SHORT $LN106@setHasTech
$LN104@setHasTech:

; 5709 : 							case RESOURCEUSAGE_STRATEGIC:
; 5710 : 								eNotificationType = NOTIFICATION_DISCOVERED_STRATEGIC_RESOURCE;

	mov	DWORD PTR _eNotificationType$225769[ebp], 2094204588 ; 7cd306acH

; 5711 : 								break;

	jmp	SHORT $LN106@setHasTech
$LN103@setHasTech:

; 5712 : 							case RESOURCEUSAGE_BONUS:
; 5713 : 								eNotificationType = NOTIFICATION_DISCOVERED_BONUS_RESOURCE;

	mov	DWORD PTR _eNotificationType$225769[ebp], 2117152609 ; 7e312f61H
$LN106@setHasTech:

; 5714 : 								break;
; 5715 : 							}
; 5716 : 
; 5717 : 							CvNotifications* pNotifications = GET_PLAYER(pLoopPlot->getOwner()).GetNotifications();

	mov	edx, DWORD PTR _pLoopPlot$225761[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR $T237258[ebp], eax
	mov	ecx, DWORD PTR $T237258[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T237262[ebp], ecx
	mov	ecx, DWORD PTR $T237262[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotifications$225786[ebp], eax

; 5718 : 							if(pNotifications)

	cmp	DWORD PTR _pNotifications$225786[ebp], 0
	je	SHORT $LN102@setHasTech

; 5719 : 							{
; 5720 : 								pNotifications->Add(eNotificationType, strBuffer, strSummary, pLoopPlot->getX(), pLoopPlot->getY(), ePlotResource);

	mov	edx, DWORD PTR _pLoopPlot$225761[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T237266[ebp], eax
	mov	ecx, DWORD PTR _pLoopPlot$225761[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T237270[ebp], edx
	lea	ecx, DWORD PTR _strSummary$225767[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T237274[ebp], eax
	push	-1
	mov	eax, DWORD PTR _ePlotResource$225763[ebp]
	push	eax
	mov	ecx, DWORD PTR $T237266[ebp]
	push	ecx
	mov	edx, DWORD PTR $T237270[ebp]
	push	edx
	mov	eax, DWORD PTR $T237274[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, DWORD PTR _eNotificationType$225769[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pNotifications$225786[ebp]
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN102@setHasTech:

; 5721 : 							}
; 5722 : 						}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strSummary$225767[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN114@setHasTech:

; 5723 : 					}
; 5724 : 				}

	jmp	$LN116@setHasTech
$LN122@setHasTech:

; 5725 : 			}
; 5726 : 
; 5727 : 		}
; 5728 : 
; 5729 : 		if(GetTeamTechs()->HasTech(eIndex))

	mov	edx, DWORD PTR _eIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	eax, al
	test	eax, eax
	je	$LN101@setHasTech

; 5730 : 		{
; 5731 : 			EraTypes eThisTechsEra = (EraTypes) pkTechInfo->GetEra();

	mov	ecx, DWORD PTR _pkTechInfo$[ebp]
	call	?GetEra@CvTechEntry@@QBEHXZ		; CvTechEntry::GetEra
	mov	DWORD PTR _eThisTechsEra$225789[ebp], eax

; 5732 : 
; 5733 : 			// Era change for this Team?
; 5734 : 			if(GetCurrentEra() < eThisTechsEra)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCurrentEra@CvTeam@@QBE?AW4EraTypes@@XZ ; CvTeam::GetCurrentEra
	cmp	eax, DWORD PTR _eThisTechsEra$225789[ebp]
	jge	SHORT $LN100@setHasTech

; 5735 : 			{
; 5736 : 				EraTypes eNewEra = (EraTypes) pkTechInfo->GetEra();

	mov	ecx, DWORD PTR _pkTechInfo$[ebp]
	call	?GetEra@CvTechEntry@@QBEHXZ		; CvTechEntry::GetEra
	mov	DWORD PTR _eNewEra$225792[ebp], eax

; 5737 : 				//int iEraChange = eNewEra - GetCurrentEra();
; 5738 : 
; 5739 : 				//int iVictoryPointChange = iEraChange * /*1*/ GC.getVICTORY_POINTS_PER_ERA();
; 5740 : 				//changeVictoryPoints(iVictoryPointChange);
; 5741 : 
; 5742 : 				//strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_ERA_VICTORY_POINTS", iVictoryPointChange);
; 5743 : 				//CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_ERA_VICTORY_POINTS");
; 5744 : 				//AddNotification(NOTIFICATION_VICTORY, strBuffer, strSummary);
; 5745 : 
; 5746 : 				SetCurrentEra(eNewEra);

	mov	ecx, DWORD PTR _eNewEra$225792[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z ; CvTeam::SetCurrentEra

; 5747 : 			}
; 5748 : 			// DON'T enter a new era with this tech
; 5749 : 			else

	jmp	$LN99@setHasTech
$LN100@setHasTech:

; 5750 : 			{
; 5751 : 				// If we have all the techs in the earlier eras, then we're in that era
; 5752 : 				bool bHasAllEarlierTechs = true;

	mov	BYTE PTR _bHasAllEarlierTechs$225795[ebp], 1

; 5753 : #ifdef AUI_WARNING_FIXES
; 5754 : 				for (uint iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)
; 5755 : #else
; 5756 : 				for(int iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)

	mov	DWORD PTR _iTechLoop$225796[ebp], 0
	jmp	SHORT $LN98@setHasTech
$LN97@setHasTech:
	mov	edx, DWORD PTR _iTechLoop$225796[ebp]
	add	edx, 1
	mov	DWORD PTR _iTechLoop$225796[ebp], edx
$LN98@setHasTech:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	cmp	DWORD PTR _iTechLoop$225796[ebp], eax
	jge	SHORT $LN96@setHasTech

; 5757 : #endif
; 5758 : 				{
; 5759 : 					const TechTypes eLoopTech = static_cast<TechTypes>(iTechLoop);

	mov	eax, DWORD PTR _iTechLoop$225796[ebp]
	mov	DWORD PTR _eLoopTech$225800[ebp], eax

; 5760 : 					CvTechEntry* pkLoopTech = GC.getTechInfo(eLoopTech);

	mov	ecx, DWORD PTR _eLoopTech$225800[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo
	mov	DWORD PTR _pkLoopTech$225802[ebp], eax

; 5761 : 					if(pkLoopTech)

	cmp	DWORD PTR _pkLoopTech$225802[ebp], 0
	je	SHORT $LN95@setHasTech

; 5762 : 					{
; 5763 : 						// Only look at techs prior to our era - there's no need to go further
; 5764 : 						if(pkLoopTech->GetEra() <= GetCurrentEra())

	mov	ecx, DWORD PTR _pkLoopTech$225802[ebp]
	call	?GetEra@CvTechEntry@@QBEHXZ		; CvTechEntry::GetEra
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCurrentEra@CvTeam@@QBE?AW4EraTypes@@XZ ; CvTeam::GetCurrentEra
	cmp	esi, eax
	jg	SHORT $LN95@setHasTech

; 5765 : 						{
; 5766 : 							if(!GetTeamTechs()->HasTech(eLoopTech))

	mov	edx, DWORD PTR _eLoopTech$225800[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN95@setHasTech

; 5767 : 							{
; 5768 : 								bHasAllEarlierTechs = false;

	mov	BYTE PTR _bHasAllEarlierTechs$225795[ebp], 0

; 5769 : 								break;

	jmp	SHORT $LN96@setHasTech
$LN95@setHasTech:

; 5770 : 							}
; 5771 : 						}
; 5772 : 					}
; 5773 : 				}

	jmp	$LN97@setHasTech
$LN96@setHasTech:

; 5774 : 
; 5775 : 				if(bHasAllEarlierTechs)

	movzx	ecx, BYTE PTR _bHasAllEarlierTechs$225795[ebp]
	test	ecx, ecx
	je	SHORT $LN99@setHasTech

; 5776 : 				{
; 5777 : #ifdef AUI_WARNING_FIXES
; 5778 : 					const uint iNextEra = static_cast<uint>(GetCurrentEra()) + 1;
; 5779 : #else
; 5780 : 					const EraTypes currentEra = GetCurrentEra();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCurrentEra@CvTeam@@QBE?AW4EraTypes@@XZ ; CvTeam::GetCurrentEra
	mov	DWORD PTR _currentEra$225807[ebp], eax

; 5781 : 					const int iNextEra = static_cast<int>(currentEra) + 1;

	mov	edx, DWORD PTR _currentEra$225807[ebp]
	add	edx, 1
	mov	DWORD PTR _iNextEra$225808[ebp], edx

; 5782 : #endif
; 5783 : 					if(iNextEra < GC.getNumEraInfos())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumEraInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumEraInfos
	cmp	DWORD PTR _iNextEra$225808[ebp], eax
	jge	SHORT $LN99@setHasTech

; 5784 : 					{
; 5785 : 						const EraTypes nextEra = static_cast<EraTypes>(iNextEra);

	mov	eax, DWORD PTR _iNextEra$225808[ebp]
	mov	DWORD PTR _nextEra$225811[ebp], eax

; 5786 : 						const CvEraInfo* pkEraInfo = GC.getEraInfo(nextEra);

	mov	ecx, DWORD PTR _nextEra$225811[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getEraInfo@CvGlobals@@QAEPAVCvEraInfo@@W4EraTypes@@@Z ; CvGlobals::getEraInfo
	mov	DWORD PTR _pkEraInfo$225813[ebp], eax

; 5787 : 						if(pkEraInfo != NULL)

	cmp	DWORD PTR _pkEraInfo$225813[ebp], 0
	je	SHORT $LN99@setHasTech

; 5788 : 						{
; 5789 : 							SetCurrentEra(nextEra);

	mov	edx, DWORD PTR _nextEra$225811[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z ; CvTeam::SetCurrentEra
$LN99@setHasTech:

; 5790 : 						}
; 5791 : 					}
; 5792 : 
; 5793 : 				}
; 5794 : 			}
; 5795 : 
; 5796 : 			if(pkTechInfo->IsMapVisible())

	mov	ecx, DWORD PTR _pkTechInfo$[ebp]
	call	?IsMapVisible@CvTechEntry@@QBE_NXZ	; CvTechEntry::IsMapVisible
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN89@setHasTech

; 5797 : 			{
; 5798 : 				GC.getMap().setRevealedPlots(GetID(), true, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T237285[ebp], ecx
	push	1
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	ecx, DWORD PTR $T237285[ebp]
	call	?setRevealedPlots@CvMap@@QAEXW4TeamTypes@@_N1@Z ; CvMap::setRevealedPlots

; 5799 : 				GC.getMap().updateDeferredFog();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T237289[ebp], edx
	mov	ecx, DWORD PTR $T237289[ebp]
	call	?updateDeferredFog@CvMap@@QAEXXZ	; CvMap::updateDeferredFog
$LN89@setHasTech:

; 5800 : 			}
; 5801 : 
; 5802 : 			DoUpdateBestRoute();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoUpdateBestRoute@CvTeam@@QAEXXZ	; CvTeam::DoUpdateBestRoute

; 5803 : 
; 5804 : 			// report event to Python, along with some other key state
; 5805 : 			//////gDLL->getEventReporterIFace()->techAcquired(eIndex, GetID(), ePlayer, bAnnounce);
; 5806 : 
; 5807 : 			bFirstResource = false;

	mov	BYTE PTR _bFirstResource$[ebp], 0

; 5808 : 
; 5809 : 			for(int iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$225816[ebp], 0
	jmp	SHORT $LN88@setHasTech
$LN87@setHasTech:
	mov	eax, DWORD PTR _iI$225816[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$225816[ebp], eax
$LN88@setHasTech:
	cmp	DWORD PTR _iI$225816[ebp], 64		; 00000040H
	jge	$LN86@setHasTech

; 5810 : 			{
; 5811 : 				const PlayerTypes eLoopPlayer = static_cast<PlayerTypes>(iI);

	mov	ecx, DWORD PTR _iI$225816[ebp]
	mov	DWORD PTR _eLoopPlayer$225820[ebp], ecx

; 5812 : 				CvPlayerAI& kPlayer = GET_PLAYER(eLoopPlayer);

	mov	edx, DWORD PTR _eLoopPlayer$225820[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$225822[ebp], edx

; 5813 : 				if(kPlayer.isAlive() && kPlayer.getTeam() == GetID())

	mov	eax, DWORD PTR _kPlayer$225822[ebp]
	mov	cl, BYTE PTR [eax+2256]
	mov	BYTE PTR $T237301[ebp], cl
	movzx	edx, BYTE PTR $T237301[ebp]
	test	edx, edx
	je	SHORT $LN85@setHasTech
	mov	eax, DWORD PTR _kPlayer$225822[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T237310[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T237310[ebp], eax
	jne	SHORT $LN85@setHasTech

; 5814 : 				{
; 5815 : 					if(kPlayer.GetPlayerTechs()->IsResearchingTech(eIndex))

	mov	edx, DWORD PTR _eIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _kPlayer$225822[ebp]
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?IsResearchingTech@CvPlayerTechs@@QBE_NW4TechTypes@@@Z ; CvPlayerTechs::IsResearchingTech
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN84@setHasTech

; 5816 : 					{
; 5817 : 						kPlayer.popResearch(eIndex);

	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kPlayer$225822[ebp]
	call	?popResearch@CvPlayer@@QAEXW4TechTypes@@@Z ; CvPlayer::popResearch
$LN84@setHasTech:

; 5818 : 					}
; 5819 : 
; 5820 : 					// notify the player they now have the tech, if they want to make immediate changes
; 5821 : 					//GET_PLAYER((PlayerTypes)iI).AI_nowHasTech(eIndex);
; 5822 : 
; 5823 : 					kPlayer.invalidateYieldRankCache();

	push	-1
	mov	ecx, DWORD PTR _kPlayer$225822[ebp]
	call	?invalidateYieldRankCache@CvPlayer@@QAEXW4YieldTypes@@@Z ; CvPlayer::invalidateYieldRankCache
$LN85@setHasTech:

; 5824 : 				}
; 5825 : 			}

	jmp	$LN87@setHasTech
$LN86@setHasTech:

; 5826 : 
; 5827 : 			if(bFirst)

	movzx	edx, BYTE PTR _bFirst$[ebp]
	test	edx, edx
	je	$LN83@setHasTech

; 5828 : 			{
; 5829 : 				if(GC.getGame().countKnownTechNumTeams(eIndex) == 1)

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237314[ebp], eax
	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T237314[ebp]
	call	?countKnownTechNumTeams@CvGame@@QAEHW4TechTypes@@@Z ; CvGame::countKnownTechNumTeams
	cmp	eax, 1
	jne	$LN83@setHasTech

; 5830 : 				{
; 5831 : 					if(pkTechInfo->GetFirstFreeUnitClass() != NO_UNITCLASS)

	mov	ecx, DWORD PTR _pkTechInfo$[ebp]
	call	?GetFirstFreeUnitClass@CvTechEntry@@QBEHXZ ; CvTechEntry::GetFirstFreeUnitClass
	cmp	eax, -1
	je	$LN81@setHasTech

; 5832 : 					{
; 5833 : 						bFirstResource = true;

	mov	BYTE PTR _bFirstResource$[ebp], 1

; 5834 : 
; 5835 : 						eFreeUnit = ((UnitTypes)(GET_PLAYER(ePlayer).getCivilizationInfo().getCivilizationUnits(GC.getTechInfo(eIndex)->GetFirstFreeUnitClass())));

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T237318[ebp], edx
	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo
	mov	ecx, eax
	call	?GetFirstFreeUnitClass@CvTechEntry@@QBEHXZ ; CvTechEntry::GetFirstFreeUnitClass
	push	eax
	mov	ecx, DWORD PTR $T237318[ebp]
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getCivilizationUnits@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationUnits
	mov	DWORD PTR _eFreeUnit$[ebp], eax

; 5836 : 
; 5837 : 						if(eFreeUnit != NULL)

	cmp	DWORD PTR _eFreeUnit$[ebp], 0
	je	SHORT $LN81@setHasTech

; 5838 : 						{
; 5839 : 							pCapitalCity = GET_PLAYER(ePlayer).getCapitalCity();

	mov	ecx, DWORD PTR _ePlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T237322[ebp], ecx
	mov	ecx, DWORD PTR $T237322[ebp]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	DWORD PTR _pCapitalCity$[ebp], eax

; 5840 : 
; 5841 : 							if(pCapitalCity != NULL)

	cmp	DWORD PTR _pCapitalCity$[ebp], 0
	je	SHORT $LN81@setHasTech

; 5842 : 							{
; 5843 : 								pCapitalCity->GetCityCitizens()->DoSpawnGreatPerson(eFreeUnit, true, false);

	push	0
	push	1
	mov	edx, DWORD PTR _eFreeUnit$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pCapitalCity$[ebp]
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?DoSpawnGreatPerson@CvCityCitizens@@QAEXW4UnitTypes@@_N1@Z ; CvCityCitizens::DoSpawnGreatPerson
$LN81@setHasTech:

; 5844 : 							}
; 5845 : 						}
; 5846 : 					}
; 5847 : 
; 5848 : 					if(pkTechInfo->GetFirstFreeTechs() > 0)

	mov	ecx, DWORD PTR _pkTechInfo$[ebp]
	call	?GetFirstFreeTechs@CvTechEntry@@QBEHXZ	; CvTechEntry::GetFirstFreeTechs
	test	eax, eax
	jle	$LN78@setHasTech

; 5849 : 					{
; 5850 : 						bFirstResource = true;

	mov	BYTE PTR _bFirstResource$[ebp], 1

; 5851 : 
; 5852 : 						if(!isHuman())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isHuman@CvTeam@@QBE_NXZ		; CvTeam::isHuman
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN77@setHasTech

; 5853 : 						{
; 5854 : 							for(int iI = 0; iI < pkTechInfo->GetFirstFreeTechs(); iI++)

	mov	DWORD PTR _iI$225833[ebp], 0
	jmp	SHORT $LN76@setHasTech
$LN75@setHasTech:
	mov	ecx, DWORD PTR _iI$225833[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$225833[ebp], ecx
$LN76@setHasTech:
	mov	ecx, DWORD PTR _pkTechInfo$[ebp]
	call	?GetFirstFreeTechs@CvTechEntry@@QBEHXZ	; CvTechEntry::GetFirstFreeTechs
	cmp	DWORD PTR _iI$225833[ebp], eax
	jge	SHORT $LN74@setHasTech

; 5855 : 							{
; 5856 : 								GET_PLAYER(ePlayer).AI_chooseFreeTech();

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR tv922[ebp], edx
	mov	eax, DWORD PTR tv922[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv922[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 5857 : 							}

	jmp	SHORT $LN75@setHasTech
$LN74@setHasTech:

; 5858 : 						}
; 5859 : 						else

	jmp	$LN73@setHasTech
$LN77@setHasTech:

; 5860 : 						{
; 5861 : 							strBuffer = GetLocalizedText("TXT_KEY_MISC_FIRST_TECH_CHOOSE_FREE", pkTechInfo->GetTextKey());

	mov	ecx, DWORD PTR _pkTechInfo$[ebp]
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	push	eax
	push	OFFSET ??_C@_0CE@BFHEGKPF@TXT_KEY_MISC_FIRST_TECH_CHOOSE_F@
	lea	ecx, DWORD PTR $T236891[ebp]
	push	ecx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv1740[ebp], eax
	mov	edx, DWORD PTR tv1740[ebp]
	mov	DWORD PTR $T237329[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	eax, DWORD PTR $T237329[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T236891[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5862 : 							GET_PLAYER(ePlayer).chooseTech(GC.getTechInfo(eIndex)->GetFirstFreeTechs(), strBuffer.GetCString());

	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T237337[ebp], eax
	mov	ecx, DWORD PTR _ePlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T237341[ebp], ecx
	push	-1
	mov	edx, DWORD PTR $T237337[ebp]
	push	edx
	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo
	mov	ecx, eax
	call	?GetFirstFreeTechs@CvTechEntry@@QBEHXZ	; CvTechEntry::GetFirstFreeTechs
	push	eax
	mov	ecx, DWORD PTR $T237341[ebp]
	call	?chooseTech@CvPlayer@@QAEXHPBDW4TechTypes@@@Z ; CvPlayer::chooseTech
$LN73@setHasTech:

; 5863 : 						}
; 5864 : 
; 5865 : 						for(int iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$225840[ebp], 0
	jmp	SHORT $LN72@setHasTech
$LN71@setHasTech:
	mov	ecx, DWORD PTR _iI$225840[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$225840[ebp], ecx
$LN72@setHasTech:
	cmp	DWORD PTR _iI$225840[ebp], 64		; 00000040H
	jge	$LN70@setHasTech

; 5866 : 						{
; 5867 : 							const PlayerTypes eLoopPlayer = static_cast<PlayerTypes>(iI);

	mov	edx, DWORD PTR _iI$225840[ebp]
	mov	DWORD PTR _eLoopPlayer$225844[ebp], edx

; 5868 : 							CvPlayerAI& kLoopPLayer = GET_PLAYER(eLoopPlayer);

	mov	eax, DWORD PTR _eLoopPlayer$225844[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kLoopPLayer$225846[ebp], eax

; 5869 : 							if(kLoopPLayer.isAlive() && GC.getGame().getActivePlayer())

	mov	ecx, DWORD PTR _kLoopPLayer$225846[ebp]
	mov	dl, BYTE PTR [ecx+2256]
	mov	BYTE PTR $T237353[ebp], dl
	movzx	eax, BYTE PTR $T237353[ebp]
	test	eax, eax
	je	$LN69@setHasTech
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237357[ebp], ecx
	mov	ecx, DWORD PTR $T237357[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	test	eax, eax
	je	$LN69@setHasTech

; 5870 : 							{
; 5871 : 								if(isHasMet(kLoopPLayer.getTeam()))

	mov	edx, DWORD PTR _kLoopPLayer$225846[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T237366[ebp], eax
	mov	ecx, DWORD PTR $T237366[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	movzx	edx, al
	test	edx, edx
	je	$LN68@setHasTech

; 5872 : 								{
; 5873 : 									strBuffer = GetLocalizedText("TXT_KEY_MISC_SOMEONE_FIRST_TO_TECH", GET_PLAYER(ePlayer).getNameKey(), pkTechInfo->GetTextKey());

	mov	ecx, DWORD PTR _pkTechInfo$[ebp]
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	mov	DWORD PTR $T236892[ebp], eax
	mov	eax, DWORD PTR _ePlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T237370[ebp], eax
	mov	ecx, DWORD PTR $T237370[ebp]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	mov	DWORD PTR $T236893[ebp], eax
	lea	ecx, DWORD PTR $T236892[ebp]
	push	ecx
	lea	edx, DWORD PTR $T236893[ebp]
	push	edx
	push	OFFSET ??_C@_0CD@JACHOIBD@TXT_KEY_MISC_SOMEONE_FIRST_TO_TE@
	lea	eax, DWORD PTR $T236894[ebp]
	push	eax
	call	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv1741[ebp], eax
	mov	ecx, DWORD PTR tv1741[ebp]
	mov	DWORD PTR $T237374[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	mov	edx, DWORD PTR $T237374[ebp]
	push	edx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T236894[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5874 : 								}
; 5875 : 								else

	jmp	SHORT $LN67@setHasTech
$LN68@setHasTech:

; 5876 : 								{
; 5877 : 									strBuffer = GetLocalizedText("TXT_KEY_MISC_UNKNOWN_FIRST_TO_TECH", GC.getTechInfo(eIndex)->GetTextKey());

	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo
	mov	ecx, eax
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	push	eax
	push	OFFSET ??_C@_0CD@HPOEABOJ@TXT_KEY_MISC_UNKNOWN_FIRST_TO_TE@
	lea	ecx, DWORD PTR $T236895[ebp]
	push	ecx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv1729[ebp], eax
	mov	edx, DWORD PTR tv1729[ebp]
	mov	DWORD PTR $T237382[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	eax, DWORD PTR $T237382[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T236895[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN67@setHasTech:

; 5878 : 								}
; 5879 : 								DLLUI->AddMessage(0, eLoopPlayer, false, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, "AS2D_FIRSTTOTECH", MESSAGE_TYPE_MAJOR_EVENT, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_HIGHLIGHT_TEXT")*/);

	mov	ecx, DWORD PTR $T237390[ebp]
	mov	DWORD PTR tv1031[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv1031[ebp], edx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T237394[ebp], eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	mov	DWORD PTR $T237398[ebp], eax
	push	0
	push	0
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR $T237394[ebp]
	push	ecx
	mov	edx, DWORD PTR $T237398[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _eLoopPlayer$225844[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR tv1031[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv1031[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN69@setHasTech:

; 5880 : 							}
; 5881 : 						}

	jmp	$LN71@setHasTech
$LN70@setHasTech:

; 5882 : 
; 5883 : 						strBuffer = GetLocalizedText("TXT_KEY_MISC_SOMEONE_FIRST_TO_TECH", GET_PLAYER(ePlayer).getName(), GC.getTechInfo(eIndex)->GetTextKey());

	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo
	mov	ecx, eax
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	mov	DWORD PTR $T236896[ebp], eax
	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T237402[ebp], edx
	mov	ecx, DWORD PTR $T237402[ebp]
	call	?getName@CvPlayer@@QBEPBDXZ		; CvPlayer::getName
	mov	DWORD PTR $T236897[ebp], eax
	lea	eax, DWORD PTR $T236896[ebp]
	push	eax
	lea	ecx, DWORD PTR $T236897[ebp]
	push	ecx
	push	OFFSET ??_C@_0CD@JACHOIBD@TXT_KEY_MISC_SOMEONE_FIRST_TO_TE@
	lea	edx, DWORD PTR $T236898[ebp]
	push	edx
	call	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv2347[ebp], eax
	mov	eax, DWORD PTR tv2347[ebp]
	mov	DWORD PTR $T237406[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	mov	ecx, DWORD PTR $T237406[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T236898[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5884 : 						GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, ePlayer, strBuffer, -1, -1);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237414[ebp], edx
	push	-1
	push	-1
	lea	eax, DWORD PTR _strBuffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ePlayer$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR $T237414[ebp]
	call	?addReplayMessage@CvGame@@QAEXW4ReplayMessageTypes@@W4PlayerTypes@@ABVCvString@@HH@Z ; CvGame::addReplayMessage
$LN78@setHasTech:

; 5885 : 					}
; 5886 : 
; 5887 : 					if(bFirstResource)

	movzx	edx, BYTE PTR _bFirstResource$[ebp]
	test	edx, edx
	je	$LN83@setHasTech

; 5888 : 					{
; 5889 : 						for(int iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$225860[ebp], 0
	jmp	SHORT $LN65@setHasTech
$LN64@setHasTech:
	mov	eax, DWORD PTR _iI$225860[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$225860[ebp], eax
$LN65@setHasTech:
	cmp	DWORD PTR _iI$225860[ebp], 64		; 00000040H
	jge	$LN83@setHasTech

; 5890 : 						{
; 5891 : 							const PlayerTypes eLoopPlayer = static_cast<PlayerTypes>(iI);

	mov	ecx, DWORD PTR _iI$225860[ebp]
	mov	DWORD PTR _eLoopPlayer$225864[ebp], ecx

; 5892 : 							CvPlayerAI& kPlayer = GET_PLAYER(eLoopPlayer);

	mov	edx, DWORD PTR _eLoopPlayer$225864[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$225866[ebp], edx

; 5893 : 							if(kPlayer.isAlive())

	mov	eax, DWORD PTR _kPlayer$225866[ebp]
	mov	cl, BYTE PTR [eax+2256]
	mov	BYTE PTR $T237426[ebp], cl
	movzx	edx, BYTE PTR $T237426[ebp]
	test	edx, edx
	je	SHORT $LN62@setHasTech

; 5894 : 							{
; 5895 : 								if(!(kPlayer.isHuman()))

	mov	ecx, DWORD PTR _kPlayer$225866[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN62@setHasTech

; 5896 : 								{
; 5897 : 									if(kPlayer.GetPlayerTechs()->IsResearchingTech(eIndex))

	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kPlayer$225866[ebp]
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?IsResearchingTech@CvPlayerTechs@@QBE_NW4TechTypes@@@Z ; CvPlayerTechs::IsResearchingTech
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN62@setHasTech

; 5898 : 									{
; 5899 : 										kPlayer.clearResearchQueue();

	mov	ecx, DWORD PTR _kPlayer$225866[ebp]
	call	?clearResearchQueue@CvPlayer@@QAEXXZ	; CvPlayer::clearResearchQueue
$LN62@setHasTech:

; 5900 : 									}
; 5901 : 								}
; 5902 : 							}
; 5903 : 						}

	jmp	$LN64@setHasTech
$LN83@setHasTech:

; 5904 : 					}
; 5905 : 				}
; 5906 : 			}
; 5907 : 
; 5908 : 			if(bAnnounce)

	movzx	eax, BYTE PTR _bAnnounce$[ebp]
	test	eax, eax
	je	$LN59@setHasTech

; 5909 : 			{
; 5910 : 				if(GC.getGame().isFinalInitialized()/* && !(gDLL->GetWorldBuilderMode())*/)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237430[ebp], ecx
	mov	ecx, DWORD PTR $T237430[ebp]
	call	?isFinalInitialized@CvGame@@QBE_NXZ	; CvGame::isFinalInitialized
	movzx	edx, al
	test	edx, edx
	je	$LN59@setHasTech

; 5911 : 				{
; 5912 : 					announceTechToPlayers(eIndex);

	push	0
	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?announceTechToPlayers@CvTeam@@IAEXW4TechTypes@@_N@Z ; CvTeam::announceTechToPlayers

; 5913 : 
; 5914 : 					// Resources discovered in a player's territory
; 5915 : #ifdef AUI_WARNING_FIXES
; 5916 : 					for (uint iI = 0; iI < GC.getMap().numPlots(); iI++)
; 5917 : #else
; 5918 : 					for(int iI = 0; iI < GC.getMap().numPlots(); iI++)

	mov	DWORD PTR _iI$225872[ebp], 0
	jmp	SHORT $LN57@setHasTech
$LN56@setHasTech:
	mov	ecx, DWORD PTR _iI$225872[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$225872[ebp], ecx
$LN57@setHasTech:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T237434[ebp], edx
	mov	eax, DWORD PTR $T237434[ebp]
	mov	ecx, DWORD PTR [eax+4028]
	mov	DWORD PTR $T237438[ebp], ecx
	mov	edx, DWORD PTR _iI$225872[ebp]
	cmp	edx, DWORD PTR $T237438[ebp]
	jge	$LN55@setHasTech

; 5919 : #endif
; 5920 : 					{
; 5921 : 						CvPlot* pLoopPlot = GC.getMap().plotByIndexUnchecked(iI);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T237442[ebp], eax
	mov	ecx, DWORD PTR _iI$225872[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T237442[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR _pLoopPlot$225876[ebp], ecx

; 5922 : 
; 5923 : 						if(pLoopPlot->getTeam() == GetID() && pLoopPlot->getOwner() == GC.getGame().getActivePlayer())

	mov	eax, DWORD PTR _pLoopPlot$225876[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR _playerID$237454[ebp], ecx
	cmp	DWORD PTR _playerID$237454[ebp], -1
	je	SHORT $LN484@setHasTech
	mov	edx, DWORD PTR _playerID$237454[ebp]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T237462[ebp], eax
	jmp	SHORT $LN485@setHasTech
	jmp	SHORT $LN485@setHasTech
$LN484@setHasTech:
	mov	DWORD PTR $T237462[ebp], -1
$LN485@setHasTech:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T237462[ebp], eax
	jne	$LN54@setHasTech
	mov	eax, DWORD PTR _pLoopPlot$225876[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR $T237466[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237470[ebp], edx
	mov	ecx, DWORD PTR $T237470[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	DWORD PTR $T237466[ebp], eax
	jne	$LN54@setHasTech

; 5924 : 						{
; 5925 : 							ResourceTypes eResource = pLoopPlot->getResourceType();

	push	-1
	mov	ecx, DWORD PTR _pLoopPlot$225876[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _eResource$225878[ebp], eax

; 5926 : 
; 5927 : 							if(eResource != NO_RESOURCE)

	cmp	DWORD PTR _eResource$225878[ebp], -1
	je	$LN54@setHasTech

; 5928 : 							{
; 5929 : 								if(GC.getResourceInfo(eResource)->getTechReveal() == eIndex && !isForceRevealedResource(eResource))

	mov	eax, DWORD PTR _eResource$225878[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getTechReveal@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getTechReveal
	cmp	eax, DWORD PTR _eIndex$[ebp]
	jne	$LN54@setHasTech
	mov	ecx, DWORD PTR _eResource$225878[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isForceRevealedResource@CvTeam@@QBE_NW4ResourceTypes@@@Z ; CvTeam::isForceRevealedResource
	movzx	edx, al
	test	edx, edx
	jne	$LN54@setHasTech

; 5930 : 								{
; 5931 : 									pCity = GC.getMap().findCity(pLoopPlot->getX(), pLoopPlot->getY(), NO_PLAYER, GetID(), false);

	mov	eax, DWORD PTR _pLoopPlot$225876[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T237474[ebp], ecx
	mov	edx, DWORD PTR _pLoopPlot$225876[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T237478[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T237482[ebp], ecx
	push	0
	push	-1
	push	-1
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	push	-1
	mov	edx, DWORD PTR $T237474[ebp]
	push	edx
	mov	eax, DWORD PTR $T237478[ebp]
	push	eax
	mov	ecx, DWORD PTR $T237482[ebp]
	call	?findCity@CvMap@@QAEPAVCvCity@@HHW4PlayerTypes@@W4TeamTypes@@_N21W4DirectionTypes@@PBV2@@Z ; CvMap::findCity
	mov	DWORD PTR _pCity$[ebp], eax

; 5932 : 
; 5933 : 									if(pCity != NULL)

	cmp	DWORD PTR _pCity$[ebp], 0
	je	$LN54@setHasTech

; 5934 : 									{
; 5935 : 										CvResourceInfo* pResourceInfo = GC.getResourceInfo(eResource);

	mov	ecx, DWORD PTR _eResource$225878[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	DWORD PTR _pResourceInfo$225882[ebp], eax

; 5936 : 
; 5937 : 										if(strcmp(pResourceInfo->GetType(), "RESOURCE_ARTIFACTS") == 0)

	mov	DWORD PTR tv2881[ebp], OFFSET ??_C@_0BD@DCOOKOLP@RESOURCE_ARTIFACTS?$AA@
	mov	ecx, DWORD PTR _pResourceInfo$225882[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR tv2880[ebp], eax
$LL647@setHasTech:
	mov	edx, DWORD PTR tv2880[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv2884[ebp], al
	mov	ecx, DWORD PTR tv2881[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN648@setHasTech
	cmp	BYTE PTR tv2884[ebp], 0
	je	SHORT $LN649@setHasTech
	mov	edx, DWORD PTR tv2880[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv2891[ebp], al
	mov	ecx, DWORD PTR tv2881[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN648@setHasTech
	add	DWORD PTR tv2880[ebp], 2
	add	DWORD PTR tv2881[ebp], 2
	cmp	BYTE PTR tv2891[ebp], 0
	jne	SHORT $LL647@setHasTech
$LN649@setHasTech:
	mov	DWORD PTR tv2896[ebp], 0
	jmp	SHORT $LN650@setHasTech
$LN648@setHasTech:
	sbb	edx, edx
	sbb	edx, -1
	mov	DWORD PTR tv2896[ebp], edx
$LN650@setHasTech:
	mov	eax, DWORD PTR tv2896[ebp]
	mov	DWORD PTR tv1204[ebp], eax
	cmp	DWORD PTR tv1204[ebp], 0
	jne	SHORT $LN508@setHasTech

; 5938 : 										{
; 5939 : 											strBuffer = GetLocalizedText("TXT_KEY_MISC_DISCOVERED_ARTIFACTS_NEAR", pCity->getNameKey());

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	push	eax
	push	OFFSET ??_C@_0CH@BOBAFPHE@TXT_KEY_MISC_DISCOVERED_ARTIFACT@
	lea	ecx, DWORD PTR $T236899[ebp]
	push	ecx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv2348[ebp], eax
	mov	edx, DWORD PTR tv2348[ebp]
	mov	DWORD PTR $T237489[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	mov	eax, DWORD PTR $T237489[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T236899[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	$LN49@setHasTech

; 5940 : 										}
; 5941 : 										else if(strcmp(pResourceInfo->GetType(), "RESOURCE_HIDDEN_ARTIFACTS") == 0)

$LN508@setHasTech:
	mov	DWORD PTR tv2910[ebp], OFFSET ??_C@_0BK@GEJOKJMD@RESOURCE_HIDDEN_ARTIFACTS?$AA@
	mov	ecx, DWORD PTR _pResourceInfo$225882[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR tv2909[ebp], eax
$LL651@setHasTech:
	mov	ecx, DWORD PTR tv2909[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv2913[ebp], dl
	mov	eax, DWORD PTR tv2910[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN652@setHasTech
	cmp	BYTE PTR tv2913[ebp], 0
	je	SHORT $LN653@setHasTech
	mov	ecx, DWORD PTR tv2909[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv2920[ebp], dl
	mov	eax, DWORD PTR tv2910[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN652@setHasTech
	add	DWORD PTR tv2909[ebp], 2
	add	DWORD PTR tv2910[ebp], 2
	cmp	BYTE PTR tv2920[ebp], 0
	jne	SHORT $LL651@setHasTech
$LN653@setHasTech:
	mov	DWORD PTR tv2925[ebp], 0
	jmp	SHORT $LN654@setHasTech
$LN652@setHasTech:
	sbb	ecx, ecx
	sbb	ecx, -1
	mov	DWORD PTR tv2925[ebp], ecx
$LN654@setHasTech:
	mov	edx, DWORD PTR tv2925[ebp]
	mov	DWORD PTR tv1225[ebp], edx
	cmp	DWORD PTR tv1225[ebp], 0
	jne	SHORT $LN48@setHasTech

; 5942 : 										{
; 5943 : 											strBuffer = GetLocalizedText("TXT_KEY_MISC_DISCOVERED_HIDDEN_ARTIFACTS_NEAR", pCity->getNameKey());

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	push	eax
	push	OFFSET ??_C@_0CO@ODOBJOOJ@TXT_KEY_MISC_DISCOVERED_HIDDEN_A@
	lea	eax, DWORD PTR $T236900[ebp]
	push	eax
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv2349[ebp], eax
	mov	ecx, DWORD PTR tv2349[ebp]
	mov	DWORD PTR $T237500[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH
	mov	edx, DWORD PTR $T237500[ebp]
	push	edx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T236900[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5944 : 										}
; 5945 : 										else

	jmp	SHORT $LN49@setHasTech
$LN48@setHasTech:

; 5946 : 										{
; 5947 : 											strBuffer = GetLocalizedText("TXT_KEY_MISC_YOU_DISCOVERED_RESOURCE", pResourceInfo->GetTextKey(), pCity->getNameKey());

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	mov	DWORD PTR $T236901[ebp], eax
	mov	ecx, DWORD PTR _pResourceInfo$225882[ebp]
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	mov	DWORD PTR $T236902[ebp], eax
	lea	eax, DWORD PTR $T236901[ebp]
	push	eax
	lea	ecx, DWORD PTR $T236902[ebp]
	push	ecx
	push	OFFSET ??_C@_0CF@IOFIPAIJ@TXT_KEY_MISC_YOU_DISCOVERED_RESO@
	lea	edx, DWORD PTR $T236903[ebp]
	push	edx
	call	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv2350[ebp], eax
	mov	eax, DWORD PTR tv2350[ebp]
	mov	DWORD PTR $T237508[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH
	mov	ecx, DWORD PTR $T237508[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T236903[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN49@setHasTech:

; 5948 : 										}
; 5949 : 
; 5950 : 										DLLUI->AddPlotMessage(0, pLoopPlot->GetPlotIndex(), pLoopPlot->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, "AS2D_DISCOVERRESOURCE", MESSAGE_TYPE_INFO, GC.getResourceInfo(eResource)->GetButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_WHITE"), pLoopPlot->getX(), pLoopPlot->getY(), true, true*/);

	mov	edx, DWORD PTR $T237516[ebp]
	mov	DWORD PTR tv1261[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv1261[ebp], eax
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T237520[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	mov	DWORD PTR $T237524[ebp], ecx
	mov	edx, DWORD PTR _pLoopPlot$225876[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR $T237528[ebp], eax
	push	0
	push	0
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR $T237520[ebp]
	push	ecx
	mov	edx, DWORD PTR $T237524[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR $T237528[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopPlot$225876[ebp]
	call	?GetPlotIndex@CvPlot@@QBEHXZ		; CvPlot::GetPlotIndex
	push	eax
	push	0
	mov	ecx, DWORD PTR tv1261[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv1261[ebp]
	mov	eax, DWORD PTR [edx+168]
	call	eax
$LN54@setHasTech:

; 5951 : 									}
; 5952 : 								}
; 5953 : 							}
; 5954 : 						}
; 5955 : 					}

	jmp	$LN56@setHasTech
$LN55@setHasTech:

; 5956 : 
; 5957 : 					// Cities demand a Resource that's been newly revealed
; 5958 : 					CvCity* pLoopCity;
; 5959 : 					int iLoop;
; 5960 : 					PlayerTypes eLoopPlayer;
; 5961 : 					ResourceTypes eResourceDemanded;
; 5962 : 
; 5963 : 					// Check all players on this team
; 5964 : 					for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	mov	DWORD PTR _iPlayerLoop$225899[ebp], 0
	jmp	SHORT $LN46@setHasTech
$LN45@setHasTech:
	mov	ecx, DWORD PTR _iPlayerLoop$225899[ebp]
	add	ecx, 1
	mov	DWORD PTR _iPlayerLoop$225899[ebp], ecx
$LN46@setHasTech:
	cmp	DWORD PTR _iPlayerLoop$225899[ebp], 22	; 00000016H
	jge	$LN59@setHasTech

; 5965 : 					{
; 5966 : 						eLoopPlayer = (PlayerTypes) iPlayerLoop;

	mov	edx, DWORD PTR _iPlayerLoop$225899[ebp]
	mov	DWORD PTR _eLoopPlayer$225897[ebp], edx

; 5967 : 
; 5968 : 						if(GET_PLAYER(eLoopPlayer).getTeam() == GetID() && eLoopPlayer == GC.getGame().getActivePlayer())

	mov	eax, DWORD PTR _eLoopPlayer$225897[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T237532[ebp], eax
	mov	ecx, DWORD PTR $T237532[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T237541[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T237541[ebp], eax
	jne	$LN43@setHasTech
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237545[ebp], eax
	mov	ecx, DWORD PTR $T237545[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	DWORD PTR _eLoopPlayer$225897[ebp], eax
	jne	$LN43@setHasTech

; 5969 : 						{
; 5970 : 							// Look at all Cities
; 5971 : 							for(pLoopCity = GET_PLAYER(eLoopPlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(eLoopPlayer).nextCity(&iLoop))

	mov	ecx, DWORD PTR _eLoopPlayer$225897[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T237549[ebp], ecx
	push	0
	lea	edx, DWORD PTR _iLoop$225896[ebp]
	push	edx
	mov	ecx, DWORD PTR $T237549[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$225895[ebp], eax
	jmp	SHORT $LN42@setHasTech
$LN41@setHasTech:
	mov	eax, DWORD PTR _eLoopPlayer$225897[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T237553[ebp], eax
	push	0
	lea	ecx, DWORD PTR _iLoop$225896[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T237553[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$225895[ebp], eax
$LN42@setHasTech:
	cmp	DWORD PTR _pLoopCity$225895[ebp], 0
	je	$LN43@setHasTech

; 5972 : 							{
; 5973 : 								eResourceDemanded = pLoopCity->GetResourceDemanded();

	push	1
	mov	ecx, DWORD PTR _pLoopCity$225895[ebp]
	call	?GetResourceDemanded@CvCity@@QBE?AW4ResourceTypes@@_N@Z ; CvCity::GetResourceDemanded
	mov	DWORD PTR _eResourceDemanded$225898[ebp], eax

; 5974 : 
; 5975 : 								if(eResourceDemanded != NO_RESOURCE)

	cmp	DWORD PTR _eResourceDemanded$225898[ebp], -1
	je	$LN39@setHasTech

; 5976 : 								{
; 5977 : 									// Resource being demanded is revealed by this Tech
; 5978 : 									if(GC.getResourceInfo(eResourceDemanded)->getTechReveal() == eIndex)

	mov	edx, DWORD PTR _eResourceDemanded$225898[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getTechReveal@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getTechReveal
	cmp	eax, DWORD PTR _eIndex$[ebp]
	jne	$LN39@setHasTech

; 5979 : 									{
; 5980 : 										strBuffer = GetLocalizedText("TXT_KEY_MISC_RESOURCE_DISCOVERED_CITY_DEMANDS", GC.getResourceInfo(eResourceDemanded)->GetTextKey(), pLoopCity->getNameKey());

	mov	ecx, DWORD PTR _pLoopCity$225895[ebp]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	mov	DWORD PTR $T236904[ebp], eax
	mov	eax, DWORD PTR _eResourceDemanded$225898[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	mov	DWORD PTR $T236905[ebp], eax
	lea	ecx, DWORD PTR $T236904[ebp]
	push	ecx
	lea	edx, DWORD PTR $T236905[ebp]
	push	edx
	push	OFFSET ??_C@_0CO@GNDPPHJN@TXT_KEY_MISC_RESOURCE_DISCOVERED@
	lea	eax, DWORD PTR $T236906[ebp]
	push	eax
	call	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv2351[ebp], eax
	mov	ecx, DWORD PTR tv2351[ebp]
	mov	DWORD PTR $T237557[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 15		; 0000000fH
	mov	edx, DWORD PTR $T237557[ebp]
	push	edx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T236906[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5981 : 										DLLUI->AddCityMessage(0, pLoopCity->GetIDInfo(), eLoopPlayer, false, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, "AS2D_DISCOVERRESOURCE", MESSAGE_TYPE_INFO, GC.getResourceInfo(eResourceDemanded)->GetButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_WHITE"), pLoopCity->getX(), pLoopCity->getY(), true, true*/);

	mov	eax, DWORD PTR $T237565[ebp]
	mov	DWORD PTR tv1394[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv1394[ebp], ecx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T237569[ebp], eax
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	mov	DWORD PTR $T237573[ebp], edx
	push	0
	push	0
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR $T237569[ebp]
	push	eax
	mov	ecx, DWORD PTR $T237573[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _eLoopPlayer$225897[ebp]
	push	edx
	lea	eax, DWORD PTR $T236907[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopCity$225895[ebp]
	call	?GetIDInfo@CvCity@@QBE?AUIDInfo@@XZ	; CvCity::GetIDInfo
	push	eax
	push	0
	mov	ecx, DWORD PTR tv1394[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv1394[ebp]
	mov	eax, DWORD PTR [edx+172]
	call	eax
$LN39@setHasTech:

; 5982 : 									}
; 5983 : 								}
; 5984 : 							}

	jmp	$LN41@setHasTech
$LN43@setHasTech:

; 5985 : 						}
; 5986 : 					}

	jmp	$LN45@setHasTech
$LN59@setHasTech:

; 5987 : 				}
; 5988 : 			}
; 5989 : 
; 5990 : 			for(int iI = 0; iI < MAX_TEAMS; iI++)

	mov	DWORD PTR _iI$225915[ebp], 0
	jmp	SHORT $LN37@setHasTech
$LN36@setHasTech:
	mov	ecx, DWORD PTR _iI$225915[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$225915[ebp], ecx
$LN37@setHasTech:
	cmp	DWORD PTR _iI$225915[ebp], 64		; 00000040H
	jge	SHORT $LN35@setHasTech

; 5991 : 			{
; 5992 : 				const TeamTypes eLoopTeam = static_cast<TeamTypes>(iI);

	mov	edx, DWORD PTR _iI$225915[ebp]
	mov	DWORD PTR _eLoopTeam$225919[ebp], edx

; 5993 : 				CvTeam& kLoopTeam = GET_TEAM(eLoopTeam);

	mov	eax, DWORD PTR _eLoopTeam$225919[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR _kLoopTeam$225921[ebp], eax

; 5994 : 				if(kLoopTeam.isAlive())

	mov	ecx, DWORD PTR _kLoopTeam$225921[ebp]
	xor	edx, edx
	cmp	DWORD PTR [ecx+12], 0
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN34@setHasTech

; 5995 : 				{
; 5996 : 					if(eLoopTeam != GetID())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR _eLoopTeam$225919[ebp], eax
	je	SHORT $LN34@setHasTech

; 5997 : 					{
; 5998 : 						kLoopTeam.updateTechShare(eIndex);

	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kLoopTeam$225921[ebp]
	call	?updateTechShare@CvTeam@@IAEXW4TechTypes@@@Z ; CvTeam::updateTechShare
$LN34@setHasTech:

; 5999 : 					}
; 6000 : 				}
; 6001 : 			}

	jmp	SHORT $LN36@setHasTech
$LN35@setHasTech:

; 6002 : 
; 6003 : 			// Cities that are owed a culture building are granted a culture building
; 6004 : 			CvCity* pLoopCity;
; 6005 : 			int iLoop;
; 6006 : 			PlayerTypes eLoopPlayer;
; 6007 : 
; 6008 : 			// Check all players on this team
; 6009 : 			for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	mov	DWORD PTR _iPlayerLoop$225927[ebp], 0
	jmp	SHORT $LN32@setHasTech
$LN31@setHasTech:
	mov	edx, DWORD PTR _iPlayerLoop$225927[ebp]
	add	edx, 1
	mov	DWORD PTR _iPlayerLoop$225927[ebp], edx
$LN32@setHasTech:
	cmp	DWORD PTR _iPlayerLoop$225927[ebp], 22	; 00000016H
	jge	$LN101@setHasTech

; 6010 : 			{
; 6011 : 				eLoopPlayer = (PlayerTypes) iPlayerLoop;

	mov	eax, DWORD PTR _iPlayerLoop$225927[ebp]
	mov	DWORD PTR _eLoopPlayer$225926[ebp], eax

; 6012 : 
; 6013 : 				if(GET_PLAYER(eLoopPlayer).getTeam() == GetID())

	mov	ecx, DWORD PTR _eLoopPlayer$225926[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T237583[ebp], ecx
	mov	edx, DWORD PTR $T237583[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T237592[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T237592[ebp], eax
	jne	$LN29@setHasTech

; 6014 : 				{
; 6015 : 					// Look at all Cities
; 6016 : 					for(pLoopCity = GET_PLAYER(eLoopPlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(eLoopPlayer).nextCity(&iLoop))

	mov	ecx, DWORD PTR _eLoopPlayer$225926[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T237596[ebp], ecx
	push	0
	lea	edx, DWORD PTR _iLoop$225925[ebp]
	push	edx
	mov	ecx, DWORD PTR $T237596[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$225924[ebp], eax
	jmp	SHORT $LN28@setHasTech
$LN27@setHasTech:
	mov	eax, DWORD PTR _eLoopPlayer$225926[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T237600[ebp], eax
	push	0
	lea	ecx, DWORD PTR _iLoop$225925[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T237600[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$225924[ebp], eax
$LN28@setHasTech:
	cmp	DWORD PTR _pLoopCity$225924[ebp], 0
	je	SHORT $LN29@setHasTech

; 6017 : 					{
; 6018 : 						if (pLoopCity->IsOwedCultureBuilding())

	mov	ecx, DWORD PTR _pLoopCity$225924[ebp]
	call	?IsOwedCultureBuilding@CvCity@@QBE_NXZ	; CvCity::IsOwedCultureBuilding
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN25@setHasTech

; 6019 : 						{
; 6020 : 							BuildingTypes eFreeCultureBuilding = pLoopCity->ChooseFreeCultureBuilding();

	mov	ecx, DWORD PTR _pLoopCity$225924[ebp]
	call	?ChooseFreeCultureBuilding@CvCity@@QBE?AW4BuildingTypes@@XZ ; CvCity::ChooseFreeCultureBuilding
	mov	DWORD PTR _eFreeCultureBuilding$225937[ebp], eax

; 6021 : 							if (eFreeCultureBuilding != NO_BUILDING)

	cmp	DWORD PTR _eFreeCultureBuilding$225937[ebp], -1
	je	SHORT $LN25@setHasTech

; 6022 : 							{
; 6023 : 								pLoopCity->GetCityBuildings()->SetNumFreeBuilding(eFreeCultureBuilding, 1);

	push	1
	mov	eax, DWORD PTR _eFreeCultureBuilding$225937[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopCity$225924[ebp]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?SetNumFreeBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::SetNumFreeBuilding

; 6024 : 								pLoopCity->SetOwedCultureBuilding(false);

	push	0
	mov	ecx, DWORD PTR _pLoopCity$225924[ebp]
	call	?SetOwedCultureBuilding@CvCity@@QAEX_N@Z ; CvCity::SetOwedCultureBuilding
$LN25@setHasTech:

; 6025 : 							}
; 6026 : 						}
; 6027 : 					}

	jmp	$LN27@setHasTech
$LN29@setHasTech:

; 6028 : 				}
; 6029 : 			}

	jmp	$LN31@setHasTech
$LN101@setHasTech:

; 6030 : 		}
; 6031 : 
; 6032 : 		if(bNewValue)

	movzx	ecx, BYTE PTR _bNewValue$[ebp]
	test	ecx, ecx
	je	$LN23@setHasTech

; 6033 : 		{
; 6034 : 			if(bAnnounce)

	movzx	edx, BYTE PTR _bAnnounce$[ebp]
	test	edx, edx
	je	$LN22@setHasTech

; 6035 : 			{
; 6036 : 				if(GC.getGame().isFinalInitialized())

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237604[ebp], eax
	mov	ecx, DWORD PTR $T237604[ebp]
	call	?isFinalInitialized@CvGame@@QBE_NXZ	; CvGame::isFinalInitialized
	movzx	ecx, al
	test	ecx, ecx
	je	$LN22@setHasTech

; 6037 : 				{
; 6038 : 					CvAssert(ePlayer != NO_PLAYER);
; 6039 : 					if(GET_PLAYER(ePlayer).isHuman())

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T237608[ebp], edx
	mov	ecx, DWORD PTR $T237608[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	je	$LN22@setHasTech

; 6040 : 					{
; 6041 : 						if(GET_PLAYER(ePlayer).GetPlayerTechs()->IsResearch() && (GET_PLAYER(ePlayer).GetPlayerTechs()->GetCurrentResearch() == NO_TECH))

	mov	ecx, DWORD PTR _ePlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T237612[ebp], ecx
	mov	ecx, DWORD PTR $T237612[ebp]
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?IsResearch@CvPlayerTechs@@QBE_NXZ	; CvPlayerTechs::IsResearch
	movzx	edx, al
	test	edx, edx
	je	$LN22@setHasTech
	mov	eax, DWORD PTR _ePlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T237616[ebp], eax
	mov	ecx, DWORD PTR $T237616[ebp]
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?GetCurrentResearch@CvPlayerTechs@@QBE?AW4TechTypes@@XZ ; CvPlayerTechs::GetCurrentResearch
	cmp	eax, -1
	jne	SHORT $LN22@setHasTech

; 6042 : 						{
; 6043 : 							strBuffer = GetLocalizedText("TXT_KEY_MISC_WHAT_TO_RESEARCH_NEXT");

	push	OFFSET ??_C@_0CD@CKJNKGCB@TXT_KEY_MISC_WHAT_TO_RESEARCH_NE@
	lea	ecx, DWORD PTR $T236908[ebp]
	push	ecx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	mov	DWORD PTR tv2352[ebp], eax
	mov	edx, DWORD PTR tv2352[ebp]
	mov	DWORD PTR $T237620[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 16		; 00000010H
	mov	eax, DWORD PTR $T237620[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T236908[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6044 : 							GET_PLAYER(ePlayer).chooseTech(0, strBuffer, eIndex);

	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T237628[ebp], eax
	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T237628[ebp]
	push	edx
	push	0
	mov	ecx, DWORD PTR _ePlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?chooseTech@CvPlayer@@QAEXHPBDW4TechTypes@@@Z ; CvPlayer::chooseTech
$LN22@setHasTech:

; 6045 : 						}
; 6046 : 					}
; 6047 : 				}
; 6048 : 			}
; 6049 : 
; 6050 : 			// espionage logic. Whenever someone gains a tech, reset the stealable techs for all other leaders
; 6051 : 			if(!GET_PLAYER(ePlayer).isMinorCiv() && !GET_PLAYER(ePlayer).isBarbarian())

	mov	eax, DWORD PTR _ePlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T237635[ebp], eax
	mov	ecx, DWORD PTR $T237635[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN23@setHasTech
	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T237639[ebp], edx
	mov	ecx, DWORD PTR $T237639[ebp]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	movzx	eax, al
	test	eax, eax
	jne	$LN23@setHasTech

; 6052 : 			{
; 6053 : 				CvPlayerEspionage* pEspionage = GET_PLAYER(ePlayer).GetEspionage();

	mov	ecx, DWORD PTR _ePlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T237643[ebp], ecx
	mov	ecx, DWORD PTR $T237643[ebp]
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	DWORD PTR _pEspionage$225947[ebp], eax

; 6054 : 				if(pEspionage)

	cmp	DWORD PTR _pEspionage$225947[ebp], 0
	je	$LN23@setHasTech

; 6055 : 				{
; 6056 : 					for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)

	mov	DWORD PTR _ui$225949[ebp], 0
	jmp	SHORT $LN16@setHasTech
$LN15@setHasTech:
	mov	edx, DWORD PTR _ui$225949[ebp]
	add	edx, 1
	mov	DWORD PTR _ui$225949[ebp], edx
$LN16@setHasTech:
	cmp	DWORD PTR _ui$225949[ebp], 22		; 00000016H
	jae	SHORT $LN23@setHasTech

; 6057 : 					{
; 6058 : 						pEspionage->BuildStealableTechList((PlayerTypes)ui);

	mov	eax, DWORD PTR _ui$225949[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEspionage$225947[ebp]
	call	?BuildStealableTechList@CvPlayerEspionage@@QAEXW4PlayerTypes@@@Z ; CvPlayerEspionage::BuildStealableTechList

; 6059 : 
; 6060 : 						// if the player is out of techs to steal, set their number of stealable techs to zero
; 6061 : 						if(pEspionage->m_aaPlayerStealableTechList[ui].size() == 0)

	mov	ecx, DWORD PTR _ui$225949[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _pEspionage$225947[ebp]
	add	ecx, DWORD PTR [edx+264]
	mov	DWORD PTR $T237647[ebp], ecx
	mov	eax, DWORD PTR $T237647[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T237651[ebp], ecx
	cmp	DWORD PTR $T237651[ebp], 0
	jne	SHORT $LN13@setHasTech

; 6062 : 						{
; 6063 : 							pEspionage->m_aiNumTechsToStealList[ui] = 0;

	mov	edx, DWORD PTR _pEspionage$225947[ebp]
	mov	eax, DWORD PTR [edx+720]
	mov	ecx, DWORD PTR _ui$225949[ebp]
	mov	DWORD PTR [eax+ecx*4], 0
$LN13@setHasTech:

; 6064 : 						}
; 6065 : 					}

	jmp	SHORT $LN15@setHasTech
$LN23@setHasTech:

; 6066 : 				}
; 6067 : 			}
; 6068 : 		}
; 6069 : 
; 6070 : 		// Update Happiness for all players
; 6071 : 		for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	mov	DWORD PTR _iPlayerLoop$225955[ebp], 0
	jmp	SHORT $LN12@setHasTech
$LN11@setHasTech:
	mov	edx, DWORD PTR _iPlayerLoop$225955[ebp]
	add	edx, 1
	mov	DWORD PTR _iPlayerLoop$225955[ebp], edx
$LN12@setHasTech:
	cmp	DWORD PTR _iPlayerLoop$225955[ebp], 22	; 00000016H
	jge	$LN10@setHasTech

; 6072 : 		{
; 6073 : 			if(GET_PLAYER((PlayerTypes)iPlayerLoop).isAlive() && GET_PLAYER((PlayerTypes) iPlayerLoop).getTeam() == GetID())

	mov	eax, DWORD PTR _iPlayerLoop$225955[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T237658[ebp], eax
	mov	ecx, DWORD PTR $T237658[ebp]
	mov	dl, BYTE PTR [ecx+2256]
	mov	BYTE PTR $T237667[ebp], dl
	movzx	eax, BYTE PTR $T237667[ebp]
	test	eax, eax
	je	SHORT $LN9@setHasTech
	mov	ecx, DWORD PTR _iPlayerLoop$225955[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T237671[ebp], ecx
	mov	edx, DWORD PTR $T237671[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T237680[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T237680[ebp], eax
	jne	SHORT $LN9@setHasTech

; 6074 : 			{
; 6075 : 				GET_PLAYER((PlayerTypes) iPlayerLoop).DoUpdateHappiness();

	mov	ecx, DWORD PTR _iPlayerLoop$225955[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?DoUpdateHappiness@CvPlayer@@QAEXXZ	; CvPlayer::DoUpdateHappiness
$LN9@setHasTech:

; 6076 : #ifdef AUI_CITIZENS_MID_TURN_ASSIGN_RUNS_SELF_CONSISTENCY
; 6077 : 				GET_PLAYER((PlayerTypes)iPlayerLoop).doSelfConsistencyCheckAllCities();
; 6078 : #endif
; 6079 : 			}
; 6080 : 		}

	jmp	$LN11@setHasTech
$LN10@setHasTech:

; 6081 : 
; 6082 : 		if(GC.getGame().isFinalInitialized())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237687[ebp], ecx
	mov	ecx, DWORD PTR $T237687[ebp]
	call	?isFinalInitialized@CvGame@@QBE_NXZ	; CvGame::isFinalInitialized
	movzx	edx, al
	test	edx, edx
	je	$LN8@setHasTech

; 6083 : 		{
; 6084 : 			if(GetID() == GC.getGame().getActiveTeam())

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237691[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	mov	esi, eax
	mov	ecx, DWORD PTR $T237691[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	esi, eax
	jne	$LN7@setHasTech

; 6085 : 			{
; 6086 : 				DLLUI->setDirty(MiscButtons_DIRTY_BIT, true);

	mov	ecx, DWORD PTR $T237695[ebp]
	mov	DWORD PTR tv1647[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv1647[ebp], edx
	push	1
	push	4
	mov	eax, DWORD PTR tv1647[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv1647[ebp]
	mov	eax, DWORD PTR [edx+260]
	call	eax

; 6087 : 				DLLUI->setDirty(SelectionButtons_DIRTY_BIT, true);

	mov	ecx, DWORD PTR $T237699[ebp]
	mov	DWORD PTR tv1659[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv1659[ebp], edx
	push	1
	push	6
	mov	eax, DWORD PTR tv1659[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv1659[ebp]
	mov	eax, DWORD PTR [edx+260]
	call	eax

; 6088 : 				DLLUI->setDirty(ResearchButtons_DIRTY_BIT, true);

	mov	ecx, DWORD PTR $T237703[ebp]
	mov	DWORD PTR tv1671[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv1671[ebp], edx
	push	1
	push	8
	mov	eax, DWORD PTR tv1671[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv1671[ebp]
	mov	eax, DWORD PTR [edx+260]
	call	eax
$LN7@setHasTech:

; 6089 : 			}
; 6090 : 
; 6091 : 			if(eIndex != NO_TECH && bNewValue)

	cmp	DWORD PTR _eIndex$[ebp], -1
	je	$LN8@setHasTech
	movzx	ecx, BYTE PTR _bNewValue$[ebp]
	test	ecx, ecx
	je	$LN8@setHasTech

; 6092 : 			{
; 6093 : 				bool bDontShowRewardPopup = DLLUI->IsOptionNoRewardPopups();

	mov	edx, DWORD PTR $T237707[ebp]
	mov	DWORD PTR tv1686[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv1686[ebp], eax
	mov	ecx, DWORD PTR tv1686[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv1686[ebp]
	mov	eax, DWORD PTR [edx+456]
	call	eax
	mov	BYTE PTR _bDontShowRewardPopup$225966[ebp], al

; 6094 : 
; 6095 : 				// Notification in MP games
; 6096 : 				if(bDontShowRewardPopup || GC.getGame().isNetworkMultiPlayer())

	movzx	ecx, BYTE PTR _bDontShowRewardPopup$225966[ebp]
	test	ecx, ecx
	jne	SHORT $LN4@setHasTech
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237711[ebp], edx
	mov	ecx, DWORD PTR $T237711[ebp]
	call	?isNetworkMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isNetworkMultiPlayer
	movzx	eax, al
	test	eax, eax
	je	$LN5@setHasTech
$LN4@setHasTech:

; 6097 : 				{
; 6098 : 					Localization::String localizedText = Localization::Lookup("TXT_KEY_MISC_YOU_DISCOVERED_TECH");

	push	OFFSET ??_C@_0CB@LLAIKMKO@TXT_KEY_MISC_YOU_DISCOVERED_TECH@
	lea	ecx, DWORD PTR _localizedText$225969[ebp]
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[ebp+8], 17		; 00000011H

; 6099 : 					localizedText << pkTechInfo->GetTextKey();

	mov	ecx, DWORD PTR _pkTechInfo$[ebp]
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	mov	DWORD PTR $T236909[ebp], eax
	lea	edx, DWORD PTR $T236909[ebp]
	push	edx
	lea	eax, DWORD PTR _localizedText$225969[ebp]
	push	eax
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 6100 : 					AddNotification(NOTIFICATION_TECH_AWARD, localizedText.toUTF8(), localizedText.toUTF8(), -1, -1, 0, (int) eIndex);

	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	push	0
	push	-1
	push	-1
	lea	ecx, DWORD PTR _localizedText$225969[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _localizedText$225969[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	push	-33507383				; fe00b7c9H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddNotification@CvTeam@@QAEXW4NotificationTypes@@PBD1HHHH@Z ; CvTeam::AddNotification

; 6101 : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _localizedText$225969[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	jmp	$LN8@setHasTech
$LN5@setHasTech:

; 6102 : 				// Popup in SP games
; 6103 : 				else if(GetID() == GC.getGame().getActiveTeam())

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237715[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	mov	esi, eax
	mov	ecx, DWORD PTR $T237715[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	esi, eax
	jne	$LN8@setHasTech

; 6104 : 				{
; 6105 : 					CvPopupInfo kPopup(BUTTONPOPUP_TECH_AWARD, GC.getGame().getActivePlayer(), 0, eIndex);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237719[ebp], eax
	mov	ecx, DWORD PTR $T237719[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	mov	DWORD PTR $T237723[ebp], eax
	mov	ecx, DWORD PTR $T237723[ebp]
	mov	DWORD PTR _kPopup$225975[ebp], ecx
	mov	DWORD PTR _kPopup$225975[ebp+4], 0
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	DWORD PTR _kPopup$225975[ebp+8], edx
	mov	DWORD PTR _kPopup$225975[ebp+12], 0
	mov	BYTE PTR _kPopup$225975[ebp+16], 0
	mov	BYTE PTR _kPopup$225975[ebp+17], 0
	mov	DWORD PTR _kPopup$225975[ebp+20], 68	; 00000044H
	mov	BYTE PTR _kPopup$225975[ebp+24], 0

; 6106 : 					//kPopup.setText(localizedText.toUTF8());
; 6107 : 					DLLUI->AddPopup(kPopup);

	mov	eax, DWORD PTR $T237727[ebp]
	mov	DWORD PTR tv1748[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv1748[ebp], ecx
	lea	edx, DWORD PTR _kPopup$225975[ebp]
	push	edx
	mov	eax, DWORD PTR tv1748[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv1748[ebp]
	mov	eax, DWORD PTR [edx+180]
	call	eax
$LN8@setHasTech:

; 6108 : 				}
; 6109 : 			}
; 6110 : 		}
; 6111 : 
; 6112 : 		if(bNewValue)

	movzx	ecx, BYTE PTR _bNewValue$[ebp]
	test	ecx, ecx
	je	SHORT $LN178@setHasTech

; 6113 : 		{
; 6114 : 			gDLL->GameplayTechAcquired(GetID(), eIndex);

	mov	edx, DWORD PTR $T237731[ebp]
	mov	DWORD PTR tv1761[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv1761[ebp], eax
	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	edx, DWORD PTR tv1761[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv1761[ebp]
	mov	edx, DWORD PTR [eax+684]
	call	edx
$LN178@setHasTech:

; 6115 : 		}
; 6116 : 	}
; 6117 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN183@setHasTech:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$0:
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$1:
	lea	ecx, DWORD PTR $T236886[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$2:
	lea	ecx, DWORD PTR _strSummary$225707[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$3:
	lea	ecx, DWORD PTR _strSummary$225767[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$4:
	lea	ecx, DWORD PTR $T236887[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$5:
	lea	ecx, DWORD PTR $T236888[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$6:
	lea	ecx, DWORD PTR $T236889[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$7:
	lea	ecx, DWORD PTR $T236890[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$8:
	lea	ecx, DWORD PTR $T236891[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$9:
	lea	ecx, DWORD PTR $T236894[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$10:
	lea	ecx, DWORD PTR $T236895[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$11:
	lea	ecx, DWORD PTR $T236898[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$12:
	lea	ecx, DWORD PTR $T236899[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$13:
	lea	ecx, DWORD PTR $T236900[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$14:
	lea	ecx, DWORD PTR $T236903[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$15:
	lea	ecx, DWORD PTR $T236906[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$16:
	lea	ecx, DWORD PTR $T236908[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$17:
	lea	ecx, DWORD PTR _localizedText$225969[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__ehhandler$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-2208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z ENDP ; CvTeam::setHasTech
PUBLIC	?getImprovementYieldChange@CvTeam@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z ; CvTeam::getImprovementYieldChange
; Function compile flags: /Odtp
;	COMDAT ?getImprovementYieldChange@CvTeam@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex1$ = 8						; size = 4
_eIndex2$ = 12						; size = 4
?getImprovementYieldChange@CvTeam@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z PROC ; CvTeam::getImprovementYieldChange, COMDAT
; _this$ = ecx

; 6122 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 6123 : 	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
; 6124 : 	CvAssertMsg(eIndex1 < GC.getNumImprovementInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
; 6125 : 	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
; 6126 : 	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
; 6127 : 	return m_ppaaiImprovementYieldChange[eIndex1][eIndex2];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2948]
	mov	edx, DWORD PTR _eIndex1$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _eIndex2$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]

; 6128 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?getImprovementYieldChange@CvTeam@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z ENDP ; CvTeam::getImprovementYieldChange
_TEXT	ENDS
PUBLIC	?changeImprovementYieldChange@CvTeam@@QAEXW4ImprovementTypes@@W4YieldTypes@@H@Z ; CvTeam::changeImprovementYieldChange
; Function compile flags: /Odtp
;	COMDAT ?changeImprovementYieldChange@CvTeam@@QAEXW4ImprovementTypes@@W4YieldTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex1$ = 8						; size = 4
_eIndex2$ = 12						; size = 4
_iChange$ = 16						; size = 4
?changeImprovementYieldChange@CvTeam@@QAEXW4ImprovementTypes@@W4YieldTypes@@H@Z PROC ; CvTeam::changeImprovementYieldChange, COMDAT
; _this$ = ecx

; 6133 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 6134 : 	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
; 6135 : 	CvAssertMsg(eIndex1 < GC.getNumImprovementInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
; 6136 : 	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
; 6137 : 	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
; 6138 : 
; 6139 : 	if(iChange != 0)

	cmp	DWORD PTR _iChange$[ebp], 0
	je	SHORT $LN2@changeImpr

; 6140 : 	{
; 6141 : 		m_ppaaiImprovementYieldChange[eIndex1][eIndex2] = (m_ppaaiImprovementYieldChange[eIndex1][eIndex2] + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2948]
	mov	edx, DWORD PTR _eIndex1$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _eIndex2$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	add	edx, DWORD PTR _iChange$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2948]
	mov	eax, DWORD PTR _eIndex1$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _eIndex2$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 6142 : 		CvAssert(getImprovementYieldChange(eIndex1, eIndex2) >= 0);
; 6143 : 
; 6144 : 		updateYield();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateYield@CvTeam@@QAEXXZ		; CvTeam::updateYield
$LN2@changeImpr:

; 6145 : 	}
; 6146 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?changeImprovementYieldChange@CvTeam@@QAEXW4ImprovementTypes@@W4YieldTypes@@H@Z ENDP ; CvTeam::changeImprovementYieldChange
_TEXT	ENDS
PUBLIC	?getImprovementNoFreshWaterYieldChange@CvTeam@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z ; CvTeam::getImprovementNoFreshWaterYieldChange
; Function compile flags: /Odtp
;	COMDAT ?getImprovementNoFreshWaterYieldChange@CvTeam@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex1$ = 8						; size = 4
_eIndex2$ = 12						; size = 4
?getImprovementNoFreshWaterYieldChange@CvTeam@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z PROC ; CvTeam::getImprovementNoFreshWaterYieldChange, COMDAT
; _this$ = ecx

; 6151 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 6152 : 	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
; 6153 : 	CvAssertMsg(eIndex1 < GC.getNumImprovementInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
; 6154 : 	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
; 6155 : 	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
; 6156 : 	return m_ppaaiImprovementNoFreshWaterYieldChange[eIndex1][eIndex2];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2952]
	mov	edx, DWORD PTR _eIndex1$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _eIndex2$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]

; 6157 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?getImprovementNoFreshWaterYieldChange@CvTeam@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z ENDP ; CvTeam::getImprovementNoFreshWaterYieldChange
_TEXT	ENDS
PUBLIC	?changeImprovementNoFreshWaterYieldChange@CvTeam@@QAEXW4ImprovementTypes@@W4YieldTypes@@H@Z ; CvTeam::changeImprovementNoFreshWaterYieldChange
; Function compile flags: /Odtp
;	COMDAT ?changeImprovementNoFreshWaterYieldChange@CvTeam@@QAEXW4ImprovementTypes@@W4YieldTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex1$ = 8						; size = 4
_eIndex2$ = 12						; size = 4
_iChange$ = 16						; size = 4
?changeImprovementNoFreshWaterYieldChange@CvTeam@@QAEXW4ImprovementTypes@@W4YieldTypes@@H@Z PROC ; CvTeam::changeImprovementNoFreshWaterYieldChange, COMDAT
; _this$ = ecx

; 6162 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 6163 : 	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
; 6164 : 	CvAssertMsg(eIndex1 < GC.getNumImprovementInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
; 6165 : 	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
; 6166 : 	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
; 6167 : 
; 6168 : 	if(iChange != 0)

	cmp	DWORD PTR _iChange$[ebp], 0
	je	SHORT $LN2@changeImpr@2

; 6169 : 	{
; 6170 : 		m_ppaaiImprovementNoFreshWaterYieldChange[eIndex1][eIndex2] = (m_ppaaiImprovementNoFreshWaterYieldChange[eIndex1][eIndex2] + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2952]
	mov	edx, DWORD PTR _eIndex1$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _eIndex2$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	add	edx, DWORD PTR _iChange$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2952]
	mov	eax, DWORD PTR _eIndex1$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _eIndex2$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 6171 : 		CvAssert(getImprovementNoFreshWaterYieldChange(eIndex1, eIndex2) >= 0);
; 6172 : 
; 6173 : 		updateYield();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateYield@CvTeam@@QAEXXZ		; CvTeam::updateYield
$LN2@changeImpr@2:

; 6174 : 	}
; 6175 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?changeImprovementNoFreshWaterYieldChange@CvTeam@@QAEXW4ImprovementTypes@@W4YieldTypes@@H@Z ENDP ; CvTeam::changeImprovementNoFreshWaterYieldChange
_TEXT	ENDS
PUBLIC	?getImprovementFreshWaterYieldChange@CvTeam@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z ; CvTeam::getImprovementFreshWaterYieldChange
; Function compile flags: /Odtp
;	COMDAT ?getImprovementFreshWaterYieldChange@CvTeam@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex1$ = 8						; size = 4
_eIndex2$ = 12						; size = 4
?getImprovementFreshWaterYieldChange@CvTeam@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z PROC ; CvTeam::getImprovementFreshWaterYieldChange, COMDAT
; _this$ = ecx

; 6180 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 6181 : 	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
; 6182 : 	CvAssertMsg(eIndex1 < GC.getNumImprovementInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
; 6183 : 	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
; 6184 : 	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
; 6185 : 	return m_ppaaiImprovementFreshWaterYieldChange[eIndex1][eIndex2];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2956]
	mov	edx, DWORD PTR _eIndex1$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _eIndex2$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]

; 6186 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?getImprovementFreshWaterYieldChange@CvTeam@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z ENDP ; CvTeam::getImprovementFreshWaterYieldChange
_TEXT	ENDS
PUBLIC	?changeImprovementFreshWaterYieldChange@CvTeam@@QAEXW4ImprovementTypes@@W4YieldTypes@@H@Z ; CvTeam::changeImprovementFreshWaterYieldChange
; Function compile flags: /Odtp
;	COMDAT ?changeImprovementFreshWaterYieldChange@CvTeam@@QAEXW4ImprovementTypes@@W4YieldTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex1$ = 8						; size = 4
_eIndex2$ = 12						; size = 4
_iChange$ = 16						; size = 4
?changeImprovementFreshWaterYieldChange@CvTeam@@QAEXW4ImprovementTypes@@W4YieldTypes@@H@Z PROC ; CvTeam::changeImprovementFreshWaterYieldChange, COMDAT
; _this$ = ecx

; 6191 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 6192 : 	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
; 6193 : 	CvAssertMsg(eIndex1 < GC.getNumImprovementInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
; 6194 : 	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
; 6195 : 	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
; 6196 : 
; 6197 : 	if(iChange != 0)

	cmp	DWORD PTR _iChange$[ebp], 0
	je	SHORT $LN2@changeImpr@3

; 6198 : 	{
; 6199 : 		m_ppaaiImprovementFreshWaterYieldChange[eIndex1][eIndex2] = (m_ppaaiImprovementFreshWaterYieldChange[eIndex1][eIndex2] + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2956]
	mov	edx, DWORD PTR _eIndex1$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _eIndex2$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	add	edx, DWORD PTR _iChange$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2956]
	mov	eax, DWORD PTR _eIndex1$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _eIndex2$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 6200 : 		CvAssert(getImprovementFreshWaterYieldChange(eIndex1, eIndex2) >= 0);
; 6201 : 
; 6202 : 		updateYield();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateYield@CvTeam@@QAEXXZ		; CvTeam::updateYield
$LN2@changeImpr@3:

; 6203 : 	}
; 6204 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?changeImprovementFreshWaterYieldChange@CvTeam@@QAEXW4ImprovementTypes@@W4YieldTypes@@H@Z ENDP ; CvTeam::changeImprovementFreshWaterYieldChange
_TEXT	ENDS
EXTRN	__imp_?max@?$numeric_limits@H@std@@SAHXZ:PROC
; Function compile flags: /Odtp
;	COMDAT ?updateTechShare@CvTeam@@IAEXW4TechTypes@@@Z
_TEXT	SEGMENT
tv147 = -36						; size = 4
_this$ = -32						; size = 4
$T237796 = -28						; size = 4
$T237789 = -24						; size = 4
$T237782 = -20						; size = 4
$T237776 = -16						; size = 4
_iCount$ = -12						; size = 4
_iBestShare$ = -8					; size = 4
_iI$ = -4						; size = 4
_eTech$ = 8						; size = 4
?updateTechShare@CvTeam@@IAEXW4TechTypes@@@Z PROC	; CvTeam::updateTechShare, COMDAT
; _this$ = ecx

; 6210 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 6211 : 	int iBestShare;
; 6212 : 	int iCount;
; 6213 : 	int iI;
; 6214 : 
; 6215 : 	if(GetTeamTechs()->HasTech(eTech))

	mov	eax, DWORD PTR _eTech$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN13@updateTech

; 6216 : 	{
; 6217 : 		return;

	jmp	$LN14@updateTech
$LN13@updateTech:

; 6218 : 	}
; 6219 : 
; 6220 : #ifdef AUI_FAST_COMP
; 6221 : 	iBestShare = MAX_INT;
; 6222 : #else
; 6223 : 	iBestShare = numeric_limits<int>::max();

	call	DWORD PTR __imp_?max@?$numeric_limits@H@std@@SAHXZ
	mov	DWORD PTR _iBestShare$[ebp], eax

; 6224 : #endif
; 6225 : 
; 6226 : 	for(iI = 0; iI < MAX_TEAMS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN12@updateTech
$LN11@updateTech:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN12@updateTech:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	SHORT $LN10@updateTech

; 6227 : 	{
; 6228 : 		if(isTechShare(iI))

	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isTechShare@CvTeam@@QBE_NH@Z		; CvTeam::isTechShare
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN9@updateTech

; 6229 : 		{
; 6230 : #ifdef AUI_FAST_COMP
; 6231 : 			iBestShare = MIN(iBestShare, (iI + 1));
; 6232 : #else
; 6233 : 			iBestShare = std::min(iBestShare, (iI + 1));

	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR $T237776[ebp], edx
	mov	eax, DWORD PTR $T237776[ebp]
	cmp	eax, DWORD PTR _iBestShare$[ebp]
	jge	SHORT $LN18@updateTech
	lea	ecx, DWORD PTR $T237776[ebp]
	mov	DWORD PTR tv147[ebp], ecx
	jmp	SHORT $LN19@updateTech
$LN18@updateTech:
	lea	edx, DWORD PTR _iBestShare$[ebp]
	mov	DWORD PTR tv147[ebp], edx
$LN19@updateTech:
	mov	eax, DWORD PTR tv147[ebp]
	mov	DWORD PTR $T237782[ebp], eax
	mov	ecx, DWORD PTR $T237782[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _iBestShare$[ebp], edx
$LN9@updateTech:

; 6234 : #endif
; 6235 : 		}
; 6236 : 	}

	jmp	SHORT $LN11@updateTech
$LN10@updateTech:

; 6237 : 
; 6238 : 	if(iBestShare != INT_MAX)

	cmp	DWORD PTR _iBestShare$[ebp], 2147483647	; 7fffffffH
	je	$LN14@updateTech

; 6239 : 	{
; 6240 : 		iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0

; 6241 : 
; 6242 : 		for(iI = 0; iI < MAX_CIV_TEAMS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN7@updateTech
$LN6@updateTech:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN7@updateTech:
	cmp	DWORD PTR _iI$[ebp], 63			; 0000003fH
	jge	SHORT $LN5@updateTech

; 6243 : 		{
; 6244 : 			if(GET_TEAM((TeamTypes)iI).isAlive())

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T237789[ebp], ecx
	mov	edx, DWORD PTR $T237789[ebp]
	xor	eax, eax
	cmp	DWORD PTR [edx+12], 0
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@updateTech

; 6245 : 			{
; 6246 : 				if(GET_TEAM((TeamTypes)iI).GetTeamTechs()->HasTech(eTech))

	mov	edx, DWORD PTR _iI$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T237796[ebp], edx
	mov	eax, DWORD PTR _eTech$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T237796[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@updateTech

; 6247 : 				{
; 6248 : 					if(isHasMet((TeamTypes)iI))

	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@updateTech

; 6249 : 					{
; 6250 : 						CvAssertMsg(iI != GetID(), "iI is not expected to be equal with GetID()");
; 6251 : 						iCount++;

	mov	ecx, DWORD PTR _iCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iCount$[ebp], ecx
$LN4@updateTech:

; 6252 : 					}
; 6253 : 				}
; 6254 : 			}
; 6255 : 		}

	jmp	SHORT $LN6@updateTech
$LN5@updateTech:

; 6256 : 
; 6257 : 		if(iCount >= iBestShare)

	mov	edx, DWORD PTR _iCount$[ebp]
	cmp	edx, DWORD PTR _iBestShare$[ebp]
	jl	SHORT $LN14@updateTech

; 6258 : 		{
; 6259 : 			setHasTech(eTech, true, NO_PLAYER, true, true);

	push	1
	push	1
	push	-1
	push	1
	mov	eax, DWORD PTR _eTech$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z ; CvTeam::setHasTech
$LN14@updateTech:

; 6260 : 		}
; 6261 : 	}
; 6262 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?updateTechShare@CvTeam@@IAEXW4TechTypes@@@Z ENDP	; CvTeam::updateTechShare
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?updateTechShare@CvTeam@@IAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_iI$ = -4						; size = 4
?updateTechShare@CvTeam@@IAEXXZ PROC			; CvTeam::updateTechShare, COMDAT
; _this$ = ecx

; 6267 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 6268 : #ifdef AUI_WARNING_FIXES
; 6269 : 	uint iI;
; 6270 : #else
; 6271 : 	int iI;
; 6272 : #endif
; 6273 : 
; 6274 : 	for(iI = 0; iI < GC.getNumTechInfos(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN3@updateTech@2
$LN2@updateTech@2:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN3@updateTech@2:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	cmp	DWORD PTR _iI$[ebp], eax
	jge	SHORT $LN4@updateTech@2

; 6275 : 	{
; 6276 : 		updateTechShare((TechTypes)iI);

	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateTechShare@CvTeam@@IAEXW4TechTypes@@@Z ; CvTeam::updateTechShare
	jmp	SHORT $LN2@updateTech@2
$LN4@updateTech@2:

; 6277 : 	}
; 6278 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?updateTechShare@CvTeam@@IAEXXZ ENDP			; CvTeam::updateTechShare
_TEXT	ENDS
PUBLIC	??_C@_0BF@CFJLAODG@CircumnavigatedGlobe?$AA@	; `string'
PUBLIC	??_C@_0CA@PBNBMOPA@TXT_KEY_MISC_UNKNOWN_CIRC_GLOBE?$AA@ ; `string'
PUBLIC	??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z	; GetLocalizedText<int>
PUBLIC	??_C@_0BM@FKAGIGBG@TXT_KEY_MISC_YOU_CIRC_GLOBE?$AA@ ; `string'
PUBLIC	??_C@_0CA@FBJNJDDI@TXT_KEY_MISC_SOMEONE_CIRC_GLOBE?$AA@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?isGameMultiPlayer@CvGame@@QBE_NXZ:PROC		; CvGame::isGameMultiPlayer
EXTRN	?makeCircumnavigated@CvGame@@QAEXXZ:PROC	; CvGame::makeCircumnavigated
EXTRN	?circumnavigationAvailable@CvGame@@QBE_NXZ:PROC	; CvGame::circumnavigationAvailable
;	COMDAT ??_C@_0BF@CFJLAODG@CircumnavigatedGlobe?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BF@CFJLAODG@CircumnavigatedGlobe?$AA@ DB 'CircumnavigatedGlobe', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@PBNBMOPA@TXT_KEY_MISC_UNKNOWN_CIRC_GLOBE?$AA@
CONST	SEGMENT
??_C@_0CA@PBNBMOPA@TXT_KEY_MISC_UNKNOWN_CIRC_GLOBE?$AA@ DB 'TXT_KEY_MISC_'
	DB	'UNKNOWN_CIRC_GLOBE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FKAGIGBG@TXT_KEY_MISC_YOU_CIRC_GLOBE?$AA@
CONST	SEGMENT
??_C@_0BM@FKAGIGBG@TXT_KEY_MISC_YOU_CIRC_GLOBE?$AA@ DB 'TXT_KEY_MISC_YOU_'
	DB	'CIRC_GLOBE', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@FBJNJDDI@TXT_KEY_MISC_SOMEONE_CIRC_GLOBE?$AA@
CONST	SEGMENT
??_C@_0CA@FBJNJDDI@TXT_KEY_MISC_SOMEONE_CIRC_GLOBE?$AA@ DB 'TXT_KEY_MISC_'
	DB	'SOMEONE_CIRC_GLOBE', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?testCircumnavigated@CvTeam@@IAEXXZ DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?testCircumnavigated@CvTeam@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?testCircumnavigated@CvTeam@@IAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?testCircumnavigated@CvTeam@@IAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?testCircumnavigated@CvTeam@@IAEXXZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?testCircumnavigated@CvTeam@@IAEXXZ$2
	DD	00H
	DD	FLAT:__unwindfunclet$?testCircumnavigated@CvTeam@@IAEXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?testCircumnavigated@CvTeam@@IAEXXZ$4
	DD	00H
	DD	FLAT:__unwindfunclet$?testCircumnavigated@CvTeam@@IAEXXZ$5
	DD	00H
	DD	FLAT:__unwindfunclet$?testCircumnavigated@CvTeam@@IAEXXZ$6
	DD	00H
	DD	FLAT:__unwindfunclet$?testCircumnavigated@CvTeam@@IAEXXZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$?testCircumnavigated@CvTeam@@IAEXXZ$8
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?testCircumnavigated@CvTeam@@IAEXXZ
_TEXT	SEGMENT
tv556 = -448						; size = 4
tv303 = -444						; size = 4
tv308 = -440						; size = 4
tv297 = -436						; size = 4
tv270 = -432						; size = 4
tv555 = -428						; size = 4
tv554 = -424						; size = 4
tv553 = -420						; size = 4
tv66 = -416						; size = 4
tv368 = -412						; size = 4
tv207 = -408						; size = 4
_this$ = -404						; size = 4
$T238052 = -400						; size = 4
$T238040 = -396						; size = 4
$T238036 = -392						; size = 4
$T238035 = -388						; size = 4
$T238025 = -384						; size = 4
$T238021 = -380						; size = 4
$T238017 = -376						; size = 4
$T238013 = -372						; size = 4
$T238005 = -368						; size = 4
$T237993 = -364						; size = 4
$T237989 = -360						; size = 4
$T237988 = -356						; size = 4
$T237984 = -352						; size = 4
$T237971 = -348						; size = 4
$T237963 = -344						; size = 4
$T237951 = -340						; size = 4
$T237939 = -333						; size = 1
$T237927 = -332						; size = 4
$T237920 = -328						; size = 4
$T237912 = -324						; size = 4
_uiOffset$237910 = -320					; size = 4
$T237891 = -316						; size = 4
$T237879 = -309						; size = 1
_uiOffset$237870 = -308					; size = 4
$T237851 = -304						; size = 4
$T237839 = -297						; size = 1
$T237808 = -296						; size = 28
$T237807 = -268						; size = 28
$T237806 = -240						; size = 28
$T237805 = -212						; size = 28
$T237804 = -184						; size = 28
$T237803 = -156						; size = 28
$T237802 = -128						; size = 28
_bResult$226120 = -97					; size = 1
_args$226119 = -96					; size = 4
_pkScriptSystem$226117 = -92				; size = 4
_kPlayer$226091 = -88					; size = 4
_iI$226087 = -84					; size = 4
_iFreeMoves$226085 = -80				; size = 4
_kMap$ = -76						; size = 4
_iActivePlayerID$ = -72					; size = 4
_pPlot$ = -68						; size = 4
_strBuffer$ = -64					; size = 28
__$ArrayPad$ = -36					; size = 4
_eTeamID$ = -32						; size = 4
_iX$ = -28						; size = 4
_kGame$ = -24						; size = 4
_bFoundVisible$ = -17					; size = 1
_iY$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?testCircumnavigated@CvTeam@@IAEXXZ PROC		; CvTeam::testCircumnavigated, COMDAT
; _this$ = ecx

; 6282 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?testCircumnavigated@CvTeam@@IAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 436				; 000001b4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 6283 : 	CvPlot* pPlot;
; 6284 : 	CvString strBuffer;

	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 6285 : 	bool bFoundVisible;
; 6286 : 	int iX, iY;
; 6287 : 
; 6288 : 	if(isBarbarian())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isBarbarian@CvTeam@@QBE_NXZ		; CvTeam::isBarbarian
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN33@testCircum

; 6289 : 	{
; 6290 : 		return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	$LN34@testCircum
$LN33@testCircum:

; 6291 : 	}
; 6292 : 
; 6293 : 	CvGame& kGame = GC.getGame();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR _kGame$[ebp], ecx

; 6294 : 	if(!kGame.circumnavigationAvailable())

	mov	ecx, DWORD PTR _kGame$[ebp]
	call	?circumnavigationAvailable@CvGame@@QBE_NXZ ; CvGame::circumnavigationAvailable
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN32@testCircum

; 6295 : 	{
; 6296 : 		return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	$LN34@testCircum
$LN32@testCircum:

; 6297 : 	}
; 6298 : 
; 6299 : 	CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 6300 : 
; 6301 : 	// Test one of the wrapping axises.  This is brute force and not exactly "correct".
; 6302 : 	// It does not test for continuity and is not able to test whether the plot was revealed by exploration or
; 6303 : 	// some other method such as gifted "maps".
; 6304 : 	TeamTypes eTeamID = GetID();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	mov	DWORD PTR _eTeamID$[ebp], eax

; 6305 : 	if(kMap.isWrapX())

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T237839[ebp], dl
	movzx	eax, BYTE PTR $T237839[ebp]
	test	eax, eax
	je	$LN31@testCircum

; 6306 : 	{
; 6307 : 		for(iX = kMap.getGridWidth(); iX--;)

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR _iX$[ebp], edx
$LN30@testCircum:
	mov	eax, DWORD PTR _iX$[ebp]
	mov	ecx, DWORD PTR _iX$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _iX$[ebp], ecx
	test	eax, eax
	je	$LN29@testCircum

; 6308 : 		{
; 6309 : 			bFoundVisible = false;

	mov	BYTE PTR _bFoundVisible$[ebp], 0

; 6310 : 
; 6311 : 			for(iY = kMap.getGridHeight(); iY--;)

	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR _iY$[ebp], eax
$LN28@testCircum:
	mov	ecx, DWORD PTR _iY$[ebp]
	mov	edx, DWORD PTR _iY$[ebp]
	sub	edx, 1
	mov	DWORD PTR _iY$[ebp], edx
	test	ecx, ecx
	je	SHORT $LN27@testCircum

; 6312 : 			{
; 6313 : 				pPlot = kMap.plotUnchecked(iX, iY);

	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T237851[ebp], ecx
	mov	edx, DWORD PTR _iY$[ebp]
	imul	edx, DWORD PTR $T237851[ebp]
	add	edx, DWORD PTR _iX$[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR _kMap$[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR _pPlot$[ebp], edx

; 6314 : 
; 6315 : 				if(pPlot->isRevealed(eTeamID))

	mov	ecx, DWORD PTR _eTeamID$[ebp]
	shr	ecx, 5
	mov	DWORD PTR _uiOffset$237870[ebp], ecx
	mov	edx, DWORD PTR _uiOffset$237870[ebp]
	shl	edx, 5
	mov	ecx, DWORD PTR _eTeamID$[ebp]
	sub	ecx, edx
	mov	eax, 1
	shl	eax, cl
	mov	ecx, DWORD PTR _uiOffset$237870[ebp]
	mov	edx, DWORD PTR _pPlot$[ebp]
	and	eax, DWORD PTR [edx+ecx*4+8]
	setne	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN26@testCircum

; 6316 : 				{
; 6317 : 					bFoundVisible = true;

	mov	BYTE PTR _bFoundVisible$[ebp], 1

; 6318 : 					break;

	jmp	SHORT $LN27@testCircum
$LN26@testCircum:

; 6319 : 				}
; 6320 : 			}

	jmp	SHORT $LN28@testCircum
$LN27@testCircum:

; 6321 : 
; 6322 : 			if(!bFoundVisible)

	movzx	edx, BYTE PTR _bFoundVisible$[ebp]
	test	edx, edx
	jne	SHORT $LN25@testCircum

; 6323 : 			{
; 6324 : 				return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	$LN34@testCircum
$LN25@testCircum:

; 6325 : 			}
; 6326 : 		}

	jmp	$LN30@testCircum
$LN29@testCircum:

; 6327 : 	}
; 6328 : 	else if(kMap.isWrapY())

	jmp	$LN24@testCircum
$LN31@testCircum:
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T237879[ebp], cl
	movzx	edx, BYTE PTR $T237879[ebp]
	test	edx, edx
	je	$LN24@testCircum

; 6329 : 	{
; 6330 : 		for(iY = kMap.getGridHeight(); iY--;)

	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR _iY$[ebp], ecx
$LN22@testCircum:
	mov	edx, DWORD PTR _iY$[ebp]
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	mov	DWORD PTR _iY$[ebp], eax
	test	edx, edx
	je	$LN24@testCircum

; 6331 : 		{
; 6332 : 			bFoundVisible = false;

	mov	BYTE PTR _bFoundVisible$[ebp], 0

; 6333 : 
; 6334 : 			for(iX = kMap.getGridWidth(); iX--;)

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR _iX$[ebp], edx
$LN20@testCircum:
	mov	eax, DWORD PTR _iX$[ebp]
	mov	ecx, DWORD PTR _iX$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _iX$[ebp], ecx
	test	eax, eax
	je	$LN19@testCircum

; 6335 : 			{
; 6336 : 				pPlot = kMap.plotUnchecked(iX, iY);

	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T237891[ebp], eax
	mov	ecx, DWORD PTR _iY$[ebp]
	imul	ecx, DWORD PTR $T237891[ebp]
	add	ecx, DWORD PTR _iX$[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _kMap$[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR _pPlot$[ebp], ecx

; 6337 : 
; 6338 : 				if(pPlot->isRevealed(GetID()))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	mov	DWORD PTR $T237912[ebp], eax
	mov	eax, DWORD PTR $T237912[ebp]
	shr	eax, 5
	mov	DWORD PTR _uiOffset$237910[ebp], eax
	mov	ecx, DWORD PTR _uiOffset$237910[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR $T237912[ebp]
	sub	edx, ecx
	mov	eax, 1
	mov	ecx, edx
	shl	eax, cl
	mov	ecx, DWORD PTR _uiOffset$237910[ebp]
	mov	edx, DWORD PTR _pPlot$[ebp]
	and	eax, DWORD PTR [edx+ecx*4+8]
	setne	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN18@testCircum

; 6339 : 				{
; 6340 : 					bFoundVisible = true;

	mov	BYTE PTR _bFoundVisible$[ebp], 1

; 6341 : 					break;

	jmp	SHORT $LN19@testCircum
$LN18@testCircum:

; 6342 : 				}
; 6343 : 			}

	jmp	$LN20@testCircum
$LN19@testCircum:

; 6344 : 
; 6345 : 			if(!bFoundVisible)

	movzx	edx, BYTE PTR _bFoundVisible$[ebp]
	test	edx, edx
	jne	SHORT $LN17@testCircum

; 6346 : 			{
; 6347 : 				return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	$LN34@testCircum
$LN17@testCircum:

; 6348 : 			}
; 6349 : 		}

	jmp	$LN22@testCircum
$LN24@testCircum:

; 6350 : 	}
; 6351 : 
; 6352 : 	kGame.makeCircumnavigated();

	mov	ecx, DWORD PTR _kGame$[ebp]
	call	?makeCircumnavigated@CvGame@@QAEXXZ	; CvGame::makeCircumnavigated

; 6353 : 
; 6354 : 	int iActivePlayerID = GC.getGame().getActivePlayer();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237920[ebp], eax
	mov	ecx, DWORD PTR $T237920[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	mov	DWORD PTR _iActivePlayerID$[ebp], eax

; 6355 : 
; 6356 : 	if(kGame.getElapsedGameTurns() > 0)

	mov	ecx, DWORD PTR _kGame$[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	test	eax, eax
	jle	$LN16@testCircum

; 6357 : 	{
; 6358 : 		int iFreeMoves = GC.getCIRCUMNAVIGATE_FREE_MOVES();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6744
	mov	DWORD PTR _iFreeMoves$226085[ebp], ecx

; 6359 : 		if(iFreeMoves != 0)

	cmp	DWORD PTR _iFreeMoves$226085[ebp], 0
	je	SHORT $LN15@testCircum

; 6360 : 			changeExtraMoves(DOMAIN_SEA, GC.getCIRCUMNAVIGATE_FREE_MOVES());

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6744
	mov	DWORD PTR $T237927[ebp], edx
	mov	eax, DWORD PTR $T237927[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeExtraMoves@CvTeam@@QAEXW4DomainTypes@@H@Z ; CvTeam::changeExtraMoves
$LN15@testCircum:

; 6361 : 
; 6362 : 		for(int iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$226087[ebp], 0
	jmp	SHORT $LN14@testCircum
$LN13@testCircum:
	mov	ecx, DWORD PTR _iI$226087[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$226087[ebp], ecx
$LN14@testCircum:
	cmp	DWORD PTR _iI$226087[ebp], 64		; 00000040H
	jge	$LN12@testCircum

; 6363 : 		{
; 6364 : 			CvPlayer& kPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	edx, DWORD PTR _iI$226087[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$226091[ebp], edx

; 6365 : 			if(kPlayer.isAlive())

	mov	eax, DWORD PTR _kPlayer$226091[ebp]
	mov	cl, BYTE PTR [eax+2256]
	mov	BYTE PTR $T237939[ebp], cl
	movzx	edx, BYTE PTR $T237939[ebp]
	test	edx, edx
	je	$LN11@testCircum

; 6366 : 			{
; 6367 : 				if(eTeamID == kPlayer.getTeam())

	mov	eax, DWORD PTR _kPlayer$226091[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	DWORD PTR _eTeamID$[ebp], eax
	jne	SHORT $LN10@testCircum

; 6368 : 				{
; 6369 : 					if(!kGame.isGameMultiPlayer() && kPlayer.isHuman())

	mov	ecx, DWORD PTR _kGame$[ebp]
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN10@testCircum
	mov	ecx, DWORD PTR _kPlayer$226091[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN10@testCircum

; 6370 : 					{
; 6371 : 						gDLL->UnlockAchievement(ACHIEVEMENT_ROUND_WORLD);

	mov	ecx, DWORD PTR $T237951[ebp]
	mov	DWORD PTR tv207[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv207[ebp], edx
	push	95					; 0000005fH
	mov	eax, DWORD PTR tv207[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv207[ebp]
	mov	eax, DWORD PTR [edx+828]
	call	eax
$LN10@testCircum:

; 6372 : 					}
; 6373 : 				}
; 6374 : 
; 6375 : 				if(iActivePlayerID == iI)

	mov	ecx, DWORD PTR _iActivePlayerID$[ebp]
	cmp	ecx, DWORD PTR _iI$226087[ebp]
	jne	$LN11@testCircum

; 6376 : 				{
; 6377 : 					if(eTeamID == kPlayer.getTeam())

	mov	edx, DWORD PTR _kPlayer$226091[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	DWORD PTR _eTeamID$[ebp], eax
	jne	$LN130@testCircum

; 6378 : 					{
; 6379 : 						if(iFreeMoves == 0)

	cmp	DWORD PTR _iFreeMoves$226085[ebp], 0
	jne	SHORT $LN6@testCircum

; 6380 : 							// Not the most ideal solution, but if the free moves are 0, use the string designed for telling about another team circling the globe
; 6381 : 							strBuffer = GetLocalizedText("TXT_KEY_MISC_SOMEONE_CIRC_GLOBE", kPlayer.getName());

	mov	ecx, DWORD PTR _kPlayer$226091[ebp]
	call	?getName@CvPlayer@@QBEPBDXZ		; CvPlayer::getName
	push	eax
	push	OFFSET ??_C@_0CA@FBJNJDDI@TXT_KEY_MISC_SOMEONE_CIRC_GLOBE?$AA@
	lea	ecx, DWORD PTR $T237802[ebp]
	push	ecx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv368[ebp], eax
	mov	edx, DWORD PTR tv368[ebp]
	mov	DWORD PTR $T237963[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR $T237963[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T237802[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6382 : 						else

	jmp	SHORT $LN5@testCircum
$LN6@testCircum:

; 6383 : 							strBuffer = GetLocalizedText("TXT_KEY_MISC_YOU_CIRC_GLOBE", iFreeMoves);

	mov	ecx, DWORD PTR _iFreeMoves$226085[ebp]
	push	ecx
	push	OFFSET ??_C@_0BM@FKAGIGBG@TXT_KEY_MISC_YOU_CIRC_GLOBE?$AA@
	lea	edx, DWORD PTR $T237803[ebp]
	push	edx
	call	??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z ; GetLocalizedText<int>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv66[ebp], eax
	mov	eax, DWORD PTR tv66[ebp]
	mov	DWORD PTR $T237971[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR $T237971[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T237803[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN5@testCircum:
	jmp	$LN4@testCircum

; 6384 : 					}
; 6385 : 					else if(isHasMet(kPlayer.getTeam()))

$LN130@testCircum:
	mov	edx, DWORD PTR _kPlayer$226091[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T237984[ebp], eax
	mov	ecx, DWORD PTR $T237984[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	movzx	edx, al
	test	edx, edx
	je	$LN3@testCircum

; 6386 : 					{
; 6387 : 						strBuffer = GetLocalizedText("TXT_KEY_MISC_SOMEONE_CIRC_GLOBE", getName().GetCString());

	lea	eax, DWORD PTR $T237804[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	DWORD PTR tv553[ebp], eax
	mov	ecx, DWORD PTR tv553[ebp]
	mov	DWORD PTR $T237988[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR $T237988[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T237989[ebp], eax
	mov	edx, DWORD PTR $T237989[ebp]
	push	edx
	push	OFFSET ??_C@_0CA@FBJNJDDI@TXT_KEY_MISC_SOMEONE_CIRC_GLOBE?$AA@
	lea	eax, DWORD PTR $T237805[ebp]
	push	eax
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv554[ebp], eax
	mov	ecx, DWORD PTR tv554[ebp]
	mov	DWORD PTR $T237993[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	edx, DWORD PTR $T237993[ebp]
	push	edx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T237805[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T237804[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6388 : 					}
; 6389 : 					else

	jmp	SHORT $LN4@testCircum
$LN3@testCircum:

; 6390 : 					{
; 6391 : 						strBuffer = GetLocalizedText("TXT_KEY_MISC_UNKNOWN_CIRC_GLOBE");

	push	OFFSET ??_C@_0CA@PBNBMOPA@TXT_KEY_MISC_UNKNOWN_CIRC_GLOBE?$AA@
	lea	eax, DWORD PTR $T237806[ebp]
	push	eax
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	mov	DWORD PTR tv555[ebp], eax
	mov	ecx, DWORD PTR tv555[ebp]
	mov	DWORD PTR $T238005[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	edx, DWORD PTR $T238005[ebp]
	push	edx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T237806[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN4@testCircum:

; 6392 : 					}
; 6393 : 					DLLUI->AddMessage(0, ((PlayerTypes)iI), false, GC.getEVENT_MESSAGE_TIME(), strBuffer);

	mov	eax, DWORD PTR $T238013[ebp]
	mov	DWORD PTR tv270[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv270[ebp], ecx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T238017[ebp], eax
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	mov	DWORD PTR $T238021[ebp], edx
	push	0
	push	0
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR $T238017[ebp]
	push	eax
	mov	ecx, DWORD PTR $T238021[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _iI$226087[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR tv270[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv270[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax

; 6394 : 
; 6395 : 					ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR $T238025[ebp]
	mov	DWORD PTR tv297[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv297[ebp], edx
	mov	eax, DWORD PTR tv297[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv297[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pkScriptSystem$226117[ebp], eax

; 6396 : 					if (pkScriptSystem)

	cmp	DWORD PTR _pkScriptSystem$226117[ebp], 0
	je	SHORT $LN11@testCircum

; 6397 : 					{
; 6398 : 						CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$226119[ebp]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle
	mov	BYTE PTR __$EHRec$[ebp+8], 6

; 6399 : 						args->Push(eTeamID);

	mov	ecx, DWORD PTR _args$226119[ebp]
	mov	DWORD PTR tv308[ebp], ecx
	mov	edx, DWORD PTR _eTeamID$[ebp]
	push	edx
	mov	eax, DWORD PTR tv308[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv308[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 6400 : 
; 6401 : 						bool bResult = false;

	mov	BYTE PTR _bResult$226120[ebp], 0

; 6402 : 						LuaSupport::CallHook(pkScriptSystem, "CircumnavigatedGlobe", args.get(), bResult);

	lea	ecx, DWORD PTR _bResult$226120[ebp]
	push	ecx
	mov	edx, DWORD PTR _args$226119[ebp]
	push	edx
	push	OFFSET ??_C@_0BF@CFJLAODG@CircumnavigatedGlobe?$AA@
	mov	eax, DWORD PTR _pkScriptSystem$226117[ebp]
	push	eax
	call	?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallHook
	add	esp, 16					; 00000010H

; 6403 : 					}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _args$226119[ebp]
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN11@testCircum:

; 6404 : 				}
; 6405 : 			}
; 6406 : 		}

	jmp	$LN13@testCircum
$LN12@testCircum:

; 6407 : 
; 6408 : 		strBuffer = GetLocalizedText("TXT_KEY_MISC_SOMEONE_CIRC_GLOBE", getName().GetCString());

	lea	ecx, DWORD PTR $T237807[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	DWORD PTR tv303[ebp], eax
	mov	edx, DWORD PTR tv303[ebp]
	mov	DWORD PTR $T238035[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	ecx, DWORD PTR $T238035[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T238036[ebp], eax
	mov	eax, DWORD PTR $T238036[ebp]
	push	eax
	push	OFFSET ??_C@_0CA@FBJNJDDI@TXT_KEY_MISC_SOMEONE_CIRC_GLOBE?$AA@
	lea	ecx, DWORD PTR $T237808[ebp]
	push	ecx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv556[ebp], eax
	mov	edx, DWORD PTR tv556[ebp]
	mov	DWORD PTR $T238040[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	eax, DWORD PTR $T238040[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	lea	ecx, DWORD PTR $T237808[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T237807[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6409 : 		GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, getLeaderID(), strBuffer, -1, -1);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T238052[ebp], ecx
	push	-1
	push	-1
	lea	edx, DWORD PTR _strBuffer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	push	eax
	push	0
	mov	ecx, DWORD PTR $T238052[ebp]
	call	?addReplayMessage@CvGame@@QAEXW4ReplayMessageTypes@@W4PlayerTypes@@ABVCvString@@HH@Z ; CvGame::addReplayMessage
$LN16@testCircum:

; 6410 : 	}
; 6411 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN34@testCircum:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?testCircumnavigated@CvTeam@@IAEXXZ$0:
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?testCircumnavigated@CvTeam@@IAEXXZ$1:
	lea	ecx, DWORD PTR $T237802[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?testCircumnavigated@CvTeam@@IAEXXZ$2:
	lea	ecx, DWORD PTR $T237803[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?testCircumnavigated@CvTeam@@IAEXXZ$3:
	lea	ecx, DWORD PTR $T237804[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?testCircumnavigated@CvTeam@@IAEXXZ$4:
	lea	ecx, DWORD PTR $T237805[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?testCircumnavigated@CvTeam@@IAEXXZ$5:
	lea	ecx, DWORD PTR $T237806[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?testCircumnavigated@CvTeam@@IAEXXZ$6:
	lea	ecx, DWORD PTR _args$226119[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__unwindfunclet$?testCircumnavigated@CvTeam@@IAEXXZ$7:
	lea	ecx, DWORD PTR $T237807[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?testCircumnavigated@CvTeam@@IAEXXZ$8:
	lea	ecx, DWORD PTR $T237808[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?testCircumnavigated@CvTeam@@IAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-440]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?testCircumnavigated@CvTeam@@IAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?testCircumnavigated@CvTeam@@IAEXXZ ENDP		; CvTeam::testCircumnavigated
PUBLIC	??_C@_0BD@IGMPLOJL@TeamTechResearched?$AA@	; `string'
PUBLIC	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ		; CvPlot::getPlotCity
PUBLIC	??_C@_0CK@FLLPCCAH@TXT_KEY_NOTIFICATION_SUMMARY_GRE@ ; `string'
PUBLIC	??_C@_0DA@DNFDIJNC@TXT_KEY_NOTIFICATION_GREAT_PERSO@ ; `string'
PUBLIC	??_C@_0BD@NNACGNOP@SPECIALUNIT_PEOPLE?$AA@	; `string'
PUBLIC	?SetHasTechForWorldCongress@CvTeam@@QAEX_N@Z	; CvTeam::SetHasTechForWorldCongress
EXTRN	?SetEndGameTechResearched@CvGame@@QAEX_N@Z:PROC	; CvGame::SetEndGameTechResearched
EXTRN	?IsEndsGame@CvTechEntry@@QBE_NXZ:PROC		; CvTechEntry::IsEndsGame
EXTRN	?updateCityRoute@CvPlot@@QAEXXZ:PROC		; CvPlot::updateCityRoute
EXTRN	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ:PROC	; CvCity::getTeam
EXTRN	?updateYield@CvPlot@@QAEXXZ:PROC		; CvPlot::updateYield
EXTRN	?chooseProduction@CvCity@@QAEXW4UnitTypes@@W4BuildingTypes@@W4ProjectTypes@@_N3@Z:PROC ; CvCity::chooseProduction
EXTRN	?clearOrderQueue@CvCity@@QAEXXZ:PROC		; CvCity::clearOrderQueue
EXTRN	?getFirstBuildingOrder@CvCity@@QBEHW4BuildingTypes@@@Z:PROC ; CvCity::getFirstBuildingOrder
EXTRN	?ChangeNumCitiesFreeChosenBuilding@CvPlayer@@QAEXW4BuildingClassTypes@@H@Z:PROC ; CvPlayer::ChangeNumCitiesFreeChosenBuilding
EXTRN	?GetNumFreeBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z:PROC ; CvCityBuildings::GetNumFreeBuilding
EXTRN	?isValidBuildingLocation@CvCity@@QBE_NW4BuildingTypes@@@Z:PROC ; CvCity::isValidBuildingLocation
EXTRN	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z:PROC ; CvCivilizationInfo::getCivilizationBuildings
EXTRN	?IsFreeBuildingAllCity@CvPlayer@@QBE_NW4BuildingClassTypes@@@Z:PROC ; CvPlayer::IsFreeBuildingAllCity
EXTRN	?IsFreeChosenBuildingNewCity@CvPlayer@@QBE_NW4BuildingClassTypes@@@Z:PROC ; CvPlayer::IsFreeChosenBuildingNewCity
EXTRN	?GetNumCitiesFreeChosenBuilding@CvPlayer@@QBEHW4BuildingClassTypes@@@Z:PROC ; CvPlayer::GetNumCitiesFreeChosenBuilding
EXTRN	?GetFreeBuildingPrereqTech@CvPlayerTraits@@QBE?AW4TechTypes@@XZ:PROC ; CvPlayerTraits::GetFreeBuildingPrereqTech
EXTRN	?SetNumRealBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z:PROC ; CvCityBuildings::SetNumRealBuilding
EXTRN	?GetNumRealBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z:PROC ; CvCityBuildings::GetNumRealBuilding
EXTRN	?GetFreeCapitalBuilding@CvPlayerTraits@@QBE?AW4BuildingTypes@@XZ:PROC ; CvPlayerTraits::GetFreeCapitalBuilding
EXTRN	?GetCapitalFreeBuildingPrereqTech@CvPlayerTraits@@QBE?AW4TechTypes@@XZ:PROC ; CvPlayerTraits::GetCapitalFreeBuildingPrereqTech
EXTRN	?GetNextFreeUnit@CvPlayerTraits@@QAEHXZ:PROC	; CvPlayerTraits::GetNextFreeUnit
EXTRN	?GetSpecialUnitType@CvUnitEntry@@QBEHXZ:PROC	; CvUnitEntry::GetSpecialUnitType
EXTRN	?addFreeUnit@CvPlayer@@QAEPAVCvPlot@@W4UnitTypes@@W4UnitAITypes@@@Z:PROC ; CvPlayer::addFreeUnit
EXTRN	?GetDefaultUnitAIType@CvUnitEntry@@QBEHXZ:PROC	; CvUnitEntry::GetDefaultUnitAIType
EXTRN	?GetEntry@CvUnitXMLEntries@@QAEPAVCvUnitEntry@@H@Z:PROC ; CvUnitXMLEntries::GetEntry
EXTRN	?GetGameUnits@CvGlobals@@QBEPAVCvUnitXMLEntries@@XZ:PROC ; CvGlobals::GetGameUnits
EXTRN	?GetFirstFreeUnit@CvPlayerTraits@@QAEHW4TechTypes@@@Z:PROC ; CvPlayerTraits::GetFirstFreeUnit
EXTRN	?recomputePolicyCostModifier@CvPlayer@@QAEXXZ:PROC ; CvPlayer::recomputePolicyCostModifier
EXTRN	?InitPlayerTraits@CvPlayerTraits@@QAEXXZ:PROC	; CvPlayerTraits::InitPlayerTraits
EXTRN	?Reset@CvPlayerTraits@@QAEXXZ:PROC		; CvPlayerTraits::Reset
EXTRN	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ:PROC ; CvPlayer::GetPlayerTraits
EXTRN	?ChangeFreePromotionCount@CvPlayer@@QAEXW4PromotionTypes@@H@Z:PROC ; CvPlayer::ChangeFreePromotionCount
EXTRN	?IsFreePromotion@CvTechEntry@@QBEHH@Z:PROC	; CvTechEntry::IsFreePromotion
EXTRN	?getNumPromotionInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumPromotionInfos
EXTRN	?ChangeExtraVotesPerDiplomat@CvPlayer@@QAEXH@Z:PROC ; CvPlayer::ChangeExtraVotesPerDiplomat
EXTRN	?GetExtraVotesPerDiplomat@CvTechEntry@@QBEHXZ:PROC ; CvTechEntry::GetExtraVotesPerDiplomat
EXTRN	?ChangeInfluenceSpreadModifier@CvPlayer@@QAEXH@Z:PROC ; CvPlayer::ChangeInfluenceSpreadModifier
EXTRN	?GetInfluenceSpreadModifier@CvTechEntry@@QBEHXZ:PROC ; CvTechEntry::GetInfluenceSpreadModifier
EXTRN	?changeWorkerSpeedModifier@CvPlayer@@QAEXH@Z:PROC ; CvPlayer::changeWorkerSpeedModifier
EXTRN	?GetWorkerSpeedModifier@CvTechEntry@@QBEHXZ:PROC ; CvTechEntry::GetWorkerSpeedModifier
EXTRN	?changeUnitBaseHealModifier@CvPlayer@@QAEXH@Z:PROC ; CvPlayer::changeUnitBaseHealModifier
EXTRN	?GetUnitBaseHealModifier@CvTechEntry@@QBEHXZ:PROC ; CvTechEntry::GetUnitBaseHealModifier
EXTRN	?changeUnitFortificationModifier@CvPlayer@@QAEXH@Z:PROC ; CvPlayer::changeUnitFortificationModifier
EXTRN	?GetUnitFortificationModifier@CvTechEntry@@QBEHXZ:PROC ; CvTechEntry::GetUnitFortificationModifier
EXTRN	?changeFeatureProductionModifier@CvPlayer@@QAEXH@Z:PROC ; CvPlayer::changeFeatureProductionModifier
EXTRN	?GetFeatureProductionModifier@CvTechEntry@@QBEHXZ:PROC ; CvTechEntry::GetFeatureProductionModifier
EXTRN	?GetTechFreshWaterYieldChanges@CvImprovementEntry@@QBEHHH@Z:PROC ; CvImprovementEntry::GetTechFreshWaterYieldChanges
EXTRN	?GetTechNoFreshWaterYieldChanges@CvImprovementEntry@@QBEHHH@Z:PROC ; CvImprovementEntry::GetTechNoFreshWaterYieldChanges
EXTRN	?GetTechYieldChanges@CvImprovementEntry@@QBEHHH@Z:PROC ; CvImprovementEntry::GetTechYieldChanges
EXTRN	?GetEnhancedYieldTech@CvBuildingEntry@@QBEHXZ:PROC ; CvBuildingEntry::GetEnhancedYieldTech
EXTRN	?GetObsoleteTech@CvBuildingEntry@@QBEHXZ:PROC	; CvBuildingEntry::GetObsoleteTech
EXTRN	?GetDomainExtraMoves@CvTechEntry@@QBEHH@Z:PROC	; CvTechEntry::GetDomainExtraMoves
EXTRN	?getTechTimeChange@CvBuildInfo@@QBEHH@Z:PROC	; CvBuildInfo::getTechTimeChange
EXTRN	?getTechMovementChange@CvRouteInfo@@QBEHH@Z:PROC ; CvRouteInfo::getTechMovementChange
EXTRN	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z:PROC ; CvGlobals::getRouteInfo
EXTRN	?GetEmbarkedSightChange@CvTechEntry@@QBEHXZ:PROC ; CvTechEntry::GetEmbarkedSightChange
EXTRN	?GetEmbarkedMoveChange@CvTechEntry@@QBEHXZ:PROC	; CvTechEntry::GetEmbarkedMoveChange
EXTRN	?IsEmbarkedAllWaterPassage@CvTechEntry@@QBE_NXZ:PROC ; CvTechEntry::IsEmbarkedAllWaterPassage
EXTRN	?IsAllowsDefensiveEmbarking@CvTechEntry@@QBE_NXZ:PROC ; CvTechEntry::IsAllowsDefensiveEmbarking
EXTRN	?IsAllowsEmbarking@CvTechEntry@@QBE_NXZ:PROC	; CvTechEntry::IsAllowsEmbarking
EXTRN	?IsWaterWork@CvTechEntry@@QBE_NXZ:PROC		; CvTechEntry::IsWaterWork
EXTRN	?IsBridgeBuilding@CvTechEntry@@QBE_NXZ:PROC	; CvTechEntry::IsBridgeBuilding
EXTRN	?IsPermanentAllianceTrading@CvTechEntry@@QBE_NXZ:PROC ; CvTechEntry::IsPermanentAllianceTrading
EXTRN	?IsTradeAgreementTradingAllowed@CvTechEntry@@QBE_NXZ:PROC ; CvTechEntry::IsTradeAgreementTradingAllowed
EXTRN	?IsResearchAgreementTradingAllowed@CvTechEntry@@QBE_NXZ:PROC ; CvTechEntry::IsResearchAgreementTradingAllowed
EXTRN	?IsDefensivePactTradingAllowed@CvTechEntry@@QBE_NXZ:PROC ; CvTechEntry::IsDefensivePactTradingAllowed
EXTRN	?IsOpenBordersTradingAllowed@CvTechEntry@@QBE_NXZ:PROC ; CvTechEntry::IsOpenBordersTradingAllowed
EXTRN	?IsAllowEmbassyTradingAllowed@CvTechEntry@@QBE_NXZ:PROC ; CvTechEntry::IsAllowEmbassyTradingAllowed
EXTRN	?IsGoldTrading@CvTechEntry@@QBE_NXZ:PROC	; CvTechEntry::IsGoldTrading
EXTRN	?IsTechTrading@CvTechEntry@@QBE_NXZ:PROC	; CvTechEntry::IsTechTrading
EXTRN	?IsMapTrading@CvTechEntry@@QBE_NXZ:PROC		; CvTechEntry::IsMapTrading
EXTRN	?IsMapCentering@CvTechEntry@@QBE_NXZ:PROC	; CvTechEntry::IsMapCentering
EXTRN	?IsExtraWaterSeeFrom@CvTechEntry@@QBE_NXZ:PROC	; CvTechEntry::IsExtraWaterSeeFrom
EXTRN	?TriggerArchaeologySiteCreation@CvGame@@QAEX_N@Z:PROC ; CvGame::TriggerArchaeologySiteCreation
EXTRN	?IsTriggersArchaeologicalSites@CvTechEntry@@QBE_NXZ:PROC ; CvTechEntry::IsTriggersArchaeologicalSites
EXTRN	?IsAllowsWorldCongress@CvTechEntry@@QBE_NXZ:PROC ; CvTechEntry::IsAllowsWorldCongress
;	COMDAT ??_C@_0BD@IGMPLOJL@TeamTechResearched?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
CONST	SEGMENT
??_C@_0BD@IGMPLOJL@TeamTechResearched?$AA@ DB 'TeamTechResearched', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@FLLPCCAH@TXT_KEY_NOTIFICATION_SUMMARY_GRE@
CONST	SEGMENT
??_C@_0CK@FLLPCCAH@TXT_KEY_NOTIFICATION_SUMMARY_GRE@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_SUMMARY_GREAT_PERSON', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@DNFDIJNC@TXT_KEY_NOTIFICATION_GREAT_PERSO@
CONST	SEGMENT
??_C@_0DA@DNFDIJNC@TXT_KEY_NOTIFICATION_GREAT_PERSO@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_GREAT_PERSON_ACTIVE_PLAYER', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NNACGNOP@SPECIALUNIT_PEOPLE?$AA@
CONST	SEGMENT
??_C@_0BD@NNACGNOP@SPECIALUNIT_PEOPLE?$AA@ DB 'SPECIALUNIT_PEOPLE', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?processTech@CvTeam@@IAEXW4TechTypes@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?processTech@CvTeam@@IAEXW4TechTypes@@H@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?processTech@CvTeam@@IAEXW4TechTypes@@H@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?processTech@CvTeam@@IAEXW4TechTypes@@H@Z$2
__ehfuncinfo$?processTech@CvTeam@@IAEXW4TechTypes@@H@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?processTech@CvTeam@@IAEXW4TechTypes@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?processTech@CvTeam@@IAEXW4TechTypes@@H@Z
_TEXT	SEGMENT
tv770 = -380						; size = 4
tv763 = -376						; size = 4
tv754 = -372						; size = 4
tv742 = -368						; size = 4
_this$ = -364						; size = 4
$T238166 = -360						; size = 4
$T238150 = -356						; size = 4
$T238138 = -348						; size = 4
$T238134 = -344						; size = 4
$T238130 = -340						; size = 4
$T238126 = -336						; size = 4
_uiOffset$238124 = -332					; size = 4
$T238112 = -328						; size = 4
$T238108 = -324						; size = 4
$T238104 = -320						; size = 4
$T238100 = -316						; size = 4
$T238096 = -312						; size = 4
$T238092 = -305						; size = 1
$T238083 = -304						; size = 4
$T238071 = -300						; size = 4
_bResult$226300 = -293					; size = 1
_args$226299 = -292					; size = 4
_pBuildInfo$226288 = -288				; size = 4
_eReplacedBuilding$226260 = -284			; size = 4
_iLoop$226256 = -280					; size = 4
_pkBuildingInfo$226254 = -276				; size = 4
_eBuilding$226250 = -272				; size = 4
_pkBuildingClassInfo$226242 = -268			; size = 4
_eFreeCapitalBuilding$226233 = -264			; size = 4
_strText$226225 = -260					; size = 80
_strSummary$226228 = -180				; size = 80
_eSpecialUnitGreatPerson$226221 = -100			; size = 4
_playerCivilization$226218 = -96			; size = 4
_ePromotion$226209 = -92				; size = 4
_iPromotion$226205 = -88				; size = 4
_eLoopUnit$226212 = -84					; size = 4
_iDefaultAI$226213 = -80				; size = 4
_iUnitClass$226214 = -76				; size = 4
_thisCiv$226237 = -72					; size = 4
_pLoopCity$226236 = -68					; size = 4
_kPlayer$226202 = -64					; size = 4
_pImprovementEntry$226186 = -60				; size = 4
_pBuildingEntry$226176 = -56				; size = 4
_pkBuildInfo$226165 = -52				; size = 4
_i$226161 = -48						; size = 4
_iJ$ = -44						; size = 4
_pCity$ = -40						; size = 4
_iI$ = -36						; size = 4
_pTech$ = -32						; size = 4
_pLoopPlot$ = -28					; size = 4
_pNewUnitPlot$ = -24					; size = 4
_pkScriptSystem$ = -20					; size = 4
_eResource$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_eTech$ = 8						; size = 4
_iChange$ = 12						; size = 4
?processTech@CvTeam@@IAEXW4TechTypes@@H@Z PROC		; CvTeam::processTech, COMDAT
; _this$ = ecx

; 6415 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?processTech@CvTeam@@IAEXW4TechTypes@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 368				; 00000170H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 6416 : 	CvCity* pCity;
; 6417 : 	CvPlot* pLoopPlot;
; 6418 : 	ResourceTypes eResource;
; 6419 : #ifdef AUI_WARNING_FIXES
; 6420 : 	uint iI;
; 6421 : 	int iJ;
; 6422 : #else
; 6423 : 	int iI, iJ;
; 6424 : #endif
; 6425 : 
; 6426 : 	CvTechEntry* pTech = GC.getTechInfo(eTech);

	mov	eax, DWORD PTR _eTech$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo
	mov	DWORD PTR _pTech$[ebp], eax

; 6427 : 
; 6428 : 	if (pTech->IsAllowsWorldCongress())

	mov	ecx, DWORD PTR _pTech$[ebp]
	call	?IsAllowsWorldCongress@CvTechEntry@@QBE_NXZ ; CvTechEntry::IsAllowsWorldCongress
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN102@processTec

; 6429 : 	{
; 6430 : 		SetHasTechForWorldCongress(true);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetHasTechForWorldCongress@CvTeam@@QAEX_N@Z ; CvTeam::SetHasTechForWorldCongress
$LN102@processTec:

; 6431 : 	}
; 6432 : 
; 6433 : 	if(pTech->IsTriggersArchaeologicalSites())

	mov	ecx, DWORD PTR _pTech$[ebp]
	call	?IsTriggersArchaeologicalSites@CvTechEntry@@QBE_NXZ ; CvTechEntry::IsTriggersArchaeologicalSites
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN101@processTec

; 6434 : 	{
; 6435 : 		GC.getGame().TriggerArchaeologySiteCreation(true /*bCheckInitialized*/);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T238071[ebp], eax
	push	1
	mov	ecx, DWORD PTR $T238071[ebp]
	call	?TriggerArchaeologySiteCreation@CvGame@@QAEX_N@Z ; CvGame::TriggerArchaeologySiteCreation
$LN101@processTec:

; 6436 : 	}
; 6437 : 
; 6438 : 	if(pTech->IsExtraWaterSeeFrom())

	mov	ecx, DWORD PTR _pTech$[ebp]
	call	?IsExtraWaterSeeFrom@CvTechEntry@@QBE_NXZ ; CvTechEntry::IsExtraWaterSeeFrom
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN100@processTec

; 6439 : 	{
; 6440 : 		changeExtraWaterSeeFromCount(iChange);

	mov	edx, DWORD PTR _iChange$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeExtraWaterSeeFromCount@CvTeam@@QAEXH@Z ; CvTeam::changeExtraWaterSeeFromCount
$LN100@processTec:

; 6441 : 	}
; 6442 : 
; 6443 : 	if(pTech->IsMapCentering())

	mov	ecx, DWORD PTR _pTech$[ebp]
	call	?IsMapCentering@CvTechEntry@@QBE_NXZ	; CvTechEntry::IsMapCentering
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN99@processTec

; 6444 : 	{
; 6445 : 		if(iChange > 0)

	cmp	DWORD PTR _iChange$[ebp], 0
	jle	SHORT $LN99@processTec

; 6446 : 		{
; 6447 : 			setMapCentering(true);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setMapCentering@CvTeam@@QAEX_N@Z	; CvTeam::setMapCentering
$LN99@processTec:

; 6448 : 		}
; 6449 : 	}
; 6450 : 
; 6451 : 	if(pTech->IsMapTrading())

	mov	ecx, DWORD PTR _pTech$[ebp]
	call	?IsMapTrading@CvTechEntry@@QBE_NXZ	; CvTechEntry::IsMapTrading
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN97@processTec

; 6452 : 	{
; 6453 : 		changeMapTradingCount(iChange);

	mov	edx, DWORD PTR _iChange$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeMapTradingCount@CvTeam@@QAEXH@Z	; CvTeam::changeMapTradingCount
$LN97@processTec:

; 6454 : 	}
; 6455 : 
; 6456 : 	if(pTech->IsTechTrading())

	mov	ecx, DWORD PTR _pTech$[ebp]
	call	?IsTechTrading@CvTechEntry@@QBE_NXZ	; CvTechEntry::IsTechTrading
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN96@processTec

; 6457 : 	{
; 6458 : 		changeTechTradingCount(iChange);

	mov	ecx, DWORD PTR _iChange$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeTechTradingCount@CvTeam@@QAEXH@Z	; CvTeam::changeTechTradingCount
$LN96@processTec:

; 6459 : 	}
; 6460 : 
; 6461 : 	if(pTech->IsGoldTrading())

	mov	ecx, DWORD PTR _pTech$[ebp]
	call	?IsGoldTrading@CvTechEntry@@QBE_NXZ	; CvTechEntry::IsGoldTrading
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN95@processTec

; 6462 : 	{
; 6463 : 		changeGoldTradingCount(iChange);

	mov	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeGoldTradingCount@CvTeam@@QAEXH@Z	; CvTeam::changeGoldTradingCount
$LN95@processTec:

; 6464 : 	}
; 6465 : 
; 6466 : 	if(pTech->IsAllowEmbassyTradingAllowed())

	mov	ecx, DWORD PTR _pTech$[ebp]
	call	?IsAllowEmbassyTradingAllowed@CvTechEntry@@QBE_NXZ ; CvTechEntry::IsAllowEmbassyTradingAllowed
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN94@processTec

; 6467 : 	{
; 6468 : 		changeAllowEmbassyTradingAllowedCount(iChange);

	mov	edx, DWORD PTR _iChange$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeAllowEmbassyTradingAllowedCount@CvTeam@@QAEXH@Z ; CvTeam::changeAllowEmbassyTradingAllowedCount
$LN94@processTec:

; 6469 : 	}
; 6470 : 
; 6471 : 	if(pTech->IsOpenBordersTradingAllowed())

	mov	ecx, DWORD PTR _pTech$[ebp]
	call	?IsOpenBordersTradingAllowed@CvTechEntry@@QBE_NXZ ; CvTechEntry::IsOpenBordersTradingAllowed
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN93@processTec

; 6472 : 	{
; 6473 : 		changeOpenBordersTradingAllowedCount(iChange);

	mov	ecx, DWORD PTR _iChange$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeOpenBordersTradingAllowedCount@CvTeam@@QAEXH@Z ; CvTeam::changeOpenBordersTradingAllowedCount
$LN93@processTec:

; 6474 : 	}
; 6475 : 
; 6476 : 	if(pTech->IsDefensivePactTradingAllowed())

	mov	ecx, DWORD PTR _pTech$[ebp]
	call	?IsDefensivePactTradingAllowed@CvTechEntry@@QBE_NXZ ; CvTechEntry::IsDefensivePactTradingAllowed
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN92@processTec

; 6477 : 	{
; 6478 : 		changeDefensivePactTradingAllowedCount(iChange);

	mov	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeDefensivePactTradingAllowedCount@CvTeam@@QAEXH@Z ; CvTeam::changeDefensivePactTradingAllowedCount
$LN92@processTec:

; 6479 : 	}
; 6480 : 
; 6481 : 	if(pTech->IsResearchAgreementTradingAllowed())

	mov	ecx, DWORD PTR _pTech$[ebp]
	call	?IsResearchAgreementTradingAllowed@CvTechEntry@@QBE_NXZ ; CvTechEntry::IsResearchAgreementTradingAllowed
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN91@processTec

; 6482 : 	{
; 6483 : 		ChangeResearchAgreementTradingAllowedCount(iChange);

	mov	edx, DWORD PTR _iChange$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChangeResearchAgreementTradingAllowedCount@CvTeam@@QAEXH@Z ; CvTeam::ChangeResearchAgreementTradingAllowedCount
$LN91@processTec:

; 6484 : 	}
; 6485 : 
; 6486 : 	if(pTech->IsTradeAgreementTradingAllowed())

	mov	ecx, DWORD PTR _pTech$[ebp]
	call	?IsTradeAgreementTradingAllowed@CvTechEntry@@QBE_NXZ ; CvTechEntry::IsTradeAgreementTradingAllowed
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN90@processTec

; 6487 : 	{
; 6488 : 		ChangeTradeAgreementTradingAllowedCount(iChange);

	mov	ecx, DWORD PTR _iChange$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChangeTradeAgreementTradingAllowedCount@CvTeam@@QAEXH@Z ; CvTeam::ChangeTradeAgreementTradingAllowedCount
$LN90@processTec:

; 6489 : 	}
; 6490 : 
; 6491 : 	if(pTech->IsPermanentAllianceTrading())

	mov	ecx, DWORD PTR _pTech$[ebp]
	call	?IsPermanentAllianceTrading@CvTechEntry@@QBE_NXZ ; CvTechEntry::IsPermanentAllianceTrading
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN89@processTec

; 6492 : 	{
; 6493 : 		changePermanentAllianceTradingCount(iChange);

	mov	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changePermanentAllianceTradingCount@CvTeam@@QAEXH@Z ; CvTeam::changePermanentAllianceTradingCount
$LN89@processTec:

; 6494 : 	}
; 6495 : 
; 6496 : 	if(pTech->IsBridgeBuilding())

	mov	ecx, DWORD PTR _pTech$[ebp]
	call	?IsBridgeBuilding@CvTechEntry@@QBE_NXZ	; CvTechEntry::IsBridgeBuilding
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN88@processTec

; 6497 : 	{
; 6498 : 		changeBridgeBuildingCount(iChange);

	mov	edx, DWORD PTR _iChange$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeBridgeBuildingCount@CvTeam@@QAEXH@Z ; CvTeam::changeBridgeBuildingCount
$LN88@processTec:

; 6499 : 	}
; 6500 : 
; 6501 : 	if(pTech->IsWaterWork())

	mov	ecx, DWORD PTR _pTech$[ebp]
	call	?IsWaterWork@CvTechEntry@@QBE_NXZ	; CvTechEntry::IsWaterWork
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN87@processTec

; 6502 : 	{
; 6503 : 		changeWaterWorkCount(iChange);

	mov	ecx, DWORD PTR _iChange$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeWaterWorkCount@CvTeam@@QAEXH@Z	; CvTeam::changeWaterWorkCount
$LN87@processTec:

; 6504 : 	}
; 6505 : 
; 6506 : 	if(pTech->IsAllowsEmbarking())

	mov	ecx, DWORD PTR _pTech$[ebp]
	call	?IsAllowsEmbarking@CvTechEntry@@QBE_NXZ	; CvTechEntry::IsAllowsEmbarking
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN86@processTec

; 6507 : 	{
; 6508 : 		changeCanEmbarkCount(iChange);

	mov	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeCanEmbarkCount@CvTeam@@QAEXH@Z	; CvTeam::changeCanEmbarkCount
$LN86@processTec:

; 6509 : 	}
; 6510 : 
; 6511 : 	if(pTech->IsAllowsDefensiveEmbarking())

	mov	ecx, DWORD PTR _pTech$[ebp]
	call	?IsAllowsDefensiveEmbarking@CvTechEntry@@QBE_NXZ ; CvTechEntry::IsAllowsDefensiveEmbarking
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN85@processTec

; 6512 : 	{
; 6513 : 		changeDefensiveEmbarkCount(iChange);

	mov	edx, DWORD PTR _iChange$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeDefensiveEmbarkCount@CvTeam@@QAEXH@Z ; CvTeam::changeDefensiveEmbarkCount
$LN85@processTec:

; 6514 : 	}
; 6515 : 
; 6516 : 	if(pTech->IsEmbarkedAllWaterPassage())

	mov	ecx, DWORD PTR _pTech$[ebp]
	call	?IsEmbarkedAllWaterPassage@CvTechEntry@@QBE_NXZ ; CvTechEntry::IsEmbarkedAllWaterPassage
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN84@processTec

; 6517 : 	{
; 6518 : 		changeEmbarkedAllWaterPassage(iChange);

	mov	ecx, DWORD PTR _iChange$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeEmbarkedAllWaterPassage@CvTeam@@QAEXH@Z ; CvTeam::changeEmbarkedAllWaterPassage
$LN84@processTec:

; 6519 : 	}
; 6520 : 
; 6521 : 	if(pTech->GetEmbarkedMoveChange() != 0)

	mov	ecx, DWORD PTR _pTech$[ebp]
	call	?GetEmbarkedMoveChange@CvTechEntry@@QBEHXZ ; CvTechEntry::GetEmbarkedMoveChange
	test	eax, eax
	je	SHORT $LN83@processTec

; 6522 : 	{
; 6523 : 		changeEmbarkedExtraMoves(pTech->GetEmbarkedMoveChange() * iChange);

	mov	ecx, DWORD PTR _pTech$[ebp]
	call	?GetEmbarkedMoveChange@CvTechEntry@@QBEHXZ ; CvTechEntry::GetEmbarkedMoveChange
	imul	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeEmbarkedExtraMoves@CvTeam@@QAEXH@Z ; CvTeam::changeEmbarkedExtraMoves
$LN83@processTec:

; 6524 : 	}
; 6525 : 
; 6526 : 	//EAP: Add Embarked Visibility Extra on Techs
; 6527 : 
; 6528 : 	if(pTech->GetEmbarkedSightChange() != 0)

	mov	ecx, DWORD PTR _pTech$[ebp]
	call	?GetEmbarkedSightChange@CvTechEntry@@QBEHXZ ; CvTechEntry::GetEmbarkedSightChange
	test	eax, eax
	je	SHORT $LN82@processTec

; 6529 : 	{
; 6530 : 		changeEmbarkedExtraSight(pTech->GetEmbarkedSightChange() * iChange);

	mov	ecx, DWORD PTR _pTech$[ebp]
	call	?GetEmbarkedSightChange@CvTechEntry@@QBEHXZ ; CvTechEntry::GetEmbarkedSightChange
	imul	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeEmbarkedExtraSight@CvTeam@@QAEXH@Z ; CvTeam::changeEmbarkedExtraSight
$LN82@processTec:

; 6531 : 	}
; 6532 : 
; 6533 : 	for(iI = 0; iI < GC.getNumRouteInfos(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN81@processTec
$LN80@processTec:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN81@processTec:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumRouteInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumRouteInfos
	cmp	DWORD PTR _iI$[ebp], eax
	jge	SHORT $LN79@processTec

; 6534 : 	{
; 6535 : 		changeRouteChange(((RouteTypes)iI), (GC.getRouteInfo((RouteTypes) iI)->getTechMovementChange(eTech) * iChange));

	mov	eax, DWORD PTR _eTech$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo
	mov	ecx, eax
	call	?getTechMovementChange@CvRouteInfo@@QBEHH@Z ; CvRouteInfo::getTechMovementChange
	imul	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeRouteChange@CvTeam@@QAEXW4RouteTypes@@H@Z ; CvTeam::changeRouteChange

; 6536 : 	}

	jmp	SHORT $LN80@processTec
$LN79@processTec:

; 6537 : 
; 6538 : #ifdef AUI_WARNING_FIXES
; 6539 : 	for (uint i = 0; i < GC.getNumBuildInfos(); i++)
; 6540 : #else
; 6541 : 	for (int i = 0; i < GC.getNumBuildInfos(); i++)

	mov	DWORD PTR _i$226161[ebp], 0
	jmp	SHORT $LN78@processTec
$LN77@processTec:
	mov	eax, DWORD PTR _i$226161[ebp]
	add	eax, 1
	mov	DWORD PTR _i$226161[ebp], eax
$LN78@processTec:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	DWORD PTR _i$226161[ebp], eax
	jge	SHORT $LN76@processTec

; 6542 : #endif
; 6543 : 	{
; 6544 : 		CvBuildInfo* pkBuildInfo = GC.getBuildInfo((BuildTypes)i);

	mov	ecx, DWORD PTR _i$226161[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	DWORD PTR _pkBuildInfo$226165[ebp], eax

; 6545 : 		if (pkBuildInfo != NULL)

	cmp	DWORD PTR _pkBuildInfo$226165[ebp], 0
	je	SHORT $LN75@processTec

; 6546 : 			changeBuildTimeChange(((BuildTypes)i), (pkBuildInfo->getTechTimeChange(eTech) * iChange));

	mov	edx, DWORD PTR _eTech$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkBuildInfo$226165[ebp]
	call	?getTechTimeChange@CvBuildInfo@@QBEHH@Z	; CvBuildInfo::getTechTimeChange
	imul	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	eax, DWORD PTR _i$226161[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeBuildTimeChange@CvTeam@@QAEXW4BuildTypes@@H@Z ; CvTeam::changeBuildTimeChange
$LN75@processTec:

; 6547 : 	}

	jmp	SHORT $LN77@processTec
$LN76@processTec:

; 6548 : 
; 6549 : 	for(iI = 0; iI < NUM_DOMAIN_TYPES; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN74@processTec
$LN73@processTec:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN74@processTec:
	cmp	DWORD PTR _iI$[ebp], 5
	jge	SHORT $LN72@processTec

; 6550 : 	{
; 6551 : 		changeExtraMoves(((DomainTypes)iI), (pTech->GetDomainExtraMoves(iI) * iChange));

	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pTech$[ebp]
	call	?GetDomainExtraMoves@CvTechEntry@@QBEHH@Z ; CvTechEntry::GetDomainExtraMoves
	imul	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeExtraMoves@CvTeam@@QAEXW4DomainTypes@@H@Z ; CvTeam::changeExtraMoves

; 6552 : 	}

	jmp	SHORT $LN73@processTec
$LN72@processTec:

; 6553 : 
; 6554 : 	for(iI = 0; iI < GC.getNumBuildingInfos(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN71@processTec
$LN70@processTec:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN71@processTec:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	cmp	DWORD PTR _iI$[ebp], eax
	jge	SHORT $LN69@processTec

; 6555 : 	{
; 6556 : 		CvBuildingEntry* pBuildingEntry = GC.getBuildingInfo((BuildingTypes) iI);

	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	DWORD PTR _pBuildingEntry$226176[ebp], eax

; 6557 : 		if(pBuildingEntry)

	cmp	DWORD PTR _pBuildingEntry$226176[ebp], 0
	je	SHORT $LN68@processTec

; 6558 : 		{
; 6559 : 			if(pBuildingEntry->GetObsoleteTech() == eTech)

	mov	ecx, DWORD PTR _pBuildingEntry$226176[ebp]
	call	?GetObsoleteTech@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetObsoleteTech
	cmp	eax, DWORD PTR _eTech$[ebp]
	jne	SHORT $LN67@processTec

; 6560 : 			{
; 6561 : 				changeObsoleteBuildingCount(((BuildingTypes)iI), iChange);

	mov	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeObsoleteBuildingCount@CvTeam@@QAEXW4BuildingTypes@@H@Z ; CvTeam::changeObsoleteBuildingCount
$LN67@processTec:

; 6562 : 			}
; 6563 : 			if(pBuildingEntry->GetEnhancedYieldTech() == eTech)

	mov	ecx, DWORD PTR _pBuildingEntry$226176[ebp]
	call	?GetEnhancedYieldTech@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetEnhancedYieldTech
	cmp	eax, DWORD PTR _eTech$[ebp]
	jne	SHORT $LN68@processTec

; 6564 : 			{
; 6565 : 				enhanceBuilding(((BuildingTypes)iI), iChange);

	mov	edx, DWORD PTR _iChange$[ebp]
	push	edx
	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?enhanceBuilding@CvTeam@@QAEXW4BuildingTypes@@H@Z ; CvTeam::enhanceBuilding
$LN68@processTec:

; 6566 : 			}
; 6567 : 		}
; 6568 : 	}

	jmp	SHORT $LN70@processTec
$LN69@processTec:

; 6569 : 
; 6570 : 	for(iI = 0; iI < GC.getNumImprovementInfos(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN65@processTec
$LN64@processTec:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN65@processTec:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumImprovementInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumImprovementInfos
	cmp	DWORD PTR _iI$[ebp], eax
	jge	$LN63@processTec

; 6571 : 	{
; 6572 : 		CvImprovementEntry* pImprovementEntry = GC.getImprovementInfo((ImprovementTypes)iI);

	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	DWORD PTR _pImprovementEntry$226186[ebp], eax

; 6573 : 		if(pImprovementEntry)

	cmp	DWORD PTR _pImprovementEntry$226186[ebp], 0
	je	$LN62@processTec

; 6574 : 		{
; 6575 : 			for(iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)

	mov	DWORD PTR _iJ$[ebp], 0
	jmp	SHORT $LN61@processTec
$LN60@processTec:
	mov	eax, DWORD PTR _iJ$[ebp]
	add	eax, 1
	mov	DWORD PTR _iJ$[ebp], eax
$LN61@processTec:
	cmp	DWORD PTR _iJ$[ebp], 6
	jge	SHORT $LN62@processTec

; 6576 : 			{
; 6577 : 				changeImprovementYieldChange(((ImprovementTypes)iI), ((YieldTypes)iJ), (pImprovementEntry->GetTechYieldChanges(eTech, iJ) * iChange));

	mov	ecx, DWORD PTR _iJ$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eTech$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pImprovementEntry$226186[ebp]
	call	?GetTechYieldChanges@CvImprovementEntry@@QBEHHH@Z ; CvImprovementEntry::GetTechYieldChanges
	imul	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	eax, DWORD PTR _iJ$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeImprovementYieldChange@CvTeam@@QAEXW4ImprovementTypes@@W4YieldTypes@@H@Z ; CvTeam::changeImprovementYieldChange

; 6578 : 				changeImprovementNoFreshWaterYieldChange(((ImprovementTypes)iI), ((YieldTypes)iJ), (pImprovementEntry->GetTechNoFreshWaterYieldChanges(eTech, iJ) * iChange));

	mov	edx, DWORD PTR _iJ$[ebp]
	push	edx
	mov	eax, DWORD PTR _eTech$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pImprovementEntry$226186[ebp]
	call	?GetTechNoFreshWaterYieldChanges@CvImprovementEntry@@QBEHHH@Z ; CvImprovementEntry::GetTechNoFreshWaterYieldChanges
	imul	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iJ$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeImprovementNoFreshWaterYieldChange@CvTeam@@QAEXW4ImprovementTypes@@W4YieldTypes@@H@Z ; CvTeam::changeImprovementNoFreshWaterYieldChange

; 6579 : 				changeImprovementFreshWaterYieldChange(((ImprovementTypes)iI), ((YieldTypes)iJ), (pImprovementEntry->GetTechFreshWaterYieldChanges(eTech, iJ) * iChange));

	mov	eax, DWORD PTR _iJ$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eTech$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pImprovementEntry$226186[ebp]
	call	?GetTechFreshWaterYieldChanges@CvImprovementEntry@@QBEHHH@Z ; CvImprovementEntry::GetTechFreshWaterYieldChanges
	imul	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	edx, DWORD PTR _iJ$[ebp]
	push	edx
	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeImprovementFreshWaterYieldChange@CvTeam@@QAEXW4ImprovementTypes@@W4YieldTypes@@H@Z ; CvTeam::changeImprovementFreshWaterYieldChange

; 6580 : 			}

	jmp	$LN60@processTec
$LN62@processTec:

; 6581 : 		}
; 6582 : 	}

	jmp	$LN64@processTec
$LN63@processTec:

; 6583 : 
; 6584 : 	CvPlot* pNewUnitPlot;
; 6585 : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN58@processTec
$LN57@processTec:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN58@processTec:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	$LN56@processTec

; 6586 : 	{
; 6587 : 		CvPlayer& kPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	edx, DWORD PTR _iI$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$226202[ebp], edx

; 6588 : 		if(kPlayer.getTeam() == GetID() && kPlayer.isEverAlive())

	mov	eax, DWORD PTR _kPlayer$226202[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T238083[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T238083[ebp], eax
	jne	$LN55@processTec
	mov	edx, DWORD PTR _kPlayer$226202[ebp]
	mov	al, BYTE PTR [edx+2268]
	mov	BYTE PTR $T238092[ebp], al
	movzx	ecx, BYTE PTR $T238092[ebp]
	test	ecx, ecx
	je	$LN55@processTec

; 6589 : 		{
; 6590 : 			kPlayer.changeFeatureProductionModifier(pTech->GetFeatureProductionModifier() * iChange);

	mov	ecx, DWORD PTR _pTech$[ebp]
	call	?GetFeatureProductionModifier@CvTechEntry@@QBEHXZ ; CvTechEntry::GetFeatureProductionModifier
	imul	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kPlayer$226202[ebp]
	call	?changeFeatureProductionModifier@CvPlayer@@QAEXH@Z ; CvPlayer::changeFeatureProductionModifier

; 6591 : 			kPlayer.changeUnitFortificationModifier(pTech->GetUnitFortificationModifier() * iChange);

	mov	ecx, DWORD PTR _pTech$[ebp]
	call	?GetUnitFortificationModifier@CvTechEntry@@QBEHXZ ; CvTechEntry::GetUnitFortificationModifier
	imul	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kPlayer$226202[ebp]
	call	?changeUnitFortificationModifier@CvPlayer@@QAEXH@Z ; CvPlayer::changeUnitFortificationModifier

; 6592 : 			kPlayer.changeUnitBaseHealModifier(pTech->GetUnitBaseHealModifier() * iChange);

	mov	ecx, DWORD PTR _pTech$[ebp]
	call	?GetUnitBaseHealModifier@CvTechEntry@@QBEHXZ ; CvTechEntry::GetUnitBaseHealModifier
	imul	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kPlayer$226202[ebp]
	call	?changeUnitBaseHealModifier@CvPlayer@@QAEXH@Z ; CvPlayer::changeUnitBaseHealModifier

; 6593 : 			kPlayer.changeWorkerSpeedModifier(pTech->GetWorkerSpeedModifier() * iChange);

	mov	ecx, DWORD PTR _pTech$[ebp]
	call	?GetWorkerSpeedModifier@CvTechEntry@@QBEHXZ ; CvTechEntry::GetWorkerSpeedModifier
	imul	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kPlayer$226202[ebp]
	call	?changeWorkerSpeedModifier@CvPlayer@@QAEXH@Z ; CvPlayer::changeWorkerSpeedModifier

; 6594 : 			kPlayer.ChangeInfluenceSpreadModifier(pTech->GetInfluenceSpreadModifier() * iChange);

	mov	ecx, DWORD PTR _pTech$[ebp]
	call	?GetInfluenceSpreadModifier@CvTechEntry@@QBEHXZ ; CvTechEntry::GetInfluenceSpreadModifier
	imul	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kPlayer$226202[ebp]
	call	?ChangeInfluenceSpreadModifier@CvPlayer@@QAEXH@Z ; CvPlayer::ChangeInfluenceSpreadModifier

; 6595 : 			kPlayer.ChangeExtraVotesPerDiplomat(pTech->GetExtraVotesPerDiplomat() * iChange);

	mov	ecx, DWORD PTR _pTech$[ebp]
	call	?GetExtraVotesPerDiplomat@CvTechEntry@@QBEHXZ ; CvTechEntry::GetExtraVotesPerDiplomat
	imul	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kPlayer$226202[ebp]
	call	?ChangeExtraVotesPerDiplomat@CvPlayer@@QAEXH@Z ; CvPlayer::ChangeExtraVotesPerDiplomat

; 6596 : 
; 6597 : 			// Free promotion from this tech?
; 6598 : #ifdef AUI_WARNING_FIXES
; 6599 : 			for (uint iPromotion = 0; iPromotion < GC.getNumPromotionInfos(); iPromotion++)
; 6600 : #else
; 6601 : 			for(int iPromotion = 0; iPromotion < GC.getNumPromotionInfos(); iPromotion++)

	mov	DWORD PTR _iPromotion$226205[ebp], 0
	jmp	SHORT $LN54@processTec
$LN53@processTec:
	mov	edx, DWORD PTR _iPromotion$226205[ebp]
	add	edx, 1
	mov	DWORD PTR _iPromotion$226205[ebp], edx
$LN54@processTec:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumPromotionInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPromotionInfos
	cmp	DWORD PTR _iPromotion$226205[ebp], eax
	jge	SHORT $LN52@processTec

; 6602 : #endif
; 6603 : 			{
; 6604 : 				PromotionTypes ePromotion = (PromotionTypes) iPromotion;

	mov	eax, DWORD PTR _iPromotion$226205[ebp]
	mov	DWORD PTR _ePromotion$226209[ebp], eax

; 6605 : 				if(pTech->IsFreePromotion(ePromotion))

	mov	ecx, DWORD PTR _ePromotion$226209[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pTech$[ebp]
	call	?IsFreePromotion@CvTechEntry@@QBEHH@Z	; CvTechEntry::IsFreePromotion
	test	eax, eax
	je	SHORT $LN51@processTec

; 6606 : 					kPlayer.ChangeFreePromotionCount(ePromotion, iChange);

	mov	edx, DWORD PTR _iChange$[ebp]
	push	edx
	mov	eax, DWORD PTR _ePromotion$226209[ebp]
	push	eax
	mov	ecx, DWORD PTR _kPlayer$226202[ebp]
	call	?ChangeFreePromotionCount@CvPlayer@@QAEXW4PromotionTypes@@H@Z ; CvPlayer::ChangeFreePromotionCount
$LN51@processTec:

; 6607 : 			}

	jmp	SHORT $LN53@processTec
$LN52@processTec:

; 6608 : 
; 6609 : 			// Update our traits (some may have become obsolete)
; 6610 : 			kPlayer.GetPlayerTraits()->Reset();

	mov	ecx, DWORD PTR _kPlayer$226202[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	ecx, eax
	call	?Reset@CvPlayerTraits@@QAEXXZ		; CvPlayerTraits::Reset

; 6611 : 			kPlayer.GetPlayerTraits()->InitPlayerTraits();

	mov	ecx, DWORD PTR _kPlayer$226202[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	ecx, eax
	call	?InitPlayerTraits@CvPlayerTraits@@QAEXXZ ; CvPlayerTraits::InitPlayerTraits

; 6612 : 			kPlayer.recomputePolicyCostModifier();

	mov	ecx, DWORD PTR _kPlayer$226202[ebp]
	call	?recomputePolicyCostModifier@CvPlayer@@QAEXXZ ; CvPlayer::recomputePolicyCostModifier

; 6613 : 
; 6614 : 			// Does our trait give us a new unit when we reach this tech?
; 6615 : 			UnitTypes eLoopUnit;
; 6616 : 			int iDefaultAI;
; 6617 : 			int iUnitClass = kPlayer.GetPlayerTraits()->GetFirstFreeUnit(eTech);

	mov	ecx, DWORD PTR _eTech$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kPlayer$226202[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	ecx, eax
	call	?GetFirstFreeUnit@CvPlayerTraits@@QAEHW4TechTypes@@@Z ; CvPlayerTraits::GetFirstFreeUnit
	mov	DWORD PTR _iUnitClass$226214[ebp], eax
$LN50@processTec:

; 6618 : 			while(iUnitClass != NO_UNITCLASS)

	cmp	DWORD PTR _iUnitClass$226214[ebp], -1
	je	$LN49@processTec

; 6619 : 			{
; 6620 : 				CvCivilizationInfo& playerCivilization = kPlayer.getCivilizationInfo();

	mov	ecx, DWORD PTR _kPlayer$226202[ebp]
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	DWORD PTR _playerCivilization$226218[ebp], eax

; 6621 : 				eLoopUnit = (UnitTypes)playerCivilization.getCivilizationUnits(iUnitClass);

	mov	edx, DWORD PTR _iUnitClass$226214[ebp]
	push	edx
	mov	ecx, DWORD PTR _playerCivilization$226218[ebp]
	call	?getCivilizationUnits@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationUnits
	mov	DWORD PTR _eLoopUnit$226212[ebp], eax

; 6622 : 				iDefaultAI = GC.GetGameUnits()->GetEntry(eLoopUnit)->GetDefaultUnitAIType();

	mov	eax, DWORD PTR _eLoopUnit$226212[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameUnits@CvGlobals@@QBEPAVCvUnitXMLEntries@@XZ ; CvGlobals::GetGameUnits
	mov	ecx, eax
	call	?GetEntry@CvUnitXMLEntries@@QAEPAVCvUnitEntry@@H@Z ; CvUnitXMLEntries::GetEntry
	mov	ecx, eax
	call	?GetDefaultUnitAIType@CvUnitEntry@@QBEHXZ ; CvUnitEntry::GetDefaultUnitAIType
	mov	DWORD PTR _iDefaultAI$226213[ebp], eax

; 6623 : 				pNewUnitPlot = kPlayer.addFreeUnit(eLoopUnit,(UnitAITypes)iDefaultAI);

	mov	ecx, DWORD PTR _iDefaultAI$226213[ebp]
	push	ecx
	mov	edx, DWORD PTR _eLoopUnit$226212[ebp]
	push	edx
	mov	ecx, DWORD PTR _kPlayer$226202[ebp]
	call	?addFreeUnit@CvPlayer@@QAEPAVCvPlot@@W4UnitTypes@@W4UnitAITypes@@@Z ; CvPlayer::addFreeUnit
	mov	DWORD PTR _pNewUnitPlot$[ebp], eax

; 6624 : 
; 6625 : 				// Notification below only tells user if their civ gets a Great Person from their trait.  But trait code allows ANY unit to be received from reaching a tech.
; 6626 : 				// So in the future we should use a different notification ("you received a new unit from your trait since you reached this tech") instead.
; 6627 : 				SpecialUnitTypes eSpecialUnitGreatPerson = (SpecialUnitTypes) GC.getInfoTypeForString("SPECIALUNIT_PEOPLE");

	push	0
	push	OFFSET ??_C@_0BD@NNACGNOP@SPECIALUNIT_PEOPLE?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eSpecialUnitGreatPerson$226221[ebp], eax

; 6628 : 				if(pNewUnitPlot && kPlayer.GetNotifications() && GC.GetGameUnits()->GetEntry(eLoopUnit)->GetSpecialUnitType() == eSpecialUnitGreatPerson)

	cmp	DWORD PTR _pNewUnitPlot$[ebp], 0
	je	$LN48@processTec
	mov	ecx, DWORD PTR _kPlayer$226202[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	test	eax, eax
	je	$LN48@processTec
	mov	eax, DWORD PTR _eLoopUnit$226212[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameUnits@CvGlobals@@QBEPAVCvUnitXMLEntries@@XZ ; CvGlobals::GetGameUnits
	mov	ecx, eax
	call	?GetEntry@CvUnitXMLEntries@@QAEPAVCvUnitEntry@@H@Z ; CvUnitXMLEntries::GetEntry
	mov	ecx, eax
	call	?GetSpecialUnitType@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetSpecialUnitType
	cmp	eax, DWORD PTR _eSpecialUnitGreatPerson$226221[ebp]
	jne	$LN48@processTec

; 6629 : 				{
; 6630 : 					Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_GREAT_PERSON_ACTIVE_PLAYER");

	push	OFFSET ??_C@_0DA@DNFDIJNC@TXT_KEY_NOTIFICATION_GREAT_PERSO@
	lea	ecx, DWORD PTR _strText$226225[ebp]
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 6631 : 					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_GREAT_PERSON");

	push	OFFSET ??_C@_0CK@FLLPCCAH@TXT_KEY_NOTIFICATION_SUMMARY_GRE@
	lea	edx, DWORD PTR _strSummary$226228[ebp]
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 6632 : 					kPlayer.GetNotifications()->Add(NOTIFICATION_GREAT_PERSON_ACTIVE_PLAYER, strText.toUTF8(), strSummary.toUTF8(), pNewUnitPlot->getX(), pNewUnitPlot->getY(), eLoopUnit);

	mov	eax, DWORD PTR _pNewUnitPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T238096[ebp], ecx
	mov	edx, DWORD PTR _pNewUnitPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T238100[ebp], eax
	push	-1
	mov	ecx, DWORD PTR _eLoopUnit$226212[ebp]
	push	ecx
	mov	edx, DWORD PTR $T238096[ebp]
	push	edx
	mov	eax, DWORD PTR $T238100[ebp]
	push	eax
	lea	ecx, DWORD PTR _strSummary$226228[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strText$226225[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	push	-2083717098				; 83cd0016H
	mov	ecx, DWORD PTR _kPlayer$226202[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ecx, eax
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 6633 : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strSummary$226228[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strText$226225[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN48@processTec:

; 6634 : 
; 6635 : 				// Another?
; 6636 : 				iUnitClass = kPlayer.GetPlayerTraits()->GetNextFreeUnit();

	mov	ecx, DWORD PTR _kPlayer$226202[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	ecx, eax
	call	?GetNextFreeUnit@CvPlayerTraits@@QAEHXZ	; CvPlayerTraits::GetNextFreeUnit
	mov	DWORD PTR _iUnitClass$226214[ebp], eax

; 6637 : 			}

	jmp	$LN50@processTec
$LN49@processTec:

; 6638 : 
; 6639 : 
; 6640 : 
; 6641 : 
; 6642 : 
; 6643 : // -- From CMP DLL inserted table entried, very usefull ~EAP
; 6644 : 
; 6645 : 			if(kPlayer.getCapitalCity() != NULL) 

	mov	ecx, DWORD PTR _kPlayer$226202[ebp]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	test	eax, eax
	je	$LN47@processTec

; 6646 : 			{
; 6647 : 		
; 6648 : 				//Free building in capital unlocked via tech?
; 6649 : 				if(kPlayer.GetPlayerTraits()->GetCapitalFreeBuildingPrereqTech() == eTech)

	mov	ecx, DWORD PTR _kPlayer$226202[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	ecx, eax
	call	?GetCapitalFreeBuildingPrereqTech@CvPlayerTraits@@QBE?AW4TechTypes@@XZ ; CvPlayerTraits::GetCapitalFreeBuildingPrereqTech
	cmp	eax, DWORD PTR _eTech$[ebp]
	jne	SHORT $LN47@processTec

; 6650 : 				{
; 6651 : 					BuildingTypes eFreeCapitalBuilding = kPlayer.GetPlayerTraits()->GetFreeCapitalBuilding();

	mov	ecx, DWORD PTR _kPlayer$226202[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	ecx, eax
	call	?GetFreeCapitalBuilding@CvPlayerTraits@@QBE?AW4BuildingTypes@@XZ ; CvPlayerTraits::GetFreeCapitalBuilding
	mov	DWORD PTR _eFreeCapitalBuilding$226233[ebp], eax

; 6652 : 					if(eFreeCapitalBuilding != NO_BUILDING)

	cmp	DWORD PTR _eFreeCapitalBuilding$226233[ebp], -1
	je	SHORT $LN47@processTec

; 6653 : 					{
; 6654 : 						if(kPlayer.getCapitalCity()->GetCityBuildings()->GetNumRealBuilding(eFreeCapitalBuilding) > 0)

	mov	ecx, DWORD PTR _eFreeCapitalBuilding$226233[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kPlayer$226202[ebp]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	ecx, eax
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumRealBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumRealBuilding
	test	eax, eax
	jle	SHORT $LN44@processTec

; 6655 : 						{
; 6656 : 							kPlayer.getCapitalCity()->GetCityBuildings()->SetNumRealBuilding(eFreeCapitalBuilding, 0);

	push	0
	mov	edx, DWORD PTR _eFreeCapitalBuilding$226233[ebp]
	push	edx
	mov	ecx, DWORD PTR _kPlayer$226202[ebp]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	ecx, eax
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?SetNumRealBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::SetNumRealBuilding
$LN44@processTec:

; 6657 : 						}
; 6658 : 						kPlayer.getCapitalCity()->GetCityBuildings()->SetNumFreeBuilding(eFreeCapitalBuilding, 1);

	push	1
	mov	eax, DWORD PTR _eFreeCapitalBuilding$226233[ebp]
	push	eax
	mov	ecx, DWORD PTR _kPlayer$226202[ebp]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	ecx, eax
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?SetNumFreeBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::SetNumFreeBuilding
$LN47@processTec:

; 6659 : 					}
; 6660 : 				}
; 6661 : 			}
; 6662 : 
; 6663 : 			// Free buildings (once unlocked via tech) -- From CMP DLL inserted table entried, very usefull ~EAP
; 6664 : 			CvCity* pLoopCity;
; 6665 : 			const CvCivilizationInfo& thisCiv = kPlayer.getCivilizationInfo();

	mov	ecx, DWORD PTR _kPlayer$226202[ebp]
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	DWORD PTR _thisCiv$226237[ebp], eax

; 6666 : 			if(kPlayer.GetPlayerTraits()->GetFreeBuildingPrereqTech() == eTech)

	mov	ecx, DWORD PTR _kPlayer$226202[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	ecx, eax
	call	?GetFreeBuildingPrereqTech@CvPlayerTraits@@QBE?AW4TechTypes@@XZ ; CvPlayerTraits::GetFreeBuildingPrereqTech
	cmp	eax, DWORD PTR _eTech$[ebp]
	jne	$LN55@processTec

; 6667 : 			{
; 6668 : 				for(iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN42@processTec
$LN41@processTec:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN42@processTec:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	DWORD PTR _iI$[ebp], eax
	jge	$LN55@processTec

; 6669 : 				{
; 6670 : 					CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo((BuildingClassTypes)iI);

	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z ; CvGlobals::getBuildingClassInfo
	mov	DWORD PTR _pkBuildingClassInfo$226242[ebp], eax

; 6671 : 					if(!pkBuildingClassInfo)

	cmp	DWORD PTR _pkBuildingClassInfo$226242[ebp], 0
	jne	SHORT $LN39@processTec

; 6672 : 					{
; 6673 : 						continue;

	jmp	SHORT $LN41@processTec
$LN39@processTec:

; 6674 : 					}
; 6675 : 					
; 6676 : 					if (kPlayer.GetNumCitiesFreeChosenBuilding((BuildingClassTypes)iI) > 0 || kPlayer.IsFreeChosenBuildingNewCity((BuildingClassTypes)iI) || kPlayer.IsFreeBuildingAllCity((BuildingClassTypes)iI))

	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kPlayer$226202[ebp]
	call	?GetNumCitiesFreeChosenBuilding@CvPlayer@@QBEHW4BuildingClassTypes@@@Z ; CvPlayer::GetNumCitiesFreeChosenBuilding
	test	eax, eax
	jg	SHORT $LN37@processTec
	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kPlayer$226202[ebp]
	call	?IsFreeChosenBuildingNewCity@CvPlayer@@QBE_NW4BuildingClassTypes@@@Z ; CvPlayer::IsFreeChosenBuildingNewCity
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN37@processTec
	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kPlayer$226202[ebp]
	call	?IsFreeBuildingAllCity@CvPlayer@@QBE_NW4BuildingClassTypes@@@Z ; CvPlayer::IsFreeBuildingAllCity
	movzx	ecx, al
	test	ecx, ecx
	je	$LN38@processTec
$LN37@processTec:

; 6677 : 					{
; 6678 : 						BuildingTypes eBuilding = ((BuildingTypes)(thisCiv.getCivilizationBuildings((BuildingClassTypes)iI)));

	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	ecx, DWORD PTR _thisCiv$226237[ebp]
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	mov	DWORD PTR _eBuilding$226250[ebp], eax

; 6679 : 
; 6680 : 						if(eBuilding != NO_BUILDING)

	cmp	DWORD PTR _eBuilding$226250[ebp], -1
	je	$LN38@processTec

; 6681 : 						{
; 6682 : 							CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);

	mov	eax, DWORD PTR _eBuilding$226250[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	DWORD PTR _pkBuildingInfo$226254[ebp], eax

; 6683 : 							if(pkBuildingInfo)

	cmp	DWORD PTR _pkBuildingInfo$226254[ebp], 0
	je	$LN38@processTec

; 6684 : 							{
; 6685 : 								int iLoop;
; 6686 : 								for(pLoopCity = kPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kPlayer.nextCity(&iLoop))

	push	0
	lea	ecx, DWORD PTR _iLoop$226256[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kPlayer$226202[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$226236[ebp], eax
	jmp	SHORT $LN34@processTec
$LN33@processTec:
	push	0
	lea	edx, DWORD PTR _iLoop$226256[ebp]
	push	edx
	mov	ecx, DWORD PTR _kPlayer$226202[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$226236[ebp], eax
$LN34@processTec:
	cmp	DWORD PTR _pLoopCity$226236[ebp], 0
	je	$LN38@processTec

; 6687 : 								{
; 6688 : 									//bool bHasBuildingClass = pLoopCity->HasBuildingClass((BuildingClassTypes)iI);
; 6689 : 									BuildingTypes eReplacedBuilding = eBuilding;

	mov	eax, DWORD PTR _eBuilding$226250[ebp]
	mov	DWORD PTR _eReplacedBuilding$226260[ebp], eax

; 6690 : 								
; 6691 : 									if(pLoopCity->isValidBuildingLocation(eBuilding) || (eBuilding != eReplacedBuilding && pLoopCity->isValidBuildingLocation(eReplacedBuilding)))

	mov	ecx, DWORD PTR _eBuilding$226250[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopCity$226236[ebp]
	call	?isValidBuildingLocation@CvCity@@QBE_NW4BuildingTypes@@@Z ; CvCity::isValidBuildingLocation
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN30@processTec
	mov	eax, DWORD PTR _eBuilding$226250[ebp]
	cmp	eax, DWORD PTR _eReplacedBuilding$226260[ebp]
	je	$LN31@processTec
	mov	ecx, DWORD PTR _eReplacedBuilding$226260[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopCity$226236[ebp]
	call	?isValidBuildingLocation@CvCity@@QBE_NW4BuildingTypes@@@Z ; CvCity::isValidBuildingLocation
	movzx	edx, al
	test	edx, edx
	je	$LN31@processTec
$LN30@processTec:

; 6692 : 									{
; 6693 : 										if (kPlayer.GetNumCitiesFreeChosenBuilding((BuildingClassTypes)iI) > 0 || kPlayer.IsFreeChosenBuildingNewCity((BuildingClassTypes)iI) || kPlayer.IsFreeBuildingAllCity((BuildingClassTypes)iI))

	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kPlayer$226202[ebp]
	call	?GetNumCitiesFreeChosenBuilding@CvPlayer@@QBEHW4BuildingClassTypes@@@Z ; CvPlayer::GetNumCitiesFreeChosenBuilding
	test	eax, eax
	jg	SHORT $LN28@processTec
	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kPlayer$226202[ebp]
	call	?IsFreeChosenBuildingNewCity@CvPlayer@@QBE_NW4BuildingClassTypes@@@Z ; CvPlayer::IsFreeChosenBuildingNewCity
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN28@processTec
	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kPlayer$226202[ebp]
	call	?IsFreeBuildingAllCity@CvPlayer@@QBE_NW4BuildingClassTypes@@@Z ; CvPlayer::IsFreeBuildingAllCity
	movzx	ecx, al
	test	ecx, ecx
	je	$LN31@processTec
$LN28@processTec:

; 6694 : 										{
; 6695 : 											if (eBuilding != eReplacedBuilding)

	mov	edx, DWORD PTR _eBuilding$226250[ebp]
	cmp	edx, DWORD PTR _eReplacedBuilding$226260[ebp]
	je	$LN27@processTec

; 6696 : 											{
; 6697 : 												pLoopCity->GetCityBuildings()->SetNumRealBuilding(eReplacedBuilding, 0);

	push	0
	mov	eax, DWORD PTR _eReplacedBuilding$226260[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopCity$226236[ebp]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?SetNumRealBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::SetNumRealBuilding

; 6698 : 												if (pLoopCity->GetCityBuildings()->GetNumFreeBuilding(eReplacedBuilding) <= 0)

	mov	ecx, DWORD PTR _eReplacedBuilding$226260[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopCity$226236[ebp]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumFreeBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumFreeBuilding
	test	eax, eax
	jg	SHORT $LN26@processTec

; 6699 : 												{
; 6700 : 													pLoopCity->GetCityBuildings()->SetNumFreeBuilding(eReplacedBuilding, 1);

	push	1
	mov	edx, DWORD PTR _eReplacedBuilding$226260[ebp]
	push	edx
	mov	ecx, DWORD PTR _pLoopCity$226236[ebp]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?SetNumFreeBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::SetNumFreeBuilding
$LN26@processTec:

; 6701 : 												}
; 6702 : 												if (pLoopCity->GetCityBuildings()->GetNumFreeBuilding(eReplacedBuilding) > 0)

	mov	eax, DWORD PTR _eReplacedBuilding$226260[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopCity$226236[ebp]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumFreeBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumFreeBuilding
	test	eax, eax
	jle	SHORT $LN25@processTec

; 6703 : 												{
; 6704 : 													kPlayer.ChangeNumCitiesFreeChosenBuilding((BuildingClassTypes)iI, -1);

	push	-1
	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kPlayer$226202[ebp]
	call	?ChangeNumCitiesFreeChosenBuilding@CvPlayer@@QAEXW4BuildingClassTypes@@H@Z ; CvPlayer::ChangeNumCitiesFreeChosenBuilding
$LN25@processTec:

; 6705 : 												}
; 6706 : 												if (pLoopCity->getFirstBuildingOrder(eReplacedBuilding) == 0)

	mov	edx, DWORD PTR _eReplacedBuilding$226260[ebp]
	push	edx
	mov	ecx, DWORD PTR _pLoopCity$226236[ebp]
	call	?getFirstBuildingOrder@CvCity@@QBEHW4BuildingTypes@@@Z ; CvCity::getFirstBuildingOrder
	test	eax, eax
	jne	SHORT $LN24@processTec

; 6707 : 												{
; 6708 : 													pLoopCity->clearOrderQueue();

	mov	ecx, DWORD PTR _pLoopCity$226236[ebp]
	call	?clearOrderQueue@CvCity@@QAEXXZ		; CvCity::clearOrderQueue

; 6709 : 													pLoopCity->chooseProduction();

	push	0
	push	0
	push	-1
	push	-1
	push	-1
	mov	ecx, DWORD PTR _pLoopCity$226236[ebp]
	call	?chooseProduction@CvCity@@QAEXW4UnitTypes@@W4BuildingTypes@@W4ProjectTypes@@_N3@Z ; CvCity::chooseProduction
$LN24@processTec:

; 6710 : 													// Send a notification to the user that what they were building was given to them, and they need to produce something else.
; 6711 : 												}
; 6712 : 											}
; 6713 : 											else

	jmp	$LN31@processTec
$LN27@processTec:

; 6714 : 											{
; 6715 : 												if (pLoopCity->GetCityBuildings()->GetNumRealBuilding(eBuilding) > 0)

	mov	eax, DWORD PTR _eBuilding$226250[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopCity$226236[ebp]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumRealBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumRealBuilding
	test	eax, eax
	jle	SHORT $LN22@processTec

; 6716 : 												{
; 6717 : 													pLoopCity->GetCityBuildings()->SetNumRealBuilding(eBuilding, 0);

	push	0
	mov	ecx, DWORD PTR _eBuilding$226250[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopCity$226236[ebp]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?SetNumRealBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::SetNumRealBuilding
$LN22@processTec:

; 6718 : 												}
; 6719 : 												if (pLoopCity->GetCityBuildings()->GetNumFreeBuilding(eBuilding) <= 0)

	mov	edx, DWORD PTR _eBuilding$226250[ebp]
	push	edx
	mov	ecx, DWORD PTR _pLoopCity$226236[ebp]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumFreeBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumFreeBuilding
	test	eax, eax
	jg	SHORT $LN21@processTec

; 6720 : 												{
; 6721 : 													pLoopCity->GetCityBuildings()->SetNumFreeBuilding(eBuilding, 1);

	push	1
	mov	eax, DWORD PTR _eBuilding$226250[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopCity$226236[ebp]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?SetNumFreeBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::SetNumFreeBuilding
$LN21@processTec:

; 6722 : 												}
; 6723 : 												if (pLoopCity->GetCityBuildings()->GetNumFreeBuilding(eBuilding) > 0)

	mov	ecx, DWORD PTR _eBuilding$226250[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopCity$226236[ebp]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumFreeBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumFreeBuilding
	test	eax, eax
	jle	SHORT $LN20@processTec

; 6724 : 												{
; 6725 : 													kPlayer.ChangeNumCitiesFreeChosenBuilding((BuildingClassTypes)iI, -1);

	push	-1
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	ecx, DWORD PTR _kPlayer$226202[ebp]
	call	?ChangeNumCitiesFreeChosenBuilding@CvPlayer@@QAEXW4BuildingClassTypes@@H@Z ; CvPlayer::ChangeNumCitiesFreeChosenBuilding
$LN20@processTec:

; 6726 : 												}
; 6727 : 												if (pLoopCity->getFirstBuildingOrder(eBuilding) == 0)

	mov	eax, DWORD PTR _eBuilding$226250[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopCity$226236[ebp]
	call	?getFirstBuildingOrder@CvCity@@QBEHW4BuildingTypes@@@Z ; CvCity::getFirstBuildingOrder
	test	eax, eax
	jne	SHORT $LN31@processTec

; 6728 : 												{
; 6729 : 													pLoopCity->clearOrderQueue();

	mov	ecx, DWORD PTR _pLoopCity$226236[ebp]
	call	?clearOrderQueue@CvCity@@QAEXXZ		; CvCity::clearOrderQueue

; 6730 : 													pLoopCity->chooseProduction();

	push	0
	push	0
	push	-1
	push	-1
	push	-1
	mov	ecx, DWORD PTR _pLoopCity$226236[ebp]
	call	?chooseProduction@CvCity@@QAEXW4UnitTypes@@W4BuildingTypes@@W4ProjectTypes@@_N3@Z ; CvCity::chooseProduction
$LN31@processTec:

; 6731 : 													// Send a notification to the user that what they were building was given to them, and they need to produce something else.
; 6732 : 												}
; 6733 : 											}
; 6734 : 										}
; 6735 : 									}
; 6736 : 								}

	jmp	$LN33@processTec
$LN38@processTec:

; 6737 : 							}
; 6738 : 						}
; 6739 : 					}
; 6740 : 				}

	jmp	$LN41@processTec
$LN55@processTec:

; 6741 : 			}
; 6742 : 
; 6743 : 
; 6744 : 		}
; 6745 : 	}

	jmp	$LN57@processTec
$LN56@processTec:

; 6746 : 
; 6747 : 	for(iI = 0; iI < GC.getMap().numPlots(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN18@processTec
$LN17@processTec:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN18@processTec:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T238104[ebp], edx
	mov	eax, DWORD PTR $T238104[ebp]
	mov	ecx, DWORD PTR [eax+4028]
	mov	DWORD PTR $T238108[ebp], ecx
	mov	edx, DWORD PTR _iI$[ebp]
	cmp	edx, DWORD PTR $T238108[ebp]
	jge	$LN16@processTec

; 6748 : 	{
; 6749 : 		pLoopPlot = GC.getMap().plotByIndexUnchecked(iI);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T238112[ebp], eax
	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T238112[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR _pLoopPlot$[ebp], ecx

; 6750 : 
; 6751 : 		eResource = pLoopPlot->getResourceType();

	push	-1
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _eResource$[ebp], eax

; 6752 : 
; 6753 : 		if(eResource != NO_RESOURCE)

	cmp	DWORD PTR _eResource$[ebp], -1
	je	SHORT $LN15@processTec

; 6754 : 		{
; 6755 : 			if(GC.getResourceInfo(eResource)->getTechReveal() == eTech)

	mov	eax, DWORD PTR _eResource$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getTechReveal@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getTechReveal
	cmp	eax, DWORD PTR _eTech$[ebp]
	jne	SHORT $LN15@processTec

; 6756 : 			{
; 6757 : 				pLoopPlot->updateYield();

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield

; 6758 : 				if(pLoopPlot->isRevealed(m_eID))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T238126[ebp], edx
	mov	eax, DWORD PTR $T238126[ebp]
	shr	eax, 5
	mov	DWORD PTR _uiOffset$238124[ebp], eax
	mov	ecx, DWORD PTR _uiOffset$238124[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR $T238126[ebp]
	sub	edx, ecx
	mov	eax, 1
	mov	ecx, edx
	shl	eax, cl
	mov	ecx, DWORD PTR _uiOffset$238124[ebp]
	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	and	eax, DWORD PTR [edx+ecx*4+8]
	setne	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN15@processTec

; 6759 : 				{
; 6760 : 					pLoopPlot->setLayoutDirty(true);

	push	1
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?setLayoutDirty@CvPlot@@QAEX_N@Z	; CvPlot::setLayoutDirty
$LN15@processTec:

; 6761 : 				}
; 6762 : 			}
; 6763 : 		}
; 6764 : 	}

	jmp	$LN17@processTec
$LN16@processTec:

; 6765 : 
; 6766 : 	for(iI = 0; iI < GC.getNumBuildInfos(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN12@processTec
$LN11@processTec:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN12@processTec:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	DWORD PTR _iI$[ebp], eax
	jge	$LN10@processTec

; 6767 : 	{
; 6768 : 		CvBuildInfo* pBuildInfo = GC.getBuildInfo((BuildTypes) iI);

	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	DWORD PTR _pBuildInfo$226288[ebp], eax

; 6769 : 		if(pBuildInfo && pBuildInfo->getTechPrereq() == eTech)

	cmp	DWORD PTR _pBuildInfo$226288[ebp], 0
	je	$LN9@processTec
	mov	ecx, DWORD PTR _pBuildInfo$226288[ebp]
	call	?getTechPrereq@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getTechPrereq
	cmp	eax, DWORD PTR _eTech$[ebp]
	jne	$LN9@processTec

; 6770 : 		{
; 6771 : 			if(pBuildInfo->getRoute() != NO_ROUTE)

	mov	ecx, DWORD PTR _pBuildInfo$226288[ebp]
	call	?getRoute@CvBuildInfo@@QBEHXZ		; CvBuildInfo::getRoute
	cmp	eax, -1
	je	$LN9@processTec

; 6772 : 			{
; 6773 : #ifdef AUI_WARNING_FIXES
; 6774 : 				for (uint iK = 0; iK < GC.getMap().numPlots(); iK++)
; 6775 : 				{
; 6776 : 					pLoopPlot = GC.getMap().plotByIndexUnchecked(iK);
; 6777 : #else
; 6778 : 				for(iJ = 0; iJ < GC.getMap().numPlots(); iJ++)

	mov	DWORD PTR _iJ$[ebp], 0
	jmp	SHORT $LN7@processTec
$LN6@processTec:
	mov	ecx, DWORD PTR _iJ$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iJ$[ebp], ecx
$LN7@processTec:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T238130[ebp], edx
	mov	eax, DWORD PTR $T238130[ebp]
	mov	ecx, DWORD PTR [eax+4028]
	mov	DWORD PTR $T238134[ebp], ecx
	mov	edx, DWORD PTR _iJ$[ebp]
	cmp	edx, DWORD PTR $T238134[ebp]
	jge	SHORT $LN9@processTec

; 6779 : 				{
; 6780 : 					pLoopPlot = GC.getMap().plotByIndexUnchecked(iJ);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T238138[ebp], eax
	mov	ecx, DWORD PTR _iJ$[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T238138[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR _pLoopPlot$[ebp], ecx

; 6781 : #endif
; 6782 : 
; 6783 : 					pCity = pLoopPlot->getPlotCity();

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pCity$[ebp], eax

; 6784 : 
; 6785 : 					if(pCity != NULL)

	cmp	DWORD PTR _pCity$[ebp], 0
	je	SHORT $LN4@processTec

; 6786 : 					{
; 6787 : 						if(pCity->getTeam() == GetID())

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	esi, eax
	jne	SHORT $LN4@processTec

; 6788 : 						{
; 6789 : 							pLoopPlot->updateCityRoute();

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?updateCityRoute@CvPlot@@QAEXXZ		; CvPlot::updateCityRoute
$LN4@processTec:

; 6790 : 						}
; 6791 : 					}
; 6792 : 				}

	jmp	$LN6@processTec
$LN9@processTec:

; 6793 : 			}
; 6794 : 		}
; 6795 : 	}

	jmp	$LN11@processTec
$LN10@processTec:

; 6796 : 
; 6797 : 	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	eax, DWORD PTR $T238150[ebp]
	mov	DWORD PTR tv742[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv742[ebp], ecx
	mov	edx, DWORD PTR tv742[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv742[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	DWORD PTR _pkScriptSystem$[ebp], eax

; 6798 : 	if(pkScriptSystem)

	cmp	DWORD PTR _pkScriptSystem$[ebp], 0
	je	$LN2@processTec

; 6799 : 	{
; 6800 : 		CvLuaArgsHandle args(3);

	push	3
	lea	ecx, DWORD PTR _args$226299[ebp]
	call	??0CvLuaArgsHandle@@QAE@I@Z		; CvLuaArgsHandle::CvLuaArgsHandle
	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 6801 : 		args->Push(GetID());

	mov	eax, DWORD PTR _args$226299[ebp]
	mov	DWORD PTR tv754[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	ecx, DWORD PTR tv754[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv754[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 6802 : 		args->Push(eTech);

	mov	ecx, DWORD PTR _args$226299[ebp]
	mov	DWORD PTR tv763[ebp], ecx
	mov	edx, DWORD PTR _eTech$[ebp]
	push	edx
	mov	eax, DWORD PTR tv763[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv763[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 6803 : 		args->Push(iChange);

	mov	ecx, DWORD PTR _args$226299[ebp]
	mov	DWORD PTR tv770[ebp], ecx
	mov	edx, DWORD PTR _iChange$[ebp]
	push	edx
	mov	eax, DWORD PTR tv770[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv770[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 6804 : 
; 6805 : 		bool bResult;
; 6806 : 		LuaSupport::CallHook(pkScriptSystem, "TeamTechResearched", args.get(), bResult);

	lea	ecx, DWORD PTR _bResult$226300[ebp]
	push	ecx
	mov	edx, DWORD PTR _args$226299[ebp]
	push	edx
	push	OFFSET ??_C@_0BD@IGMPLOJL@TeamTechResearched?$AA@
	mov	eax, DWORD PTR _pkScriptSystem$[ebp]
	push	eax
	call	?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallHook
	add	esp, 16					; 00000010H

; 6807 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _args$226299[ebp]
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN2@processTec:

; 6808 : 
; 6809 : 	// End game!
; 6810 : 	if(pTech->IsEndsGame())

	mov	ecx, DWORD PTR _pTech$[ebp]
	call	?IsEndsGame@CvTechEntry@@QBE_NXZ	; CvTechEntry::IsEndsGame
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN103@processTec

; 6811 : 	{
; 6812 : 		GC.getGame().SetEndGameTechResearched(true);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T238166[ebp], edx
	push	1
	mov	ecx, DWORD PTR $T238166[ebp]
	call	?SetEndGameTechResearched@CvGame@@QAEX_N@Z ; CvGame::SetEndGameTechResearched
$LN103@processTec:

; 6813 : 	}
; 6814 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?processTech@CvTeam@@IAEXW4TechTypes@@H@Z$0:
	lea	ecx, DWORD PTR _strText$226225[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?processTech@CvTeam@@IAEXW4TechTypes@@H@Z$1:
	lea	ecx, DWORD PTR _strSummary$226228[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?processTech@CvTeam@@IAEXW4TechTypes@@H@Z$2:
	lea	ecx, DWORD PTR _args$226299[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__ehhandler$?processTech@CvTeam@@IAEXW4TechTypes@@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-376]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?processTech@CvTeam@@IAEXW4TechTypes@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?processTech@CvTeam@@IAEXW4TechTypes@@H@Z ENDP		; CvTeam::processTech
PUBLIC	?cancelDefensivePacts@CvTeam@@IAEXXZ		; CvTeam::cancelDefensivePacts
; Function compile flags: /Odtp
;	COMDAT ?cancelDefensivePacts@CvTeam@@IAEXXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
_kTeam$226312 = -12					; size = 4
_eTeam$226310 = -8					; size = 4
_iI$ = -4						; size = 4
?cancelDefensivePacts@CvTeam@@IAEXXZ PROC		; CvTeam::cancelDefensivePacts, COMDAT
; _this$ = ecx

; 6819 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 6820 : 	int iI;
; 6821 : 
; 6822 : 	for(iI = 0; iI < MAX_TEAMS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN6@cancelDefe
$LN5@cancelDefe:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN6@cancelDefe:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	SHORT $LN7@cancelDefe

; 6823 : 	{
; 6824 : 		TeamTypes eTeam = (TeamTypes)iI;

	mov	ecx, DWORD PTR _iI$[ebp]
	mov	DWORD PTR _eTeam$226310[ebp], ecx

; 6825 : 		CvTeam& kTeam = GET_TEAM(eTeam);

	mov	edx, DWORD PTR _eTeam$226310[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR _kTeam$226312[ebp], edx

; 6826 : 
; 6827 : 		if(eTeam != GetID())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR _eTeam$226310[ebp], eax
	je	SHORT $LN3@cancelDefe

; 6828 : 		{
; 6829 : 			if(kTeam.isAlive())

	mov	eax, DWORD PTR _kTeam$226312[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+12], 0
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN3@cancelDefe

; 6830 : 			{
; 6831 : 				if(IsHasDefensivePact(eTeam))

	mov	eax, DWORD PTR _eTeam$226310[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHasDefensivePact@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsHasDefensivePact
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@cancelDefe

; 6832 : 				{
; 6833 : 					SetHasDefensivePact(eTeam, false);

	push	0
	mov	edx, DWORD PTR _eTeam$226310[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasDefensivePact

; 6834 : 					kTeam.SetHasDefensivePact(GetID(), false);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	ecx, DWORD PTR _kTeam$226312[ebp]
	call	?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasDefensivePact
$LN3@cancelDefe:

; 6835 : 				}
; 6836 : 			}
; 6837 : 		}

	jmp	SHORT $LN5@cancelDefe
$LN7@cancelDefe:

; 6838 : 	}
; 6839 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?cancelDefensivePacts@CvTeam@@IAEXXZ ENDP		; CvTeam::cancelDefensivePacts
_TEXT	ENDS
PUBLIC	?isFriendlyTerritory@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::isFriendlyTerritory
; Function compile flags: /Odtp
;	COMDAT ?isFriendlyTerritory@CvTeam@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eTeam$ = 8						; size = 4
?isFriendlyTerritory@CvTeam@@QBE_NW4TeamTypes@@@Z PROC	; CvTeam::isFriendlyTerritory, COMDAT
; _this$ = ecx

; 6844 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 6845 : 	if(eTeam == NO_TEAM)

	cmp	DWORD PTR _eTeam$[ebp], -1
	jne	SHORT $LN2@isFriendly

; 6846 : 	{
; 6847 : 		return false;

	xor	al, al
	jmp	SHORT $LN3@isFriendly
$LN2@isFriendly:

; 6848 : 	}
; 6849 : 
; 6850 : 	if(eTeam == GetID())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR _eTeam$[ebp], eax
	jne	SHORT $LN1@isFriendly

; 6851 : 	{
; 6852 : 		return true;

	mov	al, 1
	jmp	SHORT $LN3@isFriendly
$LN1@isFriendly:

; 6853 : 	}
; 6854 : 
; 6855 : 	return false;

	xor	al, al
$LN3@isFriendly:

; 6856 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isFriendlyTerritory@CvTeam@@QBE_NW4TeamTypes@@@Z ENDP	; CvTeam::isFriendlyTerritory
_TEXT	ENDS
PUBLIC	?isAtWarWithHumans@CvTeam@@QBE_NXZ		; CvTeam::isAtWarWithHumans
; Function compile flags: /Odtp
;	COMDAT ?isAtWarWithHumans@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_oppTeam$226329 = -8					; size = 4
_oppTeamIdx$226325 = -4					; size = 4
?isAtWarWithHumans@CvTeam@@QBE_NXZ PROC			; CvTeam::isAtWarWithHumans, COMDAT
; _this$ = ecx

; 6861 : {//are we currently fighting a war with a human controlled civ?

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 6862 : 	for(int oppTeamIdx = 0; oppTeamIdx < MAX_TEAMS; ++oppTeamIdx)

	mov	DWORD PTR _oppTeamIdx$226325[ebp], 0
	jmp	SHORT $LN4@isAtWarWit
$LN3@isAtWarWit:
	mov	eax, DWORD PTR _oppTeamIdx$226325[ebp]
	add	eax, 1
	mov	DWORD PTR _oppTeamIdx$226325[ebp], eax
$LN4@isAtWarWit:
	cmp	DWORD PTR _oppTeamIdx$226325[ebp], 64	; 00000040H
	jge	SHORT $LN2@isAtWarWit

; 6863 : 	{
; 6864 : 		CvTeam& oppTeam = GET_TEAM((TeamTypes)oppTeamIdx);

	mov	ecx, DWORD PTR _oppTeamIdx$226325[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR _oppTeam$226329[ebp], ecx

; 6865 : 		if(oppTeam.isAlive() && isAtWar((TeamTypes)oppTeamIdx) && oppTeam.isHuman())

	mov	edx, DWORD PTR _oppTeam$226329[ebp]
	xor	eax, eax
	cmp	DWORD PTR [edx+12], 0
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@isAtWarWit
	mov	edx, DWORD PTR _oppTeamIdx$226325[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@isAtWarWit
	mov	ecx, DWORD PTR _oppTeam$226329[ebp]
	call	?isHuman@CvTeam@@QBE_NXZ		; CvTeam::isHuman
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@isAtWarWit

; 6866 : 		{//we're at war with a human team
; 6867 : 			return true;

	mov	al, 1
	jmp	SHORT $LN5@isAtWarWit
$LN1@isAtWarWit:

; 6868 : 		}
; 6869 : 	}

	jmp	SHORT $LN3@isAtWarWit
$LN2@isAtWarWit:

; 6870 : 	return false;

	xor	al, al
$LN5@isAtWarWit:

; 6871 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isAtWarWithHumans@CvTeam@@QBE_NXZ ENDP			; CvTeam::isAtWarWithHumans
_TEXT	ENDS
PUBLIC	?isSimultaneousTurns@CvTeam@@QBE_NXZ		; CvTeam::isSimultaneousTurns
EXTRN	?isSimultaneousTurns@CvPlayer@@QBE_NXZ:PROC	; CvPlayer::isSimultaneousTurns
; Function compile flags: /Odtp
;	COMDAT ?isSimultaneousTurns@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T238213 = -16						; size = 4
$T238204 = -9						; size = 1
_kPlayer$226340 = -8					; size = 4
_iPlayer$226336 = -4					; size = 4
?isSimultaneousTurns@CvTeam@@QBE_NXZ PROC		; CvTeam::isSimultaneousTurns, COMDAT
; _this$ = ecx

; 6875 : {//determine if this team is running simultaneous turns or not.

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 6876 : 	for(int iPlayer = 0; iPlayer < MAX_PLAYERS; ++iPlayer)

	mov	DWORD PTR _iPlayer$226336[ebp], 0
	jmp	SHORT $LN4@isSimultan
$LN3@isSimultan:
	mov	eax, DWORD PTR _iPlayer$226336[ebp]
	add	eax, 1
	mov	DWORD PTR _iPlayer$226336[ebp], eax
$LN4@isSimultan:
	cmp	DWORD PTR _iPlayer$226336[ebp], 64	; 00000040H
	jge	SHORT $LN2@isSimultan

; 6877 : 	{
; 6878 : 		CvPlayer& kPlayer = GET_PLAYER((PlayerTypes)iPlayer);

	mov	ecx, DWORD PTR _iPlayer$226336[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$226340[ebp], ecx

; 6879 : 		if(kPlayer.isAlive() && kPlayer.getTeam() == GetID())

	mov	edx, DWORD PTR _kPlayer$226340[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T238204[ebp], al
	movzx	ecx, BYTE PTR $T238204[ebp]
	test	ecx, ecx
	je	SHORT $LN1@isSimultan
	mov	edx, DWORD PTR _kPlayer$226340[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T238213[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T238213[ebp], eax
	jne	SHORT $LN1@isSimultan

; 6880 : 		{
; 6881 : 			//just use the status of the first player we find for this team.
; 6882 : 			return kPlayer.isSimultaneousTurns();

	mov	ecx, DWORD PTR _kPlayer$226340[ebp]
	call	?isSimultaneousTurns@CvPlayer@@QBE_NXZ	; CvPlayer::isSimultaneousTurns
	jmp	SHORT $LN5@isSimultan
$LN1@isSimultan:

; 6883 : 		}
; 6884 : 	}

	jmp	SHORT $LN3@isSimultan
$LN2@isSimultan:

; 6885 : 
; 6886 : 	return false;

	xor	al, al
$LN5@isSimultan:

; 6887 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isSimultaneousTurns@CvTeam@@QBE_NXZ ENDP		; CvTeam::isSimultaneousTurns
_TEXT	ENDS
PUBLIC	?erase@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::erase
PUBLIC	?push_back@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEXABW4ResourceTypes@@@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::push_back
; Function compile flags: /Odtp
;	COMDAT ?setForceRevealedResource@CvTeam@@QAEXW4ResourceTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -120						; size = 4
$T238434 = -116						; size = 4
$T238430 = -112						; size = 4
$T238426 = -108						; size = 4
$T238296 = -60						; size = 4
$T238272 = -56						; size = 4
$T238219 = -28						; size = 4
$T238218 = -24						; size = 4
$T238217 = -20						; size = 4
$T238216 = -16						; size = 4
_pLoopPlot$226515 = -12					; size = 4
_iI$226511 = -8						; size = 4
_it$226502 = -4						; size = 4
_eResource$ = 8						; size = 4
_bRevealed$ = 12					; size = 1
?setForceRevealedResource@CvTeam@@QAEXW4ResourceTypes@@_N@Z PROC ; CvTeam::setForceRevealedResource, COMDAT
; _this$ = ecx

; 6892 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	mov	DWORD PTR _this$[ebp], ecx

; 6893 : 	if(isForceRevealedResource(eResource) == bRevealed)

	mov	eax, DWORD PTR _eResource$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isForceRevealedResource@CvTeam@@QBE_NW4ResourceTypes@@@Z ; CvTeam::isForceRevealedResource
	movzx	ecx, al
	movzx	edx, BYTE PTR _bRevealed$[ebp]
	cmp	ecx, edx
	jne	SHORT $LN11@setForceRe

; 6894 : 	{
; 6895 : 		return;

	jmp	$LN12@setForceRe
$LN11@setForceRe:

; 6896 : 	}
; 6897 : 
; 6898 : 	if(bRevealed)

	movzx	eax, BYTE PTR _bRevealed$[ebp]
	test	eax, eax
	je	SHORT $LN10@setForceRe

; 6899 : 	{
; 6900 : 		m_aeRevealedResources.push_back(eResource);

	lea	ecx, DWORD PTR _eResource$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2964				; 00000b94H
	call	?push_back@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEXABW4ResourceTypes@@@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::push_back

; 6901 : 	}
; 6902 : 	else

	jmp	$LN9@setForceRe
$LN10@setForceRe:

; 6903 : 	{
; 6904 : 		std::vector<ResourceTypes>::iterator it;

	mov	DWORD PTR _it$226502[ebp], 0

; 6905 : 
; 6906 : 		for(it = m_aeRevealedResources.begin(); it != m_aeRevealedResources.end(); ++it)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2968]
	mov	DWORD PTR $T238272[ebp], eax
	mov	ecx, DWORD PTR $T238272[ebp]
	mov	DWORD PTR $T238216[ebp], ecx
	mov	edx, DWORD PTR $T238216[ebp]
	mov	DWORD PTR _it$226502[ebp], edx
	jmp	SHORT $LN8@setForceRe
$LN7@setForceRe:
	mov	eax, DWORD PTR _it$226502[ebp]
	add	eax, 4
	mov	DWORD PTR _it$226502[ebp], eax
$LN8@setForceRe:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2972]
	mov	DWORD PTR $T238296[ebp], edx
	mov	eax, DWORD PTR $T238296[ebp]
	mov	DWORD PTR $T238217[ebp], eax
	mov	ecx, DWORD PTR _it$226502[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T238217[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN9@setForceRe

; 6907 : 		{
; 6908 : 			if(*it == eResource)

	mov	edx, DWORD PTR _it$226502[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _eResource$[ebp]
	jne	SHORT $LN5@setForceRe

; 6909 : 			{
; 6910 : 				m_aeRevealedResources.erase(it);

	mov	ecx, DWORD PTR _it$226502[ebp]
	mov	DWORD PTR $T238218[ebp], ecx
	mov	edx, DWORD PTR $T238218[ebp]
	push	edx
	lea	eax, DWORD PTR $T238219[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2964				; 00000b94H
	call	?erase@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::erase

; 6911 : 				break;

	jmp	SHORT $LN9@setForceRe
$LN5@setForceRe:

; 6912 : 			}
; 6913 : 		}

	jmp	SHORT $LN7@setForceRe
$LN9@setForceRe:

; 6914 : 	}
; 6915 : 
; 6916 : #ifdef AUI_WARNING_FIXES
; 6917 : 	for (uint iI = 0; iI < GC.getMap().numPlots(); ++iI)
; 6918 : #else
; 6919 : 	for(int iI = 0; iI < GC.getMap().numPlots(); ++iI)

	mov	DWORD PTR _iI$226511[ebp], 0
	jmp	SHORT $LN4@setForceRe
$LN3@setForceRe:
	mov	ecx, DWORD PTR _iI$226511[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$226511[ebp], ecx
$LN4@setForceRe:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T238426[ebp], edx
	mov	eax, DWORD PTR $T238426[ebp]
	mov	ecx, DWORD PTR [eax+4028]
	mov	DWORD PTR $T238430[ebp], ecx
	mov	edx, DWORD PTR _iI$226511[ebp]
	cmp	edx, DWORD PTR $T238430[ebp]
	jge	SHORT $LN12@setForceRe

; 6920 : #endif
; 6921 : 	{
; 6922 : 		CvPlot* pLoopPlot = GC.getMap().plotByIndexUnchecked(iI);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T238434[ebp], eax
	mov	ecx, DWORD PTR _iI$226511[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T238434[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR _pLoopPlot$226515[ebp], ecx

; 6923 : 
; 6924 : 		if(pLoopPlot->getResourceType() == eResource)

	push	-1
	mov	ecx, DWORD PTR _pLoopPlot$226515[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	cmp	eax, DWORD PTR _eResource$[ebp]
	jne	SHORT $LN1@setForceRe

; 6925 : 		{
; 6926 : 			pLoopPlot->updateYield();

	mov	ecx, DWORD PTR _pLoopPlot$226515[ebp]
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield

; 6927 : 			pLoopPlot->setLayoutDirty(true);

	push	1
	mov	ecx, DWORD PTR _pLoopPlot$226515[ebp]
	call	?setLayoutDirty@CvPlot@@QAEX_N@Z	; CvPlot::setLayoutDirty
$LN1@setForceRe:

; 6928 : 		}

	jmp	SHORT $LN3@setForceRe
$LN12@setForceRe:

; 6929 : 	}
; 6930 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?setForceRevealedResource@CvTeam@@QAEXW4ResourceTypes@@_N@Z ENDP ; CvTeam::setForceRevealedResource
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isForceRevealedResource@CvTeam@@QBE_NW4ResourceTypes@@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T238461 = -20						; size = 4
$T238449 = -16						; size = 4
$T238441 = -12						; size = 4
$T238440 = -8						; size = 4
_it$ = -4						; size = 4
_eResource$ = 8						; size = 4
?isForceRevealedResource@CvTeam@@QBE_NW4ResourceTypes@@@Z PROC ; CvTeam::isForceRevealedResource, COMDAT
; _this$ = ecx

; 6934 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 6935 : 	std::vector<ResourceTypes>::const_iterator it;

	mov	DWORD PTR _it$[ebp], 0

; 6936 : 
; 6937 : 	for(it = m_aeRevealedResources.begin(); it != m_aeRevealedResources.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2968]
	mov	DWORD PTR $T238449[ebp], ecx
	mov	edx, DWORD PTR $T238449[ebp]
	mov	DWORD PTR $T238440[ebp], edx
	mov	eax, DWORD PTR $T238440[ebp]
	mov	DWORD PTR _it$[ebp], eax
	jmp	SHORT $LN4@isForceRev
$LN3@isForceRev:
	mov	ecx, DWORD PTR _it$[ebp]
	add	ecx, 4
	mov	DWORD PTR _it$[ebp], ecx
$LN4@isForceRev:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2972]
	mov	DWORD PTR $T238461[ebp], eax
	mov	ecx, DWORD PTR $T238461[ebp]
	mov	DWORD PTR $T238441[ebp], ecx
	mov	edx, DWORD PTR _it$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T238441[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@isForceRev

; 6938 : 	{
; 6939 : 		if(*it == eResource)

	mov	eax, DWORD PTR _it$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _eResource$[ebp]
	jne	SHORT $LN1@isForceRev

; 6940 : 		{
; 6941 : 			return true;

	mov	al, 1
	jmp	SHORT $LN5@isForceRev
$LN1@isForceRev:

; 6942 : 		}
; 6943 : 	}

	jmp	SHORT $LN3@isForceRev
$LN2@isForceRev:

; 6944 : 
; 6945 : 	return false;

	xor	al, al
$LN5@isForceRev:

; 6946 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isForceRevealedResource@CvTeam@@QBE_NW4ResourceTypes@@@Z ENDP ; CvTeam::isForceRevealedResource
_TEXT	ENDS
PUBLIC	?IsResourceObsolete@CvTeam@@QAE_NW4ResourceTypes@@@Z ; CvTeam::IsResourceObsolete
EXTRN	?getAIStopTradingEra@CvResourceInfo@@QBEHXZ:PROC ; CvResourceInfo::getAIStopTradingEra
; Function compile flags: /Odtp
;	COMDAT ?IsResourceObsolete@CvTeam@@QAE_NW4ResourceTypes@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_eObsoleteEra$ = -8					; size = 4
_pResource$ = -4					; size = 4
_eResource$ = 8						; size = 4
?IsResourceObsolete@CvTeam@@QAE_NW4ResourceTypes@@@Z PROC ; CvTeam::IsResourceObsolete, COMDAT
; _this$ = ecx

; 6951 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 6952 : 	CvResourceInfo* pResource = GC.getResourceInfo(eResource);

	mov	eax, DWORD PTR _eResource$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	DWORD PTR _pResource$[ebp], eax

; 6953 : 
; 6954 : 	if(pResource == NULL)

	cmp	DWORD PTR _pResource$[ebp], 0
	jne	SHORT $LN4@IsResource

; 6955 : 		return false;

	xor	al, al
	jmp	SHORT $LN5@IsResource
$LN4@IsResource:

; 6956 : 
; 6957 : 	// If this is a luxury or bonus resource it doesn't go obsolete
; 6958 : 	if(pResource->getResourceUsage() != RESOURCEUSAGE_STRATEGIC)

	mov	ecx, DWORD PTR _pResource$[ebp]
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	cmp	eax, 1
	je	SHORT $LN3@IsResource

; 6959 : 		return false;

	xor	al, al
	jmp	SHORT $LN5@IsResource
$LN3@IsResource:

; 6960 : 
; 6961 : 	EraTypes eObsoleteEra = (EraTypes) pResource->getAIStopTradingEra();

	mov	ecx, DWORD PTR _pResource$[ebp]
	call	?getAIStopTradingEra@CvResourceInfo@@QBEHXZ ; CvResourceInfo::getAIStopTradingEra
	mov	DWORD PTR _eObsoleteEra$[ebp], eax

; 6962 : 
; 6963 : 	// AI will always trade for this
; 6964 : 	if(eObsoleteEra == NO_ERA)

	cmp	DWORD PTR _eObsoleteEra$[ebp], -1
	jne	SHORT $LN2@IsResource

; 6965 : 		return false;

	xor	al, al
	jmp	SHORT $LN5@IsResource
$LN2@IsResource:

; 6966 : 
; 6967 : 	// Not obsolete yet
; 6968 : 	if(GetCurrentEra() < eObsoleteEra)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCurrentEra@CvTeam@@QBE?AW4EraTypes@@XZ ; CvTeam::GetCurrentEra
	cmp	eax, DWORD PTR _eObsoleteEra$[ebp]
	jge	SHORT $LN1@IsResource

; 6969 : 		return false;

	xor	al, al
	jmp	SHORT $LN5@IsResource
$LN1@IsResource:

; 6970 : 
; 6971 : 	return true;

	mov	al, 1
$LN5@IsResource:

; 6972 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsResourceObsolete@CvTeam@@QAE_NW4ResourceTypes@@@Z ENDP ; CvTeam::IsResourceObsolete
_TEXT	ENDS
PUBLIC	?HasTechForWorldCongress@CvTeam@@QBE_NXZ	; CvTeam::HasTechForWorldCongress
; Function compile flags: /Odtp
;	COMDAT ?HasTechForWorldCongress@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?HasTechForWorldCongress@CvTeam@@QBE_NXZ PROC		; CvTeam::HasTechForWorldCongress, COMDAT
; _this$ = ecx

; 6977 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 6978 : 	return m_bHasTechForWorldCongress;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+131]

; 6979 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?HasTechForWorldCongress@CvTeam@@QBE_NXZ ENDP		; CvTeam::HasTechForWorldCongress
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?SetHasTechForWorldCongress@CvTeam@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bValue$ = 8						; size = 1
?SetHasTechForWorldCongress@CvTeam@@QAEX_N@Z PROC	; CvTeam::SetHasTechForWorldCongress, COMDAT
; _this$ = ecx

; 6983 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 6984 : 	m_bHasTechForWorldCongress = bValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _bValue$[ebp]
	mov	BYTE PTR [eax+131], cl

; 6985 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetHasTechForWorldCongress@CvTeam@@QAEX_N@Z ENDP	; CvTeam::SetHasTechForWorldCongress
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetCurrentEra@CvTeam@@QBE?AW4EraTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCurrentEra@CvTeam@@QBE?AW4EraTypes@@XZ PROC		; CvTeam::GetCurrentEra, COMDAT
; _this$ = ecx

; 6990 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 6991 : 	return m_eCurrentEra;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+136]

; 6992 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCurrentEra@CvTeam@@QBE?AW4EraTypes@@XZ ENDP		; CvTeam::GetCurrentEra
_TEXT	ENDS
PUBLIC	??_C@_0L@KKCIGKBH@TeamSetEra?$AA@		; `string'
PUBLIC	??_C@_0CG@MFJGCJKF@TXT_KEY_NTFN_MINOR_BONUSES_CHANG@ ; `string'
PUBLIC	??_C@_0CD@BPFEDDIG@TXT_KEY_NTFN_MINOR_BONUSES_CHANG@ ; `string'
PUBLIC	??$?6VString@Localization@@@@YAAAVString@Localization@@AAV01@ABV01@@Z ; operator<<<Localization::String>
PUBLIC	??_C@_0BF@MGALNDKL@TXT_KEY_UNMET_PLAYER?$AA@	; `string'
PUBLIC	??_C@_0BI@DCMOFOPN@TXT_KEY_NTFN_PLAYER_ERA?$AA@	; `string'
PUBLIC	__$ArrayPad$
EXTRN	?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@_N@Z:PROC ; CvPlot::getRevealedImprovementType
EXTRN	?ChangeNumFreePolicies@CvPlayer@@QAEXH@Z:PROC	; CvPlayer::ChangeNumFreePolicies
EXTRN	?getSpiesGrantedForEveryone@CvEraInfo@@QBEHXZ:PROC ; CvEraInfo::getSpiesGrantedForEveryone
EXTRN	?CreateSpy@CvPlayerEspionage@@QAEXXZ:PROC	; CvPlayerEspionage::CreateSpy
EXTRN	?GetNumSpies@CvPlayerEspionage@@QAEHXZ:PROC	; CvPlayerEspionage::GetNumSpies
EXTRN	?getSpiesGrantedForPlayer@CvEraInfo@@QBEHXZ:PROC ; CvEraInfo::getSpiesGrantedForPlayer
EXTRN	?DoMajorCivEraChange@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4EraTypes@@@Z:PROC ; CvMinorCivAI::DoMajorCivEraChange
EXTRN	?getNickName@CvPlayer@@QBEQBDXZ:PROC		; CvPlayer::getNickName
EXTRN	?getStartEra@CvGame@@QBE?AW4EraTypes@@XZ:PROC	; CvGame::getStartEra
;	COMDAT ??_C@_0L@KKCIGKBH@TeamSetEra?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaargshandle.h
CONST	SEGMENT
??_C@_0L@KKCIGKBH@TeamSetEra?$AA@ DB 'TeamSetEra', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@MFJGCJKF@TXT_KEY_NTFN_MINOR_BONUSES_CHANG@
CONST	SEGMENT
??_C@_0CG@MFJGCJKF@TXT_KEY_NTFN_MINOR_BONUSES_CHANG@ DB 'TXT_KEY_NTFN_MIN'
	DB	'OR_BONUSES_CHANGED_SM', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@BPFEDDIG@TXT_KEY_NTFN_MINOR_BONUSES_CHANG@
CONST	SEGMENT
??_C@_0CD@BPFEDDIG@TXT_KEY_NTFN_MINOR_BONUSES_CHANG@ DB 'TXT_KEY_NTFN_MIN'
	DB	'OR_BONUSES_CHANGED', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MGALNDKL@TXT_KEY_UNMET_PLAYER?$AA@
CONST	SEGMENT
??_C@_0BF@MGALNDKL@TXT_KEY_UNMET_PLAYER?$AA@ DB 'TXT_KEY_UNMET_PLAYER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DCMOFOPN@TXT_KEY_NTFN_PLAYER_ERA?$AA@
CONST	SEGMENT
??_C@_0BI@DCMOFOPN@TXT_KEY_NTFN_PLAYER_ERA?$AA@ DB 'TXT_KEY_NTFN_PLAYER_E'
	DB	'RA', 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z$4
	DD	01H
	DD	FLAT:__unwindfunclet$?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z$6
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z
_TEXT	SEGMENT
tv804 = -1464						; size = 4
tv795 = -1460						; size = 4
tv784 = -1456						; size = 4
tv772 = -1452						; size = 4
tv753 = -1448						; size = 4
tv727 = -1444						; size = 4
tv824 = -1440						; size = 4
tv78 = -1436						; size = 4
tv822 = -1432						; size = 4
tv243 = -1428						; size = 4
tv819 = -1424						; size = 4
tv81 = -1420						; size = 4
tv156 = -1416						; size = 4
_this$ = -1412						; size = 4
$T238803 = -1408					; size = 4
$T238799 = -1404					; size = 4
$T238795 = -1400					; size = 4
$T238791 = -1396					; size = 4
$T238787 = -1392					; size = 4
$T238783 = -1388					; size = 4
$T238779 = -1384					; size = 4
$T238775 = -1380					; size = 4
$T238766 = -1373					; size = 1
$T238754 = -1372					; size = 4
$T238750 = -1368					; size = 4
_playerID$238747 = -1364				; size = 4
$T238733 = -1360					; size = 4
$T238726 = -1356					; size = 4
$T238722 = -1352					; size = 4
$T238718 = -1348					; size = 4
$T238714 = -1344					; size = 4
$T238710 = -1340					; size = 4
$T238709 = -1336					; size = 4
$T238705 = -1332					; size = 4
$T238696 = -1325					; size = 1
$T238684 = -1324					; size = 4
$T238680 = -1317					; size = 1
$T238668 = -1316					; size = 4
$T238656 = -1309					; size = 1
$T238644 = -1308					; size = 4
$T238640 = -1304					; size = 4
$T238631 = -1297					; size = 1
$T238619 = -1296					; size = 4
$T238615 = -1292					; size = 4
$T238611 = -1288					; size = 4
$T238607 = -1281					; size = 1
$T238598 = -1280					; size = 4
$T238594 = -1273					; size = 1
$T238585 = -1272					; size = 4
$T238581 = -1268					; size = 4
$T238572 = -1264					; size = 4
$T238568 = -1260					; size = 4
$T238564 = -1256					; size = 4
$T238560 = -1252					; size = 4
$T238556 = -1248					; size = 4
$T238547 = -1241					; size = 1
$T238538 = -1240					; size = 4
$T238534 = -1236					; size = 4
$T238522 = -1232					; size = 4
$T238515 = -1228					; size = 4
$T238511 = -1224					; size = 4
$T238507 = -1220					; size = 4
$T238503 = -1216					; size = 4
$T238492 = -1212					; size = 80
$T238491 = -1132					; size = 80
$T238490 = -1052					; size = 4
$T238489 = -1048					; size = 4
$T238488 = -1044					; size = 80
_bResult$226700 = -961					; size = 1
_args$226699 = -960					; size = 4
_kPlayer$226693 = -956					; size = 4
_iPlayerLoop$226688 = -952				; size = 4
_iNumFreePolicies$226679 = -948				; size = 4
_kPlayer$226677 = -944					; size = 4
_iPlayerLoop$226672 = -940				; size = 4
_iIndex$226667 = -936					; size = 4
_iNumTraitSpies$226666 = -932				; size = 4
_i$226661 = -928					; size = 4
_kPlayer$226658 = -924					; size = 4
_iPlayerLoop$226653 = -920				; size = 4
_kPlayer$226649 = -916					; size = 4
_iPlayerLoop$226644 = -912				; size = 4
_ePlayer$226642 = -908					; size = 4
_bAlreadyProvided$226641 = -901				; size = 1
_eTeam$226643 = -900					; size = 4
_i$226636 = -896					; size = 4
_i$226632 = -892					; size = 4
_iNumTraitSpies$226631 = -888				; size = 4
_kPlayer$226628 = -884					; size = 4
_iPlayerLoop$226623 = -880				; size = 4
_ePlayer$226622 = -876					; size = 4
_iPlayerLoop$226601 = -872				; size = 4
_unmetPlayer$226590 = -868				; size = 80
_player$226584 = -784					; size = 4
_pkEraInfo$226581 = -780				; size = 4
_szEraTextKey$226582 = -776				; size = 4
_pNotifications$226576 = -772				; size = 4
_eNotifyPlayer$226573 = -768				; size = 4
_kCurNotifyPlayer$226575 = -764				; size = 4
_iNotifyLoop$226569 = -760				; size = 4
_kPopupInfo$226568 = -756				; size = 536
__$ArrayPad$ = -216					; size = 4
_bTemp$226563 = -209					; size = 1
_eLoopPlayer$226600 = -208				; size = 4
_strMessage$226564 = -204				; size = 80
_strSummary$226565 = -124				; size = 80
_iMinorLoop$226599 = -44				; size = 4
_bMinorBonusesChanged$226562 = -37			; size = 1
_eLoopMinor$226598 = -36				; size = 4
_pEraInfo$226620 = -32					; size = 4
_ePlayer$226671 = -28					; size = 4
_pkScriptSystem$226697 = -24				; size = 4
_iI$ = -20						; size = 4
_pLoopPlot$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_eNewValue$ = 8						; size = 4
?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z PROC		; CvTeam::SetCurrentEra, COMDAT
; _this$ = ecx

; 6997 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1452				; 000005acH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 6998 : 	CvPlot* pLoopPlot;
; 6999 : #ifdef AUI_WARNING_FIXES
; 7000 : 	uint iI;
; 7001 : #else
; 7002 : 	int iI;
; 7003 : #endif
; 7004 : 
; 7005 : 	if(GetCurrentEra() != eNewValue)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCurrentEra@CvTeam@@QBE?AW4EraTypes@@XZ ; CvTeam::GetCurrentEra
	cmp	eax, DWORD PTR _eNewValue$[ebp]
	je	$LN77@SetCurrent

; 7006 : 	{
; 7007 : 		if(!isMinorCiv())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	movzx	eax, al
	test	eax, eax
	jne	$LN75@SetCurrent

; 7008 : 		{
; 7009 : 			if(GC.getGame().isFinalInitialized())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T238503[ebp], ecx
	mov	ecx, DWORD PTR $T238503[ebp]
	call	?isFinalInitialized@CvGame@@QBE_NXZ	; CvGame::isFinalInitialized
	movzx	edx, al
	test	edx, edx
	je	$LN74@SetCurrent

; 7010 : 			{
; 7011 : 				bool bMinorBonusesChanged;
; 7012 : 				bool bTemp;
; 7013 : 				Localization::String strMessage;

	lea	ecx, DWORD PTR _strMessage$226564[ebp]
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 7014 : 				Localization::String strSummary;

	lea	ecx, DWORD PTR _strSummary$226565[ebp]
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 7015 : 
; 7016 : 				
; 7017 : 				if(!isBarbarian() && (eNewValue != GC.getGame().getStartEra())){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isBarbarian@CvTeam@@QBE_NXZ		; CvTeam::isBarbarian
	movzx	eax, al
	test	eax, eax
	jne	$LN73@SetCurrent
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T238507[ebp], ecx
	mov	ecx, DWORD PTR $T238507[ebp]
	call	?getStartEra@CvGame@@QBE?AW4EraTypes@@XZ ; CvGame::getStartEra
	cmp	DWORD PTR _eNewValue$[ebp], eax
	je	$LN73@SetCurrent

; 7018 : 					//Era Popup
; 7019 : 					if (!GC.getGame().isNetworkMultiPlayer() && isHuman() && GetID() == GC.getGame().getActiveTeam()){

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T238511[ebp], edx
	mov	ecx, DWORD PTR $T238511[ebp]
	call	?isNetworkMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isNetworkMultiPlayer
	movzx	eax, al
	test	eax, eax
	jne	$LN72@SetCurrent
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isHuman@CvTeam@@QBE_NXZ		; CvTeam::isHuman
	movzx	ecx, al
	test	ecx, ecx
	je	$LN72@SetCurrent
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T238515[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	mov	esi, eax
	mov	ecx, DWORD PTR $T238515[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	esi, eax
	jne	SHORT $LN72@SetCurrent

; 7020 : 						CvPopupInfo kPopupInfo(BUTTONPOPUP_NEW_ERA, eNewValue);

	mov	eax, DWORD PTR _eNewValue$[ebp]
	mov	DWORD PTR _kPopupInfo$226568[ebp], eax
	mov	DWORD PTR _kPopupInfo$226568[ebp+4], -1
	mov	DWORD PTR _kPopupInfo$226568[ebp+8], -1
	mov	DWORD PTR _kPopupInfo$226568[ebp+12], 0
	mov	BYTE PTR _kPopupInfo$226568[ebp+16], 0
	mov	BYTE PTR _kPopupInfo$226568[ebp+17], 0
	mov	DWORD PTR _kPopupInfo$226568[ebp+20], 55 ; 00000037H
	mov	BYTE PTR _kPopupInfo$226568[ebp+24], 0

; 7021 : 						DLLUI->AddPopup(kPopupInfo);

	mov	ecx, DWORD PTR $T238522[ebp]
	mov	DWORD PTR tv156[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv156[ebp], edx
	lea	eax, DWORD PTR _kPopupInfo$226568[ebp]
	push	eax
	mov	ecx, DWORD PTR tv156[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv156[ebp]
	mov	eax, DWORD PTR [edx+180]
	call	eax
$LN72@SetCurrent:

; 7022 : 					}
; 7023 : 
; 7024 : 					//Notify Everyone
; 7025 : 					for(int iNotifyLoop = 0; iNotifyLoop < MAX_MAJOR_CIVS; ++iNotifyLoop){

	mov	DWORD PTR _iNotifyLoop$226569[ebp], 0
	jmp	SHORT $LN71@SetCurrent
$LN70@SetCurrent:
	mov	ecx, DWORD PTR _iNotifyLoop$226569[ebp]
	add	ecx, 1
	mov	DWORD PTR _iNotifyLoop$226569[ebp], ecx
$LN71@SetCurrent:
	cmp	DWORD PTR _iNotifyLoop$226569[ebp], 22	; 00000016H
	jge	$LN73@SetCurrent

; 7026 : 						PlayerTypes eNotifyPlayer = (PlayerTypes) iNotifyLoop;

	mov	edx, DWORD PTR _iNotifyLoop$226569[ebp]
	mov	DWORD PTR _eNotifyPlayer$226573[ebp], edx

; 7027 : 						CvPlayerAI& kCurNotifyPlayer = GET_PLAYER(eNotifyPlayer);

	mov	eax, DWORD PTR _eNotifyPlayer$226573[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kCurNotifyPlayer$226575[ebp], eax

; 7028 : 						CvNotifications* pNotifications = kCurNotifyPlayer.GetNotifications();

	mov	ecx, DWORD PTR _kCurNotifyPlayer$226575[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotifications$226576[ebp], eax

; 7029 : 						if(pNotifications && 
; 7030 : 							(kCurNotifyPlayer.getTeam() != GetID() || GC.getGame().isNetworkMultiPlayer()) &&
; 7031 : 							kCurNotifyPlayer.isAlive()){

	cmp	DWORD PTR _pNotifications$226576[ebp], 0
	je	$LN68@SetCurrent
	mov	ecx, DWORD PTR _kCurNotifyPlayer$226575[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T238534[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T238534[ebp], eax
	jne	SHORT $LN108@SetCurrent
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T238538[ebp], eax
	mov	ecx, DWORD PTR $T238538[ebp]
	call	?isNetworkMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isNetworkMultiPlayer
	movzx	ecx, al
	test	ecx, ecx
	je	$LN68@SetCurrent
$LN108@SetCurrent:
	mov	edx, DWORD PTR _kCurNotifyPlayer$226575[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T238547[ebp], al
	movzx	ecx, BYTE PTR $T238547[ebp]
	test	ecx, ecx
	je	$LN68@SetCurrent

; 7032 : 							strMessage = Localization::Lookup("TXT_KEY_NTFN_PLAYER_ERA");

	push	OFFSET ??_C@_0BI@DCMOFOPN@TXT_KEY_NTFN_PLAYER_ERA?$AA@
	lea	edx, DWORD PTR $T238488[ebp]
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR tv81[ebp], eax
	mov	eax, DWORD PTR tv81[ebp]
	mov	DWORD PTR tv819[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR tv819[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strMessage$226564[ebp]
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T238488[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 7033 : 
; 7034 : 							CvEraInfo* pkEraInfo = GC.getEraInfo(eNewValue);

	mov	edx, DWORD PTR _eNewValue$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getEraInfo@CvGlobals@@QAEPAVCvEraInfo@@W4EraTypes@@@Z ; CvGlobals::getEraInfo
	mov	DWORD PTR _pkEraInfo$226581[ebp], eax

; 7035 : 							const char* szEraTextKey = pkEraInfo->GetTextKey();

	mov	ecx, DWORD PTR _pkEraInfo$226581[ebp]
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	mov	DWORD PTR _szEraTextKey$226582[ebp], eax

; 7036 : 
; 7037 : 							// Notify player has met this team
; 7038 : 							if(GET_TEAM(kCurNotifyPlayer.getTeam()).isHasMet(GetID()))

	mov	eax, DWORD PTR _kCurNotifyPlayer$226575[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T238556[ebp], eax
	mov	edx, DWORD PTR $T238556[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T238560[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	ecx, DWORD PTR $T238560[ebp]
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	movzx	eax, al
	test	eax, eax
	je	$LN66@SetCurrent

; 7039 : 							{
; 7040 : 								CvPlayerAI& player = GET_PLAYER(getLeaderID());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	mov	DWORD PTR $T238564[ebp], eax
	mov	ecx, DWORD PTR $T238564[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _player$226584[ebp], ecx

; 7041 : 								if(GC.getGame().isGameMultiPlayer() && player.isHuman())

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T238568[ebp], edx
	mov	ecx, DWORD PTR $T238568[ebp]
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN65@SetCurrent
	mov	ecx, DWORD PTR _player$226584[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN65@SetCurrent

; 7042 : 									strMessage << player.getNickName() << szEraTextKey;

	mov	ecx, DWORD PTR _player$226584[ebp]
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName
	mov	DWORD PTR $T238489[ebp], eax
	lea	edx, DWORD PTR _szEraTextKey$226582[ebp]
	push	edx
	lea	eax, DWORD PTR $T238489[ebp]
	push	eax
	lea	ecx, DWORD PTR _strMessage$226564[ebp]
	push	ecx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8
	push	eax
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 7043 : 								else

	jmp	SHORT $LN64@SetCurrent
$LN65@SetCurrent:

; 7044 : 									strMessage << player.getName() << szEraTextKey;

	mov	ecx, DWORD PTR _player$226584[ebp]
	call	?getName@CvPlayer@@QBEPBDXZ		; CvPlayer::getName
	mov	DWORD PTR $T238490[ebp], eax
	lea	edx, DWORD PTR _szEraTextKey$226582[ebp]
	push	edx
	lea	eax, DWORD PTR $T238490[ebp]
	push	eax
	lea	ecx, DWORD PTR _strMessage$226564[ebp]
	push	ecx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8
	push	eax
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8
$LN64@SetCurrent:

; 7045 : 							}
; 7046 : 
; 7047 : 							// Has not met this team
; 7048 : 							else

	jmp	SHORT $LN63@SetCurrent
$LN66@SetCurrent:

; 7049 : 							{
; 7050 : 								Localization::String unmetPlayer = Localization::Lookup("TXT_KEY_UNMET_PLAYER");

	push	OFFSET ??_C@_0BF@MGALNDKL@TXT_KEY_UNMET_PLAYER?$AA@
	lea	edx, DWORD PTR _unmetPlayer$226590[ebp]
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 7051 : 								strMessage << unmetPlayer << szEraTextKey;

	lea	eax, DWORD PTR _szEraTextKey$226582[ebp]
	push	eax
	lea	ecx, DWORD PTR _unmetPlayer$226590[ebp]
	push	ecx
	lea	edx, DWORD PTR _strMessage$226564[ebp]
	push	edx
	call	??$?6VString@Localization@@@@YAAAVString@Localization@@AAV01@ABV01@@Z ; operator<<<Localization::String>
	add	esp, 8
	push	eax
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 7052 : 							}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _unmetPlayer$226590[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN63@SetCurrent:

; 7053 : 
; 7054 : 							pNotifications->Add(NOTIFICATION_OTHER_PLAYER_NEW_ERA, strMessage.toUTF8(), strMessage.toUTF8(), -1, -1, -1);

	push	-1
	push	-1
	push	-1
	push	-1
	lea	ecx, DWORD PTR _strMessage$226564[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strMessage$226564[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	push	-66586748				; fc07f784H
	mov	ecx, DWORD PTR _pNotifications$226576[ebp]
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN68@SetCurrent:

; 7055 : 						}
; 7056 : 					}

	jmp	$LN70@SetCurrent
$LN73@SetCurrent:

; 7057 : 				}
; 7058 : 
; 7059 : 				// Apply Minor Civ changes BEFORE setting the new era
; 7060 : 				PlayerTypes eLoopMinor;
; 7061 : 				int iMinorLoop;
; 7062 : 
; 7063 : 				PlayerTypes eLoopPlayer;
; 7064 : 				for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	mov	DWORD PTR _iPlayerLoop$226601[ebp], 0
	jmp	SHORT $LN62@SetCurrent
$LN61@SetCurrent:
	mov	eax, DWORD PTR _iPlayerLoop$226601[ebp]
	add	eax, 1
	mov	DWORD PTR _iPlayerLoop$226601[ebp], eax
$LN62@SetCurrent:
	cmp	DWORD PTR _iPlayerLoop$226601[ebp], 22	; 00000016H
	jge	$LN60@SetCurrent

; 7065 : 				{
; 7066 : 					eLoopPlayer = (PlayerTypes) iPlayerLoop;

	mov	ecx, DWORD PTR _iPlayerLoop$226601[ebp]
	mov	DWORD PTR _eLoopPlayer$226600[ebp], ecx

; 7067 : 
; 7068 : 					// Must be on this team
; 7069 : 					if(GET_PLAYER(eLoopPlayer).getTeam() != GetID())

	mov	edx, DWORD PTR _eLoopPlayer$226600[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T238572[ebp], edx
	mov	eax, DWORD PTR $T238572[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T238581[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T238581[ebp], eax
	je	SHORT $LN59@SetCurrent

; 7070 : 						continue;

	jmp	SHORT $LN61@SetCurrent
$LN59@SetCurrent:

; 7071 : 
; 7072 : 					// Player not ever alive
; 7073 : 					if(!GET_PLAYER(eLoopPlayer).isEverAlive())

	mov	edx, DWORD PTR _eLoopPlayer$226600[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T238585[ebp], edx
	mov	eax, DWORD PTR $T238585[ebp]
	mov	cl, BYTE PTR [eax+2268]
	mov	BYTE PTR $T238594[ebp], cl
	movzx	edx, BYTE PTR $T238594[ebp]
	test	edx, edx
	jne	SHORT $LN58@SetCurrent

; 7074 : 						continue;

	jmp	$LN61@SetCurrent
$LN58@SetCurrent:

; 7075 : 
; 7076 : 					bMinorBonusesChanged = false;

	mov	BYTE PTR _bMinorBonusesChanged$226562[ebp], 0

; 7077 : 
; 7078 : 					for(iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)

	mov	DWORD PTR _iMinorLoop$226599[ebp], 22	; 00000016H
	jmp	SHORT $LN57@SetCurrent
$LN56@SetCurrent:
	mov	eax, DWORD PTR _iMinorLoop$226599[ebp]
	add	eax, 1
	mov	DWORD PTR _iMinorLoop$226599[ebp], eax
$LN57@SetCurrent:
	cmp	DWORD PTR _iMinorLoop$226599[ebp], 63	; 0000003fH
	jge	$LN55@SetCurrent

; 7079 : 					{
; 7080 : 						eLoopMinor = (PlayerTypes) iMinorLoop;

	mov	ecx, DWORD PTR _iMinorLoop$226599[ebp]
	mov	DWORD PTR _eLoopMinor$226598[ebp], ecx

; 7081 : 
; 7082 : 						// Minor not alive
; 7083 : 						if(!GET_PLAYER(eLoopMinor).isAlive())

	mov	edx, DWORD PTR _eLoopMinor$226598[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T238598[ebp], edx
	mov	eax, DWORD PTR $T238598[ebp]
	mov	cl, BYTE PTR [eax+2256]
	mov	BYTE PTR $T238607[ebp], cl
	movzx	edx, BYTE PTR $T238607[ebp]
	test	edx, edx
	jne	SHORT $LN54@SetCurrent

; 7084 : 							continue;

	jmp	SHORT $LN56@SetCurrent
$LN54@SetCurrent:

; 7085 : 
; 7086 : 						bTemp = GET_PLAYER(eLoopMinor).GetMinorCivAI()->DoMajorCivEraChange(eLoopPlayer, eNewValue);

	mov	eax, DWORD PTR _eLoopMinor$226598[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T238611[ebp], eax
	mov	ecx, DWORD PTR _eNewValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eLoopPlayer$226600[ebp]
	push	edx
	mov	ecx, DWORD PTR $T238611[ebp]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?DoMajorCivEraChange@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::DoMajorCivEraChange
	mov	BYTE PTR _bTemp$226563[ebp], al

; 7087 : 
; 7088 : 						if(bTemp)

	movzx	eax, BYTE PTR _bTemp$226563[ebp]
	test	eax, eax
	je	SHORT $LN53@SetCurrent

; 7089 : 							bMinorBonusesChanged = true;

	mov	BYTE PTR _bMinorBonusesChanged$226562[ebp], 1
$LN53@SetCurrent:

; 7090 : 					}

	jmp	$LN56@SetCurrent
$LN55@SetCurrent:

; 7091 : 
; 7092 : 					if(bMinorBonusesChanged)

	movzx	ecx, BYTE PTR _bMinorBonusesChanged$226562[ebp]
	test	ecx, ecx
	je	$LN52@SetCurrent

; 7093 : 					{
; 7094 : 						if(GET_PLAYER(eLoopPlayer).GetNotifications())

	mov	edx, DWORD PTR _eLoopPlayer$226600[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T238615[ebp], edx
	mov	ecx, DWORD PTR $T238615[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	test	eax, eax
	je	$LN52@SetCurrent

; 7095 : 						{
; 7096 : 							strMessage = Localization::Lookup("TXT_KEY_NTFN_MINOR_BONUSES_CHANGED");

	push	OFFSET ??_C@_0CD@BPFEDDIG@TXT_KEY_NTFN_MINOR_BONUSES_CHANG@
	lea	eax, DWORD PTR $T238491[ebp]
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR tv243[ebp], eax
	mov	ecx, DWORD PTR tv243[ebp]
	mov	DWORD PTR tv822[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	edx, DWORD PTR tv822[ebp]
	push	edx
	lea	ecx, DWORD PTR _strMessage$226564[ebp]
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T238491[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 7097 : 							strSummary = Localization::Lookup("TXT_KEY_NTFN_MINOR_BONUSES_CHANGED_SM");

	push	OFFSET ??_C@_0CG@MFJGCJKF@TXT_KEY_NTFN_MINOR_BONUSES_CHANG@
	lea	eax, DWORD PTR $T238492[ebp]
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR tv78[ebp], eax
	mov	ecx, DWORD PTR tv78[ebp]
	mov	DWORD PTR tv824[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	edx, DWORD PTR tv824[ebp]
	push	edx
	lea	ecx, DWORD PTR _strSummary$226565[ebp]
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T238492[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 7098 : 							GET_PLAYER(eLoopPlayer).GetNotifications()->Add(NOTIFICATION_MINOR, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, -1);

	mov	eax, DWORD PTR _eLoopPlayer$226600[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T238619[ebp], eax
	push	-1
	push	-1
	push	-1
	push	-1
	lea	ecx, DWORD PTR _strSummary$226565[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strMessage$226564[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	push	-967190754				; c659d71eH
	mov	ecx, DWORD PTR $T238619[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ecx, eax
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN52@SetCurrent:

; 7099 : 						}
; 7100 : 					}
; 7101 : 				}

	jmp	$LN61@SetCurrent
$LN60@SetCurrent:

; 7102 : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strSummary$226565[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strMessage$226564[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN74@SetCurrent:

; 7103 : 
; 7104 : 			CvEraInfo* pEraInfo = GC.getEraInfo(eNewValue);

	mov	ecx, DWORD PTR _eNewValue$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getEraInfo@CvGlobals@@QAEPAVCvEraInfo@@W4EraTypes@@@Z ; CvGlobals::getEraInfo
	mov	DWORD PTR _pEraInfo$226620[ebp], eax

; 7105 : 			if(pEraInfo->getSpiesGrantedForPlayer() > 0)

	mov	ecx, DWORD PTR _pEraInfo$226620[ebp]
	call	?getSpiesGrantedForPlayer@CvEraInfo@@QBEHXZ ; CvEraInfo::getSpiesGrantedForPlayer
	test	eax, eax
	jle	$LN50@SetCurrent

; 7106 : 			{
; 7107 : 				PlayerTypes ePlayer;
; 7108 : 				for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)

	mov	DWORD PTR _iPlayerLoop$226623[ebp], 0
	jmp	SHORT $LN49@SetCurrent
$LN48@SetCurrent:
	mov	edx, DWORD PTR _iPlayerLoop$226623[ebp]
	add	edx, 1
	mov	DWORD PTR _iPlayerLoop$226623[ebp], edx
$LN49@SetCurrent:
	cmp	DWORD PTR _iPlayerLoop$226623[ebp], 63	; 0000003fH
	jge	$LN50@SetCurrent

; 7109 : 				{
; 7110 : 					ePlayer = (PlayerTypes) iPlayerLoop;

	mov	eax, DWORD PTR _iPlayerLoop$226623[ebp]
	mov	DWORD PTR _ePlayer$226622[ebp], eax

; 7111 : 					CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);

	mov	ecx, DWORD PTR _ePlayer$226622[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$226628[ebp], ecx

; 7112 : 					if(kPlayer.isAlive() && kPlayer.getTeam() == GetID() && !kPlayer.isMinorCiv() && !kPlayer.isBarbarian())

	mov	edx, DWORD PTR _kPlayer$226628[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T238631[ebp], al
	movzx	ecx, BYTE PTR $T238631[ebp]
	test	ecx, ecx
	je	$LN46@SetCurrent
	mov	edx, DWORD PTR _kPlayer$226628[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T238640[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T238640[ebp], eax
	jne	$LN46@SetCurrent
	mov	ecx, DWORD PTR _kPlayer$226628[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN46@SetCurrent
	mov	ecx, DWORD PTR _kPlayer$226628[ebp]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	movzx	edx, al
	test	edx, edx
	jne	$LN46@SetCurrent

; 7113 : 					{
; 7114 : 						// provide the player with the extra spies according to their trait when they get their first spy
; 7115 : 						if (kPlayer.GetEspionage()->GetNumSpies() == 0)

	mov	ecx, DWORD PTR _kPlayer$226628[ebp]
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	ecx, eax
	call	?GetNumSpies@CvPlayerEspionage@@QAEHXZ	; CvPlayerEspionage::GetNumSpies
	test	eax, eax
	jne	SHORT $LN45@SetCurrent

; 7116 : 						{
; 7117 : 							int iNumTraitSpies = kPlayer.GetPlayerTraits()->GetExtraSpies();

	mov	ecx, DWORD PTR _kPlayer$226628[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T238644[ebp], eax
	mov	eax, DWORD PTR $T238644[ebp]
	mov	ecx, DWORD PTR [eax+272]
	mov	DWORD PTR _iNumTraitSpies$226631[ebp], ecx

; 7118 : 							for (int i = 0; i < iNumTraitSpies; i++)

	mov	DWORD PTR _i$226632[ebp], 0
	jmp	SHORT $LN44@SetCurrent
$LN43@SetCurrent:
	mov	edx, DWORD PTR _i$226632[ebp]
	add	edx, 1
	mov	DWORD PTR _i$226632[ebp], edx
$LN44@SetCurrent:
	mov	eax, DWORD PTR _i$226632[ebp]
	cmp	eax, DWORD PTR _iNumTraitSpies$226631[ebp]
	jge	SHORT $LN45@SetCurrent

; 7119 : 							{
; 7120 : 								kPlayer.GetEspionage()->CreateSpy();

	mov	ecx, DWORD PTR _kPlayer$226628[ebp]
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	ecx, eax
	call	?CreateSpy@CvPlayerEspionage@@QAEXXZ	; CvPlayerEspionage::CreateSpy

; 7121 : 							}

	jmp	SHORT $LN43@SetCurrent
$LN45@SetCurrent:

; 7122 : 						}
; 7123 : 
; 7124 : 						for(int i = 0; i < pEraInfo->getSpiesGrantedForPlayer(); i++)

	mov	DWORD PTR _i$226636[ebp], 0
	jmp	SHORT $LN41@SetCurrent
$LN40@SetCurrent:
	mov	ecx, DWORD PTR _i$226636[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$226636[ebp], ecx
$LN41@SetCurrent:
	mov	ecx, DWORD PTR _pEraInfo$226620[ebp]
	call	?getSpiesGrantedForPlayer@CvEraInfo@@QBEHXZ ; CvEraInfo::getSpiesGrantedForPlayer
	cmp	DWORD PTR _i$226636[ebp], eax
	jge	SHORT $LN46@SetCurrent

; 7125 : 						{
; 7126 : 							kPlayer.GetEspionage()->CreateSpy();

	mov	ecx, DWORD PTR _kPlayer$226628[ebp]
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	ecx, eax
	call	?CreateSpy@CvPlayerEspionage@@QAEXXZ	; CvPlayerEspionage::CreateSpy

; 7127 : 						}

	jmp	SHORT $LN40@SetCurrent
$LN46@SetCurrent:

; 7128 : 					}
; 7129 : 				}

	jmp	$LN48@SetCurrent
$LN50@SetCurrent:

; 7130 : 			}
; 7131 : 
; 7132 : 			if(pEraInfo->getSpiesGrantedForEveryone() > 0)

	mov	ecx, DWORD PTR _pEraInfo$226620[ebp]
	call	?getSpiesGrantedForEveryone@CvEraInfo@@QBEHXZ ; CvEraInfo::getSpiesGrantedForEveryone
	test	eax, eax
	jle	$LN75@SetCurrent

; 7133 : 			{
; 7134 : 				// check to see if anyone else has reached or surpassed this era yet
; 7135 : 				bool bAlreadyProvided = false;

	mov	BYTE PTR _bAlreadyProvided$226641[ebp], 0

; 7136 : 				PlayerTypes ePlayer;
; 7137 : 				TeamTypes eTeam;
; 7138 : 				for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)

	mov	DWORD PTR _iPlayerLoop$226644[ebp], 0
	jmp	SHORT $LN37@SetCurrent
$LN36@SetCurrent:
	mov	edx, DWORD PTR _iPlayerLoop$226644[ebp]
	add	edx, 1
	mov	DWORD PTR _iPlayerLoop$226644[ebp], edx
$LN37@SetCurrent:
	cmp	DWORD PTR _iPlayerLoop$226644[ebp], 63	; 0000003fH
	jge	$LN35@SetCurrent

; 7139 : 				{
; 7140 : 					ePlayer = (PlayerTypes) iPlayerLoop;

	mov	eax, DWORD PTR _iPlayerLoop$226644[ebp]
	mov	DWORD PTR _ePlayer$226642[ebp], eax

; 7141 : 					CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);

	mov	ecx, DWORD PTR _ePlayer$226642[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$226649[ebp], ecx

; 7142 : 					if (kPlayer.isEverAlive() && !kPlayer.isBarbarian() && !kPlayer.isMinorCiv())

	mov	edx, DWORD PTR _kPlayer$226649[ebp]
	mov	al, BYTE PTR [edx+2268]
	mov	BYTE PTR $T238656[ebp], al
	movzx	ecx, BYTE PTR $T238656[ebp]
	test	ecx, ecx
	je	SHORT $LN34@SetCurrent
	mov	ecx, DWORD PTR _kPlayer$226649[ebp]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN34@SetCurrent
	mov	ecx, DWORD PTR _kPlayer$226649[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN34@SetCurrent

; 7143 : 					{
; 7144 : 						eTeam = kPlayer.getTeam();

	mov	ecx, DWORD PTR _kPlayer$226649[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$226643[ebp], eax

; 7145 : 
; 7146 : 						if(GET_TEAM(eTeam).GetCurrentEra() >= eNewValue)

	mov	eax, DWORD PTR _eTeam$226643[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T238668[ebp], eax
	mov	ecx, DWORD PTR $T238668[ebp]
	call	?GetCurrentEra@CvTeam@@QBE?AW4EraTypes@@XZ ; CvTeam::GetCurrentEra
	cmp	eax, DWORD PTR _eNewValue$[ebp]
	jl	SHORT $LN34@SetCurrent

; 7147 : 						{
; 7148 : 							bAlreadyProvided = true;

	mov	BYTE PTR _bAlreadyProvided$226641[ebp], 1

; 7149 : 							break;

	jmp	SHORT $LN35@SetCurrent
$LN34@SetCurrent:

; 7150 : 						}
; 7151 : 					}
; 7152 : 				}

	jmp	$LN36@SetCurrent
$LN35@SetCurrent:

; 7153 : 
; 7154 : 				if(!bAlreadyProvided)

	movzx	ecx, BYTE PTR _bAlreadyProvided$226641[ebp]
	test	ecx, ecx
	jne	$LN75@SetCurrent

; 7155 : 				{
; 7156 : 					for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)

	mov	DWORD PTR _iPlayerLoop$226653[ebp], 0
	jmp	SHORT $LN31@SetCurrent
$LN30@SetCurrent:
	mov	edx, DWORD PTR _iPlayerLoop$226653[ebp]
	add	edx, 1
	mov	DWORD PTR _iPlayerLoop$226653[ebp], edx
$LN31@SetCurrent:
	cmp	DWORD PTR _iPlayerLoop$226653[ebp], 63	; 0000003fH
	jge	$LN75@SetCurrent

; 7157 : 					{
; 7158 : 						ePlayer = (PlayerTypes) iPlayerLoop;

	mov	eax, DWORD PTR _iPlayerLoop$226653[ebp]
	mov	DWORD PTR _ePlayer$226642[ebp], eax

; 7159 : 						CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);

	mov	ecx, DWORD PTR _ePlayer$226642[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$226658[ebp], ecx

; 7160 : 						if(!kPlayer.isAlive() || kPlayer.isBarbarian() || kPlayer.isMinorCiv())

	mov	edx, DWORD PTR _kPlayer$226658[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T238680[ebp], al
	movzx	ecx, BYTE PTR $T238680[ebp]
	test	ecx, ecx
	je	SHORT $LN27@SetCurrent
	mov	ecx, DWORD PTR _kPlayer$226658[ebp]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN27@SetCurrent
	mov	ecx, DWORD PTR _kPlayer$226658[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN28@SetCurrent
$LN27@SetCurrent:

; 7161 : 						{
; 7162 : 							continue;

	jmp	$LN30@SetCurrent
$LN28@SetCurrent:

; 7163 : 						}
; 7164 : 
; 7165 : 						for(int i = 0; i < pEraInfo->getSpiesGrantedForEveryone(); i++)

	mov	DWORD PTR _i$226661[ebp], 0
	jmp	SHORT $LN26@SetCurrent
$LN25@SetCurrent:
	mov	ecx, DWORD PTR _i$226661[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$226661[ebp], ecx
$LN26@SetCurrent:
	mov	ecx, DWORD PTR _pEraInfo$226620[ebp]
	call	?getSpiesGrantedForEveryone@CvEraInfo@@QBEHXZ ; CvEraInfo::getSpiesGrantedForEveryone
	cmp	DWORD PTR _i$226661[ebp], eax
	jge	$LN24@SetCurrent

; 7166 : 						{
; 7167 : 							// provide the player with the extra spies according to their trait when they get their first spy
; 7168 : 							if (kPlayer.GetEspionage()->GetNumSpies() == 0)

	mov	ecx, DWORD PTR _kPlayer$226658[ebp]
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	ecx, eax
	call	?GetNumSpies@CvPlayerEspionage@@QAEHXZ	; CvPlayerEspionage::GetNumSpies
	test	eax, eax
	jne	SHORT $LN23@SetCurrent

; 7169 : 							{
; 7170 : 								int iNumTraitSpies = kPlayer.GetPlayerTraits()->GetExtraSpies();

	mov	ecx, DWORD PTR _kPlayer$226658[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T238684[ebp], eax
	mov	edx, DWORD PTR $T238684[ebp]
	mov	eax, DWORD PTR [edx+272]
	mov	DWORD PTR _iNumTraitSpies$226666[ebp], eax

; 7171 : 								for (int iIndex = 0; iIndex < iNumTraitSpies; iIndex++)

	mov	DWORD PTR _iIndex$226667[ebp], 0
	jmp	SHORT $LN22@SetCurrent
$LN21@SetCurrent:
	mov	ecx, DWORD PTR _iIndex$226667[ebp]
	add	ecx, 1
	mov	DWORD PTR _iIndex$226667[ebp], ecx
$LN22@SetCurrent:
	mov	edx, DWORD PTR _iIndex$226667[ebp]
	cmp	edx, DWORD PTR _iNumTraitSpies$226666[ebp]
	jge	SHORT $LN23@SetCurrent

; 7172 : 								{
; 7173 : 									kPlayer.GetEspionage()->CreateSpy();

	mov	ecx, DWORD PTR _kPlayer$226658[ebp]
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	ecx, eax
	call	?CreateSpy@CvPlayerEspionage@@QAEXXZ	; CvPlayerEspionage::CreateSpy

; 7174 : 								}

	jmp	SHORT $LN21@SetCurrent
$LN23@SetCurrent:

; 7175 : 							}
; 7176 : 							kPlayer.GetEspionage()->CreateSpy();

	mov	ecx, DWORD PTR _kPlayer$226658[ebp]
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	ecx, eax
	call	?CreateSpy@CvPlayerEspionage@@QAEXXZ	; CvPlayerEspionage::CreateSpy

; 7177 : 						}

	jmp	$LN25@SetCurrent
$LN24@SetCurrent:

; 7178 : 					}

	jmp	$LN30@SetCurrent
$LN75@SetCurrent:

; 7179 : 				}
; 7180 : 			}
; 7181 : 		}
; 7182 : 
; 7183 : 		// Trait to provide free policies on era change?
; 7184 : 		PlayerTypes ePlayer;
; 7185 : 		for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)

	mov	DWORD PTR _iPlayerLoop$226672[ebp], 0
	jmp	SHORT $LN19@SetCurrent
$LN18@SetCurrent:
	mov	eax, DWORD PTR _iPlayerLoop$226672[ebp]
	add	eax, 1
	mov	DWORD PTR _iPlayerLoop$226672[ebp], eax
$LN19@SetCurrent:
	cmp	DWORD PTR _iPlayerLoop$226672[ebp], 63	; 0000003fH
	jge	$LN17@SetCurrent

; 7186 : 		{
; 7187 : 			ePlayer = (PlayerTypes) iPlayerLoop;

	mov	ecx, DWORD PTR _iPlayerLoop$226672[ebp]
	mov	DWORD PTR _ePlayer$226671[ebp], ecx

; 7188 : 			CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);

	mov	edx, DWORD PTR _ePlayer$226671[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$226677[ebp], edx

; 7189 : 			if(kPlayer.isAlive() && kPlayer.getTeam() == GetID() && !kPlayer.isMinorCiv() && !kPlayer.isBarbarian())

	mov	eax, DWORD PTR _kPlayer$226677[ebp]
	mov	cl, BYTE PTR [eax+2256]
	mov	BYTE PTR $T238696[ebp], cl
	movzx	edx, BYTE PTR $T238696[ebp]
	test	edx, edx
	je	$LN16@SetCurrent
	mov	eax, DWORD PTR _kPlayer$226677[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T238705[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T238705[ebp], eax
	jne	SHORT $LN16@SetCurrent
	mov	ecx, DWORD PTR _kPlayer$226677[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN16@SetCurrent
	mov	ecx, DWORD PTR _kPlayer$226677[ebp]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN16@SetCurrent

; 7190 : 			{
; 7191 : 				int iNumFreePolicies = kPlayer.GetPlayerTraits()->GetFreeSocialPoliciesPerEra() > 0;

	mov	ecx, DWORD PTR _kPlayer$226677[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T238709[ebp], eax
	mov	ecx, DWORD PTR $T238709[ebp]
	mov	edx, DWORD PTR [ecx+288]
	mov	DWORD PTR $T238710[ebp], edx
	xor	eax, eax
	cmp	DWORD PTR $T238710[ebp], 0
	setg	al
	mov	DWORD PTR _iNumFreePolicies$226679[ebp], eax

; 7192 : 				if (iNumFreePolicies > 0)

	cmp	DWORD PTR _iNumFreePolicies$226679[ebp], 0
	jle	SHORT $LN16@SetCurrent

; 7193 : 				{
; 7194 : 					kPlayer.ChangeNumFreePolicies(iNumFreePolicies);

	mov	ecx, DWORD PTR _iNumFreePolicies$226679[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kPlayer$226677[ebp]
	call	?ChangeNumFreePolicies@CvPlayer@@QAEXH@Z ; CvPlayer::ChangeNumFreePolicies
$LN16@SetCurrent:

; 7195 : 				}
; 7196 : 			}
; 7197 : 		}

	jmp	$LN18@SetCurrent
$LN17@SetCurrent:

; 7198 : 
; 7199 : 		m_eCurrentEra = eNewValue;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _eNewValue$[ebp]
	mov	DWORD PTR [edx+136], eax

; 7200 : 
; 7201 : 		if(GC.getGame().getActiveTeam() != NO_TEAM)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T238714[ebp], ecx
	mov	ecx, DWORD PTR $T238714[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	eax, -1
	je	$LN14@SetCurrent

; 7202 : 		{
; 7203 : 			for(iI = 0; iI < GC.getMap().numPlots(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN13@SetCurrent
$LN12@SetCurrent:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN13@SetCurrent:
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T238718[ebp], eax
	mov	ecx, DWORD PTR $T238718[ebp]
	mov	edx, DWORD PTR [ecx+4028]
	mov	DWORD PTR $T238722[ebp], edx
	mov	eax, DWORD PTR _iI$[ebp]
	cmp	eax, DWORD PTR $T238722[ebp]
	jge	$LN14@SetCurrent

; 7204 : 			{
; 7205 : 				pLoopPlot = GC.getMap().plotByIndexUnchecked(iI);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T238726[ebp], ecx
	mov	edx, DWORD PTR _iI$[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T238726[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR _pLoopPlot$[ebp], edx

; 7206 : 
; 7207 : 				if(pLoopPlot->getRevealedImprovementType(GC.getGame().getActiveTeam(), true) != NO_IMPROVEMENT)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T238733[ebp], ecx
	push	1
	mov	ecx, DWORD PTR $T238733[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	push	eax
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@_N@Z ; CvPlot::getRevealedImprovementType
	cmp	eax, -1
	je	$LN10@SetCurrent

; 7208 : 				{
; 7209 : 					if((pLoopPlot->getTeam() == GetID()) ||
; 7210 : 					        (!pLoopPlot->isOwned() && GetID() == GC.getGame().getActiveTeam()))

	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR _playerID$238747[ebp], eax
	cmp	DWORD PTR _playerID$238747[ebp], -1
	je	SHORT $LN201@SetCurrent
	mov	ecx, DWORD PTR _playerID$238747[ebp]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T238750[ebp], eax
	jmp	SHORT $LN202@SetCurrent
	jmp	SHORT $LN202@SetCurrent
$LN201@SetCurrent:
	mov	DWORD PTR $T238750[ebp], -1
$LN202@SetCurrent:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T238750[ebp], eax
	je	SHORT $LN8@SetCurrent
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN10@SetCurrent
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T238754[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	mov	esi, eax
	mov	ecx, DWORD PTR $T238754[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	esi, eax
	jne	SHORT $LN10@SetCurrent
$LN8@SetCurrent:

; 7211 : 					{
; 7212 : 						pLoopPlot->setLayoutDirty(true);

	push	1
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?setLayoutDirty@CvPlot@@QAEX_N@Z	; CvPlot::setLayoutDirty
$LN10@SetCurrent:

; 7213 : 					}
; 7214 : 				}
; 7215 : 			}

	jmp	$LN12@SetCurrent
$LN14@SetCurrent:

; 7216 : 		}
; 7217 : 
; 7218 : 		// need to map gameplay eras to the artwork eras
; 7219 : 		for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)

	mov	DWORD PTR _iPlayerLoop$226688[ebp], 0
	jmp	SHORT $LN7@SetCurrent
$LN6@SetCurrent:
	mov	ecx, DWORD PTR _iPlayerLoop$226688[ebp]
	add	ecx, 1
	mov	DWORD PTR _iPlayerLoop$226688[ebp], ecx
$LN7@SetCurrent:
	cmp	DWORD PTR _iPlayerLoop$226688[ebp], 63	; 0000003fH
	jge	$LN5@SetCurrent

; 7220 : 		{
; 7221 : 			ePlayer = (PlayerTypes) iPlayerLoop;

	mov	edx, DWORD PTR _iPlayerLoop$226688[ebp]
	mov	DWORD PTR _ePlayer$226671[ebp], edx

; 7222 : 
; 7223 : 			CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);

	mov	eax, DWORD PTR _ePlayer$226671[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$226693[ebp], eax

; 7224 : 			if(kPlayer.isAlive() && kPlayer.getTeam() == GetID())

	mov	ecx, DWORD PTR _kPlayer$226693[ebp]
	mov	dl, BYTE PTR [ecx+2256]
	mov	BYTE PTR $T238766[ebp], dl
	movzx	eax, BYTE PTR $T238766[ebp]
	test	eax, eax
	je	SHORT $LN4@SetCurrent
	mov	ecx, DWORD PTR _kPlayer$226693[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T238775[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T238775[ebp], eax
	jne	SHORT $LN4@SetCurrent

; 7225 : 			{
; 7226 : 				gDLL->GameplayEraChanged(ePlayer, eNewValue);

	mov	eax, DWORD PTR $T238779[ebp]
	mov	DWORD PTR tv727[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv727[ebp], ecx
	mov	edx, DWORD PTR _eNewValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _ePlayer$226671[ebp]
	push	eax
	mov	ecx, DWORD PTR tv727[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv727[ebp]
	mov	eax, DWORD PTR [edx+576]
	call	eax
$LN4@SetCurrent:

; 7227 : 			}
; 7228 : 		}

	jmp	$LN6@SetCurrent
$LN5@SetCurrent:

; 7229 : 
; 7230 : 		if(GC.getGame().getActiveTeam() == GetID() && isBridgeBuilding() && eNewValue >= GC.getLAST_BRIDGE_ART_ERA())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T238783[ebp], ecx
	mov	ecx, DWORD PTR $T238783[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	esi, eax
	jne	SHORT $LN3@SetCurrent
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isBridgeBuilding@CvTeam@@QBE_NXZ	; CvTeam::isBridgeBuilding
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@SetCurrent
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8496
	mov	DWORD PTR $T238787[ebp], eax
	mov	ecx, DWORD PTR _eNewValue$[ebp]
	cmp	ecx, DWORD PTR $T238787[ebp]
	jl	SHORT $LN3@SetCurrent

; 7231 : 		{
; 7232 : 			gDLL->GameplayBridgeChanged(true, 1);

	mov	edx, DWORD PTR $T238791[ebp]
	mov	DWORD PTR tv753[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv753[ebp], eax
	push	1
	push	1
	mov	ecx, DWORD PTR tv753[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv753[ebp]
	mov	eax, DWORD PTR [edx+580]
	call	eax
$LN3@SetCurrent:

; 7233 : 		}
; 7234 : 
; 7235 : 		if(GetID() == GC.getGame().getActiveTeam())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T238795[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	mov	esi, eax
	mov	ecx, DWORD PTR $T238795[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	esi, eax
	jne	SHORT $LN2@SetCurrent

; 7236 : 		{
; 7237 : 			DLLUI->setDirty(Soundtrack_DIRTY_BIT, true);

	mov	edx, DWORD PTR $T238799[ebp]
	mov	DWORD PTR tv772[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv772[ebp], eax
	push	1
	push	28					; 0000001cH
	mov	ecx, DWORD PTR tv772[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv772[ebp]
	mov	eax, DWORD PTR [edx+260]
	call	eax
$LN2@SetCurrent:

; 7238 : 		}
; 7239 : 
; 7240 : 		ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR $T238803[ebp]
	mov	DWORD PTR tv784[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv784[ebp], edx
	mov	eax, DWORD PTR tv784[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv784[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pkScriptSystem$226697[ebp], eax

; 7241 : 		if(pkScriptSystem)

	cmp	DWORD PTR _pkScriptSystem$226697[ebp], 0
	je	$LN77@SetCurrent

; 7242 : 		{
; 7243 : 			CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$226699[ebp]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle
	mov	DWORD PTR __$EHRec$[ebp+8], 6

; 7244 : 			args->Push(GetID());

	mov	ecx, DWORD PTR _args$226699[ebp]
	mov	DWORD PTR tv795[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	edx, DWORD PTR tv795[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv795[ebp]
	mov	edx, DWORD PTR [eax+8]
	call	edx

; 7245 : 			args->Push(GetCurrentEra());

	mov	eax, DWORD PTR _args$226699[ebp]
	mov	DWORD PTR tv804[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCurrentEra@CvTeam@@QBE?AW4EraTypes@@XZ ; CvTeam::GetCurrentEra
	push	eax
	mov	ecx, DWORD PTR tv804[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv804[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 7246 : 			
; 7247 : 			bool bResult = false;

	mov	BYTE PTR _bResult$226700[ebp], 0

; 7248 : 			LuaSupport::CallHook(pkScriptSystem, "TeamSetEra", args.get(), bResult);

	lea	ecx, DWORD PTR _bResult$226700[ebp]
	push	ecx
	mov	edx, DWORD PTR _args$226699[ebp]
	push	edx
	push	OFFSET ??_C@_0L@KKCIGKBH@TeamSetEra?$AA@
	mov	eax, DWORD PTR _pkScriptSystem$226697[ebp]
	push	eax
	call	?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallHook
	add	esp, 16					; 00000010H

; 7249 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _args$226699[ebp]
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN77@SetCurrent:

; 7250 : 	}
; 7251 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z$0:
	lea	ecx, DWORD PTR _strMessage$226564[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z$1:
	lea	ecx, DWORD PTR _strSummary$226565[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z$2:
	lea	ecx, DWORD PTR $T238488[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z$3:
	lea	ecx, DWORD PTR _unmetPlayer$226590[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z$4:
	lea	ecx, DWORD PTR $T238491[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z$5:
	lea	ecx, DWORD PTR $T238492[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z$6:
	lea	ecx, DWORD PTR _args$226699[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__ehhandler$?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1460]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-204]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z ENDP		; CvTeam::SetCurrentEra
PUBLIC	?countNumHumanGameTurnActive@CvTeam@@QBEHXZ	; CvTeam::countNumHumanGameTurnActive
EXTRN	?isTurnActive@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isTurnActive
; Function compile flags: /Odtp
;	COMDAT ?countNumHumanGameTurnActive@CvTeam@@QBEHXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T238832 = -16						; size = 4
_kLoopPlayer$226710 = -12				; size = 4
_iI$226706 = -8						; size = 4
_iCount$ = -4						; size = 4
?countNumHumanGameTurnActive@CvTeam@@QBEHXZ PROC	; CvTeam::countNumHumanGameTurnActive, COMDAT
; _this$ = ecx

; 7255 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 7256 : 	int iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0

; 7257 : 
; 7258 : 	for(int iI = 0; iI < MAX_CIV_PLAYERS; iI++)

	mov	DWORD PTR _iI$226706[ebp], 0
	jmp	SHORT $LN5@countNumHu
$LN4@countNumHu:
	mov	eax, DWORD PTR _iI$226706[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$226706[ebp], eax
$LN5@countNumHu:
	cmp	DWORD PTR _iI$226706[ebp], 63		; 0000003fH
	jge	SHORT $LN3@countNumHu

; 7259 : 	{
; 7260 : 		CvPlayer& kLoopPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	ecx, DWORD PTR _iI$226706[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kLoopPlayer$226710[ebp], ecx

; 7261 : 
; 7262 : 		if(kLoopPlayer.isHuman() && kLoopPlayer.getTeam() == GetID())

	mov	ecx, DWORD PTR _kLoopPlayer$226710[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@countNumHu
	mov	eax, DWORD PTR _kLoopPlayer$226710[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T238832[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T238832[ebp], eax
	jne	SHORT $LN2@countNumHu

; 7263 : 		{
; 7264 : 			if(kLoopPlayer.isTurnActive())

	mov	ecx, DWORD PTR _kLoopPlayer$226710[ebp]
	call	?isTurnActive@CvPlayer@@QBE_NXZ		; CvPlayer::isTurnActive
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@countNumHu

; 7265 : 			{
; 7266 : 				++iCount;

	mov	eax, DWORD PTR _iCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCount$[ebp], eax
$LN2@countNumHu:

; 7267 : 			}
; 7268 : 		}
; 7269 : 	}

	jmp	SHORT $LN4@countNumHu
$LN3@countNumHu:

; 7270 : 
; 7271 : 	return iCount;

	mov	eax, DWORD PTR _iCount$[ebp]

; 7272 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?countNumHumanGameTurnActive@CvTeam@@QBEHXZ ENDP	; CvTeam::countNumHumanGameTurnActive
_TEXT	ENDS
PUBLIC	?setTurnActive@CvTeam@@QAEX_N0@Z		; CvTeam::setTurnActive
EXTRN	?setTurnActive@CvPlayer@@QAEX_N0@Z:PROC		; CvPlayer::setTurnActive
; Function compile flags: /Odtp
;	COMDAT ?setTurnActive@CvTeam@@QAEX_N0@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T238855 = -16						; size = 4
$T238846 = -9						; size = 1
_kPlayer$226723 = -8					; size = 4
_iPlayer$226719 = -4					; size = 4
_bNewValue$ = 8						; size = 1
_bDoTurn$ = 12						; size = 1
?setTurnActive@CvTeam@@QAEX_N0@Z PROC			; CvTeam::setTurnActive, COMDAT
; _this$ = ecx

; 7276 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 7277 : 	CvAssert(GC.getGame().isSimultaneousTeamTurns());
; 7278 : 
; 7279 : 	for(int iPlayer = 0; iPlayer < MAX_PLAYERS; ++iPlayer)

	mov	DWORD PTR _iPlayer$226719[ebp], 0
	jmp	SHORT $LN4@setTurnAct
$LN3@setTurnAct:
	mov	eax, DWORD PTR _iPlayer$226719[ebp]
	add	eax, 1
	mov	DWORD PTR _iPlayer$226719[ebp], eax
$LN4@setTurnAct:
	cmp	DWORD PTR _iPlayer$226719[ebp], 64	; 00000040H
	jge	SHORT $LN5@setTurnAct

; 7280 : 	{
; 7281 : 		CvPlayer& kPlayer = GET_PLAYER((PlayerTypes)iPlayer);

	mov	ecx, DWORD PTR _iPlayer$226719[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$226723[ebp], ecx

; 7282 : 		if(kPlayer.isAlive() && kPlayer.getTeam() == GetID())

	mov	edx, DWORD PTR _kPlayer$226723[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T238846[ebp], al
	movzx	ecx, BYTE PTR $T238846[ebp]
	test	ecx, ecx
	je	SHORT $LN1@setTurnAct
	mov	edx, DWORD PTR _kPlayer$226723[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T238855[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T238855[ebp], eax
	jne	SHORT $LN1@setTurnAct

; 7283 : 		{
; 7284 : 			kPlayer.setTurnActive(bNewValue, bDoTurn);

	movzx	ecx, BYTE PTR _bDoTurn$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _bNewValue$[ebp]
	push	edx
	mov	ecx, DWORD PTR _kPlayer$226723[ebp]
	call	?setTurnActive@CvPlayer@@QAEX_N0@Z	; CvPlayer::setTurnActive
$LN1@setTurnAct:

; 7285 : 		}

	jmp	SHORT $LN3@setTurnAct
$LN5@setTurnAct:

; 7286 : 	}
; 7287 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?setTurnActive@CvTeam@@QAEX_N0@Z ENDP			; CvTeam::setTurnActive
_TEXT	ENDS
PUBLIC	?isTurnActive@CvTeam@@QBE_NXZ			; CvTeam::isTurnActive
; Function compile flags: /Odtp
;	COMDAT ?isTurnActive@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T238878 = -16						; size = 4
$T238869 = -9						; size = 1
_kPlayer$226733 = -8					; size = 4
_iPlayer$226729 = -4					; size = 4
?isTurnActive@CvTeam@@QBE_NXZ PROC			; CvTeam::isTurnActive, COMDAT
; _this$ = ecx

; 7291 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 7292 : 	CvAssert(GC.getGame().isSimultaneousTeamTurns());
; 7293 : 
; 7294 : 	for(int iPlayer = 0; iPlayer < MAX_PLAYERS; ++iPlayer)

	mov	DWORD PTR _iPlayer$226729[ebp], 0
	jmp	SHORT $LN5@isTurnActi
$LN4@isTurnActi:
	mov	eax, DWORD PTR _iPlayer$226729[ebp]
	add	eax, 1
	mov	DWORD PTR _iPlayer$226729[ebp], eax
$LN5@isTurnActi:
	cmp	DWORD PTR _iPlayer$226729[ebp], 64	; 00000040H
	jge	SHORT $LN3@isTurnActi

; 7295 : 	{
; 7296 : 		CvPlayer& kPlayer = GET_PLAYER((PlayerTypes)iPlayer);

	mov	ecx, DWORD PTR _iPlayer$226729[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$226733[ebp], ecx

; 7297 : 		if(kPlayer.isAlive() && kPlayer.getTeam() == GetID())

	mov	edx, DWORD PTR _kPlayer$226733[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T238869[ebp], al
	movzx	ecx, BYTE PTR $T238869[ebp]
	test	ecx, ecx
	je	SHORT $LN2@isTurnActi
	mov	edx, DWORD PTR _kPlayer$226733[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T238878[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T238878[ebp], eax
	jne	SHORT $LN2@isTurnActi

; 7298 : 		{
; 7299 : 			if(kPlayer.isTurnActive())

	mov	ecx, DWORD PTR _kPlayer$226733[ebp]
	call	?isTurnActive@CvPlayer@@QBE_NXZ		; CvPlayer::isTurnActive
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@isTurnActi

; 7300 : 			{
; 7301 : 				return true;

	mov	al, 1
	jmp	SHORT $LN6@isTurnActi
$LN2@isTurnActi:

; 7302 : 			}
; 7303 : 		}
; 7304 : 	}

	jmp	SHORT $LN4@isTurnActi
$LN3@isTurnActi:

; 7305 : 
; 7306 : 	return false;

	xor	al, al
$LN6@isTurnActi:

; 7307 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isTurnActive@CvTeam@@QBE_NXZ ENDP			; CvTeam::isTurnActive
_TEXT	ENDS
PUBLIC	?PushIgnoreWarning@CvTeam@@QAEXW4TeamTypes@@@Z	; CvTeam::PushIgnoreWarning
; Function compile flags: /Odtp
;	COMDAT ?PushIgnoreWarning@CvTeam@@QAEXW4TeamTypes@@@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_eTeam$ = 8						; size = 4
?PushIgnoreWarning@CvTeam@@QAEXW4TeamTypes@@@Z PROC	; CvTeam::PushIgnoreWarning, COMDAT
; _this$ = ecx

; 7311 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 7312 : 	CvAssertMsg(eTeam != NO_TEAM, "PushIgnoreWarning got NO_TEAM passed to it");
; 7313 : 	if (eTeam == NO_TEAM)

	cmp	DWORD PTR _eTeam$[ebp], -1
	jne	SHORT $LN4@PushIgnore

; 7314 : 	{
; 7315 : 		return;

	jmp	SHORT $LN2@PushIgnore

; 7316 : 	}
; 7317 : 
; 7318 : 	m_aiIgnoreWarningCount[eTeam] += 1;

$LN4@PushIgnore:
	mov	eax, DWORD PTR _eTeam$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4+1448]
	mov	DWORD PTR tv69[ebp], edx
	mov	eax, DWORD PTR tv69[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR tv69[ebp]
	mov	DWORD PTR [edx], ecx
$LN2@PushIgnore:

; 7319 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?PushIgnoreWarning@CvTeam@@QAEXW4TeamTypes@@@Z ENDP	; CvTeam::PushIgnoreWarning
_TEXT	ENDS
PUBLIC	?PopIgnoreWarning@CvTeam@@QAEXW4TeamTypes@@@Z	; CvTeam::PopIgnoreWarning
; Function compile flags: /Odtp
;	COMDAT ?PopIgnoreWarning@CvTeam@@QAEXW4TeamTypes@@@Z
_TEXT	SEGMENT
tv74 = -8						; size = 4
_this$ = -4						; size = 4
_eTeam$ = 8						; size = 4
?PopIgnoreWarning@CvTeam@@QAEXW4TeamTypes@@@Z PROC	; CvTeam::PopIgnoreWarning, COMDAT
; _this$ = ecx

; 7323 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 7324 : 	CvAssertMsg(eTeam != NO_TEAM, "PopIgnoreWarning got NO_TEAM passed to it");
; 7325 : 	if (eTeam == NO_TEAM)

	cmp	DWORD PTR _eTeam$[ebp], -1
	jne	SHORT $LN5@PopIgnoreW

; 7326 : 	{
; 7327 : 		return;

	jmp	SHORT $LN3@PopIgnoreW

; 7328 : 	}
; 7329 : 
; 7330 : 	CvAssertMsg(m_aiIgnoreWarningCount[eTeam] > 0, "Trying to pop when there's nothing to be popped");
; 7331 : 	if (m_aiIgnoreWarningCount[eTeam] > 0)

$LN5@PopIgnoreW:
	mov	eax, DWORD PTR _eTeam$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4+1448], 0
	jle	SHORT $LN3@PopIgnoreW

; 7332 : 	{
; 7333 : 		m_aiIgnoreWarningCount[eTeam] -= 1;

	mov	edx, DWORD PTR _eTeam$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4+1448]
	mov	DWORD PTR tv74[ebp], ecx
	mov	edx, DWORD PTR tv74[ebp]
	mov	eax, DWORD PTR [edx]
	sub	eax, 1
	mov	ecx, DWORD PTR tv74[ebp]
	mov	DWORD PTR [ecx], eax
$LN3@PopIgnoreW:

; 7334 : 	}
; 7335 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?PopIgnoreWarning@CvTeam@@QAEXW4TeamTypes@@@Z ENDP	; CvTeam::PopIgnoreWarning
_TEXT	ENDS
PUBLIC	?GetIgnoreWarningCount@CvTeam@@QAEHW4TeamTypes@@@Z ; CvTeam::GetIgnoreWarningCount
; Function compile flags: /Odtp
;	COMDAT ?GetIgnoreWarningCount@CvTeam@@QAEHW4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eTeam$ = 8						; size = 4
?GetIgnoreWarningCount@CvTeam@@QAEHW4TeamTypes@@@Z PROC	; CvTeam::GetIgnoreWarningCount, COMDAT
; _this$ = ecx

; 7339 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 7340 : 	CvAssertMsg(eTeam != NO_TEAM, "GetIgnoreWarningCount got NO_TEAM passed to it");
; 7341 : 	if (eTeam == NO_TEAM)

	cmp	DWORD PTR _eTeam$[ebp], -1
	jne	SHORT $LN4@GetIgnoreW

; 7342 : 	{
; 7343 : 		return -1;

	or	eax, -1
	jmp	SHORT $LN2@GetIgnoreW

; 7344 : 	}
; 7345 : 
; 7346 : 	return m_aiIgnoreWarningCount[eTeam];

$LN4@GetIgnoreW:
	mov	eax, DWORD PTR _eTeam$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4+1448]
$LN2@GetIgnoreW:

; 7347 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetIgnoreWarningCount@CvTeam@@QAEHW4TeamTypes@@@Z ENDP	; CvTeam::GetIgnoreWarningCount
_TEXT	ENDS
PUBLIC	?setDynamicTurnsSimultMode@CvTeam@@QAEX_N@Z	; CvTeam::setDynamicTurnsSimultMode
EXTRN	?setDynamicTurnsSimultMode@CvPlayer@@QAEX_N@Z:PROC ; CvPlayer::setDynamicTurnsSimultMode
; Function compile flags: /Odtp
;	COMDAT ?setDynamicTurnsSimultMode@CvTeam@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T238919 = -16						; size = 4
$T238910 = -9						; size = 1
_kPlayer$226761 = -8					; size = 4
_iPlayer$226757 = -4					; size = 4
_simultaneousTurns$ = 8					; size = 1
?setDynamicTurnsSimultMode@CvTeam@@QAEX_N@Z PROC	; CvTeam::setDynamicTurnsSimultMode, COMDAT
; _this$ = ecx

; 7460 : {//set DynamicTurnsSimultMode for every player on this team.

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 7461 : 	for(int iPlayer = 0; iPlayer < MAX_PLAYERS; ++iPlayer)

	mov	DWORD PTR _iPlayer$226757[ebp], 0
	jmp	SHORT $LN4@setDynamic
$LN3@setDynamic:
	mov	eax, DWORD PTR _iPlayer$226757[ebp]
	add	eax, 1
	mov	DWORD PTR _iPlayer$226757[ebp], eax
$LN4@setDynamic:
	cmp	DWORD PTR _iPlayer$226757[ebp], 64	; 00000040H
	jge	SHORT $LN5@setDynamic

; 7462 : 	{
; 7463 : 		CvPlayer& kPlayer = GET_PLAYER((PlayerTypes)iPlayer);

	mov	ecx, DWORD PTR _iPlayer$226757[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$226761[ebp], ecx

; 7464 : 		if(kPlayer.isAlive() && kPlayer.getTeam() == GetID())

	mov	edx, DWORD PTR _kPlayer$226761[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T238910[ebp], al
	movzx	ecx, BYTE PTR $T238910[ebp]
	test	ecx, ecx
	je	SHORT $LN1@setDynamic
	mov	edx, DWORD PTR _kPlayer$226761[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T238919[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T238919[ebp], eax
	jne	SHORT $LN1@setDynamic

; 7465 : 		{
; 7466 : 			kPlayer.setDynamicTurnsSimultMode(simultaneousTurns);

	movzx	ecx, BYTE PTR _simultaneousTurns$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kPlayer$226761[ebp]
	call	?setDynamicTurnsSimultMode@CvPlayer@@QAEX_N@Z ; CvPlayer::setDynamicTurnsSimultMode
$LN1@setDynamic:

; 7467 : 		}

	jmp	SHORT $LN3@setDynamic
$LN5@setDynamic:

; 7468 : 	}
; 7469 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?setDynamicTurnsSimultMode@CvTeam@@QAEX_N@Z ENDP	; CvTeam::setDynamicTurnsSimultMode
_TEXT	ENDS
PUBLIC	??$ReadHashedTypeArray@W4ResourceTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@AAV?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@@Z ; CvInfosSerializationHelper::ReadHashedTypeArray<enum ResourceTypes>
PUBLIC	??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<bool>
PUBLIC	??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z ; operator>><bool>
PUBLIC	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
PUBLIC	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ; operator>><int>
EXTRN	?ReadYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z:PROC ; ImprovementArrayHelpers::ReadYieldArray
EXTRN	?Read@CvTeamTechs@@QAEXAAVFDataStream@@@Z:PROC	; CvTeamTechs::Read
EXTRN	?Read@BuildingArrayHelpers@@YAXAAVFDataStream@@PAH@Z:PROC ; BuildingArrayHelpers::Read
EXTRN	?Read@BuildingClassArrayHelpers@@YAXAAVFDataStream@@PAH@Z:PROC ; BuildingClassArrayHelpers::Read
EXTRN	?Read@UnitClassArrayHelpers@@YAXAAVFDataStream@@PAH@Z:PROC ; UnitClassArrayHelpers::Read
EXTRN	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z:PROC ; CvInfosSerializationHelper::ReadHashed
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4EraTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4TeamTypes@@@Z:PROC ; operator>>
EXTRN	?Read@FDataStream@@IAEXAA_N@Z:PROC		; FDataStream::Read
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Odtp
;	COMDAT ?Read@CvTeam@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -240						; size = 4
_temp$226897 = -168					; size = 4
_j$226893 = -164					; size = 4
_temp$226891 = -160					; size = 4
_j$226887 = -156					; size = 4
_iType$226885 = -152					; size = 4
_i$226881 = -148					; size = 4
_kIgnoreWarningWrapper$ = -144				; size = 8
_kAtWarWrapper$ = -136					; size = 8
_kTradeAgreementWrapper$ = -128				; size = 8
_kEmbassyWrapper$ = -120				; size = 8
_kDefensivePactWrapper$ = -112				; size = 8
_kNumTurnsAtWarWrapper$ = -104				; size = 8
_kForcePeaceWrapper$ = -96				; size = 8
_kNumTurnsLockedIntoWarWrapper$ = -88			; size = 8
_kPermanentWarWrapper$ = -80				; size = 8
_uiVersion$ = -72					; size = 4
_iNumProjects$ = -68					; size = 4
_kHasFoundPlayerWrapper$ = -64				; size = 8
_kOpenBordersWrapper$ = -56				; size = 8
_kTurnTeamMetWrapper$ = -48				; size = 8
_kHasMetWrapper$ = -40					; size = 8
_kTurnMadePeaceWrapper$ = -32				; size = 8
_kResearchAgreementWrapper$ = -24			; size = 8
_kTechShareCountWrapper$ = -16				; size = 8
_kExtraMovesWrapper$ = -8				; size = 8
_kStream$ = 8						; size = 4
?Read@CvTeam@@UAEXAAVFDataStream@@@Z PROC		; CvTeam::Read, COMDAT
; _this$ = ecx

; 7475 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	mov	DWORD PTR _this$[ebp], ecx

; 7476 : 	// Init data before load
; 7477 : 	reset();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?reset@CvTeam@@QAEXW4TeamTypes@@_N@Z	; CvTeam::reset

; 7478 : 
; 7479 : 	// Version number to maintain backwards compatibility
; 7480 : 	uint uiVersion;
; 7481 : 	kStream >> uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 7482 : 
; 7483 : 	kStream >> m_iNumMembers;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7484 : 	kStream >> m_iAliveCount;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7485 : 	kStream >> m_iEverAliveCount;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7486 : 	kStream >> m_iNumCities;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7487 : 	kStream >> m_iTotalPopulation;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 24					; 00000018H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7488 : 	kStream >> m_iTotalLand;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 28					; 0000001cH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7489 : 	kStream >> m_iNukeInterception;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7490 : 	kStream >> m_iExtraWaterSeeFromCount;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 36					; 00000024H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7491 : 	kStream >> m_iMapTradingCount;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7492 : 	kStream >> m_iTechTradingCount;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7493 : 	kStream >> m_iGoldTradingCount;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 48					; 00000030H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7494 : 	kStream >> m_iAllowEmbassyTradingAllowedCount;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 52					; 00000034H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7495 : 	kStream >> m_iOpenBordersTradingAllowedCount;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7496 : 	kStream >> m_iDefensivePactTradingAllowedCount;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 60					; 0000003cH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7497 : 	kStream >> m_iResearchAgreementTradingAllowedCount;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 64					; 00000040H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7498 : 	kStream >> m_iTradeAgreementTradingAllowedCount;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 68					; 00000044H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7499 : 	kStream >> m_iPermanentAllianceTradingCount;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 72					; 00000048H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7500 : 	kStream >> m_iBridgeBuildingCount;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 76					; 0000004cH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7501 : 	kStream >> m_iWaterWorkCount;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7502 : 	kStream >> m_iRiverTradeCount;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 84					; 00000054H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7503 : 	kStream >> m_iBorderObstacleCount;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 88					; 00000058H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7504 : 	kStream >> m_iVictoryPoints;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7505 : 	kStream >> m_iEmbarkedExtraMoves;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 96					; 00000060H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7506 : 	//EAP: Extra embarked visiblity on tech
; 7507 : 	kStream >> m_iEmbarkedExtraSight;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 100				; 00000064H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7508 : 	kStream >> m_iCanEmbarkCount;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 104				; 00000068H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7509 : 	kStream >> m_iDefensiveEmbarkCount;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 108				; 0000006cH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7510 : 	kStream >> m_iEmbarkedAllWaterPassageCount;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 112				; 00000070H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7511 : 	kStream >> m_iNumNaturalWondersDiscovered;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 116				; 00000074H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7512 : 	kStream >> m_iBestPossibleRoute;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 120				; 00000078H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7513 : 	kStream >> m_iNumMinorCivsAttacked;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 124				; 0000007cH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7514 : #ifdef AUI_ASTAR_TWEAKED_OPTIMIZED_BUT_CAN_STILL_USE_ROADS
; 7515 : 	kStream >> m_iBestRouteFlatCostMultiplier;
; 7516 : 	kStream >> m_iBestRouteNormalCostMultiplier;
; 7517 : 	kStream >> m_iUseFlatCostIfBelowThis;
; 7518 : #endif
; 7519 : 
; 7520 : 	kStream >> m_bMapCentering;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 128				; 00000080H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 7521 : 	kStream >> m_bHasBrokenPeaceTreaty;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 129				; 00000081H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 7522 : 	kStream >> m_bHomeOfUnitedNations;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 130				; 00000082H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 7523 : 	kStream >> m_bHasTechForWorldCongress;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 131				; 00000083H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 7524 : 
; 7525 : 	kStream >> m_bBrokenMilitaryPromise;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 132				; 00000084H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 7526 : 	kStream >> m_bBrokenExpansionPromise;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 133				; 00000085H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 7527 : 	kStream >> m_bBrokenBorderPromise;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 134				; 00000086H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 7528 : 	kStream >> m_bBrokenCityStatePromise;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 135				; 00000087H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 7529 : 
; 7530 : 	kStream >> m_eID;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??5@YAAAVFDataStream@@AAV0@AAW4TeamTypes@@@Z ; operator>>
	add	esp, 8

; 7531 : 
; 7532 : 	kStream >> m_eCurrentEra;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 136				; 00000088H
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??5@YAAAVFDataStream@@AAV0@AAW4EraTypes@@@Z ; operator>>
	add	esp, 8

; 7533 : 	kStream >> m_eLiberatedByTeam;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??5@YAAAVFDataStream@@AAV0@AAW4TeamTypes@@@Z ; operator>>
	add	esp, 8

; 7534 : 	kStream >> m_eKilledByTeam;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 144				; 00000090H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??5@YAAAVFDataStream@@AAV0@AAW4TeamTypes@@@Z ; operator>>
	add	esp, 8

; 7535 : 
; 7536 : 	ArrayWrapper<int> kTechShareCountWrapper(MAX_TEAMS, &m_aiTechShareCount[0]);

	xor	edx, edx
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+148]
	mov	DWORD PTR _kTechShareCountWrapper$[ebp], ecx
	mov	DWORD PTR _kTechShareCountWrapper$[ebp+4], 64 ; 00000040H

; 7537 : 	kStream >> kTechShareCountWrapper;

	lea	edx, DWORD PTR _kTechShareCountWrapper$[ebp]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ; operator>><int>
	add	esp, 8

; 7538 : 
; 7539 : 	ArrayWrapper<int> kNumTurnsAtWarWrapper(MAX_TEAMS, &m_aiNumTurnsAtWar[0]);

	xor	ecx, ecx
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+468]
	mov	DWORD PTR _kNumTurnsAtWarWrapper$[ebp], eax
	mov	DWORD PTR _kNumTurnsAtWarWrapper$[ebp+4], 64 ; 00000040H

; 7540 : 	kStream >> kNumTurnsAtWarWrapper;

	lea	ecx, DWORD PTR _kNumTurnsAtWarWrapper$[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ; operator>><int>
	add	esp, 8

; 7541 : 
; 7542 : 	ArrayWrapper<int> kNumTurnsLockedIntoWarWrapper(MAX_TEAMS, &m_aiNumTurnsLockedIntoWar[0]);

	xor	eax, eax
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+788]
	mov	DWORD PTR _kNumTurnsLockedIntoWarWrapper$[ebp], edx
	mov	DWORD PTR _kNumTurnsLockedIntoWarWrapper$[ebp+4], 64 ; 00000040H

; 7543 : 	kStream >> kNumTurnsLockedIntoWarWrapper;

	lea	eax, DWORD PTR _kNumTurnsLockedIntoWarWrapper$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ; operator>><int>
	add	esp, 8

; 7544 : 
; 7545 : 	ArrayWrapper<int> kExtraMovesWrapper(NUM_DOMAIN_TYPES, &m_aiExtraMoves[0]);

	xor	edx, edx
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+1108]
	mov	DWORD PTR _kExtraMovesWrapper$[ebp], ecx
	mov	DWORD PTR _kExtraMovesWrapper$[ebp+4], 5

; 7546 : 	kStream >> kExtraMovesWrapper;

	lea	edx, DWORD PTR _kExtraMovesWrapper$[ebp]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ; operator>><int>
	add	esp, 8

; 7547 : 
; 7548 : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_aiForceTeamVoteEligibilityCount, GC.getNumVoteSourceInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumVoteSourceInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumVoteSourceInfos
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2892]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
	add	esp, 12					; 0000000cH

; 7549 : 
; 7550 : 	ArrayWrapper<int> kTurnMadePeaceWrapper(MAX_TEAMS, &m_paiTurnMadePeaceTreatyWithTeam[0]);

	xor	ecx, ecx
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+1128]
	mov	DWORD PTR _kTurnMadePeaceWrapper$[ebp], eax
	mov	DWORD PTR _kTurnMadePeaceWrapper$[ebp+4], 64 ; 00000040H

; 7551 : 	kStream >> kTurnMadePeaceWrapper;

	lea	ecx, DWORD PTR _kTurnMadePeaceWrapper$[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ; operator>><int>
	add	esp, 8

; 7552 : 
; 7553 : 	ArrayWrapper<int> kIgnoreWarningWrapper(MAX_TEAMS, &m_aiIgnoreWarningCount[0]);

	xor	eax, eax
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1448]
	mov	DWORD PTR _kIgnoreWarningWrapper$[ebp], edx
	mov	DWORD PTR _kIgnoreWarningWrapper$[ebp+4], 64 ; 00000040H

; 7554 : 	kStream >> kIgnoreWarningWrapper;

	lea	eax, DWORD PTR _kIgnoreWarningWrapper$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ; operator>><int>
	add	esp, 8

; 7555 : 
; 7556 : 	ArrayWrapper<bool> kHasMetWrapper(MAX_TEAMS, &m_abHasMet[0]);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1848				; 00000738H
	mov	DWORD PTR _kHasMetWrapper$[ebp], edx
	mov	DWORD PTR _kHasMetWrapper$[ebp+4], 64	; 00000040H

; 7557 : 	kStream >> kHasMetWrapper;

	lea	eax, DWORD PTR _kHasMetWrapper$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z ; operator>><bool>
	add	esp, 8

; 7558 : 
; 7559 : 	ArrayWrapper<bool> kHasFoundPlayerWrapper(MAX_PLAYERS, &m_abHasFoundPlayersTerritory[0]);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1768				; 000006e8H
	mov	DWORD PTR _kHasFoundPlayerWrapper$[ebp], edx
	mov	DWORD PTR _kHasFoundPlayerWrapper$[ebp+4], 64 ; 00000040H

; 7560 : 	kStream >> kHasFoundPlayerWrapper;

	lea	eax, DWORD PTR _kHasFoundPlayerWrapper$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z ; operator>><bool>
	add	esp, 8

; 7561 : 
; 7562 : 	ArrayWrapper<bool> kAtWarWrapper(MAX_TEAMS, &m_abAtWar[0]);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1928				; 00000788H
	mov	DWORD PTR _kAtWarWrapper$[ebp], edx
	mov	DWORD PTR _kAtWarWrapper$[ebp+4], 64	; 00000040H

; 7563 : 	kStream >> kAtWarWrapper;

	lea	eax, DWORD PTR _kAtWarWrapper$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z ; operator>><bool>
	add	esp, 8

; 7564 : 
; 7565 : 	ArrayWrapper<bool> kPermanentWarWrapper(MAX_TEAMS, &m_abPermanentWarPeace[0]);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2008				; 000007d8H
	mov	DWORD PTR _kPermanentWarWrapper$[ebp], edx
	mov	DWORD PTR _kPermanentWarWrapper$[ebp+4], 64 ; 00000040H

; 7566 : 	kStream >> kPermanentWarWrapper;

	lea	eax, DWORD PTR _kPermanentWarWrapper$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z ; operator>><bool>
	add	esp, 8

; 7567 : 
; 7568 : 	ArrayWrapper<bool> kEmbassyWrapper(MAX_TEAMS, &m_abEmbassy[0]);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2088				; 00000828H
	mov	DWORD PTR _kEmbassyWrapper$[ebp], edx
	mov	DWORD PTR _kEmbassyWrapper$[ebp+4], 64	; 00000040H

; 7569 : 	kStream >> kEmbassyWrapper;

	lea	eax, DWORD PTR _kEmbassyWrapper$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z ; operator>><bool>
	add	esp, 8

; 7570 : 
; 7571 : 	ArrayWrapper<bool> kOpenBordersWrapper(MAX_TEAMS, &m_abOpenBorders[0]);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2168				; 00000878H
	mov	DWORD PTR _kOpenBordersWrapper$[ebp], edx
	mov	DWORD PTR _kOpenBordersWrapper$[ebp+4], 64 ; 00000040H

; 7572 : 	kStream >> kOpenBordersWrapper;

	lea	eax, DWORD PTR _kOpenBordersWrapper$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z ; operator>><bool>
	add	esp, 8

; 7573 : 
; 7574 : 	ArrayWrapper<bool> kDefensivePactWrapper(MAX_TEAMS, &m_abDefensivePact[0]);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2248				; 000008c8H
	mov	DWORD PTR _kDefensivePactWrapper$[ebp], edx
	mov	DWORD PTR _kDefensivePactWrapper$[ebp+4], 64 ; 00000040H

; 7575 : 	kStream >> kDefensivePactWrapper;

	lea	eax, DWORD PTR _kDefensivePactWrapper$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z ; operator>><bool>
	add	esp, 8

; 7576 : 
; 7577 : 	ArrayWrapper<bool> kResearchAgreementWrapper(MAX_TEAMS, &m_abResearchAgreement[0]);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2328				; 00000918H
	mov	DWORD PTR _kResearchAgreementWrapper$[ebp], edx
	mov	DWORD PTR _kResearchAgreementWrapper$[ebp+4], 64 ; 00000040H

; 7578 : 	kStream >> kResearchAgreementWrapper;

	lea	eax, DWORD PTR _kResearchAgreementWrapper$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z ; operator>><bool>
	add	esp, 8

; 7579 : 
; 7580 : 	ArrayWrapper<bool> kTradeAgreementWrapper(MAX_TEAMS, &m_abTradeAgreement[0]);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2408				; 00000968H
	mov	DWORD PTR _kTradeAgreementWrapper$[ebp], edx
	mov	DWORD PTR _kTradeAgreementWrapper$[ebp+4], 64 ; 00000040H

; 7581 : 	kStream >> kTradeAgreementWrapper;

	lea	eax, DWORD PTR _kTradeAgreementWrapper$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z ; operator>><bool>
	add	esp, 8

; 7582 : 
; 7583 : 	ArrayWrapper<bool> kForcePeaceWrapper(MAX_TEAMS, &m_abForcePeace[0]);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2488				; 000009b8H
	mov	DWORD PTR _kForcePeaceWrapper$[ebp], edx
	mov	DWORD PTR _kForcePeaceWrapper$[ebp+4], 64 ; 00000040H

; 7584 : 	kStream >> kForcePeaceWrapper;

	lea	eax, DWORD PTR _kForcePeaceWrapper$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z ; operator>><bool>
	add	esp, 8

; 7585 : 
; 7586 : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_abCanLaunch, GC.getNumVictoryInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumVictoryInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumVictoryInfos
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2896]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<bool>
	add	esp, 12					; 0000000cH

; 7587 : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_abVictoryAchieved, GC.getNumVictoryInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumVictoryInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumVictoryInfos
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2900]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<bool>
	add	esp, 12					; 0000000cH

; 7588 : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_abSmallAwardAchieved, GC.getNumSmallAwardInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumSmallAwardInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumSmallAwardInfos
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2904]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<bool>
	add	esp, 12					; 0000000cH

; 7589 : 
; 7590 : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_paiRouteChange, GC.getNumRouteInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumRouteInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumRouteInfos
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2908]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
	add	esp, 12					; 0000000cH

; 7591 : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_paiBuildTimeChange, GC.getNumBuildInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2912]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
	add	esp, 12					; 0000000cH

; 7592 : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_paiProjectCount, GC.getNumProjectInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumProjectInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumProjectInfos
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2916]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
	add	esp, 12					; 0000000cH

; 7593 : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_paiProjectDefaultArtTypes, GC.getNumProjectInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumProjectInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumProjectInfos
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2920]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
	add	esp, 12					; 0000000cH

; 7594 : 
; 7595 : 	//project art types
; 7596 : 
; 7597 : #ifdef AUI_WARNING_FIXES
; 7598 : 	uint iNumProjects;
; 7599 : 	kStream >> iNumProjects;
; 7600 : 	for (uint i = 0; i<iNumProjects; i++)
; 7601 : #else
; 7602 : 	int iNumProjects;
; 7603 : 	kStream >> iNumProjects;

	lea	edx, DWORD PTR _iNumProjects$[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7604 : 	for(int i=0; i<iNumProjects; i++)

	mov	DWORD PTR _i$226881[ebp], 0
	jmp	SHORT $LN12@Read
$LN11@Read:
	mov	eax, DWORD PTR _i$226881[ebp]
	add	eax, 1
	mov	DWORD PTR _i$226881[ebp], eax
$LN12@Read:
	mov	ecx, DWORD PTR _i$226881[ebp]
	cmp	ecx, DWORD PTR _iNumProjects$[ebp]
	jge	$LN10@Read

; 7605 : #endif
; 7606 : 	{
; 7607 : 		int iType = CvInfosSerializationHelper::ReadHashed(kStream);

	push	0
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	add	esp, 8
	mov	DWORD PTR _iType$226885[ebp], eax

; 7608 : 		if (iType != -1)

	cmp	DWORD PTR _iType$226885[ebp], -1
	je	SHORT $LN9@Read

; 7609 : 		{
; 7610 : 			for(int j=0; j<m_paiProjectCount[iType]; j++)

	mov	DWORD PTR _j$226887[ebp], 0
	jmp	SHORT $LN8@Read
$LN7@Read:
	mov	eax, DWORD PTR _j$226887[ebp]
	add	eax, 1
	mov	DWORD PTR _j$226887[ebp], eax
$LN8@Read:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2916]
	mov	eax, DWORD PTR _iType$226885[ebp]
	mov	ecx, DWORD PTR _j$226887[ebp]
	cmp	ecx, DWORD PTR [edx+eax*4]
	jge	SHORT $LN6@Read

; 7611 : 			{
; 7612 : 				int temp;
; 7613 : 				kStream >> temp;

	lea	edx, DWORD PTR _temp$226891[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7614 : 				m_pavProjectArtTypes[iType].push_back(temp);

	lea	eax, DWORD PTR _temp$226891[ebp]
	push	eax
	mov	ecx, DWORD PTR _iType$226885[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+2960]
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 7615 : 			}

	jmp	SHORT $LN7@Read
$LN6@Read:

; 7616 : 		}
; 7617 : 		else

	jmp	SHORT $LN5@Read
$LN9@Read:

; 7618 : 		{
; 7619 : 			for(int j=0; j<m_paiProjectCount[iType]; j++)

	mov	DWORD PTR _j$226893[ebp], 0
	jmp	SHORT $LN4@Read
$LN3@Read:
	mov	eax, DWORD PTR _j$226893[ebp]
	add	eax, 1
	mov	DWORD PTR _j$226893[ebp], eax
$LN4@Read:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2916]
	mov	eax, DWORD PTR _iType$226885[ebp]
	mov	ecx, DWORD PTR _j$226893[ebp]
	cmp	ecx, DWORD PTR [edx+eax*4]
	jge	SHORT $LN2@Read

; 7620 : 			{
; 7621 : 				int temp;
; 7622 : 				kStream >> temp;

	lea	edx, DWORD PTR _temp$226897[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7623 : 			}

	jmp	SHORT $LN3@Read
$LN2@Read:

; 7624 : 			m_paiProjectCount[iType] = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2916]
	mov	edx, DWORD PTR _iType$226885[ebp]
	mov	DWORD PTR [ecx+edx*4], 0
$LN5@Read:

; 7625 : 		}
; 7626 : 	}

	jmp	$LN11@Read
$LN10@Read:

; 7627 : 
; 7628 : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_paiProjectMaking, GC.getNumProjectInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumProjectInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumProjectInfos
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2924]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
	add	esp, 12					; 0000000cH

; 7629 : 
; 7630 : 	UnitClassArrayHelpers::Read(kStream, m_paiUnitClassCount);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2928]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?Read@UnitClassArrayHelpers@@YAXAAVFDataStream@@PAH@Z ; UnitClassArrayHelpers::Read
	add	esp, 8

; 7631 : 
; 7632 : 	BuildingClassArrayHelpers::Read(kStream, m_paiBuildingClassCount);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2932]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?Read@BuildingClassArrayHelpers@@YAXAAVFDataStream@@PAH@Z ; BuildingClassArrayHelpers::Read
	add	esp, 8

; 7633 : 	BuildingArrayHelpers::Read(kStream, m_paiObsoleteBuildingCount);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2936]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?Read@BuildingArrayHelpers@@YAXAAVFDataStream@@PAH@Z ; BuildingArrayHelpers::Read
	add	esp, 8

; 7634 : 
; 7635 : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_paiTerrainTradeCount, GC.getNumTerrainInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTerrainInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTerrainInfos
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2940]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
	add	esp, 12					; 0000000cH

; 7636 : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_aiVictoryCountdown, GC.getNumVictoryInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumVictoryInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumVictoryInfos
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2944]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
	add	esp, 12					; 0000000cH

; 7637 : 
; 7638 : 	ArrayWrapper<int> kTurnTeamMetWrapper(MAX_CIV_TEAMS, &m_aiTurnTeamMet[0]);

	xor	eax, eax
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+2568]
	mov	DWORD PTR _kTurnTeamMetWrapper$[ebp], edx
	mov	DWORD PTR _kTurnTeamMetWrapper$[ebp+4], 63 ; 0000003fH

; 7639 : 	kStream >> kTurnTeamMetWrapper;

	lea	eax, DWORD PTR _kTurnTeamMetWrapper$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ; operator>><int>
	add	esp, 8

; 7640 : 
; 7641 : 	m_pTeamTechs->Read(kStream);

	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2980]
	call	?Read@CvTeamTechs@@QAEXAAVFDataStream@@@Z ; CvTeamTechs::Read

; 7642 : 
; 7643 : 	ImprovementArrayHelpers::ReadYieldArray(kStream, m_ppaaiImprovementYieldChange, NUM_YIELD_TYPES);

	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2948]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	?ReadYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z ; ImprovementArrayHelpers::ReadYieldArray
	add	esp, 12					; 0000000cH

; 7644 : 	ImprovementArrayHelpers::ReadYieldArray(kStream, m_ppaaiImprovementNoFreshWaterYieldChange, NUM_YIELD_TYPES);

	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2952]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	?ReadYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z ; ImprovementArrayHelpers::ReadYieldArray
	add	esp, 12					; 0000000cH

; 7645 : 	ImprovementArrayHelpers::ReadYieldArray(kStream, m_ppaaiImprovementFreshWaterYieldChange, NUM_YIELD_TYPES);

	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2956]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	?ReadYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z ; ImprovementArrayHelpers::ReadYieldArray
	add	esp, 12					; 0000000cH

; 7646 : 
; 7647 : 	CvInfosSerializationHelper::ReadHashedTypeArray(kStream, m_aeRevealedResources);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2964				; 00000b94H
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$ReadHashedTypeArray@W4ResourceTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@AAV?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@@Z ; CvInfosSerializationHelper::ReadHashedTypeArray<enum ResourceTypes>
	add	esp, 8

; 7648 : 
; 7649 : 	// Fix bad 'at war' flags where we are at war with ourselves.  Not a good thing.
; 7650 : 	if(m_eID >= 0 && m_eID < MAX_TEAMS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jl	SHORT $LN13@Read
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 64			; 00000040H
	jge	SHORT $LN13@Read

; 7651 : 	{
; 7652 : 		m_abAtWar[m_eID] = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+eax+1928], 0

; 7653 : 		m_aiNumTurnsAtWar[m_eID] = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+468], 0
$LN13@Read:

; 7654 : 	}
; 7655 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Read@CvTeam@@UAEXAAVFDataStream@@@Z ENDP		; CvTeam::Read
_TEXT	ENDS
PUBLIC	??$WriteHashedTypeArray@W4ResourceTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@ABV?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@@Z ; CvInfosSerializationHelper::WriteHashedTypeArray<enum ResourceTypes>
PUBLIC	??$WriteHashedDataArray@W4VictoryTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum VictoryTypes,int>
PUBLIC	??$WriteHashedDataArray@W4TerrainTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum TerrainTypes,int>
PUBLIC	??$WriteHashedDataArray@W4ProjectTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum ProjectTypes,int>
PUBLIC	??$WriteHashedDataArray@W4BuildTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum BuildTypes,int>
PUBLIC	??$WriteHashedDataArray@W4RouteTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum RouteTypes,int>
PUBLIC	??$WriteHashedDataArray@W4SmallAwardTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum SmallAwardTypes,bool>
PUBLIC	??$WriteHashedDataArray@W4VictoryTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum VictoryTypes,bool>
PUBLIC	??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapperConst@_N@@@Z ; operator<<<bool>
PUBLIC	??$WriteHashedDataArray@W4VoteSourceTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum VoteSourceTypes,int>
PUBLIC	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapperConst@H@@@Z ; operator<<<int>
EXTRN	?WriteYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z:PROC ; ImprovementArrayHelpers::WriteYieldArray
EXTRN	?Write@CvTeamTechs@@QAEXAAVFDataStream@@@Z:PROC	; CvTeamTechs::Write
EXTRN	?Write@BuildingArrayHelpers@@YAXAAVFDataStream@@PAHH@Z:PROC ; BuildingArrayHelpers::Write
EXTRN	?Write@BuildingClassArrayHelpers@@YAXAAVFDataStream@@PAHH@Z:PROC ; BuildingClassArrayHelpers::Write
EXTRN	?Write@UnitClassArrayHelpers@@YAXAAVFDataStream@@PAHH@Z:PROC ; UnitClassArrayHelpers::Write
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@PBVCvBaseInfo@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4EraTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4TeamTypes@@@Z:PROC ; operator<<
EXTRN	?Write@FDataStream@@IAEXAB_N@Z:PROC		; FDataStream::Write
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Odtp
;	COMDAT ?Write@CvTeam@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -164						; size = 4
$T239540 = -160						; size = 4
$T239317 = -156						; size = 8
$T239316 = -148						; size = 4
$T239315 = -144						; size = 8
$T239314 = -136						; size = 8
$T239313 = -128						; size = 8
$T239312 = -120						; size = 8
$T239311 = -112						; size = 8
$T239310 = -104						; size = 8
$T239309 = -96						; size = 8
$T239308 = -88						; size = 8
$T239307 = -80						; size = 8
$T239306 = -72						; size = 8
$T239305 = -64						; size = 8
$T239304 = -56						; size = 8
$T239303 = -48						; size = 8
$T239302 = -40						; size = 8
$T239301 = -32						; size = 8
$T239300 = -24						; size = 8
_j$227090 = -16						; size = 4
_i$227085 = -12						; size = 4
_uiVersion$ = -8					; size = 4
_iNumImprovements$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Write@CvTeam@@UBEXAAVFDataStream@@@Z PROC		; CvTeam::Write, COMDAT
; _this$ = ecx

; 7660 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 164				; 000000a4H
	mov	DWORD PTR _this$[ebp], ecx

; 7661 : 	// Current version number
; 7662 : 	uint uiVersion = 1;

	mov	DWORD PTR _uiVersion$[ebp], 1

; 7663 : 	kStream << uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 7664 : 
; 7665 : 	kStream << m_iNumMembers;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7666 : 	kStream << m_iAliveCount;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7667 : 	kStream << m_iEverAliveCount;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7668 : 	kStream << m_iNumCities;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7669 : 	kStream << m_iTotalPopulation;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 24					; 00000018H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7670 : 	kStream << m_iTotalLand;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 28					; 0000001cH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7671 : 	kStream << m_iNukeInterception;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7672 : 	kStream << m_iExtraWaterSeeFromCount;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 36					; 00000024H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7673 : 	kStream << m_iMapTradingCount;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7674 : 	kStream << m_iTechTradingCount;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7675 : 	kStream << m_iGoldTradingCount;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 48					; 00000030H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7676 : 	kStream << m_iAllowEmbassyTradingAllowedCount;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 52					; 00000034H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7677 : 	kStream << m_iOpenBordersTradingAllowedCount;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7678 : 	kStream << m_iDefensivePactTradingAllowedCount;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 60					; 0000003cH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7679 : 	kStream << m_iResearchAgreementTradingAllowedCount;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 64					; 00000040H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7680 : 	kStream << m_iTradeAgreementTradingAllowedCount;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 68					; 00000044H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7681 : 	kStream << m_iPermanentAllianceTradingCount;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 72					; 00000048H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7682 : 	kStream << m_iBridgeBuildingCount;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 76					; 0000004cH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7683 : 	kStream << m_iWaterWorkCount;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7684 : 	kStream << m_iRiverTradeCount;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 84					; 00000054H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7685 : 	kStream << m_iBorderObstacleCount;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 88					; 00000058H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7686 : 	kStream << m_iVictoryPoints;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7687 : 	kStream << m_iEmbarkedExtraMoves;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 96					; 00000060H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7688 : 	//EAP: Extra embarked sight on tech
; 7689 : 	kStream << m_iEmbarkedExtraSight;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 100				; 00000064H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7690 : 	kStream << m_iCanEmbarkCount;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 104				; 00000068H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7691 : 	kStream << m_iDefensiveEmbarkCount;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 108				; 0000006cH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7692 : 	kStream << m_iEmbarkedAllWaterPassageCount;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 112				; 00000070H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7693 : 	kStream << m_iNumNaturalWondersDiscovered;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 116				; 00000074H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7694 : 	kStream << m_iBestPossibleRoute;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 120				; 00000078H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7695 : 	kStream << m_iNumMinorCivsAttacked;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 124				; 0000007cH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7696 : #ifdef AUI_ASTAR_TWEAKED_OPTIMIZED_BUT_CAN_STILL_USE_ROADS
; 7697 : 	kStream << m_iBestRouteFlatCostMultiplier;
; 7698 : 	kStream << m_iBestRouteNormalCostMultiplier;
; 7699 : 	kStream << m_iUseFlatCostIfBelowThis;
; 7700 : #endif
; 7701 : 
; 7702 : 	kStream << m_bMapCentering;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 128				; 00000080H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 7703 : 	kStream << m_bHasBrokenPeaceTreaty;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 129				; 00000081H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 7704 : 	kStream << m_bHomeOfUnitedNations;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 130				; 00000082H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 7705 : 	kStream << m_bHasTechForWorldCongress;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 131				; 00000083H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 7706 : 
; 7707 : 	kStream << m_bBrokenMilitaryPromise;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 132				; 00000084H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 7708 : 	kStream << m_bBrokenExpansionPromise;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 133				; 00000085H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 7709 : 	kStream << m_bBrokenBorderPromise;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 134				; 00000086H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 7710 : 	kStream << m_bBrokenCityStatePromise;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 135				; 00000087H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 7711 : 
; 7712 : 	kStream << m_eID;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??6@YAAAVFDataStream@@AAV0@ABW4TeamTypes@@@Z ; operator<<
	add	esp, 8

; 7713 : 
; 7714 : 	kStream << m_eCurrentEra;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 136				; 00000088H
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??6@YAAAVFDataStream@@AAV0@ABW4EraTypes@@@Z ; operator<<
	add	esp, 8

; 7715 : 	kStream << m_eLiberatedByTeam;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??6@YAAAVFDataStream@@AAV0@ABW4TeamTypes@@@Z ; operator<<
	add	esp, 8

; 7716 : 	kStream << m_eKilledByTeam;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 144				; 00000090H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??6@YAAAVFDataStream@@AAV0@ABW4TeamTypes@@@Z ; operator<<
	add	esp, 8

; 7717 : 
; 7718 : 	kStream << ArrayWrapperConst<int>(MAX_TEAMS, &m_aiTechShareCount[0]);

	xor	edx, edx
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+148]
	mov	DWORD PTR $T239300[ebp], ecx
	mov	DWORD PTR $T239300[ebp+4], 64		; 00000040H
	lea	edx, DWORD PTR $T239300[ebp]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapperConst@H@@@Z ; operator<<<int>
	add	esp, 8

; 7719 : 	kStream << ArrayWrapperConst<int>(MAX_TEAMS, &m_aiNumTurnsAtWar[0]);

	xor	ecx, ecx
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+468]
	mov	DWORD PTR $T239301[ebp], eax
	mov	DWORD PTR $T239301[ebp+4], 64		; 00000040H
	lea	ecx, DWORD PTR $T239301[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapperConst@H@@@Z ; operator<<<int>
	add	esp, 8

; 7720 : 	kStream << ArrayWrapperConst<int>(MAX_TEAMS, &m_aiNumTurnsLockedIntoWar[0]);

	xor	eax, eax
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+788]
	mov	DWORD PTR $T239302[ebp], edx
	mov	DWORD PTR $T239302[ebp+4], 64		; 00000040H
	lea	eax, DWORD PTR $T239302[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapperConst@H@@@Z ; operator<<<int>
	add	esp, 8

; 7721 : 	kStream << ArrayWrapperConst<int>(NUM_DOMAIN_TYPES, &m_aiExtraMoves[0]);

	xor	edx, edx
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+1108]
	mov	DWORD PTR $T239303[ebp], ecx
	mov	DWORD PTR $T239303[ebp+4], 5
	lea	edx, DWORD PTR $T239303[ebp]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapperConst@H@@@Z ; operator<<<int>
	add	esp, 8

; 7722 : 
; 7723 : 	CvInfosSerializationHelper::WriteHashedDataArray<VoteSourceTypes, int>(kStream, m_aiForceTeamVoteEligibilityCount, GC.getNumVoteSourceInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumVoteSourceInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumVoteSourceInfos
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2892]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$WriteHashedDataArray@W4VoteSourceTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum VoteSourceTypes,int>
	add	esp, 12					; 0000000cH

; 7724 : 
; 7725 : 	kStream << ArrayWrapperConst<int>(MAX_TEAMS, &m_paiTurnMadePeaceTreatyWithTeam[0]);

	xor	ecx, ecx
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+1128]
	mov	DWORD PTR $T239304[ebp], eax
	mov	DWORD PTR $T239304[ebp+4], 64		; 00000040H
	lea	ecx, DWORD PTR $T239304[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapperConst@H@@@Z ; operator<<<int>
	add	esp, 8

; 7726 : 	kStream << ArrayWrapperConst<int>(MAX_TEAMS, &m_aiIgnoreWarningCount[0]);

	xor	eax, eax
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1448]
	mov	DWORD PTR $T239305[ebp], edx
	mov	DWORD PTR $T239305[ebp+4], 64		; 00000040H
	lea	eax, DWORD PTR $T239305[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapperConst@H@@@Z ; operator<<<int>
	add	esp, 8

; 7727 : 
; 7728 : 	kStream << ArrayWrapperConst<bool>(MAX_TEAMS, &m_abHasMet[0]);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1848				; 00000738H
	mov	DWORD PTR $T239306[ebp], edx
	mov	DWORD PTR $T239306[ebp+4], 64		; 00000040H
	lea	eax, DWORD PTR $T239306[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapperConst@_N@@@Z ; operator<<<bool>
	add	esp, 8

; 7729 : 	kStream << ArrayWrapperConst<bool>(MAX_PLAYERS, &m_abHasFoundPlayersTerritory[0]);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1768				; 000006e8H
	mov	DWORD PTR $T239307[ebp], edx
	mov	DWORD PTR $T239307[ebp+4], 64		; 00000040H
	lea	eax, DWORD PTR $T239307[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapperConst@_N@@@Z ; operator<<<bool>
	add	esp, 8

; 7730 : 	kStream << ArrayWrapperConst<bool>(MAX_TEAMS, &m_abAtWar[0]);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1928				; 00000788H
	mov	DWORD PTR $T239308[ebp], edx
	mov	DWORD PTR $T239308[ebp+4], 64		; 00000040H
	lea	eax, DWORD PTR $T239308[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapperConst@_N@@@Z ; operator<<<bool>
	add	esp, 8

; 7731 : 	kStream << ArrayWrapperConst<bool>(MAX_TEAMS, &m_abPermanentWarPeace[0]);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2008				; 000007d8H
	mov	DWORD PTR $T239309[ebp], edx
	mov	DWORD PTR $T239309[ebp+4], 64		; 00000040H
	lea	eax, DWORD PTR $T239309[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapperConst@_N@@@Z ; operator<<<bool>
	add	esp, 8

; 7732 : 	kStream << ArrayWrapperConst<bool>(MAX_TEAMS, &m_abEmbassy[0]);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2088				; 00000828H
	mov	DWORD PTR $T239310[ebp], edx
	mov	DWORD PTR $T239310[ebp+4], 64		; 00000040H
	lea	eax, DWORD PTR $T239310[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapperConst@_N@@@Z ; operator<<<bool>
	add	esp, 8

; 7733 : 	kStream << ArrayWrapperConst<bool>(MAX_TEAMS, &m_abOpenBorders[0]);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2168				; 00000878H
	mov	DWORD PTR $T239311[ebp], edx
	mov	DWORD PTR $T239311[ebp+4], 64		; 00000040H
	lea	eax, DWORD PTR $T239311[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapperConst@_N@@@Z ; operator<<<bool>
	add	esp, 8

; 7734 : 	kStream << ArrayWrapperConst<bool>(MAX_TEAMS, &m_abDefensivePact[0]);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2248				; 000008c8H
	mov	DWORD PTR $T239312[ebp], edx
	mov	DWORD PTR $T239312[ebp+4], 64		; 00000040H
	lea	eax, DWORD PTR $T239312[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapperConst@_N@@@Z ; operator<<<bool>
	add	esp, 8

; 7735 : 	kStream << ArrayWrapperConst<bool>(MAX_TEAMS, &m_abResearchAgreement[0]);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2328				; 00000918H
	mov	DWORD PTR $T239313[ebp], edx
	mov	DWORD PTR $T239313[ebp+4], 64		; 00000040H
	lea	eax, DWORD PTR $T239313[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapperConst@_N@@@Z ; operator<<<bool>
	add	esp, 8

; 7736 : 	kStream << ArrayWrapperConst<bool>(MAX_TEAMS, &m_abTradeAgreement[0]);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2408				; 00000968H
	mov	DWORD PTR $T239314[ebp], edx
	mov	DWORD PTR $T239314[ebp+4], 64		; 00000040H
	lea	eax, DWORD PTR $T239314[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapperConst@_N@@@Z ; operator<<<bool>
	add	esp, 8

; 7737 : 	kStream << ArrayWrapperConst<bool>(MAX_TEAMS, &m_abForcePeace[0]);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2488				; 000009b8H
	mov	DWORD PTR $T239315[ebp], edx
	mov	DWORD PTR $T239315[ebp+4], 64		; 00000040H
	lea	eax, DWORD PTR $T239315[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapperConst@_N@@@Z ; operator<<<bool>
	add	esp, 8

; 7738 : 
; 7739 : 	CvInfosSerializationHelper::WriteHashedDataArray<VictoryTypes, bool>(kStream, m_abCanLaunch, GC.getNumVictoryInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumVictoryInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumVictoryInfos
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2896]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$WriteHashedDataArray@W4VictoryTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum VictoryTypes,bool>
	add	esp, 12					; 0000000cH

; 7740 : 	CvInfosSerializationHelper::WriteHashedDataArray<VictoryTypes, bool>(kStream, m_abVictoryAchieved, GC.getNumVictoryInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumVictoryInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumVictoryInfos
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2900]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$WriteHashedDataArray@W4VictoryTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum VictoryTypes,bool>
	add	esp, 12					; 0000000cH

; 7741 : 	CvInfosSerializationHelper::WriteHashedDataArray<SmallAwardTypes, bool>(kStream, m_abSmallAwardAchieved, GC.getNumSmallAwardInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumSmallAwardInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumSmallAwardInfos
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2904]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$WriteHashedDataArray@W4SmallAwardTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum SmallAwardTypes,bool>
	add	esp, 12					; 0000000cH

; 7742 : 	CvInfosSerializationHelper::WriteHashedDataArray<RouteTypes, int>(kStream, m_paiRouteChange, GC.getNumRouteInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumRouteInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumRouteInfos
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2908]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$WriteHashedDataArray@W4RouteTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum RouteTypes,int>
	add	esp, 12					; 0000000cH

; 7743 : 	CvInfosSerializationHelper::WriteHashedDataArray<BuildTypes, int>(kStream, m_paiBuildTimeChange, GC.getNumBuildInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2912]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$WriteHashedDataArray@W4BuildTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum BuildTypes,int>
	add	esp, 12					; 0000000cH

; 7744 : 	CvInfosSerializationHelper::WriteHashedDataArray<ProjectTypes, int>(kStream, m_paiProjectCount, GC.getNumProjectInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumProjectInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumProjectInfos
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2916]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$WriteHashedDataArray@W4ProjectTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum ProjectTypes,int>
	add	esp, 12					; 0000000cH

; 7745 : 	CvInfosSerializationHelper::WriteHashedDataArray<ProjectTypes, int>(kStream, m_paiProjectDefaultArtTypes, GC.getNumProjectInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumProjectInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumProjectInfos
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2920]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$WriteHashedDataArray@W4ProjectTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum ProjectTypes,int>
	add	esp, 12					; 0000000cH

; 7746 : 
; 7747 : 	//project art types
; 7748 : 	kStream << GC.getNumProjectInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumProjectInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumProjectInfos
	mov	DWORD PTR $T239316[ebp], eax
	lea	edx, DWORD PTR $T239316[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7749 : 
; 7750 : #ifdef AUI_WARNING_FIXES
; 7751 : 	for (uint i = 0; i<GC.getNumProjectInfos(); i++)
; 7752 : #else
; 7753 : 	for(int i=0; i<GC.getNumProjectInfos(); i++)

	mov	DWORD PTR _i$227085[ebp], 0
	jmp	SHORT $LN6@Write
$LN5@Write:
	mov	eax, DWORD PTR _i$227085[ebp]
	add	eax, 1
	mov	DWORD PTR _i$227085[ebp], eax
$LN6@Write:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumProjectInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumProjectInfos
	cmp	DWORD PTR _i$227085[ebp], eax
	jge	SHORT $LN4@Write

; 7754 : #endif
; 7755 : 	{
; 7756 : 		CvInfosSerializationHelper::WriteHashed(kStream, GC.getProjectInfo((ProjectTypes)i));

	mov	ecx, DWORD PTR _i$227085[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getProjectInfo@CvGlobals@@QAEPAVCvProjectEntry@@W4ProjectTypes@@@Z ; CvGlobals::getProjectInfo
	push	eax
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@PBVCvBaseInfo@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8

; 7757 : 		for(int j=0; j<m_paiProjectCount[i]; j++)

	mov	DWORD PTR _j$227090[ebp], 0
	jmp	SHORT $LN3@Write
$LN2@Write:
	mov	eax, DWORD PTR _j$227090[ebp]
	add	eax, 1
	mov	DWORD PTR _j$227090[ebp], eax
$LN3@Write:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2916]
	mov	eax, DWORD PTR _i$227085[ebp]
	mov	ecx, DWORD PTR _j$227090[ebp]
	cmp	ecx, DWORD PTR [edx+eax*4]
	jge	SHORT $LN1@Write

; 7758 : 		{
; 7759 : 			kStream << m_pavProjectArtTypes[i][j];

	mov	edx, DWORD PTR _i$227085[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2960]
	mov	edx, DWORD PTR [ecx+edx+4]
	mov	eax, DWORD PTR _j$227090[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T239540[ebp], ecx
	mov	edx, DWORD PTR $T239540[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7760 : 		}

	jmp	SHORT $LN2@Write
$LN1@Write:

; 7761 : 	}

	jmp	$LN5@Write
$LN4@Write:

; 7762 : 
; 7763 : 	CvInfosSerializationHelper::WriteHashedDataArray<ProjectTypes, int>(kStream, m_paiProjectMaking, GC.getNumProjectInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumProjectInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumProjectInfos
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2924]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$WriteHashedDataArray@W4ProjectTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum ProjectTypes,int>
	add	esp, 12					; 0000000cH

; 7764 : 
; 7765 : 	UnitClassArrayHelpers::Write(kStream, m_paiUnitClassCount, GC.getNumUnitClassInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumUnitClassInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitClassInfos
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2928]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?Write@UnitClassArrayHelpers@@YAXAAVFDataStream@@PAHH@Z ; UnitClassArrayHelpers::Write
	add	esp, 12					; 0000000cH

; 7766 : 	BuildingClassArrayHelpers::Write(kStream, m_paiBuildingClassCount, GC.getNumBuildingClassInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2932]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?Write@BuildingClassArrayHelpers@@YAXAAVFDataStream@@PAHH@Z ; BuildingClassArrayHelpers::Write
	add	esp, 12					; 0000000cH

; 7767 : 	BuildingArrayHelpers::Write(kStream, m_paiObsoleteBuildingCount, GC.getNumBuildingInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2936]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?Write@BuildingArrayHelpers@@YAXAAVFDataStream@@PAHH@Z ; BuildingArrayHelpers::Write
	add	esp, 12					; 0000000cH

; 7768 : 
; 7769 : 	CvInfosSerializationHelper::WriteHashedDataArray<TerrainTypes, int>(kStream, m_paiTerrainTradeCount, GC.getNumTerrainInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTerrainInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTerrainInfos
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2940]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$WriteHashedDataArray@W4TerrainTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum TerrainTypes,int>
	add	esp, 12					; 0000000cH

; 7770 : 	CvInfosSerializationHelper::WriteHashedDataArray<VictoryTypes, int>(kStream, m_aiVictoryCountdown, GC.getNumVictoryInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumVictoryInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumVictoryInfos
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2944]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$WriteHashedDataArray@W4VictoryTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum VictoryTypes,int>
	add	esp, 12					; 0000000cH

; 7771 : 	kStream << ArrayWrapperConst<int>(MAX_CIV_TEAMS, &m_aiTurnTeamMet[0]);

	xor	eax, eax
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+2568]
	mov	DWORD PTR $T239317[ebp], edx
	mov	DWORD PTR $T239317[ebp+4], 63		; 0000003fH
	lea	eax, DWORD PTR $T239317[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapperConst@H@@@Z ; operator<<<int>
	add	esp, 8

; 7772 : 
; 7773 : 	m_pTeamTechs->Write(kStream);

	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2980]
	call	?Write@CvTeamTechs@@QAEXAAVFDataStream@@@Z ; CvTeamTechs::Write

; 7774 : 
; 7775 : 	int iNumImprovements = GC.getNumImprovementInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumImprovementInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumImprovementInfos
	mov	DWORD PTR _iNumImprovements$[ebp], eax

; 7776 : 	ImprovementArrayHelpers::WriteYieldArray(kStream, m_ppaaiImprovementYieldChange, iNumImprovements);

	mov	ecx, DWORD PTR _iNumImprovements$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2948]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	?WriteYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z ; ImprovementArrayHelpers::WriteYieldArray
	add	esp, 12					; 0000000cH

; 7777 : 	ImprovementArrayHelpers::WriteYieldArray(kStream, m_ppaaiImprovementNoFreshWaterYieldChange, iNumImprovements);

	mov	edx, DWORD PTR _iNumImprovements$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2952]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?WriteYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z ; ImprovementArrayHelpers::WriteYieldArray
	add	esp, 12					; 0000000cH

; 7778 : 	ImprovementArrayHelpers::WriteYieldArray(kStream, m_ppaaiImprovementFreshWaterYieldChange, iNumImprovements);

	mov	eax, DWORD PTR _iNumImprovements$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2956]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	?WriteYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z ; ImprovementArrayHelpers::WriteYieldArray
	add	esp, 12					; 0000000cH

; 7779 : 
; 7780 : 	CvInfosSerializationHelper::WriteHashedTypeArray(kStream, m_aeRevealedResources);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2964				; 00000b94H
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$WriteHashedTypeArray@W4ResourceTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@ABV?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@@Z ; CvInfosSerializationHelper::WriteHashedTypeArray<enum ResourceTypes>
	add	esp, 8

; 7781 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Write@CvTeam@@UBEXAAVFDataStream@@@Z ENDP		; CvTeam::Write
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?AddNotification@CvTeam@@QAEXW4NotificationTypes@@PBD1HHHH@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T239569 = -20						; size = 4
$T239560 = -13						; size = 1
_loopPlayer$227142 = -12				; size = 4
_iI$227137 = -8						; size = 4
_eLoopPlayer$ = -4					; size = 4
_eNotificationType$ = 8					; size = 4
_strMessage$ = 12					; size = 4
_strSummary$ = 16					; size = 4
_iX$ = 20						; size = 4
_iY$ = 24						; size = 4
_iGameDataIndex$ = 28					; size = 4
_iExtraGameData$ = 32					; size = 4
?AddNotification@CvTeam@@QAEXW4NotificationTypes@@PBD1HHHH@Z PROC ; CvTeam::AddNotification, COMDAT
; _this$ = ecx

; 7789 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 7790 : 	PlayerTypes eLoopPlayer;
; 7791 : 
; 7792 : 	for(int iI = 0; iI < MAX_MAJOR_CIVS; iI++)

	mov	DWORD PTR _iI$227137[ebp], 0
	jmp	SHORT $LN6@AddNotific
$LN5@AddNotific:
	mov	eax, DWORD PTR _iI$227137[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$227137[ebp], eax
$LN6@AddNotific:
	cmp	DWORD PTR _iI$227137[ebp], 22		; 00000016H
	jge	$LN7@AddNotific

; 7793 : 	{
; 7794 : 		eLoopPlayer = (PlayerTypes) iI;

	mov	ecx, DWORD PTR _iI$227137[ebp]
	mov	DWORD PTR _eLoopPlayer$[ebp], ecx

; 7795 : 		CvPlayer& loopPlayer = GET_PLAYER(eLoopPlayer);

	mov	edx, DWORD PTR _eLoopPlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _loopPlayer$227142[ebp], edx

; 7796 : 
; 7797 : 		if(!loopPlayer.isAlive())

	mov	eax, DWORD PTR _loopPlayer$227142[ebp]
	mov	cl, BYTE PTR [eax+2256]
	mov	BYTE PTR $T239560[ebp], cl
	movzx	edx, BYTE PTR $T239560[ebp]
	test	edx, edx
	jne	SHORT $LN17@AddNotific

; 7798 : 			continue;

	jmp	SHORT $LN5@AddNotific

; 7799 : 
; 7800 : 		if(loopPlayer.getTeam() != GetID())

$LN17@AddNotific:
	mov	eax, DWORD PTR _loopPlayer$227142[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T239569[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	cmp	DWORD PTR $T239569[ebp], eax
	je	SHORT $LN2@AddNotific

; 7801 : 			continue;

	jmp	SHORT $LN5@AddNotific
$LN2@AddNotific:

; 7802 : 
; 7803 : 		if(!loopPlayer.GetNotifications())

	mov	ecx, DWORD PTR _loopPlayer$227142[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	test	eax, eax
	jne	SHORT $LN1@AddNotific

; 7804 : 			continue;

	jmp	SHORT $LN5@AddNotific
$LN1@AddNotific:

; 7805 : 
; 7806 : 		loopPlayer.GetNotifications()->Add(eNotificationType, strMessage, strSummary, iX, iY, iGameDataIndex, iExtraGameData);

	mov	edx, DWORD PTR _iExtraGameData$[ebp]
	push	edx
	mov	eax, DWORD PTR _iGameDataIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iX$[ebp]
	push	edx
	mov	eax, DWORD PTR _strSummary$[ebp]
	push	eax
	mov	ecx, DWORD PTR _strMessage$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eNotificationType$[ebp]
	push	edx
	mov	ecx, DWORD PTR _loopPlayer$227142[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ecx, eax
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
	jmp	$LN5@AddNotific
$LN7@AddNotific:

; 7807 : 	}
; 7808 : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?AddNotification@CvTeam@@QAEXW4NotificationTypes@@PBD1HHHH@Z ENDP ; CvTeam::AddNotification
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::~vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXXZ ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::~vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >
PUBLIC	?insert@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@ABW4ResourceTypes@@@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::insert
PUBLIC	??$_Uninit_fill_n@PAW4ResourceTypes@@IW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAXPAW4ResourceTypes@@IABW41@AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum ResourceTypes *,unsigned int,enum ResourceTypes,std::allocator<enum ResourceTypes> >
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEXABW4ResourceTypes@@@Z
_TEXT	SEGMENT
tv129 = -64						; size = 4
_this$ = -60						; size = 4
$T239707 = -32						; size = 4
$T239697 = -28						; size = 4
$T239687 = -24						; size = 4
__Cat$239694 = -19					; size = 1
$T239692 = -18						; size = 1
$T239691 = -17						; size = 1
$T239664 = -16						; size = 4
$T239660 = -12						; size = 4
$T239659 = -8						; size = 4
$T239658 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEXABW4ResourceTypes@@@Z PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T239664[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN9@push_back
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN7@push_back
$LN9@push_back:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv129[ebp], eax
$LN7@push_back:
	mov	ecx, DWORD PTR $T239664[ebp]
	cmp	ecx, DWORD PTR tv129[ebp]
	jae	SHORT $LN2@push_back

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T239697[ebp], eax
	mov	ecx, DWORD PTR $T239697[ebp]
	mov	DWORD PTR $T239687[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T239691[ebp], dl
	mov	al, BYTE PTR __Cat$239694[ebp]
	mov	BYTE PTR $T239692[ebp], al
	movzx	ecx, BYTE PTR $T239691[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T239692[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR $T239687[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAW4ResourceTypes@@IW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAXPAW4ResourceTypes@@IABW41@AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum ResourceTypes *,unsigned int,enum ResourceTypes,std::allocator<enum ResourceTypes> >
	add	esp, 24					; 00000018H
	mov	eax, 1
	shl	eax, 2
	add	eax, DWORD PTR $T239697[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back
$LN2@push_back:

; 823  : 			insert(end(), _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T239707[ebp], eax
	mov	ecx, DWORD PTR $T239707[ebp]
	mov	DWORD PTR $T239659[ebp], ecx
	mov	edx, DWORD PTR $T239659[ebp]
	mov	DWORD PTR $T239658[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239658[ebp]
	push	ecx
	lea	edx, DWORD PTR $T239660[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@ABW4ResourceTypes@@@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::insert
$LN3@push_back:

; 824  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEXABW4ResourceTypes@@@Z ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::push_back
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?erase@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -60						; size = 4
$T239877 = -56						; size = 4
$T239876 = -52						; size = 4
$T239858 = -48						; size = 4
$T239857 = -44						; size = 4
$T239841 = -40						; size = 4
__Cat$239864 = -34					; size = 1
$T239862 = -33						; size = 1
$T239815 = -32						; size = 4
$T239814 = -28						; size = 4
$T239813 = -24						; size = 4
$T239796 = -18						; size = 1
$T239795 = -17						; size = 1
$T239794 = -16						; size = 4
$T239793 = -12						; size = 4
__Cat$239802 = -4					; size = 1
$T239800 = -3						; size = 1
$T239799 = -2						; size = 1
$T239798 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@@Z PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::erase, COMDAT
; _this$ = ecx

; 1017 : 		{	// erase element at where

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	DWORD PTR _this$[ebp], ecx

; 1018 : 		_STDEXT unchecked_copy(_VEC_ITER_BASE(_Where) + 1, _Mylast,
; 1019 : 			_VEC_ITER_BASE(_Where));

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T239815[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T239814[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	add	eax, 4
	mov	DWORD PTR $T239813[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T239798[ebp], cl
	mov	dl, BYTE PTR __Cat$239802[ebp]
	mov	BYTE PTR $T239799[ebp], dl
	mov	al, BYTE PTR $T239798[ebp]
	mov	BYTE PTR $T239796[ebp], al
	mov	cl, BYTE PTR $T239800[ebp]
	mov	BYTE PTR $T239795[ebp], cl
	mov	edx, DWORD PTR $T239815[ebp]
	mov	DWORD PTR $T239794[ebp], edx
	mov	eax, DWORD PTR $T239813[ebp]
	mov	DWORD PTR $T239793[ebp], eax
	jmp	SHORT $LN11@erase
$LN10@erase:
	mov	ecx, DWORD PTR $T239794[ebp]
	add	ecx, 4
	mov	DWORD PTR $T239794[ebp], ecx
	mov	edx, DWORD PTR $T239793[ebp]
	add	edx, 4
	mov	DWORD PTR $T239793[ebp], edx
$LN11@erase:
	mov	eax, DWORD PTR $T239793[ebp]
	cmp	eax, DWORD PTR $T239814[ebp]
	je	SHORT $LN3@erase
	mov	ecx, DWORD PTR $T239794[ebp]
	mov	edx, DWORD PTR $T239793[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN10@erase
$LN3@erase:

; 1020 : 		_Destroy(_Mylast - 1, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T239877[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, 4
	mov	DWORD PTR $T239876[ebp], ecx
	mov	edx, DWORD PTR $T239877[ebp]
	mov	DWORD PTR $T239858[ebp], edx
	mov	eax, DWORD PTR $T239876[ebp]
	mov	DWORD PTR $T239857[ebp], eax
	mov	cl, BYTE PTR __Cat$239864[ebp]
	mov	BYTE PTR $T239862[ebp], cl
	mov	edx, DWORD PTR $T239857[ebp]
	mov	DWORD PTR $T239841[ebp], edx
	jmp	SHORT $LN22@erase
$LN21@erase:
	mov	eax, DWORD PTR $T239841[ebp]
	add	eax, 4
	mov	DWORD PTR $T239841[ebp], eax
$LN22@erase:
	mov	ecx, DWORD PTR $T239841[ebp]
	cmp	ecx, DWORD PTR $T239858[ebp]
	je	SHORT $LN14@erase
	jmp	SHORT $LN21@erase
$LN14@erase:

; 1021 : 		--_Mylast;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1022 : 		return (_Make_iter(_Where));

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1023 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@@Z ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::erase
_TEXT	ENDS
PUBLIC	??1?$BaseVector@W4PlayerTypes@@$00@@QAE@XZ	; BaseVector<enum PlayerTypes,1>::~BaseVector<enum PlayerTypes,1>
PUBLIC	??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ ; `string'
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ DB 'd:\sources\'
	DB	'lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\FF'
	DB	'astVector.h', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T239905 = -20						; size = 4
_pRet$239901 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<enum PlayerTypes,63,1,297,0>::FStaticVector<enum PlayerTypes,63,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 63			; 0000003fH

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T239905[ebp], edx
	cmp	DWORD PTR $T239905[ebp], 63		; 0000003fH
	jbe	SHORT $LN7@FStaticVec
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T239905[ebp]
	shl	eax, 2
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$239901[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T239905[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec
$LN7@FStaticVec:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$239901[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 63			; 0000003fH
$LN8@FStaticVec:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$239901[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@W4PlayerTypes@@$00@@QAE@XZ ; BaseVector<enum PlayerTypes,1>::~BaseVector<enum PlayerTypes,1>
__ehhandler$??0?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<enum PlayerTypes,63,1,297,0>::FStaticVector<enum PlayerTypes,63,1,297,0>
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T239936 = -24						; size = 4
$T239935 = -20						; size = 4
_i$239930 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<enum PlayerTypes,63,1,297,0>::~FStaticVector<enum PlayerTypes,63,1,297,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T239936[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T239935[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN5@FStaticVec@2
	xor	edx, edx
	je	SHORT $LN5@FStaticVec@2
	mov	DWORD PTR _i$239930[ebp], 0
	jmp	SHORT $LN10@FStaticVec@2
$LN9@FStaticVec@2:
	mov	eax, DWORD PTR _i$239930[ebp]
	add	eax, 1
	mov	DWORD PTR _i$239930[ebp], eax
$LN10@FStaticVec@2:
	mov	ecx, DWORD PTR _i$239930[ebp]
	cmp	ecx, DWORD PTR $T239936[ebp]
	jae	SHORT $LN5@FStaticVec@2
	jmp	SHORT $LN9@FStaticVec@2
$LN5@FStaticVec@2:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T239935[ebp], edx
	je	SHORT $LN1@FStaticVec@2
	mov	eax, DWORD PTR $T239935[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@FStaticVec@2:

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@W4PlayerTypes@@$00@@QAE@XZ ; BaseVector<enum PlayerTypes,1>::~BaseVector<enum PlayerTypes,1>
__ehhandler$??1?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<enum PlayerTypes,63,1,297,0>::~FStaticVector<enum PlayerTypes,63,1,297,0>
PUBLIC	?GrowSize@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<enum PlayerTypes,63,1,297,0>::GrowSize
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAEIABW4PlayerTypes@@@Z
_TEXT	SEGMENT
tv140 = -52						; size = 4
tv131 = -48						; size = 4
_this$ = -44						; size = 4
$T239948 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAEIABW4PlayerTypes@@@Z PROC ; FStaticVector<enum PlayerTypes,63,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+264], 0

; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN35@push_back@2

; 679  : 			GrowSize(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<enum PlayerTypes,63,1,297,0>::GrowSize

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN35@push_back@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T239948[ebp], ecx
	cmp	DWORD PTR $T239948[ebp], 0
	je	SHORT $LN4@push_back@2
	mov	edx, DWORD PTR $T239948[ebp]
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T239948[ebp]
	mov	DWORD PTR tv131[ebp], edx
	jmp	SHORT $LN5@push_back@2
$LN4@push_back@2:
	mov	DWORD PTR tv131[ebp], 0
$LN5@push_back@2:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv140[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR tv140[ebp]

; 682  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAEIABW4PlayerTypes@@@Z ENDP ; FStaticVector<enum PlayerTypes,63,1,297,0>::push_back
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
_TEXT	ENDS
;	COMDAT ??1?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
??1?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE@XZ PROC ; CvWeightedVector<enum TeamTypes,63,1>::~CvWeightedVector<enum TeamTypes,63,1>, COMDAT
; _this$ = ecx

; 58   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 59   : 	};

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::~FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE@XZ ENDP ; CvWeightedVector<enum TeamTypes,63,1>::~CvWeightedVector<enum TeamTypes,63,1>
_TEXT	ENDS
PUBLIC	??$_Sort@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0H@Z ; std::_Sort<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,int>
; Function compile flags: /Odtp
;	COMDAT ?SortItems@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAEXXZ
_TEXT	SEGMENT
_this$ = -156						; size = 4
$T240029 = -8						; size = 4
$T240025 = -4						; size = 4
?SortItems@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAEXXZ PROC ; CvWeightedVector<enum TeamTypes,63,1>::SortItems, COMDAT
; _this$ = ecx

; 139  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		std::sort(m_pItems.begin(), m_pItems.end());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T240025[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T240029[ebp], eax
	mov	ecx, DWORD PTR $T240025[ebp]
	sub	ecx, DWORD PTR $T240029[ebp]
	sar	ecx, 3
	push	ecx
	mov	edx, DWORD PTR $T240025[ebp]
	push	edx
	mov	eax, DWORD PTR $T240029[ebp]
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0H@Z ; std::_Sort<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 141  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?SortItems@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAEXXZ ENDP ; CvWeightedVector<enum TeamTypes,63,1>::SortItems
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ChooseFromTopChoices@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE?AW4TeamTypes@@HPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T240232 = -36						; size = 4
$T240228 = -32						; size = 4
$T240217 = -28						; size = 4
$T240213 = -24						; size = 4
_iTotalTopChoicesWeight$ = -20				; size = 4
_iChoice$ = -16						; size = 4
_i$ = -12						; size = 4
_elem$ = -8						; size = 8
_iNumChoices$ = 8					; size = 4
_rndFcn$ = 12						; size = 4
_szRollName$ = 16					; size = 4
?ChooseFromTopChoices@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE?AW4TeamTypes@@HPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z PROC ; CvWeightedVector<enum TeamTypes,63,1>::ChooseFromTopChoices, COMDAT
; _this$ = ecx

; 223  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 224  : 		// Loop through the top choices, or the total vector size, whichever is smaller
; 225  : 		if (iNumChoices > (int) m_pItems.size())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T240213[ebp], ecx
	mov	edx, DWORD PTR _iNumChoices$[ebp]
	cmp	edx, DWORD PTR $T240213[ebp]
	jle	SHORT $LN8@ChooseFrom

; 226  : 		{
; 227  : 			iNumChoices = (int) m_pItems.size();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T240217[ebp], ecx
	mov	edx, DWORD PTR $T240217[ebp]
	mov	DWORD PTR _iNumChoices$[ebp], edx
$LN8@ChooseFrom:

; 228  : 		}
; 229  : 
; 230  : 		WeightedElement elem;

	mov	DWORD PTR _elem$[ebp], 0
	mov	DWORD PTR _elem$[ebp+4], 0

; 231  : 		int i;
; 232  : 		int iChoice;
; 233  : 		int iTotalTopChoicesWeight = 0;

	mov	DWORD PTR _iTotalTopChoicesWeight$[ebp], 0

; 234  : 
; 235  : 		// Get the total weight
; 236  : 		for (i = 0; i < iNumChoices; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@ChooseFrom
$LN6@ChooseFrom:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@ChooseFrom:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _iNumChoices$[ebp]
	jge	SHORT $LN5@ChooseFrom

; 237  : 		{
; 238  : 			elem = m_pItems[i];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR [eax+ecx*8+4]
	mov	DWORD PTR _elem$[ebp], edx
	mov	DWORD PTR _elem$[ebp+4], eax

; 239  : 			iTotalTopChoicesWeight += elem.m_iWeight;

	mov	ecx, DWORD PTR _iTotalTopChoicesWeight$[ebp]
	add	ecx, DWORD PTR _elem$[ebp+4]
	mov	DWORD PTR _iTotalTopChoicesWeight$[ebp], ecx

; 240  : 		}

	jmp	SHORT $LN6@ChooseFrom
$LN5@ChooseFrom:

; 241  : 
; 242  : 		// Random roll up to total weight
; 243  : 		iChoice = (*rndFcn)(iTotalTopChoicesWeight, szRollName);

	mov	edx, DWORD PTR _rndFcn$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T240228[ebp], eax
	mov	ecx, DWORD PTR _rndFcn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T240232[ebp], edx
	mov	eax, DWORD PTR _szRollName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iTotalTopChoicesWeight$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T240232[ebp]
	call	DWORD PTR $T240228[ebp]
	mov	DWORD PTR _iChoice$[ebp], eax

; 244  : 
; 245  : 		// Find out which element was chosen
; 246  : 		for (i = 0; i < iNumChoices; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@ChooseFrom
$LN3@ChooseFrom:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@ChooseFrom:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _iNumChoices$[ebp]
	jge	SHORT $LN2@ChooseFrom

; 247  : 		{
; 248  : 			elem = m_pItems[i];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR [edx+eax*8+4]
	mov	DWORD PTR _elem$[ebp], ecx
	mov	DWORD PTR _elem$[ebp+4], edx

; 249  : 			iChoice -= elem.m_iWeight;

	mov	eax, DWORD PTR _iChoice$[ebp]
	sub	eax, DWORD PTR _elem$[ebp+4]
	mov	DWORD PTR _iChoice$[ebp], eax

; 250  : 			if (iChoice < 0)

	jns	SHORT $LN1@ChooseFrom

; 251  : 			{
; 252  : 				return elem.m_Element;

	mov	eax, DWORD PTR _elem$[ebp]
	jmp	SHORT $LN9@ChooseFrom
$LN1@ChooseFrom:

; 253  : 			}
; 254  : 		}

	jmp	SHORT $LN3@ChooseFrom
$LN2@ChooseFrom:

; 255  : 
; 256  : 		// We should have found something, so reaching here is an error
; 257  : 		//    Just return last thing accessed
; 258  : 		CvAssertMsg (false, "Internal error in CvWeightedVector.");
; 259  : 		return elem.m_Element;

	mov	eax, DWORD PTR _elem$[ebp]
$LN9@ChooseFrom:

; 260  : 	};

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?ChooseFromTopChoices@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE?AW4TeamTypes@@HPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ENDP ; CvWeightedVector<enum TeamTypes,63,1>::ChooseFromTopChoices
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_inst$240249 = -8					; size = 4
$T240244 = -4						; size = 4
??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ PROC		; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>, COMDAT
; _this$ = ecx

; 720  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 721  : 		delete _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T240244[ebp], ecx
	cmp	DWORD PTR $T240244[ebp], 0
	je	SHORT $LN1@auto_ptr
	mov	edx, DWORD PTR $T240244[ebp]
	mov	DWORD PTR _inst$240249[ebp], edx
	mov	eax, DWORD PTR _inst$240249[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _inst$240249[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+4]
	call	eax
$LN1@auto_ptr:

; 722  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ ENDP		; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<enum ResourceTypes,std::allocator<enum ResourceTypes> >::~_Vector_val<enum ResourceTypes,std::allocator<enum ResourceTypes> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<enum ResourceTypes,std::allocator<enum ResourceTypes> >::~_Vector_val<enum ResourceTypes,std::allocator<enum ResourceTypes> >
_TEXT	ENDS
PUBLIC	?Alloc@?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > >::Alloc
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fbatchallocate.h
;	COMDAT ?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z
_TEXT	SEGMENT
_this$ = -196						; size = 4
_nLocalBytes$ = -16					; size = 4
_pLocMemStart$ = -12					; size = 4
_iAlignmentFix$ = -8					; size = 4
_pRet$ = -4						; size = 4
_nBytes$ = 8						; size = 4
_pData$ = 12						; size = 4
?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z PROC ; FAllocArrayType<int,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > > >::Alloc, COMDAT
; _this$ = ecx

; 69   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	mov	DWORD PTR _this$[ebp], ecx

; 70   : 		unsigned int nLocalBytes = sizeof(TYPE) * (pData->nX + 1);

	mov	eax, DWORD PTR _pData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	lea	edx, DWORD PTR [ecx*4+4]
	mov	DWORD PTR _nLocalBytes$[ebp], edx

; 71   : 		void* pRet = BASE::Alloc( nBytes + nLocalBytes, pData+1 );

	mov	eax, DWORD PTR _pData$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _nBytes$[ebp]
	add	ecx, DWORD PTR _nLocalBytes$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Alloc@?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > >::Alloc
	mov	DWORD PTR _pRet$[ebp], eax

; 72   : 		unsigned char* pLocMemStart = static_cast< unsigned char* > ( pRet ) - nLocalBytes;

	mov	edx, DWORD PTR _pRet$[ebp]
	sub	edx, DWORD PTR _nLocalBytes$[ebp]
	mov	DWORD PTR _pLocMemStart$[ebp], edx

; 73   : 
; 74   : 		unsigned int iAlignmentFix = sizeof(TYPE) - reinterpret_cast< unsigned int >(pLocMemStart) % sizeof(TYPE);

	mov	eax, DWORD PTR _pLocMemStart$[ebp]
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	mov	eax, 4
	sub	eax, edx
	mov	DWORD PTR _iAlignmentFix$[ebp], eax

; 75   : 		(*static_cast< TYPE** >(pData->pOut)) = (TYPE*)( pLocMemStart + iAlignmentFix );

	mov	ecx, DWORD PTR _pLocMemStart$[ebp]
	add	ecx, DWORD PTR _iAlignmentFix$[ebp]
	mov	edx, DWORD PTR _pData$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 76   : 
; 77   : 		return static_cast< void* >( pLocMemStart );

	mov	eax, DWORD PTR _pLocMemStart$[ebp]

; 78   : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ENDP ; FAllocArrayType<int,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > > >::Alloc
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Insert_n
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?insert@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@ABW4ResourceTypes@@@Z
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
__Tmp$240323 = -24					; size = 4
$T240306 = -20						; size = 4
$T240287 = -16						; size = 4
$T240274 = -12						; size = 4
$T240271 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@ABW4ResourceTypes@@@Z PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	test	edx, edx
	jne	SHORT $LN3@insert
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert
$LN3@insert:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T240287[ebp], ecx
	mov	edx, DWORD PTR $T240287[ebp]
	mov	DWORD PTR $T240271[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	sub	eax, DWORD PTR $T240271[ebp]
	sar	eax, 2
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T240306[ebp], edx
	mov	eax, DWORD PTR $T240306[ebp]
	mov	DWORD PTR $T240274[ebp], eax
	mov	ecx, DWORD PTR $T240274[ebp]
	mov	DWORD PTR __Tmp$240323[ebp], ecx
	mov	edx, DWORD PTR __Off$[ebp]
	mov	eax, DWORD PTR __Tmp$240323[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR __Tmp$240323[ebp], ecx
	mov	edx, DWORD PTR __Tmp$240323[ebp]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@ABW4ResourceTypes@@@Z ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::insert
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?erase@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
$T240470 = -64						; size = 4
$T240452 = -60						; size = 4
$T240451 = -56						; size = 4
$T240435 = -52						; size = 4
__Cat$240458 = -46					; size = 1
$T240456 = -45						; size = 1
$T240409 = -44						; size = 4
$T240408 = -40						; size = 4
$T240407 = -36						; size = 4
$T240390 = -30						; size = 1
$T240389 = -29						; size = 1
$T240388 = -28						; size = 4
$T240387 = -24						; size = 4
__Cat$240396 = -16					; size = 1
$T240394 = -15						; size = 1
$T240393 = -14						; size = 1
$T240392 = -13						; size = 1
__Ptr$227368 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@0@Z PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	$LN1@erase@2

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T240409[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T240408[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T240407[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T240392[ebp], cl
	mov	dl, BYTE PTR __Cat$240396[ebp]
	mov	BYTE PTR $T240393[ebp], dl
	mov	al, BYTE PTR $T240392[ebp]
	mov	BYTE PTR $T240390[ebp], al
	mov	cl, BYTE PTR $T240394[ebp]
	mov	BYTE PTR $T240389[ebp], cl
	mov	edx, DWORD PTR $T240409[ebp]
	mov	DWORD PTR $T240388[ebp], edx
	mov	eax, DWORD PTR $T240407[ebp]
	mov	DWORD PTR $T240387[ebp], eax
	jmp	SHORT $LN28@erase@2
$LN27@erase@2:
	mov	ecx, DWORD PTR $T240388[ebp]
	add	ecx, 4
	mov	DWORD PTR $T240388[ebp], ecx
	mov	edx, DWORD PTR $T240387[ebp]
	add	edx, 4
	mov	DWORD PTR $T240387[ebp], edx
$LN28@erase@2:
	mov	eax, DWORD PTR $T240387[ebp]
	cmp	eax, DWORD PTR $T240408[ebp]
	je	SHORT $LN20@erase@2
	mov	ecx, DWORD PTR $T240388[ebp]
	mov	edx, DWORD PTR $T240387[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN27@erase@2
$LN20@erase@2:
	mov	ecx, DWORD PTR $T240388[ebp]
	mov	DWORD PTR __Ptr$227368[ebp], ecx

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T240470[ebp], eax
	mov	ecx, DWORD PTR $T240470[ebp]
	mov	DWORD PTR $T240452[ebp], ecx
	mov	edx, DWORD PTR __Ptr$227368[ebp]
	mov	DWORD PTR $T240451[ebp], edx
	mov	al, BYTE PTR __Cat$240458[ebp]
	mov	BYTE PTR $T240456[ebp], al
	mov	ecx, DWORD PTR $T240451[ebp]
	mov	DWORD PTR $T240435[ebp], ecx
	jmp	SHORT $LN39@erase@2
$LN38@erase@2:
	mov	edx, DWORD PTR $T240435[ebp]
	add	edx, 4
	mov	DWORD PTR $T240435[ebp], edx
$LN39@erase@2:
	mov	eax, DWORD PTR $T240435[ebp]
	cmp	eax, DWORD PTR $T240452[ebp]
	je	SHORT $LN31@erase@2
	jmp	SHORT $LN38@erase@2
$LN31@erase@2:

; 1049 : 			_Mylast = _Ptr;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Ptr$227368[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN1@erase@2:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@0@Z ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::erase
_TEXT	ENDS
PUBLIC	??$_Allocate@W4ResourceTypes@@@std@@YAPAW4ResourceTypes@@IPAW41@@Z ; std::_Allocate<enum ResourceTypes>
PUBLIC	?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$240485 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAE_NI@Z PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy
	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$240485[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$240485[ebp], 0
	jbe	SHORT $LN11@Buy
	mov	eax, DWORD PTR __Count$240485[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy
$LN11@Buy:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@W4ResourceTypes@@@std@@YAPAW4ResourceTypes@@IPAW41@@Z ; std::_Allocate<enum ResourceTypes>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T240581 = -32						; size = 4
$T240580 = -28						; size = 4
$T240576 = -24						; size = 4
$T240575 = -20						; size = 4
$T240557 = -16						; size = 4
$T240556 = -12						; size = 4
$T240540 = -8						; size = 4
__Cat$240564 = -2					; size = 1
$T240562 = -1						; size = 1
?_Tidy@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXXZ PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T240576[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T240575[ebp], ecx
	mov	edx, DWORD PTR $T240576[ebp]
	mov	DWORD PTR $T240557[ebp], edx
	mov	eax, DWORD PTR $T240575[ebp]
	mov	DWORD PTR $T240556[ebp], eax
	mov	cl, BYTE PTR __Cat$240564[ebp]
	mov	BYTE PTR $T240562[ebp], cl
	mov	edx, DWORD PTR $T240556[ebp]
	mov	DWORD PTR $T240540[ebp], edx
	jmp	SHORT $LN12@Tidy
$LN11@Tidy:
	mov	eax, DWORD PTR $T240540[ebp]
	add	eax, 4
	mov	DWORD PTR $T240540[ebp], eax
$LN12@Tidy:
	mov	ecx, DWORD PTR $T240540[ebp]
	cmp	ecx, DWORD PTR $T240557[ebp]
	je	SHORT $LN4@Tidy
	jmp	SHORT $LN11@Tidy
$LN4@Tidy:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR $T240581[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T240580[ebp], eax
	mov	ecx, DWORD PTR $T240580[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXXZ ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Tidy
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
_TEXT	ENDS
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?GrowSize@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv178 = -44						; size = 4
_this$ = -40						; size = 4
$T240621 = -36						; size = 4
$T240620 = -32						; size = 4
_i$240615 = -28						; size = 4
$T240596 = -24						; size = 4
_pRet$240592 = -20					; size = 4
$T240587 = -16						; size = 4
_i$227420 = -12						; size = 4
_uiNewSize$227412 = -8					; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<enum PlayerTypes,63,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@GrowSize
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jb	SHORT $LN7@GrowSize

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	DWORD PTR _uiNewSize$227412[ebp], edx

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$227412[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN6@GrowSize

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 754  : 				break;

	jmp	SHORT $LN7@GrowSize
$LN6@GrowSize:

; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$227412[ebp]
	mov	DWORD PTR [ecx+8], edx

; 759  : 		}

	jmp	SHORT $LN8@GrowSize
$LN7@GrowSize:

; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T240596[ebp], ecx
	cmp	DWORD PTR $T240596[ebp], 63		; 0000003fH
	jbe	SHORT $LN15@GrowSize
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T240596[ebp]
	shl	edx, 2
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$240592[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T240596[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN16@GrowSize
$LN15@GrowSize:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$240592[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 63			; 0000003fH
$LN16@GrowSize:
	mov	ecx, DWORD PTR _pRet$240592[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 762  : 		if( bPODType ){

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@GrowSize

; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 764  : 		}else{

	jmp	SHORT $LN4@GrowSize
$LN5@GrowSize:

; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$227420[ebp], 0
	jmp	SHORT $LN3@GrowSize
$LN2@GrowSize:
	mov	edx, DWORD PTR _i$227420[ebp]
	add	edx, 1
	mov	DWORD PTR _i$227420[ebp], edx
$LN3@GrowSize:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$227420[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN4@GrowSize

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$227420[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T240587[ebp], ecx
	cmp	DWORD PTR $T240587[ebp], 0
	je	SHORT $LN12@GrowSize
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T240587[ebp]
	mov	edx, DWORD PTR _i$227420[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T240587[ebp]
	mov	DWORD PTR tv178[ebp], ecx
	jmp	SHORT $LN13@GrowSize
$LN12@GrowSize:
	mov	DWORD PTR tv178[ebp], 0
$LN13@GrowSize:
	jmp	SHORT $LN2@GrowSize
$LN4@GrowSize:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T240621[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T240620[ebp], edx
	xor	eax, eax
	je	SHORT $LN21@GrowSize
	xor	ecx, ecx
	je	SHORT $LN21@GrowSize
	mov	DWORD PTR _i$240615[ebp], 0
	jmp	SHORT $LN26@GrowSize
$LN25@GrowSize:
	mov	edx, DWORD PTR _i$240615[ebp]
	add	edx, 1
	mov	DWORD PTR _i$240615[ebp], edx
$LN26@GrowSize:
	mov	eax, DWORD PTR _i$240615[ebp]
	cmp	eax, DWORD PTR $T240621[ebp]
	jae	SHORT $LN21@GrowSize
	jmp	SHORT $LN25@GrowSize
$LN21@GrowSize:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	cmp	DWORD PTR $T240620[ebp], ecx
	je	SHORT $LN22@GrowSize
	mov	edx, DWORD PTR $T240620[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN22@GrowSize:

; 769  : 		m_pData = pTemp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], ecx

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+264], 1

; 772  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<enum PlayerTypes,63,1,297,0>::GrowSize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@W4PlayerTypes@@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@W4PlayerTypes@@$00@@QAE@XZ PROC		; BaseVector<enum PlayerTypes,1>::~BaseVector<enum PlayerTypes,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@W4PlayerTypes@@$00@@QAE@XZ ENDP		; BaseVector<enum PlayerTypes,1>::~BaseVector<enum PlayerTypes,1>
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T240637 = -20						; size = 4
_pRet$240633 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 63			; 0000003fH

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T240637[ebp], edx
	cmp	DWORD PTR $T240637[ebp], 63		; 0000003fH
	jbe	SHORT $LN7@FStaticVec@3
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T240637[ebp]
	shl	eax, 3
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$240633[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T240637[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec@3
$LN7@FStaticVec@3:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$240633[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 63			; 0000003fH
$LN8@FStaticVec@3:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$240633[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>
__ehhandler$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T240668 = -24						; size = 4
$T240667 = -20						; size = 4
_i$240660 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::~FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T240668[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T240667[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN5@FStaticVec@4
	xor	edx, edx
	je	SHORT $LN5@FStaticVec@4
	mov	DWORD PTR _i$240660[ebp], 0
	jmp	SHORT $LN10@FStaticVec@4
$LN9@FStaticVec@4:
	mov	eax, DWORD PTR _i$240660[ebp]
	add	eax, 1
	mov	DWORD PTR _i$240660[ebp], eax
$LN10@FStaticVec@4:
	mov	ecx, DWORD PTR _i$240660[ebp]
	cmp	ecx, DWORD PTR $T240668[ebp]
	jae	SHORT $LN5@FStaticVec@4
	jmp	SHORT $LN9@FStaticVec@4
$LN5@FStaticVec@4:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T240667[ebp], edx
	je	SHORT $LN1@FStaticVec@4
	mov	eax, DWORD PTR $T240667[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@FStaticVec@4:

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>
__ehhandler$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::~FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>
PUBLIC	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::GrowSize
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@Z
_TEXT	SEGMENT
tv157 = -64						; size = 4
tv149 = -60						; size = 4
_this$ = -56						; size = 4
$T240681 = -8						; size = 4
$T240680 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@Z PROC ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+516], 0

; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN39@push_back@3

; 679  : 			GrowSize(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::GrowSize

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN39@push_back@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T240681[ebp], ecx
	cmp	DWORD PTR $T240681[ebp], 0
	je	SHORT $LN4@push_back@3
	mov	edx, DWORD PTR $T240681[ebp]
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T240681[ebp]
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR $T240681[ebp]
	mov	DWORD PTR tv149[ebp], edx
	jmp	SHORT $LN5@push_back@3
$LN4@push_back@3:
	mov	DWORD PTR tv149[ebp], 0
$LN5@push_back@3:
	mov	eax, DWORD PTR tv149[ebp]
	mov	DWORD PTR $T240680[ebp], eax

; 681  : 		return m_uiCurrSize++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv157[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR tv157[ebp]

; 682  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@Z ENDP ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::push_back
_TEXT	ENDS
PUBLIC	?Alloc@?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > >::Alloc
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fbatchallocate.h
;	COMDAT ?Alloc@?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z
_TEXT	SEGMENT
_this$ = -196						; size = 4
_nLocalBytes$ = -16					; size = 4
_pLocMemStart$ = -12					; size = 4
_iAlignmentFix$ = -8					; size = 4
_pRet$ = -4						; size = 4
_nBytes$ = 8						; size = 4
_pData$ = 12						; size = 4
?Alloc@?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z PROC ; FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > >::Alloc, COMDAT
; _this$ = ecx

; 69   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	mov	DWORD PTR _this$[ebp], ecx

; 70   : 		unsigned int nLocalBytes = sizeof(TYPE) * (pData->nX + 1);

	mov	eax, DWORD PTR _pData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	DWORD PTR _nLocalBytes$[ebp], ecx

; 71   : 		void* pRet = BASE::Alloc( nBytes + nLocalBytes, pData+1 );

	mov	edx, DWORD PTR _pData$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	eax, DWORD PTR _nBytes$[ebp]
	add	eax, DWORD PTR _nLocalBytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Alloc@?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > >::Alloc
	mov	DWORD PTR _pRet$[ebp], eax

; 72   : 		unsigned char* pLocMemStart = static_cast< unsigned char* > ( pRet ) - nLocalBytes;

	mov	ecx, DWORD PTR _pRet$[ebp]
	sub	ecx, DWORD PTR _nLocalBytes$[ebp]
	mov	DWORD PTR _pLocMemStart$[ebp], ecx

; 73   : 
; 74   : 		unsigned int iAlignmentFix = sizeof(TYPE) - reinterpret_cast< unsigned int >(pLocMemStart) % sizeof(TYPE);

	mov	eax, DWORD PTR _pLocMemStart$[ebp]
	xor	edx, edx
	mov	ecx, 1
	div	ecx
	mov	eax, 1
	sub	eax, edx
	mov	DWORD PTR _iAlignmentFix$[ebp], eax

; 75   : 		(*static_cast< TYPE** >(pData->pOut)) = (TYPE*)( pLocMemStart + iAlignmentFix );

	mov	ecx, DWORD PTR _pLocMemStart$[ebp]
	add	ecx, DWORD PTR _iAlignmentFix$[ebp]
	mov	edx, DWORD PTR _pData$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 76   : 
; 77   : 		return static_cast< void* >( pLocMemStart );

	mov	eax, DWORD PTR _pLocMemStart$[ebp]

; 78   : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?Alloc@?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ENDP ; FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > >::Alloc
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum ResourceTypes *,enum ResourceTypes *,std::allocator<enum ResourceTypes> >
PUBLIC	??$unchecked_uninitialized_copy@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@stdext@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@std@@@Z ; stdext::unchecked_uninitialized_copy<enum ResourceTypes *,enum ResourceTypes *,std::allocator<enum ResourceTypes> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z$2
__catchsym$?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z$0
__unwindtable$?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z$5
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z$6
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z
_TEXT	SEGMENT
tv84 = -424						; size = 4
tv302 = -420						; size = 4
tv288 = -416						; size = 4
tv280 = -412						; size = 4
_this$ = -408						; size = 4
$T241429 = -404						; size = 4
$T241421 = -400						; size = 4
$T241420 = -396						; size = 4
$T241397 = -390						; size = 1
$T241396 = -389						; size = 1
$T241395 = -388						; size = 4
$T241394 = -384						; size = 4
$T241382 = -377						; size = 1
$T241381 = -376						; size = 4
$T241380 = -372						; size = 4
$T241379 = -368						; size = 4
__Cat$241413 = -364					; size = 1
$T241411 = -363						; size = 1
$T241410 = -362						; size = 1
__Cat$241403 = -360					; size = 1
$T241401 = -359						; size = 1
$T241400 = -358						; size = 1
$T241399 = -357						; size = 1
$T241354 = -356						; size = 4
$T241335 = -352						; size = 4
$T241318 = -345						; size = 1
$T241317 = -344						; size = 4
$T241307 = -340						; size = 4
$T241306 = -336						; size = 4
__Cat$241351 = -330					; size = 1
$T241349 = -329						; size = 1
$T241348 = -328						; size = 1
__Cat$241342 = -327					; size = 1
$T241340 = -326						; size = 1
$T241339 = -325						; size = 1
$T241282 = -324						; size = 4
$T241274 = -320						; size = 4
$T241266 = -316						; size = 4
$T241248 = -312						; size = 4
$T241247 = -308						; size = 4
$T241231 = -304						; size = 4
__Cat$241254 = -298					; size = 1
$T241252 = -297						; size = 1
$T241205 = -296						; size = 4
$T241204 = -292						; size = 4
$T241194 = -288						; size = 4
__Cat$241201 = -283					; size = 1
$T241199 = -282						; size = 1
$T241198 = -281						; size = 1
$T241178 = -280						; size = 4
$T241159 = -276						; size = 4
$T241142 = -269						; size = 1
$T241141 = -268						; size = 4
$T241131 = -264						; size = 4
$T241130 = -260						; size = 4
__Cat$241175 = -254					; size = 1
$T241173 = -253						; size = 1
$T241172 = -252						; size = 1
__Cat$241166 = -251					; size = 1
$T241164 = -250						; size = 1
$T241163 = -249						; size = 1
$T241106 = -248						; size = 4
$T241105 = -244						; size = 4
$T241101 = -240						; size = 4
$T241100 = -236						; size = 4
$T241082 = -232						; size = 4
$T241081 = -228						; size = 4
$T241065 = -224						; size = 4
__Cat$241088 = -218					; size = 1
$T241086 = -217						; size = 1
$T241016 = -216						; size = 4
$T241015 = -212						; size = 4
$T240999 = -208						; size = 4
__Cat$241022 = -202					; size = 1
$T241020 = -201						; size = 1
$T240956 = -200						; size = 4
$T240955 = -196						; size = 4
$T240939 = -192						; size = 4
__Cat$240962 = -186					; size = 1
$T240960 = -185						; size = 1
$T240913 = -184						; size = 4
$T240901 = -180						; size = 4
$T240891 = -173						; size = 1
$T240890 = -172						; size = 4
__Cat$240908 = -167					; size = 1
$T240906 = -166						; size = 1
$T240905 = -165						; size = 1
$T240878 = -164						; size = 4
$T240866 = -160						; size = 4
$T240856 = -153						; size = 1
$T240855 = -152						; size = 4
__Cat$240873 = -147					; size = 1
$T240871 = -146						; size = 1
$T240870 = -145						; size = 1
$T240843 = -144						; size = 4
$T240833 = -140						; size = 4
__Cat$240840 = -135					; size = 1
$T240838 = -134						; size = 1
$T240837 = -133						; size = 1
__Count$240805 = -120					; size = 4
__Count$240779 = -48					; size = 4
__Tmp$227531 = -44					; size = 4
__Oldend$227532 = -40					; size = 4
__Tmp$227521 = -36					; size = 4
__Ncopied$227508 = -32					; size = 4
__Newvec$227506 = -28					; size = 4
__Whereoff$227507 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 408				; 00000198H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN29@Insert_n
	mov	DWORD PTR tv280[ebp], 0
	jmp	SHORT $LN27@Insert_n
$LN29@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv280[ebp], eax
$LN27@Insert_n:
	mov	ecx, DWORD PTR tv280[ebp]
	mov	DWORD PTR __Capacity$[ebp], ecx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n
	jmp	$LN16@Insert_n
$LN14@Insert_n:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$240779[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$240779[ebp], 0
	jbe	SHORT $LN35@Insert_n
	mov	edx, DWORD PTR __Count$240779[ebp]
	mov	DWORD PTR tv288[ebp], edx
	jmp	SHORT $LN37@Insert_n
$LN35@Insert_n:
	mov	DWORD PTR tv288[ebp], 1
$LN37@Insert_n:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	eax, DWORD PTR tv288[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN42@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Xlen
	jmp	$LN16@Insert_n

; 1167 : 		else if (_Capacity < size() + _Count)

$LN42@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$240805[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$240805[ebp], 0
	jbe	SHORT $LN48@Insert_n
	mov	ecx, DWORD PTR __Count$240805[ebp]
	mov	DWORD PTR tv302[ebp], ecx
	jmp	SHORT $LN44@Insert_n
$LN48@Insert_n:
	mov	DWORD PTR tv302[ebp], 1
$LN44@Insert_n:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	mov	eax, DWORD PTR tv302[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	add	ecx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], ecx
$LN18@Insert_n:
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1171 : 			if (_Capacity < size() + _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], edx
	jae	SHORT $LN54@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN54@Insert_n:
	push	0
	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	call	??$_Allocate@W4ResourceTypes@@@std@@YAPAW4ResourceTypes@@IPAW41@@Z ; std::_Allocate<enum ResourceTypes>
	add	esp, 8
	mov	DWORD PTR __Newvec$227506[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR __Whereoff$227507[ebp], edx

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$227508[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Whereoff$227507[ebp]
	mov	ecx, DWORD PTR __Newvec$227506[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T240843[ebp], edx
	mov	eax, DWORD PTR $T240843[ebp]
	mov	DWORD PTR $T240833[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T240837[ebp], cl
	mov	dl, BYTE PTR __Cat$240840[ebp]
	mov	BYTE PTR $T240838[ebp], dl
	movzx	eax, BYTE PTR $T240837[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T240838[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T240833[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAW4ResourceTypes@@IW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAXPAW4ResourceTypes@@IABW41@AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum ResourceTypes *,unsigned int,enum ResourceTypes,std::allocator<enum ResourceTypes> >
	add	esp, 24					; 00000018H

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$227508[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$227508[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T240878[ebp], edx
	mov	eax, DWORD PTR __Newvec$227506[ebp]
	mov	DWORD PTR $T240866[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T240870[ebp], cl
	mov	dl, BYTE PTR __Cat$240873[ebp]
	mov	BYTE PTR $T240871[ebp], dl
	mov	al, BYTE PTR $T240870[ebp]
	mov	BYTE PTR $T240856[ebp], al
	mov	ecx, DWORD PTR $T240866[ebp]
	mov	DWORD PTR $T240855[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T240855[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T240878[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@stdext@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@std@@@Z ; stdext::unchecked_uninitialized_copy<enum ResourceTypes *,enum ResourceTypes *,std::allocator<enum ResourceTypes> >
	add	esp, 16					; 00000010H

; 1182 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$227508[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$227508[ebp], eax

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T240913[ebp], edx
	mov	eax, DWORD PTR __Whereoff$227507[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Newvec$227506[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T240901[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T240905[ebp], al
	mov	cl, BYTE PTR __Cat$240908[ebp]
	mov	BYTE PTR $T240906[ebp], cl
	mov	dl, BYTE PTR $T240905[ebp]
	mov	BYTE PTR $T240891[ebp], dl
	mov	eax, DWORD PTR $T240901[ebp]
	mov	DWORD PTR $T240890[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T240890[ebp]
	push	edx
	mov	eax, DWORD PTR $T240913[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	call	??$unchecked_uninitialized_copy@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@stdext@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@std@@@Z ; stdext::unchecked_uninitialized_copy<enum ResourceTypes *,enum ResourceTypes *,std::allocator<enum ResourceTypes> >
	add	esp, 16					; 00000010H
	jmp	$LN19@Insert_n
__catch$?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$227508[ebp], 1
	jle	SHORT $LN7@Insert_n

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	edx, DWORD PTR __Whereoff$227507[ebp]
	mov	eax, DWORD PTR __Newvec$227506[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T240956[ebp], ecx
	mov	edx, DWORD PTR __Newvec$227506[ebp]
	mov	DWORD PTR $T240955[ebp], edx
	mov	al, BYTE PTR __Cat$240962[ebp]
	mov	BYTE PTR $T240960[ebp], al
	mov	ecx, DWORD PTR $T240955[ebp]
	mov	DWORD PTR $T240939[ebp], ecx
	jmp	SHORT $LN91@Insert_n
$LN90@Insert_n:
	mov	edx, DWORD PTR $T240939[ebp]
	add	edx, 4
	mov	DWORD PTR $T240939[ebp], edx
$LN91@Insert_n:
	mov	eax, DWORD PTR $T240939[ebp]
	cmp	eax, DWORD PTR $T240956[ebp]
	je	SHORT $LN7@Insert_n
	jmp	SHORT $LN90@Insert_n
$LN7@Insert_n:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$227508[ebp], 0
	jle	SHORT $LN6@Insert_n

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Whereoff$227507[ebp]
	mov	edx, DWORD PTR __Newvec$227506[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T241016[ebp], edx
	mov	eax, DWORD PTR __Whereoff$227507[ebp]
	mov	ecx, DWORD PTR __Newvec$227506[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T241015[ebp], edx
	mov	al, BYTE PTR __Cat$241022[ebp]
	mov	BYTE PTR $T241020[ebp], al
	mov	ecx, DWORD PTR $T241015[ebp]
	mov	DWORD PTR $T240999[ebp], ecx
	jmp	SHORT $LN106@Insert_n
$LN105@Insert_n:
	mov	edx, DWORD PTR $T240999[ebp]
	add	edx, 4
	mov	DWORD PTR $T240999[ebp], edx
$LN106@Insert_n:
	mov	eax, DWORD PTR $T240999[ebp]
	cmp	eax, DWORD PTR $T241016[ebp]
	je	SHORT $LN6@Insert_n
	jmp	SHORT $LN105@Insert_n
$LN6@Insert_n:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	ecx, DWORD PTR __Newvec$227506[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN115@Insert_n
	ret	0
$LN19@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN115@Insert_n:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], ecx

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN5@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T241101[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T241100[ebp], eax
	mov	ecx, DWORD PTR $T241101[ebp]
	mov	DWORD PTR $T241082[ebp], ecx
	mov	edx, DWORD PTR $T241100[ebp]
	mov	DWORD PTR $T241081[ebp], edx
	mov	al, BYTE PTR __Cat$241088[ebp]
	mov	BYTE PTR $T241086[ebp], al
	mov	ecx, DWORD PTR $T241081[ebp]
	mov	DWORD PTR $T241065[ebp], ecx
	jmp	SHORT $LN125@Insert_n
$LN124@Insert_n:
	mov	edx, DWORD PTR $T241065[ebp]
	add	edx, 4
	mov	DWORD PTR $T241065[ebp], edx
$LN125@Insert_n:
	mov	eax, DWORD PTR $T241065[ebp]
	cmp	eax, DWORD PTR $T241082[ebp]
	je	SHORT $LN117@Insert_n
	jmp	SHORT $LN124@Insert_n
$LN117@Insert_n:

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR $T241106[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T241105[ebp], edx
	mov	eax, DWORD PTR $T241105[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	ecx, DWORD PTR __Capacity$[ebp]
	mov	edx, DWORD PTR __Newvec$227506[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Newvec$227506[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newvec$227506[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	$LN16@Insert_n
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	sar	eax, 2
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$227521[ebp], edx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T241178[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T241159[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T241163[ebp], dl
	mov	al, BYTE PTR __Cat$241166[ebp]
	mov	BYTE PTR $T241164[ebp], al
	mov	cl, BYTE PTR $T241163[ebp]
	mov	BYTE PTR $T241142[ebp], cl
	mov	edx, DWORD PTR $T241159[ebp]
	mov	DWORD PTR $T241141[ebp], edx
	mov	eax, DWORD PTR $T241141[ebp]
	mov	DWORD PTR $T241131[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T241130[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T241172[ebp], dl
	mov	al, BYTE PTR __Cat$241175[ebp]
	mov	BYTE PTR $T241173[ebp], al
	movzx	ecx, BYTE PTR $T241172[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T241173[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T241131[ebp]
	push	ecx
	mov	edx, DWORD PTR $T241178[ebp]
	push	edx
	mov	eax, DWORD PTR $T241130[ebp]
	push	eax
	call	??$_Uninit_copy@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum ResourceTypes *,enum ResourceTypes *,std::allocator<enum ResourceTypes> >
	add	esp, 24					; 00000018H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 2
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	mov	DWORD PTR $T241205[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T241204[ebp], edx
	mov	eax, DWORD PTR $T241204[ebp]
	mov	DWORD PTR $T241194[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T241198[ebp], cl
	mov	dl, BYTE PTR __Cat$241201[ebp]
	mov	BYTE PTR $T241199[ebp], dl
	movzx	eax, BYTE PTR $T241198[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T241199[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	lea	eax, DWORD PTR __Tmp$227521[ebp]
	push	eax
	mov	ecx, DWORD PTR $T241205[ebp]
	push	ecx
	mov	edx, DWORD PTR $T241194[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAW4ResourceTypes@@IW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAXPAW4ResourceTypes@@IABW41@AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum ResourceTypes *,unsigned int,enum ResourceTypes,std::allocator<enum ResourceTypes> >
	add	esp, 24					; 00000018H
	jmp	SHORT $LN21@Insert_n
__catch$?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T241266[ebp], eax
	mov	ecx, DWORD PTR $T241266[ebp]
	mov	DWORD PTR $T241248[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T241247[ebp], ecx
	mov	dl, BYTE PTR __Cat$241254[ebp]
	mov	BYTE PTR $T241252[ebp], dl
	mov	eax, DWORD PTR $T241247[ebp]
	mov	DWORD PTR $T241231[ebp], eax
	jmp	SHORT $LN160@Insert_n
$LN159@Insert_n:
	mov	ecx, DWORD PTR $T241231[ebp]
	add	ecx, 4
	mov	DWORD PTR $T241231[ebp], ecx
$LN160@Insert_n:
	mov	edx, DWORD PTR $T241231[ebp]
	cmp	edx, DWORD PTR $T241248[ebp]
	je	SHORT $LN152@Insert_n
	jmp	SHORT $LN159@Insert_n
$LN152@Insert_n:

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z$3
	ret	0
$LN21@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, edx
	mov	DWORD PTR $T241282[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T241274[ebp], edx
	jmp	SHORT $LN171@Insert_n
$LN170@Insert_n:
	mov	eax, DWORD PTR $T241274[ebp]
	add	eax, 4
	mov	DWORD PTR $T241274[ebp], eax
$LN171@Insert_n:
	mov	ecx, DWORD PTR $T241274[ebp]
	cmp	ecx, DWORD PTR $T241282[ebp]
	je	SHORT $LN167@Insert_n
	mov	edx, DWORD PTR $T241274[ebp]
	mov	eax, DWORD PTR __Tmp$227521[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN170@Insert_n
$LN167@Insert_n:

; 1232 : 			}
; 1233 : 		else

	jmp	$LN16@Insert_n
$LN3@Insert_n:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$227531[ebp], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Oldend$227532[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T241354[ebp], eax
	mov	ecx, DWORD PTR $T241354[ebp]
	mov	DWORD PTR $T241335[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T241339[ebp], dl
	mov	al, BYTE PTR __Cat$241342[ebp]
	mov	BYTE PTR $T241340[ebp], al
	mov	cl, BYTE PTR $T241339[ebp]
	mov	BYTE PTR $T241318[ebp], cl
	mov	edx, DWORD PTR $T241335[ebp]
	mov	DWORD PTR $T241317[ebp], edx
	mov	eax, DWORD PTR $T241317[ebp]
	mov	DWORD PTR $T241307[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR __Oldend$227532[ebp]
	sub	edx, ecx
	mov	DWORD PTR $T241306[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T241348[ebp], al
	mov	cl, BYTE PTR __Cat$241351[ebp]
	mov	BYTE PTR $T241349[ebp], cl
	movzx	edx, BYTE PTR $T241348[ebp]
	push	edx
	movzx	eax, BYTE PTR $T241349[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T241307[ebp]
	push	edx
	mov	eax, DWORD PTR __Oldend$227532[ebp]
	push	eax
	mov	ecx, DWORD PTR $T241306[ebp]
	push	ecx
	call	??$_Uninit_copy@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum ResourceTypes *,enum ResourceTypes *,std::allocator<enum ResourceTypes> >
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, DWORD PTR __Oldend$227532[ebp]
	mov	DWORD PTR $T241421[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T241420[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T241399[ebp], dl
	mov	al, BYTE PTR __Cat$241403[ebp]
	mov	BYTE PTR $T241400[ebp], al
	mov	cl, BYTE PTR $T241399[ebp]
	mov	BYTE PTR $T241397[ebp], cl
	mov	dl, BYTE PTR $T241401[ebp]
	mov	BYTE PTR $T241396[ebp], dl
	mov	eax, DWORD PTR $T241421[ebp]
	mov	DWORD PTR $T241395[ebp], eax
	mov	ecx, DWORD PTR $T241420[ebp]
	mov	DWORD PTR $T241394[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T241410[ebp], dl
	mov	al, BYTE PTR __Cat$241413[ebp]
	mov	BYTE PTR $T241411[ebp], al
	mov	cl, BYTE PTR $T241410[ebp]
	mov	BYTE PTR $T241382[ebp], cl
	mov	edx, DWORD PTR $T241395[ebp]
	mov	DWORD PTR $T241381[ebp], edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Oldend$227532[ebp]
	sub	ecx, eax
	mov	DWORD PTR $T241380[ebp], ecx
	mov	edx, DWORD PTR $T241394[ebp]
	mov	DWORD PTR $T241379[ebp], edx
$LN197@Insert_n:
	mov	eax, DWORD PTR $T241379[ebp]
	cmp	eax, DWORD PTR $T241380[ebp]
	je	SHORT $LN186@Insert_n
	mov	ecx, DWORD PTR $T241380[ebp]
	sub	ecx, 4
	mov	DWORD PTR $T241380[ebp], ecx
	mov	edx, DWORD PTR $T241381[ebp]
	sub	edx, 4
	mov	DWORD PTR $T241381[ebp], edx
	mov	eax, DWORD PTR $T241381[ebp]
	mov	ecx, DWORD PTR $T241380[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN197@Insert_n
$LN186@Insert_n:

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T241429[ebp], eax
	jmp	SHORT $LN204@Insert_n
$LN203@Insert_n:
	mov	ecx, DWORD PTR $T241429[ebp]
	add	ecx, 4
	mov	DWORD PTR $T241429[ebp], ecx
$LN204@Insert_n:
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	cmp	DWORD PTR $T241429[ebp], ecx
	je	SHORT $LN16@Insert_n
	mov	edx, DWORD PTR $T241429[ebp]
	mov	eax, DWORD PTR __Tmp$227531[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN203@Insert_n
$LN16@Insert_n:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-428]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Insert_n
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_Elength_error@std@@UAEPAXI@Z ; std::length_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_Elogic_error@std@@UAEPAXI@Z ; std::logic_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T241451 = -80						; size = 28
$T241450 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T241451[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T241450[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T241450[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T241451[ebp]
	push	eax
	lea	ecx, DWORD PTR $T241450[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T241450[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T241450[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T241451[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T241451[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T241450[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Xlen
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 34   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 36   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@

; 110  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	edx, DWORD PTR ___flags$[ebp]
	and	edx, 1
	je	SHORT $LN1@scalar@2
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv186 = -52						; size = 4
_this$ = -48						; size = 4
$T241544 = -44						; size = 4
$T241543 = -40						; size = 4
_i$241538 = -36						; size = 4
$T241522 = -32						; size = 4
$T241515 = -28						; size = 4
_pRet$241511 = -24					; size = 4
$T241505 = -20						; size = 4
$T241504 = -16						; size = 4
_i$227579 = -12						; size = 4
_uiNewSize$227571 = -8					; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@IAEXI@Z PROC ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@GrowSize@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@GrowSize@2:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jb	SHORT $LN7@GrowSize@2

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	DWORD PTR _uiNewSize$227571[ebp], edx

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$227571[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN6@GrowSize@2

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 754  : 				break;

	jmp	SHORT $LN7@GrowSize@2
$LN6@GrowSize@2:

; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$227571[ebp]
	mov	DWORD PTR [ecx+8], edx

; 759  : 		}

	jmp	SHORT $LN8@GrowSize@2
$LN7@GrowSize@2:

; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T241515[ebp], ecx
	cmp	DWORD PTR $T241515[ebp], 63		; 0000003fH
	jbe	SHORT $LN16@GrowSize@2
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T241515[ebp]
	shl	edx, 3
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$241511[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T241515[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN17@GrowSize@2
$LN16@GrowSize@2:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$241511[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 63			; 0000003fH
$LN17@GrowSize@2:
	mov	ecx, DWORD PTR _pRet$241511[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 762  : 		if( bPODType ){

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@GrowSize@2

; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 764  : 		}else{

	jmp	SHORT $LN4@GrowSize@2
$LN5@GrowSize@2:

; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$227579[ebp], 0
	jmp	SHORT $LN3@GrowSize@2
$LN2@GrowSize@2:
	mov	edx, DWORD PTR _i$227579[ebp]
	add	edx, 1
	mov	DWORD PTR _i$227579[ebp], edx
$LN3@GrowSize@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$227579[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN4@GrowSize@2

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$227579[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T241505[ebp], ecx
	cmp	DWORD PTR $T241505[ebp], 0
	je	SHORT $LN12@GrowSize@2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _i$227579[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T241522[ebp], edx
	mov	eax, DWORD PTR $T241505[ebp]
	mov	ecx, DWORD PTR $T241522[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR $T241505[ebp]
	mov	ecx, DWORD PTR $T241522[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR $T241505[ebp]
	mov	DWORD PTR tv186[ebp], eax
	jmp	SHORT $LN13@GrowSize@2
$LN12@GrowSize@2:
	mov	DWORD PTR tv186[ebp], 0
$LN13@GrowSize@2:
	mov	ecx, DWORD PTR tv186[ebp]
	mov	DWORD PTR $T241504[ebp], ecx
	jmp	SHORT $LN2@GrowSize@2
$LN4@GrowSize@2:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T241544[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T241543[ebp], edx
	xor	eax, eax
	je	SHORT $LN24@GrowSize@2
	xor	ecx, ecx
	je	SHORT $LN24@GrowSize@2
	mov	DWORD PTR _i$241538[ebp], 0
	jmp	SHORT $LN29@GrowSize@2
$LN28@GrowSize@2:
	mov	edx, DWORD PTR _i$241538[ebp]
	add	edx, 1
	mov	DWORD PTR _i$241538[ebp], edx
$LN29@GrowSize@2:
	mov	eax, DWORD PTR _i$241538[ebp]
	cmp	eax, DWORD PTR $T241544[ebp]
	jae	SHORT $LN24@GrowSize@2
	jmp	SHORT $LN28@GrowSize@2
$LN24@GrowSize@2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	cmp	DWORD PTR $T241543[ebp], ecx
	je	SHORT $LN25@GrowSize@2
	mov	edx, DWORD PTR $T241543[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN25@GrowSize@2:

; 769  : 		m_pData = pTemp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], ecx

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+516], 1

; 772  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::GrowSize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QAE@XZ PROC ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QAE@XZ ENDP ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>
_TEXT	ENDS
PUBLIC	?Alloc@?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > >::Alloc
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fbatchallocate.h
;	COMDAT ?Alloc@?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z
_TEXT	SEGMENT
_this$ = -196						; size = 4
_nLocalBytes$ = -16					; size = 4
_pLocMemStart$ = -12					; size = 4
_iAlignmentFix$ = -8					; size = 4
_pRet$ = -4						; size = 4
_nBytes$ = 8						; size = 4
_pData$ = 12						; size = 4
?Alloc@?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z PROC ; FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > >::Alloc, COMDAT
; _this$ = ecx

; 69   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	mov	DWORD PTR _this$[ebp], ecx

; 70   : 		unsigned int nLocalBytes = sizeof(TYPE) * (pData->nX + 1);

	mov	eax, DWORD PTR _pData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	DWORD PTR _nLocalBytes$[ebp], ecx

; 71   : 		void* pRet = BASE::Alloc( nBytes + nLocalBytes, pData+1 );

	mov	edx, DWORD PTR _pData$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	eax, DWORD PTR _nBytes$[ebp]
	add	eax, DWORD PTR _nLocalBytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Alloc@?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > >::Alloc
	mov	DWORD PTR _pRet$[ebp], eax

; 72   : 		unsigned char* pLocMemStart = static_cast< unsigned char* > ( pRet ) - nLocalBytes;

	mov	ecx, DWORD PTR _pRet$[ebp]
	sub	ecx, DWORD PTR _nLocalBytes$[ebp]
	mov	DWORD PTR _pLocMemStart$[ebp], ecx

; 73   : 
; 74   : 		unsigned int iAlignmentFix = sizeof(TYPE) - reinterpret_cast< unsigned int >(pLocMemStart) % sizeof(TYPE);

	mov	eax, DWORD PTR _pLocMemStart$[ebp]
	xor	edx, edx
	mov	ecx, 1
	div	ecx
	mov	eax, 1
	sub	eax, edx
	mov	DWORD PTR _iAlignmentFix$[ebp], eax

; 75   : 		(*static_cast< TYPE** >(pData->pOut)) = (TYPE*)( pLocMemStart + iAlignmentFix );

	mov	ecx, DWORD PTR _pLocMemStart$[ebp]
	add	ecx, DWORD PTR _iAlignmentFix$[ebp]
	mov	edx, DWORD PTR _pData$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 76   : 
; 77   : 		return static_cast< void* >( pLocMemStart );

	mov	eax, DWORD PTR _pLocMemStart$[ebp]

; 78   : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?Alloc@?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ENDP ; FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > >::Alloc
_TEXT	ENDS
PUBLIC	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > >::Alloc
; Function compile flags: /Odtp
;	COMDAT ?Alloc@?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z
_TEXT	SEGMENT
_this$ = -180						; size = 4
_nLocalBytes$ = -16					; size = 4
_pLocMemStart$ = -12					; size = 4
_iAlignmentFix$ = -8					; size = 4
_pRet$ = -4						; size = 4
_nBytes$ = 8						; size = 4
_pData$ = 12						; size = 4
?Alloc@?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z PROC ; FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > >::Alloc, COMDAT
; _this$ = ecx

; 69   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	mov	DWORD PTR _this$[ebp], ecx

; 70   : 		unsigned int nLocalBytes = sizeof(TYPE) * (pData->nX + 1);

	mov	eax, DWORD PTR _pData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	DWORD PTR _nLocalBytes$[ebp], ecx

; 71   : 		void* pRet = BASE::Alloc( nBytes + nLocalBytes, pData+1 );

	mov	edx, DWORD PTR _pData$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	eax, DWORD PTR _nBytes$[ebp]
	add	eax, DWORD PTR _nLocalBytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > >::Alloc
	mov	DWORD PTR _pRet$[ebp], eax

; 72   : 		unsigned char* pLocMemStart = static_cast< unsigned char* > ( pRet ) - nLocalBytes;

	mov	ecx, DWORD PTR _pRet$[ebp]
	sub	ecx, DWORD PTR _nLocalBytes$[ebp]
	mov	DWORD PTR _pLocMemStart$[ebp], ecx

; 73   : 
; 74   : 		unsigned int iAlignmentFix = sizeof(TYPE) - reinterpret_cast< unsigned int >(pLocMemStart) % sizeof(TYPE);

	mov	eax, DWORD PTR _pLocMemStart$[ebp]
	xor	edx, edx
	mov	ecx, 1
	div	ecx
	mov	eax, 1
	sub	eax, edx
	mov	DWORD PTR _iAlignmentFix$[ebp], eax

; 75   : 		(*static_cast< TYPE** >(pData->pOut)) = (TYPE*)( pLocMemStart + iAlignmentFix );

	mov	ecx, DWORD PTR _pLocMemStart$[ebp]
	add	ecx, DWORD PTR _iAlignmentFix$[ebp]
	mov	edx, DWORD PTR _pData$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 76   : 
; 77   : 		return static_cast< void* >( pLocMemStart );

	mov	eax, DWORD PTR _pLocMemStart$[ebp]

; 78   : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?Alloc@?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ENDP ; FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > >::Alloc
_TEXT	ENDS
PUBLIC	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > >::Alloc
; Function compile flags: /Odtp
;	COMDAT ?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z
_TEXT	SEGMENT
_this$ = -200						; size = 4
_nLocalBytes$ = -16					; size = 4
_pLocMemStart$ = -12					; size = 4
_iAlignmentFix$ = -8					; size = 4
_pRet$ = -4						; size = 4
_nBytes$ = 8						; size = 4
_pData$ = 12						; size = 4
?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > >::Alloc, COMDAT
; _this$ = ecx

; 69   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 200				; 000000c8H
	mov	DWORD PTR _this$[ebp], ecx

; 70   : 		unsigned int nLocalBytes = sizeof(TYPE) * (pData->nX + 1);

	mov	eax, DWORD PTR _pData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	lea	edx, DWORD PTR [ecx*4+4]
	mov	DWORD PTR _nLocalBytes$[ebp], edx

; 71   : 		void* pRet = BASE::Alloc( nBytes + nLocalBytes, pData+1 );

	mov	eax, DWORD PTR _pData$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _nBytes$[ebp]
	add	ecx, DWORD PTR _nLocalBytes$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > >::Alloc
	mov	DWORD PTR _pRet$[ebp], eax

; 72   : 		unsigned char* pLocMemStart = static_cast< unsigned char* > ( pRet ) - nLocalBytes;

	mov	edx, DWORD PTR _pRet$[ebp]
	sub	edx, DWORD PTR _nLocalBytes$[ebp]
	mov	DWORD PTR _pLocMemStart$[ebp], edx

; 73   : 
; 74   : 		unsigned int iAlignmentFix = sizeof(TYPE) - reinterpret_cast< unsigned int >(pLocMemStart) % sizeof(TYPE);

	mov	eax, DWORD PTR _pLocMemStart$[ebp]
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	mov	eax, 4
	sub	eax, edx
	mov	DWORD PTR _iAlignmentFix$[ebp], eax

; 75   : 		(*static_cast< TYPE** >(pData->pOut)) = (TYPE*)( pLocMemStart + iAlignmentFix );

	mov	ecx, DWORD PTR _pLocMemStart$[ebp]
	add	ecx, DWORD PTR _iAlignmentFix$[ebp]
	mov	edx, DWORD PTR _pData$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 76   : 
; 77   : 		return static_cast< void* >( pLocMemStart );

	mov	eax, DWORD PTR _pLocMemStart$[ebp]

; 78   : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > >::Alloc
_TEXT	ENDS
PUBLIC	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > >::Alloc
; Function compile flags: /Odtp
;	COMDAT ?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z
_TEXT	SEGMENT
_this$ = -184						; size = 4
_nLocalBytes$ = -16					; size = 4
_pLocMemStart$ = -12					; size = 4
_iAlignmentFix$ = -8					; size = 4
_pRet$ = -4						; size = 4
_nBytes$ = 8						; size = 4
_pData$ = 12						; size = 4
?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > >::Alloc, COMDAT
; _this$ = ecx

; 69   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 184				; 000000b8H
	mov	DWORD PTR _this$[ebp], ecx

; 70   : 		unsigned int nLocalBytes = sizeof(TYPE) * (pData->nX + 1);

	mov	eax, DWORD PTR _pData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	lea	edx, DWORD PTR [ecx*4+4]
	mov	DWORD PTR _nLocalBytes$[ebp], edx

; 71   : 		void* pRet = BASE::Alloc( nBytes + nLocalBytes, pData+1 );

	mov	eax, DWORD PTR _pData$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _nBytes$[ebp]
	add	ecx, DWORD PTR _nLocalBytes$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > >::Alloc
	mov	DWORD PTR _pRet$[ebp], eax

; 72   : 		unsigned char* pLocMemStart = static_cast< unsigned char* > ( pRet ) - nLocalBytes;

	mov	edx, DWORD PTR _pRet$[ebp]
	sub	edx, DWORD PTR _nLocalBytes$[ebp]
	mov	DWORD PTR _pLocMemStart$[ebp], edx

; 73   : 
; 74   : 		unsigned int iAlignmentFix = sizeof(TYPE) - reinterpret_cast< unsigned int >(pLocMemStart) % sizeof(TYPE);

	mov	eax, DWORD PTR _pLocMemStart$[ebp]
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	mov	eax, 4
	sub	eax, edx
	mov	DWORD PTR _iAlignmentFix$[ebp], eax

; 75   : 		(*static_cast< TYPE** >(pData->pOut)) = (TYPE*)( pLocMemStart + iAlignmentFix );

	mov	ecx, DWORD PTR _pLocMemStart$[ebp]
	add	ecx, DWORD PTR _iAlignmentFix$[ebp]
	mov	edx, DWORD PTR _pData$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 76   : 
; 77   : 		return static_cast< void* >( pLocMemStart );

	mov	eax, DWORD PTR _pLocMemStart$[ebp]

; 78   : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > >::Alloc
_TEXT	ENDS
PUBLIC	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > >::Alloc
; Function compile flags: /Odtp
;	COMDAT ?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z
_TEXT	SEGMENT
_this$ = -204						; size = 4
_nLocalBytes$ = -16					; size = 4
_pLocMemStart$ = -12					; size = 4
_iAlignmentFix$ = -8					; size = 4
_pRet$ = -4						; size = 4
_nBytes$ = 8						; size = 4
_pData$ = 12						; size = 4
?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > >::Alloc, COMDAT
; _this$ = ecx

; 69   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	mov	DWORD PTR _this$[ebp], ecx

; 70   : 		unsigned int nLocalBytes = sizeof(TYPE) * (pData->nX + 1);

	mov	eax, DWORD PTR _pData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	lea	edx, DWORD PTR [ecx*4+4]
	mov	DWORD PTR _nLocalBytes$[ebp], edx

; 71   : 		void* pRet = BASE::Alloc( nBytes + nLocalBytes, pData+1 );

	mov	eax, DWORD PTR _pData$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _nBytes$[ebp]
	add	ecx, DWORD PTR _nLocalBytes$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > >::Alloc
	mov	DWORD PTR _pRet$[ebp], eax

; 72   : 		unsigned char* pLocMemStart = static_cast< unsigned char* > ( pRet ) - nLocalBytes;

	mov	edx, DWORD PTR _pRet$[ebp]
	sub	edx, DWORD PTR _nLocalBytes$[ebp]
	mov	DWORD PTR _pLocMemStart$[ebp], edx

; 73   : 
; 74   : 		unsigned int iAlignmentFix = sizeof(TYPE) - reinterpret_cast< unsigned int >(pLocMemStart) % sizeof(TYPE);

	mov	eax, DWORD PTR _pLocMemStart$[ebp]
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	mov	eax, 4
	sub	eax, edx
	mov	DWORD PTR _iAlignmentFix$[ebp], eax

; 75   : 		(*static_cast< TYPE** >(pData->pOut)) = (TYPE*)( pLocMemStart + iAlignmentFix );

	mov	ecx, DWORD PTR _pLocMemStart$[ebp]
	add	ecx, DWORD PTR _iAlignmentFix$[ebp]
	mov	edx, DWORD PTR _pData$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 76   : 
; 77   : 		return static_cast< void* >( pLocMemStart );

	mov	eax, DWORD PTR _pLocMemStart$[ebp]

; 78   : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > >::Alloc
_TEXT	ENDS
PUBLIC	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > >::Alloc
; Function compile flags: /Odtp
;	COMDAT ?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z
_TEXT	SEGMENT
_this$ = -188						; size = 4
_nLocalBytes$ = -16					; size = 4
_pLocMemStart$ = -12					; size = 4
_iAlignmentFix$ = -8					; size = 4
_pRet$ = -4						; size = 4
_nBytes$ = 8						; size = 4
_pData$ = 12						; size = 4
?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > >::Alloc, COMDAT
; _this$ = ecx

; 69   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 188				; 000000bcH
	mov	DWORD PTR _this$[ebp], ecx

; 70   : 		unsigned int nLocalBytes = sizeof(TYPE) * (pData->nX + 1);

	mov	eax, DWORD PTR _pData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	lea	edx, DWORD PTR [ecx*4+4]
	mov	DWORD PTR _nLocalBytes$[ebp], edx

; 71   : 		void* pRet = BASE::Alloc( nBytes + nLocalBytes, pData+1 );

	mov	eax, DWORD PTR _pData$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _nBytes$[ebp]
	add	ecx, DWORD PTR _nLocalBytes$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > >::Alloc
	mov	DWORD PTR _pRet$[ebp], eax

; 72   : 		unsigned char* pLocMemStart = static_cast< unsigned char* > ( pRet ) - nLocalBytes;

	mov	edx, DWORD PTR _pRet$[ebp]
	sub	edx, DWORD PTR _nLocalBytes$[ebp]
	mov	DWORD PTR _pLocMemStart$[ebp], edx

; 73   : 
; 74   : 		unsigned int iAlignmentFix = sizeof(TYPE) - reinterpret_cast< unsigned int >(pLocMemStart) % sizeof(TYPE);

	mov	eax, DWORD PTR _pLocMemStart$[ebp]
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	mov	eax, 4
	sub	eax, edx
	mov	DWORD PTR _iAlignmentFix$[ebp], eax

; 75   : 		(*static_cast< TYPE** >(pData->pOut)) = (TYPE*)( pLocMemStart + iAlignmentFix );

	mov	ecx, DWORD PTR _pLocMemStart$[ebp]
	add	ecx, DWORD PTR _iAlignmentFix$[ebp]
	mov	edx, DWORD PTR _pData$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 76   : 
; 77   : 		return static_cast< void* >( pLocMemStart );

	mov	eax, DWORD PTR _pLocMemStart$[ebp]

; 78   : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > >::Alloc
_TEXT	ENDS
PUBLIC	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > >::Alloc
; Function compile flags: /Odtp
;	COMDAT ?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z
_TEXT	SEGMENT
_this$ = -216						; size = 4
_nLocalBytes$ = -16					; size = 4
_pLocMemStart$ = -12					; size = 4
_iAlignmentFix$ = -8					; size = 4
_pRet$ = -4						; size = 4
_nBytes$ = 8						; size = 4
_pData$ = 12						; size = 4
?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > >::Alloc, COMDAT
; _this$ = ecx

; 69   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	mov	DWORD PTR _this$[ebp], ecx

; 70   : 		unsigned int nLocalBytes = sizeof(TYPE) * (pData->nX + 1);

	mov	eax, DWORD PTR _pData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	lea	edx, DWORD PTR [ecx*4+4]
	mov	DWORD PTR _nLocalBytes$[ebp], edx

; 71   : 		void* pRet = BASE::Alloc( nBytes + nLocalBytes, pData+1 );

	mov	eax, DWORD PTR _pData$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _nBytes$[ebp]
	add	ecx, DWORD PTR _nLocalBytes$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > >::Alloc
	mov	DWORD PTR _pRet$[ebp], eax

; 72   : 		unsigned char* pLocMemStart = static_cast< unsigned char* > ( pRet ) - nLocalBytes;

	mov	edx, DWORD PTR _pRet$[ebp]
	sub	edx, DWORD PTR _nLocalBytes$[ebp]
	mov	DWORD PTR _pLocMemStart$[ebp], edx

; 73   : 
; 74   : 		unsigned int iAlignmentFix = sizeof(TYPE) - reinterpret_cast< unsigned int >(pLocMemStart) % sizeof(TYPE);

	mov	eax, DWORD PTR _pLocMemStart$[ebp]
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	mov	eax, 4
	sub	eax, edx
	mov	DWORD PTR _iAlignmentFix$[ebp], eax

; 75   : 		(*static_cast< TYPE** >(pData->pOut)) = (TYPE*)( pLocMemStart + iAlignmentFix );

	mov	ecx, DWORD PTR _pLocMemStart$[ebp]
	add	ecx, DWORD PTR _iAlignmentFix$[ebp]
	mov	edx, DWORD PTR _pData$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 76   : 
; 77   : 		return static_cast< void* >( pLocMemStart );

	mov	eax, DWORD PTR _pLocMemStart$[ebp]

; 78   : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > >::Alloc
_TEXT	ENDS
PUBLIC	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > >::Alloc
; Function compile flags: /Odtp
;	COMDAT ?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z
_TEXT	SEGMENT
_this$ = -200						; size = 4
_nLocalBytes$ = -16					; size = 4
_pLocMemStart$ = -12					; size = 4
_iAlignmentFix$ = -8					; size = 4
_pRet$ = -4						; size = 4
_nBytes$ = 8						; size = 4
_pData$ = 12						; size = 4
?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > >::Alloc, COMDAT
; _this$ = ecx

; 69   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 200				; 000000c8H
	mov	DWORD PTR _this$[ebp], ecx

; 70   : 		unsigned int nLocalBytes = sizeof(TYPE) * (pData->nX + 1);

	mov	eax, DWORD PTR _pData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	lea	edx, DWORD PTR [ecx*4+4]
	mov	DWORD PTR _nLocalBytes$[ebp], edx

; 71   : 		void* pRet = BASE::Alloc( nBytes + nLocalBytes, pData+1 );

	mov	eax, DWORD PTR _pData$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _nBytes$[ebp]
	add	ecx, DWORD PTR _nLocalBytes$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > >::Alloc
	mov	DWORD PTR _pRet$[ebp], eax

; 72   : 		unsigned char* pLocMemStart = static_cast< unsigned char* > ( pRet ) - nLocalBytes;

	mov	edx, DWORD PTR _pRet$[ebp]
	sub	edx, DWORD PTR _nLocalBytes$[ebp]
	mov	DWORD PTR _pLocMemStart$[ebp], edx

; 73   : 
; 74   : 		unsigned int iAlignmentFix = sizeof(TYPE) - reinterpret_cast< unsigned int >(pLocMemStart) % sizeof(TYPE);

	mov	eax, DWORD PTR _pLocMemStart$[ebp]
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	mov	eax, 4
	sub	eax, edx
	mov	DWORD PTR _iAlignmentFix$[ebp], eax

; 75   : 		(*static_cast< TYPE** >(pData->pOut)) = (TYPE*)( pLocMemStart + iAlignmentFix );

	mov	ecx, DWORD PTR _pLocMemStart$[ebp]
	add	ecx, DWORD PTR _iAlignmentFix$[ebp]
	mov	edx, DWORD PTR _pData$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 76   : 
; 77   : 		return static_cast< void* >( pLocMemStart );

	mov	eax, DWORD PTR _pLocMemStart$[ebp]

; 78   : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > >::Alloc
_TEXT	ENDS
PUBLIC	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > >::Alloc
; Function compile flags: /Odtp
;	COMDAT ?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z
_TEXT	SEGMENT
_this$ = -184						; size = 4
_nLocalBytes$ = -16					; size = 4
_pLocMemStart$ = -12					; size = 4
_iAlignmentFix$ = -8					; size = 4
_pRet$ = -4						; size = 4
_nBytes$ = 8						; size = 4
_pData$ = 12						; size = 4
?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > >::Alloc, COMDAT
; _this$ = ecx

; 69   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 184				; 000000b8H
	mov	DWORD PTR _this$[ebp], ecx

; 70   : 		unsigned int nLocalBytes = sizeof(TYPE) * (pData->nX + 1);

	mov	eax, DWORD PTR _pData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	lea	edx, DWORD PTR [ecx*4+4]
	mov	DWORD PTR _nLocalBytes$[ebp], edx

; 71   : 		void* pRet = BASE::Alloc( nBytes + nLocalBytes, pData+1 );

	mov	eax, DWORD PTR _pData$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _nBytes$[ebp]
	add	ecx, DWORD PTR _nLocalBytes$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > >::Alloc
	mov	DWORD PTR _pRet$[ebp], eax

; 72   : 		unsigned char* pLocMemStart = static_cast< unsigned char* > ( pRet ) - nLocalBytes;

	mov	edx, DWORD PTR _pRet$[ebp]
	sub	edx, DWORD PTR _nLocalBytes$[ebp]
	mov	DWORD PTR _pLocMemStart$[ebp], edx

; 73   : 
; 74   : 		unsigned int iAlignmentFix = sizeof(TYPE) - reinterpret_cast< unsigned int >(pLocMemStart) % sizeof(TYPE);

	mov	eax, DWORD PTR _pLocMemStart$[ebp]
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	mov	eax, 4
	sub	eax, edx
	mov	DWORD PTR _iAlignmentFix$[ebp], eax

; 75   : 		(*static_cast< TYPE** >(pData->pOut)) = (TYPE*)( pLocMemStart + iAlignmentFix );

	mov	ecx, DWORD PTR _pLocMemStart$[ebp]
	add	ecx, DWORD PTR _iAlignmentFix$[ebp]
	mov	edx, DWORD PTR _pData$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 76   : 
; 77   : 		return static_cast< void* >( pLocMemStart );

	mov	eax, DWORD PTR _pLocMemStart$[ebp]

; 78   : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > >::Alloc
_TEXT	ENDS
PUBLIC	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > >::Alloc
; Function compile flags: /Odtp
;	COMDAT ?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z
_TEXT	SEGMENT
_this$ = -168						; size = 4
_nLocalBytes$ = -16					; size = 4
_pLocMemStart$ = -12					; size = 4
_iAlignmentFix$ = -8					; size = 4
_pRet$ = -4						; size = 4
_nBytes$ = 8						; size = 4
_pData$ = 12						; size = 4
?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > >::Alloc, COMDAT
; _this$ = ecx

; 69   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 168				; 000000a8H
	mov	DWORD PTR _this$[ebp], ecx

; 70   : 		unsigned int nLocalBytes = sizeof(TYPE) * (pData->nX + 1);

	mov	eax, DWORD PTR _pData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	lea	edx, DWORD PTR [ecx*4+4]
	mov	DWORD PTR _nLocalBytes$[ebp], edx

; 71   : 		void* pRet = BASE::Alloc( nBytes + nLocalBytes, pData+1 );

	mov	eax, DWORD PTR _pData$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _nBytes$[ebp]
	add	ecx, DWORD PTR _nLocalBytes$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > >::Alloc
	mov	DWORD PTR _pRet$[ebp], eax

; 72   : 		unsigned char* pLocMemStart = static_cast< unsigned char* > ( pRet ) - nLocalBytes;

	mov	edx, DWORD PTR _pRet$[ebp]
	sub	edx, DWORD PTR _nLocalBytes$[ebp]
	mov	DWORD PTR _pLocMemStart$[ebp], edx

; 73   : 
; 74   : 		unsigned int iAlignmentFix = sizeof(TYPE) - reinterpret_cast< unsigned int >(pLocMemStart) % sizeof(TYPE);

	mov	eax, DWORD PTR _pLocMemStart$[ebp]
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	mov	eax, 4
	sub	eax, edx
	mov	DWORD PTR _iAlignmentFix$[ebp], eax

; 75   : 		(*static_cast< TYPE** >(pData->pOut)) = (TYPE*)( pLocMemStart + iAlignmentFix );

	mov	ecx, DWORD PTR _pLocMemStart$[ebp]
	add	ecx, DWORD PTR _iAlignmentFix$[ebp]
	mov	edx, DWORD PTR _pData$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 76   : 
; 77   : 		return static_cast< void* >( pLocMemStart );

	mov	eax, DWORD PTR _pLocMemStart$[ebp]

; 78   : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > >::Alloc
_TEXT	ENDS
PUBLIC	?Alloc@?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > >::Alloc
; Function compile flags: /Odtp
;	COMDAT ?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z
_TEXT	SEGMENT
_this$ = -152						; size = 4
_nLocalBytes$ = -16					; size = 4
_pLocMemStart$ = -12					; size = 4
_iAlignmentFix$ = -8					; size = 4
_pRet$ = -4						; size = 4
_nBytes$ = 8						; size = 4
_pData$ = 12						; size = 4
?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > >::Alloc, COMDAT
; _this$ = ecx

; 69   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H
	mov	DWORD PTR _this$[ebp], ecx

; 70   : 		unsigned int nLocalBytes = sizeof(TYPE) * (pData->nX + 1);

	mov	eax, DWORD PTR _pData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	lea	edx, DWORD PTR [ecx*4+4]
	mov	DWORD PTR _nLocalBytes$[ebp], edx

; 71   : 		void* pRet = BASE::Alloc( nBytes + nLocalBytes, pData+1 );

	mov	eax, DWORD PTR _pData$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _nBytes$[ebp]
	add	ecx, DWORD PTR _nLocalBytes$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Alloc@?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > >::Alloc
	mov	DWORD PTR _pRet$[ebp], eax

; 72   : 		unsigned char* pLocMemStart = static_cast< unsigned char* > ( pRet ) - nLocalBytes;

	mov	edx, DWORD PTR _pRet$[ebp]
	sub	edx, DWORD PTR _nLocalBytes$[ebp]
	mov	DWORD PTR _pLocMemStart$[ebp], edx

; 73   : 
; 74   : 		unsigned int iAlignmentFix = sizeof(TYPE) - reinterpret_cast< unsigned int >(pLocMemStart) % sizeof(TYPE);

	mov	eax, DWORD PTR _pLocMemStart$[ebp]
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	mov	eax, 4
	sub	eax, edx
	mov	DWORD PTR _iAlignmentFix$[ebp], eax

; 75   : 		(*static_cast< TYPE** >(pData->pOut)) = (TYPE*)( pLocMemStart + iAlignmentFix );

	mov	ecx, DWORD PTR _pLocMemStart$[ebp]
	add	ecx, DWORD PTR _iAlignmentFix$[ebp]
	mov	edx, DWORD PTR _pData$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 76   : 
; 77   : 		return static_cast< void* >( pLocMemStart );

	mov	eax, DWORD PTR _pLocMemStart$[ebp]

; 78   : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > >::Alloc
_TEXT	ENDS
PUBLIC	?Alloc@?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > >::Alloc
; Function compile flags: /Odtp
;	COMDAT ?Alloc@?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z
_TEXT	SEGMENT
_this$ = -136						; size = 4
_nLocalBytes$ = -16					; size = 4
_pLocMemStart$ = -12					; size = 4
_iAlignmentFix$ = -8					; size = 4
_pRet$ = -4						; size = 4
_nBytes$ = 8						; size = 4
_pData$ = 12						; size = 4
?Alloc@?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z PROC ; FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > >::Alloc, COMDAT
; _this$ = ecx

; 69   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	mov	DWORD PTR _this$[ebp], ecx

; 70   : 		unsigned int nLocalBytes = sizeof(TYPE) * (pData->nX + 1);

	mov	eax, DWORD PTR _pData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	lea	edx, DWORD PTR [ecx*4+4]
	mov	DWORD PTR _nLocalBytes$[ebp], edx

; 71   : 		void* pRet = BASE::Alloc( nBytes + nLocalBytes, pData+1 );

	mov	eax, DWORD PTR _pData$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _nBytes$[ebp]
	add	ecx, DWORD PTR _nLocalBytes$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Alloc@?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > >::Alloc
	mov	DWORD PTR _pRet$[ebp], eax

; 72   : 		unsigned char* pLocMemStart = static_cast< unsigned char* > ( pRet ) - nLocalBytes;

	mov	edx, DWORD PTR _pRet$[ebp]
	sub	edx, DWORD PTR _nLocalBytes$[ebp]
	mov	DWORD PTR _pLocMemStart$[ebp], edx

; 73   : 
; 74   : 		unsigned int iAlignmentFix = sizeof(TYPE) - reinterpret_cast< unsigned int >(pLocMemStart) % sizeof(TYPE);

	mov	eax, DWORD PTR _pLocMemStart$[ebp]
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	mov	eax, 4
	sub	eax, edx
	mov	DWORD PTR _iAlignmentFix$[ebp], eax

; 75   : 		(*static_cast< TYPE** >(pData->pOut)) = (TYPE*)( pLocMemStart + iAlignmentFix );

	mov	ecx, DWORD PTR _pLocMemStart$[ebp]
	add	ecx, DWORD PTR _iAlignmentFix$[ebp]
	mov	edx, DWORD PTR _pData$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 76   : 
; 77   : 		return static_cast< void* >( pLocMemStart );

	mov	eax, DWORD PTR _pLocMemStart$[ebp]

; 78   : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?Alloc@?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ENDP ; FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > >::Alloc
_TEXT	ENDS
PUBLIC	?Alloc@?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > >::Alloc
; Function compile flags: /Odtp
;	COMDAT ?Alloc@?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@QAEPAXIPAUAllocData@@@Z
_TEXT	SEGMENT
_this$ = -120						; size = 4
_i$227850 = -36						; size = 4
_pLocMemStart$ = -32					; size = 4
_iArrayAlignmentFix$ = -28				; size = 4
_nDataBytes$ = -24					; size = 4
_nArrayBytes$ = -20					; size = 4
_pFirstElement$ = -16					; size = 4
_iDataAlignmentFix$ = -12				; size = 4
_ppArray$ = -8						; size = 4
_pRet$ = -4						; size = 4
_nBytes$ = 8						; size = 4
_pData$ = 12						; size = 4
?Alloc@?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@QAEPAXIPAUAllocData@@@Z PROC ; FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > >::Alloc, COMDAT
; _this$ = ecx

; 97   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	mov	DWORD PTR _this$[ebp], ecx

; 98   : 		unsigned int nArrayBytes = sizeof(TYPE*) * (pData->nX + 1);

	mov	eax, DWORD PTR _pData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	lea	edx, DWORD PTR [ecx*4+4]
	mov	DWORD PTR _nArrayBytes$[ebp], edx

; 99   : 		unsigned int nDataBytes = sizeof(TYPE) * pData->nX * ( pData->nY + 1 );

	mov	eax, DWORD PTR _pData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	mov	edx, DWORD PTR _pData$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 1
	imul	ecx, eax
	mov	DWORD PTR _nDataBytes$[ebp], ecx

; 100  : 		void* pRet = BASE::Alloc( nBytes + nDataBytes + nArrayBytes, pData+1 );

	mov	ecx, DWORD PTR _pData$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	edx, DWORD PTR _nBytes$[ebp]
	add	edx, DWORD PTR _nDataBytes$[ebp]
	add	edx, DWORD PTR _nArrayBytes$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Alloc@?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > >::Alloc
	mov	DWORD PTR _pRet$[ebp], eax

; 101  : 		unsigned char* pLocMemStart = static_cast< unsigned char* > ( pRet );

	mov	eax, DWORD PTR _pRet$[ebp]
	mov	DWORD PTR _pLocMemStart$[ebp], eax

; 102  : 
; 103  : 		unsigned int iDataAlignmentFix = sizeof(TYPE) - reinterpret_cast< unsigned int >(pLocMemStart -= nDataBytes) % sizeof(TYPE);

	mov	ecx, DWORD PTR _pLocMemStart$[ebp]
	sub	ecx, DWORD PTR _nDataBytes$[ebp]
	mov	DWORD PTR _pLocMemStart$[ebp], ecx
	mov	eax, DWORD PTR _pLocMemStart$[ebp]
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	mov	eax, 4
	sub	eax, edx
	mov	DWORD PTR _iDataAlignmentFix$[ebp], eax

; 104  : 		TYPE* pFirstElement = (TYPE*)( pLocMemStart + iDataAlignmentFix );

	mov	ecx, DWORD PTR _pLocMemStart$[ebp]
	add	ecx, DWORD PTR _iDataAlignmentFix$[ebp]
	mov	DWORD PTR _pFirstElement$[ebp], ecx

; 105  : 
; 106  : 		unsigned int iArrayAlignmentFix = sizeof(TYPE*) - reinterpret_cast< unsigned int >(pLocMemStart -= nArrayBytes) % sizeof(TYPE*);

	mov	edx, DWORD PTR _pLocMemStart$[ebp]
	sub	edx, DWORD PTR _nArrayBytes$[ebp]
	mov	DWORD PTR _pLocMemStart$[ebp], edx
	mov	eax, DWORD PTR _pLocMemStart$[ebp]
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	mov	eax, 4
	sub	eax, edx
	mov	DWORD PTR _iArrayAlignmentFix$[ebp], eax

; 107  : 		TYPE** ppArray = (*static_cast< TYPE*** >(pData->pOut)) = (TYPE**)( pLocMemStart + iArrayAlignmentFix );

	mov	ecx, DWORD PTR _pLocMemStart$[ebp]
	add	ecx, DWORD PTR _iArrayAlignmentFix$[ebp]
	mov	edx, DWORD PTR _pData$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _pData$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _ppArray$[ebp], eax

; 108  : 
; 109  : 		for( unsigned int i = 0; i < pData->nX; ++i )

	mov	DWORD PTR _i$227850[ebp], 0
	jmp	SHORT $LN3@Alloc
$LN2@Alloc:
	mov	ecx, DWORD PTR _i$227850[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$227850[ebp], ecx
$LN3@Alloc:
	mov	edx, DWORD PTR _pData$[ebp]
	mov	eax, DWORD PTR _i$227850[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jae	SHORT $LN1@Alloc

; 110  : 		{
; 111  : 			*ppArray = pFirstElement + i * pData->nY;

	mov	ecx, DWORD PTR _pData$[ebp]
	mov	edx, DWORD PTR _i$227850[ebp]
	imul	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _pFirstElement$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _ppArray$[ebp]
	mov	DWORD PTR [edx], ecx

; 112  : 			++ppArray;

	mov	eax, DWORD PTR _ppArray$[ebp]
	add	eax, 4
	mov	DWORD PTR _ppArray$[ebp], eax

; 113  : 		}

	jmp	SHORT $LN2@Alloc
$LN1@Alloc:

; 114  : 
; 115  : 		return static_cast< void* >( pLocMemStart );

	mov	eax, DWORD PTR _pLocMemStart$[ebp]

; 116  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?Alloc@?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@QAEPAXIPAUAllocData@@@Z ENDP ; FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > >::Alloc
_TEXT	ENDS
PUBLIC	?Alloc@?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArray2DType<int,FAllocBase<0,0,0> >::Alloc
; Function compile flags: /Odtp
;	COMDAT ?Alloc@?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@QAEPAXIPAUAllocData@@@Z
_TEXT	SEGMENT
_this$ = -84						; size = 4
_i$227877 = -36						; size = 4
_pLocMemStart$ = -32					; size = 4
_iArrayAlignmentFix$ = -28				; size = 4
_nDataBytes$ = -24					; size = 4
_nArrayBytes$ = -20					; size = 4
_pFirstElement$ = -16					; size = 4
_iDataAlignmentFix$ = -12				; size = 4
_ppArray$ = -8						; size = 4
_pRet$ = -4						; size = 4
_nBytes$ = 8						; size = 4
_pData$ = 12						; size = 4
?Alloc@?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@QAEPAXIPAUAllocData@@@Z PROC ; FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > >::Alloc, COMDAT
; _this$ = ecx

; 97   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	DWORD PTR _this$[ebp], ecx

; 98   : 		unsigned int nArrayBytes = sizeof(TYPE*) * (pData->nX + 1);

	mov	eax, DWORD PTR _pData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	lea	edx, DWORD PTR [ecx*4+4]
	mov	DWORD PTR _nArrayBytes$[ebp], edx

; 99   : 		unsigned int nDataBytes = sizeof(TYPE) * pData->nX * ( pData->nY + 1 );

	mov	eax, DWORD PTR _pData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	mov	edx, DWORD PTR _pData$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 1
	imul	ecx, eax
	mov	DWORD PTR _nDataBytes$[ebp], ecx

; 100  : 		void* pRet = BASE::Alloc( nBytes + nDataBytes + nArrayBytes, pData+1 );

	mov	ecx, DWORD PTR _pData$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	edx, DWORD PTR _nBytes$[ebp]
	add	edx, DWORD PTR _nDataBytes$[ebp]
	add	edx, DWORD PTR _nArrayBytes$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Alloc@?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArray2DType<int,FAllocBase<0,0,0> >::Alloc
	mov	DWORD PTR _pRet$[ebp], eax

; 101  : 		unsigned char* pLocMemStart = static_cast< unsigned char* > ( pRet );

	mov	eax, DWORD PTR _pRet$[ebp]
	mov	DWORD PTR _pLocMemStart$[ebp], eax

; 102  : 
; 103  : 		unsigned int iDataAlignmentFix = sizeof(TYPE) - reinterpret_cast< unsigned int >(pLocMemStart -= nDataBytes) % sizeof(TYPE);

	mov	ecx, DWORD PTR _pLocMemStart$[ebp]
	sub	ecx, DWORD PTR _nDataBytes$[ebp]
	mov	DWORD PTR _pLocMemStart$[ebp], ecx
	mov	eax, DWORD PTR _pLocMemStart$[ebp]
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	mov	eax, 4
	sub	eax, edx
	mov	DWORD PTR _iDataAlignmentFix$[ebp], eax

; 104  : 		TYPE* pFirstElement = (TYPE*)( pLocMemStart + iDataAlignmentFix );

	mov	ecx, DWORD PTR _pLocMemStart$[ebp]
	add	ecx, DWORD PTR _iDataAlignmentFix$[ebp]
	mov	DWORD PTR _pFirstElement$[ebp], ecx

; 105  : 
; 106  : 		unsigned int iArrayAlignmentFix = sizeof(TYPE*) - reinterpret_cast< unsigned int >(pLocMemStart -= nArrayBytes) % sizeof(TYPE*);

	mov	edx, DWORD PTR _pLocMemStart$[ebp]
	sub	edx, DWORD PTR _nArrayBytes$[ebp]
	mov	DWORD PTR _pLocMemStart$[ebp], edx
	mov	eax, DWORD PTR _pLocMemStart$[ebp]
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	mov	eax, 4
	sub	eax, edx
	mov	DWORD PTR _iArrayAlignmentFix$[ebp], eax

; 107  : 		TYPE** ppArray = (*static_cast< TYPE*** >(pData->pOut)) = (TYPE**)( pLocMemStart + iArrayAlignmentFix );

	mov	ecx, DWORD PTR _pLocMemStart$[ebp]
	add	ecx, DWORD PTR _iArrayAlignmentFix$[ebp]
	mov	edx, DWORD PTR _pData$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _pData$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _ppArray$[ebp], eax

; 108  : 
; 109  : 		for( unsigned int i = 0; i < pData->nX; ++i )

	mov	DWORD PTR _i$227877[ebp], 0
	jmp	SHORT $LN3@Alloc@2
$LN2@Alloc@2:
	mov	ecx, DWORD PTR _i$227877[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$227877[ebp], ecx
$LN3@Alloc@2:
	mov	edx, DWORD PTR _pData$[ebp]
	mov	eax, DWORD PTR _i$227877[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jae	SHORT $LN1@Alloc@2

; 110  : 		{
; 111  : 			*ppArray = pFirstElement + i * pData->nY;

	mov	ecx, DWORD PTR _pData$[ebp]
	mov	edx, DWORD PTR _i$227877[ebp]
	imul	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _pFirstElement$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _ppArray$[ebp]
	mov	DWORD PTR [edx], ecx

; 112  : 			++ppArray;

	mov	eax, DWORD PTR _ppArray$[ebp]
	add	eax, 4
	mov	DWORD PTR _ppArray$[ebp], eax

; 113  : 		}

	jmp	SHORT $LN2@Alloc@2
$LN1@Alloc@2:

; 114  : 
; 115  : 		return static_cast< void* >( pLocMemStart );

	mov	eax, DWORD PTR _pLocMemStart$[ebp]

; 116  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?Alloc@?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@QAEPAXIPAUAllocData@@@Z ENDP ; FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > >::Alloc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Alloc@?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@QAEPAXIPAUAllocData@@@Z
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T241723 = -44						; size = 4
$T241721 = -40						; size = 4
_i$227904 = -36						; size = 4
_pLocMemStart$ = -32					; size = 4
_iArrayAlignmentFix$ = -28				; size = 4
_nDataBytes$ = -24					; size = 4
_nArrayBytes$ = -20					; size = 4
_pFirstElement$ = -16					; size = 4
_iDataAlignmentFix$ = -12				; size = 4
_ppArray$ = -8						; size = 4
_pRet$ = -4						; size = 4
_nBytes$ = 8						; size = 4
_pData$ = 12						; size = 4
?Alloc@?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@QAEPAXIPAUAllocData@@@Z PROC ; FAllocArray2DType<int,FAllocBase<0,0,0> >::Alloc, COMDAT
; _this$ = ecx

; 97   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 98   : 		unsigned int nArrayBytes = sizeof(TYPE*) * (pData->nX + 1);

	mov	eax, DWORD PTR _pData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	lea	edx, DWORD PTR [ecx*4+4]
	mov	DWORD PTR _nArrayBytes$[ebp], edx

; 99   : 		unsigned int nDataBytes = sizeof(TYPE) * pData->nX * ( pData->nY + 1 );

	mov	eax, DWORD PTR _pData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	mov	edx, DWORD PTR _pData$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 1
	imul	ecx, eax
	mov	DWORD PTR _nDataBytes$[ebp], ecx

; 100  : 		void* pRet = BASE::Alloc( nBytes + nDataBytes + nArrayBytes, pData+1 );

	mov	ecx, DWORD PTR _nBytes$[ebp]
	add	ecx, DWORD PTR _nDataBytes$[ebp]
	add	ecx, DWORD PTR _nArrayBytes$[ebp]
	mov	DWORD PTR $T241723[ebp], ecx
	mov	edx, DWORD PTR $T241723[ebp]
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T241721[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T241721[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, DWORD PTR $T241723[ebp]
	mov	DWORD PTR _pRet$[ebp], eax

; 101  : 		unsigned char* pLocMemStart = static_cast< unsigned char* > ( pRet );

	mov	ecx, DWORD PTR _pRet$[ebp]
	mov	DWORD PTR _pLocMemStart$[ebp], ecx

; 102  : 
; 103  : 		unsigned int iDataAlignmentFix = sizeof(TYPE) - reinterpret_cast< unsigned int >(pLocMemStart -= nDataBytes) % sizeof(TYPE);

	mov	edx, DWORD PTR _pLocMemStart$[ebp]
	sub	edx, DWORD PTR _nDataBytes$[ebp]
	mov	DWORD PTR _pLocMemStart$[ebp], edx
	mov	eax, DWORD PTR _pLocMemStart$[ebp]
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	mov	eax, 4
	sub	eax, edx
	mov	DWORD PTR _iDataAlignmentFix$[ebp], eax

; 104  : 		TYPE* pFirstElement = (TYPE*)( pLocMemStart + iDataAlignmentFix );

	mov	ecx, DWORD PTR _pLocMemStart$[ebp]
	add	ecx, DWORD PTR _iDataAlignmentFix$[ebp]
	mov	DWORD PTR _pFirstElement$[ebp], ecx

; 105  : 
; 106  : 		unsigned int iArrayAlignmentFix = sizeof(TYPE*) - reinterpret_cast< unsigned int >(pLocMemStart -= nArrayBytes) % sizeof(TYPE*);

	mov	edx, DWORD PTR _pLocMemStart$[ebp]
	sub	edx, DWORD PTR _nArrayBytes$[ebp]
	mov	DWORD PTR _pLocMemStart$[ebp], edx
	mov	eax, DWORD PTR _pLocMemStart$[ebp]
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	mov	eax, 4
	sub	eax, edx
	mov	DWORD PTR _iArrayAlignmentFix$[ebp], eax

; 107  : 		TYPE** ppArray = (*static_cast< TYPE*** >(pData->pOut)) = (TYPE**)( pLocMemStart + iArrayAlignmentFix );

	mov	ecx, DWORD PTR _pLocMemStart$[ebp]
	add	ecx, DWORD PTR _iArrayAlignmentFix$[ebp]
	mov	edx, DWORD PTR _pData$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _pData$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _ppArray$[ebp], eax

; 108  : 
; 109  : 		for( unsigned int i = 0; i < pData->nX; ++i )

	mov	DWORD PTR _i$227904[ebp], 0
	jmp	SHORT $LN3@Alloc@3
$LN2@Alloc@3:
	mov	ecx, DWORD PTR _i$227904[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$227904[ebp], ecx
$LN3@Alloc@3:
	mov	edx, DWORD PTR _pData$[ebp]
	mov	eax, DWORD PTR _i$227904[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jae	SHORT $LN1@Alloc@3

; 110  : 		{
; 111  : 			*ppArray = pFirstElement + i * pData->nY;

	mov	ecx, DWORD PTR _pData$[ebp]
	mov	edx, DWORD PTR _i$227904[ebp]
	imul	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _pFirstElement$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _ppArray$[ebp]
	mov	DWORD PTR [edx], ecx

; 112  : 			++ppArray;

	mov	eax, DWORD PTR _ppArray$[ebp]
	add	eax, 4
	mov	DWORD PTR _ppArray$[ebp], eax

; 113  : 		}

	jmp	SHORT $LN2@Alloc@3
$LN1@Alloc@3:

; 114  : 
; 115  : 		return static_cast< void* >( pLocMemStart );

	mov	eax, DWORD PTR _pLocMemStart$[ebp]

; 116  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?Alloc@?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@QAEPAXIPAUAllocData@@@Z ENDP ; FAllocArray2DType<int,FAllocBase<0,0,0> >::Alloc
_TEXT	ENDS
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z$1
__ehfuncinfo$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z
_TEXT	SEGMENT
$T241730 = -140						; size = 4
_str$ = -136						; size = 28
__$ArrayPad$ = -108					; size = 4
_bytes$ = -104						; size = 4
_text$ = -100						; size = 80
_szComposedString$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
_arg2$ = 20						; size = 4
??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z PROC ; GetLocalizedText<char const *,char const *>, COMDAT

; 514  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 128				; 00000080H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T241730[ebp], 0

; 515  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[ebp]
	push	eax
	lea	ecx, DWORD PTR _text$[ebp]
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 516  : 	text << arg1 << arg2;

	mov	edx, DWORD PTR _arg2$[ebp]
	push	edx
	mov	eax, DWORD PTR _arg1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _text$[ebp]
	push	ecx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8
	push	eax
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 517  : 
; 518  : 	size_t bytes = 0;

	mov	DWORD PTR _bytes$[ebp], 0

; 519  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	edx, DWORD PTR _bytes$[ebp]
	push	edx
	lea	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z
	mov	DWORD PTR _szComposedString$[ebp], eax

; 520  : 	CvString str;

	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 521  : 	str.assign(szComposedString, bytes);

	mov	eax, DWORD PTR _bytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szComposedString$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z

; 522  : 	return str;

	lea	edx, DWORD PTR _str$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T241730[ebp]
	or	eax, 1
	mov	DWORD PTR $T241730[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 523  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z$1:
	lea	ecx, DWORD PTR _str$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z$2:
	mov	eax, DWORD PTR $T241730[ebp]
	and	eax, 1
	je	$LN6@GetLocaliz@2
	and	DWORD PTR $T241730[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN6@GetLocaliz@2:
	ret	0
__ehhandler$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-132]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ENDP ; GetLocalizedText<char const *,char const *>
EXTRN	__imp_?PushArgument@String@Localization@@QAE_NPBD@Z:PROC
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvlocalization\include\cvlocalization.h
;	COMDAT ??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z PROC	; operator<<<char const *>, COMDAT

; 490  : {

	push	ebp
	mov	ebp, esp

; 491  : 	s.PushArgument(val);

	mov	eax, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _s$[ebp]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 492  : 	return s;

	mov	eax, DWORD PTR _s$[ebp]

; 493  : }

	pop	ebp
	ret	0
??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ENDP	; operator<<<char const *>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
_TEXT	ENDS
;	COMDAT ??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_x$ = 12						; size = 4
_func$ = 16						; size = 4
??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z PROC ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>, COMDAT

; 2030 : FastDelegate2<Param1, Param2, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2)) { 

	push	ebp
	mov	ebp, esp

; 2031 : 	return FastDelegate2<Param1, Param2, FASTDLGT_RETTYPE>(x, func);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR _func$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR _x$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2032 : }

	pop	ebp
	ret	0
??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z ENDP ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$1
__ehfuncinfo$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z
_TEXT	SEGMENT
$T241792 = -140						; size = 4
_str$ = -136						; size = 28
__$ArrayPad$ = -108					; size = 4
_bytes$ = -104						; size = 4
_text$ = -100						; size = 80
_szComposedString$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z PROC	; GetLocalizedText<char const *>, COMDAT

; 501  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 128				; 00000080H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T241792[ebp], 0

; 502  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[ebp]
	push	eax
	lea	ecx, DWORD PTR _text$[ebp]
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 503  : 	text << arg1;

	lea	edx, DWORD PTR _arg1$[ebp]
	push	edx
	lea	eax, DWORD PTR _text$[ebp]
	push	eax
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 504  : 
; 505  : 	size_t bytes = 0;

	mov	DWORD PTR _bytes$[ebp], 0

; 506  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	ecx, DWORD PTR _bytes$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z
	mov	DWORD PTR _szComposedString$[ebp], eax

; 507  : 	CvString str;

	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 508  : 	str.assign(szComposedString, bytes);

	mov	edx, DWORD PTR _bytes$[ebp]
	push	edx
	mov	eax, DWORD PTR _szComposedString$[ebp]
	push	eax
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z

; 509  : 	return str;

	lea	ecx, DWORD PTR _str$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	edx, DWORD PTR $T241792[ebp]
	or	edx, 1
	mov	DWORD PTR $T241792[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 510  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$1:
	lea	ecx, DWORD PTR _str$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$2:
	mov	eax, DWORD PTR $T241792[ebp]
	and	eax, 1
	je	$LN6@GetLocaliz@3
	and	DWORD PTR $T241792[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN6@GetLocaliz@3:
	ret	0
__ehhandler$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-132]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ENDP	; GetLocalizedText<char const *>
PUBLIC	??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z	; operator<<<int>
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z$1
__ehfuncinfo$??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z
_TEXT	SEGMENT
$T241818 = -140						; size = 4
_str$ = -136						; size = 28
__$ArrayPad$ = -108					; size = 4
_bytes$ = -104						; size = 4
_text$ = -100						; size = 80
_szComposedString$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
_arg2$ = 20						; size = 4
??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z PROC	; GetLocalizedText<int,int>, COMDAT

; 514  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 128				; 00000080H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T241818[ebp], 0

; 515  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[ebp]
	push	eax
	lea	ecx, DWORD PTR _text$[ebp]
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 516  : 	text << arg1 << arg2;

	mov	edx, DWORD PTR _arg2$[ebp]
	push	edx
	mov	eax, DWORD PTR _arg1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _text$[ebp]
	push	ecx
	call	??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z ; operator<<<int>
	add	esp, 8
	push	eax
	call	??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z ; operator<<<int>
	add	esp, 8

; 517  : 
; 518  : 	size_t bytes = 0;

	mov	DWORD PTR _bytes$[ebp], 0

; 519  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	edx, DWORD PTR _bytes$[ebp]
	push	edx
	lea	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z
	mov	DWORD PTR _szComposedString$[ebp], eax

; 520  : 	CvString str;

	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 521  : 	str.assign(szComposedString, bytes);

	mov	eax, DWORD PTR _bytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szComposedString$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z

; 522  : 	return str;

	lea	edx, DWORD PTR _str$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T241818[ebp]
	or	eax, 1
	mov	DWORD PTR $T241818[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 523  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z$1:
	lea	ecx, DWORD PTR _str$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z$2:
	mov	eax, DWORD PTR $T241818[ebp]
	and	eax, 1
	je	$LN6@GetLocaliz@4
	and	DWORD PTR $T241818[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN6@GetLocaliz@4:
	ret	0
__ehhandler$??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-132]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z ENDP	; GetLocalizedText<int,int>
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z$1
__ehfuncinfo$??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z
_TEXT	SEGMENT
$T241844 = -140						; size = 4
_str$ = -136						; size = 28
__$ArrayPad$ = -108					; size = 4
_bytes$ = -104						; size = 4
_text$ = -100						; size = 80
_szComposedString$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z PROC	; GetLocalizedText<int>, COMDAT

; 501  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 128				; 00000080H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T241844[ebp], 0

; 502  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[ebp]
	push	eax
	lea	ecx, DWORD PTR _text$[ebp]
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 503  : 	text << arg1;

	lea	edx, DWORD PTR _arg1$[ebp]
	push	edx
	lea	eax, DWORD PTR _text$[ebp]
	push	eax
	call	??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z ; operator<<<int>
	add	esp, 8

; 504  : 
; 505  : 	size_t bytes = 0;

	mov	DWORD PTR _bytes$[ebp], 0

; 506  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	ecx, DWORD PTR _bytes$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z
	mov	DWORD PTR _szComposedString$[ebp], eax

; 507  : 	CvString str;

	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 508  : 	str.assign(szComposedString, bytes);

	mov	edx, DWORD PTR _bytes$[ebp]
	push	edx
	mov	eax, DWORD PTR _szComposedString$[ebp]
	push	eax
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z

; 509  : 	return str;

	lea	ecx, DWORD PTR _str$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	edx, DWORD PTR $T241844[ebp]
	or	edx, 1
	mov	DWORD PTR $T241844[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 510  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z$1:
	lea	ecx, DWORD PTR _str$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z$2:
	mov	eax, DWORD PTR $T241844[ebp]
	and	eax, 1
	je	$LN6@GetLocaliz@5
	and	DWORD PTR $T241844[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN6@GetLocaliz@5:
	ret	0
__ehhandler$??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-132]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z ENDP	; GetLocalizedText<int>
EXTRN	__imp_?PushArgument@String@Localization@@QAE_NABV12@@Z:PROC
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvlocalization\include\cvlocalization.h
;	COMDAT ??$?6VString@Localization@@@@YAAAVString@Localization@@AAV01@ABV01@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6VString@Localization@@@@YAAAVString@Localization@@AAV01@ABV01@@Z PROC ; operator<<<Localization::String>, COMDAT

; 490  : {

	push	ebp
	mov	ebp, esp

; 491  : 	s.PushArgument(val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NABV12@@Z

; 492  : 	return s;

	mov	eax, DWORD PTR _s$[ebp]

; 493  : }

	pop	ebp
	ret	0
??$?6VString@Localization@@@@YAAAVString@Localization@@AAV01@ABV01@@Z ENDP ; operator<<<Localization::String>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fdatastream.h
_TEXT	ENDS
;	COMDAT ??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z
_TEXT	SEGMENT
_i$ = -12						; size = 4
_values$ = -8						; size = 4
_count$ = -4						; size = 4
_loadFrom$ = 8						; size = 4
_v$ = 12						; size = 4
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z PROC ; operator>><int>, COMDAT

; 515  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 516  : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 517  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _count$[ebp], ecx

; 518  : 	ValueType * values = v.getArray();

	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _values$[ebp], eax

; 519  : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@operator
$LN2@operator:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN3@operator:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _count$[ebp]
	jge	SHORT $LN1@operator

; 520  : 	{
; 521  : 		loadFrom >> values[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _values$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 522  : 	}

	jmp	SHORT $LN2@operator
$LN1@operator:

; 523  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 524  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ENDP ; operator>><int>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvinfosserializationhelper.h
_TEXT	ENDS
;	COMDAT ??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z
_TEXT	SEGMENT
_tValue$227986 = -24					; size = 4
_tValue$227981 = -20					; size = 4
_iType$227979 = -16					; size = 4
_bValid$227978 = -9					; size = 1
_iI$227974 = -8						; size = 4
_uiNumEntries$ = -4					; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_iArraySize$ = 16					; size = 4
??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z PROC ; CvInfosSerializationHelper::ReadHashedDataArray<int>, COMDAT

; 248  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 249  : 	uint uiNumEntries;
; 250  : 
; 251  : 	kStream >> uiNumEntries;

	lea	eax, DWORD PTR _uiNumEntries$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 252  : 
; 253  : 	for(uint iI = 0; iI < uiNumEntries; iI++)

	mov	DWORD PTR _iI$227974[ebp], 0
	jmp	SHORT $LN7@ReadHashed
$LN6@ReadHashed:
	mov	ecx, DWORD PTR _iI$227974[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$227974[ebp], ecx
$LN7@ReadHashed:
	mov	edx, DWORD PTR _iI$227974[ebp]
	cmp	edx, DWORD PTR _uiNumEntries$[ebp]
	jae	SHORT $LN8@ReadHashed

; 254  : 	{
; 255  : 		bool bValid;
; 256  : 		int iType = ReadHashed(kStream, &bValid);

	lea	eax, DWORD PTR _bValid$227978[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	add	esp, 8
	mov	DWORD PTR _iType$227979[ebp], eax

; 257  : 		if(iType != -1)

	cmp	DWORD PTR _iType$227979[ebp], -1
	je	SHORT $LN4@ReadHashed

; 258  : 		{
; 259  : 			TData tValue;
; 260  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$227981[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 261  : 			if((int)iType < iArraySize)

	mov	eax, DWORD PTR _iType$227979[ebp]
	cmp	eax, DWORD PTR _iArraySize$[ebp]
	jge	SHORT $LN3@ReadHashed

; 262  : 				paArray[iType] = tValue;

	mov	ecx, DWORD PTR _iType$227979[ebp]
	mov	edx, DWORD PTR _paArray$[ebp]
	mov	eax, DWORD PTR _tValue$227981[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
$LN3@ReadHashed:

; 263  : 		}

	jmp	SHORT $LN2@ReadHashed
$LN4@ReadHashed:

; 264  : 		else if(!bValid)

	movzx	ecx, BYTE PTR _bValid$227978[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@ReadHashed

; 265  : 		{
; 266  : 			TData tValue;
; 267  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$227986[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
$LN2@ReadHashed:

; 268  : 		}
; 269  : 	}

	jmp	SHORT $LN6@ReadHashed
$LN8@ReadHashed:

; 270  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ENDP ; CvInfosSerializationHelper::ReadHashedDataArray<int>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fdatastream.h
_TEXT	ENDS
;	COMDAT ??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z
_TEXT	SEGMENT
_i$ = -12						; size = 4
_values$ = -8						; size = 4
_count$ = -4						; size = 4
_loadFrom$ = 8						; size = 4
_v$ = 12						; size = 4
??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z PROC ; operator>><bool>, COMDAT

; 515  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 516  : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 517  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _count$[ebp], ecx

; 518  : 	ValueType * values = v.getArray();

	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _values$[ebp], eax

; 519  : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@operator@2
$LN2@operator@2:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN3@operator@2:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _count$[ebp]
	jge	SHORT $LN1@operator@2

; 520  : 	{
; 521  : 		loadFrom >> values[i];

	mov	eax, DWORD PTR _values$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 522  : 	}

	jmp	SHORT $LN2@operator@2
$LN1@operator@2:

; 523  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 524  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z ENDP ; operator>><bool>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvinfosserializationhelper.h
_TEXT	ENDS
;	COMDAT ??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z
_TEXT	SEGMENT
_tValue$228008 = -18					; size = 1
_tValue$228003 = -17					; size = 1
_iType$228001 = -16					; size = 4
_bValid$228000 = -9					; size = 1
_iI$227996 = -8						; size = 4
_uiNumEntries$ = -4					; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_iArraySize$ = 16					; size = 4
??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z PROC ; CvInfosSerializationHelper::ReadHashedDataArray<bool>, COMDAT

; 248  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 249  : 	uint uiNumEntries;
; 250  : 
; 251  : 	kStream >> uiNumEntries;

	lea	eax, DWORD PTR _uiNumEntries$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 252  : 
; 253  : 	for(uint iI = 0; iI < uiNumEntries; iI++)

	mov	DWORD PTR _iI$227996[ebp], 0
	jmp	SHORT $LN7@ReadHashed@2
$LN6@ReadHashed@2:
	mov	ecx, DWORD PTR _iI$227996[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$227996[ebp], ecx
$LN7@ReadHashed@2:
	mov	edx, DWORD PTR _iI$227996[ebp]
	cmp	edx, DWORD PTR _uiNumEntries$[ebp]
	jae	SHORT $LN8@ReadHashed@2

; 254  : 	{
; 255  : 		bool bValid;
; 256  : 		int iType = ReadHashed(kStream, &bValid);

	lea	eax, DWORD PTR _bValid$228000[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	add	esp, 8
	mov	DWORD PTR _iType$228001[ebp], eax

; 257  : 		if(iType != -1)

	cmp	DWORD PTR _iType$228001[ebp], -1
	je	SHORT $LN4@ReadHashed@2

; 258  : 		{
; 259  : 			TData tValue;
; 260  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$228003[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 261  : 			if((int)iType < iArraySize)

	mov	eax, DWORD PTR _iType$228001[ebp]
	cmp	eax, DWORD PTR _iArraySize$[ebp]
	jge	SHORT $LN3@ReadHashed@2

; 262  : 				paArray[iType] = tValue;

	mov	ecx, DWORD PTR _paArray$[ebp]
	add	ecx, DWORD PTR _iType$228001[ebp]
	mov	dl, BYTE PTR _tValue$228003[ebp]
	mov	BYTE PTR [ecx], dl
$LN3@ReadHashed@2:

; 263  : 		}

	jmp	SHORT $LN2@ReadHashed@2
$LN4@ReadHashed@2:

; 264  : 		else if(!bValid)

	movzx	eax, BYTE PTR _bValid$228000[ebp]
	test	eax, eax
	jne	SHORT $LN2@ReadHashed@2

; 265  : 		{
; 266  : 			TData tValue;
; 267  : 			kStream >> tValue;

	lea	ecx, DWORD PTR _tValue$228008[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read
$LN2@ReadHashed@2:

; 268  : 		}
; 269  : 	}

	jmp	SHORT $LN6@ReadHashed@2
$LN8@ReadHashed@2:

; 270  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z ENDP ; CvInfosSerializationHelper::ReadHashedDataArray<bool>
_TEXT	ENDS
PUBLIC	?resize@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEXIW4ResourceTypes@@@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::resize
; Function compile flags: /Odtp
;	COMDAT ??$ReadHashedTypeArray@W4ResourceTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@AAV?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@@Z
_TEXT	SEGMENT
$T242148 = -128						; size = 4
$T242144 = -124						; size = 4
_iI$228012 = -8						; size = 4
_uiNumEntries$ = -4					; size = 4
_kStream$ = 8						; size = 4
_aArray$ = 12						; size = 4
??$ReadHashedTypeArray@W4ResourceTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@AAV?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@@Z PROC ; CvInfosSerializationHelper::ReadHashedTypeArray<enum ResourceTypes>, COMDAT

; 438  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H

; 439  : 	uint uiNumEntries;
; 440  : 
; 441  : 	kStream >> uiNumEntries;

	lea	eax, DWORD PTR _uiNumEntries$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 442  : 
; 443  : 	if(aArray.size() < uiNumEntries)

	mov	ecx, DWORD PTR _aArray$[ebp]
	mov	edx, DWORD PTR _aArray$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	cmp	eax, DWORD PTR _uiNumEntries$[ebp]
	jae	SHORT $LN4@ReadHashed@3

; 444  : 		aArray.resize(uiNumEntries);

	mov	ecx, DWORD PTR _uiNumEntries$[ebp]
	mov	DWORD PTR $T242144[ebp], ecx
	push	0
	mov	edx, DWORD PTR $T242144[ebp]
	push	edx
	mov	ecx, DWORD PTR _aArray$[ebp]
	call	?resize@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEXIW4ResourceTypes@@@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::resize
$LN4@ReadHashed@3:

; 445  : 
; 446  : 	for(uint iI = 0; iI < uiNumEntries; iI++)

	mov	DWORD PTR _iI$228012[ebp], 0
	jmp	SHORT $LN3@ReadHashed@3
$LN2@ReadHashed@3:
	mov	eax, DWORD PTR _iI$228012[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$228012[ebp], eax
$LN3@ReadHashed@3:
	mov	ecx, DWORD PTR _iI$228012[ebp]
	cmp	ecx, DWORD PTR _uiNumEntries$[ebp]
	jae	SHORT $LN5@ReadHashed@3

; 447  : 	{
; 448  : 		aArray[iI] = (TType)ReadHashed(kStream);

	mov	edx, DWORD PTR _aArray$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _iI$228012[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T242148[ebp], edx
	push	0
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	add	esp, 8
	mov	ecx, DWORD PTR $T242148[ebp]
	mov	DWORD PTR [ecx], eax

; 449  : 	}

	jmp	SHORT $LN2@ReadHashed@3
$LN5@ReadHashed@3:

; 450  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$ReadHashedTypeArray@W4ResourceTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@AAV?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@@Z ENDP ; CvInfosSerializationHelper::ReadHashedTypeArray<enum ResourceTypes>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fdatastream.h
_TEXT	ENDS
;	COMDAT ??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapperConst@H@@@Z
_TEXT	SEGMENT
_i$ = -12						; size = 4
_values$ = -8						; size = 4
_count$ = -4						; size = 4
_saveTo$ = 8						; size = 4
_v$ = 12						; size = 4
??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapperConst@H@@@Z PROC ; operator<<<int>, COMDAT

; 528  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 529  : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 530  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _count$[ebp], ecx

; 531  : 	const ValueType * values = v.getArray();

	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _values$[ebp], eax

; 532  : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@operator@3
$LN2@operator@3:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN3@operator@3:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _count$[ebp]
	jge	SHORT $LN1@operator@3

; 533  : 	{
; 534  : 		saveTo << values[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _values$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 535  : 	}

	jmp	SHORT $LN2@operator@3
$LN1@operator@3:

; 536  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 537  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapperConst@H@@@Z ENDP ; operator<<<int>
_TEXT	ENDS
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4VoteSourceTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvinfosserializationhelper.h
;	COMDAT ??$WriteHashedDataArray@W4VoteSourceTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z
_TEXT	SEGMENT
_eType$228029 = -8					; size = 4
_iI$228025 = -4						; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4VoteSourceTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum VoteSourceTypes,int>, COMDAT

; 559  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 560  : 	kStream << uiArraySize;

	lea	eax, DWORD PTR _uiArraySize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	mov	DWORD PTR _iI$228025[ebp], 0
	jmp	SHORT $LN4@WriteHashe
$LN3@WriteHashe:
	mov	ecx, DWORD PTR _iI$228025[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$228025[ebp], ecx
$LN4@WriteHashe:
	mov	edx, DWORD PTR _iI$228025[ebp]
	cmp	edx, DWORD PTR _uiArraySize$[ebp]
	jae	SHORT $LN5@WriteHashe

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);

	mov	eax, DWORD PTR _iI$228025[ebp]
	mov	DWORD PTR _eType$228029[ebp], eax

; 565  : 		if(WriteHashed(kStream, eType))

	mov	ecx, DWORD PTR _eType$228029[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4VoteSourceTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@WriteHashe

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	mov	ecx, DWORD PTR _iI$228025[ebp]
	mov	edx, DWORD PTR _paArray$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
$LN1@WriteHashe:

; 568  : 		}
; 569  : 	}

	jmp	SHORT $LN3@WriteHashe
$LN5@WriteHashe:

; 570  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$WriteHashedDataArray@W4VoteSourceTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum VoteSourceTypes,int>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fdatastream.h
_TEXT	ENDS
;	COMDAT ??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapperConst@_N@@@Z
_TEXT	SEGMENT
_i$ = -12						; size = 4
_values$ = -8						; size = 4
_count$ = -4						; size = 4
_saveTo$ = 8						; size = 4
_v$ = 12						; size = 4
??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapperConst@_N@@@Z PROC ; operator<<<bool>, COMDAT

; 528  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 529  : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 530  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _count$[ebp], ecx

; 531  : 	const ValueType * values = v.getArray();

	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _values$[ebp], eax

; 532  : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@operator@4
$LN2@operator@4:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN3@operator@4:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _count$[ebp]
	jge	SHORT $LN1@operator@4

; 533  : 	{
; 534  : 		saveTo << values[i];

	mov	eax, DWORD PTR _values$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 535  : 	}

	jmp	SHORT $LN2@operator@4
$LN1@operator@4:

; 536  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 537  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapperConst@_N@@@Z ENDP ; operator<<<bool>
_TEXT	ENDS
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4VictoryTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvinfosserializationhelper.h
;	COMDAT ??$WriteHashedDataArray@W4VictoryTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z
_TEXT	SEGMENT
_eType$228044 = -8					; size = 4
_iI$228040 = -4						; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4VictoryTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum VictoryTypes,bool>, COMDAT

; 559  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 560  : 	kStream << uiArraySize;

	lea	eax, DWORD PTR _uiArraySize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	mov	DWORD PTR _iI$228040[ebp], 0
	jmp	SHORT $LN4@WriteHashe@2
$LN3@WriteHashe@2:
	mov	ecx, DWORD PTR _iI$228040[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$228040[ebp], ecx
$LN4@WriteHashe@2:
	mov	edx, DWORD PTR _iI$228040[ebp]
	cmp	edx, DWORD PTR _uiArraySize$[ebp]
	jae	SHORT $LN5@WriteHashe@2

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);

	mov	eax, DWORD PTR _iI$228040[ebp]
	mov	DWORD PTR _eType$228044[ebp], eax

; 565  : 		if(WriteHashed(kStream, eType))

	mov	ecx, DWORD PTR _eType$228044[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4VictoryTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@WriteHashe@2

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	mov	ecx, DWORD PTR _paArray$[ebp]
	add	ecx, DWORD PTR _iI$228040[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
$LN1@WriteHashe@2:

; 568  : 		}
; 569  : 	}

	jmp	SHORT $LN3@WriteHashe@2
$LN5@WriteHashe@2:

; 570  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$WriteHashedDataArray@W4VictoryTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum VictoryTypes,bool>
_TEXT	ENDS
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4SmallAwardTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
; Function compile flags: /Odtp
;	COMDAT ??$WriteHashedDataArray@W4SmallAwardTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z
_TEXT	SEGMENT
_eType$228052 = -8					; size = 4
_iI$228048 = -4						; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4SmallAwardTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum SmallAwardTypes,bool>, COMDAT

; 559  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 560  : 	kStream << uiArraySize;

	lea	eax, DWORD PTR _uiArraySize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	mov	DWORD PTR _iI$228048[ebp], 0
	jmp	SHORT $LN4@WriteHashe@3
$LN3@WriteHashe@3:
	mov	ecx, DWORD PTR _iI$228048[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$228048[ebp], ecx
$LN4@WriteHashe@3:
	mov	edx, DWORD PTR _iI$228048[ebp]
	cmp	edx, DWORD PTR _uiArraySize$[ebp]
	jae	SHORT $LN5@WriteHashe@3

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);

	mov	eax, DWORD PTR _iI$228048[ebp]
	mov	DWORD PTR _eType$228052[ebp], eax

; 565  : 		if(WriteHashed(kStream, eType))

	mov	ecx, DWORD PTR _eType$228052[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4SmallAwardTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@WriteHashe@3

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	mov	ecx, DWORD PTR _paArray$[ebp]
	add	ecx, DWORD PTR _iI$228048[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
$LN1@WriteHashe@3:

; 568  : 		}
; 569  : 	}

	jmp	SHORT $LN3@WriteHashe@3
$LN5@WriteHashe@3:

; 570  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$WriteHashedDataArray@W4SmallAwardTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum SmallAwardTypes,bool>
_TEXT	ENDS
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4RouteTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
; Function compile flags: /Odtp
;	COMDAT ??$WriteHashedDataArray@W4RouteTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z
_TEXT	SEGMENT
_eType$228060 = -8					; size = 4
_iI$228056 = -4						; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4RouteTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum RouteTypes,int>, COMDAT

; 559  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 560  : 	kStream << uiArraySize;

	lea	eax, DWORD PTR _uiArraySize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	mov	DWORD PTR _iI$228056[ebp], 0
	jmp	SHORT $LN4@WriteHashe@4
$LN3@WriteHashe@4:
	mov	ecx, DWORD PTR _iI$228056[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$228056[ebp], ecx
$LN4@WriteHashe@4:
	mov	edx, DWORD PTR _iI$228056[ebp]
	cmp	edx, DWORD PTR _uiArraySize$[ebp]
	jae	SHORT $LN5@WriteHashe@4

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);

	mov	eax, DWORD PTR _iI$228056[ebp]
	mov	DWORD PTR _eType$228060[ebp], eax

; 565  : 		if(WriteHashed(kStream, eType))

	mov	ecx, DWORD PTR _eType$228060[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4RouteTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@WriteHashe@4

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	mov	ecx, DWORD PTR _iI$228056[ebp]
	mov	edx, DWORD PTR _paArray$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
$LN1@WriteHashe@4:

; 568  : 		}
; 569  : 	}

	jmp	SHORT $LN3@WriteHashe@4
$LN5@WriteHashe@4:

; 570  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$WriteHashedDataArray@W4RouteTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum RouteTypes,int>
_TEXT	ENDS
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4BuildTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
; Function compile flags: /Odtp
;	COMDAT ??$WriteHashedDataArray@W4BuildTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z
_TEXT	SEGMENT
_eType$228068 = -8					; size = 4
_iI$228064 = -4						; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4BuildTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum BuildTypes,int>, COMDAT

; 559  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 560  : 	kStream << uiArraySize;

	lea	eax, DWORD PTR _uiArraySize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	mov	DWORD PTR _iI$228064[ebp], 0
	jmp	SHORT $LN4@WriteHashe@5
$LN3@WriteHashe@5:
	mov	ecx, DWORD PTR _iI$228064[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$228064[ebp], ecx
$LN4@WriteHashe@5:
	mov	edx, DWORD PTR _iI$228064[ebp]
	cmp	edx, DWORD PTR _uiArraySize$[ebp]
	jae	SHORT $LN5@WriteHashe@5

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);

	mov	eax, DWORD PTR _iI$228064[ebp]
	mov	DWORD PTR _eType$228068[ebp], eax

; 565  : 		if(WriteHashed(kStream, eType))

	mov	ecx, DWORD PTR _eType$228068[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4BuildTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@WriteHashe@5

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	mov	ecx, DWORD PTR _iI$228064[ebp]
	mov	edx, DWORD PTR _paArray$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
$LN1@WriteHashe@5:

; 568  : 		}
; 569  : 	}

	jmp	SHORT $LN3@WriteHashe@5
$LN5@WriteHashe@5:

; 570  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$WriteHashedDataArray@W4BuildTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum BuildTypes,int>
_TEXT	ENDS
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4ProjectTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
; Function compile flags: /Odtp
;	COMDAT ??$WriteHashedDataArray@W4ProjectTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z
_TEXT	SEGMENT
_eType$228076 = -8					; size = 4
_iI$228072 = -4						; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4ProjectTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum ProjectTypes,int>, COMDAT

; 559  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 560  : 	kStream << uiArraySize;

	lea	eax, DWORD PTR _uiArraySize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	mov	DWORD PTR _iI$228072[ebp], 0
	jmp	SHORT $LN4@WriteHashe@6
$LN3@WriteHashe@6:
	mov	ecx, DWORD PTR _iI$228072[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$228072[ebp], ecx
$LN4@WriteHashe@6:
	mov	edx, DWORD PTR _iI$228072[ebp]
	cmp	edx, DWORD PTR _uiArraySize$[ebp]
	jae	SHORT $LN5@WriteHashe@6

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);

	mov	eax, DWORD PTR _iI$228072[ebp]
	mov	DWORD PTR _eType$228076[ebp], eax

; 565  : 		if(WriteHashed(kStream, eType))

	mov	ecx, DWORD PTR _eType$228076[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4ProjectTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@WriteHashe@6

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	mov	ecx, DWORD PTR _iI$228072[ebp]
	mov	edx, DWORD PTR _paArray$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
$LN1@WriteHashe@6:

; 568  : 		}
; 569  : 	}

	jmp	SHORT $LN3@WriteHashe@6
$LN5@WriteHashe@6:

; 570  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$WriteHashedDataArray@W4ProjectTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum ProjectTypes,int>
_TEXT	ENDS
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4TerrainTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
; Function compile flags: /Odtp
;	COMDAT ??$WriteHashedDataArray@W4TerrainTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z
_TEXT	SEGMENT
_eType$228084 = -8					; size = 4
_iI$228080 = -4						; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4TerrainTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum TerrainTypes,int>, COMDAT

; 559  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 560  : 	kStream << uiArraySize;

	lea	eax, DWORD PTR _uiArraySize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	mov	DWORD PTR _iI$228080[ebp], 0
	jmp	SHORT $LN4@WriteHashe@7
$LN3@WriteHashe@7:
	mov	ecx, DWORD PTR _iI$228080[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$228080[ebp], ecx
$LN4@WriteHashe@7:
	mov	edx, DWORD PTR _iI$228080[ebp]
	cmp	edx, DWORD PTR _uiArraySize$[ebp]
	jae	SHORT $LN5@WriteHashe@7

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);

	mov	eax, DWORD PTR _iI$228080[ebp]
	mov	DWORD PTR _eType$228084[ebp], eax

; 565  : 		if(WriteHashed(kStream, eType))

	mov	ecx, DWORD PTR _eType$228084[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4TerrainTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@WriteHashe@7

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	mov	ecx, DWORD PTR _iI$228080[ebp]
	mov	edx, DWORD PTR _paArray$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
$LN1@WriteHashe@7:

; 568  : 		}
; 569  : 	}

	jmp	SHORT $LN3@WriteHashe@7
$LN5@WriteHashe@7:

; 570  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$WriteHashedDataArray@W4TerrainTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum TerrainTypes,int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$WriteHashedDataArray@W4VictoryTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z
_TEXT	SEGMENT
_eType$228092 = -8					; size = 4
_iI$228088 = -4						; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4VictoryTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum VictoryTypes,int>, COMDAT

; 559  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 560  : 	kStream << uiArraySize;

	lea	eax, DWORD PTR _uiArraySize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	mov	DWORD PTR _iI$228088[ebp], 0
	jmp	SHORT $LN4@WriteHashe@8
$LN3@WriteHashe@8:
	mov	ecx, DWORD PTR _iI$228088[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$228088[ebp], ecx
$LN4@WriteHashe@8:
	mov	edx, DWORD PTR _iI$228088[ebp]
	cmp	edx, DWORD PTR _uiArraySize$[ebp]
	jae	SHORT $LN5@WriteHashe@8

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);

	mov	eax, DWORD PTR _iI$228088[ebp]
	mov	DWORD PTR _eType$228092[ebp], eax

; 565  : 		if(WriteHashed(kStream, eType))

	mov	ecx, DWORD PTR _eType$228092[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4VictoryTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@WriteHashe@8

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	mov	ecx, DWORD PTR _iI$228088[ebp]
	mov	edx, DWORD PTR _paArray$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
$LN1@WriteHashe@8:

; 568  : 		}
; 569  : 	}

	jmp	SHORT $LN3@WriteHashe@8
$LN5@WriteHashe@8:

; 570  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$WriteHashedDataArray@W4VictoryTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum VictoryTypes,int>
_TEXT	ENDS
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4ResourceTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
; Function compile flags: /Odtp
;	COMDAT ??$WriteHashedTypeArray@W4ResourceTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@ABV?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@@Z
_TEXT	SEGMENT
$T242237 = -8						; size = 4
_iI$228097 = -4						; size = 4
_kStream$ = 8						; size = 4
_aiArray$ = 12						; size = 4
??$WriteHashedTypeArray@W4ResourceTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@ABV?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@@Z PROC ; CvInfosSerializationHelper::WriteHashedTypeArray<enum ResourceTypes>, COMDAT

; 661  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 662  : 	kStream << aiArray.size();

	mov	eax, DWORD PTR _aiArray$[ebp]
	mov	ecx, DWORD PTR _aiArray$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T242237[ebp], edx
	lea	eax, DWORD PTR $T242237[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 663  : 
; 664  : 	for(uint iI = 0; iI < aiArray.size(); iI++)

	mov	DWORD PTR _iI$228097[ebp], 0
	jmp	SHORT $LN10@WriteHashe@9
$LN2@WriteHashe@9:
	mov	ecx, DWORD PTR _iI$228097[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$228097[ebp], ecx
$LN10@WriteHashe@9:
	mov	edx, DWORD PTR _aiArray$[ebp]
	mov	eax, DWORD PTR _aiArray$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	cmp	DWORD PTR _iI$228097[ebp], ecx
	jae	SHORT $LN4@WriteHashe@9

; 665  : 	{
; 666  : 		WriteHashed(kStream, aiArray[iI]);

	mov	edx, DWORD PTR _aiArray$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _iI$228097[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4ResourceTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8

; 667  : 	}

	jmp	SHORT $LN2@WriteHashe@9
$LN4@WriteHashe@9:

; 668  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$WriteHashedTypeArray@W4ResourceTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@ABV?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@@Z ENDP ; CvInfosSerializationHelper::WriteHashedTypeArray<enum ResourceTypes>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R0?AVbad_alloc@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
xdata$x	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_Ebad_alloc@std@@UAEPAXI@Z ; std::bad_alloc::`vftable'
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
CONST	ENDS
;	COMDAT ??$_Allocate@W4ResourceTypes@@@std@@YAPAW4ResourceTypes@@IPAW41@@Z
_TEXT	SEGMENT
$T242256 = -16						; size = 4
$T242252 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@W4ResourceTypes@@@std@@YAPAW4ResourceTypes@@IPAW41@@Z PROC ; std::_Allocate<enum ResourceTypes>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T242256[ebp], 0
	lea	eax, DWORD PTR $T242256[ebp]
	push	eax
	lea	ecx, DWORD PTR $T242252[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T242252[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T242252[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@W4ResourceTypes@@@std@@YAPAW4ResourceTypes@@IPAW41@@Z ENDP ; std::_Allocate<enum ResourceTypes>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar@3
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?resize@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEXIW4ResourceTypes@@@Z
_TEXT	SEGMENT
_this$ = -116						; size = 4
__Tmp$242341 = -48					; size = 4
$T242324 = -44						; size = 4
$T242308 = -40						; size = 4
$T242286 = -36						; size = 4
$T242273 = -32						; size = 4
$T242272 = -28						; size = 4
$T242271 = -24						; size = 4
$T242270 = -20						; size = 4
$T242269 = -16						; size = 4
$T242268 = -12						; size = 4
$T242267 = -8						; size = 4
$T242266 = -4						; size = 4
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
?resize@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEXIW4ResourceTypes@@@Z PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::resize, COMDAT
; _this$ = ecx

; 717  : 		{	// determine new length, padding with _Val elements as needed

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	DWORD PTR _this$[ebp], ecx

; 718  : 		if (size() < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	edx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN16@resize

; 719  : 			_Insert_n(end(), _Newsize - size(), _Val);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T242286[ebp], ecx
	mov	edx, DWORD PTR $T242286[ebp]
	mov	DWORD PTR $T242267[ebp], edx
	mov	eax, DWORD PTR $T242267[ebp]
	mov	DWORD PTR $T242266[ebp], eax
	lea	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	edx, DWORD PTR __Newsize$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR $T242266[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Insert_n
	jmp	SHORT $LN4@resize

; 720  : 		else if (_Newsize < size())

$LN16@resize:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	cmp	DWORD PTR __Newsize$[ebp], eax
	jae	SHORT $LN4@resize

; 721  : 			erase(begin() + _Newsize, end());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T242308[ebp], edx
	mov	eax, DWORD PTR $T242308[ebp]
	mov	DWORD PTR $T242269[ebp], eax
	mov	ecx, DWORD PTR $T242269[ebp]
	mov	DWORD PTR $T242268[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T242324[ebp], eax
	mov	ecx, DWORD PTR $T242324[ebp]
	mov	DWORD PTR $T242271[ebp], ecx
	mov	edx, DWORD PTR $T242271[ebp]
	mov	DWORD PTR __Tmp$242341[ebp], edx
	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	ecx, DWORD PTR __Tmp$242341[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Tmp$242341[ebp], edx
	mov	eax, DWORD PTR __Tmp$242341[ebp]
	mov	DWORD PTR $T242272[ebp], eax
	mov	ecx, DWORD PTR $T242272[ebp]
	mov	DWORD PTR $T242270[ebp], ecx
	mov	edx, DWORD PTR $T242268[ebp]
	push	edx
	mov	eax, DWORD PTR $T242270[ebp]
	push	eax
	lea	ecx, DWORD PTR $T242273[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@0@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::erase
$LN4@resize:

; 722  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?resize@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEXIW4ResourceTypes@@@Z ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::resize
_TEXT	ENDS
EXTRN	__imp_?PushArgument@String@Localization@@QAE_NH@Z:PROC
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvlocalization\include\cvlocalization.h
;	COMDAT ??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z PROC	; operator<<<int>, COMDAT

; 490  : {

	push	ebp
	mov	ebp, esp

; 491  : 	s.PushArgument(val);

	mov	eax, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _s$[ebp]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z

; 492  : 	return s;

	mov	eax, DWORD PTR _s$[ebp]

; 493  : }

	pop	ebp
	ret	0
??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z ENDP	; operator<<<int>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>
PUBLIC	??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z ; std::_Pop_heap_0<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>
PUBLIC	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,int,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>
PUBLIC	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Sort@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0H@Z
_TEXT	SEGMENT
$T242616 = -128						; size = 4
__Mid$228427 = -12					; size = 8
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
??$_Sort@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0H@Z PROC ; std::_Sort<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,int>, COMDAT

; 3082 : 	{	// order [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
$LN7@Sort:

; 3083 : 	_Diff _Count;
; 3084 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	mov	DWORD PTR __Count$[ebp], eax
	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jle	$LN6@Sort
	cmp	DWORD PTR __Ideal$[ebp], 0
	jle	SHORT $LN6@Sort

; 3085 : 		{	// divide and conquer by quicksort
; 3086 : 		pair<_RanIt, _RanIt> _Mid =
; 3087 : 			std::_Unguarded_partition(_First, _Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR __Mid$228427[ebp]
	push	eax
	call	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3088 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions

	mov	eax, DWORD PTR __Ideal$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Ideal$[ebp], eax
	mov	eax, DWORD PTR __Ideal$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR __Ideal$[ebp]
	mov	DWORD PTR __Ideal$[ebp], eax

; 3089 : 
; 3090 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	ecx, DWORD PTR __Mid$228427[ebp]
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 3
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __Mid$228427[ebp+4]
	sar	edx, 3
	cmp	ecx, edx
	jge	SHORT $LN5@Sort

; 3091 : 			{	// loop on second half
; 3092 : 			std::_Sort(_First, _Mid.first, _Ideal);

	mov	eax, DWORD PTR __Ideal$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$228427[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0H@Z ; std::_Sort<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3093 : 			_First = _Mid.second;

	mov	eax, DWORD PTR __Mid$228427[ebp+4]
	mov	DWORD PTR __First$[ebp], eax

; 3094 : 			}
; 3095 : 		else

	jmp	SHORT $LN4@Sort
$LN5@Sort:

; 3096 : 			{	// loop on first half
; 3097 : 			std::_Sort(_Mid.second, _Last, _Ideal);

	mov	ecx, DWORD PTR __Ideal$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$228427[ebp+4]
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0H@Z ; std::_Sort<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3098 : 			_Last = _Mid.first;

	mov	ecx, DWORD PTR __Mid$228427[ebp]
	mov	DWORD PTR __Last$[ebp], ecx
$LN4@Sort:

; 3099 : 			}
; 3100 : 		}

	jmp	$LN7@Sort
$LN6@Sort:

; 3101 : 
; 3102 : 	if (_ISORT_MAX < _Count)

	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jle	SHORT $LN3@Sort

; 3103 : 		{	// heap sort if too many divisions
; 3104 : 		std::make_heap(_First, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __First$[ebp]
	sar	edx, 3
	cmp	edx, 1
	jle	SHORT $LN76@Sort
	push	0
	push	0
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,int,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN76@Sort:

; 3105 : 		std::sort_heap(_First, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T242616[ebp], edx
	jmp	SHORT $LN92@Sort
$LN91@Sort:
	mov	eax, DWORD PTR $T242616[ebp]
	sub	eax, 8
	mov	DWORD PTR $T242616[ebp], eax
$LN92@Sort:
	mov	ecx, DWORD PTR $T242616[ebp]
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 3
	cmp	ecx, 1
	jle	SHORT $LN88@Sort
	mov	edx, DWORD PTR $T242616[ebp]
	sub	edx, DWORD PTR __First$[ebp]
	sar	edx, 3
	cmp	edx, 1
	jle	SHORT $LN96@Sort
	push	0
	mov	eax, DWORD PTR $T242616[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z ; std::_Pop_heap_0<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>
	add	esp, 12					; 0000000cH
$LN96@Sort:
	jmp	SHORT $LN91@Sort
$LN88@Sort:

; 3106 : 		}
; 3107 : 	else if (1 < _Count)

	jmp	SHORT $LN8@Sort
$LN3@Sort:
	cmp	DWORD PTR __Count$[ebp], 1
	jle	SHORT $LN8@Sort

; 3108 : 		std::_Insertion_sort(_First, _Last);	// small

	push	0
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>
	add	esp, 12					; 0000000cH
$LN8@Sort:

; 3109 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Sort@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0H@Z ENDP ; std::_Sort<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,int>
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAW4ResourceTypes@@IW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAXPAW4ResourceTypes@@IABW41@AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAW4ResourceTypes@@IW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAXPAW4ResourceTypes@@IABW41@AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAW4ResourceTypes@@IW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAXPAW4ResourceTypes@@IABW41@AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAW4ResourceTypes@@IW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAXPAW4ResourceTypes@@IABW41@AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAW4ResourceTypes@@IW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAXPAW4ResourceTypes@@IABW41@AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_fill_n@PAW4ResourceTypes@@IW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAXPAW4ResourceTypes@@IABW41@AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAW4ResourceTypes@@IW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAXPAW4ResourceTypes@@IABW41@AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAW4ResourceTypes@@IW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAXPAW4ResourceTypes@@IABW41@AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAW4ResourceTypes@@IW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAXPAW4ResourceTypes@@IABW41@AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv83 = -32						; size = 4
$T242710 = -28						; size = 4
__Vptr$242716 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAW4ResourceTypes@@IW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAXPAW4ResourceTypes@@IABW41@AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<enum ResourceTypes *,unsigned int,enum ResourceTypes,std::allocator<enum ResourceTypes> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAW4ResourceTypes@@IW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAXPAW4ResourceTypes@@IABW41@AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil
$LN5@Uninit_fil:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 4
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Vptr$242716[ebp], eax
	mov	ecx, DWORD PTR __Vptr$242716[ebp]
	mov	DWORD PTR $T242710[ebp], ecx
	cmp	DWORD PTR $T242710[ebp], 0
	je	SHORT $LN18@Uninit_fil
	mov	edx, DWORD PTR $T242710[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T242710[ebp]
	mov	DWORD PTR tv83[ebp], edx
	jmp	SHORT $LN14@Uninit_fil
$LN18@Uninit_fil:
	mov	DWORD PTR tv83[ebp], 0
$LN14@Uninit_fil:
	jmp	SHORT $LN5@Uninit_fil
$LN4@Uninit_fil:
	jmp	SHORT $LN10@Uninit_fil
__catch$??$_Uninit_fill_n@PAW4ResourceTypes@@IW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAXPAW4ResourceTypes@@IABW41@AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil
$LN2@Uninit_fil:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 4
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_fil:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil

; 407  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_fil
$LN1@Uninit_fil:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil
	ret	0
$LN10@Uninit_fil:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAW4ResourceTypes@@IW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAXPAW4ResourceTypes@@IABW41@AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAW4ResourceTypes@@IW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAXPAW4ResourceTypes@@IABW41@AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAW4ResourceTypes@@IW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAXPAW4ResourceTypes@@IABW41@AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<enum ResourceTypes *,unsigned int,enum ResourceTypes,std::allocator<enum ResourceTypes> >
PUBLIC	??$_Median@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z ; std::_Median<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z
_TEXT	SEGMENT
$T242908 = -124						; size = 4
__Tmp$242906 = -120					; size = 8
$T242888 = -112						; size = 4
$T242887 = -108						; size = 4
__Tmp$242885 = -104					; size = 8
$T242867 = -96						; size = 4
__Tmp$242865 = -92					; size = 8
$T242847 = -84						; size = 4
$T242846 = -80						; size = 4
__Tmp$242844 = -76					; size = 8
$T242826 = -68						; size = 4
$T242825 = -64						; size = 4
__Tmp$242823 = -60					; size = 8
$T242802 = -52						; size = 4
$T242801 = -48						; size = 4
__Tmp$242799 = -44					; size = 8
$T242775 = -36						; size = 4
__Tmp$242773 = -32					; size = 8
__Plast$ = -20						; size = 4
__Glast$ = -16						; size = 4
__Pfirst$ = -12						; size = 4
__Gfirst$ = -8						; size = 4
__Mid$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z PROC ; std::_Unguarded_partition<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>, COMDAT

; 3024 : 	{	// partition [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH

; 3025 : 	_RanIt _Mid = _First + (_Last - _First) / 2;	// sort median to _Mid

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Mid$[ebp], edx

; 3026 : 	std::_Median(_First, _Mid, _Last - 1);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Median@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z ; std::_Median<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3027 : 	_RanIt _Pfirst = _Mid;

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Pfirst$[ebp], eax

; 3028 : 	_RanIt _Plast = _Pfirst + 1;

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Plast$[ebp], ecx
$LN27@Unguarded_:

; 3029 : 
; 3030 : 	while (_First < _Pfirst
; 3031 : 		&& !_DEBUG_LT(*(_Pfirst - 1), *_Pfirst)
; 3032 : 		&& !(*_Pfirst < *(_Pfirst - 1)))

	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Pfirst$[ebp]
	jae	SHORT $LN25@Unguarded_
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	edx, DWORD PTR [eax-4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN25@Unguarded_
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax-4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN25@Unguarded_

; 3033 : 		--_Pfirst;

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	sub	ecx, 8
	mov	DWORD PTR __Pfirst$[ebp], ecx
	jmp	SHORT $LN27@Unguarded_
$LN25@Unguarded_:

; 3034 : 	while (_Plast < _Last
; 3035 : 		&& !_DEBUG_LT(*_Plast, *_Pfirst)
; 3036 : 		&& !(*_Pfirst < *_Plast))

	mov	edx, DWORD PTR __Plast$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	jae	SHORT $LN24@Unguarded_
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN24@Unguarded_
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN24@Unguarded_

; 3037 : 		++_Plast;

	mov	ecx, DWORD PTR __Plast$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Plast$[ebp], ecx
	jmp	SHORT $LN25@Unguarded_
$LN24@Unguarded_:

; 3038 : 
; 3039 : 	_RanIt _Gfirst = _Plast;

	mov	edx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR __Gfirst$[ebp], edx

; 3040 : 	_RanIt _Glast = _Pfirst;

	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR __Glast$[ebp], eax
$LN23@Unguarded_:

; 3041 : 
; 3042 : 	for (; ; )
; 3043 : 		{	// partition
; 3044 : 		for (; _Gfirst < _Last; ++_Gfirst)

	jmp	SHORT $LN21@Unguarded_
$LN20@Unguarded_:
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Gfirst$[ebp], ecx
$LN21@Unguarded_:
	mov	edx, DWORD PTR __Gfirst$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	jae	$LN19@Unguarded_

; 3045 : 			if (_DEBUG_LT(*_Pfirst, *_Gfirst))

	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN44@Unguarded_
	jmp	SHORT $LN17@Unguarded_

; 3046 : 				;
; 3047 : 			else if (*_Gfirst < *_Pfirst)

$LN44@Unguarded_:
	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN16@Unguarded_

; 3048 : 				break;

	jmp	SHORT $LN19@Unguarded_

; 3049 : 			else

	jmp	SHORT $LN17@Unguarded_
$LN16@Unguarded_:

; 3050 : 				std::iter_swap(_Plast++, _Gfirst);

	mov	ecx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T242775[ebp], ecx
	mov	edx, DWORD PTR __Plast$[ebp]
	add	edx, 8
	mov	DWORD PTR __Plast$[ebp], edx
	mov	eax, DWORD PTR $T242775[ebp]
	cmp	eax, DWORD PTR __Gfirst$[ebp]
	je	SHORT $LN17@Unguarded_
	mov	ecx, DWORD PTR $T242775[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$242773[ebp], edx
	mov	eax, DWORD PTR $T242775[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$242773[ebp+4], ecx
	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T242775[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR __Gfirst$[ebp]
	mov	ecx, DWORD PTR __Tmp$242773[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$242773[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN17@Unguarded_:
	jmp	$LN20@Unguarded_
$LN19@Unguarded_:

; 3051 : 		for (; _First < _Glast; --_Glast)

	jmp	SHORT $LN14@Unguarded_
$LN13@Unguarded_:
	mov	eax, DWORD PTR __Glast$[ebp]
	sub	eax, 8
	mov	DWORD PTR __Glast$[ebp], eax
$LN14@Unguarded_:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Glast$[ebp]
	jae	$LN12@Unguarded_

; 3052 : 			if (_DEBUG_LT(*(_Glast - 1), *_Pfirst))

	mov	edx, DWORD PTR __Glast$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR [edx-4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN55@Unguarded_
	jmp	SHORT $LN10@Unguarded_

; 3053 : 				;
; 3054 : 			else if (*_Pfirst < *(_Glast - 1))

$LN55@Unguarded_:
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	edx, DWORD PTR __Glast$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx-4]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN9@Unguarded_

; 3055 : 				break;

	jmp	SHORT $LN12@Unguarded_

; 3056 : 			else

	jmp	SHORT $LN10@Unguarded_
$LN9@Unguarded_:

; 3057 : 				std::iter_swap(--_Pfirst, _Glast - 1);

	mov	eax, DWORD PTR __Pfirst$[ebp]
	sub	eax, 8
	mov	DWORD PTR __Pfirst$[ebp], eax
	mov	ecx, DWORD PTR __Glast$[ebp]
	sub	ecx, 8
	mov	DWORD PTR $T242802[ebp], ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T242801[ebp], edx
	mov	eax, DWORD PTR $T242801[ebp]
	cmp	eax, DWORD PTR $T242802[ebp]
	je	SHORT $LN10@Unguarded_
	mov	ecx, DWORD PTR $T242801[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$242799[ebp], edx
	mov	eax, DWORD PTR $T242801[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$242799[ebp+4], ecx
	mov	edx, DWORD PTR $T242802[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T242801[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T242802[ebp]
	mov	ecx, DWORD PTR __Tmp$242799[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$242799[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN10@Unguarded_:
	jmp	$LN13@Unguarded_
$LN12@Unguarded_:

; 3058 : 		if (_Glast == _First && _Gfirst == _Last)

	mov	eax, DWORD PTR __Glast$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	jne	SHORT $LN7@Unguarded_
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	jne	SHORT $LN7@Unguarded_

; 3059 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN28@Unguarded_
$LN7@Unguarded_:

; 3060 : 
; 3061 : 		if (_Glast == _First)

	mov	eax, DWORD PTR __Glast$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	jne	$LN6@Unguarded_

; 3062 : 			{	// no room at bottom, rotate pivot upward
; 3063 : 			if (_Plast != _Gfirst)

	mov	ecx, DWORD PTR __Plast$[ebp]
	cmp	ecx, DWORD PTR __Gfirst$[ebp]
	je	SHORT $LN5@Unguarded_

; 3064 : 				std::iter_swap(_Pfirst, _Plast);

	mov	edx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T242826[ebp], edx
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T242825[ebp], eax
	mov	ecx, DWORD PTR $T242825[ebp]
	cmp	ecx, DWORD PTR $T242826[ebp]
	je	SHORT $LN5@Unguarded_
	mov	edx, DWORD PTR $T242825[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$242823[ebp], eax
	mov	ecx, DWORD PTR $T242825[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$242823[ebp+4], edx
	mov	eax, DWORD PTR $T242826[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T242825[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR $T242826[ebp]
	mov	edx, DWORD PTR __Tmp$242823[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$242823[ebp+4]
	mov	DWORD PTR [ecx+4], eax
$LN5@Unguarded_:

; 3065 : 			++_Plast;

	mov	ecx, DWORD PTR __Plast$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Plast$[ebp], ecx

; 3066 : 			std::iter_swap(_Pfirst++, _Gfirst++);

	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR $T242847[ebp], edx
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T242846[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Pfirst$[ebp], ecx
	mov	edx, DWORD PTR __Gfirst$[ebp]
	add	edx, 8
	mov	DWORD PTR __Gfirst$[ebp], edx
	mov	eax, DWORD PTR $T242846[ebp]
	cmp	eax, DWORD PTR $T242847[ebp]
	je	SHORT $LN73@Unguarded_
	mov	ecx, DWORD PTR $T242846[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$242844[ebp], edx
	mov	eax, DWORD PTR $T242846[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$242844[ebp+4], ecx
	mov	edx, DWORD PTR $T242847[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T242846[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T242847[ebp]
	mov	ecx, DWORD PTR __Tmp$242844[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$242844[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN73@Unguarded_:

; 3067 : 			}
; 3068 : 		else if (_Gfirst == _Last)

	jmp	$LN4@Unguarded_
$LN6@Unguarded_:
	mov	eax, DWORD PTR __Gfirst$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	jne	$LN3@Unguarded_

; 3069 : 			{	// no room at top, rotate pivot downward
; 3070 : 			if (--_Glast != --_Pfirst)

	mov	ecx, DWORD PTR __Glast$[ebp]
	sub	ecx, 8
	mov	DWORD PTR __Glast$[ebp], ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Pfirst$[ebp], edx
	mov	eax, DWORD PTR __Glast$[ebp]
	cmp	eax, DWORD PTR __Pfirst$[ebp]
	je	SHORT $LN2@Unguarded_

; 3071 : 				std::iter_swap(_Glast, _Pfirst);

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T242867[ebp], ecx
	mov	edx, DWORD PTR __Glast$[ebp]
	cmp	edx, DWORD PTR $T242867[ebp]
	je	SHORT $LN2@Unguarded_
	mov	eax, DWORD PTR __Glast$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$242865[ebp], ecx
	mov	edx, DWORD PTR __Glast$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$242865[ebp+4], eax
	mov	ecx, DWORD PTR $T242867[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Glast$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T242867[ebp]
	mov	eax, DWORD PTR __Tmp$242865[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$242865[ebp+4]
	mov	DWORD PTR [edx+4], ecx
$LN2@Unguarded_:

; 3072 : 			std::iter_swap(_Pfirst, --_Plast);

	mov	edx, DWORD PTR __Plast$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Plast$[ebp], edx
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T242888[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T242887[ebp], ecx
	mov	edx, DWORD PTR $T242887[ebp]
	cmp	edx, DWORD PTR $T242888[ebp]
	je	SHORT $LN87@Unguarded_
	mov	eax, DWORD PTR $T242887[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$242885[ebp], ecx
	mov	edx, DWORD PTR $T242887[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$242885[ebp+4], eax
	mov	ecx, DWORD PTR $T242888[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T242887[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T242888[ebp]
	mov	eax, DWORD PTR __Tmp$242885[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$242885[ebp+4]
	mov	DWORD PTR [edx+4], ecx
$LN87@Unguarded_:

; 3073 : 			}
; 3074 : 		else

	jmp	SHORT $LN4@Unguarded_
$LN3@Unguarded_:

; 3075 : 			std::iter_swap(_Gfirst++, --_Glast);

	mov	edx, DWORD PTR __Glast$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Glast$[ebp], edx
	mov	eax, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR $T242908[ebp], eax
	mov	ecx, DWORD PTR $T242908[ebp]
	cmp	ecx, DWORD PTR __Glast$[ebp]
	je	SHORT $LN94@Unguarded_
	mov	edx, DWORD PTR $T242908[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$242906[ebp], eax
	mov	ecx, DWORD PTR $T242908[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$242906[ebp+4], edx
	mov	eax, DWORD PTR __Glast$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T242908[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Glast$[ebp]
	mov	edx, DWORD PTR __Tmp$242906[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$242906[ebp+4]
	mov	DWORD PTR [ecx+4], eax
$LN94@Unguarded_:
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Gfirst$[ebp], ecx
$LN4@Unguarded_:

; 3076 : 		}

	jmp	$LN23@Unguarded_
$LN28@Unguarded_:

; 3077 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z ENDP ; std::_Unguarded_partition<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Med3@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z ; std::_Med3<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
; Function compile flags: /Odtp
;	COMDAT ??$_Median@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z
_TEXT	SEGMENT
__Step$228691 = -4					; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Median@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z PROC ; std::_Median<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>, COMDAT

; 3009 : 	{	// sort median element to middle

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH

; 3010 : 	if (40 < _Last - _First)

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	cmp	eax, 40					; 00000028H
	jle	$LN2@Median

; 3011 : 		{	// median of nine
; 3012 : 		size_t _Step = (_Last - _First + 1) / 8;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	add	eax, 1
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	DWORD PTR __Step$228691[ebp], eax

; 3013 : 		std::_Med3(_First, _First + _Step, _First + 2 * _Step);

	mov	ecx, DWORD PTR __Step$228691[ebp]
	shl	ecx, 1
	mov	edx, DWORD PTR __First$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	ecx, DWORD PTR __Step$228691[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z ; std::_Med3<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3014 : 		std::_Med3(_Mid - _Step, _Mid, _Mid + _Step);

	mov	edx, DWORD PTR __Step$228691[ebp]
	mov	eax, DWORD PTR __Mid$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR __Step$228691[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR __Mid$[ebp]
	sub	ecx, eax
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z ; std::_Med3<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3015 : 		std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Step$228691[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Step$228691[ebp]
	shl	edx, 1
	shl	edx, 3
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, edx
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z ; std::_Med3<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3016 : 		std::_Med3(_First + _Step, _Mid, _Last - _Step);

	mov	ecx, DWORD PTR __Step$228691[ebp]
	shl	ecx, 3
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Step$228691[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z ; std::_Med3<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3017 : 		}
; 3018 : 	else

	jmp	SHORT $LN3@Median
$LN2@Median:

; 3019 : 		std::_Med3(_First, _Mid, _Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z ; std::_Med3<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
	add	esp, 12					; 0000000cH
$LN3@Median:

; 3020 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Median@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z ENDP ; std::_Median<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,int,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>
; Function compile flags: /Odtp
;	COMDAT ??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0PAH0@Z
_TEXT	SEGMENT
$T243221 = -20						; size = 4
$T243220 = -16						; size = 4
__Hole$228709 = -8					; size = 4
__Bottom$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0PAH0@Z PROC ; std::_Make_heap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,int,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>, COMDAT

; 2164 : 	{	// make nontrivial [_First, _Last) into a heap, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 2165 : 	_Diff _Bottom = _Last - _First;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	mov	DWORD PTR __Bottom$[ebp], eax

; 2166 : 
; 2167 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

	mov	eax, DWORD PTR __Bottom$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Hole$228709[ebp], eax
$LN2@Make_heap:
	cmp	DWORD PTR __Hole$228709[ebp], 0
	jle	SHORT $LN3@Make_heap

; 2168 : 		{	// reheap top half, bottom to top
; 2169 : 		--_Hole;

	mov	ecx, DWORD PTR __Hole$228709[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Hole$228709[ebp], ecx

; 2170 : 		std::_Adjust_heap(_First, _Hole, _Bottom,
; 2171 : 			_Ty(*(_First + _Hole)));

	mov	edx, DWORD PTR __Hole$228709[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T243221[ebp], ecx
	sub	esp, 8
	mov	DWORD PTR $T243220[ebp], esp
	mov	edx, DWORD PTR $T243220[ebp]
	mov	eax, DWORD PTR $T243221[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T243220[ebp]
	mov	eax, DWORD PTR $T243221[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR __Bottom$[ebp]
	push	edx
	mov	eax, DWORD PTR __Hole$228709[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,int,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2172 : 		}

	jmp	SHORT $LN2@Make_heap
$LN3@Make_heap:

; 2173 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0PAH0@Z ENDP ; std::_Make_heap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,int,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z
_TEXT	SEGMENT
$T243291 = -52						; size = 4
$T243290 = -48						; size = 4
$T243274 = -42						; size = 1
$T243273 = -41						; size = 1
$T243272 = -40						; size = 4
$T243271 = -36						; size = 4
$T243270 = -32						; size = 4
__Cat$243282 = -24					; size = 1
$T243279 = -23						; size = 1
$T243278 = -22						; size = 1
$T243277 = -21						; size = 1
__First1$228750 = -20					; size = 4
__Val$228740 = -16					; size = 8
__Next1$228739 = -8					; size = 4
__Next$228735 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z PROC ; std::_Insertion_sort1<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>, COMDAT

; 2967 : 	{	// insertion sort [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 2968 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$228735[ebp], ecx
$LN7@Insertion_:
	mov	edx, DWORD PTR __Next$228735[ebp]
	add	edx, 8
	mov	DWORD PTR __Next$228735[ebp], edx
	mov	eax, DWORD PTR __Next$228735[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;

	mov	ecx, DWORD PTR __Next$228735[ebp]
	mov	DWORD PTR __Next1$228739[ebp], ecx

; 2972 : 			_Ty _Val = *_Next;

	mov	edx, DWORD PTR __Next$228735[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Val$228740[ebp], eax
	mov	ecx, DWORD PTR __Next$228735[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Val$228740[ebp+4], edx

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Val$228740[ebp+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN5@Insertion_

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	ecx, DWORD PTR __Next1$228739[ebp]
	add	ecx, 8
	mov	DWORD PTR __Next1$228739[ebp], ecx
	mov	edx, DWORD PTR __Next1$228739[ebp]
	mov	DWORD PTR $T243291[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T243290[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T243277[ebp], cl
	mov	dl, BYTE PTR __Cat$243282[ebp]
	mov	BYTE PTR $T243278[ebp], dl
	mov	al, BYTE PTR $T243277[ebp]
	mov	BYTE PTR $T243274[ebp], al
	mov	cl, BYTE PTR $T243279[ebp]
	mov	BYTE PTR $T243273[ebp], cl
	mov	edx, DWORD PTR $T243291[ebp]
	mov	DWORD PTR $T243272[ebp], edx
	mov	eax, DWORD PTR __Next$228735[ebp]
	mov	DWORD PTR $T243271[ebp], eax
	mov	ecx, DWORD PTR $T243290[ebp]
	mov	DWORD PTR $T243270[ebp], ecx
$LN22@Insertion_:
	mov	edx, DWORD PTR $T243270[ebp]
	cmp	edx, DWORD PTR $T243271[ebp]
	je	SHORT $LN15@Insertion_
	mov	eax, DWORD PTR $T243271[ebp]
	sub	eax, 8
	mov	DWORD PTR $T243271[ebp], eax
	mov	ecx, DWORD PTR $T243272[ebp]
	sub	ecx, 8
	mov	DWORD PTR $T243272[ebp], ecx
	mov	edx, DWORD PTR $T243271[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T243272[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN22@Insertion_
$LN15@Insertion_:

; 2977 : 				*_First = _Val;

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Val$228740[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Val$228740[ebp+4]
	mov	DWORD PTR [eax+4], edx

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_
$LN5@Insertion_:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;

	mov	eax, DWORD PTR __Next1$228739[ebp]
	mov	DWORD PTR __First1$228750[ebp], eax

; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	jmp	SHORT $LN3@Insertion_
$LN2@Insertion_:
	mov	ecx, DWORD PTR __First1$228750[ebp]
	mov	DWORD PTR __Next1$228739[ebp], ecx
$LN3@Insertion_:
	mov	edx, DWORD PTR __First1$228750[ebp]
	sub	edx, 8
	mov	DWORD PTR __First1$228750[ebp], edx
	mov	eax, DWORD PTR __First1$228750[ebp]
	mov	ecx, DWORD PTR __Val$228740[ebp+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN1@Insertion_

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	ecx, DWORD PTR __First1$228750[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Next1$228739[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN2@Insertion_
$LN1@Insertion_:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	edx, DWORD PTR __Next1$228739[ebp]
	mov	eax, DWORD PTR __Val$228740[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Val$228740[ebp+4]
	mov	DWORD PTR [edx+4], ecx
$LN4@Insertion_:

; 2986 : 				}
; 2987 : 			}

	jmp	$LN7@Insertion_
$LN9@Insertion_:

; 2988 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z ENDP ; std::_Insertion_sort1<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@stdext@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@std@@@Z
_TEXT	SEGMENT
__Cat$243301 = -3					; size = 1
$T243298 = -2						; size = 1
$T243297 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@stdext@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<enum ResourceTypes *,enum ResourceTypes *,std::allocator<enum ResourceTypes> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T243297[ebp], al
	mov	cl, BYTE PTR __Cat$243301[ebp]
	mov	BYTE PTR $T243298[ebp], cl
	movzx	edx, BYTE PTR $T243297[ebp]
	push	edx
	movzx	eax, BYTE PTR $T243298[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninit_copy@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum ResourceTypes *,enum ResourceTypes *,std::allocator<enum ResourceTypes> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@stdext@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<enum ResourceTypes *,enum ResourceTypes *,std::allocator<enum ResourceTypes> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
_TEXT	ENDS
;	COMDAT ??$_Med3@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z
_TEXT	SEGMENT
__Tmp$243367 = -24					; size = 8
__Tmp$243345 = -16					; size = 8
__Tmp$243323 = -8					; size = 8
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Med3@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z PROC ; std::_Med3<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>, COMDAT

; 2998 : 	{	// sort median of three elements to middle

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 2999 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN15@Med3

; 3000 : 		std::iter_swap(_Mid, _First);

	mov	edx, DWORD PTR __Mid$[ebp]
	cmp	edx, DWORD PTR __First$[ebp]
	je	SHORT $LN15@Med3
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$243323[ebp], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$243323[ebp+4], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Tmp$243323[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$243323[ebp+4]
	mov	DWORD PTR [edx+4], ecx

; 3001 : 	if (_DEBUG_LT(*_Last, *_Mid))

$LN15@Med3:
	mov	edx, DWORD PTR __Last$[ebp]
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN24@Med3

; 3002 : 		std::iter_swap(_Last, _Mid);

	mov	ecx, DWORD PTR __Last$[ebp]
	cmp	ecx, DWORD PTR __Mid$[ebp]
	je	SHORT $LN24@Med3
	mov	edx, DWORD PTR __Last$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$243345[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$243345[ebp+4], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR __Tmp$243345[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$243345[ebp+4]
	mov	DWORD PTR [ecx+4], eax

; 3003 : 	if (_DEBUG_LT(*_Mid, *_First))

$LN24@Med3:
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN4@Med3

; 3004 : 		std::iter_swap(_Mid, _First);

	mov	eax, DWORD PTR __Mid$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN4@Med3
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$243367[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$243367[ebp+4], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Tmp$243367[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$243367[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN4@Med3:

; 3005 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Med3@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z ENDP ; std::_Med3<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HHU12@@Z
_TEXT	SEGMENT
$T243394 = -32						; size = 4
$T243393 = -28						; size = 8
__Idx$243386 = -20					; size = 4
$T243380 = -16						; size = 4
__Idx$ = -8						; size = 4
__Top$ = -4						; size = 4
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HHU12@@Z PROC ; std::_Adjust_heap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,int,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>, COMDAT

; 2055 : 	{	// percolate _Hole to _Bottom, then push _Val, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi

; 2056 : 	_Diff _Top = _Hole;

	mov	eax, DWORD PTR __Hole$[ebp]
	mov	DWORD PTR __Top$[ebp], eax

; 2057 : 	_Diff _Idx = 2 * _Hole + 2;

	mov	ecx, DWORD PTR __Hole$[ebp]
	lea	edx, DWORD PTR [ecx+ecx+2]
	mov	DWORD PTR __Idx$[ebp], edx

; 2058 : 
; 2059 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	jmp	SHORT $LN5@Adjust_hea
$LN4@Adjust_hea:
	mov	eax, DWORD PTR __Idx$[ebp]
	lea	ecx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __Idx$[ebp], ecx
$LN5@Adjust_hea:
	mov	edx, DWORD PTR __Idx$[ebp]
	cmp	edx, DWORD PTR __Bottom$[ebp]
	jge	SHORT $LN3@Adjust_hea

; 2060 : 		{	// move _Hole down to larger child
; 2061 : 		if (_DEBUG_LT(*(_First + _Idx), *(_First + (_Idx - 1))))

	mov	eax, DWORD PTR __Idx$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR __Idx$[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [ecx+eax*8+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+edx*8-4]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@Adjust_hea

; 2062 : 			--_Idx;

	mov	eax, DWORD PTR __Idx$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Idx$[ebp], eax
$LN2@Adjust_hea:

; 2063 : 		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;

	mov	ecx, DWORD PTR __Idx$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR [edx+ecx*8+4]
	mov	edx, DWORD PTR __Hole$[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	DWORD PTR [esi+edx*8], eax
	mov	DWORD PTR [esi+edx*8+4], ecx
	mov	eax, DWORD PTR __Idx$[ebp]
	mov	DWORD PTR __Hole$[ebp], eax

; 2064 : 		}

	jmp	SHORT $LN4@Adjust_hea
$LN3@Adjust_hea:

; 2065 : 
; 2066 : 	if (_Idx == _Bottom)

	mov	ecx, DWORD PTR __Idx$[ebp]
	cmp	ecx, DWORD PTR __Bottom$[ebp]
	jne	SHORT $LN1@Adjust_hea

; 2067 : 		{	// only child at bottom, move _Hole down to it
; 2068 : 		*(_First + _Hole) = *(_First + (_Bottom - 1));

	mov	edx, DWORD PTR __Bottom$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8-8]
	mov	edx, DWORD PTR [eax+edx*8-4]
	mov	eax, DWORD PTR __Hole$[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	DWORD PTR [esi+eax*8], ecx
	mov	DWORD PTR [esi+eax*8+4], edx

; 2069 : 		_Hole = _Bottom - 1;

	mov	ecx, DWORD PTR __Bottom$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Hole$[ebp], ecx
$LN1@Adjust_hea:

; 2070 : 		}
; 2071 : 	std::_Push_heap(_First, _Hole, _Top, _Val);

	lea	edx, DWORD PTR $T243393[ebp]
	mov	DWORD PTR $T243380[ebp], edx
	mov	eax, DWORD PTR $T243380[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR $T243380[ebp]
	mov	eax, DWORD PTR __Val$[ebp+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR __Hole$[ebp]
	mov	DWORD PTR $T243394[ebp], ecx
	mov	eax, DWORD PTR $T243394[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Idx$243386[ebp], eax
	jmp	SHORT $LN14@Adjust_hea
$LN13@Adjust_hea:
	mov	eax, DWORD PTR $T243394[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Idx$243386[ebp], eax
$LN14@Adjust_hea:
	mov	edx, DWORD PTR __Top$[ebp]
	cmp	edx, DWORD PTR $T243394[ebp]
	jge	SHORT $LN12@Adjust_hea
	mov	eax, DWORD PTR __Idx$243386[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+4]
	xor	eax, eax
	cmp	edx, DWORD PTR $T243393[ebp+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN12@Adjust_hea
	mov	edx, DWORD PTR __Idx$243386[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8]
	mov	edx, DWORD PTR [eax+edx*8+4]
	mov	eax, DWORD PTR $T243394[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	DWORD PTR [esi+eax*8], ecx
	mov	DWORD PTR [esi+eax*8+4], edx
	mov	ecx, DWORD PTR __Idx$243386[ebp]
	mov	DWORD PTR $T243394[ebp], ecx
	jmp	SHORT $LN13@Adjust_hea
$LN12@Adjust_hea:
	mov	edx, DWORD PTR $T243394[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR $T243393[ebp]
	mov	DWORD PTR [eax+edx*8], ecx
	mov	ecx, DWORD PTR $T243393[ebp+4]
	mov	DWORD PTR [eax+edx*8+4], ecx

; 2072 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HHU12@@Z ENDP ; std::_Adjust_heap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,int,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv83 = -32						; size = 4
$T243422 = -28						; size = 4
__Vptr$243420 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<enum ResourceTypes *,enum ResourceTypes *,std::allocator<enum ResourceTypes> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop
$LN5@Uninit_cop:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 4
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 4
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$243420[ebp], ecx
	mov	edx, DWORD PTR __Vptr$243420[ebp]
	mov	DWORD PTR $T243422[ebp], edx
	cmp	DWORD PTR $T243422[ebp], 0
	je	SHORT $LN18@Uninit_cop
	mov	eax, DWORD PTR $T243422[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR $T243422[ebp]
	mov	DWORD PTR tv83[ebp], eax
	jmp	SHORT $LN14@Uninit_cop
$LN18@Uninit_cop:
	mov	DWORD PTR tv83[ebp], 0
$LN14@Uninit_cop:
	jmp	SHORT $LN5@Uninit_cop
$LN4@Uninit_cop:
	jmp	SHORT $LN10@Uninit_cop
__catch$??$_Uninit_copy@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop
$LN2@Uninit_cop:
	mov	ecx, DWORD PTR __Next$[ebp]
	add	ecx, 4
	mov	DWORD PTR __Next$[ebp], ecx
$LN3@Uninit_cop:
	mov	edx, DWORD PTR __Next$[ebp]
	cmp	edx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop

; 134  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_cop
$LN1@Uninit_cop:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<enum ResourceTypes *,enum ResourceTypes *,std::allocator<enum ResourceTypes> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z
_TEXT	SEGMENT
$T243489 = -60						; size = 8
$T243460 = -20						; size = 4
$T243454 = -12						; size = 4
$T243453 = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z PROC ; std::_Pop_heap_0<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>, COMDAT

; 2087 : 	{	// pop *_First to *(_Last - 1) and reheap, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 2088 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2089 : 		_Ty(*(_Last - 1)), _Dist_type(_First));

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, 8
	mov	DWORD PTR $T243454[ebp], eax
	lea	ecx, DWORD PTR $T243489[ebp]
	mov	DWORD PTR $T243453[ebp], ecx
	mov	edx, DWORD PTR $T243453[ebp]
	mov	eax, DWORD PTR $T243454[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T243453[ebp]
	mov	eax, DWORD PTR $T243454[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR [edx-8], eax
	mov	DWORD PTR [edx-4], ecx
	sub	esp, 8
	mov	DWORD PTR $T243460[ebp], esp
	mov	eax, DWORD PTR $T243460[ebp]
	mov	ecx, DWORD PTR $T243489[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR $T243460[ebp]
	mov	eax, DWORD PTR $T243489[ebp+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, 8
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 3
	push	ecx
	push	0
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,int,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2090 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z ENDP ; std::_Pop_heap_0<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT

; 298  : {

	push	ebp
	mov	ebp, esp

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	DWORD PTR _p$[ebp], 0
	jl	SHORT $LN1@teamType
	cmp	DWORD PTR _p$[ebp], 64			; 00000040H
	jge	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	eax, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN2@teamType
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1
$LN2@teamType:

; 302  : }

	pop	ebp
	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isCity@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T243500 = -4						; size = 4
?isCity@CvPlot@@QBE_NXZ PROC				; CvPlot::isCity, COMDAT
; _this$ = ecx

; 244  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 245  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+104], 0
	jl	SHORT $LN1@isCity
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+104], 64			; 00000040H
	jge	SHORT $LN1@isCity

; 246  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID)) != NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T243500[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	mov	ecx, DWORD PTR $T243500[ebp]
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	neg	eax
	sbb	eax, eax
	neg	eax
	jmp	SHORT $LN2@isCity
$LN1@isCity:

; 247  : 
; 248  : 		return false;

	xor	al, al
$LN2@isCity:

; 249  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?isCity@CvPlot@@QBE_NXZ ENDP				; CvPlot::isCity
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T243506 = -4						; size = 4
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ PROC		; CvPlot::getPlotCity, COMDAT
; _this$ = ecx

; 532  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 533  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+104], 0
	jl	SHORT $LN1@getPlotCit
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+104], 64			; 00000040H
	jge	SHORT $LN1@getPlotCit

; 534  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T243506[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	mov	ecx, DWORD PTR $T243506[ebp]
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	jmp	SHORT $LN2@getPlotCit
$LN1@getPlotCit:

; 535  : 
; 536  : 		return NULL;

	xor	eax, eax
$LN2@getPlotCit:

; 537  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ ENDP		; CvPlot::getPlotCity
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv88 = -132						; size = 4
tv145 = -128						; size = 4
_this$ = -124						; size = 4
$T243538 = -30						; size = 1
$T243525 = -29						; size = 1
$T243521 = -28						; size = 4
$T243514 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T243538[ebp]
	mov	DWORD PTR $T243514[ebp], eax
	lea	ecx, DWORD PTR $T243525[ebp]
	mov	DWORD PTR $T243521[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv145[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv88[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
; Function compile flags: /Odtp
;	COMDAT ??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Allocate@H@std@@YAPAHIPAH@Z			; std::_Allocate<int>
PUBLIC	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$243662 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z PROC	; std::vector<int,std::allocator<int> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@2

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@2
	jmp	SHORT $LN3@Buy@2
$LN4@Buy@2:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$243662[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$243662[ebp], 0
	jbe	SHORT $LN11@Buy@2
	mov	eax, DWORD PTR __Count$243662[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy@2
$LN11@Buy@2:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy@2:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy@2

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@2

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy@2:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy@2:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@2:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ENDP	; std::vector<int,std::allocator<int> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T243728 = -28						; size = 4
$T243727 = -24						; size = 4
$T243723 = -20						; size = 4
$T243722 = -16						; size = 4
$T243711 = -12						; size = 4
$T243710 = -8						; size = 4
__Cat$243718 = -2					; size = 1
$T243716 = -1						; size = 1
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy@2

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T243723[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T243722[ebp], ecx
	mov	edx, DWORD PTR $T243723[ebp]
	mov	DWORD PTR $T243711[ebp], edx
	mov	eax, DWORD PTR $T243722[ebp]
	mov	DWORD PTR $T243710[ebp], eax
	mov	cl, BYTE PTR __Cat$243718[ebp]
	mov	BYTE PTR $T243716[ebp], cl

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR $T243728[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T243727[ebp], eax
	mov	ecx, DWORD PTR $T243727[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy@2:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0length_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T243746 = -80						; size = 28
$T243745 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ PROC	; std::vector<int,std::allocator<int> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T243746[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T243745[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T243745[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T243746[ebp]
	push	eax
	lea	ecx, DWORD PTR $T243745[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T243745[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T243745[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T243746[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@2:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T243746[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T243745[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ENDP	; std::vector<int,std::allocator<int> >::_Xlen
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT
$T243771 = -16						; size = 4
$T243767 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@H@std@@YAPAHIPAH@Z PROC			; std::_Allocate<int>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@2
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T243771[ebp], 0
	lea	eax, DWORD PTR $T243771[ebp]
	push	eax
	lea	ecx, DWORD PTR $T243767[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T243767[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T243767[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@2:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@H@std@@YAPAHIPAH@Z ENDP			; std::_Allocate<int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ; std::vector<int,std::allocator<int> >::insert
PUBLIC	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z	; stdext::unchecked_fill_n<int *,unsigned int,int>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
tv129 = -96						; size = 4
_this$ = -92						; size = 4
$T243864 = -64						; size = 4
$T243854 = -60						; size = 4
$T243842 = -56						; size = 4
$T243832 = -49						; size = 1
$T243831 = -48						; size = 4
__Cat$243849 = -19					; size = 1
$T243846 = -18						; size = 1
$T243845 = -17						; size = 1
$T243783 = -16						; size = 4
$T243779 = -12						; size = 4
$T243778 = -8						; size = 4
$T243777 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::vector<int,std::allocator<int> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T243783[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN9@push_back@4
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN7@push_back@4
$LN9@push_back@4:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv129[ebp], eax
$LN7@push_back@4:
	mov	ecx, DWORD PTR $T243783[ebp]
	cmp	ecx, DWORD PTR tv129[ebp]
	jae	SHORT $LN2@push_back@4

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T243854[ebp], eax
	mov	ecx, DWORD PTR $T243854[ebp]
	mov	DWORD PTR $T243842[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T243845[ebp], dl
	mov	al, BYTE PTR __Cat$243849[ebp]
	mov	BYTE PTR $T243846[ebp], al
	mov	cl, BYTE PTR $T243845[ebp]
	mov	BYTE PTR $T243832[ebp], cl
	mov	edx, DWORD PTR $T243842[ebp]
	mov	DWORD PTR $T243831[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR $T243831[ebp]
	push	ecx
	call	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ; stdext::unchecked_fill_n<int *,unsigned int,int>
	add	esp, 12					; 0000000cH
	mov	edx, 1
	shl	edx, 2
	add	edx, DWORD PTR $T243854[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back@4
$LN2@push_back@4:

; 823  : 			insert(end(), _Val);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T243864[ebp], edx
	mov	eax, DWORD PTR $T243864[ebp]
	mov	DWORD PTR $T243778[ebp], eax
	mov	ecx, DWORD PTR $T243778[ebp]
	mov	DWORD PTR $T243777[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR $T243777[ebp]
	push	eax
	lea	ecx, DWORD PTR $T243779[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ; std::vector<int,std::allocator<int> >::insert
$LN3@push_back@4:

; 824  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::vector<int,std::allocator<int> >::push_back
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
__Tmp$243989 = -24					; size = 4
$T243967 = -20						; size = 4
$T243948 = -16						; size = 4
$T243935 = -12						; size = 4
$T243932 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z PROC ; std::vector<int,std::allocator<int> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	test	edx, edx
	jne	SHORT $LN3@insert@2
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert@2
$LN3@insert@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T243948[ebp], ecx
	mov	edx, DWORD PTR $T243948[ebp]
	mov	DWORD PTR $T243932[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	sub	eax, DWORD PTR $T243932[ebp]
	sar	eax, 2
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert@2:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T243967[ebp], edx
	mov	eax, DWORD PTR $T243967[ebp]
	mov	DWORD PTR $T243935[ebp], eax
	mov	ecx, DWORD PTR $T243935[ebp]
	mov	DWORD PTR __Tmp$243989[ebp], ecx
	mov	edx, DWORD PTR __Off$[ebp]
	mov	eax, DWORD PTR __Tmp$243989[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR __Tmp$243989[ebp], ecx
	mov	edx, DWORD PTR __Tmp$243989[ebp]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ENDP ; std::vector<int,std::allocator<int> >::insert
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>
PUBLIC	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
PUBLIC	??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<int *,int *,std::allocator<int> >
PUBLIC	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$2
__catchsym$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$0
__unwindtable$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$5
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$6
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
_TEXT	SEGMENT
tv84 = -432						; size = 4
tv302 = -428						; size = 4
tv288 = -424						; size = 4
tv280 = -420						; size = 4
_this$ = -416						; size = 4
$T244543 = -412						; size = 4
$T244491 = -368						; size = 4
$T244479 = -364						; size = 4
$T244469 = -357						; size = 1
$T244468 = -356						; size = 4
__Cat$244487 = -327					; size = 1
$T244484 = -326						; size = 1
$T244483 = -325						; size = 1
$T244440 = -324						; size = 4
$T244432 = -320						; size = 4
$T244424 = -316						; size = 4
$T244413 = -312						; size = 4
$T244412 = -308						; size = 4
__Cat$244420 = -302					; size = 1
$T244418 = -301						; size = 1
$T244341 = -276						; size = 4
$T244322 = -272						; size = 4
$T244305 = -265						; size = 1
$T244304 = -264						; size = 4
$T244294 = -260						; size = 4
$T244293 = -256						; size = 4
__Cat$244338 = -250					; size = 1
$T244336 = -249						; size = 1
$T244335 = -248						; size = 1
__Cat$244330 = -247					; size = 1
$T244327 = -246						; size = 1
$T244326 = -245						; size = 1
$T244269 = -244						; size = 4
$T244268 = -240						; size = 4
$T244264 = -236						; size = 4
$T244263 = -232						; size = 4
$T244252 = -228						; size = 4
$T244251 = -224						; size = 4
__Cat$244258 = -218					; size = 1
$T244256 = -217						; size = 1
$T244216 = -216						; size = 4
$T244215 = -212						; size = 4
__Cat$244222 = -206					; size = 1
$T244220 = -205						; size = 1
$T244186 = -204						; size = 4
$T244185 = -200						; size = 4
__Cat$244192 = -194					; size = 1
$T244190 = -193						; size = 1
$T244166 = -192						; size = 4
$T244154 = -188						; size = 4
$T244144 = -181						; size = 1
$T244143 = -180						; size = 4
__Cat$244161 = -175					; size = 1
$T244158 = -174						; size = 1
$T244157 = -173						; size = 1
$T244131 = -172						; size = 4
$T244119 = -168						; size = 4
$T244109 = -161						; size = 1
$T244108 = -160						; size = 4
__Cat$244126 = -155					; size = 1
$T244123 = -154						; size = 1
$T244122 = -153						; size = 1
$T244096 = -152						; size = 4
$T244084 = -148						; size = 4
$T244074 = -141						; size = 1
$T244073 = -140						; size = 4
__Cat$244090 = -135					; size = 1
$T244088 = -134						; size = 1
$T244087 = -133						; size = 1
__Count$244050 = -120					; size = 4
__Count$244024 = -48					; size = 4
__Tmp$214818 = -44					; size = 4
__Oldend$214819 = -40					; size = 4
__Tmp$214808 = -36					; size = 4
__Ncopied$214795 = -32					; size = 4
__Newvec$214793 = -28					; size = 4
__Whereoff$214794 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z PROC ; std::vector<int,std::allocator<int> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 416				; 000001a0H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN29@Insert_n@2
	mov	DWORD PTR tv280[ebp], 0
	jmp	SHORT $LN27@Insert_n@2
$LN29@Insert_n@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv280[ebp], eax
$LN27@Insert_n@2:
	mov	ecx, DWORD PTR tv280[ebp]
	mov	DWORD PTR __Capacity$[ebp], ecx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@2
	jmp	$LN16@Insert_n@2
$LN14@Insert_n@2:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$244024[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$244024[ebp], 0
	jbe	SHORT $LN35@Insert_n@2
	mov	edx, DWORD PTR __Count$244024[ebp]
	mov	DWORD PTR tv288[ebp], edx
	jmp	SHORT $LN37@Insert_n@2
$LN35@Insert_n@2:
	mov	DWORD PTR tv288[ebp], 1
$LN37@Insert_n@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	eax, DWORD PTR tv288[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN42@Insert_n@2

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
	jmp	$LN16@Insert_n@2

; 1167 : 		else if (_Capacity < size() + _Count)

$LN42@Insert_n@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@2

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$244050[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$244050[ebp], 0
	jbe	SHORT $LN48@Insert_n@2
	mov	ecx, DWORD PTR __Count$244050[ebp]
	mov	DWORD PTR tv302[ebp], ecx
	jmp	SHORT $LN44@Insert_n@2
$LN48@Insert_n@2:
	mov	DWORD PTR tv302[ebp], 1
$LN44@Insert_n@2:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	mov	eax, DWORD PTR tv302[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@2
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@2
$LN17@Insert_n@2:
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	add	ecx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], ecx
$LN18@Insert_n@2:
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1171 : 			if (_Capacity < size() + _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], edx
	jae	SHORT $LN54@Insert_n@2

; 1172 : 				_Capacity = size() + _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN54@Insert_n@2:
	push	0
	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	add	esp, 8
	mov	DWORD PTR __Newvec$214793[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR __Whereoff$214794[ebp], edx

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$214795[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Whereoff$214794[ebp]
	mov	ecx, DWORD PTR __Newvec$214793[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T244096[ebp], edx
	mov	eax, DWORD PTR $T244096[ebp]
	mov	DWORD PTR $T244084[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T244087[ebp], cl
	mov	dl, BYTE PTR __Cat$244090[ebp]
	mov	BYTE PTR $T244088[ebp], dl
	mov	al, BYTE PTR $T244087[ebp]
	mov	BYTE PTR $T244074[ebp], al
	mov	ecx, DWORD PTR $T244084[ebp]
	mov	DWORD PTR $T244073[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T244073[ebp]
	push	ecx
	call	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ; stdext::unchecked_fill_n<int *,unsigned int,int>
	add	esp, 12					; 0000000cH

; 1179 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$214795[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$214795[ebp], edx

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T244131[ebp], ecx
	mov	edx, DWORD PTR __Newvec$214793[ebp]
	mov	DWORD PTR $T244119[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T244122[ebp], al
	mov	cl, BYTE PTR __Cat$244126[ebp]
	mov	BYTE PTR $T244123[ebp], cl
	mov	dl, BYTE PTR $T244122[ebp]
	mov	BYTE PTR $T244109[ebp], dl
	mov	eax, DWORD PTR $T244119[ebp]
	mov	DWORD PTR $T244108[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T244108[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T244131[ebp]
	push	ecx
	call	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
	add	esp, 16					; 00000010H

; 1182 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$214795[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$214795[ebp], edx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T244166[ebp], ecx
	mov	edx, DWORD PTR __Whereoff$214794[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Newvec$214793[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T244154[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T244157[ebp], dl
	mov	al, BYTE PTR __Cat$244161[ebp]
	mov	BYTE PTR $T244158[ebp], al
	mov	cl, BYTE PTR $T244157[ebp]
	mov	BYTE PTR $T244144[ebp], cl
	mov	edx, DWORD PTR $T244154[ebp]
	mov	DWORD PTR $T244143[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T244143[ebp]
	push	ecx
	mov	edx, DWORD PTR $T244166[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
	add	esp, 16					; 00000010H
	jmp	$LN19@Insert_n@2
__catch$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$214795[ebp], 1
	jle	SHORT $LN7@Insert_n@2

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	ecx, DWORD PTR __Whereoff$214794[ebp]
	mov	edx, DWORD PTR __Newvec$214793[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T244186[ebp], eax
	mov	ecx, DWORD PTR __Newvec$214793[ebp]
	mov	DWORD PTR $T244185[ebp], ecx
	mov	dl, BYTE PTR __Cat$244192[ebp]
	mov	BYTE PTR $T244190[ebp], dl
$LN7@Insert_n@2:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$214795[ebp], 0
	jle	SHORT $LN6@Insert_n@2

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	eax, DWORD PTR __Whereoff$214794[ebp]
	mov	ecx, DWORD PTR __Newvec$214793[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T244216[ebp], ecx
	mov	edx, DWORD PTR __Whereoff$214794[ebp]
	mov	eax, DWORD PTR __Newvec$214793[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T244215[ebp], ecx
	mov	dl, BYTE PTR __Cat$244222[ebp]
	mov	BYTE PTR $T244220[ebp], dl
$LN6@Insert_n@2:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Newvec$214793[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN103@Insert_n@2
	ret	0
$LN19@Insert_n@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN103@Insert_n@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN5@Insert_n@2

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T244264[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T244263[ebp], edx
	mov	eax, DWORD PTR $T244264[ebp]
	mov	DWORD PTR $T244252[ebp], eax
	mov	ecx, DWORD PTR $T244263[ebp]
	mov	DWORD PTR $T244251[ebp], ecx
	mov	dl, BYTE PTR __Cat$244258[ebp]
	mov	BYTE PTR $T244256[ebp], dl

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T244269[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T244268[ebp], ecx
	mov	edx, DWORD PTR $T244268[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n@2:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR __Newvec$214793[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Newvec$214793[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$214793[ebp]
	mov	DWORD PTR [edx+4], eax
	jmp	$LN16@Insert_n@2
$LN10@Insert_n@2:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 2
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@2

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$214808[ebp], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T244341[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T244322[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T244326[ebp], cl
	mov	dl, BYTE PTR __Cat$244330[ebp]
	mov	BYTE PTR $T244327[ebp], dl
	mov	al, BYTE PTR $T244326[ebp]
	mov	BYTE PTR $T244305[ebp], al
	mov	ecx, DWORD PTR $T244322[ebp]
	mov	DWORD PTR $T244304[ebp], ecx
	mov	edx, DWORD PTR $T244304[ebp]
	mov	DWORD PTR $T244294[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T244293[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T244335[ebp], cl
	mov	dl, BYTE PTR __Cat$244338[ebp]
	mov	BYTE PTR $T244336[ebp], dl
	movzx	eax, BYTE PTR $T244335[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T244336[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T244294[ebp]
	push	eax
	mov	ecx, DWORD PTR $T244341[ebp]
	push	ecx
	mov	edx, DWORD PTR $T244293[ebp]
	push	edx
	call	??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<int *,int *,std::allocator<int> >
	add	esp, 24					; 00000018H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	eax, DWORD PTR __Tmp$214808[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 2
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
	jmp	SHORT $LN21@Insert_n@2
__catch$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T244424[ebp], eax
	mov	ecx, DWORD PTR $T244424[ebp]
	mov	DWORD PTR $T244413[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T244412[ebp], ecx
	mov	dl, BYTE PTR __Cat$244420[ebp]
	mov	BYTE PTR $T244418[ebp], dl

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$3
	ret	0
$LN21@Insert_n@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, edx
	mov	DWORD PTR $T244440[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T244432[ebp], edx
	jmp	SHORT $LN151@Insert_n@2
$LN150@Insert_n@2:
	mov	eax, DWORD PTR $T244432[ebp]
	add	eax, 4
	mov	DWORD PTR $T244432[ebp], eax
$LN151@Insert_n@2:
	mov	ecx, DWORD PTR $T244432[ebp]
	cmp	ecx, DWORD PTR $T244440[ebp]
	je	SHORT $LN147@Insert_n@2
	mov	edx, DWORD PTR $T244432[ebp]
	mov	eax, DWORD PTR __Tmp$214808[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN150@Insert_n@2
$LN147@Insert_n@2:

; 1232 : 			}
; 1233 : 		else

	jmp	$LN16@Insert_n@2
$LN3@Insert_n@2:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$214818[ebp], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Oldend$214819[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T244491[ebp], eax
	mov	ecx, DWORD PTR $T244491[ebp]
	mov	DWORD PTR $T244479[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T244483[ebp], dl
	mov	al, BYTE PTR __Cat$244487[ebp]
	mov	BYTE PTR $T244484[ebp], al
	mov	cl, BYTE PTR $T244483[ebp]
	mov	BYTE PTR $T244469[ebp], cl
	mov	edx, DWORD PTR $T244479[ebp]
	mov	DWORD PTR $T244468[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T244468[ebp]
	push	ecx
	mov	edx, DWORD PTR __Oldend$214819[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Oldend$214819[ebp]
	sub	ecx, eax
	push	ecx
	call	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, DWORD PTR __Oldend$214819[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR __Oldend$214819[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T244543[ebp], ecx
	jmp	SHORT $LN186@Insert_n@2
$LN185@Insert_n@2:
	mov	edx, DWORD PTR $T244543[ebp]
	add	edx, 4
	mov	DWORD PTR $T244543[ebp], edx
$LN186@Insert_n@2:
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	cmp	DWORD PTR $T244543[ebp], edx
	je	SHORT $LN16@Insert_n@2
	mov	eax, DWORD PTR $T244543[ebp]
	mov	ecx, DWORD PTR __Tmp$214818[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN185@Insert_n@2
$LN16@Insert_n@2:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-436]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T244614 = -40						; size = 4
$T244604 = -33						; size = 1
$T244603 = -32						; size = 4
__Cat$244610 = -3					; size = 1
$T244608 = -2						; size = 1
$T244607 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z PROC ; std::vector<int,std::allocator<int> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR $T244614[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T244607[ebp], cl
	mov	dl, BYTE PTR __Cat$244610[ebp]
	mov	BYTE PTR $T244608[ebp], dl
	mov	al, BYTE PTR $T244607[ebp]
	mov	BYTE PTR $T244604[ebp], al
	mov	ecx, DWORD PTR $T244614[ebp]
	mov	DWORD PTR $T244603[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T244603[ebp]
	push	ecx
	call	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ; stdext::unchecked_fill_n<int *,unsigned int,int>
	add	esp, 12					; 0000000cH

; 1255 : 		return (_Ptr + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [eax+edx*4]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Ufill
_TEXT	ENDS
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z
_TEXT	SEGMENT
$T244659 = -38						; size = 1
$T244658 = -37						; size = 1
$T244657 = -36						; size = 4
$T244656 = -32						; size = 4
$T244643 = -25						; size = 1
$T244642 = -24						; size = 4
$T244641 = -20						; size = 4
__Off$244651 = -16					; size = 4
__Result$244652 = -12					; size = 4
__Cat$244648 = -8					; size = 1
$T244646 = -7						; size = 1
$T244645 = -6						; size = 1
__Cat$244623 = -4					; size = 1
$T244619 = -3						; size = 1
$T244618 = -2						; size = 1
$T244617 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z PROC ; stdext::_Unchecked_move_backward<int *,int *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T244617[ebp], al
	mov	cl, BYTE PTR __Cat$244623[ebp]
	mov	BYTE PTR $T244618[ebp], cl
	mov	dl, BYTE PTR $T244617[ebp]
	mov	BYTE PTR $T244659[ebp], dl
	mov	al, BYTE PTR $T244619[ebp]
	mov	BYTE PTR $T244658[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T244657[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T244656[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T244645[ebp], al
	mov	cl, BYTE PTR __Cat$244648[ebp]
	mov	BYTE PTR $T244646[ebp], cl
	mov	dl, BYTE PTR $T244645[ebp]
	mov	BYTE PTR $T244643[ebp], dl
	mov	eax, DWORD PTR $T244657[ebp]
	mov	DWORD PTR $T244642[ebp], eax
	mov	ecx, DWORD PTR $T244656[ebp]
	mov	DWORD PTR $T244641[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR $T244641[ebp]
	sar	edx, 2
	mov	DWORD PTR __Off$244651[ebp], edx
	mov	eax, DWORD PTR __Off$244651[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR $T244642[ebp]
	sub	ecx, eax
	mov	DWORD PTR __Result$244652[ebp], ecx
	cmp	DWORD PTR __Off$244651[ebp], 0
	jle	SHORT $LN7@Unchecked_
	mov	edx, DWORD PTR __Off$244651[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR $T244641[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$244651[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __Result$244652[ebp]
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN7@Unchecked_:
	mov	eax, DWORD PTR __Result$244652[ebp]

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ENDP ; stdext::_Unchecked_move_backward<int *,int *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z
_TEXT	SEGMENT
$T244689 = -22						; size = 1
$T244688 = -21						; size = 1
$T244687 = -20						; size = 4
$T244678 = -13						; size = 1
$T244677 = -12						; size = 4
$T244676 = -8						; size = 4
$T244681 = -4						; size = 1
$T244663 = -2						; size = 1
$T244662 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z PROC	; stdext::unchecked_fill_n<int *,unsigned int,int>, COMDAT

; 3720 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T244662[ebp], al
	mov	cl, BYTE PTR $T244662[ebp]
	mov	BYTE PTR $T244689[ebp], cl
	mov	dl, BYTE PTR $T244663[ebp]
	mov	BYTE PTR $T244688[ebp], dl
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T244687[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T244681[ebp], cl
	mov	dl, BYTE PTR $T244681[ebp]
	mov	BYTE PTR $T244678[ebp], dl
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR $T244677[ebp], eax
	mov	ecx, DWORD PTR $T244687[ebp]
	mov	DWORD PTR $T244676[ebp], ecx
	jmp	SHORT $LN9@unchecked_
$LN8@unchecked_:
	mov	edx, DWORD PTR $T244677[ebp]
	sub	edx, 1
	mov	DWORD PTR $T244677[ebp], edx
	mov	eax, DWORD PTR $T244676[ebp]
	add	eax, 4
	mov	DWORD PTR $T244676[ebp], eax
$LN9@unchecked_:
	cmp	DWORD PTR $T244677[ebp], 0
	jbe	SHORT $LN1@unchecked_
	mov	ecx, DWORD PTR $T244676[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN8@unchecked_
$LN1@unchecked_:

; 3722 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ENDP	; stdext::unchecked_fill_n<int *,unsigned int,int>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
$T244706 = -21						; size = 1
$T244705 = -20						; size = 4
$T244704 = -16						; size = 4
__Result$244701 = -12					; size = 4
__Count$244700 = -8					; size = 4
__Cat$244696 = -3					; size = 1
$T244693 = -2						; size = 1
$T244692 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T244692[ebp], al
	mov	cl, BYTE PTR __Cat$244696[ebp]
	mov	BYTE PTR $T244693[ebp], cl
	mov	dl, BYTE PTR $T244692[ebp]
	mov	BYTE PTR $T244706[ebp], dl
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T244705[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T244704[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR $T244704[ebp]
	sar	edx, 2
	mov	DWORD PTR __Count$244700[ebp], edx
	mov	eax, DWORD PTR __Count$244700[ebp]
	mov	ecx, DWORD PTR $T244705[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Result$244701[ebp], edx
	cmp	DWORD PTR __Count$244700[ebp], 0
	jbe	SHORT $LN6@unchecked_@2
	mov	eax, DWORD PTR __Count$244700[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR $T244704[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$244700[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR $T244705[ebp]
	push	eax
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN6@unchecked_@2:
	mov	eax, DWORD PTR __Result$244701[ebp]

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<int *,int *,std::allocator<int> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@2

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@2:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<int *,int *,std::allocator<int> >
_TEXT	ENDS
END
