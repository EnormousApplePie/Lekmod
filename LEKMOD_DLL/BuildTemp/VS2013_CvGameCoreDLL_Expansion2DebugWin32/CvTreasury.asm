; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvTreasury.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
PUBLIC	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
PUBLIC	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
PUBLIC	??_7CvTreasury@@6B@				; CvTreasury::`vftable'
PUBLIC	??0CvTreasury@@QAE@XZ				; CvTreasury::CvTreasury
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	??_ECvTreasury@@UAEPAXI@Z:PROC			; CvTreasury::`vector deleting destructor'
;	COMDAT ??_7CvTreasury@@6B@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
CONST	SEGMENT
??_7CvTreasury@@6B@ DD FLAT:??_ECvTreasury@@UAEPAXI@Z	; CvTreasury::`vftable'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CvTreasury@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvTreasury@@QAE@XZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvTreasury@@QAE@XZ$0
	DD	01H
	DD	FLAT:__unwindfunclet$??0CvTreasury@@QAE@XZ$6
__ehfuncinfo$??0CvTreasury@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0CvTreasury@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtreasury.cpp
xdata$x	ENDS
;	COMDAT ??0CvTreasury@@QAE@XZ
_TEXT	SEGMENT
tv198 = -256						; size = 4
tv254 = -252						; size = 4
tv145 = -248						; size = 4
tv170 = -244						; size = 4
_this$ = -240						; size = 4
$T218333 = -236						; size = 4
$T218284 = -142						; size = 1
$T218271 = -141						; size = 1
$T218267 = -140						; size = 4
$T218260 = -132						; size = 4
$T218253 = -124						; size = 4
$T218203 = -30						; size = 1
$T218190 = -29						; size = 1
$T218186 = -28						; size = 4
$T218179 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0CvTreasury@@QAE@XZ PROC				; CvTreasury::CvTreasury, COMDAT
; _this$ = ecx

; 36   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvTreasury@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 244				; 000000f4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvTreasury@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+36], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+40], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+44], 0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 48					; 00000030H
	mov	DWORD PTR $T218253[ebp], eax
	lea	ecx, DWORD PTR $T218203[ebp]
	mov	DWORD PTR $T218179[ebp], ecx
	lea	edx, DWORD PTR $T218190[ebp]
	mov	DWORD PTR $T218186[ebp], edx
	mov	eax, DWORD PTR $T218253[ebp]
	mov	DWORD PTR tv170[ebp], eax
	mov	ecx, DWORD PTR $T218253[ebp]
	mov	DWORD PTR tv145[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	0
	mov	ecx, DWORD PTR $T218253[ebp]
	call	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 64					; 00000040H
	mov	DWORD PTR $T218333[ebp], edx
	lea	eax, DWORD PTR $T218284[ebp]
	mov	DWORD PTR $T218260[ebp], eax
	lea	ecx, DWORD PTR $T218271[ebp]
	mov	DWORD PTR $T218267[ebp], ecx
	mov	edx, DWORD PTR $T218333[ebp]
	mov	DWORD PTR tv254[ebp], edx
	mov	eax, DWORD PTR $T218333[ebp]
	mov	DWORD PTR tv198[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	push	0
	mov	ecx, DWORD PTR $T218333[ebp]
	call	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 37   : 
; 38   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvTreasury@@QAE@XZ$2:
	mov	ecx, DWORD PTR $T218253[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__unwindfunclet$??0CvTreasury@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??0CvTreasury@@QAE@XZ$6:
	mov	ecx, DWORD PTR $T218333[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__ehhandler$??0CvTreasury@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-248]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvTreasury@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvTreasury@@QAE@XZ ENDP				; CvTreasury::CvTreasury
PUBLIC	??1CvTreasury@@UAE@XZ				; CvTreasury::~CvTreasury
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp
;	COMDAT ??_GCvTreasury@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCvTreasury@@UAEPAXI@Z PROC				; CvTreasury::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvTreasury@@UAE@XZ			; CvTreasury::~CvTreasury
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCvTreasury@@UAEPAXI@Z ENDP				; CvTreasury::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1CvTreasury@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvTreasury@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvTreasury@@UAE@XZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvTreasury@@UAE@XZ$4
__ehfuncinfo$??1CvTreasury@@UAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1CvTreasury@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtreasury.cpp
xdata$x	ENDS
;	COMDAT ??1CvTreasury@@UAE@XZ
_TEXT	SEGMENT
_this$ = -80						; size = 4
$T218462 = -76						; size = 4
$T218406 = -44						; size = 4
__$EHRec$ = -12						; size = 12
??1CvTreasury@@UAE@XZ PROC				; CvTreasury::~CvTreasury, COMDAT
; _this$ = ecx

; 42   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvTreasury@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvTreasury@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 43   : }

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	mov	DWORD PTR $T218406[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR $T218406[ebp]
	call	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 48					; 00000030H
	mov	DWORD PTR $T218462[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR $T218462[ebp]
	call	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvTreasury@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??1CvTreasury@@UAE@XZ$2:
	mov	ecx, DWORD PTR $T218406[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__unwindfunclet$??1CvTreasury@@UAE@XZ$4:
	mov	ecx, DWORD PTR $T218462[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__ehhandler$??1CvTreasury@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvTreasury@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvTreasury@@UAE@XZ ENDP				; CvTreasury::~CvTreasury
PUBLIC	?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z ; std::vector<int,std::allocator<int> >::reserve
PUBLIC	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase
PUBLIC	?Init@CvTreasury@@QAEXPAVCvPlayer@@@Z		; CvTreasury::Init
; Function compile flags: /Odtp
;	COMDAT ?Init@CvTreasury@@QAEXPAVCvPlayer@@@Z
_TEXT	SEGMENT
_this$ = -172						; size = 4
$T218770 = -168						; size = 4
$T218652 = -112						; size = 4
$T218636 = -108						; size = 4
$T218756 = -104						; size = 4
$T218755 = -100						; size = 4
$T218754 = -96						; size = 4
$T218753 = -92						; size = 4
$T218752 = -88						; size = 4
$T218620 = -84						; size = 4
$T218502 = -28						; size = 4
$T218486 = -24						; size = 4
$T218606 = -20						; size = 4
$T218605 = -16						; size = 4
$T218604 = -12						; size = 4
$T218603 = -8						; size = 4
$T218602 = -4						; size = 4
_pPlayer$ = 8						; size = 4
?Init@CvTreasury@@QAEXPAVCvPlayer@@@Z PROC		; CvTreasury::Init, COMDAT
; _this$ = ecx

; 47   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 172				; 000000acH
	mov	DWORD PTR _this$[ebp], ecx

; 48   : 	m_pPlayer = pPlayer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 49   : 
; 50   : 	m_iGold = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 51   : 	m_iGoldPerTurnFromDiplomacy = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 52   : 	m_iExpensePerTurnUnitMaintenance = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 53   : 	m_iExpensePerTurnUnitSupply = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 54   : 	m_iCityConnectionGoldTimes100 = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0

; 55   : 	m_iCityConnectionTradeRouteGoldModifier = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], 0

; 56   : 	m_iCityConnectionTradeRouteGoldChange = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], 0

; 57   : 	m_iBaseBuildingGoldMaintenance = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+36], 0

; 58   : 	m_iBaseImprovementGoldMaintenance = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+40], 0

; 59   : 	m_iLifetimeGrossGoldIncome = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+44], 0

; 60   : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 61   : 	m_iCurrentGoldChange = 0;
; 62   : 	m_iCurrentGrossGoldChange = 0;
; 63   : #endif
; 64   : 
; 65   : 	m_GoldBalanceForTurnTimes100.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 48					; 00000030H
	mov	DWORD PTR $T218620[ebp], eax
	mov	ecx, DWORD PTR $T218620[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T218486[ebp], edx
	mov	eax, DWORD PTR $T218486[ebp]
	mov	DWORD PTR $T218603[ebp], eax
	mov	ecx, DWORD PTR $T218603[ebp]
	mov	DWORD PTR $T218602[ebp], ecx
	mov	edx, DWORD PTR $T218620[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T218502[ebp], eax
	mov	ecx, DWORD PTR $T218502[ebp]
	mov	DWORD PTR $T218605[ebp], ecx
	mov	edx, DWORD PTR $T218605[ebp]
	mov	DWORD PTR $T218604[ebp], edx
	mov	eax, DWORD PTR $T218602[ebp]
	push	eax
	mov	ecx, DWORD PTR $T218604[ebp]
	push	ecx
	lea	edx, DWORD PTR $T218606[ebp]
	push	edx
	mov	ecx, DWORD PTR $T218620[ebp]
	call	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase

; 66   : 	m_GoldBalanceForTurnTimes100.reserve(750);

	push	750					; 000002eeH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z ; std::vector<int,std::allocator<int> >::reserve

; 67   : 	m_GoldChangeForTurnTimes100.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 64					; 00000040H
	mov	DWORD PTR $T218770[ebp], eax
	mov	ecx, DWORD PTR $T218770[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T218636[ebp], edx
	mov	eax, DWORD PTR $T218636[ebp]
	mov	DWORD PTR $T218753[ebp], eax
	mov	ecx, DWORD PTR $T218753[ebp]
	mov	DWORD PTR $T218752[ebp], ecx
	mov	edx, DWORD PTR $T218770[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T218652[ebp], eax
	mov	ecx, DWORD PTR $T218652[ebp]
	mov	DWORD PTR $T218755[ebp], ecx
	mov	edx, DWORD PTR $T218755[ebp]
	mov	DWORD PTR $T218754[ebp], edx
	mov	eax, DWORD PTR $T218752[ebp]
	push	eax
	mov	ecx, DWORD PTR $T218754[ebp]
	push	ecx
	lea	edx, DWORD PTR $T218756[ebp]
	push	edx
	mov	ecx, DWORD PTR $T218770[ebp]
	call	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase

; 68   : 	m_GoldChangeForTurnTimes100.reserve(750);

	push	750					; 000002eeH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z ; std::vector<int,std::allocator<int> >::reserve

; 69   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Init@CvTreasury@@QAEXPAVCvPlayer@@@Z ENDP		; CvTreasury::Init
_TEXT	ENDS
PUBLIC	?Uninit@CvTreasury@@QAEXXZ			; CvTreasury::Uninit
; Function compile flags: /Odtp
;	COMDAT ?Uninit@CvTreasury@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Uninit@CvTreasury@@QAEXXZ PROC				; CvTreasury::Uninit, COMDAT
; _this$ = ecx

; 73   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 74   : 
; 75   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Uninit@CvTreasury@@QAEXXZ ENDP				; CvTreasury::Uninit
_TEXT	ENDS
PUBLIC	?GetGoldFromCitiesTimes100@CvTreasury@@QBEH_N@Z	; CvTreasury::GetGoldFromCitiesTimes100
PUBLIC	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
PUBLIC	?CalculateGrossGold@CvTreasury@@QAEHXZ		; CvTreasury::CalculateGrossGold
PUBLIC	?ChangeGoldTimes100@CvTreasury@@QAEXH@Z		; CvTreasury::ChangeGoldTimes100
PUBLIC	?SetGold@CvTreasury@@QAEXH@Z			; CvTreasury::SetGold
PUBLIC	?GetGoldTimes100@CvTreasury@@QBEHXZ		; CvTreasury::GetGoldTimes100
PUBLIC	?DoGold@CvTreasury@@QAEXXZ			; CvTreasury::DoGold
EXTRN	?isGameMultiPlayer@CvGame@@QBE_NXZ:PROC		; CvGame::isGameMultiPlayer
EXTRN	?isHuman@CvPlayer@@QBE_NXZ:PROC			; CvPlayer::isHuman
EXTRN	?getGameTurn@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurn
EXTRN	?DoDeficit@CvPlayer@@QAEXXZ:PROC		; CvPlayer::DoDeficit
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
EXTRN	?calculateGoldRateTimes100@CvPlayer@@QBEHXZ:PROC ; CvPlayer::calculateGoldRateTimes100
; Function compile flags: /Odtp
;	COMDAT ?DoGold@CvTreasury@@QAEXXZ
_TEXT	SEGMENT
tv170 = -176						; size = 4
_this$ = -172						; size = 4
$T219024 = -168						; size = 4
$T219020 = -164						; size = 4
$T218891 = -96						; size = 4
$T218887 = -92						; size = 4
$T218886 = -88						; size = 4
$T218788 = -36						; size = 4
$T218784 = -32						; size = 4
$T218783 = -28						; size = 4
$T218779 = -24						; size = 4
$T218775 = -20						; size = 4
_iGoldDelta$217123 = -16				; size = 4
_iGoldAfterThisTurn$ = -12				; size = 4
_iGoldChange$ = -8					; size = 4
_iGrossGoldChange$ = -4					; size = 4
?DoGold@CvTreasury@@QAEXXZ PROC				; CvTreasury::DoGold, COMDAT
; _this$ = ecx

; 97   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 176				; 000000b0H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 98   : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 99   : 	int iGoldChange = getGoldT100ForThisTurn();
; 100  : #else
; 101  : 	int iGoldChange;
; 102  : 
; 103  : 	iGoldChange = m_pPlayer->calculateGoldRateTimes100();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?calculateGoldRateTimes100@CvPlayer@@QBEHXZ ; CvPlayer::calculateGoldRateTimes100
	mov	DWORD PTR _iGoldChange$[ebp], eax

; 104  : #endif
; 105  : 
; 106  : 	int iGoldAfterThisTurn = iGoldChange + GetGoldTimes100();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetGoldTimes100@CvTreasury@@QBEHXZ	; CvTreasury::GetGoldTimes100
	add	eax, DWORD PTR _iGoldChange$[ebp]
	mov	DWORD PTR _iGoldAfterThisTurn$[ebp], eax

; 107  : 	if(iGoldAfterThisTurn < 0)

	jns	SHORT $LN8@DoGold

; 108  : 	{
; 109  : 		SetGold(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetGold@CvTreasury@@QAEXH@Z		; CvTreasury::SetGold

; 110  : 
; 111  : 		if(iGoldAfterThisTurn <= /*-5*/ GC.getDEFICIT_UNIT_DISBANDING_THRESHOLD() * 100)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6548
	mov	DWORD PTR $T218779[ebp], ecx
	mov	edx, DWORD PTR $T218779[ebp]
	imul	edx, 100				; 00000064H
	cmp	DWORD PTR _iGoldAfterThisTurn$[ebp], edx
	jg	SHORT $LN7@DoGold

; 112  : 			m_pPlayer->DoDeficit();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?DoDeficit@CvPlayer@@QAEXXZ		; CvPlayer::DoDeficit
$LN7@DoGold:

; 113  : 	}
; 114  : 	else

	jmp	SHORT $LN6@DoGold
$LN8@DoGold:

; 115  : 	{
; 116  : 		ChangeGoldTimes100(iGoldChange);

	mov	ecx, DWORD PTR _iGoldChange$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChangeGoldTimes100@CvTreasury@@QAEXH@Z	; CvTreasury::ChangeGoldTimes100
$LN6@DoGold:

; 117  : 	}
; 118  : 
; 119  : 	// Update the amount of gold grossed across lifetime of game
; 120  : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 121  : 	int iGrossGoldChange = getGrossGoldForThisTurn();
; 122  : #else
; 123  : 	int iGrossGoldChange = CalculateGrossGold();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateGrossGold@CvTreasury@@QAEHXZ	; CvTreasury::CalculateGrossGold
	mov	DWORD PTR _iGrossGoldChange$[ebp], eax

; 124  : #endif
; 125  : 	if(iGrossGoldChange > 0)

	cmp	DWORD PTR _iGrossGoldChange$[ebp], 0
	jle	SHORT $LN5@DoGold

; 126  : 	{
; 127  : 		m_iLifetimeGrossGoldIncome += iGrossGoldChange;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	add	eax, DWORD PTR _iGrossGoldChange$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+44], eax
$LN5@DoGold:

; 128  : 	}
; 129  : 
; 130  : 	FAssertMsg(m_GoldBalanceForTurnTimes100.size() <= (unsigned int) GC.getGame().getGameTurn(), "History of Gold Balances corrupted");
; 131  : 	if(m_GoldBalanceForTurnTimes100.size() < (unsigned int) GC.getGame().getGameTurn())

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 48					; 00000030H
	mov	DWORD PTR $T218783[ebp], edx
	mov	eax, DWORD PTR $T218783[ebp]
	mov	ecx, DWORD PTR $T218783[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T218784[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T218788[ebp], eax
	mov	ecx, DWORD PTR $T218788[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	cmp	DWORD PTR $T218784[ebp], eax
	jae	SHORT $LN4@DoGold

; 132  : 	{
; 133  : 		m_GoldBalanceForTurnTimes100.push_back(GetGoldTimes100());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetGoldTimes100@CvTreasury@@QBEHXZ	; CvTreasury::GetGoldTimes100
	mov	DWORD PTR $T218775[ebp], eax
	lea	ecx, DWORD PTR $T218775[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
$LN4@DoGold:

; 134  : 	}
; 135  : 
; 136  : 	FAssertMsg(m_GoldChangeForTurnTimes100.size() <= (unsigned int) GC.getGame().getGameTurn(), "History of Gold Changes corrupted");
; 137  : 	if(m_GoldChangeForTurnTimes100.size() < (unsigned int) GC.getGame().getGameTurn())

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 64					; 00000040H
	mov	DWORD PTR $T218886[ebp], edx
	mov	eax, DWORD PTR $T218886[ebp]
	mov	ecx, DWORD PTR $T218886[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T218887[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T218891[ebp], eax
	mov	ecx, DWORD PTR $T218891[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	cmp	DWORD PTR $T218887[ebp], eax
	jae	SHORT $LN3@DoGold

; 138  : 	{
; 139  : 		m_GoldChangeForTurnTimes100.push_back(iGoldChange);

	lea	ecx, DWORD PTR _iGoldChange$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
$LN3@DoGold:

; 140  : 	}
; 141  : 
; 142  : 	if (m_pPlayer->isHuman() && !GC.getGame().isGameMultiPlayer())

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	je	$LN9@DoGold
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T219020[ebp], ecx
	mov	ecx, DWORD PTR $T219020[ebp]
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN9@DoGold

; 143  : 	{
; 144  : 		int iGoldDelta = (GetGoldFromCitiesTimes100(false) - GetGoldFromCitiesTimes100(true)) / 100;

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetGoldFromCitiesTimes100@CvTreasury@@QBEH_N@Z ; CvTreasury::GetGoldFromCitiesTimes100
	mov	esi, eax
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetGoldFromCitiesTimes100@CvTreasury@@QBEH_N@Z ; CvTreasury::GetGoldFromCitiesTimes100
	sub	esi, eax
	mov	eax, esi
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iGoldDelta$217123[ebp], eax

; 145  : 		if (iGoldDelta >= 200)

	cmp	DWORD PTR _iGoldDelta$217123[ebp], 200	; 000000c8H
	jl	SHORT $LN9@DoGold

; 146  : 		{
; 147  : 			gDLL->UnlockAchievement(ACHIEVEMENT_XP2_32);

	mov	edx, DWORD PTR $T219024[ebp]
	mov	DWORD PTR tv170[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv170[ebp], eax
	push	274					; 00000112H
	mov	ecx, DWORD PTR tv170[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv170[ebp]
	mov	eax, DWORD PTR [edx+828]
	call	eax
$LN9@DoGold:

; 148  : 		}
; 149  : 	}
; 150  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?DoGold@CvTreasury@@QAEXXZ ENDP				; CvTreasury::DoGold
_TEXT	ENDS
PUBLIC	?GetGold@CvTreasury@@QBEHXZ			; CvTreasury::GetGold
; Function compile flags: /Odtp
;	COMDAT ?GetGold@CvTreasury@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGold@CvTreasury@@QBEHXZ PROC			; CvTreasury::GetGold, COMDAT
; _this$ = ecx

; 154  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 	return m_iGold / 100;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx

; 156  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGold@CvTreasury@@QBEHXZ ENDP			; CvTreasury::GetGold
_TEXT	ENDS
PUBLIC	?SetGoldTimes100@CvTreasury@@QAEXH@Z		; CvTreasury::SetGoldTimes100
; Function compile flags: /Odtp
;	COMDAT ?SetGold@CvTreasury@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iNewValue$ = 8						; size = 4
?SetGold@CvTreasury@@QAEXH@Z PROC			; CvTreasury::SetGold, COMDAT
; _this$ = ecx

; 160  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 	SetGoldTimes100(iNewValue * 100);

	mov	eax, DWORD PTR _iNewValue$[ebp]
	imul	eax, 100				; 00000064H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetGoldTimes100@CvTreasury@@QAEXH@Z	; CvTreasury::SetGoldTimes100

; 162  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetGold@CvTreasury@@QAEXH@Z ENDP			; CvTreasury::SetGold
_TEXT	ENDS
PUBLIC	?ChangeGold@CvTreasury@@QAEXH@Z			; CvTreasury::ChangeGold
; Function compile flags: /Odtp
;	COMDAT ?ChangeGold@CvTreasury@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?ChangeGold@CvTreasury@@QAEXH@Z PROC			; CvTreasury::ChangeGold, COMDAT
; _this$ = ecx

; 166  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 167  : 	ChangeGoldTimes100(iChange*100);

	mov	eax, DWORD PTR _iChange$[ebp]
	imul	eax, 100				; 00000064H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChangeGoldTimes100@CvTreasury@@QAEXH@Z	; CvTreasury::ChangeGoldTimes100

; 168  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ChangeGold@CvTreasury@@QAEXH@Z ENDP			; CvTreasury::ChangeGold
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetGoldTimes100@CvTreasury@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGoldTimes100@CvTreasury@@QBEHXZ PROC		; CvTreasury::GetGoldTimes100, COMDAT
; _this$ = ecx

; 172  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 173  : 	return m_iGold;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 174  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGoldTimes100@CvTreasury@@QBEHXZ ENDP		; CvTreasury::GetGoldTimes100
_TEXT	ENDS
EXTRN	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ:PROC ; CvGame::getActivePlayer
; Function compile flags: /Odtp
;	COMDAT ?SetGoldTimes100@CvTreasury@@QAEXH@Z
_TEXT	SEGMENT
tv140 = -36						; size = 4
tv128 = -32						; size = 4
tv84 = -28						; size = 4
_this$ = -24						; size = 4
$T219059 = -20						; size = 4
$T219055 = -16						; size = 4
$T219051 = -12						; size = 4
$T219047 = -8						; size = 4
$T219043 = -4						; size = 4
_iNewValue$ = 8						; size = 4
?SetGoldTimes100@CvTreasury@@QAEXH@Z PROC		; CvTreasury::SetGoldTimes100, COMDAT
; _this$ = ecx

; 178  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 179  : 	// Minors don't get Gold!
; 180  : 	if(GetGoldTimes100() != iNewValue)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetGoldTimes100@CvTreasury@@QBEHXZ	; CvTreasury::GetGoldTimes100
	cmp	eax, DWORD PTR _iNewValue$[ebp]
	je	$LN4@SetGoldTim

; 181  : 	{
; 182  : 		if(iNewValue < 0)
; 183  : 		{
; 184  : 			CvAssertMsg(false, "GAMEPLAY: Player is being set to a negative Gold value. Please send Jon this with your last 5 autosaves.");
; 185  : 		}
; 186  : 
; 187  : 		m_iGold = iNewValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iNewValue$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 188  : 
; 189  : 		if(m_pPlayer->GetID() == GC.getGame().getActivePlayer())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T219043[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T219047[ebp], edx
	mov	ecx, DWORD PTR $T219047[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	DWORD PTR $T219043[ebp], eax
	jne	SHORT $LN4@SetGoldTim

; 190  : 		{
; 191  : 			// Are we now able to buy a Plot when we weren't before?
; 192  : 			//if (GetGold() >= m_pPlayer->GetBuyPlotCost() && iOldGold < m_pPlayer->GetBuyPlotCost() && m_pPlayer->getNumCities() > 0)
; 193  : 			//{
; 194  : 			//	CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_ENOUGH_GOLD_TO_BUY_PLOT");
; 195  : 			//	CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_ENOUGH_GOLD_TO_BUY_PLOT");
; 196  : 			//	CvNotifications* pNotifications = m_pPlayer->GetNotifications();
; 197  : 			//	if (pNotifications)
; 198  : 			//	{
; 199  : 			//		pNotifications->Add(NOTIFICATION_BUY_TILE, strBuffer, strSummary, -1, -1, -1);
; 200  : 			//	}
; 201  : 			//}
; 202  : 
; 203  : 			GC.GetEngineUserInterface()->setDirty(MiscButtons_DIRTY_BIT, true);

	mov	eax, DWORD PTR $T219051[ebp]
	mov	DWORD PTR tv84[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv84[ebp], ecx
	push	1
	push	4
	mov	edx, DWORD PTR tv84[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv84[ebp]
	mov	edx, DWORD PTR [eax+260]
	call	edx

; 204  : 			GC.GetEngineUserInterface()->setDirty(SelectionButtons_DIRTY_BIT, true);

	mov	eax, DWORD PTR $T219055[ebp]
	mov	DWORD PTR tv128[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv128[ebp], ecx
	push	1
	push	6
	mov	edx, DWORD PTR tv128[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv128[ebp]
	mov	edx, DWORD PTR [eax+260]
	call	edx

; 205  : 			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	mov	eax, DWORD PTR $T219059[ebp]
	mov	DWORD PTR tv140[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv140[ebp], ecx
	push	1
	push	11					; 0000000bH
	mov	edx, DWORD PTR tv140[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv140[ebp]
	mov	edx, DWORD PTR [eax+260]
	call	edx
$LN4@SetGoldTim:

; 206  : 		}
; 207  : 	}
; 208  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetGoldTimes100@CvTreasury@@QAEXH@Z ENDP		; CvTreasury::SetGoldTimes100
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ChangeGoldTimes100@CvTreasury@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?ChangeGoldTimes100@CvTreasury@@QAEXH@Z PROC		; CvTreasury::ChangeGoldTimes100, COMDAT
; _this$ = ecx

; 212  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 213  : 	SetGoldTimes100(GetGoldTimes100() + iChange);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetGoldTimes100@CvTreasury@@QBEHXZ	; CvTreasury::GetGoldTimes100
	add	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetGoldTimes100@CvTreasury@@QAEXH@Z	; CvTreasury::SetGoldTimes100

; 214  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ChangeGoldTimes100@CvTreasury@@QAEXH@Z ENDP		; CvTreasury::ChangeGoldTimes100
_TEXT	ENDS
PUBLIC	?GetGoldFromCities@CvTreasury@@QBEHXZ		; CvTreasury::GetGoldFromCities
; Function compile flags: /Odtp
;	COMDAT ?GetGoldFromCities@CvTreasury@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGoldFromCities@CvTreasury@@QBEHXZ PROC		; CvTreasury::GetGoldFromCities, COMDAT
; _this$ = ecx

; 218  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 219  : 	return GetGoldFromCitiesTimes100() / 100;

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetGoldFromCitiesTimes100@CvTreasury@@QBEH_N@Z ; CvTreasury::GetGoldFromCitiesTimes100
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx

; 220  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGoldFromCities@CvTreasury@@QBEHXZ ENDP		; CvTreasury::GetGoldFromCities
_TEXT	ENDS
EXTRN	?getYieldRateTimes100@CvCity@@QBEHW4YieldTypes@@_N@Z:PROC ; CvCity::getYieldRateTimes100
EXTRN	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::nextCity
EXTRN	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::firstCity
; Function compile flags: /Odtp
;	COMDAT ?GetGoldFromCitiesTimes100@CvTreasury@@QBEH_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
_iGold$ = -12						; size = 4
_pLoopCity$ = -8					; size = 4
_iLoop$ = -4						; size = 4
_bExcludeTradeRoutes$ = 8				; size = 1
?GetGoldFromCitiesTimes100@CvTreasury@@QBEH_N@Z PROC	; CvTreasury::GetGoldFromCitiesTimes100, COMDAT
; _this$ = ecx

; 224  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 225  : 	int iGold = 0;

	mov	DWORD PTR _iGold$[ebp], 0

; 226  : 
; 227  : 	CvCity* pLoopCity;
; 228  : 
; 229  : 	int iLoop;
; 230  : 	for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
	jmp	SHORT $LN3@GetGoldFro
$LN2@GetGoldFro:
	push	0
	lea	edx, DWORD PTR _iLoop$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
$LN3@GetGoldFro:
	cmp	DWORD PTR _pLoopCity$[ebp], 0
	je	SHORT $LN1@GetGoldFro

; 231  : 	{
; 232  : 		iGold += pLoopCity->getYieldRateTimes100(YIELD_GOLD, bExcludeTradeRoutes);

	movzx	ecx, BYTE PTR _bExcludeTradeRoutes$[ebp]
	push	ecx
	push	2
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?getYieldRateTimes100@CvCity@@QBEHW4YieldTypes@@_N@Z ; CvCity::getYieldRateTimes100
	add	eax, DWORD PTR _iGold$[ebp]
	mov	DWORD PTR _iGold$[ebp], eax

; 233  : 	}

	jmp	SHORT $LN2@GetGoldFro
$LN1@GetGoldFro:

; 234  : 
; 235  : 	return iGold;

	mov	eax, DWORD PTR _iGold$[ebp]

; 236  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetGoldFromCitiesTimes100@CvTreasury@@QBEH_N@Z ENDP	; CvTreasury::GetGoldFromCitiesTimes100
_TEXT	ENDS
PUBLIC	?GetGoldPerTurnFromDiplomacy@CvTreasury@@QBEHXZ	; CvTreasury::GetGoldPerTurnFromDiplomacy
; Function compile flags: /Odtp
;	COMDAT ?GetGoldPerTurnFromDiplomacy@CvTreasury@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGoldPerTurnFromDiplomacy@CvTreasury@@QBEHXZ PROC	; CvTreasury::GetGoldPerTurnFromDiplomacy, COMDAT
; _this$ = ecx

; 240  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 241  : 	return m_iGoldPerTurnFromDiplomacy;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]

; 242  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGoldPerTurnFromDiplomacy@CvTreasury@@QBEHXZ ENDP	; CvTreasury::GetGoldPerTurnFromDiplomacy
_TEXT	ENDS
PUBLIC	?SetGoldPerTurnFromDiplomacy@CvTreasury@@QAEXH@Z ; CvTreasury::SetGoldPerTurnFromDiplomacy
; Function compile flags: /Odtp
;	COMDAT ?SetGoldPerTurnFromDiplomacy@CvTreasury@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iValue$ = 8						; size = 4
?SetGoldPerTurnFromDiplomacy@CvTreasury@@QAEXH@Z PROC	; CvTreasury::SetGoldPerTurnFromDiplomacy, COMDAT
; _this$ = ecx

; 246  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 247  : 	m_iGoldPerTurnFromDiplomacy = iValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iValue$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 248  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetGoldPerTurnFromDiplomacy@CvTreasury@@QAEXH@Z ENDP	; CvTreasury::SetGoldPerTurnFromDiplomacy
_TEXT	ENDS
PUBLIC	?ChangeGoldPerTurnFromDiplomacy@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeGoldPerTurnFromDiplomacy
; Function compile flags: /Odtp
;	COMDAT ?ChangeGoldPerTurnFromDiplomacy@CvTreasury@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?ChangeGoldPerTurnFromDiplomacy@CvTreasury@@QAEXH@Z PROC ; CvTreasury::ChangeGoldPerTurnFromDiplomacy, COMDAT
; _this$ = ecx

; 252  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 253  : 	SetGoldPerTurnFromDiplomacy(GetGoldPerTurnFromDiplomacy() + iChange);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetGoldPerTurnFromDiplomacy@CvTreasury@@QBEHXZ ; CvTreasury::GetGoldPerTurnFromDiplomacy
	add	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetGoldPerTurnFromDiplomacy@CvTreasury@@QAEXH@Z ; CvTreasury::SetGoldPerTurnFromDiplomacy

; 254  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ChangeGoldPerTurnFromDiplomacy@CvTreasury@@QAEXH@Z ENDP ; CvTreasury::ChangeGoldPerTurnFromDiplomacy
_TEXT	ENDS
PUBLIC	?GetCityConnectionTradeRouteGoldModifier@CvTreasury@@QBEHXZ ; CvTreasury::GetCityConnectionTradeRouteGoldModifier
PUBLIC	?GetCityConnectionTradeRouteGoldChange@CvTreasury@@QBEHXZ ; CvTreasury::GetCityConnectionTradeRouteGoldChange
PUBLIC	?GetCityConnectionRouteGoldTimes100@CvTreasury@@QBEHPAVCvCity@@@Z ; CvTreasury::GetCityConnectionRouteGoldTimes100
EXTRN	?getPopulation@CvCity@@QBEHXZ:PROC		; CvCity::getPopulation
EXTRN	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ:PROC	; CvPlayer::getCapitalCity
; Function compile flags: /Odtp
;	COMDAT ?GetCityConnectionRouteGoldTimes100@CvTreasury@@QBEHPAVCvCity@@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
_iTradeRouteCapitalGoldMultiplier$ = -20		; size = 4
_iTradeRouteCityGoldMultiplier$ = -16			; size = 4
_pCapitalCity$ = -12					; size = 4
_iTradeRouteBaseGold$ = -8				; size = 4
_iGold$ = -4						; size = 4
_pNonCapitalCity$ = 8					; size = 4
?GetCityConnectionRouteGoldTimes100@CvTreasury@@QBEHPAVCvCity@@@Z PROC ; CvTreasury::GetCityConnectionRouteGoldTimes100, COMDAT
; _this$ = ecx

; 258  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 259  : 	CvCity* pCapitalCity = m_pPlayer->getCapitalCity();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	DWORD PTR _pCapitalCity$[ebp], eax

; 260  : 	if(!pNonCapitalCity || pNonCapitalCity == pCapitalCity || pCapitalCity == NULL)

	cmp	DWORD PTR _pNonCapitalCity$[ebp], 0
	je	SHORT $LN2@GetCityCon
	mov	ecx, DWORD PTR _pNonCapitalCity$[ebp]
	cmp	ecx, DWORD PTR _pCapitalCity$[ebp]
	je	SHORT $LN2@GetCityCon
	cmp	DWORD PTR _pCapitalCity$[ebp], 0
	jne	SHORT $LN3@GetCityCon
$LN2@GetCityCon:

; 261  : 	{
; 262  : 		return 0;

	xor	eax, eax
	jmp	$LN4@GetCityCon
$LN3@GetCityCon:

; 263  : 	}
; 264  : 
; 265  : 	int iGold = 0;

	mov	DWORD PTR _iGold$[ebp], 0

; 266  : 
; 267  : 	int iTradeRouteBaseGold = /*100*/ GC.getTRADE_ROUTE_BASE_GOLD();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6536
	mov	DWORD PTR _iTradeRouteBaseGold$[ebp], edx

; 268  : 	int iTradeRouteCapitalGoldMultiplier = /*0*/ GC.getTRADE_ROUTE_CAPITAL_POP_GOLD_MULTIPLIER();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6540
	mov	DWORD PTR _iTradeRouteCapitalGoldMultiplier$[ebp], eax

; 269  : 	int iTradeRouteCityGoldMultiplier = /*125*/ GC.getTRADE_ROUTE_CITY_POP_GOLD_MULTIPLIER();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6544
	mov	DWORD PTR _iTradeRouteCityGoldMultiplier$[ebp], ecx

; 270  : 
; 271  : 	iGold += iTradeRouteBaseGold;	// Base Gold: 0

	mov	edx, DWORD PTR _iGold$[ebp]
	add	edx, DWORD PTR _iTradeRouteBaseGold$[ebp]
	mov	DWORD PTR _iGold$[ebp], edx

; 272  : 	iGold += (pCapitalCity->getPopulation() * iTradeRouteCapitalGoldMultiplier);	// Capital Multiplier

	mov	ecx, DWORD PTR _pCapitalCity$[ebp]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	imul	eax, DWORD PTR _iTradeRouteCapitalGoldMultiplier$[ebp]
	add	eax, DWORD PTR _iGold$[ebp]
	mov	DWORD PTR _iGold$[ebp], eax

; 273  : 	iGold += (pNonCapitalCity->getPopulation() * iTradeRouteCityGoldMultiplier);	// City Multiplier

	mov	ecx, DWORD PTR _pNonCapitalCity$[ebp]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	imul	eax, DWORD PTR _iTradeRouteCityGoldMultiplier$[ebp]
	add	eax, DWORD PTR _iGold$[ebp]
	mov	DWORD PTR _iGold$[ebp], eax

; 274  : 	iGold += GetCityConnectionTradeRouteGoldChange() * 100;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCityConnectionTradeRouteGoldChange@CvTreasury@@QBEHXZ ; CvTreasury::GetCityConnectionTradeRouteGoldChange
	imul	eax, 100				; 00000064H
	add	eax, DWORD PTR _iGold$[ebp]
	mov	DWORD PTR _iGold$[ebp], eax

; 275  : 
; 276  : 	if(GetCityConnectionTradeRouteGoldModifier() != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCityConnectionTradeRouteGoldModifier@CvTreasury@@QBEHXZ ; CvTreasury::GetCityConnectionTradeRouteGoldModifier
	test	eax, eax
	je	SHORT $LN1@GetCityCon

; 277  : 	{
; 278  : 		iGold *= (100 + GetCityConnectionTradeRouteGoldModifier());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCityConnectionTradeRouteGoldModifier@CvTreasury@@QBEHXZ ; CvTreasury::GetCityConnectionTradeRouteGoldModifier
	add	eax, 100				; 00000064H
	imul	eax, DWORD PTR _iGold$[ebp]
	mov	DWORD PTR _iGold$[ebp], eax

; 279  : 		iGold /= 100;

	mov	eax, DWORD PTR _iGold$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iGold$[ebp], eax
$LN1@GetCityCon:

; 280  : 	}
; 281  : 
; 282  : 	return iGold;

	mov	eax, DWORD PTR _iGold$[ebp]
$LN4@GetCityCon:

; 283  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetCityConnectionRouteGoldTimes100@CvTreasury@@QBEHPAVCvCity@@@Z ENDP ; CvTreasury::GetCityConnectionRouteGoldTimes100
_TEXT	ENDS
PUBLIC	?GetCityConnectionGold@CvTreasury@@QBEHXZ	; CvTreasury::GetCityConnectionGold
; Function compile flags: /Odtp
;	COMDAT ?GetCityConnectionGold@CvTreasury@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCityConnectionGold@CvTreasury@@QBEHXZ PROC		; CvTreasury::GetCityConnectionGold, COMDAT
; _this$ = ecx

; 288  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 289  : 	return m_iCityConnectionGoldTimes100 / 100;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+24]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx

; 290  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCityConnectionGold@CvTreasury@@QBEHXZ ENDP		; CvTreasury::GetCityConnectionGold
_TEXT	ENDS
PUBLIC	?GetCityConnectionGoldTimes100@CvTreasury@@QBEHXZ ; CvTreasury::GetCityConnectionGoldTimes100
; Function compile flags: /Odtp
;	COMDAT ?GetCityConnectionGoldTimes100@CvTreasury@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCityConnectionGoldTimes100@CvTreasury@@QBEHXZ PROC	; CvTreasury::GetCityConnectionGoldTimes100, COMDAT
; _this$ = ecx

; 294  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 295  : 	return m_iCityConnectionGoldTimes100;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+24]

; 296  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCityConnectionGoldTimes100@CvTreasury@@QBEHXZ ENDP	; CvTreasury::GetCityConnectionGoldTimes100
_TEXT	ENDS
PUBLIC	?HasCityConnectionRouteBetweenCities@CvTreasury@@QBE_NPAVCvCity@@0_N@Z ; CvTreasury::HasCityConnectionRouteBetweenCities
PUBLIC	?DoUpdateCityConnectionGold@CvTreasury@@QAEXXZ	; CvTreasury::DoUpdateCityConnectionGold
EXTRN	?getNumCities@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getNumCities
; Function compile flags: /Odtp
;	COMDAT ?DoUpdateCityConnectionGold@CvTreasury@@QAEXXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_pLoopCity$217198 = -16					; size = 4
_iLoop$217199 = -12					; size = 4
_iNumGold$ = -8						; size = 4
_pCapitalCity$ = -4					; size = 4
?DoUpdateCityConnectionGold@CvTreasury@@QAEXXZ PROC	; CvTreasury::DoUpdateCityConnectionGold, COMDAT
; _this$ = ecx

; 300  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 301  : 	int iNumGold = 0;

	mov	DWORD PTR _iNumGold$[ebp], 0

; 302  : 
; 303  : 	CvCity* pCapitalCity = m_pPlayer->getCapitalCity();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	DWORD PTR _pCapitalCity$[ebp], eax

; 304  : 
; 305  : 	// Must have a capital before we can check if other Cities are connected to it!
; 306  : 	if(pCapitalCity != NULL && m_pPlayer->getNumCities() > 1)

	cmp	DWORD PTR _pCapitalCity$[ebp], 0
	je	SHORT $LN6@DoUpdateCi
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	cmp	eax, 1
	jle	SHORT $LN6@DoUpdateCi

; 307  : 	{
; 308  : 		CvCity* pLoopCity;
; 309  : 
; 310  : 		int iLoop;
; 311  : 		for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	push	0
	lea	edx, DWORD PTR _iLoop$217199[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$217198[ebp], eax
	jmp	SHORT $LN5@DoUpdateCi
$LN4@DoUpdateCi:
	push	0
	lea	ecx, DWORD PTR _iLoop$217199[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$217198[ebp], eax
$LN5@DoUpdateCi:
	cmp	DWORD PTR _pLoopCity$217198[ebp], 0
	je	SHORT $LN6@DoUpdateCi

; 312  : 		{
; 313  : 			if(pLoopCity != pCapitalCity)

	mov	eax, DWORD PTR _pLoopCity$217198[ebp]
	cmp	eax, DWORD PTR _pCapitalCity$[ebp]
	je	SHORT $LN2@DoUpdateCi

; 314  : 			{
; 315  : 				if(HasCityConnectionRouteBetweenCities(pCapitalCity, pLoopCity))

	push	0
	mov	ecx, DWORD PTR _pLoopCity$217198[ebp]
	push	ecx
	mov	edx, DWORD PTR _pCapitalCity$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasCityConnectionRouteBetweenCities@CvTreasury@@QBE_NPAVCvCity@@0_N@Z ; CvTreasury::HasCityConnectionRouteBetweenCities
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@DoUpdateCi

; 316  : 				{
; 317  : 					iNumGold += GetCityConnectionRouteGoldTimes100(pLoopCity);

	mov	ecx, DWORD PTR _pLoopCity$217198[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCityConnectionRouteGoldTimes100@CvTreasury@@QBEHPAVCvCity@@@Z ; CvTreasury::GetCityConnectionRouteGoldTimes100
	add	eax, DWORD PTR _iNumGold$[ebp]
	mov	DWORD PTR _iNumGold$[ebp], eax
$LN2@DoUpdateCi:

; 318  : 				}
; 319  : 			}
; 320  : 		}

	jmp	SHORT $LN4@DoUpdateCi
$LN6@DoUpdateCi:

; 321  : 	}
; 322  : 
; 323  : 	m_iCityConnectionGoldTimes100 = iNumGold;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iNumGold$[ebp]
	mov	DWORD PTR [edx+24], eax

; 324  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DoUpdateCityConnectionGold@CvTreasury@@QAEXXZ ENDP	; CvTreasury::DoUpdateCityConnectionGold
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetCityConnectionTradeRouteGoldModifier@CvTreasury@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCityConnectionTradeRouteGoldModifier@CvTreasury@@QBEHXZ PROC ; CvTreasury::GetCityConnectionTradeRouteGoldModifier, COMDAT
; _this$ = ecx

; 329  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 330  : 	return m_iCityConnectionTradeRouteGoldModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+28]

; 331  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCityConnectionTradeRouteGoldModifier@CvTreasury@@QBEHXZ ENDP ; CvTreasury::GetCityConnectionTradeRouteGoldModifier
_TEXT	ENDS
PUBLIC	?ChangeCityConnectionTradeRouteGoldModifier@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeCityConnectionTradeRouteGoldModifier
; Function compile flags: /Odtp
;	COMDAT ?ChangeCityConnectionTradeRouteGoldModifier@CvTreasury@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?ChangeCityConnectionTradeRouteGoldModifier@CvTreasury@@QAEXH@Z PROC ; CvTreasury::ChangeCityConnectionTradeRouteGoldModifier, COMDAT
; _this$ = ecx

; 335  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 336  : 	if(iChange != 0)

	cmp	DWORD PTR _iChange$[ebp], 0
	je	SHORT $LN2@ChangeCity

; 337  : 	{
; 338  : 		m_iCityConnectionTradeRouteGoldModifier += iChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], ecx

; 339  : 
; 340  : 		DoUpdateCityConnectionGold();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoUpdateCityConnectionGold@CvTreasury@@QAEXXZ ; CvTreasury::DoUpdateCityConnectionGold
$LN2@ChangeCity:

; 341  : 	}
; 342  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ChangeCityConnectionTradeRouteGoldModifier@CvTreasury@@QAEXH@Z ENDP ; CvTreasury::ChangeCityConnectionTradeRouteGoldModifier
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetCityConnectionTradeRouteGoldChange@CvTreasury@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCityConnectionTradeRouteGoldChange@CvTreasury@@QBEHXZ PROC ; CvTreasury::GetCityConnectionTradeRouteGoldChange, COMDAT
; _this$ = ecx

; 346  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 347  : 	return m_iCityConnectionTradeRouteGoldChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+32]

; 348  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCityConnectionTradeRouteGoldChange@CvTreasury@@QBEHXZ ENDP ; CvTreasury::GetCityConnectionTradeRouteGoldChange
_TEXT	ENDS
PUBLIC	?ChangeCityConnectionTradeRouteGoldChange@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeCityConnectionTradeRouteGoldChange
; Function compile flags: /Odtp
;	COMDAT ?ChangeCityConnectionTradeRouteGoldChange@CvTreasury@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?ChangeCityConnectionTradeRouteGoldChange@CvTreasury@@QAEXH@Z PROC ; CvTreasury::ChangeCityConnectionTradeRouteGoldChange, COMDAT
; _this$ = ecx

; 352  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 353  : 	if(iChange != 0)

	cmp	DWORD PTR _iChange$[ebp], 0
	je	SHORT $LN2@ChangeCity@2

; 354  : 	{
; 355  : 		m_iCityConnectionTradeRouteGoldChange += iChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], ecx

; 356  : 
; 357  : 		DoUpdateCityConnectionGold();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoUpdateCityConnectionGold@CvTreasury@@QAEXXZ ; CvTreasury::DoUpdateCityConnectionGold
$LN2@ChangeCity@2:

; 358  : 	}
; 359  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ChangeCityConnectionTradeRouteGoldChange@CvTreasury@@QAEXH@Z ENDP ; CvTreasury::ChangeCityConnectionTradeRouteGoldChange
_TEXT	ENDS
EXTRN	?GetRouteInfo@CvCityConnections@@QAEPAURouteInfo@1@II@Z:PROC ; CvCityConnections::GetRouteInfo
EXTRN	?GetPlotIndex@CvPlot@@QBEHXZ:PROC		; CvPlot::GetPlotIndex
EXTRN	?plot@CvCity@@QBEPAVCvPlot@@XZ:PROC		; CvCity::plot
EXTRN	?GetCityConnections@CvPlayer@@QBEPAVCvCityConnections@@XZ:PROC ; CvPlayer::GetCityConnections
; Function compile flags: /Odtp
;	COMDAT ?HasCityConnectionRouteBetweenCities@CvTreasury@@QBE_NPAVCvCity@@0_N@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T219110 = -32						; size = 4
$T219106 = -28						; size = 4
$T219102 = -24						; size = 4
_ui$217234 = -20					; size = 4
_iFirstCityIndex$ = -16					; size = 4
_iSecondCityIndex$ = -12				; size = 4
_pRouteInfo$ = -8					; size = 4
_pCityConnections$ = -4					; size = 4
_pFirstCity$ = 8					; size = 4
_pSecondCity$ = 12					; size = 4
_bBestRoute$ = 16					; size = 1
?HasCityConnectionRouteBetweenCities@CvTreasury@@QBE_NPAVCvCity@@0_N@Z PROC ; CvTreasury::HasCityConnectionRouteBetweenCities, COMDAT
; _this$ = ecx

; 363  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 364  : 	CvCityConnections* pCityConnections = m_pPlayer->GetCityConnections();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetCityConnections@CvPlayer@@QBEPAVCvCityConnections@@XZ ; CvPlayer::GetCityConnections
	mov	DWORD PTR _pCityConnections$[ebp], eax

; 365  : 	FASSERT(pCityConnections, "m_pCityConnections is null");
; 366  : 	if(!pCityConnections)

	cmp	DWORD PTR _pCityConnections$[ebp], 0
	jne	SHORT $LN15@HasCityCon

; 367  : 	{
; 368  : 		// invalid value
; 369  : 		return FALSE;

	xor	al, al
	jmp	$LN16@HasCityCon
$LN15@HasCityCon:

; 370  : 	}
; 371  : 
; 372  : 	FASSERT(pFirstCity, "pFirstCity is null. Invalid!");
; 373  : 	FASSERT(pSecondCity, "pSecondCity is null. Invalid!");
; 374  : 	if(!pFirstCity || !pSecondCity)

	cmp	DWORD PTR _pFirstCity$[ebp], 0
	je	SHORT $LN13@HasCityCon
	cmp	DWORD PTR _pSecondCity$[ebp], 0
	jne	SHORT $LN14@HasCityCon
$LN13@HasCityCon:

; 375  : 	{
; 376  : 		// null city passed in
; 377  : 		return FALSE;

	xor	al, al
	jmp	$LN16@HasCityCon
$LN14@HasCityCon:

; 378  : 	}
; 379  : 
; 380  : 	FASSERT(pFirstCity != pSecondCity, "Cities are the same and are by default connected?");
; 381  : 	if(pFirstCity == pSecondCity)

	mov	ecx, DWORD PTR _pFirstCity$[ebp]
	cmp	ecx, DWORD PTR _pSecondCity$[ebp]
	jne	SHORT $LN12@HasCityCon

; 382  : 	{
; 383  : 		// trying to go to the same city
; 384  : 		return FALSE;

	xor	al, al
	jmp	$LN16@HasCityCon
$LN12@HasCityCon:

; 385  : 	}
; 386  : 
; 387  : 	int iFirstCityIndex = -1;

	mov	DWORD PTR _iFirstCityIndex$[ebp], -1

; 388  : 	int iSecondCityIndex = -1;

	mov	DWORD PTR _iSecondCityIndex$[ebp], -1

; 389  : 	for(uint ui = 0; ui < pCityConnections->m_aiCityPlotIDs.size(); ui++)

	mov	DWORD PTR _ui$217234[ebp], 0
	jmp	SHORT $LN11@HasCityCon
$LN10@HasCityCon:
	mov	edx, DWORD PTR _ui$217234[ebp]
	add	edx, 1
	mov	DWORD PTR _ui$217234[ebp], edx
$LN11@HasCityCon:
	mov	eax, DWORD PTR _pCityConnections$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR $T219102[ebp], ecx
	mov	edx, DWORD PTR _ui$217234[ebp]
	cmp	edx, DWORD PTR $T219102[ebp]
	jae	SHORT $LN9@HasCityCon

; 390  : 	{
; 391  : 		if(pFirstCity->plot()->GetPlotIndex() == pCityConnections->m_aiCityPlotIDs[ui])

	mov	eax, DWORD PTR _pCityConnections$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _ui$217234[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T219106[ebp], eax
	mov	ecx, DWORD PTR _pFirstCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	ecx, eax
	call	?GetPlotIndex@CvPlot@@QBEHXZ		; CvPlot::GetPlotIndex
	mov	ecx, DWORD PTR $T219106[ebp]
	cmp	eax, DWORD PTR [ecx]
	jne	SHORT $LN8@HasCityCon

; 392  : 		{
; 393  : 			iFirstCityIndex = ui;

	mov	edx, DWORD PTR _ui$217234[ebp]
	mov	DWORD PTR _iFirstCityIndex$[ebp], edx
$LN8@HasCityCon:

; 394  : 		}
; 395  : 
; 396  : 		if(pSecondCity->plot()->GetPlotIndex() == pCityConnections->m_aiCityPlotIDs[ui])

	mov	eax, DWORD PTR _pCityConnections$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _ui$217234[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T219110[ebp], eax
	mov	ecx, DWORD PTR _pSecondCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	ecx, eax
	call	?GetPlotIndex@CvPlot@@QBEHXZ		; CvPlot::GetPlotIndex
	mov	ecx, DWORD PTR $T219110[ebp]
	cmp	eax, DWORD PTR [ecx]
	jne	SHORT $LN7@HasCityCon

; 397  : 		{
; 398  : 			iSecondCityIndex = ui;

	mov	edx, DWORD PTR _ui$217234[ebp]
	mov	DWORD PTR _iSecondCityIndex$[ebp], edx
$LN7@HasCityCon:

; 399  : 		}
; 400  : 
; 401  : 		if(iFirstCityIndex >= 0 && iSecondCityIndex >= 0)

	cmp	DWORD PTR _iFirstCityIndex$[ebp], 0
	jl	SHORT $LN6@HasCityCon
	cmp	DWORD PTR _iSecondCityIndex$[ebp], 0
	jl	SHORT $LN6@HasCityCon

; 402  : 		{
; 403  : 			break;

	jmp	SHORT $LN9@HasCityCon
$LN6@HasCityCon:

; 404  : 		}
; 405  : 	}

	jmp	SHORT $LN10@HasCityCon
$LN9@HasCityCon:

; 406  : 
; 407  : 	if(iFirstCityIndex < 0 || iSecondCityIndex < 0)

	cmp	DWORD PTR _iFirstCityIndex$[ebp], 0
	jl	SHORT $LN4@HasCityCon
	cmp	DWORD PTR _iSecondCityIndex$[ebp], 0
	jge	SHORT $LN5@HasCityCon
$LN4@HasCityCon:

; 408  : 	{
; 409  : 		// did not find one or both of the cities
; 410  : 		return FALSE;

	xor	al, al
	jmp	SHORT $LN16@HasCityCon
$LN5@HasCityCon:

; 411  : 	}
; 412  : 
; 413  : 	CvCityConnections::RouteInfo* pRouteInfo = pCityConnections->GetRouteInfo(iFirstCityIndex, iSecondCityIndex);

	mov	eax, DWORD PTR _iSecondCityIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iFirstCityIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pCityConnections$[ebp]
	call	?GetRouteInfo@CvCityConnections@@QAEPAURouteInfo@1@II@Z ; CvCityConnections::GetRouteInfo
	mov	DWORD PTR _pRouteInfo$[ebp], eax

; 414  : 	if(pRouteInfo)

	cmp	DWORD PTR _pRouteInfo$[ebp], 0
	je	SHORT $LN3@HasCityCon

; 415  : 	{
; 416  : 		if(bBestRoute)

	movzx	edx, BYTE PTR _bBestRoute$[ebp]
	test	edx, edx
	je	SHORT $LN2@HasCityCon

; 417  : 		{
; 418  : 			return pRouteInfo->m_cRouteState & CvCityConnections::HAS_BEST_ROUTE;

	mov	eax, DWORD PTR _pRouteInfo$[ebp]
	movsx	ecx, BYTE PTR [eax]
	and	ecx, 4
	setne	al
	jmp	SHORT $LN16@HasCityCon

; 419  : 		}
; 420  : 		else

	jmp	SHORT $LN3@HasCityCon
$LN2@HasCityCon:

; 421  : 		{
; 422  : 			return pRouteInfo->m_cRouteState & CvCityConnections::HAS_ANY_ROUTE;

	mov	edx, DWORD PTR _pRouteInfo$[ebp]
	movsx	eax, BYTE PTR [edx]
	and	eax, 1
	jmp	SHORT $LN16@HasCityCon
$LN3@HasCityCon:

; 423  : 		}
; 424  : 	}
; 425  : 
; 426  : 	return FALSE;

	xor	al, al
$LN16@HasCityCon:

; 427  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?HasCityConnectionRouteBetweenCities@CvTreasury@@QBE_NPAVCvCity@@0_N@Z ENDP ; CvTreasury::HasCityConnectionRouteBetweenCities
_TEXT	ENDS
PUBLIC	?GetGoldPerTurnFromTradeRoutes@CvTreasury@@QBEHXZ ; CvTreasury::GetGoldPerTurnFromTradeRoutes
; Function compile flags: /Odtp
;	COMDAT ?GetGoldPerTurnFromTradeRoutes@CvTreasury@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGoldPerTurnFromTradeRoutes@CvTreasury@@QBEHXZ PROC	; CvTreasury::GetGoldPerTurnFromTradeRoutes, COMDAT
; _this$ = ecx

; 431  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 432  : 	// needs fixin
; 433  : 	return 0;

	xor	eax, eax

; 434  : 	//return GetGoldPerTurnFromTradeRoutesTimes100() / 100;
; 435  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGoldPerTurnFromTradeRoutes@CvTreasury@@QBEHXZ ENDP	; CvTreasury::GetGoldPerTurnFromTradeRoutes
_TEXT	ENDS
PUBLIC	?GetGoldPerTurnFromTradeRoutesTimes100@CvTreasury@@QBEHXZ ; CvTreasury::GetGoldPerTurnFromTradeRoutesTimes100
; Function compile flags: /Odtp
;	COMDAT ?GetGoldPerTurnFromTradeRoutesTimes100@CvTreasury@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGoldPerTurnFromTradeRoutesTimes100@CvTreasury@@QBEHXZ PROC ; CvTreasury::GetGoldPerTurnFromTradeRoutesTimes100, COMDAT
; _this$ = ecx

; 439  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 440  : 	return 0;

	xor	eax, eax

; 441  : 	//return m_pPlayer->GetTrade()->GetAllTradeValueTimes100(YIELD_GOLD);
; 442  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGoldPerTurnFromTradeRoutesTimes100@CvTreasury@@QBEHXZ ENDP ; CvTreasury::GetGoldPerTurnFromTradeRoutesTimes100
_TEXT	ENDS
PUBLIC	?GetGoldPerTurnFromTraits@CvTreasury@@QBEHXZ	; CvTreasury::GetGoldPerTurnFromTraits
EXTRN	?GetNumDifferentTradingPartners@CvPlayerTrade@@QAEHXZ:PROC ; CvPlayerTrade::GetNumDifferentTradingPartners
EXTRN	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ:PROC ; CvPlayer::GetTrade
EXTRN	?GetCurrentEra@CvPlayer@@QBE?AW4EraTypes@@XZ:PROC ; CvPlayer::GetCurrentEra
EXTRN	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ:PROC ; CvPlayer::GetPlayerTraits
; Function compile flags: /Odtp
;	COMDAT ?GetGoldPerTurnFromTraits@CvTreasury@@QBEHXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T219120 = -8						; size = 4
_bonus$ = -4						; size = 4
?GetGoldPerTurnFromTraits@CvTreasury@@QBEHXZ PROC	; CvTreasury::GetGoldPerTurnFromTraits, COMDAT
; _this$ = ecx

; 446  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 447  : 	// NQMP GJS - Morocco UA Gateway To Africa now scales with era BEGIN TradePartnerYieldFlatBonusPerEra
; 448  : 	int bonus = m_pPlayer->GetPlayerTraits()->GetYieldChangePerTradePartner(YIELD_GOLD);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T219120[ebp], eax
	mov	ecx, 2
	shl	ecx, 2
	mov	edx, DWORD PTR $T219120[ebp]
	mov	eax, DWORD PTR [edx+ecx+504]
	mov	DWORD PTR _bonus$[ebp], eax

; 449  : 	if (bonus > 0) // temp fix since the GetTradePartnerYieldFlatBonusPerEra() stat is currently hard-coded to return 1 instead of reading from SQL

	cmp	DWORD PTR _bonus$[ebp], 0
	jle	SHORT $LN1@GetGoldPer

; 450  : 	{
; 451  : 		bonus += m_pPlayer->GetPlayerTraits()->GetTradePartnerYieldFlatBonusPerEra() * m_pPlayer->GetCurrentEra();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?GetCurrentEra@CvPlayer@@QBE?AW4EraTypes@@XZ ; CvPlayer::GetCurrentEra
	imul	eax, 1
	add	eax, DWORD PTR _bonus$[ebp]
	mov	DWORD PTR _bonus$[ebp], eax

; 452  : 		bonus *= m_pPlayer->GetTrade()->GetNumDifferentTradingPartners();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	ecx, eax
	call	?GetNumDifferentTradingPartners@CvPlayerTrade@@QAEHXZ ; CvPlayerTrade::GetNumDifferentTradingPartners
	imul	eax, DWORD PTR _bonus$[ebp]
	mov	DWORD PTR _bonus$[ebp], eax
$LN1@GetGoldPer:

; 453  : 	}
; 454  : 	return bonus;

	mov	eax, DWORD PTR _bonus$[ebp]

; 455  : 	//return m_pPlayer->GetPlayerTraits()->GetYieldChangePerTradePartner(YIELD_GOLD) * m_pPlayer->GetTrade()->GetNumDifferentTradingPartners();
; 456  : 	// NQMP GJS - Morocco UA Gateway To Africa now scales with era END
; 457  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGoldPerTurnFromTraits@CvTreasury@@QBEHXZ ENDP	; CvTreasury::GetGoldPerTurnFromTraits
_TEXT	ENDS
PUBLIC	?GetGoldPerTurnFromReligion@CvTreasury@@QBEHXZ	; CvTreasury::GetGoldPerTurnFromReligion
EXTRN	?GetNumFollowers@CvGameReligions@@QBEHW4ReligionTypes@@@Z:PROC ; CvGameReligions::GetNumFollowers
EXTRN	?GetGoldPerXFollowers@CvReligionBeliefs@@QBEHXZ:PROC ; CvReligionBeliefs::GetGoldPerXFollowers
EXTRN	?GetNumCitiesFollowing@CvGameReligions@@QBEHW4ReligionTypes@@@Z:PROC ; CvGameReligions::GetNumCitiesFollowing
EXTRN	?GetGoldPerFollowingCity@CvReligionBeliefs@@QBEHXZ:PROC ; CvReligionBeliefs::GetGoldPerFollowingCity
EXTRN	?GetReligion@CvGameReligions@@QBEPBVCvReligion@@W4ReligionTypes@@W4PlayerTypes@@@Z:PROC ; CvGameReligions::GetReligion
EXTRN	?GetFounderBenefitsReligion@CvGameReligions@@QBE?AW4ReligionTypes@@W4PlayerTypes@@@Z:PROC ; CvGameReligions::GetFounderBenefitsReligion
EXTRN	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ:PROC ; CvGame::GetGameReligions
; Function compile flags: /Odtp
;	COMDAT ?GetGoldPerTurnFromReligion@CvTreasury@@QBEHXZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T219138 = -32						; size = 4
$T219129 = -28						; size = 4
_iGoldPerFollowingCity$217267 = -24			; size = 4
_iGoldPerXFollowers$217268 = -20			; size = 4
_pReligion$217265 = -16					; size = 4
_iGoldFromReligion$ = -12				; size = 4
_pReligions$ = -8					; size = 4
_eFoundedReligion$ = -4					; size = 4
?GetGoldPerTurnFromReligion@CvTreasury@@QBEHXZ PROC	; CvTreasury::GetGoldPerTurnFromReligion, COMDAT
; _this$ = ecx

; 461  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 462  : 	int iGoldFromReligion = 0;

	mov	DWORD PTR _iGoldFromReligion$[ebp], 0

; 463  : 
; 464  : 	CvGameReligions* pReligions = GC.getGame().GetGameReligions();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T219129[ebp], eax
	mov	ecx, DWORD PTR $T219129[ebp]
	call	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ ; CvGame::GetGameReligions
	mov	DWORD PTR _pReligions$[ebp], eax

; 465  : 
; 466  : 	// Founder beliefs
; 467  : 	ReligionTypes eFoundedReligion = pReligions->GetFounderBenefitsReligion(m_pPlayer->GetID());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T219138[ebp], eax
	mov	ecx, DWORD PTR $T219138[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pReligions$[ebp]
	call	?GetFounderBenefitsReligion@CvGameReligions@@QBE?AW4ReligionTypes@@W4PlayerTypes@@@Z ; CvGameReligions::GetFounderBenefitsReligion
	mov	DWORD PTR _eFoundedReligion$[ebp], eax

; 468  : 	if(eFoundedReligion != NO_RELIGION)

	cmp	DWORD PTR _eFoundedReligion$[ebp], -1
	je	SHORT $LN3@GetGoldPer@2

; 469  : 	{
; 470  : 		const CvReligion* pReligion = pReligions->GetReligion(eFoundedReligion, NO_PLAYER);

	push	-1
	mov	edx, DWORD PTR _eFoundedReligion$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pReligions$[ebp]
	call	?GetReligion@CvGameReligions@@QBEPBVCvReligion@@W4ReligionTypes@@W4PlayerTypes@@@Z ; CvGameReligions::GetReligion
	mov	DWORD PTR _pReligion$217265[ebp], eax

; 471  : 		if(pReligion)

	cmp	DWORD PTR _pReligion$217265[ebp], 0
	je	SHORT $LN3@GetGoldPer@2

; 472  : 		{
; 473  : 			int iGoldPerFollowingCity = pReligion->m_Beliefs.GetGoldPerFollowingCity();

	mov	ecx, DWORD PTR _pReligion$217265[ebp]
	add	ecx, 152				; 00000098H
	call	?GetGoldPerFollowingCity@CvReligionBeliefs@@QBEHXZ ; CvReligionBeliefs::GetGoldPerFollowingCity
	mov	DWORD PTR _iGoldPerFollowingCity$217267[ebp], eax

; 474  : 			iGoldFromReligion += (pReligions->GetNumCitiesFollowing(eFoundedReligion) * iGoldPerFollowingCity);

	mov	eax, DWORD PTR _eFoundedReligion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pReligions$[ebp]
	call	?GetNumCitiesFollowing@CvGameReligions@@QBEHW4ReligionTypes@@@Z ; CvGameReligions::GetNumCitiesFollowing
	imul	eax, DWORD PTR _iGoldPerFollowingCity$217267[ebp]
	add	eax, DWORD PTR _iGoldFromReligion$[ebp]
	mov	DWORD PTR _iGoldFromReligion$[ebp], eax

; 475  : 
; 476  : 			int iGoldPerXFollowers = pReligion->m_Beliefs.GetGoldPerXFollowers();

	mov	ecx, DWORD PTR _pReligion$217265[ebp]
	add	ecx, 152				; 00000098H
	call	?GetGoldPerXFollowers@CvReligionBeliefs@@QBEHXZ ; CvReligionBeliefs::GetGoldPerXFollowers
	mov	DWORD PTR _iGoldPerXFollowers$217268[ebp], eax

; 477  : 			if(iGoldPerXFollowers > 0)

	cmp	DWORD PTR _iGoldPerXFollowers$217268[ebp], 0
	jle	SHORT $LN3@GetGoldPer@2

; 478  : 			{
; 479  : 				iGoldFromReligion += (pReligions->GetNumFollowers(eFoundedReligion) / iGoldPerXFollowers);

	mov	ecx, DWORD PTR _eFoundedReligion$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pReligions$[ebp]
	call	?GetNumFollowers@CvGameReligions@@QBEHW4ReligionTypes@@@Z ; CvGameReligions::GetNumFollowers
	cdq
	idiv	DWORD PTR _iGoldPerXFollowers$217268[ebp]
	add	eax, DWORD PTR _iGoldFromReligion$[ebp]
	mov	DWORD PTR _iGoldFromReligion$[ebp], eax
$LN3@GetGoldPer@2:

; 480  : 			}
; 481  : 		}
; 482  : 	}
; 483  : 
; 484  : 	return iGoldFromReligion;

	mov	eax, DWORD PTR _iGoldFromReligion$[ebp]

; 485  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGoldPerTurnFromReligion@CvTreasury@@QBEHXZ ENDP	; CvTreasury::GetGoldPerTurnFromReligion
_TEXT	ENDS
PUBLIC	?CalculateGrossGoldTimes100@CvTreasury@@QAEHXZ	; CvTreasury::CalculateGrossGoldTimes100
; Function compile flags: /Odtp
;	COMDAT ?CalculateGrossGold@CvTreasury@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CalculateGrossGold@CvTreasury@@QAEHXZ PROC		; CvTreasury::CalculateGrossGold, COMDAT
; _this$ = ecx

; 489  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 490  : 	return CalculateGrossGoldTimes100() / 100;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateGrossGoldTimes100@CvTreasury@@QAEHXZ ; CvTreasury::CalculateGrossGoldTimes100
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx

; 491  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CalculateGrossGold@CvTreasury@@QAEHXZ ENDP		; CvTreasury::CalculateGrossGold
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?CalculateGrossGoldTimes100@CvTreasury@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_iNetGold$ = -4						; size = 4
?CalculateGrossGoldTimes100@CvTreasury@@QAEHXZ PROC	; CvTreasury::CalculateGrossGoldTimes100, COMDAT
; _this$ = ecx

; 495  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 496  : 	int iNetGold;
; 497  : 
; 498  : 	// Gold from Cities
; 499  : 	iNetGold = GetGoldFromCitiesTimes100();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetGoldFromCitiesTimes100@CvTreasury@@QBEH_N@Z ; CvTreasury::GetGoldFromCitiesTimes100
	mov	DWORD PTR _iNetGold$[ebp], eax

; 500  : 
; 501  : 	// Gold per Turn from Diplomacy
; 502  : 	iNetGold += GetGoldPerTurnFromDiplomacy() * 100;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetGoldPerTurnFromDiplomacy@CvTreasury@@QBEHXZ ; CvTreasury::GetGoldPerTurnFromDiplomacy
	imul	eax, 100				; 00000064H
	add	eax, DWORD PTR _iNetGold$[ebp]
	mov	DWORD PTR _iNetGold$[ebp], eax

; 503  : 
; 504  : 	// City connection bonuses
; 505  : 	iNetGold += GetCityConnectionGoldTimes100();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCityConnectionGoldTimes100@CvTreasury@@QBEHXZ ; CvTreasury::GetCityConnectionGoldTimes100
	add	eax, DWORD PTR _iNetGold$[ebp]
	mov	DWORD PTR _iNetGold$[ebp], eax

; 506  : 
; 507  : 	// Religion
; 508  : 	iNetGold += GetGoldPerTurnFromReligion() * 100;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetGoldPerTurnFromReligion@CvTreasury@@QBEHXZ ; CvTreasury::GetGoldPerTurnFromReligion
	imul	eax, 100				; 00000064H
	add	eax, DWORD PTR _iNetGold$[ebp]
	mov	DWORD PTR _iNetGold$[ebp], eax

; 509  : 
; 510  : 	// International trade
; 511  : 	iNetGold += GetGoldPerTurnFromTraits() * 100;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetGoldPerTurnFromTraits@CvTreasury@@QBEHXZ ; CvTreasury::GetGoldPerTurnFromTraits
	imul	eax, 100				; 00000064H
	add	eax, DWORD PTR _iNetGold$[ebp]
	mov	DWORD PTR _iNetGold$[ebp], eax

; 512  : 
; 513  : 	return iNetGold;

	mov	eax, DWORD PTR _iNetGold$[ebp]

; 514  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CalculateGrossGoldTimes100@CvTreasury@@QAEHXZ ENDP	; CvTreasury::CalculateGrossGoldTimes100
_TEXT	ENDS
PUBLIC	?GetLifetimeGrossGold@CvTreasury@@QAEHXZ	; CvTreasury::GetLifetimeGrossGold
; Function compile flags: /Odtp
;	COMDAT ?GetLifetimeGrossGold@CvTreasury@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLifetimeGrossGold@CvTreasury@@QAEHXZ PROC		; CvTreasury::GetLifetimeGrossGold, COMDAT
; _this$ = ecx

; 518  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 519  : 	return m_iLifetimeGrossGoldIncome;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+44]

; 520  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetLifetimeGrossGold@CvTreasury@@QAEHXZ ENDP		; CvTreasury::GetLifetimeGrossGold
_TEXT	ENDS
PUBLIC	?CalculateBaseNetGoldTimes100@CvTreasury@@QAEHXZ ; CvTreasury::CalculateBaseNetGoldTimes100
PUBLIC	?CalculateBaseNetGold@CvTreasury@@QAEHXZ	; CvTreasury::CalculateBaseNetGold
; Function compile flags: /Odtp
;	COMDAT ?CalculateBaseNetGold@CvTreasury@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CalculateBaseNetGold@CvTreasury@@QAEHXZ PROC		; CvTreasury::CalculateBaseNetGold, COMDAT
; _this$ = ecx

; 524  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 525  : 	return CalculateBaseNetGoldTimes100() / 100;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateBaseNetGoldTimes100@CvTreasury@@QAEHXZ ; CvTreasury::CalculateBaseNetGoldTimes100
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx

; 526  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CalculateBaseNetGold@CvTreasury@@QAEHXZ ENDP		; CvTreasury::CalculateBaseNetGold
_TEXT	ENDS
PUBLIC	?CalculateInflatedCosts@CvTreasury@@QAEHXZ	; CvTreasury::CalculateInflatedCosts
; Function compile flags: /Odtp
;	COMDAT ?CalculateBaseNetGoldTimes100@CvTreasury@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_iNetGold$ = -4						; size = 4
?CalculateBaseNetGoldTimes100@CvTreasury@@QAEHXZ PROC	; CvTreasury::CalculateBaseNetGoldTimes100, COMDAT
; _this$ = ecx

; 530  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 531  : 	int iNetGold = CalculateGrossGoldTimes100();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateGrossGoldTimes100@CvTreasury@@QAEHXZ ; CvTreasury::CalculateGrossGoldTimes100
	mov	DWORD PTR _iNetGold$[ebp], eax

; 532  : 
; 533  : 	// Remove costs
; 534  : 	iNetGold -= CalculateInflatedCosts() * 100;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateInflatedCosts@CvTreasury@@QAEHXZ ; CvTreasury::CalculateInflatedCosts
	imul	eax, 100				; 00000064H
	mov	ecx, DWORD PTR _iNetGold$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _iNetGold$[ebp], ecx

; 535  : 
; 536  : 	return iNetGold;

	mov	eax, DWORD PTR _iNetGold$[ebp]

; 537  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CalculateBaseNetGoldTimes100@CvTreasury@@QAEHXZ ENDP	; CvTreasury::CalculateBaseNetGoldTimes100
_TEXT	ENDS
PUBLIC	__real@4059000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	?CalculateUnitCost@CvTreasury@@QAEHAAH000@Z	; CvTreasury::CalculateUnitCost
EXTRN	?getAIUnitCostPercent@CvHandicapInfo@@QBEHXZ:PROC ; CvHandicapInfo::getAIUnitCostPercent
EXTRN	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ:PROC ; CvGame::getHandicapInfo
EXTRN	?IsAITeammateOfHuman@CvPlayer@@QBE_NXZ:PROC	; CvPlayer::IsAITeammateOfHuman
EXTRN	?getUnitCostPercent@CvHandicapInfo@@QBEHXZ:PROC	; CvHandicapInfo::getUnitCostPercent
EXTRN	?GetUnitGoldMaintenanceMod@CvPlayer@@QBEHXZ:PROC ; CvPlayer::GetUnitGoldMaintenanceMod
EXTRN	?getDefaultEstimateEndTurn@CvGame@@QBEHXZ:PROC	; CvGame::getDefaultEstimateEndTurn
EXTRN	?getElapsedGameTurns@CvGame@@QBEHXZ:PROC	; CvGame::getElapsedGameTurns
EXTRN	?getExtraUnitCost@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getExtraUnitCost
EXTRN	?GetNumUnitsWithUnitCombat@CvPlayer@@QAEHW4UnitCombatTypes@@@Z:PROC ; CvPlayer::GetNumUnitsWithUnitCombat
EXTRN	?GetMaintenanceModifierUnitCombat@CvPlayerTraits@@QBEHH@Z:PROC ; CvPlayerTraits::GetMaintenanceModifierUnitCombat
EXTRN	?getUnitCombatClassInfo@CvGlobals@@QAEPAVCvBaseInfo@@W4UnitCombatTypes@@@Z:PROC ; CvGlobals::getUnitCombatClassInfo
EXTRN	?getNumUnitCombatClassInfos@CvGlobals@@QAEHXZ:PROC ; CvGlobals::getNumUnitCombatClassInfos
EXTRN	?GetNumUnitsWithDomain@CvPlayer@@QAEHW4DomainTypes@@_N@Z:PROC ; CvPlayer::GetNumUnitsWithDomain
EXTRN	?getGoldPerUnitTimes100@CvPlayer@@QBEHXZ:PROC	; CvPlayer::getGoldPerUnitTimes100
EXTRN	?getNumUnits@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getNumUnits
EXTRN	?getBaseFreeUnits@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getBaseFreeUnits
EXTRN	?GetNumMaintenanceFreeUnits@CvPlayer@@QBEHW4DomainTypes@@_N@Z:PROC ; CvPlayer::GetNumMaintenanceFreeUnits
EXTRN	?getGoldFreeUnits@CvHandicapInfo@@QBEHXZ:PROC	; CvHandicapInfo::getGoldFreeUnits
EXTRN	?getHandicapInfo@CvPlayer@@QBEAAVCvHandicapInfo@@XZ:PROC ; CvPlayer::getHandicapInfo
EXTRN	__fltused:DWORD
EXTRN	___libm_sse2_pow:PROC
;	COMDAT __real@4059000000000000
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtreasury.cpp
CONST	ENDS
;	COMDAT ?CalculateUnitCost@CvTreasury@@QAEHAAH000@Z
_TEXT	SEGMENT
tv153 = -188						; size = 4
tv454 = -184						; size = 8
tv280 = -176						; size = 4
_this$ = -172						; size = 4
$T219197 = -168						; size = 4
$T219191 = -164						; size = 4
$T219187 = -160						; size = 4
$T219183 = -156						; size = 4
$T219179 = -152						; size = 4
$T219175 = -148						; size = 4
$T219171 = -144						; size = 4
$T219167 = -140						; size = 4
$T219160 = -136						; size = 4
$T219154 = -132						; size = 4
$T219153 = -128						; size = 4
$T219152 = -124						; size = 4
$T219151 = -120						; size = 4
_iModifiedCost$217321 = -116				; size = 4
_iNumUnits$217319 = -112				; size = 4
_iCost$217320 = -108					; size = 4
_iModifier$217317 = -104				; size = 4
_pkUnitCombatClassInfo$217315 = -100			; size = 4
_eUnitCombatClass$217313 = -96				; size = 4
_iI$217309 = -92					; size = 4
_iNavalUnits$217306 = -88				; size = 4
_iFreeNavalUnits$217307 = -84				; size = 4
_iPaidNavalUnits$217308 = -80				; size = 4
_iFreeLandUnits$217302 = -76				; size = 4
_iPaidLandUnits$217303 = -72				; size = 4
_iLandUnits$217301 = -68				; size = 4
_fMultiplyFactor$ = -64					; size = 8
_iLandUnitMod$ = -52					; size = 4
_fExponentialFactor$ = -48				; size = 8
_playerHandicap$ = -40					; size = 4
_iSupport$ = -36					; size = 4
_fGameProgressFactor$ = -32				; size = 8
_dFinalCost$ = -24					; size = 8
_iNavalUnitMod$ = -12					; size = 4
_fTempCost$ = -8					; size = 8
_iFreeUnits$ = 8					; size = 4
_iPaidUnits$ = 12					; size = 4
_iBaseUnitCost$ = 16					; size = 4
_iExtraCost$ = 20					; size = 4
?CalculateUnitCost@CvTreasury@@QAEHAAH000@Z PROC	; CvTreasury::CalculateUnitCost, COMDAT
; _this$ = ecx

; 542  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 188				; 000000bcH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 543  : 	// If player has 0 Cities then no Unit cost
; 544  : 	if(m_pPlayer->getNumCities() == 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	test	eax, eax
	jne	SHORT $LN12@CalculateU

; 545  : 	{
; 546  : 		return 0;

	xor	eax, eax
	jmp	$LN13@CalculateU
$LN12@CalculateU:

; 547  : 	}
; 548  : 
; 549  : 	int iSupport = 0;

	mov	DWORD PTR _iSupport$[ebp], 0

; 550  : 
; 551  : 	CvHandicapInfo& playerHandicap = m_pPlayer->getHandicapInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?getHandicapInfo@CvPlayer@@QBEAAVCvHandicapInfo@@XZ ; CvPlayer::getHandicapInfo
	mov	DWORD PTR _playerHandicap$[ebp], eax

; 552  : 	iFreeUnits = playerHandicap.getGoldFreeUnits();

	mov	ecx, DWORD PTR _playerHandicap$[ebp]
	call	?getGoldFreeUnits@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getGoldFreeUnits
	mov	edx, DWORD PTR _iFreeUnits$[ebp]
	mov	DWORD PTR [edx], eax

; 553  : 
; 554  : 	// Defined in XML by unit info type
; 555  : 	iFreeUnits += m_pPlayer->GetNumMaintenanceFreeUnits();

	push	0
	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetNumMaintenanceFreeUnits@CvPlayer@@QBEHW4DomainTypes@@_N@Z ; CvPlayer::GetNumMaintenanceFreeUnits
	mov	ecx, DWORD PTR _iFreeUnits$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR _iFreeUnits$[ebp]
	mov	DWORD PTR [edx], eax

; 556  : 	iFreeUnits += m_pPlayer->getBaseFreeUnits();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?getBaseFreeUnits@CvPlayer@@QBEHXZ	; CvPlayer::getBaseFreeUnits
	mov	ecx, DWORD PTR _iFreeUnits$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR _iFreeUnits$[ebp]
	mov	DWORD PTR [edx], eax

; 557  : 
; 558  : 	iPaidUnits = max(0, m_pPlayer->getNumUnits() - iFreeUnits);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?getNumUnits@CvPlayer@@QBEHXZ		; CvPlayer::getNumUnits
	mov	ecx, DWORD PTR _iFreeUnits$[ebp]
	sub	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T219151[ebp], eax
	mov	DWORD PTR $T219152[ebp], 0
	mov	edx, DWORD PTR $T219152[ebp]
	cmp	edx, DWORD PTR $T219151[ebp]
	jge	SHORT $LN17@CalculateU
	lea	eax, DWORD PTR $T219151[ebp]
	mov	DWORD PTR tv280[ebp], eax
	jmp	SHORT $LN18@CalculateU
$LN17@CalculateU:
	lea	ecx, DWORD PTR $T219152[ebp]
	mov	DWORD PTR tv280[ebp], ecx
$LN18@CalculateU:
	mov	edx, DWORD PTR tv280[ebp]
	mov	DWORD PTR $T219160[ebp], edx
	mov	eax, DWORD PTR _iPaidUnits$[ebp]
	mov	ecx, DWORD PTR $T219160[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 559  : 
; 560  : 	iBaseUnitCost = iPaidUnits * m_pPlayer->getGoldPerUnitTimes100();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?getGoldPerUnitTimes100@CvPlayer@@QBEHXZ ; CvPlayer::getGoldPerUnitTimes100
	mov	ecx, DWORD PTR _iPaidUnits$[ebp]
	imul	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR _iBaseUnitCost$[ebp]
	mov	DWORD PTR [edx], eax

; 561  : 
; 562  : 	// Discount on land unit maintenance?
; 563  : 	int iLandUnitMod = m_pPlayer->GetPlayerTraits()->GetLandUnitMaintenanceModifier();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T219167[ebp], eax
	mov	ecx, DWORD PTR $T219167[ebp]
	mov	edx, DWORD PTR [ecx+248]
	mov	DWORD PTR _iLandUnitMod$[ebp], edx

; 564  : 	if(iLandUnitMod != 0)

	cmp	DWORD PTR _iLandUnitMod$[ebp], 0
	je	SHORT $LN11@CalculateU

; 565  : 	{
; 566  : 		int iLandUnits = m_pPlayer->GetNumUnitsWithDomain(DOMAIN_LAND, true /*bMilitaryOnly*/);

	push	1
	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetNumUnitsWithDomain@CvPlayer@@QAEHW4DomainTypes@@_N@Z ; CvPlayer::GetNumUnitsWithDomain
	mov	DWORD PTR _iLandUnits$217301[ebp], eax

; 567  : 		int iFreeLandUnits = m_pPlayer->GetNumMaintenanceFreeUnits(DOMAIN_LAND, true);

	push	1
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?GetNumMaintenanceFreeUnits@CvPlayer@@QBEHW4DomainTypes@@_N@Z ; CvPlayer::GetNumMaintenanceFreeUnits
	mov	DWORD PTR _iFreeLandUnits$217302[ebp], eax

; 568  : 		int iPaidLandUnits = iLandUnits - iFreeLandUnits;

	mov	edx, DWORD PTR _iLandUnits$217301[ebp]
	sub	edx, DWORD PTR _iFreeLandUnits$217302[ebp]
	mov	DWORD PTR _iPaidLandUnits$217303[ebp], edx

; 569  : 		iBaseUnitCost += (iLandUnitMod * iPaidLandUnits * m_pPlayer->getGoldPerUnitTimes100()) / 100;

	mov	esi, DWORD PTR _iLandUnitMod$[ebp]
	imul	esi, DWORD PTR _iPaidLandUnits$217303[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?getGoldPerUnitTimes100@CvPlayer@@QBEHXZ ; CvPlayer::getGoldPerUnitTimes100
	imul	eax, esi
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	edx, DWORD PTR _iBaseUnitCost$[ebp]
	add	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _iBaseUnitCost$[ebp]
	mov	DWORD PTR [ecx], eax
$LN11@CalculateU:

; 570  : 	}
; 571  : 
; 572  : 	// Discount on naval unit maintenance?
; 573  : 	int iNavalUnitMod = m_pPlayer->GetPlayerTraits()->GetNavalUnitMaintenanceModifier();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T219171[ebp], eax
	mov	eax, DWORD PTR $T219171[ebp]
	mov	ecx, DWORD PTR [eax+252]
	mov	DWORD PTR _iNavalUnitMod$[ebp], ecx

; 574  : 	if(iNavalUnitMod != 0)

	cmp	DWORD PTR _iNavalUnitMod$[ebp], 0
	je	SHORT $LN10@CalculateU

; 575  : 	{
; 576  : 		int iNavalUnits = m_pPlayer->GetNumUnitsWithDomain(DOMAIN_SEA, true /*bMilitaryOnly*/);

	push	1
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?GetNumUnitsWithDomain@CvPlayer@@QAEHW4DomainTypes@@_N@Z ; CvPlayer::GetNumUnitsWithDomain
	mov	DWORD PTR _iNavalUnits$217306[ebp], eax

; 577  : 		int iFreeNavalUnits = m_pPlayer->GetNumMaintenanceFreeUnits(DOMAIN_SEA, true);

	push	1
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetNumMaintenanceFreeUnits@CvPlayer@@QBEHW4DomainTypes@@_N@Z ; CvPlayer::GetNumMaintenanceFreeUnits
	mov	DWORD PTR _iFreeNavalUnits$217307[ebp], eax

; 578  : 		int iPaidNavalUnits = iNavalUnits - iFreeNavalUnits;

	mov	ecx, DWORD PTR _iNavalUnits$217306[ebp]
	sub	ecx, DWORD PTR _iFreeNavalUnits$217307[ebp]
	mov	DWORD PTR _iPaidNavalUnits$217308[ebp], ecx

; 579  : 		iBaseUnitCost += (iNavalUnitMod * iPaidNavalUnits * m_pPlayer->getGoldPerUnitTimes100()) / 100;

	mov	esi, DWORD PTR _iNavalUnitMod$[ebp]
	imul	esi, DWORD PTR _iPaidNavalUnits$217308[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?getGoldPerUnitTimes100@CvPlayer@@QBEHXZ ; CvPlayer::getGoldPerUnitTimes100
	imul	eax, esi
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	edx, DWORD PTR _iBaseUnitCost$[ebp]
	add	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _iBaseUnitCost$[ebp]
	mov	DWORD PTR [ecx], eax
$LN10@CalculateU:

; 580  : 	}
; 581  : 
; 582  : 	// Discounts for units of certain UnitCombat classes
; 583  : #ifdef AUI_WARNING_FIXES
; 584  : 	for (uint iI = 0; iI < GC.getNumUnitCombatClassInfos(); iI++)
; 585  : #else
; 586  : 	for(int iI = 0; iI < GC.getNumUnitCombatClassInfos(); iI++)

	mov	DWORD PTR _iI$217309[ebp], 0
	jmp	SHORT $LN9@CalculateU
$LN8@CalculateU:
	mov	edx, DWORD PTR _iI$217309[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$217309[ebp], edx
$LN9@CalculateU:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumUnitCombatClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumUnitCombatClassInfos
	cmp	DWORD PTR _iI$217309[ebp], eax
	jge	$LN7@CalculateU

; 587  : #endif
; 588  : 	{
; 589  : 		const UnitCombatTypes eUnitCombatClass = static_cast<UnitCombatTypes>(iI);

	mov	eax, DWORD PTR _iI$217309[ebp]
	mov	DWORD PTR _eUnitCombatClass$217313[ebp], eax

; 590  : 		CvBaseInfo* pkUnitCombatClassInfo = GC.getUnitCombatClassInfo(eUnitCombatClass);

	mov	ecx, DWORD PTR _eUnitCombatClass$217313[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitCombatClassInfo@CvGlobals@@QAEPAVCvBaseInfo@@W4UnitCombatTypes@@@Z ; CvGlobals::getUnitCombatClassInfo
	mov	DWORD PTR _pkUnitCombatClassInfo$217315[ebp], eax

; 591  : 		if(pkUnitCombatClassInfo)

	cmp	DWORD PTR _pkUnitCombatClassInfo$217315[ebp], 0
	je	$LN5@CalculateU

; 592  : 		{
; 593  : 			int iModifier = m_pPlayer->GetPlayerTraits()->GetMaintenanceModifierUnitCombat(eUnitCombatClass);

	mov	edx, DWORD PTR _eUnitCombatClass$217313[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	ecx, eax
	call	?GetMaintenanceModifierUnitCombat@CvPlayerTraits@@QBEHH@Z ; CvPlayerTraits::GetMaintenanceModifierUnitCombat
	mov	DWORD PTR _iModifier$217317[ebp], eax

; 594  : 			if (iModifier != 0)

	cmp	DWORD PTR _iModifier$217317[ebp], 0
	je	SHORT $LN5@CalculateU

; 595  : 			{
; 596  : 				int iNumUnits = m_pPlayer->GetNumUnitsWithUnitCombat(eUnitCombatClass);

	mov	ecx, DWORD PTR _eUnitCombatClass$217313[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?GetNumUnitsWithUnitCombat@CvPlayer@@QAEHW4UnitCombatTypes@@@Z ; CvPlayer::GetNumUnitsWithUnitCombat
	mov	DWORD PTR _iNumUnits$217319[ebp], eax

; 597  : 				int iCost = iNumUnits * m_pPlayer->getGoldPerUnitTimes100(); 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?getGoldPerUnitTimes100@CvPlayer@@QBEHXZ ; CvPlayer::getGoldPerUnitTimes100
	imul	eax, DWORD PTR _iNumUnits$217319[ebp]
	mov	DWORD PTR _iCost$217320[ebp], eax

; 598  : 				int iModifiedCost = iNumUnits * m_pPlayer->getGoldPerUnitTimes100() * (100 + iModifier) / 100; 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?getGoldPerUnitTimes100@CvPlayer@@QBEHXZ ; CvPlayer::getGoldPerUnitTimes100
	imul	eax, DWORD PTR _iNumUnits$217319[ebp]
	mov	edx, DWORD PTR _iModifier$217317[ebp]
	add	edx, 100				; 00000064H
	imul	eax, edx
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iModifiedCost$217321[ebp], eax

; 599  : 				
; 600  : 				// Reduce cost based on difference
; 601  : 				iBaseUnitCost += (iModifiedCost - iCost);

	mov	edx, DWORD PTR _iModifiedCost$217321[ebp]
	sub	edx, DWORD PTR _iCost$217320[ebp]
	mov	eax, DWORD PTR _iBaseUnitCost$[ebp]
	add	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _iBaseUnitCost$[ebp]
	mov	DWORD PTR [ecx], edx
$LN5@CalculateU:

; 602  : 			}
; 603  : 		}
; 604  : 	}

	jmp	$LN8@CalculateU
$LN7@CalculateU:

; 605  : 
; 606  : 	iExtraCost = m_pPlayer->getExtraUnitCost() * 100;	// In hundreds to avoid rounding errors

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?getExtraUnitCost@CvPlayer@@QBEHXZ	; CvPlayer::getExtraUnitCost
	imul	eax, 100				; 00000064H
	mov	ecx, DWORD PTR _iExtraCost$[ebp]
	mov	DWORD PTR [ecx], eax

; 607  : 
; 608  : 	iSupport = iBaseUnitCost + iExtraCost;

	mov	edx, DWORD PTR _iBaseUnitCost$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _iExtraCost$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR _iSupport$[ebp], eax

; 609  : 
; 610  : 	// Game progress factor ranges from 0.0 to 1.0 based on how far into the game we are
; 611  : 	double fGameProgressFactor = double(GC.getGame().getElapsedGameTurns()) / GC.getGame().getDefaultEstimateEndTurn();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T219175[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T219179[ebp], eax
	mov	ecx, DWORD PTR $T219175[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	cvtsi2sd xmm0, eax
	mov	ecx, DWORD PTR $T219179[ebp]
	movsd	QWORD PTR tv454[ebp], xmm0
	call	?getDefaultEstimateEndTurn@CvGame@@QBEHXZ ; CvGame::getDefaultEstimateEndTurn
	cvtsi2sd xmm0, eax
	movsd	xmm1, QWORD PTR tv454[ebp]
	divsd	xmm1, xmm0
	movsd	QWORD PTR _fGameProgressFactor$[ebp], xmm1

; 612  : 
; 613  : 	// Multiplicative increase - helps scale costs as game goes on - the HIGHER this number the more is paid
; 614  : 	double fMultiplyFactor = 1.0 + (fGameProgressFactor* /*8*/ GC.getUNIT_MAINTENANCE_GAME_MULTIPLIER());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6524
	mov	DWORD PTR $T219183[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR $T219183[ebp]
	mulsd	xmm0, QWORD PTR _fGameProgressFactor$[ebp]
	addsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR _fMultiplyFactor$[ebp], xmm0

; 615  : 	// Exponential increase - this one really punishes those with a HUGE military - the LOWER this number the more is paid
; 616  : 	double fExponentialFactor = 1.0 + (fGameProgressFactor / /*7*/ GC.getUNIT_MAINTENANCE_GAME_EXPONENT_DIVISOR());

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6528
	mov	DWORD PTR $T219187[ebp], edx
	cvtsi2sd xmm0, DWORD PTR $T219187[ebp]
	movsd	xmm1, QWORD PTR _fGameProgressFactor$[ebp]
	divsd	xmm1, xmm0
	addsd	xmm1, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR _fExponentialFactor$[ebp], xmm1

; 617  : 
; 618  : 	double fTempCost = fMultiplyFactor * iSupport;

	cvtsi2sd xmm0, DWORD PTR _iSupport$[ebp]
	mulsd	xmm0, QWORD PTR _fMultiplyFactor$[ebp]
	movsd	QWORD PTR _fTempCost$[ebp], xmm0

; 619  : 	fTempCost /= 100;	// Take this out of hundreds now

	movsd	xmm0, QWORD PTR _fTempCost$[ebp]
	divsd	xmm0, QWORD PTR __real@4059000000000000
	movsd	QWORD PTR _fTempCost$[ebp], xmm0

; 620  : 
; 621  : 	double dFinalCost = pow(fTempCost, fExponentialFactor);

	movsd	xmm0, QWORD PTR _fTempCost$[ebp]
	movsd	xmm1, QWORD PTR _fExponentialFactor$[ebp]
	call	___libm_sse2_pow
	movsd	QWORD PTR _dFinalCost$[ebp], xmm0

; 622  : 
; 623  : 	// A mod at the player level? (Policies, etc.)
; 624  : 	if(m_pPlayer->GetUnitGoldMaintenanceMod() != 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetUnitGoldMaintenanceMod@CvPlayer@@QBEHXZ ; CvPlayer::GetUnitGoldMaintenanceMod
	test	eax, eax
	je	SHORT $LN4@CalculateU

; 625  : 	{
; 626  : 		dFinalCost *= (100 + m_pPlayer->GetUnitGoldMaintenanceMod());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?GetUnitGoldMaintenanceMod@CvPlayer@@QBEHXZ ; CvPlayer::GetUnitGoldMaintenanceMod
	add	eax, 100				; 00000064H
	cvtsi2sd xmm0, eax
	mulsd	xmm0, QWORD PTR _dFinalCost$[ebp]
	movsd	QWORD PTR _dFinalCost$[ebp], xmm0

; 627  : 		dFinalCost /= 100;

	movsd	xmm0, QWORD PTR _dFinalCost$[ebp]
	divsd	xmm0, QWORD PTR __real@4059000000000000
	movsd	QWORD PTR _dFinalCost$[ebp], xmm0
$LN4@CalculateU:

; 628  : 	}
; 629  : 
; 630  : 	// Human bonus for unit maintenance costs
; 631  : 	if(m_pPlayer->isHuman())

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@CalculateU

; 632  : 	{
; 633  : 		dFinalCost *= playerHandicap.getUnitCostPercent();

	mov	ecx, DWORD PTR _playerHandicap$[ebp]
	call	?getUnitCostPercent@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getUnitCostPercent
	cvtsi2sd xmm0, eax
	mulsd	xmm0, QWORD PTR _dFinalCost$[ebp]
	movsd	QWORD PTR _dFinalCost$[ebp], xmm0

; 634  : 		dFinalCost /= 100;

	movsd	xmm0, QWORD PTR _dFinalCost$[ebp]
	divsd	xmm0, QWORD PTR __real@4059000000000000
	movsd	QWORD PTR _dFinalCost$[ebp], xmm0
	jmp	SHORT $LN1@CalculateU
$LN3@CalculateU:

; 635  : 	}
; 636  : 	// AI bonus for unit maintenance costs
; 637  : 	else if(!m_pPlayer->IsAITeammateOfHuman())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?IsAITeammateOfHuman@CvPlayer@@QBE_NXZ	; CvPlayer::IsAITeammateOfHuman
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN1@CalculateU

; 638  : 	{
; 639  : 		dFinalCost *= GC.getGame().getHandicapInfo().getAIUnitCostPercent();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T219191[ebp], eax
	mov	ecx, DWORD PTR $T219191[ebp]
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo
	mov	ecx, eax
	call	?getAIUnitCostPercent@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getAIUnitCostPercent
	cvtsi2sd xmm0, eax
	mulsd	xmm0, QWORD PTR _dFinalCost$[ebp]
	movsd	QWORD PTR _dFinalCost$[ebp], xmm0

; 640  : 		dFinalCost /= 100;

	movsd	xmm0, QWORD PTR _dFinalCost$[ebp]
	divsd	xmm0, QWORD PTR __real@4059000000000000
	movsd	QWORD PTR _dFinalCost$[ebp], xmm0
$LN1@CalculateU:

; 641  : 	}
; 642  : 
; 643  : 	//iFinalCost /= 100;
; 644  : 
; 645  : 	return std::max(0, int(dFinalCost));

	cvttsd2si ecx, QWORD PTR _dFinalCost$[ebp]
	mov	DWORD PTR $T219153[ebp], ecx
	mov	DWORD PTR $T219154[ebp], 0
	mov	edx, DWORD PTR $T219154[ebp]
	cmp	edx, DWORD PTR $T219153[ebp]
	jge	SHORT $LN35@CalculateU
	lea	eax, DWORD PTR $T219153[ebp]
	mov	DWORD PTR tv153[ebp], eax
	jmp	SHORT $LN36@CalculateU
$LN35@CalculateU:
	lea	ecx, DWORD PTR $T219154[ebp]
	mov	DWORD PTR tv153[ebp], ecx
$LN36@CalculateU:
	mov	edx, DWORD PTR tv153[ebp]
	mov	DWORD PTR $T219197[ebp], edx
	mov	eax, DWORD PTR $T219197[ebp]
	mov	eax, DWORD PTR [eax]
$LN13@CalculateU:

; 646  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?CalculateUnitCost@CvTreasury@@QAEHAAH000@Z ENDP	; CvTreasury::CalculateUnitCost
_TEXT	ENDS
PUBLIC	?CalculateUnitSupply@CvTreasury@@QAEHAAH0@Z	; CvTreasury::CalculateUnitSupply
EXTRN	?GetUnitSupplyMod@CvPlayer@@QBEHXZ:PROC		; CvPlayer::GetUnitSupplyMod
EXTRN	?getEstimateEndTurn@CvGame@@QBEHXZ:PROC		; CvGame::getEstimateEndTurn
EXTRN	?getAIPerEraModifier@CvHandicapInfo@@QBEHXZ:PROC ; CvHandicapInfo::getAIPerEraModifier
EXTRN	?isBarbarian@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isBarbarian
EXTRN	?getNumOutsideUnits@CvPlayer@@QAEHXZ:PROC	; CvPlayer::getNumOutsideUnits
; Function compile flags: /Odtp
;	COMDAT ?CalculateUnitSupply@CvTreasury@@QAEHAAH0@Z
_TEXT	SEGMENT
tv265 = -116						; size = 4
tv72 = -112						; size = 4
tv188 = -108						; size = 4
_this$ = -104						; size = 4
$T219258 = -100						; size = 4
$T219254 = -96						; size = 4
$T219250 = -92						; size = 4
$T219246 = -88						; size = 4
$T219239 = -84						; size = 4
$T219233 = -80						; size = 4
$T219229 = -76						; size = 4
$T219222 = -72						; size = 4
$T219216 = -68						; size = 4
$T219212 = -64						; size = 4
$T219211 = -60						; size = 4
$T219210 = -56						; size = 4
$T219209 = -52						; size = 4
_fMultiplyFactor$ = -48					; size = 8
_fExponentialFactor$ = -40				; size = 8
_iSupply$ = -28						; size = 4
_playerHandicap$ = -24					; size = 4
_iFinalCost$ = -20					; size = 4
_fGameProgressFactor$ = -16				; size = 8
_fTempCost$ = -8					; size = 8
_iPaidUnits$ = 8					; size = 4
_iBaseSupplyCost$ = 12					; size = 4
?CalculateUnitSupply@CvTreasury@@QAEHAAH0@Z PROC	; CvTreasury::CalculateUnitSupply, COMDAT
; _this$ = ecx

; 650  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 	int iSupply;
; 652  : 
; 653  : 	iPaidUnits = std::max(0, (m_pPlayer->getNumOutsideUnits() - /*3*/ GC.getINITIAL_FREE_OUTSIDE_UNITS()));

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6516
	mov	DWORD PTR $T219216[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?getNumOutsideUnits@CvPlayer@@QAEHXZ	; CvPlayer::getNumOutsideUnits
	sub	eax, DWORD PTR $T219216[ebp]
	mov	DWORD PTR $T219209[ebp], eax
	mov	DWORD PTR $T219210[ebp], 0
	mov	edx, DWORD PTR $T219210[ebp]
	cmp	edx, DWORD PTR $T219209[ebp]
	jge	SHORT $LN9@CalculateU@2
	lea	eax, DWORD PTR $T219209[ebp]
	mov	DWORD PTR tv188[ebp], eax
	jmp	SHORT $LN10@CalculateU@2
$LN9@CalculateU@2:
	lea	ecx, DWORD PTR $T219210[ebp]
	mov	DWORD PTR tv188[ebp], ecx
$LN10@CalculateU@2:
	mov	edx, DWORD PTR tv188[ebp]
	mov	DWORD PTR $T219222[ebp], edx
	mov	eax, DWORD PTR _iPaidUnits$[ebp]
	mov	ecx, DWORD PTR $T219222[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 654  : 
; 655  : 	// JON: This is set to 0 right now, which pretty much means it's disabled
; 656  : 	iBaseSupplyCost = iPaidUnits* /*0*/ GC.getINITIAL_OUTSIDE_UNIT_GOLD_PERCENT();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6520
	mov	DWORD PTR $T219229[ebp], eax
	mov	ecx, DWORD PTR _iPaidUnits$[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	edx, DWORD PTR $T219229[ebp]
	mov	eax, DWORD PTR _iBaseSupplyCost$[ebp]
	mov	DWORD PTR [eax], edx

; 657  : 	iBaseSupplyCost /= 100;

	mov	ecx, DWORD PTR _iBaseSupplyCost$[ebp]
	mov	eax, DWORD PTR [ecx]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	edx, DWORD PTR _iBaseSupplyCost$[ebp]
	mov	DWORD PTR [edx], eax

; 658  : 
; 659  : 	iSupply = iBaseSupplyCost;

	mov	eax, DWORD PTR _iBaseSupplyCost$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iSupply$[ebp], ecx

; 660  : 
; 661  : 	CvHandicapInfo& playerHandicap = m_pPlayer->getHandicapInfo();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?getHandicapInfo@CvPlayer@@QBEAAVCvHandicapInfo@@XZ ; CvPlayer::getHandicapInfo
	mov	DWORD PTR _playerHandicap$[ebp], eax

; 662  : 	iSupply *= playerHandicap.getUnitCostPercent();

	mov	ecx, DWORD PTR _playerHandicap$[ebp]
	call	?getUnitCostPercent@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getUnitCostPercent
	imul	eax, DWORD PTR _iSupply$[ebp]
	mov	DWORD PTR _iSupply$[ebp], eax

; 663  : 	iSupply /= 100;

	mov	eax, DWORD PTR _iSupply$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iSupply$[ebp], eax

; 664  : 
; 665  : 	if(!m_pPlayer->isHuman() && !m_pPlayer->IsAITeammateOfHuman() && !m_pPlayer->isBarbarian())

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	jne	$LN2@CalculateU@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?IsAITeammateOfHuman@CvPlayer@@QBE_NXZ	; CvPlayer::IsAITeammateOfHuman
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@CalculateU@2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@CalculateU@2

; 666  : 	{
; 667  : 		//iSupply *= gameHandicap->getAIUnitSupplyPercent();	// This is no longer valid
; 668  : 		//iSupply /= 100;
; 669  : 
; 670  : 		iSupply *= std::max(0, ((GC.getGame().getHandicapInfo().getAIPerEraModifier() * m_pPlayer->GetCurrentEra()) + 100));

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T219233[ebp], edx
	mov	ecx, DWORD PTR $T219233[ebp]
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo
	mov	ecx, eax
	call	?getAIPerEraModifier@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getAIPerEraModifier
	mov	esi, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetCurrentEra@CvPlayer@@QBE?AW4EraTypes@@XZ ; CvPlayer::GetCurrentEra
	imul	esi, eax
	add	esi, 100				; 00000064H
	mov	DWORD PTR $T219211[ebp], esi
	mov	DWORD PTR $T219212[ebp], 0
	mov	ecx, DWORD PTR $T219212[ebp]
	cmp	ecx, DWORD PTR $T219211[ebp]
	jge	SHORT $LN17@CalculateU@2
	lea	edx, DWORD PTR $T219211[ebp]
	mov	DWORD PTR tv72[ebp], edx
	jmp	SHORT $LN18@CalculateU@2
$LN17@CalculateU@2:
	lea	eax, DWORD PTR $T219212[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN18@CalculateU@2:
	mov	ecx, DWORD PTR tv72[ebp]
	mov	DWORD PTR $T219239[ebp], ecx
	mov	edx, DWORD PTR $T219239[ebp]
	mov	eax, DWORD PTR _iSupply$[ebp]
	imul	eax, DWORD PTR [edx]
	mov	DWORD PTR _iSupply$[ebp], eax

; 671  : 		iSupply /= 100;

	mov	eax, DWORD PTR _iSupply$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iSupply$[ebp], eax
$LN2@CalculateU@2:

; 672  : 	}
; 673  : 
; 674  : 	// Game progress factor ranges from 0.0 to 1.0 based on how far into the game we are
; 675  : 	double fGameProgressFactor = float(GC.getGame().getElapsedGameTurns()) / GC.getGame().getEstimateEndTurn();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T219246[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T219250[ebp], eax
	mov	ecx, DWORD PTR $T219246[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR $T219250[ebp]
	movss	DWORD PTR tv265[ebp], xmm0
	call	?getEstimateEndTurn@CvGame@@QBEHXZ	; CvGame::getEstimateEndTurn
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR tv265[ebp]
	divss	xmm1, xmm0
	cvtss2sd xmm0, xmm1
	movsd	QWORD PTR _fGameProgressFactor$[ebp], xmm0

; 676  : 
; 677  : 	// Multiplicative increase - helps scale costs as game goes on - the HIGHER this number the more is paid
; 678  : 	double fMultiplyFactor = 1.0 + (fGameProgressFactor* /*8*/ GC.getUNIT_MAINTENANCE_GAME_MULTIPLIER());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6524
	mov	DWORD PTR $T219254[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR $T219254[ebp]
	mulsd	xmm0, QWORD PTR _fGameProgressFactor$[ebp]
	addsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR _fMultiplyFactor$[ebp], xmm0

; 679  : 	// Exponential increase - this one really punishes those with a HUGE military - the LOWER this number the more is paid
; 680  : 	double fExponentialFactor = 1.0 + (fGameProgressFactor / /*7*/ GC.getUNIT_MAINTENANCE_GAME_EXPONENT_DIVISOR());

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6528
	mov	DWORD PTR $T219258[ebp], edx
	cvtsi2sd xmm0, DWORD PTR $T219258[ebp]
	movsd	xmm1, QWORD PTR _fGameProgressFactor$[ebp]
	divsd	xmm1, xmm0
	addsd	xmm1, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR _fExponentialFactor$[ebp], xmm1

; 681  : 
; 682  : 	double fTempCost = fMultiplyFactor * iSupply;

	cvtsi2sd xmm0, DWORD PTR _iSupply$[ebp]
	mulsd	xmm0, QWORD PTR _fMultiplyFactor$[ebp]
	movsd	QWORD PTR _fTempCost$[ebp], xmm0

; 683  : 	int iFinalCost = (int) pow(fTempCost, fExponentialFactor);

	movsd	xmm0, QWORD PTR _fTempCost$[ebp]
	movsd	xmm1, QWORD PTR _fExponentialFactor$[ebp]
	call	___libm_sse2_pow
	cvttsd2si eax, xmm0
	mov	DWORD PTR _iFinalCost$[ebp], eax

; 684  : 
; 685  : 	// A mod at the player level? (Policies, etc.)
; 686  : 	if(m_pPlayer->GetUnitSupplyMod() != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?GetUnitSupplyMod@CvPlayer@@QBEHXZ	; CvPlayer::GetUnitSupplyMod
	test	eax, eax
	je	SHORT $LN1@CalculateU@2

; 687  : 	{
; 688  : 		iFinalCost *= (100 + m_pPlayer->GetUnitSupplyMod());

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?GetUnitSupplyMod@CvPlayer@@QBEHXZ	; CvPlayer::GetUnitSupplyMod
	add	eax, 100				; 00000064H
	imul	eax, DWORD PTR _iFinalCost$[ebp]
	mov	DWORD PTR _iFinalCost$[ebp], eax

; 689  : 		iFinalCost /= 100;

	mov	eax, DWORD PTR _iFinalCost$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iFinalCost$[ebp], eax
$LN1@CalculateU@2:

; 690  : 	}
; 691  : 
; 692  : 	CvAssert(iFinalCost >= 0);
; 693  : 
; 694  : 	return iFinalCost;

	mov	eax, DWORD PTR _iFinalCost$[ebp]

; 695  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?CalculateUnitSupply@CvTreasury@@QAEHAAH0@Z ENDP	; CvTreasury::CalculateUnitSupply
_TEXT	ENDS
PUBLIC	?GetImprovementGoldMaintenance@CvTreasury@@QBEHXZ ; CvTreasury::GetImprovementGoldMaintenance
PUBLIC	?GetBuildingGoldMaintenance@CvTreasury@@QBEHXZ	; CvTreasury::GetBuildingGoldMaintenance
PUBLIC	?CalculatePreInflatedCosts@CvTreasury@@QAEHXZ	; CvTreasury::CalculatePreInflatedCosts
; Function compile flags: /Odtp
;	COMDAT ?CalculatePreInflatedCosts@CvTreasury@@QAEHXZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_iTotalCosts$ = -24					; size = 4
_iExtraCost$ = -20					; size = 4
_iBaseUnitCost$ = -16					; size = 4
_iBaseSupplyCost$ = -12					; size = 4
_iPaidUnits$ = -8					; size = 4
_iFreeUnits$ = -4					; size = 4
?CalculatePreInflatedCosts@CvTreasury@@QAEHXZ PROC	; CvTreasury::CalculatePreInflatedCosts, COMDAT
; _this$ = ecx

; 699  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 700  : 	int iFreeUnits;
; 701  : 	int iPaidUnits;
; 702  : 	int iBaseUnitCost;
; 703  : 	int iExtraCost;
; 704  : 	int iBaseSupplyCost;
; 705  : 
; 706  : 	m_iExpensePerTurnUnitMaintenance = CalculateUnitCost(iFreeUnits, iPaidUnits, iBaseUnitCost, iExtraCost);

	lea	eax, DWORD PTR _iExtraCost$[ebp]
	push	eax
	lea	ecx, DWORD PTR _iBaseUnitCost$[ebp]
	push	ecx
	lea	edx, DWORD PTR _iPaidUnits$[ebp]
	push	edx
	lea	eax, DWORD PTR _iFreeUnits$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateUnitCost@CvTreasury@@QAEHAAH000@Z ; CvTreasury::CalculateUnitCost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 707  : 	m_iExpensePerTurnUnitSupply = CalculateUnitSupply(iPaidUnits, iBaseSupplyCost);

	lea	edx, DWORD PTR _iBaseSupplyCost$[ebp]
	push	edx
	lea	eax, DWORD PTR _iPaidUnits$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateUnitSupply@CvTreasury@@QAEHAAH0@Z ; CvTreasury::CalculateUnitSupply
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 708  : 
; 709  : 	int iTotalCosts = 0;

	mov	DWORD PTR _iTotalCosts$[ebp], 0

; 710  : 
; 711  : 	iTotalCosts += m_iExpensePerTurnUnitMaintenance;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iTotalCosts$[ebp]
	add	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _iTotalCosts$[ebp], eax

; 712  : 	iTotalCosts += m_iExpensePerTurnUnitSupply;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _iTotalCosts$[ebp]
	add	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _iTotalCosts$[ebp], edx

; 713  : 	iTotalCosts += GetBuildingGoldMaintenance();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBuildingGoldMaintenance@CvTreasury@@QBEHXZ ; CvTreasury::GetBuildingGoldMaintenance
	add	eax, DWORD PTR _iTotalCosts$[ebp]
	mov	DWORD PTR _iTotalCosts$[ebp], eax

; 714  : 	iTotalCosts += GetImprovementGoldMaintenance();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetImprovementGoldMaintenance@CvTreasury@@QBEHXZ ; CvTreasury::GetImprovementGoldMaintenance
	add	eax, DWORD PTR _iTotalCosts$[ebp]
	mov	DWORD PTR _iTotalCosts$[ebp], eax

; 715  : 
; 716  : 	return iTotalCosts;

	mov	eax, DWORD PTR _iTotalCosts$[ebp]

; 717  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CalculatePreInflatedCosts@CvTreasury@@QAEHXZ ENDP	; CvTreasury::CalculatePreInflatedCosts
_TEXT	ENDS
PUBLIC	?CalculateInflationRate@CvTreasury@@QAEHXZ	; CvTreasury::CalculateInflationRate
EXTRN	?getAIInflationPercent@CvHandicapInfo@@QBEHXZ:PROC ; CvHandicapInfo::getAIInflationPercent
EXTRN	?getInflationPercent@CvHandicapInfo@@QBEHXZ:PROC ; CvHandicapInfo::getInflationPercent
EXTRN	?getInflationPercent@CvGameSpeedInfo@@QBEHXZ:PROC ; CvGameSpeedInfo::getInflationPercent
EXTRN	?getInflationOffset@CvGameSpeedInfo@@QBEHXZ:PROC ; CvGameSpeedInfo::getInflationOffset
EXTRN	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ:PROC ; CvGame::getGameSpeedInfo
; Function compile flags: /Odtp
;	COMDAT ?CalculateInflationRate@CvTreasury@@QAEHXZ
_TEXT	SEGMENT
tv142 = -72						; size = 4
tv64 = -68						; size = 4
_this$ = -64						; size = 4
$T219284 = -60						; size = 4
$T219275 = -56						; size = 4
$T219266 = -52						; size = 4
$T219265 = -48						; size = 4
$T219264 = -44						; size = 4
$T219263 = -40						; size = 4
_iAIModifier$217373 = -36				; size = 4
_iInflationPerTurnTimes10000$ = -32			; size = 4
_gameHandicap$ = -28					; size = 4
_gameSpeedInfo$ = -24					; size = 4
_playerHandicap$ = -20					; size = 4
_iTurns$ = -16						; size = 4
_iRatePercent$ = -12					; size = 4
_kGame$ = -8						; size = 4
_iModifier$ = -4					; size = 4
?CalculateInflationRate@CvTreasury@@QAEHXZ PROC		; CvTreasury::CalculateInflationRate, COMDAT
; _this$ = ecx

; 721  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 722  : 	CvGame& kGame = GC.getGame();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR _kGame$[ebp], eax

; 723  : 
; 724  : 	CvHandicapInfo& playerHandicap = m_pPlayer->getHandicapInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?getHandicapInfo@CvPlayer@@QBEAAVCvHandicapInfo@@XZ ; CvPlayer::getHandicapInfo
	mov	DWORD PTR _playerHandicap$[ebp], eax

; 725  : 	CvHandicapInfo& gameHandicap = kGame.getHandicapInfo();

	mov	ecx, DWORD PTR _kGame$[ebp]
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo
	mov	DWORD PTR _gameHandicap$[ebp], eax

; 726  : 	CvGameSpeedInfo& gameSpeedInfo = kGame.getGameSpeedInfo();

	mov	ecx, DWORD PTR _kGame$[ebp]
	call	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ ; CvGame::getGameSpeedInfo
	mov	DWORD PTR _gameSpeedInfo$[ebp], eax

; 727  : 
; 728  : 	int iTurns = ((kGame.getGameTurn() + kGame.getElapsedGameTurns()) / 2);

	mov	ecx, DWORD PTR _kGame$[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	esi, eax
	mov	ecx, DWORD PTR _kGame$[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	add	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _iTurns$[ebp], eax

; 729  : 	iTurns += gameSpeedInfo.getInflationOffset();

	mov	ecx, DWORD PTR _gameSpeedInfo$[ebp]
	call	?getInflationOffset@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getInflationOffset
	add	eax, DWORD PTR _iTurns$[ebp]
	mov	DWORD PTR _iTurns$[ebp], eax

; 730  : 
; 731  : 	if(iTurns <= 0)

	cmp	DWORD PTR _iTurns$[ebp], 0
	jg	SHORT $LN2@CalculateI

; 732  : 	{
; 733  : 		return 0;

	xor	eax, eax
	jmp	$LN3@CalculateI
$LN2@CalculateI:

; 734  : 	}
; 735  : 
; 736  : 	int iInflationPerTurnTimes10000 = gameSpeedInfo.getInflationPercent();

	mov	ecx, DWORD PTR _gameSpeedInfo$[ebp]
	call	?getInflationPercent@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getInflationPercent
	mov	DWORD PTR _iInflationPerTurnTimes10000$[ebp], eax

; 737  : 	iInflationPerTurnTimes10000 *= playerHandicap.getInflationPercent();

	mov	ecx, DWORD PTR _playerHandicap$[ebp]
	call	?getInflationPercent@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getInflationPercent
	imul	eax, DWORD PTR _iInflationPerTurnTimes10000$[ebp]
	mov	DWORD PTR _iInflationPerTurnTimes10000$[ebp], eax

; 738  : 	iInflationPerTurnTimes10000 /= 100;

	mov	eax, DWORD PTR _iInflationPerTurnTimes10000$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iInflationPerTurnTimes10000$[ebp], eax

; 739  : 
; 740  : 	int iModifier = 0;

	mov	DWORD PTR _iModifier$[ebp], 0

; 741  : 
; 742  : 	if(!m_pPlayer->isHuman() && !m_pPlayer->isBarbarian())

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	jne	$LN1@CalculateI
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN1@CalculateI

; 743  : 	{
; 744  : 		int iAIModifier = gameHandicap.getAIInflationPercent();

	mov	ecx, DWORD PTR _gameHandicap$[ebp]
	call	?getAIInflationPercent@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getAIInflationPercent
	mov	DWORD PTR _iAIModifier$217373[ebp], eax

; 745  : 		iAIModifier *= std::max(0, ((gameHandicap.getAIPerEraModifier() * m_pPlayer->GetCurrentEra()) + 100));

	mov	ecx, DWORD PTR _gameHandicap$[ebp]
	call	?getAIPerEraModifier@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getAIPerEraModifier
	mov	esi, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetCurrentEra@CvPlayer@@QBE?AW4EraTypes@@XZ ; CvPlayer::GetCurrentEra
	imul	esi, eax
	add	esi, 100				; 00000064H
	mov	DWORD PTR $T219263[ebp], esi
	mov	DWORD PTR $T219264[ebp], 0
	mov	ecx, DWORD PTR $T219264[ebp]
	cmp	ecx, DWORD PTR $T219263[ebp]
	jge	SHORT $LN9@CalculateI
	lea	edx, DWORD PTR $T219263[ebp]
	mov	DWORD PTR tv64[ebp], edx
	jmp	SHORT $LN10@CalculateI
$LN9@CalculateI:
	lea	eax, DWORD PTR $T219264[ebp]
	mov	DWORD PTR tv64[ebp], eax
$LN10@CalculateI:
	mov	ecx, DWORD PTR tv64[ebp]
	mov	DWORD PTR $T219275[ebp], ecx
	mov	edx, DWORD PTR $T219275[ebp]
	mov	eax, DWORD PTR _iAIModifier$217373[ebp]
	imul	eax, DWORD PTR [edx]
	mov	DWORD PTR _iAIModifier$217373[ebp], eax

; 746  : 		iAIModifier /= 100;

	mov	eax, DWORD PTR _iAIModifier$217373[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iAIModifier$217373[ebp], eax

; 747  : 
; 748  : 		iModifier += iAIModifier - 100;

	mov	edx, DWORD PTR _iAIModifier$217373[ebp]
	mov	eax, DWORD PTR _iModifier$[ebp]
	lea	ecx, DWORD PTR [eax+edx-100]
	mov	DWORD PTR _iModifier$[ebp], ecx
$LN1@CalculateI:

; 749  : 	}
; 750  : 
; 751  : 	iInflationPerTurnTimes10000 *= std::max(0, 100 + iModifier);

	mov	edx, DWORD PTR _iModifier$[ebp]
	add	edx, 100				; 00000064H
	mov	DWORD PTR $T219265[ebp], edx
	mov	DWORD PTR $T219266[ebp], 0
	mov	eax, DWORD PTR $T219266[ebp]
	cmp	eax, DWORD PTR $T219265[ebp]
	jge	SHORT $LN13@CalculateI
	lea	ecx, DWORD PTR $T219265[ebp]
	mov	DWORD PTR tv142[ebp], ecx
	jmp	SHORT $LN14@CalculateI
$LN13@CalculateI:
	lea	edx, DWORD PTR $T219266[ebp]
	mov	DWORD PTR tv142[ebp], edx
$LN14@CalculateI:
	mov	eax, DWORD PTR tv142[ebp]
	mov	DWORD PTR $T219284[ebp], eax
	mov	ecx, DWORD PTR $T219284[ebp]
	mov	edx, DWORD PTR _iInflationPerTurnTimes10000$[ebp]
	imul	edx, DWORD PTR [ecx]
	mov	DWORD PTR _iInflationPerTurnTimes10000$[ebp], edx

; 752  : 	iInflationPerTurnTimes10000 /= 100;

	mov	eax, DWORD PTR _iInflationPerTurnTimes10000$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iInflationPerTurnTimes10000$[ebp], eax

; 753  : 
; 754  : 	// Keep up to second order terms in binomial series
; 755  : 	int iRatePercent = (iTurns * iInflationPerTurnTimes10000) / 100;

	mov	eax, DWORD PTR _iTurns$[ebp]
	imul	eax, DWORD PTR _iInflationPerTurnTimes10000$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iRatePercent$[ebp], eax

; 756  : 	iRatePercent += (iTurns * (iTurns - 1) * iInflationPerTurnTimes10000 * iInflationPerTurnTimes10000) / 2000000;

	mov	edx, DWORD PTR _iTurns$[ebp]
	sub	edx, 1
	mov	eax, edx
	imul	eax, DWORD PTR _iTurns$[ebp]
	imul	eax, DWORD PTR _iInflationPerTurnTimes10000$[ebp]
	imul	eax, DWORD PTR _iInflationPerTurnTimes10000$[ebp]
	cdq
	mov	ecx, 2000000				; 001e8480H
	idiv	ecx
	add	eax, DWORD PTR _iRatePercent$[ebp]
	mov	DWORD PTR _iRatePercent$[ebp], eax

; 757  : 
; 758  : 	CvAssert(iRatePercent >= 0);
; 759  : 
; 760  : 	return iRatePercent;

	mov	eax, DWORD PTR _iRatePercent$[ebp]
$LN3@CalculateI:

; 761  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?CalculateInflationRate@CvTreasury@@QAEHXZ ENDP		; CvTreasury::CalculateInflationRate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?CalculateInflatedCosts@CvTreasury@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_iCosts$ = -4						; size = 4
?CalculateInflatedCosts@CvTreasury@@QAEHXZ PROC		; CvTreasury::CalculateInflatedCosts, COMDAT
; _this$ = ecx

; 765  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 766  : 	int iCosts = CalculatePreInflatedCosts();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculatePreInflatedCosts@CvTreasury@@QAEHXZ ; CvTreasury::CalculatePreInflatedCosts
	mov	DWORD PTR _iCosts$[ebp], eax

; 767  : 
; 768  : 	//iCosts *= std::max(0, (CalculateInflationRate() + 100));
; 769  : 	//iCosts /= 100;
; 770  : 
; 771  : 	return iCosts;

	mov	eax, DWORD PTR _iCosts$[ebp]

; 772  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CalculateInflatedCosts@CvTreasury@@QAEHXZ ENDP		; CvTreasury::CalculateInflatedCosts
_TEXT	ENDS
PUBLIC	?GetBaseBuildingGoldMaintenance@CvTreasury@@QBEHXZ ; CvTreasury::GetBaseBuildingGoldMaintenance
EXTRN	?getBuildingMaintenancePercent@CvEraInfo@@QBEHXZ:PROC ; CvEraInfo::getBuildingMaintenancePercent
EXTRN	?getStartEraInfo@CvGame@@QBEAAVCvEraInfo@@XZ:PROC ; CvGame::getStartEraInfo
EXTRN	?getAIBuildingCostPercent@CvHandicapInfo@@QBEHXZ:PROC ; CvHandicapInfo::getAIBuildingCostPercent
EXTRN	?getBuildingCostPercent@CvHandicapInfo@@QBEHXZ:PROC ; CvHandicapInfo::getBuildingCostPercent
EXTRN	?GetBuildingGoldMaintenanceMod@CvPlayer@@QBEHXZ:PROC ; CvPlayer::GetBuildingGoldMaintenanceMod
; Function compile flags: /Odtp
;	COMDAT ?GetBuildingGoldMaintenance@CvTreasury@@QBEHXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T219299 = -16						; size = 4
$T219295 = -12						; size = 4
_playerHandicap$ = -8					; size = 4
_iMaintenance$ = -4					; size = 4
?GetBuildingGoldMaintenance@CvTreasury@@QBEHXZ PROC	; CvTreasury::GetBuildingGoldMaintenance, COMDAT
; _this$ = ecx

; 776  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 777  : 	int iMaintenance = GetBaseBuildingGoldMaintenance();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBaseBuildingGoldMaintenance@CvTreasury@@QBEHXZ ; CvTreasury::GetBaseBuildingGoldMaintenance
	mov	DWORD PTR _iMaintenance$[ebp], eax

; 778  : 
; 779  : 	// Player modifier
; 780  : 	iMaintenance *= (100 + m_pPlayer->GetBuildingGoldMaintenanceMod());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetBuildingGoldMaintenanceMod@CvPlayer@@QBEHXZ ; CvPlayer::GetBuildingGoldMaintenanceMod
	add	eax, 100				; 00000064H
	imul	eax, DWORD PTR _iMaintenance$[ebp]
	mov	DWORD PTR _iMaintenance$[ebp], eax

; 781  : 	iMaintenance /= 100;

	mov	eax, DWORD PTR _iMaintenance$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iMaintenance$[ebp], eax

; 782  : 
; 783  : 	// Modifier for difficulty level
; 784  : 	CvHandicapInfo& playerHandicap = m_pPlayer->getHandicapInfo();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?getHandicapInfo@CvPlayer@@QBEAAVCvHandicapInfo@@XZ ; CvPlayer::getHandicapInfo
	mov	DWORD PTR _playerHandicap$[ebp], eax

; 785  : 	//iMaintenance *= playerHandicap->getBuildingCostPercent();
; 786  : 	//iMaintenance /= 100;
; 787  : 
; 788  : 	// Human bonus for Building maintenance costs
; 789  : 	if(m_pPlayer->isHuman())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@GetBuildin

; 790  : 	{
; 791  : 		iMaintenance *= playerHandicap.getBuildingCostPercent();

	mov	ecx, DWORD PTR _playerHandicap$[ebp]
	call	?getBuildingCostPercent@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getBuildingCostPercent
	imul	eax, DWORD PTR _iMaintenance$[ebp]
	mov	DWORD PTR _iMaintenance$[ebp], eax

; 792  : 		iMaintenance /= 100;

	mov	eax, DWORD PTR _iMaintenance$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iMaintenance$[ebp], eax
	jmp	SHORT $LN2@GetBuildin
$LN3@GetBuildin:

; 793  : 	}
; 794  : 	// AI bonus for Building maintenance costs
; 795  : 	else if(!m_pPlayer->IsAITeammateOfHuman())

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?IsAITeammateOfHuman@CvPlayer@@QBE_NXZ	; CvPlayer::IsAITeammateOfHuman
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@GetBuildin

; 796  : 	{
; 797  : 		iMaintenance *= GC.getGame().getHandicapInfo().getAIBuildingCostPercent();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T219295[ebp], ecx
	mov	ecx, DWORD PTR $T219295[ebp]
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo
	mov	ecx, eax
	call	?getAIBuildingCostPercent@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getAIBuildingCostPercent
	imul	eax, DWORD PTR _iMaintenance$[ebp]
	mov	DWORD PTR _iMaintenance$[ebp], eax

; 798  : 		iMaintenance /= 100;

	mov	eax, DWORD PTR _iMaintenance$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iMaintenance$[ebp], eax
$LN2@GetBuildin:

; 799  : 	}
; 800  : 
; 801  : 	// Start Era mod
; 802  : 	iMaintenance *= GC.getGame().getStartEraInfo().getBuildingMaintenancePercent();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T219299[ebp], edx
	mov	ecx, DWORD PTR $T219299[ebp]
	call	?getStartEraInfo@CvGame@@QBEAAVCvEraInfo@@XZ ; CvGame::getStartEraInfo
	mov	ecx, eax
	call	?getBuildingMaintenancePercent@CvEraInfo@@QBEHXZ ; CvEraInfo::getBuildingMaintenancePercent
	imul	eax, DWORD PTR _iMaintenance$[ebp]
	mov	DWORD PTR _iMaintenance$[ebp], eax

; 803  : 	iMaintenance /= 100;

	mov	eax, DWORD PTR _iMaintenance$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iMaintenance$[ebp], eax

; 804  : 
; 805  : 	return iMaintenance;

	mov	eax, DWORD PTR _iMaintenance$[ebp]

; 806  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetBuildingGoldMaintenance@CvTreasury@@QBEHXZ ENDP	; CvTreasury::GetBuildingGoldMaintenance
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetBaseBuildingGoldMaintenance@CvTreasury@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBaseBuildingGoldMaintenance@CvTreasury@@QBEHXZ PROC	; CvTreasury::GetBaseBuildingGoldMaintenance, COMDAT
; _this$ = ecx

; 810  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 811  : 	return m_iBaseBuildingGoldMaintenance;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+36]

; 812  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseBuildingGoldMaintenance@CvTreasury@@QBEHXZ ENDP	; CvTreasury::GetBaseBuildingGoldMaintenance
_TEXT	ENDS
PUBLIC	?SetBaseBuildingGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::SetBaseBuildingGoldMaintenance
; Function compile flags: /Odtp
;	COMDAT ?SetBaseBuildingGoldMaintenance@CvTreasury@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iValue$ = 8						; size = 4
?SetBaseBuildingGoldMaintenance@CvTreasury@@QAEXH@Z PROC ; CvTreasury::SetBaseBuildingGoldMaintenance, COMDAT
; _this$ = ecx

; 816  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 817  : 	m_iBaseBuildingGoldMaintenance = iValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iValue$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 818  : 
; 819  : 	if(m_iBaseBuildingGoldMaintenance < 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+36], 0
	jge	SHORT $LN2@SetBaseBui

; 820  : 		m_iBaseBuildingGoldMaintenance = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+36], 0
$LN2@SetBaseBui:

; 821  : 
; 822  : 	CvAssertMsg(m_iBaseBuildingGoldMaintenance >= 0, "Building Maintenance is negative somehow. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 823  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetBaseBuildingGoldMaintenance@CvTreasury@@QAEXH@Z ENDP ; CvTreasury::SetBaseBuildingGoldMaintenance
_TEXT	ENDS
PUBLIC	?ChangeBaseBuildingGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeBaseBuildingGoldMaintenance
; Function compile flags: /Odtp
;	COMDAT ?ChangeBaseBuildingGoldMaintenance@CvTreasury@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?ChangeBaseBuildingGoldMaintenance@CvTreasury@@QAEXH@Z PROC ; CvTreasury::ChangeBaseBuildingGoldMaintenance, COMDAT
; _this$ = ecx

; 827  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 828  : 	SetBaseBuildingGoldMaintenance(GetBaseBuildingGoldMaintenance() + iChange);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBaseBuildingGoldMaintenance@CvTreasury@@QBEHXZ ; CvTreasury::GetBaseBuildingGoldMaintenance
	add	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetBaseBuildingGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::SetBaseBuildingGoldMaintenance

; 829  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ChangeBaseBuildingGoldMaintenance@CvTreasury@@QAEXH@Z ENDP ; CvTreasury::ChangeBaseBuildingGoldMaintenance
_TEXT	ENDS
EXTRN	?getRouteCostPercent@CvHandicapInfo@@QBEHXZ:PROC ; CvHandicapInfo::getRouteCostPercent
EXTRN	?GetRouteGoldMaintenanceMod@CvPlayer@@QBEHXZ:PROC ; CvPlayer::GetRouteGoldMaintenanceMod
; Function compile flags: /Odtp
;	COMDAT ?GetImprovementGoldMaintenance@CvTreasury@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_iMaintenance$ = -4					; size = 4
?GetImprovementGoldMaintenance@CvTreasury@@QBEHXZ PROC	; CvTreasury::GetImprovementGoldMaintenance, COMDAT
; _this$ = ecx

; 833  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 834  : 	int iMaintenance = m_iBaseImprovementGoldMaintenance;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _iMaintenance$[ebp], ecx

; 835  : 
; 836  : 	// Player modifier
; 837  : 	iMaintenance *= (100 + m_pPlayer->GetRouteGoldMaintenanceMod());

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?GetRouteGoldMaintenanceMod@CvPlayer@@QBEHXZ ; CvPlayer::GetRouteGoldMaintenanceMod
	add	eax, 100				; 00000064H
	imul	eax, DWORD PTR _iMaintenance$[ebp]
	mov	DWORD PTR _iMaintenance$[ebp], eax

; 838  : 	iMaintenance /= 100;

	mov	eax, DWORD PTR _iMaintenance$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iMaintenance$[ebp], eax

; 839  : 
; 840  : 	// Handicap
; 841  : 	iMaintenance *= m_pPlayer->getHandicapInfo().getRouteCostPercent();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?getHandicapInfo@CvPlayer@@QBEAAVCvHandicapInfo@@XZ ; CvPlayer::getHandicapInfo
	mov	ecx, eax
	call	?getRouteCostPercent@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getRouteCostPercent
	imul	eax, DWORD PTR _iMaintenance$[ebp]
	mov	DWORD PTR _iMaintenance$[ebp], eax

; 842  : 	iMaintenance /= 100;

	mov	eax, DWORD PTR _iMaintenance$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iMaintenance$[ebp], eax

; 843  : 
; 844  : 	return iMaintenance;

	mov	eax, DWORD PTR _iMaintenance$[ebp]

; 845  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetImprovementGoldMaintenance@CvTreasury@@QBEHXZ ENDP	; CvTreasury::GetImprovementGoldMaintenance
_TEXT	ENDS
PUBLIC	?GetBaseImprovementGoldMaintenance@CvTreasury@@QBEHXZ ; CvTreasury::GetBaseImprovementGoldMaintenance
; Function compile flags: /Odtp
;	COMDAT ?GetBaseImprovementGoldMaintenance@CvTreasury@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBaseImprovementGoldMaintenance@CvTreasury@@QBEHXZ PROC ; CvTreasury::GetBaseImprovementGoldMaintenance, COMDAT
; _this$ = ecx

; 849  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 850  : 	return m_iBaseImprovementGoldMaintenance;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+40]

; 851  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseImprovementGoldMaintenance@CvTreasury@@QBEHXZ ENDP ; CvTreasury::GetBaseImprovementGoldMaintenance
_TEXT	ENDS
PUBLIC	?SetBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::SetBaseImprovementGoldMaintenance
; Function compile flags: /Odtp
;	COMDAT ?SetBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z
_TEXT	SEGMENT
tv86 = -20						; size = 4
_this$ = -16						; size = 4
$T219328 = -12						; size = 4
$T219324 = -8						; size = 4
$T219320 = -4						; size = 4
_iValue$ = 8						; size = 4
?SetBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z PROC ; CvTreasury::SetBaseImprovementGoldMaintenance, COMDAT
; _this$ = ecx

; 855  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 856  : 	if(GetBaseImprovementGoldMaintenance() != iValue)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBaseImprovementGoldMaintenance@CvTreasury@@QBEHXZ ; CvTreasury::GetBaseImprovementGoldMaintenance
	cmp	eax, DWORD PTR _iValue$[ebp]
	je	SHORT $LN4@SetBaseImp

; 857  : 	{
; 858  : 		m_iBaseImprovementGoldMaintenance = iValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iValue$[ebp]
	mov	DWORD PTR [eax+40], ecx

; 859  : 
; 860  : 		CvAssertMsg(m_iBaseImprovementGoldMaintenance >= 0, "Improvement Maintenance is negative somehow. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 861  : 
; 862  : 		if(m_iBaseImprovementGoldMaintenance < 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+40], 0
	jge	SHORT $LN8@SetBaseImp

; 863  : 			m_iBaseImprovementGoldMaintenance = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+40], 0

; 864  : 
; 865  : 		if(m_pPlayer->GetID() == GC.getGame().getActivePlayer())

$LN8@SetBaseImp:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T219320[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T219324[ebp], ecx
	mov	ecx, DWORD PTR $T219324[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	DWORD PTR $T219320[ebp], eax
	jne	SHORT $LN4@SetBaseImp

; 866  : 			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	mov	edx, DWORD PTR $T219328[ebp]
	mov	DWORD PTR tv86[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv86[ebp], eax
	push	1
	push	11					; 0000000bH
	mov	ecx, DWORD PTR tv86[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv86[ebp]
	mov	eax, DWORD PTR [edx+260]
	call	eax
$LN4@SetBaseImp:

; 867  : 	}
; 868  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z ENDP ; CvTreasury::SetBaseImprovementGoldMaintenance
_TEXT	ENDS
PUBLIC	?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeBaseImprovementGoldMaintenance
; Function compile flags: /Odtp
;	COMDAT ?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z PROC ; CvTreasury::ChangeBaseImprovementGoldMaintenance, COMDAT
; _this$ = ecx

; 872  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 873  : 	SetBaseImprovementGoldMaintenance(GetBaseImprovementGoldMaintenance() + iChange);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBaseImprovementGoldMaintenance@CvTreasury@@QBEHXZ ; CvTreasury::GetBaseImprovementGoldMaintenance
	add	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::SetBaseImprovementGoldMaintenance

; 874  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z ENDP ; CvTreasury::ChangeBaseImprovementGoldMaintenance
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	?AverageIncome@CvTreasury@@QAENH@Z		; CvTreasury::AverageIncome
;	COMDAT __real@0000000000000000
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtreasury.cpp
CONST	ENDS
;	COMDAT ?AverageIncome@CvTreasury@@QAENH@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T219340 = -20						; size = 4
$T219336 = -16						; size = 4
_iSamples$217426 = -12					; size = 4
_iIndex$217427 = -8					; size = 4
_iTotal$217428 = -4					; size = 4
_iTurns$ = 8						; size = 4
?AverageIncome@CvTreasury@@QAENH@Z PROC			; CvTreasury::AverageIncome, COMDAT
; _this$ = ecx

; 878  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 879  : 	CvAssertMsg(iTurns > 0, "Invalid number of turns parameter");
; 880  : 
; 881  : 	if(m_GoldChangeForTurnTimes100.size() > 0)

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 64					; 00000040H
	mov	DWORD PTR $T219336[ebp], eax
	mov	ecx, DWORD PTR $T219336[ebp]
	mov	edx, DWORD PTR $T219336[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	test	eax, eax
	jbe	SHORT $LN3@AverageInc

; 882  : 	{
; 883  : 		int iSamples = 0;

	mov	DWORD PTR _iSamples$217426[ebp], 0

; 884  : 		int iIndex = m_GoldChangeForTurnTimes100.size() - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	mov	DWORD PTR $T219340[ebp], ecx
	mov	edx, DWORD PTR $T219340[ebp]
	mov	eax, DWORD PTR $T219340[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	sub	ecx, 1
	mov	DWORD PTR _iIndex$217427[ebp], ecx

; 885  : 		int iTotal = 0;

	mov	DWORD PTR _iTotal$217428[ebp], 0
$LN2@AverageInc:

; 886  : 
; 887  : 		while(iSamples < iTurns)

	mov	edx, DWORD PTR _iSamples$217426[ebp]
	cmp	edx, DWORD PTR _iTurns$[ebp]
	jge	SHORT $LN1@AverageInc

; 888  : 		{
; 889  : 			iTotal += m_GoldChangeForTurnTimes100[iIndex];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	edx, DWORD PTR _iIndex$217427[ebp]
	mov	eax, DWORD PTR _iTotal$217428[ebp]
	add	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _iTotal$217428[ebp], eax

; 890  : 			iSamples++;

	mov	ecx, DWORD PTR _iSamples$217426[ebp]
	add	ecx, 1
	mov	DWORD PTR _iSamples$217426[ebp], ecx

; 891  : 		}

	jmp	SHORT $LN2@AverageInc
$LN1@AverageInc:

; 892  : 
; 893  : 		return ((double)iTotal / (double)iSamples / 100);

	fild	DWORD PTR _iTotal$217428[ebp]
	fidiv	DWORD PTR _iSamples$217426[ebp]
	fdiv	QWORD PTR __real@4059000000000000
	jmp	SHORT $LN4@AverageInc
$LN3@AverageInc:

; 894  : 	}
; 895  : 
; 896  : 	return 0;

	fldz
$LN4@AverageInc:

; 897  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?AverageIncome@CvTreasury@@QAENH@Z ENDP			; CvTreasury::AverageIncome
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
PUBLIC	??_C@_0BJ@HAEBLPBN@Research?5Agreement?5Cost?3?$AA@ ; `string'
PUBLIC	??_C@_0BJ@OIABGNKL@Research?5Agreement?5with?3?$AA@ ; `string'
PUBLIC	??_C@_0BJ@NPIPBGEN@Emergency?5Building?5Cost?3?$AA@ ; `string'
PUBLIC	??_C@_0BE@GIABCIPA@Emergency?5Building?3?$AA@	; `string'
PUBLIC	??_C@_0BF@OBMNJCAM@Emergency?5Unit?5Cost?3?$AA@	; `string'
PUBLIC	??_C@_0BA@MKJAPDEO@Emergency?5Unit?3?$AA@	; `string'
PUBLIC	??_C@_0M@KIFCJNEP@Bought?5for?3?$AA@		; `string'
PUBLIC	??_C@_0BD@MOGJFNDG@City?5State?5Bought?3?$AA@	; `string'
PUBLIC	??_C@_0BN@JKEBKCPE@Gold?5for?5Improvement?5Amount?3?$AA@ ; `string'
PUBLIC	??_C@_0BF@KJAKNNIA@City?5State?5Improved?3?$AA@	; `string'
PUBLIC	??_C@_0BC@DHDMLBIJ@Gold?5Gift?5Amount?3?$AA@	; `string'
PUBLIC	??_C@_0BI@OOJPHEDP@City?5State?5Gold?5Gifted?3?$AA@ ; `string'
PUBLIC	??_C@_0O@CKGJCDAN@Unit?5Upgrade?3?$AA@		; `string'
PUBLIC	??_C@_0BC@NOOEJKPD@Spent?5on?5Upgrade?3?$AA@	; `string'
PUBLIC	??_C@_0P@DNBAMIFN@Unit?5Upgraded?3?$AA@		; `string'
PUBLIC	??_C@_0M@FHPPFOAE@City?5Spent?3?$AA@		; `string'
PUBLIC	??_C@_0N@GNBJBAKL@City?5Bought?3?$AA@		; `string'
PUBLIC	??_C@_0O@HHNGJPBC@Cost?5of?5Plot?3?$AA@		; `string'
PUBLIC	??_C@_0BJ@DJPJBDOC@Treasury?5Before?5Purchase?$AA@ ; `string'
PUBLIC	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z ; TreasuryHelpers::AppendToLog
PUBLIC	??_C@_04EKEMLFA@Turn?$AA@			; `string'
PUBLIC	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z ; TreasuryHelpers::AppendToLog
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_08IFIFDOPL@Civ?5Name?$AA@			; `string'
PUBLIC	??_C@_0BD@DOEGLOHP@ExpenditureLog?4csv?$AA@	; `string'
PUBLIC	??_C@_04EBGNMJBD@?4csv?$AA@			; `string'
PUBLIC	??_C@_0BA@JPFFLKJG@ExpenditureLog_?$AA@		; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z	; CvTreasury::LogExpenditure
EXTRN	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ:PROC ; CvPlayer::GetTreasury
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	?GetInstance@FILogFileMgr@@SAAAV1@XZ:PROC	; FILogFileMgr::GetInstance
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z:PROC
EXTRN	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ:PROC ; CvGlobals::getPlayerAndCityAILogSplit
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
EXTRN	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationShortDescription
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	?getAILogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getAILogging
EXTRN	?getLogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getLogging
;	COMDAT ??_C@_0BJ@HAEBLPBN@Research?5Agreement?5Cost?3?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BJ@HAEBLPBN@Research?5Agreement?5Cost?3?$AA@ DB 'Research Agreemen'
	DB	't Cost:', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@OIABGNKL@Research?5Agreement?5with?3?$AA@
CONST	SEGMENT
??_C@_0BJ@OIABGNKL@Research?5Agreement?5with?3?$AA@ DB 'Research Agreemen'
	DB	't with:', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@NPIPBGEN@Emergency?5Building?5Cost?3?$AA@
CONST	SEGMENT
??_C@_0BJ@NPIPBGEN@Emergency?5Building?5Cost?3?$AA@ DB 'Emergency Buildin'
	DB	'g Cost:', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GIABCIPA@Emergency?5Building?3?$AA@
CONST	SEGMENT
??_C@_0BE@GIABCIPA@Emergency?5Building?3?$AA@ DB 'Emergency Building:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OBMNJCAM@Emergency?5Unit?5Cost?3?$AA@
CONST	SEGMENT
??_C@_0BF@OBMNJCAM@Emergency?5Unit?5Cost?3?$AA@ DB 'Emergency Unit Cost:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MKJAPDEO@Emergency?5Unit?3?$AA@
CONST	SEGMENT
??_C@_0BA@MKJAPDEO@Emergency?5Unit?3?$AA@ DB 'Emergency Unit:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KIFCJNEP@Bought?5for?3?$AA@
CONST	SEGMENT
??_C@_0M@KIFCJNEP@Bought?5for?3?$AA@ DB 'Bought for:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MOGJFNDG@City?5State?5Bought?3?$AA@
CONST	SEGMENT
??_C@_0BD@MOGJFNDG@City?5State?5Bought?3?$AA@ DB 'City State Bought:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JKEBKCPE@Gold?5for?5Improvement?5Amount?3?$AA@
CONST	SEGMENT
??_C@_0BN@JKEBKCPE@Gold?5for?5Improvement?5Amount?3?$AA@ DB 'Gold for Imp'
	DB	'rovement Amount:', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KJAKNNIA@City?5State?5Improved?3?$AA@
CONST	SEGMENT
??_C@_0BF@KJAKNNIA@City?5State?5Improved?3?$AA@ DB 'City State Improved:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DHDMLBIJ@Gold?5Gift?5Amount?3?$AA@
CONST	SEGMENT
??_C@_0BC@DHDMLBIJ@Gold?5Gift?5Amount?3?$AA@ DB 'Gold Gift Amount:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@OOJPHEDP@City?5State?5Gold?5Gifted?3?$AA@
CONST	SEGMENT
??_C@_0BI@OOJPHEDP@City?5State?5Gold?5Gifted?3?$AA@ DB 'City State Gold G'
	DB	'ifted:', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CKGJCDAN@Unit?5Upgrade?3?$AA@
CONST	SEGMENT
??_C@_0O@CKGJCDAN@Unit?5Upgrade?3?$AA@ DB 'Unit Upgrade:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NOOEJKPD@Spent?5on?5Upgrade?3?$AA@
CONST	SEGMENT
??_C@_0BC@NOOEJKPD@Spent?5on?5Upgrade?3?$AA@ DB 'Spent on Upgrade:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DNBAMIFN@Unit?5Upgraded?3?$AA@
CONST	SEGMENT
??_C@_0P@DNBAMIFN@Unit?5Upgraded?3?$AA@ DB 'Unit Upgraded:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FHPPFOAE@City?5Spent?3?$AA@
CONST	SEGMENT
??_C@_0M@FHPPFOAE@City?5Spent?3?$AA@ DB 'City Spent:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GNBJBAKL@City?5Bought?3?$AA@
CONST	SEGMENT
??_C@_0N@GNBJBAKL@City?5Bought?3?$AA@ DB 'City Bought:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HHNGJPBC@Cost?5of?5Plot?3?$AA@
CONST	SEGMENT
??_C@_0O@HHNGJPBC@Cost?5of?5Plot?3?$AA@ DB 'Cost of Plot:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DJPJBDOC@Treasury?5Before?5Purchase?$AA@
CONST	SEGMENT
??_C@_0BJ@DJPJBDOC@Treasury?5Before?5Purchase?$AA@ DB 'Treasury Before Pu'
	DB	'rchase', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04EKEMLFA@Turn?$AA@
CONST	SEGMENT
??_C@_04EKEMLFA@Turn?$AA@ DB 'Turn', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08IFIFDOPL@Civ?5Name?$AA@
CONST	SEGMENT
??_C@_08IFIFDOPL@Civ?5Name?$AA@ DB 'Civ Name', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DOEGLOHP@ExpenditureLog?4csv?$AA@
CONST	SEGMENT
??_C@_0BD@DOEGLOHP@ExpenditureLog?4csv?$AA@ DB 'ExpenditureLog.csv', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04EBGNMJBD@?4csv?$AA@
CONST	SEGMENT
??_C@_04EBGNMJBD@?4csv?$AA@ DB '.csv', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JPFFLKJG@ExpenditureLog_?$AA@
CONST	SEGMENT
??_C@_0BA@JPFFLKJG@ExpenditureLog_?$AA@ DB 'ExpenditureLog_', 00H ; `string'
CONST	ENDS
;	COMDAT ?bFirstRun@?7??LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z@4_NA
_DATA	SEGMENT
?bFirstRun@?7??LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z@4_NA DB 01H ; `CvTreasury::LogExpenditure'::`8'::bFirstRun
_DATA	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z DD 019930522H
	DD	019H
	DD	FLAT:__unwindtable$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$6
	DD	04H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$8
	DD	07H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$14
	DD	07H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$17
	DD	07H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$20
	DD	07H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$23
	DD	07H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$26
	DD	07H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$29
	DD	07H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$32
	DD	07H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$35
	DD	07H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$38
	DD	07H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$41
	DD	07H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$44
	DD	07H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$47
	DD	07H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$50
	DD	07H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$53
	DD	07H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$56
	DD	07H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$59
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtreasury.cpp
xdata$x	ENDS
;	COMDAT ?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z
_TEXT	SEGMENT
tv1252 = -1092						; size = 4
tv2096 = -1088						; size = 4
tv1249 = -1084						; size = 4
tv2083 = -1080						; size = 4
tv1246 = -1076						; size = 4
tv2070 = -1072						; size = 4
tv1244 = -1068						; size = 4
tv2057 = -1064						; size = 4
tv1241 = -1060						; size = 4
tv2044 = -1056						; size = 4
tv1238 = -1052						; size = 4
tv1236 = -1048						; size = 4
tv2016 = -1044						; size = 4
tv1233 = -1040						; size = 4
tv2003 = -1036						; size = 4
tv1230 = -1032						; size = 4
tv1990 = -1028						; size = 4
tv1228 = -1024						; size = 4
tv1977 = -1020						; size = 4
tv1225 = -1016						; size = 4
tv1964 = -1012						; size = 4
tv1222 = -1008						; size = 4
tv1220 = -1004						; size = 4
tv1936 = -1000						; size = 4
tv1217 = -996						; size = 4
tv1923 = -992						; size = 4
tv1214 = -988						; size = 4
tv1910 = -984						; size = 4
tv1212 = -980						; size = 4
tv1897 = -976						; size = 4
tv1209 = -972						; size = 4
tv1884 = -968						; size = 4
tv1206 = -964						; size = 4
tv1204 = -960						; size = 4
tv1856 = -956						; size = 4
tv1201 = -952						; size = 4
tv1843 = -948						; size = 4
tv1198 = -944						; size = 4
tv1830 = -940						; size = 4
tv1196 = -936						; size = 4
tv1817 = -932						; size = 4
tv1193 = -928						; size = 4
tv1804 = -924						; size = 4
tv1190 = -920						; size = 4
tv1188 = -916						; size = 4
tv1776 = -912						; size = 4
tv1185 = -908						; size = 4
tv1763 = -904						; size = 4
tv1182 = -900						; size = 4
tv1750 = -896						; size = 4
tv1180 = -892						; size = 4
tv1737 = -888						; size = 4
tv1177 = -884						; size = 4
tv1724 = -880						; size = 4
tv1174 = -876						; size = 4
tv1172 = -872						; size = 4
tv1696 = -868						; size = 4
tv1169 = -864						; size = 4
tv1651 = -860						; size = 4
tv1166 = -856						; size = 4
tv1638 = -852						; size = 4
tv1164 = -848						; size = 4
tv1625 = -844						; size = 4
tv1161 = -840						; size = 4
tv1612 = -836						; size = 4
tv1158 = -832						; size = 4
tv1156 = -828						; size = 4
tv1584 = -824						; size = 4
tv1153 = -820						; size = 4
tv1571 = -816						; size = 4
tv1150 = -812						; size = 4
tv1558 = -808						; size = 4
tv1148 = -804						; size = 4
tv1545 = -800						; size = 4
tv1145 = -796						; size = 4
tv1532 = -792						; size = 4
tv1142 = -788						; size = 4
tv1140 = -784						; size = 4
tv1504 = -780						; size = 4
tv1137 = -776						; size = 4
tv1491 = -772						; size = 4
tv1134 = -768						; size = 4
tv1478 = -764						; size = 4
tv1132 = -760						; size = 4
tv1465 = -756						; size = 4
tv1129 = -752						; size = 4
tv1452 = -748						; size = 4
tv1126 = -744						; size = 4
tv1124 = -740						; size = 4
tv1424 = -736						; size = 4
tv1121 = -732						; size = 4
tv1411 = -728						; size = 4
tv1118 = -724						; size = 4
tv1398 = -720						; size = 4
tv1115 = -716						; size = 4
tv1385 = -712						; size = 4
tv1112 = -708						; size = 4
tv1372 = -704						; size = 4
tv1109 = -700						; size = 4
tv155 = -696						; size = 4
tv2081 = -692						; size = 4
tv1104 = -688						; size = 4
tv2094 = -684						; size = 4
_this$ = -680						; size = 4
$T219975 = -676						; size = 4
$T219971 = -672						; size = 4
$T219967 = -668						; size = 4
$T219958 = -664						; size = 4
$T219949 = -660						; size = 4
$T219940 = -656						; size = 4
$T219931 = -652						; size = 4
$T219922 = -648						; size = 4
$T219917 = -644						; size = 4
$T219908 = -640						; size = 4
$T219899 = -636						; size = 4
$T219890 = -632						; size = 4
$T219881 = -628						; size = 4
$T219872 = -624						; size = 4
$T219867 = -620						; size = 4
$T219858 = -616						; size = 4
$T219849 = -612						; size = 4
$T219840 = -608						; size = 4
$T219831 = -604						; size = 4
$T219822 = -600						; size = 4
$T219817 = -596						; size = 4
$T219808 = -592						; size = 4
$T219799 = -588						; size = 4
$T219790 = -584						; size = 4
$T219781 = -580						; size = 4
$T219772 = -576						; size = 4
$T219767 = -572						; size = 4
$T219758 = -568						; size = 4
$T219749 = -564						; size = 4
$T219740 = -560						; size = 4
$T219731 = -556						; size = 4
$T219722 = -552						; size = 4
$T219717 = -548						; size = 4
$T219708 = -544						; size = 4
$T219699 = -540						; size = 4
$T219690 = -536						; size = 4
$T219681 = -532						; size = 4
$T219672 = -528						; size = 4
$T219667 = -524						; size = 4
$T219658 = -520						; size = 4
$T219649 = -516						; size = 4
$T219640 = -512						; size = 4
$T219631 = -508						; size = 4
$T219622 = -504						; size = 4
$T219617 = -500						; size = 4
$T219608 = -496						; size = 4
$T219599 = -492						; size = 4
$T219590 = -488						; size = 4
$T219581 = -484						; size = 4
$T219572 = -480						; size = 4
$T219567 = -476						; size = 4
$T219558 = -472						; size = 4
$T219549 = -468						; size = 4
$T219540 = -464						; size = 4
$T219531 = -460						; size = 4
$T219527 = -456						; size = 4
$T219518 = -452						; size = 4
$T219509 = -448						; size = 4
$T219500 = -444						; size = 4
$T219492 = -440						; size = 4
$T219404 = -436						; size = 4
$T219403 = -432						; size = 4
$T219402 = -428						; size = 4
$T219401 = -424						; size = 4
$T219400 = -420						; size = 4
$T219399 = -416						; size = 4
$T219398 = -412						; size = 4
$T219397 = -408						; size = 4
$T219396 = -404						; size = 4
$T219395 = -400						; size = 4
$T219394 = -396						; size = 4
$T219393 = -392						; size = 4
$T219392 = -388						; size = 4
$T219391 = -384						; size = 4
$T219390 = -380						; size = 4
$T219389 = -376						; size = 4
$T219388 = -372						; size = 4
$T219387 = -368						; size = 4
$T219386 = -364						; size = 4
$T219385 = -360						; size = 4
$T219384 = -356						; size = 4
$T219383 = -352						; size = 4
$T219382 = -348						; size = 4
$T219381 = -344						; size = 4
$T219380 = -340						; size = 4
$T219379 = -336						; size = 4
$T219378 = -332						; size = 4
$T219377 = -328						; size = 4
$T219376 = -324						; size = 4
$T219375 = -320						; size = 4
$T219374 = -316						; size = 4
$T219373 = -312						; size = 4
$T219372 = -308						; size = 4
$T219371 = -304						; size = 4
$T219370 = -300						; size = 4
$T219369 = -296						; size = 4
$T219368 = -292						; size = 4
$T219367 = -288						; size = 4
$T219366 = -284						; size = 4
$T219365 = -280						; size = 4
$T219364 = -276						; size = 4
$T219363 = -272						; size = 4
$T219362 = -268						; size = 4
$T219361 = -264						; size = 4
$T219360 = -260						; size = 4
$T219359 = -256						; size = 4
$T219358 = -252						; size = 4
$T219357 = -248						; size = 4
$T219356 = -244						; size = 4
$T219355 = -240						; size = 4
$T219354 = -236						; size = 4
$T219353 = -232						; size = 4
$T219352 = -228						; size = 4
$T219351 = -224						; size = 4
$T219350 = -220						; size = 28
$T219349 = -192						; size = 28
_str$ = -164						; size = 28
_strLog$ = -136						; size = 28
_bBuildHeader$ = -105					; size = 1
_strPlayerName$ = -104					; size = 28
_strLogName$ = -76					; size = 28
_pLog$ = -48						; size = 4
_strHeader$ = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_strExpenditure$ = 8					; size = 28
_iAmount$ = 36						; size = 4
_iColumn$ = 40						; size = 4
?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z PROC	; CvTreasury::LogExpenditure, COMDAT
; _this$ = ecx

; 900  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1080				; 00000438H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 901  : 	if(!(GC.getLogging() && GC.getAILogging()))

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN24@LogExpendi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN25@LogExpendi
$LN24@LogExpendi:

; 902  : 	{
; 903  : 		return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strExpenditure$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	$LN26@LogExpendi
$LN25@LogExpendi:

; 904  : 	}
; 905  : 
; 906  : 	// don't log minor civs for now
; 907  : 	if(m_pPlayer->isMinorCiv())

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN23@LogExpendi

; 908  : 	{
; 909  : 		return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strExpenditure$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	$LN26@LogExpendi
$LN23@LogExpendi:

; 910  : 	}
; 911  : 
; 912  : 	static bool bFirstRun = true;
; 913  : 	bool bBuildHeader = false;

	mov	BYTE PTR _bBuildHeader$[ebp], 0

; 914  : 	CvString strHeader;

	lea	ecx, DWORD PTR _strHeader$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 915  : 	if(bFirstRun)

	movzx	ecx, BYTE PTR ?bFirstRun@?7??LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z@4_NA
	test	ecx, ecx
	je	SHORT $LN22@LogExpendi

; 916  : 	{
; 917  : 		bFirstRun = false;

	mov	BYTE PTR ?bFirstRun@?7??LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z@4_NA, 0

; 918  : 		bBuildHeader = true;

	mov	BYTE PTR _bBuildHeader$[ebp], 1
$LN22@LogExpendi:

; 919  : 	}
; 920  : 
; 921  : 	CvString strLog;

	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 922  : 
; 923  : 	// Find the name of this civ and city
; 924  : 	CvString strPlayerName;

	lea	ecx, DWORD PTR _strPlayerName$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 925  : 	strPlayerName = m_pPlayer->getCivilizationShortDescription();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T219492[ebp], eax
	cmp	DWORD PTR $T219492[ebp], 0
	je	SHORT $LN106@LogExpendi
	mov	eax, DWORD PTR $T219492[ebp]
	push	eax
	lea	ecx, DWORD PTR _strPlayerName$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN107@LogExpendi
$LN106@LogExpendi:
	lea	ecx, DWORD PTR _strPlayerName$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN107@LogExpendi:

; 926  : 	CvString strLogName;

	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 927  : 
; 928  : 	// Open the log file
; 929  : 	if(GC.getPlayerAndCityAILogSplit())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ ; CvGlobals::getPlayerAndCityAILogSplit
	movzx	ecx, al
	test	ecx, ecx
	je	$LN21@LogExpendi

; 930  : 	{
; 931  : 		strLogName = "ExpenditureLog_" + strPlayerName + ".csv";

	lea	edx, DWORD PTR _strPlayerName$[ebp]
	push	edx
	push	OFFSET ??_C@_0BA@JPFFLKJG@ExpenditureLog_?$AA@
	lea	eax, DWORD PTR $T219349[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv2094[ebp], eax
	mov	ecx, DWORD PTR tv2094[ebp]
	mov	DWORD PTR tv1104[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	push	OFFSET ??_C@_04EBGNMJBD@?4csv?$AA@
	mov	edx, DWORD PTR tv1104[ebp]
	push	edx
	lea	eax, DWORD PTR $T219350[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv2081[ebp], eax
	mov	ecx, DWORD PTR tv2081[ebp]
	mov	DWORD PTR $T219500[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR $T219500[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T219350[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T219349[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 932  : 	}
; 933  : 	else

	jmp	SHORT $LN20@LogExpendi
$LN21@LogExpendi:

; 934  : 	{
; 935  : 		strLogName = "ExpenditureLog.csv";

	mov	edx, OFFSET ??_C@_0BD@DOEGLOHP@ExpenditureLog?4csv?$AA@
	test	edx, edx
	je	SHORT $LN115@LogExpendi
	push	OFFSET ??_C@_0BD@DOEGLOHP@ExpenditureLog?4csv?$AA@
	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN20@LogExpendi
$LN115@LogExpendi:
	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN20@LogExpendi:

; 936  : 	}
; 937  : 
; 938  : 
; 939  : 	FILogFile* pLog;
; 940  : 	pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv155[ebp], eax
	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T219509[ebp], eax
	push	0
	push	1
	mov	eax, DWORD PTR $T219509[ebp]
	push	eax
	mov	ecx, DWORD PTR tv155[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv155[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pLog$[ebp], eax

; 941  : 
; 942  : 	CvString str;

	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 7

; 943  : 
; 944  : 	// civ name
; 945  : 	TreasuryHelpers::AppendToLog(strHeader, strLog, "Civ Name", strPlayerName);

	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T219351[ebp], esp
	mov	DWORD PTR $T219518[ebp], ecx
	lea	edx, DWORD PTR _strPlayerName$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T219518[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T219518[ebp]
	mov	DWORD PTR tv1109[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T219352[ebp], esp
	mov	DWORD PTR $T219527[ebp], ecx
	mov	edx, OFFSET ??_C@_08IFIFDOPL@Civ?5Name?$AA@
	test	edx, edx
	je	SHORT $LN128@LogExpendi
	mov	DWORD PTR tv1372[ebp], OFFSET ??_C@_08IFIFDOPL@Civ?5Name?$AA@
	jmp	SHORT $LN129@LogExpendi
$LN128@LogExpendi:
	mov	DWORD PTR tv1372[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN129@LogExpendi:
	mov	eax, DWORD PTR tv1372[ebp]
	push	eax
	mov	ecx, DWORD PTR $T219527[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR $T219527[ebp]
	mov	DWORD PTR tv1112[ebp], ecx
	lea	edx, DWORD PTR _strLog$[ebp]
	push	edx
	lea	eax, DWORD PTR _strHeader$[ebp]
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z ; TreasuryHelpers::AppendToLog
	add	esp, 64					; 00000040H

; 946  : 
; 947  : 	// turn
; 948  : 	TreasuryHelpers::AppendToLog(strHeader, strLog, "Turn", GC.getGame().getGameTurn());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T219531[ebp], ecx
	mov	ecx, DWORD PTR $T219531[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	push	eax
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T219353[ebp], esp
	mov	DWORD PTR $T219540[ebp], edx
	mov	eax, OFFSET ??_C@_04EKEMLFA@Turn?$AA@
	test	eax, eax
	je	SHORT $LN135@LogExpendi
	mov	DWORD PTR tv1385[ebp], OFFSET ??_C@_04EKEMLFA@Turn?$AA@
	jmp	SHORT $LN136@LogExpendi
$LN135@LogExpendi:
	mov	DWORD PTR tv1385[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN136@LogExpendi:
	mov	ecx, DWORD PTR tv1385[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T219540[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T219540[ebp]
	mov	DWORD PTR tv1115[ebp], edx
	lea	eax, DWORD PTR _strLog$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[ebp]
	push	ecx
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z ; TreasuryHelpers::AppendToLog
	add	esp, 40					; 00000028H

; 949  : 
; 950  : 	// treasury at turn start
; 951  : 	TreasuryHelpers::AppendToLog(strHeader, strLog, "Treasury Before Purchase", m_pPlayer->GetTreasury()->GetGold());

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?GetGold@CvTreasury@@QBEHXZ		; CvTreasury::GetGold
	push	eax
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T219354[ebp], esp
	mov	DWORD PTR $T219549[ebp], eax
	mov	ecx, OFFSET ??_C@_0BJ@DJPJBDOC@Treasury?5Before?5Purchase?$AA@
	test	ecx, ecx
	je	SHORT $LN140@LogExpendi
	mov	DWORD PTR tv1398[ebp], OFFSET ??_C@_0BJ@DJPJBDOC@Treasury?5Before?5Purchase?$AA@
	jmp	SHORT $LN141@LogExpendi
$LN140@LogExpendi:
	mov	DWORD PTR tv1398[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN141@LogExpendi:
	mov	edx, DWORD PTR tv1398[ebp]
	push	edx
	mov	ecx, DWORD PTR $T219549[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR $T219549[ebp]
	mov	DWORD PTR tv1118[ebp], eax
	lea	ecx, DWORD PTR _strLog$[ebp]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[ebp]
	push	edx
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z ; TreasuryHelpers::AppendToLog
	add	esp, 40					; 00000028H

; 952  : 	
; 953  : 	// Cost of Plot
; 954  : 	if (iColumn == 1){

	cmp	DWORD PTR _iColumn$[ebp], 1
	jne	SHORT $LN19@LogExpendi

; 955  : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Cost of Plot:", iAmount);

	mov	eax, DWORD PTR _iAmount$[ebp]
	push	eax
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T219355[ebp], esp
	mov	DWORD PTR $T219558[ebp], ecx
	mov	edx, OFFSET ??_C@_0O@HHNGJPBC@Cost?5of?5Plot?3?$AA@
	test	edx, edx
	je	SHORT $LN145@LogExpendi
	mov	DWORD PTR tv1411[ebp], OFFSET ??_C@_0O@HHNGJPBC@Cost?5of?5Plot?3?$AA@
	jmp	SHORT $LN146@LogExpendi
$LN145@LogExpendi:
	mov	DWORD PTR tv1411[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN146@LogExpendi:
	mov	eax, DWORD PTR tv1411[ebp]
	push	eax
	mov	ecx, DWORD PTR $T219558[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR $T219558[ebp]
	mov	DWORD PTR tv1121[ebp], ecx
	lea	edx, DWORD PTR _strLog$[ebp]
	push	edx
	lea	eax, DWORD PTR _strHeader$[ebp]
	push	eax
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z ; TreasuryHelpers::AppendToLog
	add	esp, 40					; 00000028H

; 956  : 	}
; 957  : 	else{

	jmp	SHORT $LN18@LogExpendi
$LN19@LogExpendi:

; 958  : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Cost of Plot:", 0);

	push	0
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T219356[ebp], esp
	mov	DWORD PTR $T219567[ebp], ecx
	mov	edx, OFFSET ??_C@_0O@HHNGJPBC@Cost?5of?5Plot?3?$AA@
	test	edx, edx
	je	SHORT $LN150@LogExpendi
	mov	DWORD PTR tv1424[ebp], OFFSET ??_C@_0O@HHNGJPBC@Cost?5of?5Plot?3?$AA@
	jmp	SHORT $LN151@LogExpendi
$LN150@LogExpendi:
	mov	DWORD PTR tv1424[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN151@LogExpendi:
	mov	eax, DWORD PTR tv1424[ebp]
	push	eax
	mov	ecx, DWORD PTR $T219567[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR $T219567[ebp]
	mov	DWORD PTR tv1124[ebp], ecx
	lea	edx, DWORD PTR _strLog$[ebp]
	push	edx
	lea	eax, DWORD PTR _strHeader$[ebp]
	push	eax
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z ; TreasuryHelpers::AppendToLog
	add	esp, 40					; 00000028H
$LN18@LogExpendi:

; 959  : 	}
; 960  : 	
; 961  : 	// City Expenditure and Amount
; 962  : 	if (iColumn == 2){

	cmp	DWORD PTR _iColumn$[ebp], 2
	jne	$LN17@LogExpendi

; 963  : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "City Bought:", strExpenditure);

	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T219357[ebp], esp
	mov	DWORD PTR $T219572[ebp], ecx
	lea	edx, DWORD PTR _strExpenditure$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T219572[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T219572[ebp]
	mov	DWORD PTR tv1126[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T219358[ebp], esp
	mov	DWORD PTR $T219581[ebp], ecx
	mov	edx, OFFSET ??_C@_0N@GNBJBAKL@City?5Bought?3?$AA@
	test	edx, edx
	je	SHORT $LN158@LogExpendi
	mov	DWORD PTR tv1452[ebp], OFFSET ??_C@_0N@GNBJBAKL@City?5Bought?3?$AA@
	jmp	SHORT $LN159@LogExpendi
$LN158@LogExpendi:
	mov	DWORD PTR tv1452[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN159@LogExpendi:
	mov	eax, DWORD PTR tv1452[ebp]
	push	eax
	mov	ecx, DWORD PTR $T219581[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR $T219581[ebp]
	mov	DWORD PTR tv1129[ebp], ecx
	lea	edx, DWORD PTR _strLog$[ebp]
	push	edx
	lea	eax, DWORD PTR _strHeader$[ebp]
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z ; TreasuryHelpers::AppendToLog
	add	esp, 64					; 00000040H

; 964  : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "City Spent:", iAmount);

	mov	ecx, DWORD PTR _iAmount$[ebp]
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T219359[ebp], esp
	mov	DWORD PTR $T219590[ebp], edx
	mov	eax, OFFSET ??_C@_0M@FHPPFOAE@City?5Spent?3?$AA@
	test	eax, eax
	je	SHORT $LN163@LogExpendi
	mov	DWORD PTR tv1465[ebp], OFFSET ??_C@_0M@FHPPFOAE@City?5Spent?3?$AA@
	jmp	SHORT $LN164@LogExpendi
$LN163@LogExpendi:
	mov	DWORD PTR tv1465[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN164@LogExpendi:
	mov	ecx, DWORD PTR tv1465[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T219590[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T219590[ebp]
	mov	DWORD PTR tv1132[ebp], edx
	lea	eax, DWORD PTR _strLog$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[ebp]
	push	ecx
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z ; TreasuryHelpers::AppendToLog
	add	esp, 40					; 00000028H

; 965  : 	}
; 966  : 	else{

	jmp	$LN16@LogExpendi
$LN17@LogExpendi:

; 967  : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "City Bought:", "");

	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T219360[ebp], esp
	mov	DWORD PTR $T219599[ebp], edx
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
	test	eax, eax
	je	SHORT $LN168@LogExpendi
	mov	DWORD PTR tv1478[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
	jmp	SHORT $LN169@LogExpendi
$LN168@LogExpendi:
	mov	DWORD PTR tv1478[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN169@LogExpendi:
	mov	ecx, DWORD PTR tv1478[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T219599[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T219599[ebp]
	mov	DWORD PTR tv1134[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T219361[ebp], esp
	mov	DWORD PTR $T219608[ebp], eax
	mov	ecx, OFFSET ??_C@_0N@GNBJBAKL@City?5Bought?3?$AA@
	test	ecx, ecx
	je	SHORT $LN173@LogExpendi
	mov	DWORD PTR tv1491[ebp], OFFSET ??_C@_0N@GNBJBAKL@City?5Bought?3?$AA@
	jmp	SHORT $LN174@LogExpendi
$LN173@LogExpendi:
	mov	DWORD PTR tv1491[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN174@LogExpendi:
	mov	edx, DWORD PTR tv1491[ebp]
	push	edx
	mov	ecx, DWORD PTR $T219608[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR $T219608[ebp]
	mov	DWORD PTR tv1137[ebp], eax
	lea	ecx, DWORD PTR _strLog$[ebp]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[ebp]
	push	edx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z ; TreasuryHelpers::AppendToLog
	add	esp, 64					; 00000040H

; 968  : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "City Spent:", 0);

	push	0
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T219362[ebp], esp
	mov	DWORD PTR $T219617[ebp], eax
	mov	ecx, OFFSET ??_C@_0M@FHPPFOAE@City?5Spent?3?$AA@
	test	ecx, ecx
	je	SHORT $LN178@LogExpendi
	mov	DWORD PTR tv1504[ebp], OFFSET ??_C@_0M@FHPPFOAE@City?5Spent?3?$AA@
	jmp	SHORT $LN179@LogExpendi
$LN178@LogExpendi:
	mov	DWORD PTR tv1504[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN179@LogExpendi:
	mov	edx, DWORD PTR tv1504[ebp]
	push	edx
	mov	ecx, DWORD PTR $T219617[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR $T219617[ebp]
	mov	DWORD PTR tv1140[ebp], eax
	lea	ecx, DWORD PTR _strLog$[ebp]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[ebp]
	push	edx
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z ; TreasuryHelpers::AppendToLog
	add	esp, 40					; 00000028H
$LN16@LogExpendi:

; 969  : 	}
; 970  : 	
; 971  : 	// Unit Upgrade and cost
; 972  : 	if (iColumn == 3){

	cmp	DWORD PTR _iColumn$[ebp], 3
	jne	$LN15@LogExpendi

; 973  : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Unit Upgraded:", strExpenditure);

	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T219363[ebp], esp
	mov	DWORD PTR $T219622[ebp], eax
	lea	ecx, DWORD PTR _strExpenditure$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T219622[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	edx, DWORD PTR $T219622[ebp]
	mov	DWORD PTR tv1142[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T219364[ebp], esp
	mov	DWORD PTR $T219631[ebp], eax
	mov	ecx, OFFSET ??_C@_0P@DNBAMIFN@Unit?5Upgraded?3?$AA@
	test	ecx, ecx
	je	SHORT $LN186@LogExpendi
	mov	DWORD PTR tv1532[ebp], OFFSET ??_C@_0P@DNBAMIFN@Unit?5Upgraded?3?$AA@
	jmp	SHORT $LN187@LogExpendi
$LN186@LogExpendi:
	mov	DWORD PTR tv1532[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN187@LogExpendi:
	mov	edx, DWORD PTR tv1532[ebp]
	push	edx
	mov	ecx, DWORD PTR $T219631[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR $T219631[ebp]
	mov	DWORD PTR tv1145[ebp], eax
	lea	ecx, DWORD PTR _strLog$[ebp]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[ebp]
	push	edx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z ; TreasuryHelpers::AppendToLog
	add	esp, 64					; 00000040H

; 974  : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Spent on Upgrade:", iAmount);

	mov	eax, DWORD PTR _iAmount$[ebp]
	push	eax
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T219365[ebp], esp
	mov	DWORD PTR $T219640[ebp], ecx
	mov	edx, OFFSET ??_C@_0BC@NOOEJKPD@Spent?5on?5Upgrade?3?$AA@
	test	edx, edx
	je	SHORT $LN191@LogExpendi
	mov	DWORD PTR tv1545[ebp], OFFSET ??_C@_0BC@NOOEJKPD@Spent?5on?5Upgrade?3?$AA@
	jmp	SHORT $LN192@LogExpendi
$LN191@LogExpendi:
	mov	DWORD PTR tv1545[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN192@LogExpendi:
	mov	eax, DWORD PTR tv1545[ebp]
	push	eax
	mov	ecx, DWORD PTR $T219640[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR $T219640[ebp]
	mov	DWORD PTR tv1148[ebp], ecx
	lea	edx, DWORD PTR _strLog$[ebp]
	push	edx
	lea	eax, DWORD PTR _strHeader$[ebp]
	push	eax
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z ; TreasuryHelpers::AppendToLog
	add	esp, 40					; 00000028H

; 975  : 	}
; 976  : 	else{

	jmp	$LN14@LogExpendi
$LN15@LogExpendi:

; 977  : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Unit Upgrade:", "");

	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T219366[ebp], esp
	mov	DWORD PTR $T219649[ebp], ecx
	mov	edx, OFFSET ??_C@_00CNPNBAHC@?$AA@
	test	edx, edx
	je	SHORT $LN196@LogExpendi
	mov	DWORD PTR tv1558[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
	jmp	SHORT $LN197@LogExpendi
$LN196@LogExpendi:
	mov	DWORD PTR tv1558[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN197@LogExpendi:
	mov	eax, DWORD PTR tv1558[ebp]
	push	eax
	mov	ecx, DWORD PTR $T219649[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR $T219649[ebp]
	mov	DWORD PTR tv1150[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T219367[ebp], esp
	mov	DWORD PTR $T219658[ebp], edx
	mov	eax, OFFSET ??_C@_0O@CKGJCDAN@Unit?5Upgrade?3?$AA@
	test	eax, eax
	je	SHORT $LN201@LogExpendi
	mov	DWORD PTR tv1571[ebp], OFFSET ??_C@_0O@CKGJCDAN@Unit?5Upgrade?3?$AA@
	jmp	SHORT $LN202@LogExpendi
$LN201@LogExpendi:
	mov	DWORD PTR tv1571[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN202@LogExpendi:
	mov	ecx, DWORD PTR tv1571[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T219658[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T219658[ebp]
	mov	DWORD PTR tv1153[ebp], edx
	lea	eax, DWORD PTR _strLog$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[ebp]
	push	ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z ; TreasuryHelpers::AppendToLog
	add	esp, 64					; 00000040H

; 978  : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Spent on Upgrade:", 0);

	push	0
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T219368[ebp], esp
	mov	DWORD PTR $T219667[ebp], edx
	mov	eax, OFFSET ??_C@_0BC@NOOEJKPD@Spent?5on?5Upgrade?3?$AA@
	test	eax, eax
	je	SHORT $LN206@LogExpendi
	mov	DWORD PTR tv1584[ebp], OFFSET ??_C@_0BC@NOOEJKPD@Spent?5on?5Upgrade?3?$AA@
	jmp	SHORT $LN207@LogExpendi
$LN206@LogExpendi:
	mov	DWORD PTR tv1584[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN207@LogExpendi:
	mov	ecx, DWORD PTR tv1584[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T219667[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T219667[ebp]
	mov	DWORD PTR tv1156[ebp], edx
	lea	eax, DWORD PTR _strLog$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[ebp]
	push	ecx
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z ; TreasuryHelpers::AppendToLog
	add	esp, 40					; 00000028H
$LN14@LogExpendi:

; 979  : 	}
; 980  : 
; 981  : 	// City State Gifted and Amount
; 982  : 	if (iColumn == 4){

	cmp	DWORD PTR _iColumn$[ebp], 4
	jne	$LN13@LogExpendi

; 983  : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "City State Gold Gifted:", strExpenditure);

	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T219369[ebp], esp
	mov	DWORD PTR $T219672[ebp], edx
	lea	eax, DWORD PTR _strExpenditure$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T219672[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T219672[ebp]
	mov	DWORD PTR tv1158[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T219370[ebp], esp
	mov	DWORD PTR $T219681[ebp], edx
	mov	eax, OFFSET ??_C@_0BI@OOJPHEDP@City?5State?5Gold?5Gifted?3?$AA@
	test	eax, eax
	je	SHORT $LN214@LogExpendi
	mov	DWORD PTR tv1612[ebp], OFFSET ??_C@_0BI@OOJPHEDP@City?5State?5Gold?5Gifted?3?$AA@
	jmp	SHORT $LN215@LogExpendi
$LN214@LogExpendi:
	mov	DWORD PTR tv1612[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN215@LogExpendi:
	mov	ecx, DWORD PTR tv1612[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T219681[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T219681[ebp]
	mov	DWORD PTR tv1161[ebp], edx
	lea	eax, DWORD PTR _strLog$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[ebp]
	push	ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z ; TreasuryHelpers::AppendToLog
	add	esp, 64					; 00000040H

; 984  : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Gold Gift Amount:", iAmount);

	mov	edx, DWORD PTR _iAmount$[ebp]
	push	edx
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T219371[ebp], esp
	mov	DWORD PTR $T219690[ebp], eax
	mov	ecx, OFFSET ??_C@_0BC@DHDMLBIJ@Gold?5Gift?5Amount?3?$AA@
	test	ecx, ecx
	je	SHORT $LN219@LogExpendi
	mov	DWORD PTR tv1625[ebp], OFFSET ??_C@_0BC@DHDMLBIJ@Gold?5Gift?5Amount?3?$AA@
	jmp	SHORT $LN220@LogExpendi
$LN219@LogExpendi:
	mov	DWORD PTR tv1625[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN220@LogExpendi:
	mov	edx, DWORD PTR tv1625[ebp]
	push	edx
	mov	ecx, DWORD PTR $T219690[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR $T219690[ebp]
	mov	DWORD PTR tv1164[ebp], eax
	lea	ecx, DWORD PTR _strLog$[ebp]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[ebp]
	push	edx
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z ; TreasuryHelpers::AppendToLog
	add	esp, 40					; 00000028H

; 985  : 	}
; 986  : 	else{

	jmp	$LN12@LogExpendi
$LN13@LogExpendi:

; 987  : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "City State Gold Gifted:", "");

	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T219372[ebp], esp
	mov	DWORD PTR $T219699[ebp], eax
	mov	ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
	test	ecx, ecx
	je	SHORT $LN224@LogExpendi
	mov	DWORD PTR tv1638[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
	jmp	SHORT $LN225@LogExpendi
$LN224@LogExpendi:
	mov	DWORD PTR tv1638[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN225@LogExpendi:
	mov	edx, DWORD PTR tv1638[ebp]
	push	edx
	mov	ecx, DWORD PTR $T219699[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR $T219699[ebp]
	mov	DWORD PTR tv1166[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T219373[ebp], esp
	mov	DWORD PTR $T219708[ebp], ecx
	mov	edx, OFFSET ??_C@_0BI@OOJPHEDP@City?5State?5Gold?5Gifted?3?$AA@
	test	edx, edx
	je	SHORT $LN229@LogExpendi
	mov	DWORD PTR tv1651[ebp], OFFSET ??_C@_0BI@OOJPHEDP@City?5State?5Gold?5Gifted?3?$AA@
	jmp	SHORT $LN230@LogExpendi
$LN229@LogExpendi:
	mov	DWORD PTR tv1651[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN230@LogExpendi:
	mov	eax, DWORD PTR tv1651[ebp]
	push	eax
	mov	ecx, DWORD PTR $T219708[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR $T219708[ebp]
	mov	DWORD PTR tv1169[ebp], ecx
	lea	edx, DWORD PTR _strLog$[ebp]
	push	edx
	lea	eax, DWORD PTR _strHeader$[ebp]
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z ; TreasuryHelpers::AppendToLog
	add	esp, 64					; 00000040H

; 988  : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Gold Gift Amount:", 0);

	push	0
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T219374[ebp], esp
	mov	DWORD PTR $T219717[ebp], ecx
	mov	edx, OFFSET ??_C@_0BC@DHDMLBIJ@Gold?5Gift?5Amount?3?$AA@
	test	edx, edx
	je	SHORT $LN234@LogExpendi
	mov	DWORD PTR tv1696[ebp], OFFSET ??_C@_0BC@DHDMLBIJ@Gold?5Gift?5Amount?3?$AA@
	jmp	SHORT $LN235@LogExpendi
$LN234@LogExpendi:
	mov	DWORD PTR tv1696[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN235@LogExpendi:
	mov	eax, DWORD PTR tv1696[ebp]
	push	eax
	mov	ecx, DWORD PTR $T219717[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR $T219717[ebp]
	mov	DWORD PTR tv1172[ebp], ecx
	lea	edx, DWORD PTR _strLog$[ebp]
	push	edx
	lea	eax, DWORD PTR _strHeader$[ebp]
	push	eax
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z ; TreasuryHelpers::AppendToLog
	add	esp, 40					; 00000028H
$LN12@LogExpendi:

; 989  : 	}
; 990  : 	
; 991  : 	// City State Improved and Amount
; 992  : 	if (iColumn == 5){

	cmp	DWORD PTR _iColumn$[ebp], 5
	jne	$LN11@LogExpendi

; 993  : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "City State Improved:", strExpenditure);

	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T219375[ebp], esp
	mov	DWORD PTR $T219722[ebp], ecx
	lea	edx, DWORD PTR _strExpenditure$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T219722[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T219722[ebp]
	mov	DWORD PTR tv1174[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 15		; 0000000fH
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T219376[ebp], esp
	mov	DWORD PTR $T219731[ebp], ecx
	mov	edx, OFFSET ??_C@_0BF@KJAKNNIA@City?5State?5Improved?3?$AA@
	test	edx, edx
	je	SHORT $LN242@LogExpendi
	mov	DWORD PTR tv1724[ebp], OFFSET ??_C@_0BF@KJAKNNIA@City?5State?5Improved?3?$AA@
	jmp	SHORT $LN243@LogExpendi
$LN242@LogExpendi:
	mov	DWORD PTR tv1724[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN243@LogExpendi:
	mov	eax, DWORD PTR tv1724[ebp]
	push	eax
	mov	ecx, DWORD PTR $T219731[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR $T219731[ebp]
	mov	DWORD PTR tv1177[ebp], ecx
	lea	edx, DWORD PTR _strLog$[ebp]
	push	edx
	lea	eax, DWORD PTR _strHeader$[ebp]
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z ; TreasuryHelpers::AppendToLog
	add	esp, 64					; 00000040H

; 994  : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Gold for Improvement Amount:", iAmount);

	mov	ecx, DWORD PTR _iAmount$[ebp]
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T219377[ebp], esp
	mov	DWORD PTR $T219740[ebp], edx
	mov	eax, OFFSET ??_C@_0BN@JKEBKCPE@Gold?5for?5Improvement?5Amount?3?$AA@
	test	eax, eax
	je	SHORT $LN247@LogExpendi
	mov	DWORD PTR tv1737[ebp], OFFSET ??_C@_0BN@JKEBKCPE@Gold?5for?5Improvement?5Amount?3?$AA@
	jmp	SHORT $LN248@LogExpendi
$LN247@LogExpendi:
	mov	DWORD PTR tv1737[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN248@LogExpendi:
	mov	ecx, DWORD PTR tv1737[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T219740[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T219740[ebp]
	mov	DWORD PTR tv1180[ebp], edx
	lea	eax, DWORD PTR _strLog$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[ebp]
	push	ecx
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z ; TreasuryHelpers::AppendToLog
	add	esp, 40					; 00000028H

; 995  : 	}
; 996  : 	else{

	jmp	$LN10@LogExpendi
$LN11@LogExpendi:

; 997  : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "City State Improved:", "");

	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T219378[ebp], esp
	mov	DWORD PTR $T219749[ebp], edx
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
	test	eax, eax
	je	SHORT $LN252@LogExpendi
	mov	DWORD PTR tv1750[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
	jmp	SHORT $LN253@LogExpendi
$LN252@LogExpendi:
	mov	DWORD PTR tv1750[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN253@LogExpendi:
	mov	ecx, DWORD PTR tv1750[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T219749[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T219749[ebp]
	mov	DWORD PTR tv1182[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 16		; 00000010H
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T219379[ebp], esp
	mov	DWORD PTR $T219758[ebp], eax
	mov	ecx, OFFSET ??_C@_0BF@KJAKNNIA@City?5State?5Improved?3?$AA@
	test	ecx, ecx
	je	SHORT $LN257@LogExpendi
	mov	DWORD PTR tv1763[ebp], OFFSET ??_C@_0BF@KJAKNNIA@City?5State?5Improved?3?$AA@
	jmp	SHORT $LN258@LogExpendi
$LN257@LogExpendi:
	mov	DWORD PTR tv1763[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN258@LogExpendi:
	mov	edx, DWORD PTR tv1763[ebp]
	push	edx
	mov	ecx, DWORD PTR $T219758[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR $T219758[ebp]
	mov	DWORD PTR tv1185[ebp], eax
	lea	ecx, DWORD PTR _strLog$[ebp]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[ebp]
	push	edx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z ; TreasuryHelpers::AppendToLog
	add	esp, 64					; 00000040H

; 998  : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Gold for Improvement Amount:", 0);

	push	0
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T219380[ebp], esp
	mov	DWORD PTR $T219767[ebp], eax
	mov	ecx, OFFSET ??_C@_0BN@JKEBKCPE@Gold?5for?5Improvement?5Amount?3?$AA@
	test	ecx, ecx
	je	SHORT $LN262@LogExpendi
	mov	DWORD PTR tv1776[ebp], OFFSET ??_C@_0BN@JKEBKCPE@Gold?5for?5Improvement?5Amount?3?$AA@
	jmp	SHORT $LN263@LogExpendi
$LN262@LogExpendi:
	mov	DWORD PTR tv1776[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN263@LogExpendi:
	mov	edx, DWORD PTR tv1776[ebp]
	push	edx
	mov	ecx, DWORD PTR $T219767[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR $T219767[ebp]
	mov	DWORD PTR tv1188[ebp], eax
	lea	ecx, DWORD PTR _strLog$[ebp]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[ebp]
	push	edx
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z ; TreasuryHelpers::AppendToLog
	add	esp, 40					; 00000028H
$LN10@LogExpendi:

; 999  : 	}
; 1000 : 
; 1001 : 	// City State Bought and Amount
; 1002 : 	if (iColumn == 6){

	cmp	DWORD PTR _iColumn$[ebp], 6
	jne	$LN9@LogExpendi

; 1003 : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "City State Bought:", strExpenditure);

	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T219381[ebp], esp
	mov	DWORD PTR $T219772[ebp], eax
	lea	ecx, DWORD PTR _strExpenditure$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T219772[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	edx, DWORD PTR $T219772[ebp]
	mov	DWORD PTR tv1190[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 17		; 00000011H
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T219382[ebp], esp
	mov	DWORD PTR $T219781[ebp], eax
	mov	ecx, OFFSET ??_C@_0BD@MOGJFNDG@City?5State?5Bought?3?$AA@
	test	ecx, ecx
	je	SHORT $LN270@LogExpendi
	mov	DWORD PTR tv1804[ebp], OFFSET ??_C@_0BD@MOGJFNDG@City?5State?5Bought?3?$AA@
	jmp	SHORT $LN271@LogExpendi
$LN270@LogExpendi:
	mov	DWORD PTR tv1804[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN271@LogExpendi:
	mov	edx, DWORD PTR tv1804[ebp]
	push	edx
	mov	ecx, DWORD PTR $T219781[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR $T219781[ebp]
	mov	DWORD PTR tv1193[ebp], eax
	lea	ecx, DWORD PTR _strLog$[ebp]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[ebp]
	push	edx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z ; TreasuryHelpers::AppendToLog
	add	esp, 64					; 00000040H

; 1004 : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Bought for:", iAmount);

	mov	eax, DWORD PTR _iAmount$[ebp]
	push	eax
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T219383[ebp], esp
	mov	DWORD PTR $T219790[ebp], ecx
	mov	edx, OFFSET ??_C@_0M@KIFCJNEP@Bought?5for?3?$AA@
	test	edx, edx
	je	SHORT $LN275@LogExpendi
	mov	DWORD PTR tv1817[ebp], OFFSET ??_C@_0M@KIFCJNEP@Bought?5for?3?$AA@
	jmp	SHORT $LN276@LogExpendi
$LN275@LogExpendi:
	mov	DWORD PTR tv1817[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN276@LogExpendi:
	mov	eax, DWORD PTR tv1817[ebp]
	push	eax
	mov	ecx, DWORD PTR $T219790[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR $T219790[ebp]
	mov	DWORD PTR tv1196[ebp], ecx
	lea	edx, DWORD PTR _strLog$[ebp]
	push	edx
	lea	eax, DWORD PTR _strHeader$[ebp]
	push	eax
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z ; TreasuryHelpers::AppendToLog
	add	esp, 40					; 00000028H

; 1005 : 	}
; 1006 : 	else{

	jmp	$LN8@LogExpendi
$LN9@LogExpendi:

; 1007 : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "City State Bought:", "");

	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T219384[ebp], esp
	mov	DWORD PTR $T219799[ebp], ecx
	mov	edx, OFFSET ??_C@_00CNPNBAHC@?$AA@
	test	edx, edx
	je	SHORT $LN280@LogExpendi
	mov	DWORD PTR tv1830[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
	jmp	SHORT $LN281@LogExpendi
$LN280@LogExpendi:
	mov	DWORD PTR tv1830[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN281@LogExpendi:
	mov	eax, DWORD PTR tv1830[ebp]
	push	eax
	mov	ecx, DWORD PTR $T219799[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR $T219799[ebp]
	mov	DWORD PTR tv1198[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 18		; 00000012H
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T219385[ebp], esp
	mov	DWORD PTR $T219808[ebp], edx
	mov	eax, OFFSET ??_C@_0BD@MOGJFNDG@City?5State?5Bought?3?$AA@
	test	eax, eax
	je	SHORT $LN285@LogExpendi
	mov	DWORD PTR tv1843[ebp], OFFSET ??_C@_0BD@MOGJFNDG@City?5State?5Bought?3?$AA@
	jmp	SHORT $LN286@LogExpendi
$LN285@LogExpendi:
	mov	DWORD PTR tv1843[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN286@LogExpendi:
	mov	ecx, DWORD PTR tv1843[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T219808[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T219808[ebp]
	mov	DWORD PTR tv1201[ebp], edx
	lea	eax, DWORD PTR _strLog$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[ebp]
	push	ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z ; TreasuryHelpers::AppendToLog
	add	esp, 64					; 00000040H

; 1008 : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Bought for:", 0);

	push	0
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T219386[ebp], esp
	mov	DWORD PTR $T219817[ebp], edx
	mov	eax, OFFSET ??_C@_0M@KIFCJNEP@Bought?5for?3?$AA@
	test	eax, eax
	je	SHORT $LN290@LogExpendi
	mov	DWORD PTR tv1856[ebp], OFFSET ??_C@_0M@KIFCJNEP@Bought?5for?3?$AA@
	jmp	SHORT $LN291@LogExpendi
$LN290@LogExpendi:
	mov	DWORD PTR tv1856[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN291@LogExpendi:
	mov	ecx, DWORD PTR tv1856[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T219817[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T219817[ebp]
	mov	DWORD PTR tv1204[ebp], edx
	lea	eax, DWORD PTR _strLog$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[ebp]
	push	ecx
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z ; TreasuryHelpers::AppendToLog
	add	esp, 40					; 00000028H
$LN8@LogExpendi:

; 1009 : 	}
; 1010 : 	
; 1011 : 	// Emergency City Expenditure Unit and Amount
; 1012 : 	if (iColumn == 7){

	cmp	DWORD PTR _iColumn$[ebp], 7
	jne	$LN7@LogExpendi

; 1013 : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Emergency Unit:", strExpenditure);

	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T219387[ebp], esp
	mov	DWORD PTR $T219822[ebp], edx
	lea	eax, DWORD PTR _strExpenditure$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T219822[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T219822[ebp]
	mov	DWORD PTR tv1206[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 19		; 00000013H
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T219388[ebp], esp
	mov	DWORD PTR $T219831[ebp], edx
	mov	eax, OFFSET ??_C@_0BA@MKJAPDEO@Emergency?5Unit?3?$AA@
	test	eax, eax
	je	SHORT $LN298@LogExpendi
	mov	DWORD PTR tv1884[ebp], OFFSET ??_C@_0BA@MKJAPDEO@Emergency?5Unit?3?$AA@
	jmp	SHORT $LN299@LogExpendi
$LN298@LogExpendi:
	mov	DWORD PTR tv1884[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN299@LogExpendi:
	mov	ecx, DWORD PTR tv1884[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T219831[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T219831[ebp]
	mov	DWORD PTR tv1209[ebp], edx
	lea	eax, DWORD PTR _strLog$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[ebp]
	push	ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z ; TreasuryHelpers::AppendToLog
	add	esp, 64					; 00000040H

; 1014 : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Emergency Unit Cost:", iAmount);

	mov	edx, DWORD PTR _iAmount$[ebp]
	push	edx
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T219389[ebp], esp
	mov	DWORD PTR $T219840[ebp], eax
	mov	ecx, OFFSET ??_C@_0BF@OBMNJCAM@Emergency?5Unit?5Cost?3?$AA@
	test	ecx, ecx
	je	SHORT $LN303@LogExpendi
	mov	DWORD PTR tv1897[ebp], OFFSET ??_C@_0BF@OBMNJCAM@Emergency?5Unit?5Cost?3?$AA@
	jmp	SHORT $LN304@LogExpendi
$LN303@LogExpendi:
	mov	DWORD PTR tv1897[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN304@LogExpendi:
	mov	edx, DWORD PTR tv1897[ebp]
	push	edx
	mov	ecx, DWORD PTR $T219840[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR $T219840[ebp]
	mov	DWORD PTR tv1212[ebp], eax
	lea	ecx, DWORD PTR _strLog$[ebp]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[ebp]
	push	edx
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z ; TreasuryHelpers::AppendToLog
	add	esp, 40					; 00000028H

; 1015 : 	}
; 1016 : 	else{

	jmp	$LN6@LogExpendi
$LN7@LogExpendi:

; 1017 : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Emergency Unit:", "");

	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T219390[ebp], esp
	mov	DWORD PTR $T219849[ebp], eax
	mov	ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
	test	ecx, ecx
	je	SHORT $LN308@LogExpendi
	mov	DWORD PTR tv1910[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
	jmp	SHORT $LN309@LogExpendi
$LN308@LogExpendi:
	mov	DWORD PTR tv1910[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN309@LogExpendi:
	mov	edx, DWORD PTR tv1910[ebp]
	push	edx
	mov	ecx, DWORD PTR $T219849[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR $T219849[ebp]
	mov	DWORD PTR tv1214[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 20		; 00000014H
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T219391[ebp], esp
	mov	DWORD PTR $T219858[ebp], ecx
	mov	edx, OFFSET ??_C@_0BA@MKJAPDEO@Emergency?5Unit?3?$AA@
	test	edx, edx
	je	SHORT $LN313@LogExpendi
	mov	DWORD PTR tv1923[ebp], OFFSET ??_C@_0BA@MKJAPDEO@Emergency?5Unit?3?$AA@
	jmp	SHORT $LN314@LogExpendi
$LN313@LogExpendi:
	mov	DWORD PTR tv1923[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN314@LogExpendi:
	mov	eax, DWORD PTR tv1923[ebp]
	push	eax
	mov	ecx, DWORD PTR $T219858[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR $T219858[ebp]
	mov	DWORD PTR tv1217[ebp], ecx
	lea	edx, DWORD PTR _strLog$[ebp]
	push	edx
	lea	eax, DWORD PTR _strHeader$[ebp]
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z ; TreasuryHelpers::AppendToLog
	add	esp, 64					; 00000040H

; 1018 : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Emergency Unit Cost:", 0);

	push	0
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T219392[ebp], esp
	mov	DWORD PTR $T219867[ebp], ecx
	mov	edx, OFFSET ??_C@_0BF@OBMNJCAM@Emergency?5Unit?5Cost?3?$AA@
	test	edx, edx
	je	SHORT $LN318@LogExpendi
	mov	DWORD PTR tv1936[ebp], OFFSET ??_C@_0BF@OBMNJCAM@Emergency?5Unit?5Cost?3?$AA@
	jmp	SHORT $LN319@LogExpendi
$LN318@LogExpendi:
	mov	DWORD PTR tv1936[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN319@LogExpendi:
	mov	eax, DWORD PTR tv1936[ebp]
	push	eax
	mov	ecx, DWORD PTR $T219867[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR $T219867[ebp]
	mov	DWORD PTR tv1220[ebp], ecx
	lea	edx, DWORD PTR _strLog$[ebp]
	push	edx
	lea	eax, DWORD PTR _strHeader$[ebp]
	push	eax
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z ; TreasuryHelpers::AppendToLog
	add	esp, 40					; 00000028H
$LN6@LogExpendi:

; 1019 : 	}
; 1020 : 	
; 1021 : 	// Emergency City Expenditure Unit and Amount
; 1022 : 	if (iColumn == 8){

	cmp	DWORD PTR _iColumn$[ebp], 8
	jne	$LN5@LogExpendi

; 1023 : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Emergency Building:", strExpenditure);

	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T219393[ebp], esp
	mov	DWORD PTR $T219872[ebp], ecx
	lea	edx, DWORD PTR _strExpenditure$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T219872[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T219872[ebp]
	mov	DWORD PTR tv1222[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 21		; 00000015H
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T219394[ebp], esp
	mov	DWORD PTR $T219881[ebp], ecx
	mov	edx, OFFSET ??_C@_0BE@GIABCIPA@Emergency?5Building?3?$AA@
	test	edx, edx
	je	SHORT $LN326@LogExpendi
	mov	DWORD PTR tv1964[ebp], OFFSET ??_C@_0BE@GIABCIPA@Emergency?5Building?3?$AA@
	jmp	SHORT $LN327@LogExpendi
$LN326@LogExpendi:
	mov	DWORD PTR tv1964[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN327@LogExpendi:
	mov	eax, DWORD PTR tv1964[ebp]
	push	eax
	mov	ecx, DWORD PTR $T219881[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR $T219881[ebp]
	mov	DWORD PTR tv1225[ebp], ecx
	lea	edx, DWORD PTR _strLog$[ebp]
	push	edx
	lea	eax, DWORD PTR _strHeader$[ebp]
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z ; TreasuryHelpers::AppendToLog
	add	esp, 64					; 00000040H

; 1024 : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Emergency Building Cost:", iAmount);

	mov	ecx, DWORD PTR _iAmount$[ebp]
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T219395[ebp], esp
	mov	DWORD PTR $T219890[ebp], edx
	mov	eax, OFFSET ??_C@_0BJ@NPIPBGEN@Emergency?5Building?5Cost?3?$AA@
	test	eax, eax
	je	SHORT $LN331@LogExpendi
	mov	DWORD PTR tv1977[ebp], OFFSET ??_C@_0BJ@NPIPBGEN@Emergency?5Building?5Cost?3?$AA@
	jmp	SHORT $LN332@LogExpendi
$LN331@LogExpendi:
	mov	DWORD PTR tv1977[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN332@LogExpendi:
	mov	ecx, DWORD PTR tv1977[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T219890[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T219890[ebp]
	mov	DWORD PTR tv1228[ebp], edx
	lea	eax, DWORD PTR _strLog$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[ebp]
	push	ecx
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z ; TreasuryHelpers::AppendToLog
	add	esp, 40					; 00000028H

; 1025 : 	}
; 1026 : 	else{

	jmp	$LN4@LogExpendi
$LN5@LogExpendi:

; 1027 : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Emergency Building:", "");

	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T219396[ebp], esp
	mov	DWORD PTR $T219899[ebp], edx
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
	test	eax, eax
	je	SHORT $LN336@LogExpendi
	mov	DWORD PTR tv1990[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
	jmp	SHORT $LN337@LogExpendi
$LN336@LogExpendi:
	mov	DWORD PTR tv1990[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN337@LogExpendi:
	mov	ecx, DWORD PTR tv1990[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T219899[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T219899[ebp]
	mov	DWORD PTR tv1230[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 22		; 00000016H
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T219397[ebp], esp
	mov	DWORD PTR $T219908[ebp], eax
	mov	ecx, OFFSET ??_C@_0BE@GIABCIPA@Emergency?5Building?3?$AA@
	test	ecx, ecx
	je	SHORT $LN341@LogExpendi
	mov	DWORD PTR tv2003[ebp], OFFSET ??_C@_0BE@GIABCIPA@Emergency?5Building?3?$AA@
	jmp	SHORT $LN342@LogExpendi
$LN341@LogExpendi:
	mov	DWORD PTR tv2003[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN342@LogExpendi:
	mov	edx, DWORD PTR tv2003[ebp]
	push	edx
	mov	ecx, DWORD PTR $T219908[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR $T219908[ebp]
	mov	DWORD PTR tv1233[ebp], eax
	lea	ecx, DWORD PTR _strLog$[ebp]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[ebp]
	push	edx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z ; TreasuryHelpers::AppendToLog
	add	esp, 64					; 00000040H

; 1028 : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Emergency Building Cost:", 0);

	push	0
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T219398[ebp], esp
	mov	DWORD PTR $T219917[ebp], eax
	mov	ecx, OFFSET ??_C@_0BJ@NPIPBGEN@Emergency?5Building?5Cost?3?$AA@
	test	ecx, ecx
	je	SHORT $LN346@LogExpendi
	mov	DWORD PTR tv2016[ebp], OFFSET ??_C@_0BJ@NPIPBGEN@Emergency?5Building?5Cost?3?$AA@
	jmp	SHORT $LN347@LogExpendi
$LN346@LogExpendi:
	mov	DWORD PTR tv2016[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN347@LogExpendi:
	mov	edx, DWORD PTR tv2016[ebp]
	push	edx
	mov	ecx, DWORD PTR $T219917[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR $T219917[ebp]
	mov	DWORD PTR tv1236[ebp], eax
	lea	ecx, DWORD PTR _strLog$[ebp]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[ebp]
	push	edx
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z ; TreasuryHelpers::AppendToLog
	add	esp, 40					; 00000028H
$LN4@LogExpendi:

; 1029 : 	}
; 1030 : 
; 1031 : 	// Research Agreement and Amount
; 1032 : 	if (iColumn == 9){

	cmp	DWORD PTR _iColumn$[ebp], 9
	jne	$LN3@LogExpendi

; 1033 : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Research Agreement with:", strExpenditure);

	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T219399[ebp], esp
	mov	DWORD PTR $T219922[ebp], eax
	lea	ecx, DWORD PTR _strExpenditure$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T219922[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	edx, DWORD PTR $T219922[ebp]
	mov	DWORD PTR tv1238[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 23		; 00000017H
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T219400[ebp], esp
	mov	DWORD PTR $T219931[ebp], eax
	mov	ecx, OFFSET ??_C@_0BJ@OIABGNKL@Research?5Agreement?5with?3?$AA@
	test	ecx, ecx
	je	SHORT $LN354@LogExpendi
	mov	DWORD PTR tv2044[ebp], OFFSET ??_C@_0BJ@OIABGNKL@Research?5Agreement?5with?3?$AA@
	jmp	SHORT $LN355@LogExpendi
$LN354@LogExpendi:
	mov	DWORD PTR tv2044[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN355@LogExpendi:
	mov	edx, DWORD PTR tv2044[ebp]
	push	edx
	mov	ecx, DWORD PTR $T219931[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR $T219931[ebp]
	mov	DWORD PTR tv1241[ebp], eax
	lea	ecx, DWORD PTR _strLog$[ebp]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[ebp]
	push	edx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z ; TreasuryHelpers::AppendToLog
	add	esp, 64					; 00000040H

; 1034 : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Research Agreement Cost:", iAmount);

	mov	eax, DWORD PTR _iAmount$[ebp]
	push	eax
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T219401[ebp], esp
	mov	DWORD PTR $T219940[ebp], ecx
	mov	edx, OFFSET ??_C@_0BJ@HAEBLPBN@Research?5Agreement?5Cost?3?$AA@
	test	edx, edx
	je	SHORT $LN359@LogExpendi
	mov	DWORD PTR tv2057[ebp], OFFSET ??_C@_0BJ@HAEBLPBN@Research?5Agreement?5Cost?3?$AA@
	jmp	SHORT $LN360@LogExpendi
$LN359@LogExpendi:
	mov	DWORD PTR tv2057[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN360@LogExpendi:
	mov	eax, DWORD PTR tv2057[ebp]
	push	eax
	mov	ecx, DWORD PTR $T219940[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR $T219940[ebp]
	mov	DWORD PTR tv1244[ebp], ecx
	lea	edx, DWORD PTR _strLog$[ebp]
	push	edx
	lea	eax, DWORD PTR _strHeader$[ebp]
	push	eax
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z ; TreasuryHelpers::AppendToLog
	add	esp, 40					; 00000028H

; 1035 : 	}
; 1036 : 	else{

	jmp	$LN2@LogExpendi
$LN3@LogExpendi:

; 1037 : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Research Agreement with:", "");

	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T219402[ebp], esp
	mov	DWORD PTR $T219949[ebp], ecx
	mov	edx, OFFSET ??_C@_00CNPNBAHC@?$AA@
	test	edx, edx
	je	SHORT $LN364@LogExpendi
	mov	DWORD PTR tv2070[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
	jmp	SHORT $LN365@LogExpendi
$LN364@LogExpendi:
	mov	DWORD PTR tv2070[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN365@LogExpendi:
	mov	eax, DWORD PTR tv2070[ebp]
	push	eax
	mov	ecx, DWORD PTR $T219949[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR $T219949[ebp]
	mov	DWORD PTR tv1246[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 24		; 00000018H
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T219403[ebp], esp
	mov	DWORD PTR $T219958[ebp], edx
	mov	eax, OFFSET ??_C@_0BJ@OIABGNKL@Research?5Agreement?5with?3?$AA@
	test	eax, eax
	je	SHORT $LN369@LogExpendi
	mov	DWORD PTR tv2083[ebp], OFFSET ??_C@_0BJ@OIABGNKL@Research?5Agreement?5with?3?$AA@
	jmp	SHORT $LN370@LogExpendi
$LN369@LogExpendi:
	mov	DWORD PTR tv2083[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN370@LogExpendi:
	mov	ecx, DWORD PTR tv2083[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T219958[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T219958[ebp]
	mov	DWORD PTR tv1249[ebp], edx
	lea	eax, DWORD PTR _strLog$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[ebp]
	push	ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z ; TreasuryHelpers::AppendToLog
	add	esp, 64					; 00000040H

; 1038 : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Research Agreement Cost:", 0);

	push	0
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T219404[ebp], esp
	mov	DWORD PTR $T219967[ebp], edx
	mov	eax, OFFSET ??_C@_0BJ@HAEBLPBN@Research?5Agreement?5Cost?3?$AA@
	test	eax, eax
	je	SHORT $LN374@LogExpendi
	mov	DWORD PTR tv2096[ebp], OFFSET ??_C@_0BJ@HAEBLPBN@Research?5Agreement?5Cost?3?$AA@
	jmp	SHORT $LN375@LogExpendi
$LN374@LogExpendi:
	mov	DWORD PTR tv2096[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN375@LogExpendi:
	mov	ecx, DWORD PTR tv2096[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T219967[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T219967[ebp]
	mov	DWORD PTR tv1252[ebp], edx
	lea	eax, DWORD PTR _strLog$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[ebp]
	push	ecx
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z ; TreasuryHelpers::AppendToLog
	add	esp, 40					; 00000028H
$LN2@LogExpendi:

; 1039 : 	}
; 1040 : 
; 1041 : 	if(bBuildHeader)

	movzx	edx, BYTE PTR _bBuildHeader$[ebp]
	test	edx, edx
	je	SHORT $LN1@LogExpendi

; 1042 : 	{
; 1043 : 		pLog->Msg(strHeader);

	lea	ecx, DWORD PTR _strHeader$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T219971[ebp], eax
	mov	eax, DWORD PTR $T219971[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLog$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pLog$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx]
	call	ecx
	add	esp, 8
$LN1@LogExpendi:

; 1044 : 	}
; 1045 : 	pLog->Msg(strLog);

	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T219975[ebp], eax
	mov	edx, DWORD PTR $T219975[ebp]
	push	edx
	mov	eax, DWORD PTR _pLog$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pLog$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	eax
	add	esp, 8

; 1046 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _strPlayerName$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strHeader$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strExpenditure$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN26@LogExpendi:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$0:
	lea	ecx, DWORD PTR _strExpenditure$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$1:
	lea	ecx, DWORD PTR _strHeader$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$2:
	lea	ecx, DWORD PTR _strLog$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$3:
	lea	ecx, DWORD PTR _strPlayerName$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$4:
	lea	ecx, DWORD PTR _strLogName$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$5:
	lea	ecx, DWORD PTR $T219349[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$6:
	lea	ecx, DWORD PTR $T219350[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$7:
	lea	ecx, DWORD PTR _str$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$8:
	mov	ecx, DWORD PTR $T219351[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$14:
	mov	ecx, DWORD PTR $T219357[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$17:
	mov	ecx, DWORD PTR $T219360[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$20:
	mov	ecx, DWORD PTR $T219363[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$23:
	mov	ecx, DWORD PTR $T219366[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$26:
	mov	ecx, DWORD PTR $T219369[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$29:
	mov	ecx, DWORD PTR $T219372[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$32:
	mov	ecx, DWORD PTR $T219375[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$35:
	mov	ecx, DWORD PTR $T219378[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$38:
	mov	ecx, DWORD PTR $T219381[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$41:
	mov	ecx, DWORD PTR $T219384[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$44:
	mov	ecx, DWORD PTR $T219387[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$47:
	mov	ecx, DWORD PTR $T219390[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$50:
	mov	ecx, DWORD PTR $T219393[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$53:
	mov	ecx, DWORD PTR $T219396[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$56:
	mov	ecx, DWORD PTR $T219399[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$59:
	mov	ecx, DWORD PTR $T219402[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1084]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z ENDP	; CvTreasury::LogExpenditure
PUBLIC	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ; operator>><int>
PUBLIC	?Read@CvTreasury@@QAEXAAVFDataStream@@@Z	; CvTreasury::Read
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Odtp
;	COMDAT ?Read@CvTreasury@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Read@CvTreasury@@QAEXAAVFDataStream@@@Z PROC		; CvTreasury::Read, COMDAT
; _this$ = ecx

; 1050 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1051 : 	// Version number to maintain backwards compatibility
; 1052 : 	uint uiVersion;
; 1053 : 
; 1054 : 	kStream >> uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 1055 : 
; 1056 : 	kStream >> m_iGold;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1057 : 	kStream >> m_iGoldPerTurnFromDiplomacy;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1058 : 	kStream >> m_iExpensePerTurnUnitMaintenance;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1059 : 	kStream >> m_iExpensePerTurnUnitSupply;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1060 : 	kStream >> m_iCityConnectionGoldTimes100;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 24					; 00000018H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1061 : 	kStream >> m_iCityConnectionTradeRouteGoldModifier;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 28					; 0000001cH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1062 : 	kStream >> m_iCityConnectionTradeRouteGoldChange;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1063 : 	kStream >> m_iBaseBuildingGoldMaintenance;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 36					; 00000024H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1064 : 	kStream >> m_iBaseImprovementGoldMaintenance;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1065 : 	kStream >> m_GoldBalanceForTurnTimes100;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ; operator>><int>
	add	esp, 8

; 1066 : 	kStream >> m_GoldChangeForTurnTimes100;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 64					; 00000040H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ; operator>><int>
	add	esp, 8

; 1067 : 	kStream >> m_iLifetimeGrossGoldIncome;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 44					; 0000002cH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1068 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Read@CvTreasury@@QAEXAAVFDataStream@@@Z ENDP		; CvTreasury::Read
_TEXT	ENDS
PUBLIC	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$vector@HV?$allocator@H@std@@@std@@@Z ; operator<<<int>
PUBLIC	?Write@CvTreasury@@QAEXAAVFDataStream@@@Z	; CvTreasury::Write
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Odtp
;	COMDAT ?Write@CvTreasury@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Write@CvTreasury@@QAEXAAVFDataStream@@@Z PROC		; CvTreasury::Write, COMDAT
; _this$ = ecx

; 1072 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1073 : 	// Current version number
; 1074 : 	uint uiVersion = 1;

	mov	DWORD PTR _uiVersion$[ebp], 1

; 1075 : 	kStream << uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 1076 : 
; 1077 : 	kStream << m_iGold;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1078 : 	kStream << m_iGoldPerTurnFromDiplomacy;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1079 : 	kStream << m_iExpensePerTurnUnitMaintenance;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1080 : 	kStream << m_iExpensePerTurnUnitSupply;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1081 : 	kStream << m_iCityConnectionGoldTimes100;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 24					; 00000018H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1082 : 	kStream << m_iCityConnectionTradeRouteGoldModifier;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 28					; 0000001cH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1083 : 	kStream << m_iCityConnectionTradeRouteGoldChange;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1084 : 	kStream << m_iBaseBuildingGoldMaintenance;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 36					; 00000024H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1085 : 	kStream << m_iBaseImprovementGoldMaintenance;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1086 : 	kStream << m_GoldBalanceForTurnTimes100;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$vector@HV?$allocator@H@std@@@std@@@Z ; operator<<<int>
	add	esp, 8

; 1087 : 	kStream << m_GoldChangeForTurnTimes100;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 64					; 00000040H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$vector@HV?$allocator@H@std@@@std@@@Z ; operator<<<int>
	add	esp, 8

; 1088 : 	kStream << m_iLifetimeGrossGoldIncome;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 44					; 0000002cH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1089 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Write@CvTreasury@@QAEXAAVFDataStream@@@Z ENDP		; CvTreasury::Write
_TEXT	ENDS
PUBLIC	??_C@_01IHBHIGKO@?0?$AA@			; `string'
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
;	COMDAT ??_C@_01IHBHIGKO@?0?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_01IHBHIGKO@?0?$AA@ DB ',', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z$1
__ehfuncinfo$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtreasury.cpp
xdata$x	ENDS
;	COMDAT ?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_strHeader$ = 8						; size = 4
_strLog$ = 12						; size = 4
_strHeaderValue$ = 16					; size = 28
_strValue$ = 44						; size = 28
?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z PROC ; TreasuryHelpers::AppendToLog, COMDAT

; 1092 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1093 : 	strHeader += strHeaderValue;

	lea	eax, DWORD PTR _strHeaderValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _strHeader$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 1094 : 	strHeader += ",";

	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	mov	ecx, DWORD PTR _strHeader$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1095 : 	strLog += strValue;

	lea	ecx, DWORD PTR _strValue$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 1096 : 	strLog += ",";

	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	mov	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1097 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strHeaderValue$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strValue$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z$0:
	lea	ecx, DWORD PTR _strValue$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z$1:
	lea	ecx, DWORD PTR _strHeaderValue$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z ENDP ; TreasuryHelpers::AppendToLog
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
PUBLIC	??_C@_03DPLIHHLN@?$CFd?0?$AA@			; `string'
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_03DPLIHHLN@?$CFd?0?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_03DPLIHHLN@?$CFd?0?$AA@ DB '%d,', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z$1
__ehfuncinfo$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtreasury.cpp
xdata$x	ENDS
;	COMDAT ?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z
_TEXT	SEGMENT
_str$ = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_strHeader$ = 8						; size = 4
_strLog$ = 12						; size = 4
_strHeaderValue$ = 16					; size = 28
_iValue$ = 44						; size = 4
?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z PROC ; TreasuryHelpers::AppendToLog, COMDAT

; 1100 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1101 : 	strHeader += strHeaderValue;

	lea	eax, DWORD PTR _strHeaderValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _strHeader$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 1102 : 	strHeader += ",";

	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	mov	ecx, DWORD PTR _strHeader$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1103 : 	CvString str;

	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1104 : 	str.Format("%d,", iValue);

	mov	ecx, DWORD PTR _iValue$[ebp]
	push	ecx
	push	OFFSET ??_C@_03DPLIHHLN@?$CFd?0?$AA@
	lea	edx, DWORD PTR _str$[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 1105 : 	strLog += str;

	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	mov	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 1106 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strHeaderValue$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z$0:
	lea	ecx, DWORD PTR _strHeaderValue$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z$1:
	lea	ecx, DWORD PTR _str$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z ENDP ; TreasuryHelpers::AppendToLog
PUBLIC	??_C@_05EIOELHKK@?$CF?42f?0?$AA@		; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@M@Z ; TreasuryHelpers::AppendToLog
;	COMDAT ??_C@_05EIOELHKK@?$CF?42f?0?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_05EIOELHKK@?$CF?42f?0?$AA@ DB '%.2f,', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@M@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@M@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@M@Z$1
__ehfuncinfo$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@M@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@M@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtreasury.cpp
xdata$x	ENDS
;	COMDAT ?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@M@Z
_TEXT	SEGMENT
_str$ = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_strHeader$ = 8						; size = 4
_strLog$ = 12						; size = 4
_strHeaderValue$ = 16					; size = 28
_fValue$ = 44						; size = 4
?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@M@Z PROC ; TreasuryHelpers::AppendToLog, COMDAT

; 1109 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@M@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1110 : 	strHeader += strHeaderValue;

	lea	eax, DWORD PTR _strHeaderValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _strHeader$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 1111 : 	strHeader += ",";

	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	mov	ecx, DWORD PTR _strHeader$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1112 : 	CvString str;

	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1113 : 	str.Format("%.2f,", fValue);

	cvtss2sd xmm0, DWORD PTR _fValue$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_05EIOELHKK@?$CF?42f?0?$AA@
	lea	ecx, DWORD PTR _str$[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 1114 : 	strLog += str;

	lea	edx, DWORD PTR _str$[ebp]
	push	edx
	mov	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 1115 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strHeaderValue$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@M@Z$0:
	lea	ecx, DWORD PTR _strHeaderValue$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@M@Z$1:
	lea	ecx, DWORD PTR _str$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@M@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@M@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@M@Z ENDP ; TreasuryHelpers::AppendToLog
PUBLIC	??$_Uninit_copy@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<int,std::allocator<int> >,int *,std::allocator<int> >
PUBLIC	??$_Allocate@H@std@@YAPAHIPAH@Z			; std::_Allocate<int>
PUBLIC	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z$4
__ehfuncinfo$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
tv170 = -200						; size = 4
tv168 = -196						; size = 4
_this$ = -192						; size = 4
$T220332 = -188						; size = 4
$T220331 = -184						; size = 4
$T220327 = -180						; size = 4
$T220326 = -176						; size = 4
$T220315 = -172						; size = 4
$T220314 = -168						; size = 4
__Cat$220321 = -162					; size = 1
$T220319 = -161						; size = 1
$T220289 = -160						; size = 4
$T220288 = -156						; size = 4
$T220269 = -152						; size = 4
$T220252 = -145						; size = 1
$T220251 = -144						; size = 4
$T220241 = -140						; size = 4
$T220240 = -136						; size = 4
__Cat$220283 = -130					; size = 1
$T220280 = -129						; size = 1
$T220279 = -128						; size = 1
__Cat$220276 = -127					; size = 1
$T220273 = -126						; size = 1
$T220272 = -125						; size = 1
$T220210 = -124						; size = 4
$T220194 = -120						; size = 4
__Count$220161 = -36					; size = 4
$T220144 = -32						; size = 4
$T220143 = -28						; size = 4
__Size$217602 = -24					; size = 4
__Ptr$217593 = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z PROC ; std::vector<int,std::allocator<int> >::reserve, COMDAT
; _this$ = ecx

; 602  : 		{	// determine new minimum length of allocated storage

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 184				; 000000b8H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 603  : 		if (max_size() < _Count)

	mov	DWORD PTR __Count$220161[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$220161[ebp], 0
	jbe	SHORT $LN16@reserve
	mov	eax, DWORD PTR __Count$220161[ebp]
	mov	DWORD PTR tv168[ebp], eax
	jmp	SHORT $LN12@reserve
$LN16@reserve:
	mov	DWORD PTR tv168[ebp], 1
$LN12@reserve:
	mov	ecx, DWORD PTR tv168[ebp]
	cmp	ecx, DWORD PTR __Count$[ebp]
	jae	SHORT $LN5@reserve

; 604  : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
	jmp	$LN7@reserve
$LN5@reserve:

; 605  : 		else if (capacity() < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN26@reserve
	mov	DWORD PTR tv170[ebp], 0
	jmp	SHORT $LN24@reserve
$LN26@reserve:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR tv170[ebp], edx
$LN24@reserve:
	mov	eax, DWORD PTR tv170[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN7@reserve

; 606  : 			{	// not enough room, reallocate
; 607  : 			pointer _Ptr = this->_Alval.allocate(_Count);

	push	0
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	add	esp, 8
	mov	DWORD PTR __Ptr$217593[ebp], eax

; 608  : 
; 609  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 610  : 			_Umove(begin(), end(), _Ptr);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T220194[ebp], eax
	mov	ecx, DWORD PTR $T220194[ebp]
	mov	DWORD PTR $T220143[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T220210[ebp], eax
	mov	ecx, DWORD PTR $T220210[ebp]
	mov	DWORD PTR $T220144[ebp], ecx
	mov	edx, DWORD PTR $T220143[ebp]
	mov	DWORD PTR $T220289[ebp], edx
	mov	eax, DWORD PTR $T220144[ebp]
	mov	DWORD PTR $T220288[ebp], eax
	mov	ecx, DWORD PTR __Ptr$217593[ebp]
	mov	DWORD PTR $T220269[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T220272[ebp], dl
	mov	al, BYTE PTR __Cat$220276[ebp]
	mov	BYTE PTR $T220273[ebp], al
	mov	cl, BYTE PTR $T220272[ebp]
	mov	BYTE PTR $T220252[ebp], cl
	mov	edx, DWORD PTR $T220269[ebp]
	mov	DWORD PTR $T220251[ebp], edx
	mov	eax, DWORD PTR $T220251[ebp]
	mov	DWORD PTR $T220241[ebp], eax
	mov	ecx, DWORD PTR $T220288[ebp]
	mov	DWORD PTR $T220240[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T220279[ebp], dl
	mov	al, BYTE PTR __Cat$220283[ebp]
	mov	BYTE PTR $T220280[ebp], al
	movzx	ecx, BYTE PTR $T220279[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T220280[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T220241[ebp]
	push	ecx
	mov	edx, DWORD PTR $T220289[ebp]
	push	edx
	mov	eax, DWORD PTR $T220240[ebp]
	push	eax
	call	??$_Uninit_copy@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<int,std::allocator<int> >,int *,std::allocator<int> >
	add	esp, 24					; 00000018H
	jmp	SHORT $LN8@reserve
__catch$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z$0:

; 611  : 			_CATCH_ALL
; 612  : 			this->_Alval.deallocate(_Ptr, _Count);

	mov	ecx, DWORD PTR __Ptr$217593[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 613  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 614  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN61@reserve
	ret	0
$LN8@reserve:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 615  : 
; 616  : 			size_type _Size = size();

$LN61@reserve:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR __Size$217602[ebp], ecx

; 617  : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $LN1@reserve

; 618  : 				{	// destroy and deallocate old array
; 619  : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T220327[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T220326[ebp], eax
	mov	ecx, DWORD PTR $T220327[ebp]
	mov	DWORD PTR $T220315[ebp], ecx
	mov	edx, DWORD PTR $T220326[ebp]
	mov	DWORD PTR $T220314[ebp], edx
	mov	al, BYTE PTR __Cat$220321[ebp]
	mov	BYTE PTR $T220319[ebp], al

; 620  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR $T220332[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T220331[ebp], edx
	mov	eax, DWORD PTR $T220331[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@reserve:

; 621  : 				}
; 622  : 
; 623  :  #if _HAS_ITERATOR_DEBUGGING
; 624  : 			this->_Orphan_all();
; 625  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 626  : 
; 627  : 			_Myend = _Ptr + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Ptr$217593[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 628  : 			_Mylast = _Ptr + _Size;

	mov	edx, DWORD PTR __Size$217602[ebp]
	mov	eax, DWORD PTR __Ptr$217593[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 629  : 			_Myfirst = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$217593[ebp]
	mov	DWORD PTR [eax+4], ecx
$LN7@reserve:

; 630  : 			}
; 631  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-204]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z ENDP ; std::vector<int,std::allocator<int> >::reserve
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv143 = -36						; size = 4
$T220398 = -32						; size = 4
$T220390 = -28						; size = 4
__Vptr$220396 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_iterator<int,std::allocator<int> >,int *,std::allocator<int> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN18@Uninit_cop
$LN5@Uninit_cop:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 4
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 4
	mov	DWORD PTR __First$[ebp], edx
$LN18@Uninit_cop:
	mov	eax, DWORD PTR __First$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN4@Uninit_cop

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T220398[ebp], ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$220396[ebp], edx
	mov	eax, DWORD PTR __Vptr$220396[ebp]
	mov	DWORD PTR $T220390[ebp], eax
	cmp	DWORD PTR $T220390[ebp], 0
	je	SHORT $LN30@Uninit_cop
	mov	ecx, DWORD PTR $T220390[ebp]
	mov	edx, DWORD PTR $T220398[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T220390[ebp]
	mov	DWORD PTR tv143[ebp], ecx
	jmp	SHORT $LN26@Uninit_cop
$LN30@Uninit_cop:
	mov	DWORD PTR tv143[ebp], 0
$LN26@Uninit_cop:
	jmp	SHORT $LN5@Uninit_cop
$LN4@Uninit_cop:
	jmp	SHORT $LN10@Uninit_cop
__catch$??$_Uninit_copy@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop
$LN2@Uninit_cop:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 4
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_cop:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop

; 134  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_cop
$LN1@Uninit_cop:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_iterator<int,std::allocator<int> >,int *,std::allocator<int> >
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -48						; size = 28
__$ArrayPad$ = -20					; size = 4
_args$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 2124				; 0000084cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);

	lea	eax, DWORD PTR _lpszFormat$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _args$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpszFormat$[ebp]
	push	edx
	lea	eax, DWORD PTR _result$[ebp]
	push	eax
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);

	mov	DWORD PTR _args$[ebp], 0

; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-2128]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	__$ArrayPad$
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__imp___vsnprintf:PROC
; Function compile flags: /Odtp
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
tv74 = -2096						; size = 4
$T220446 = -2092					; size = 4
$T220445 = -2088					; size = 4
$T220444 = -2084					; size = 4
_maxlen$95294 = -2080					; size = 4
_kMaxAttempts$ = -2076					; size = 4
_buf$ = -2072						; size = 2048
__$ArrayPad$ = -20					; size = 4
_len$ = -16						; size = 4
_attempts$ = -12					; size = 4
_success$ = -5						; size = 1
_pbuf$ = -4						; size = 4
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2096				; 00000830H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	lea	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _pbuf$[ebp], eax

; 194  : 	int len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 195  : 	int attempts = 0;

	mov	DWORD PTR _attempts$[ebp], 0

; 196  : 	bool success = false;

	mov	BYTE PTR _success$[ebp], 0

; 197  : 	const int kMaxAttempts = 40;

	mov	DWORD PTR _kMaxAttempts$[ebp], 40	; 00000028H
$LN10@formatv:

; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;

	mov	ecx, DWORD PTR _attempts$[ebp]
	shl	ecx, 11					; 0000000bH
	add	ecx, 2047				; 000007ffH
	mov	DWORD PTR _maxlen$95294[ebp], ecx

; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	edx, DWORD PTR _args$[ebp]
	push	edx
	mov	eax, DWORD PTR _fmt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _maxlen$95294[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbuf$[ebp]
	push	edx
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR _len$[ebp], eax

; 203  : 		attempts++;

	mov	eax, DWORD PTR _attempts$[ebp]
	add	eax, 1
	mov	DWORD PTR _attempts$[ebp], eax

; 204  : 		success = (len>=0 && len<=maxlen);

	cmp	DWORD PTR _len$[ebp], 0
	jl	SHORT $LN13@formatv
	mov	ecx, DWORD PTR _len$[ebp]
	cmp	ecx, DWORD PTR _maxlen$95294[ebp]
	jg	SHORT $LN13@formatv
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN14@formatv
$LN13@formatv:
	mov	DWORD PTR tv74[ebp], 0
$LN14@formatv:
	mov	dl, BYTE PTR tv74[ebp]
	mov	BYTE PTR _success$[ebp], dl

; 205  : 		if (!success)

	movzx	eax, BYTE PTR _success$[ebp]
	test	eax, eax
	jne	SHORT $LN9@formatv

; 206  : 		{
; 207  : 			if (pbuf!=buf)

	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, edx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T220444[ebp], eax
	mov	ecx, DWORD PTR $T220444[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	mov	edx, DWORD PTR _attempts$[ebp]
	shl	edx, 11					; 0000000bH
	add	edx, 2048				; 00000800H
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T220445[ebp], eax
	mov	eax, DWORD PTR $T220445[ebp]
	mov	DWORD PTR _pbuf$[ebp], eax
$LN9@formatv:

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	movzx	ecx, BYTE PTR _success$[ebp]
	test	ecx, ecx
	jne	SHORT $LN4@formatv
	cmp	DWORD PTR _attempts$[ebp], 40		; 00000028H
	jl	$LN10@formatv
$LN4@formatv:

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)

	movzx	edx, BYTE PTR _success$[ebp]
	test	edx, edx
	je	SHORT $LN3@formatv

; 220  : 		out = pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 221  : 	else

	jmp	SHORT $LN2@formatv
$LN3@formatv:

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN2@formatv:

; 223  : 
; 224  : 	if (pbuf!=buf)

	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, edx
	je	SHORT $LN1@formatv

; 225  : 		delete [] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T220446[ebp], eax
	mov	ecx, DWORD PTR $T220446[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN1@formatv:

; 226  : 
; 227  : 	return success;

	mov	al, BYTE PTR _success$[ebp]

; 228  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
; Function compile flags: /Odtp
;	COMDAT ??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$220526 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z PROC	; std::vector<int,std::allocator<int> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy
	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$220526[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$220526[ebp], 0
	jbe	SHORT $LN11@Buy
	mov	eax, DWORD PTR __Count$220526[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy
$LN11@Buy:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ENDP	; std::vector<int,std::allocator<int> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T220589 = -28						; size = 4
$T220588 = -24						; size = 4
$T220584 = -20						; size = 4
$T220583 = -16						; size = 4
$T220572 = -12						; size = 4
$T220571 = -8						; size = 4
__Cat$220578 = -2					; size = 1
$T220576 = -1						; size = 1
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T220584[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T220583[ebp], ecx
	mov	edx, DWORD PTR $T220584[ebp]
	mov	DWORD PTR $T220572[ebp], edx
	mov	eax, DWORD PTR $T220583[ebp]
	mov	DWORD PTR $T220571[ebp], eax
	mov	cl, BYTE PTR __Cat$220578[ebp]
	mov	BYTE PTR $T220576[ebp], cl

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR $T220589[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T220588[ebp], eax
	mov	ecx, DWORD PTR $T220588[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_Elength_error@std@@UAEPAXI@Z ; std::length_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_Elogic_error@std@@UAEPAXI@Z ; std::logic_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T220593 = -80						; size = 28
$T220592 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ PROC	; std::vector<int,std::allocator<int> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T220593[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T220592[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T220592[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T220593[ebp]
	push	eax
	lea	ecx, DWORD PTR $T220592[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T220592[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T220592[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T220593[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T220593[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T220592[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ENDP	; std::vector<int,std::allocator<int> >::_Xlen
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 34   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 36   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar@2
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@

; 110  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	edx, DWORD PTR ___flags$[ebp]
	and	edx, 1
	je	SHORT $LN1@scalar@3
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0length_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R0?AVbad_alloc@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
xdata$x	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_Ebad_alloc@std@@UAEPAXI@Z ; std::bad_alloc::`vftable'
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
CONST	ENDS
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT
$T220664 = -16						; size = 4
$T220660 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@H@std@@YAPAHIPAH@Z PROC			; std::_Allocate<int>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T220664[ebp], 0
	lea	eax, DWORD PTR $T220664[ebp]
	push	eax
	lea	ecx, DWORD PTR $T220660[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T220660[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T220660[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@H@std@@YAPAHIPAH@Z ENDP			; std::_Allocate<int>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar@4
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z	; stdext::unchecked_copy<int *,int *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T220767 = -52						; size = 4
$T220756 = -48						; size = 4
$T220755 = -44						; size = 4
__Cat$220762 = -40					; size = 1
$T220760 = -39						; size = 1
__Ptr$210227 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z PROC ; std::vector<int,std::allocator<int> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@erase

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::unchecked_copy<int *,int *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$210227[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T220767[ebp], edx
	mov	eax, DWORD PTR $T220767[ebp]
	mov	DWORD PTR $T220756[ebp], eax
	mov	ecx, DWORD PTR __Ptr$210227[ebp]
	mov	DWORD PTR $T220755[ebp], ecx
	mov	dl, BYTE PTR __Cat$220762[ebp]
	mov	BYTE PTR $T220760[ebp], dl

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$210227[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN1@erase:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ENDP ; std::vector<int,std::allocator<int> >::erase
_TEXT	ENDS
PUBLIC	??$SerializeToSequenceContainer@HV?$vector@HV?$allocator@H@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ; SerializeToSequenceContainer<int,std::vector<int,std::allocator<int> > >
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$?5H@@YAAAVFDataStream@@AAV0@AAV?$vector@HV?$allocator@H@std@@@std@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$vector@HV?$allocator@H@std@@@std@@@Z PROC ; operator>><int>, COMDAT

; 225  : {

	push	ebp
	mov	ebp, esp

; 226  : 	// The functor needs to be instantiated to properly resize the container based 
; 227  : 	// on how many elements the stream says it should have before passing it along
; 228  : 	// to std::for_each
; 229  : 	SerializeToSequenceContainer<ElementType, std::vector<ElementType> >(loadFrom, writeTo);

	mov	eax, DWORD PTR _writeTo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	push	ecx
	call	??$SerializeToSequenceContainer@HV?$vector@HV?$allocator@H@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ; SerializeToSequenceContainer<int,std::vector<int,std::allocator<int> > >
	add	esp, 8

; 230  : 
; 231  : 	//std::for_each(writeTo.begin(), writeTo.end(), func);
; 232  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 233  : }

	pop	ebp
	ret	0
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ENDP ; operator>><int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?6H@@YAAAVFDataStream@@AAV0@ABV?$vector@HV?$allocator@H@std@@@std@@@Z
_TEXT	SEGMENT
$T220856 = -72						; size = 8
$T220855 = -64						; size = 4
$T220854 = -60						; size = 4
$T220834 = -56						; size = 4
$T220829 = -52						; size = 4
__ChkFirst$220849 = -48					; size = 4
__ChkLast$220850 = -44					; size = 4
$T220805 = -40						; size = 4
$T220796 = -36						; size = 4
$T220784 = -32						; size = 4
$T220787 = -28						; size = 4
$T220775 = -24						; size = 8
$T220774 = -16						; size = 4
$T220773 = -12						; size = 4
$T220772 = -8						; size = 8
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??$?6H@@YAAAVFDataStream@@AAV0@ABV?$vector@HV?$allocator@H@std@@@std@@@Z PROC ; operator<<<int>, COMDAT

; 198  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H

; 199  : 	std::for_each(readFrom.begin(), readFrom.end(), SerializeFromSequenceContainer<const ElementType, const std::vector<ElementType> >(saveTo, readFrom));

	mov	eax, DWORD PTR _saveTo$[ebp]
	mov	DWORD PTR $T220772[ebp], eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	DWORD PTR $T220772[ebp+4], ecx
	mov	edx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR $T220787[ebp], ecx
	mov	edx, DWORD PTR $T220772[ebp]
	mov	DWORD PTR $T220784[ebp], edx
	lea	eax, DWORD PTR $T220787[ebp]
	push	eax
	mov	ecx, DWORD PTR $T220784[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T220796[ebp], edx
	mov	eax, DWORD PTR $T220796[ebp]
	mov	DWORD PTR $T220773[ebp], eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T220805[ebp], edx
	mov	eax, DWORD PTR $T220805[ebp]
	mov	DWORD PTR $T220774[ebp], eax
	mov	ecx, DWORD PTR $T220772[ebp]
	mov	DWORD PTR $T220856[ebp], ecx
	mov	edx, DWORD PTR $T220772[ebp+4]
	mov	DWORD PTR $T220856[ebp+4], edx
	mov	eax, DWORD PTR $T220773[ebp]
	mov	DWORD PTR $T220855[ebp], eax
	mov	ecx, DWORD PTR $T220774[ebp]
	mov	DWORD PTR $T220854[ebp], ecx
	mov	edx, DWORD PTR $T220854[ebp]
	mov	DWORD PTR __ChkFirst$220849[ebp], edx
	mov	eax, DWORD PTR $T220855[ebp]
	mov	DWORD PTR __ChkLast$220850[ebp], eax
	jmp	SHORT $LN24@operator
$LN18@operator:
	mov	ecx, DWORD PTR __ChkFirst$220849[ebp]
	add	ecx, 4
	mov	DWORD PTR __ChkFirst$220849[ebp], ecx
$LN24@operator:
	mov	edx, DWORD PTR __ChkFirst$220849[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __ChkLast$220850[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN17@operator
	mov	eax, DWORD PTR __ChkFirst$220849[ebp]
	mov	DWORD PTR $T220834[ebp], eax
	mov	ecx, DWORD PTR $T220856[ebp]
	mov	DWORD PTR $T220829[ebp], ecx
	mov	edx, DWORD PTR $T220834[ebp]
	push	edx
	mov	ecx, DWORD PTR $T220829[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	jmp	SHORT $LN18@operator
$LN17@operator:
	mov	eax, DWORD PTR $T220856[ebp]
	mov	DWORD PTR $T220775[ebp], eax
	mov	ecx, DWORD PTR $T220856[ebp+4]
	mov	DWORD PTR $T220775[ebp+4], ecx

; 200  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 201  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?6H@@YAAAVFDataStream@@AAV0@ABV?$vector@HV?$allocator@H@std@@@std@@@Z ENDP ; operator<<<int>
_TEXT	ENDS
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z
_TEXT	SEGMENT
$T220879 = -26						; size = 1
$T220878 = -25						; size = 1
$T220877 = -24						; size = 4
$T220876 = -20						; size = 4
__Off$220872 = -16					; size = 4
__Result$220873 = -12					; size = 4
__Cat$220864 = -4					; size = 1
$T220861 = -3						; size = 1
$T220860 = -2						; size = 1
$T220859 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z PROC	; stdext::unchecked_copy<int *,int *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T220859[ebp], al
	mov	cl, BYTE PTR __Cat$220864[ebp]
	mov	BYTE PTR $T220860[ebp], cl
	mov	dl, BYTE PTR $T220859[ebp]
	mov	BYTE PTR $T220879[ebp], dl
	mov	al, BYTE PTR $T220861[ebp]
	mov	BYTE PTR $T220878[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T220877[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T220876[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR $T220876[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$220872[ebp], eax
	mov	ecx, DWORD PTR __Off$220872[ebp]
	mov	edx, DWORD PTR $T220877[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$220873[ebp], eax
	cmp	DWORD PTR __Off$220872[ebp], 0
	jle	SHORT $LN8@unchecked_
	mov	ecx, DWORD PTR __Off$220872[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR $T220876[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$220872[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR $T220877[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_:
	mov	eax, DWORD PTR __Result$220873[ebp]

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z ENDP	; stdext::unchecked_copy<int *,int *>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
_TEXT	ENDS
;	COMDAT ??$SerializeToSequenceContainer@HV?$vector@HV?$allocator@H@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z
_TEXT	SEGMENT
$T220913 = -40						; size = 4
$T220897 = -36						; size = 4
$T221021 = -32						; size = 4
$T221020 = -28						; size = 4
$T221019 = -24						; size = 4
$T221018 = -20						; size = 4
$T221017 = -16						; size = 4
_v$213750 = -12						; size = 4
_i$ = -8						; size = 4
_count$ = -4						; size = 4
_loadFrom$ = 8						; size = 4
_container$ = 12					; size = 4
??$SerializeToSequenceContainer@HV?$vector@HV?$allocator@H@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z PROC ; SerializeToSequenceContainer<int,std::vector<int,std::allocator<int> > >, COMDAT

; 83   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 176				; 000000b0H

; 84   : 	container.clear();

	mov	eax, DWORD PTR _container$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T220897[ebp], ecx
	mov	edx, DWORD PTR $T220897[ebp]
	mov	DWORD PTR $T221018[ebp], edx
	mov	eax, DWORD PTR $T221018[ebp]
	mov	DWORD PTR $T221017[ebp], eax
	mov	ecx, DWORD PTR _container$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T220913[ebp], edx
	mov	eax, DWORD PTR $T220913[ebp]
	mov	DWORD PTR $T221020[ebp], eax
	mov	ecx, DWORD PTR $T221020[ebp]
	mov	DWORD PTR $T221019[ebp], ecx
	mov	edx, DWORD PTR $T221017[ebp]
	push	edx
	mov	eax, DWORD PTR $T221019[ebp]
	push	eax
	lea	ecx, DWORD PTR $T221021[ebp]
	push	ecx
	mov	ecx, DWORD PTR _container$[ebp]
	call	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase

; 85   : 	ContainerType::size_type count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 86   : 	loadFrom >> count;

	lea	edx, DWORD PTR _count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 87   : 	ContainerType::size_type i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 88   : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@SerializeT
$LN2@SerializeT:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@SerializeT:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _count$[ebp]
	jae	SHORT $LN4@SerializeT

; 89   : 	{
; 90   : 		ElementType v;
; 91   : 		loadFrom >> v;

	lea	edx, DWORD PTR _v$213750[ebp]
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 92   : 		container.push_back(v);

	lea	eax, DWORD PTR _v$213750[ebp]
	push	eax
	mov	ecx, DWORD PTR _container$[ebp]
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 93   : 	}

	jmp	SHORT $LN2@SerializeT
$LN4@SerializeT:

; 94   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$SerializeToSequenceContainer@HV?$vector@HV?$allocator@H@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ENDP ; SerializeToSequenceContainer<int,std::vector<int,std::allocator<int> > >
_TEXT	ENDS
PUBLIC	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ; std::vector<int,std::allocator<int> >::insert
PUBLIC	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z	; stdext::unchecked_fill_n<int *,unsigned int,int>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
tv129 = -96						; size = 4
_this$ = -92						; size = 4
$T221284 = -64						; size = 4
$T221274 = -60						; size = 4
$T221262 = -56						; size = 4
$T221252 = -49						; size = 1
$T221251 = -48						; size = 4
__Cat$221269 = -19					; size = 1
$T221266 = -18						; size = 1
$T221265 = -17						; size = 1
$T221203 = -16						; size = 4
$T221199 = -12						; size = 4
$T221198 = -8						; size = 4
$T221197 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::vector<int,std::allocator<int> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T221203[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN9@push_back
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN7@push_back
$LN9@push_back:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv129[ebp], eax
$LN7@push_back:
	mov	ecx, DWORD PTR $T221203[ebp]
	cmp	ecx, DWORD PTR tv129[ebp]
	jae	SHORT $LN2@push_back

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T221274[ebp], eax
	mov	ecx, DWORD PTR $T221274[ebp]
	mov	DWORD PTR $T221262[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T221265[ebp], dl
	mov	al, BYTE PTR __Cat$221269[ebp]
	mov	BYTE PTR $T221266[ebp], al
	mov	cl, BYTE PTR $T221265[ebp]
	mov	BYTE PTR $T221252[ebp], cl
	mov	edx, DWORD PTR $T221262[ebp]
	mov	DWORD PTR $T221251[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR $T221251[ebp]
	push	ecx
	call	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ; stdext::unchecked_fill_n<int *,unsigned int,int>
	add	esp, 12					; 0000000cH
	mov	edx, 1
	shl	edx, 2
	add	edx, DWORD PTR $T221274[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back
$LN2@push_back:

; 823  : 			insert(end(), _Val);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T221284[ebp], edx
	mov	eax, DWORD PTR $T221284[ebp]
	mov	DWORD PTR $T221198[ebp], eax
	mov	ecx, DWORD PTR $T221198[ebp]
	mov	DWORD PTR $T221197[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR $T221197[ebp]
	push	eax
	lea	ecx, DWORD PTR $T221199[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ; std::vector<int,std::allocator<int> >::insert
$LN3@push_back:

; 824  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::vector<int,std::allocator<int> >::push_back
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
__Tmp$221409 = -24					; size = 4
$T221387 = -20						; size = 4
$T221368 = -16						; size = 4
$T221355 = -12						; size = 4
$T221352 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z PROC ; std::vector<int,std::allocator<int> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	test	edx, edx
	jne	SHORT $LN3@insert
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert
$LN3@insert:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T221368[ebp], ecx
	mov	edx, DWORD PTR $T221368[ebp]
	mov	DWORD PTR $T221352[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	sub	eax, DWORD PTR $T221352[ebp]
	sar	eax, 2
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T221387[ebp], edx
	mov	eax, DWORD PTR $T221387[ebp]
	mov	DWORD PTR $T221355[ebp], eax
	mov	ecx, DWORD PTR $T221355[ebp]
	mov	DWORD PTR __Tmp$221409[ebp], ecx
	mov	edx, DWORD PTR __Off$[ebp]
	mov	eax, DWORD PTR __Tmp$221409[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR __Tmp$221409[ebp], ecx
	mov	edx, DWORD PTR __Tmp$221409[ebp]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ENDP ; std::vector<int,std::allocator<int> >::insert
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>
PUBLIC	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
PUBLIC	??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<int *,int *,std::allocator<int> >
PUBLIC	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$2
__catchsym$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$0
__unwindtable$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$5
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$6
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
_TEXT	SEGMENT
tv84 = -432						; size = 4
tv302 = -428						; size = 4
tv288 = -424						; size = 4
tv280 = -420						; size = 4
_this$ = -416						; size = 4
$T221963 = -412						; size = 4
$T221911 = -368						; size = 4
$T221899 = -364						; size = 4
$T221889 = -357						; size = 1
$T221888 = -356						; size = 4
__Cat$221907 = -327					; size = 1
$T221904 = -326						; size = 1
$T221903 = -325						; size = 1
$T221860 = -324						; size = 4
$T221852 = -320						; size = 4
$T221844 = -316						; size = 4
$T221833 = -312						; size = 4
$T221832 = -308						; size = 4
__Cat$221840 = -302					; size = 1
$T221838 = -301						; size = 1
$T221761 = -276						; size = 4
$T221742 = -272						; size = 4
$T221725 = -265						; size = 1
$T221724 = -264						; size = 4
$T221714 = -260						; size = 4
$T221713 = -256						; size = 4
__Cat$221758 = -250					; size = 1
$T221756 = -249						; size = 1
$T221755 = -248						; size = 1
__Cat$221750 = -247					; size = 1
$T221747 = -246						; size = 1
$T221746 = -245						; size = 1
$T221689 = -244						; size = 4
$T221688 = -240						; size = 4
$T221684 = -236						; size = 4
$T221683 = -232						; size = 4
$T221672 = -228						; size = 4
$T221671 = -224						; size = 4
__Cat$221678 = -218					; size = 1
$T221676 = -217						; size = 1
$T221636 = -216						; size = 4
$T221635 = -212						; size = 4
__Cat$221642 = -206					; size = 1
$T221640 = -205						; size = 1
$T221606 = -204						; size = 4
$T221605 = -200						; size = 4
__Cat$221612 = -194					; size = 1
$T221610 = -193						; size = 1
$T221586 = -192						; size = 4
$T221574 = -188						; size = 4
$T221564 = -181						; size = 1
$T221563 = -180						; size = 4
__Cat$221581 = -175					; size = 1
$T221578 = -174						; size = 1
$T221577 = -173						; size = 1
$T221551 = -172						; size = 4
$T221539 = -168						; size = 4
$T221529 = -161						; size = 1
$T221528 = -160						; size = 4
__Cat$221546 = -155					; size = 1
$T221543 = -154						; size = 1
$T221542 = -153						; size = 1
$T221516 = -152						; size = 4
$T221504 = -148						; size = 4
$T221494 = -141						; size = 1
$T221493 = -140						; size = 4
__Cat$221510 = -135					; size = 1
$T221508 = -134						; size = 1
$T221507 = -133						; size = 1
__Count$221470 = -120					; size = 4
__Count$221444 = -48					; size = 4
__Tmp$214818 = -44					; size = 4
__Oldend$214819 = -40					; size = 4
__Tmp$214808 = -36					; size = 4
__Ncopied$214795 = -32					; size = 4
__Newvec$214793 = -28					; size = 4
__Whereoff$214794 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z PROC ; std::vector<int,std::allocator<int> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 416				; 000001a0H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN29@Insert_n
	mov	DWORD PTR tv280[ebp], 0
	jmp	SHORT $LN27@Insert_n
$LN29@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv280[ebp], eax
$LN27@Insert_n:
	mov	ecx, DWORD PTR tv280[ebp]
	mov	DWORD PTR __Capacity$[ebp], ecx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n
	jmp	$LN16@Insert_n
$LN14@Insert_n:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$221444[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$221444[ebp], 0
	jbe	SHORT $LN35@Insert_n
	mov	edx, DWORD PTR __Count$221444[ebp]
	mov	DWORD PTR tv288[ebp], edx
	jmp	SHORT $LN37@Insert_n
$LN35@Insert_n:
	mov	DWORD PTR tv288[ebp], 1
$LN37@Insert_n:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	eax, DWORD PTR tv288[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN42@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
	jmp	$LN16@Insert_n

; 1167 : 		else if (_Capacity < size() + _Count)

$LN42@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$221470[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$221470[ebp], 0
	jbe	SHORT $LN48@Insert_n
	mov	ecx, DWORD PTR __Count$221470[ebp]
	mov	DWORD PTR tv302[ebp], ecx
	jmp	SHORT $LN44@Insert_n
$LN48@Insert_n:
	mov	DWORD PTR tv302[ebp], 1
$LN44@Insert_n:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	mov	eax, DWORD PTR tv302[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	add	ecx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], ecx
$LN18@Insert_n:
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1171 : 			if (_Capacity < size() + _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], edx
	jae	SHORT $LN54@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN54@Insert_n:
	push	0
	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	add	esp, 8
	mov	DWORD PTR __Newvec$214793[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR __Whereoff$214794[ebp], edx

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$214795[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Whereoff$214794[ebp]
	mov	ecx, DWORD PTR __Newvec$214793[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T221516[ebp], edx
	mov	eax, DWORD PTR $T221516[ebp]
	mov	DWORD PTR $T221504[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T221507[ebp], cl
	mov	dl, BYTE PTR __Cat$221510[ebp]
	mov	BYTE PTR $T221508[ebp], dl
	mov	al, BYTE PTR $T221507[ebp]
	mov	BYTE PTR $T221494[ebp], al
	mov	ecx, DWORD PTR $T221504[ebp]
	mov	DWORD PTR $T221493[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T221493[ebp]
	push	ecx
	call	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ; stdext::unchecked_fill_n<int *,unsigned int,int>
	add	esp, 12					; 0000000cH

; 1179 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$214795[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$214795[ebp], edx

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T221551[ebp], ecx
	mov	edx, DWORD PTR __Newvec$214793[ebp]
	mov	DWORD PTR $T221539[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T221542[ebp], al
	mov	cl, BYTE PTR __Cat$221546[ebp]
	mov	BYTE PTR $T221543[ebp], cl
	mov	dl, BYTE PTR $T221542[ebp]
	mov	BYTE PTR $T221529[ebp], dl
	mov	eax, DWORD PTR $T221539[ebp]
	mov	DWORD PTR $T221528[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T221528[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T221551[ebp]
	push	ecx
	call	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
	add	esp, 16					; 00000010H

; 1182 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$214795[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$214795[ebp], edx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T221586[ebp], ecx
	mov	edx, DWORD PTR __Whereoff$214794[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Newvec$214793[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T221574[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T221577[ebp], dl
	mov	al, BYTE PTR __Cat$221581[ebp]
	mov	BYTE PTR $T221578[ebp], al
	mov	cl, BYTE PTR $T221577[ebp]
	mov	BYTE PTR $T221564[ebp], cl
	mov	edx, DWORD PTR $T221574[ebp]
	mov	DWORD PTR $T221563[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T221563[ebp]
	push	ecx
	mov	edx, DWORD PTR $T221586[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
	add	esp, 16					; 00000010H
	jmp	$LN19@Insert_n
__catch$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$214795[ebp], 1
	jle	SHORT $LN7@Insert_n

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	ecx, DWORD PTR __Whereoff$214794[ebp]
	mov	edx, DWORD PTR __Newvec$214793[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T221606[ebp], eax
	mov	ecx, DWORD PTR __Newvec$214793[ebp]
	mov	DWORD PTR $T221605[ebp], ecx
	mov	dl, BYTE PTR __Cat$221612[ebp]
	mov	BYTE PTR $T221610[ebp], dl
$LN7@Insert_n:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$214795[ebp], 0
	jle	SHORT $LN6@Insert_n

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	eax, DWORD PTR __Whereoff$214794[ebp]
	mov	ecx, DWORD PTR __Newvec$214793[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T221636[ebp], ecx
	mov	edx, DWORD PTR __Whereoff$214794[ebp]
	mov	eax, DWORD PTR __Newvec$214793[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T221635[ebp], ecx
	mov	dl, BYTE PTR __Cat$221642[ebp]
	mov	BYTE PTR $T221640[ebp], dl
$LN6@Insert_n:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Newvec$214793[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN103@Insert_n
	ret	0
$LN19@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN103@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN5@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T221684[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T221683[ebp], edx
	mov	eax, DWORD PTR $T221684[ebp]
	mov	DWORD PTR $T221672[ebp], eax
	mov	ecx, DWORD PTR $T221683[ebp]
	mov	DWORD PTR $T221671[ebp], ecx
	mov	dl, BYTE PTR __Cat$221678[ebp]
	mov	BYTE PTR $T221676[ebp], dl

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T221689[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T221688[ebp], ecx
	mov	edx, DWORD PTR $T221688[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR __Newvec$214793[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Newvec$214793[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$214793[ebp]
	mov	DWORD PTR [edx+4], eax
	jmp	$LN16@Insert_n
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 2
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$214808[ebp], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T221761[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T221742[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T221746[ebp], cl
	mov	dl, BYTE PTR __Cat$221750[ebp]
	mov	BYTE PTR $T221747[ebp], dl
	mov	al, BYTE PTR $T221746[ebp]
	mov	BYTE PTR $T221725[ebp], al
	mov	ecx, DWORD PTR $T221742[ebp]
	mov	DWORD PTR $T221724[ebp], ecx
	mov	edx, DWORD PTR $T221724[ebp]
	mov	DWORD PTR $T221714[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T221713[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T221755[ebp], cl
	mov	dl, BYTE PTR __Cat$221758[ebp]
	mov	BYTE PTR $T221756[ebp], dl
	movzx	eax, BYTE PTR $T221755[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T221756[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T221714[ebp]
	push	eax
	mov	ecx, DWORD PTR $T221761[ebp]
	push	ecx
	mov	edx, DWORD PTR $T221713[ebp]
	push	edx
	call	??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<int *,int *,std::allocator<int> >
	add	esp, 24					; 00000018H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	eax, DWORD PTR __Tmp$214808[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 2
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
	jmp	SHORT $LN21@Insert_n
__catch$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T221844[ebp], eax
	mov	ecx, DWORD PTR $T221844[ebp]
	mov	DWORD PTR $T221833[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T221832[ebp], ecx
	mov	dl, BYTE PTR __Cat$221840[ebp]
	mov	BYTE PTR $T221838[ebp], dl

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$3
	ret	0
$LN21@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, edx
	mov	DWORD PTR $T221860[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T221852[ebp], edx
	jmp	SHORT $LN151@Insert_n
$LN150@Insert_n:
	mov	eax, DWORD PTR $T221852[ebp]
	add	eax, 4
	mov	DWORD PTR $T221852[ebp], eax
$LN151@Insert_n:
	mov	ecx, DWORD PTR $T221852[ebp]
	cmp	ecx, DWORD PTR $T221860[ebp]
	je	SHORT $LN147@Insert_n
	mov	edx, DWORD PTR $T221852[ebp]
	mov	eax, DWORD PTR __Tmp$214808[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN150@Insert_n
$LN147@Insert_n:

; 1232 : 			}
; 1233 : 		else

	jmp	$LN16@Insert_n
$LN3@Insert_n:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$214818[ebp], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Oldend$214819[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T221911[ebp], eax
	mov	ecx, DWORD PTR $T221911[ebp]
	mov	DWORD PTR $T221899[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T221903[ebp], dl
	mov	al, BYTE PTR __Cat$221907[ebp]
	mov	BYTE PTR $T221904[ebp], al
	mov	cl, BYTE PTR $T221903[ebp]
	mov	BYTE PTR $T221889[ebp], cl
	mov	edx, DWORD PTR $T221899[ebp]
	mov	DWORD PTR $T221888[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T221888[ebp]
	push	ecx
	mov	edx, DWORD PTR __Oldend$214819[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Oldend$214819[ebp]
	sub	ecx, eax
	push	ecx
	call	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, DWORD PTR __Oldend$214819[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR __Oldend$214819[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T221963[ebp], ecx
	jmp	SHORT $LN186@Insert_n
$LN185@Insert_n:
	mov	edx, DWORD PTR $T221963[ebp]
	add	edx, 4
	mov	DWORD PTR $T221963[ebp], edx
$LN186@Insert_n:
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	cmp	DWORD PTR $T221963[ebp], edx
	je	SHORT $LN16@Insert_n
	mov	eax, DWORD PTR $T221963[ebp]
	mov	ecx, DWORD PTR __Tmp$214818[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN185@Insert_n
$LN16@Insert_n:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-436]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T222034 = -40						; size = 4
$T222024 = -33						; size = 1
$T222023 = -32						; size = 4
__Cat$222030 = -3					; size = 1
$T222028 = -2						; size = 1
$T222027 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z PROC ; std::vector<int,std::allocator<int> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR $T222034[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T222027[ebp], cl
	mov	dl, BYTE PTR __Cat$222030[ebp]
	mov	BYTE PTR $T222028[ebp], dl
	mov	al, BYTE PTR $T222027[ebp]
	mov	BYTE PTR $T222024[ebp], al
	mov	ecx, DWORD PTR $T222034[ebp]
	mov	DWORD PTR $T222023[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T222023[ebp]
	push	ecx
	call	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ; stdext::unchecked_fill_n<int *,unsigned int,int>
	add	esp, 12					; 0000000cH

; 1255 : 		return (_Ptr + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [eax+edx*4]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Ufill
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z
_TEXT	SEGMENT
$T222079 = -38						; size = 1
$T222078 = -37						; size = 1
$T222077 = -36						; size = 4
$T222076 = -32						; size = 4
$T222063 = -25						; size = 1
$T222062 = -24						; size = 4
$T222061 = -20						; size = 4
__Off$222071 = -16					; size = 4
__Result$222072 = -12					; size = 4
__Cat$222068 = -8					; size = 1
$T222066 = -7						; size = 1
$T222065 = -6						; size = 1
__Cat$222043 = -4					; size = 1
$T222039 = -3						; size = 1
$T222038 = -2						; size = 1
$T222037 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z PROC ; stdext::_Unchecked_move_backward<int *,int *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T222037[ebp], al
	mov	cl, BYTE PTR __Cat$222043[ebp]
	mov	BYTE PTR $T222038[ebp], cl
	mov	dl, BYTE PTR $T222037[ebp]
	mov	BYTE PTR $T222079[ebp], dl
	mov	al, BYTE PTR $T222039[ebp]
	mov	BYTE PTR $T222078[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T222077[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T222076[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T222065[ebp], al
	mov	cl, BYTE PTR __Cat$222068[ebp]
	mov	BYTE PTR $T222066[ebp], cl
	mov	dl, BYTE PTR $T222065[ebp]
	mov	BYTE PTR $T222063[ebp], dl
	mov	eax, DWORD PTR $T222077[ebp]
	mov	DWORD PTR $T222062[ebp], eax
	mov	ecx, DWORD PTR $T222076[ebp]
	mov	DWORD PTR $T222061[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR $T222061[ebp]
	sar	edx, 2
	mov	DWORD PTR __Off$222071[ebp], edx
	mov	eax, DWORD PTR __Off$222071[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR $T222062[ebp]
	sub	ecx, eax
	mov	DWORD PTR __Result$222072[ebp], ecx
	cmp	DWORD PTR __Off$222071[ebp], 0
	jle	SHORT $LN7@Unchecked_
	mov	edx, DWORD PTR __Off$222071[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR $T222061[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$222071[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __Result$222072[ebp]
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN7@Unchecked_:
	mov	eax, DWORD PTR __Result$222072[ebp]

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ENDP ; stdext::_Unchecked_move_backward<int *,int *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z
_TEXT	SEGMENT
$T222109 = -22						; size = 1
$T222108 = -21						; size = 1
$T222107 = -20						; size = 4
$T222098 = -13						; size = 1
$T222097 = -12						; size = 4
$T222096 = -8						; size = 4
$T222101 = -4						; size = 1
$T222083 = -2						; size = 1
$T222082 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z PROC	; stdext::unchecked_fill_n<int *,unsigned int,int>, COMDAT

; 3720 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T222082[ebp], al
	mov	cl, BYTE PTR $T222082[ebp]
	mov	BYTE PTR $T222109[ebp], cl
	mov	dl, BYTE PTR $T222083[ebp]
	mov	BYTE PTR $T222108[ebp], dl
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T222107[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T222101[ebp], cl
	mov	dl, BYTE PTR $T222101[ebp]
	mov	BYTE PTR $T222098[ebp], dl
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR $T222097[ebp], eax
	mov	ecx, DWORD PTR $T222107[ebp]
	mov	DWORD PTR $T222096[ebp], ecx
	jmp	SHORT $LN9@unchecked_@2
$LN8@unchecked_@2:
	mov	edx, DWORD PTR $T222097[ebp]
	sub	edx, 1
	mov	DWORD PTR $T222097[ebp], edx
	mov	eax, DWORD PTR $T222096[ebp]
	add	eax, 4
	mov	DWORD PTR $T222096[ebp], eax
$LN9@unchecked_@2:
	cmp	DWORD PTR $T222097[ebp], 0
	jbe	SHORT $LN1@unchecked_@2
	mov	ecx, DWORD PTR $T222096[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN8@unchecked_@2
$LN1@unchecked_@2:

; 3722 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ENDP	; stdext::unchecked_fill_n<int *,unsigned int,int>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
$T222126 = -21						; size = 1
$T222125 = -20						; size = 4
$T222124 = -16						; size = 4
__Result$222121 = -12					; size = 4
__Count$222120 = -8					; size = 4
__Cat$222116 = -3					; size = 1
$T222113 = -2						; size = 1
$T222112 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T222112[ebp], al
	mov	cl, BYTE PTR __Cat$222116[ebp]
	mov	BYTE PTR $T222113[ebp], cl
	mov	dl, BYTE PTR $T222112[ebp]
	mov	BYTE PTR $T222126[ebp], dl
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T222125[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T222124[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR $T222124[ebp]
	sar	edx, 2
	mov	DWORD PTR __Count$222120[ebp], edx
	mov	eax, DWORD PTR __Count$222120[ebp]
	mov	ecx, DWORD PTR $T222125[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Result$222121[ebp], edx
	cmp	DWORD PTR __Count$222120[ebp], 0
	jbe	SHORT $LN6@unchecked_@3
	mov	eax, DWORD PTR __Count$222120[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR $T222124[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$222120[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR $T222125[ebp]
	push	eax
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN6@unchecked_@3:
	mov	eax, DWORD PTR __Result$222121[ebp]

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<int *,int *,std::allocator<int> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@2

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@2:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<int *,int *,std::allocator<int> >
_TEXT	ENDS
END
