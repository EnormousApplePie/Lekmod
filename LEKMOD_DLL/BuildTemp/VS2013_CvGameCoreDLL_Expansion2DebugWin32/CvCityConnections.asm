; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvCityConnections.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABURouteInfo@CvCityConnections@@@Z ; operator<<
EXTRN	?Write@FDataStream@@IAEXABD@Z:PROC		; FDataStream::Write
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvcityconnections.cpp
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABURouteInfo@CvCityConnections@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABURouteInfo@CvCityConnections@@@Z PROC ; operator<<, COMDAT

; 21   : {

	push	ebp
	mov	ebp, esp

; 22   : 	saveTo << readFrom.m_cRouteState;

	mov	eax, DWORD PTR _readFrom$[ebp]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 23   : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 24   : }

	pop	ebp
	ret	0
??6@YAAAVFDataStream@@AAV0@ABURouteInfo@CvCityConnections@@@Z ENDP ; operator<<
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAURouteInfo@CvCityConnections@@@Z ; operator>>
EXTRN	?Read@FDataStream@@IAEXAAD@Z:PROC		; FDataStream::Read
; Function compile flags: /Odtp
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAURouteInfo@CvCityConnections@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAURouteInfo@CvCityConnections@@@Z PROC ; operator>>, COMDAT

; 27   : {

	push	ebp
	mov	ebp, esp

; 28   : 	loadFrom >> writeTo.m_cRouteState;

	mov	eax, DWORD PTR _writeTo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 29   : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 30   : }

	pop	ebp
	ret	0
??5@YAAAVFDataStream@@AAV0@AAURouteInfo@CvCityConnections@@@Z ENDP ; operator>>
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@UPlotRouteInfo@CvCityConnections@@$0GE@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvCityConnections::PlotRouteInfo,100,1,297,0>::~FStaticVector<CvCityConnections::PlotRouteInfo,100,1,297,0>
PUBLIC	??1?$FStaticVector@W4BuildingTypes@@$09$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum BuildingTypes,10,1,297,0>::~FStaticVector<enum BuildingTypes,10,1,297,0>
PUBLIC	??1?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ	; FStaticVector<int,64,1,297,0>::~FStaticVector<int,64,1,297,0>
PUBLIC	?Uninit@CvCityConnections@@QAEXXZ		; CvCityConnections::Uninit
PUBLIC	??0?$FStaticVector@UPlotRouteInfo@CvCityConnections@@$0GE@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvCityConnections::PlotRouteInfo,100,1,297,0>::FStaticVector<CvCityConnections::PlotRouteInfo,100,1,297,0>
PUBLIC	??0?$FStaticVector@W4BuildingTypes@@$09$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum BuildingTypes,10,1,297,0>::FStaticVector<enum BuildingTypes,10,1,297,0>
PUBLIC	??0?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ	; FStaticVector<int,64,1,297,0>::FStaticVector<int,64,1,297,0>
PUBLIC	??0CvCityConnections@@QAE@XZ			; CvCityConnections::CvCityConnections
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??0CvCityConnections@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvCityConnections@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvCityConnections@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CvCityConnections@@QAE@XZ$2
__ehfuncinfo$??0CvCityConnections@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0CvCityConnections@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvcityconnections.cpp
xdata$x	ENDS
;	COMDAT ??0CvCityConnections@@QAE@XZ
_TEXT	SEGMENT
_this$ = -40						; size = 4
__$EHRec$ = -12						; size = 12
??0CvCityConnections@@QAE@XZ PROC			; CvCityConnections::CvCityConnections, COMDAT
; _this$ = ecx

; 34   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvCityConnections@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<int,64,1,297,0>::FStaticVector<int,64,1,297,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 284				; 0000011cH
	call	??0?$FStaticVector@W4BuildingTypes@@$09$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum BuildingTypes,10,1,297,0>::FStaticVector<enum BuildingTypes,10,1,297,0>
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 340				; 00000154H
	call	??0?$FStaticVector@UPlotRouteInfo@CvCityConnections@@$0GE@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvCityConnections::PlotRouteInfo,100,1,297,0>::FStaticVector<CvCityConnections::PlotRouteInfo,100,1,297,0>
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 35   : 	m_aRouteInfos = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 36   : 	Uninit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Uninit@CvCityConnections@@QAEXXZ	; CvCityConnections::Uninit

; 37   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvCityConnections@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	??1?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<int,64,1,297,0>::~FStaticVector<int,64,1,297,0>
__unwindfunclet$??0CvCityConnections@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 284				; 0000011cH
	jmp	??1?$FStaticVector@W4BuildingTypes@@$09$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum BuildingTypes,10,1,297,0>::~FStaticVector<enum BuildingTypes,10,1,297,0>
__unwindfunclet$??0CvCityConnections@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 340				; 00000154H
	jmp	??1?$FStaticVector@UPlotRouteInfo@CvCityConnections@@$0GE@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvCityConnections::PlotRouteInfo,100,1,297,0>::~FStaticVector<CvCityConnections::PlotRouteInfo,100,1,297,0>
__ehhandler$??0CvCityConnections@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvCityConnections@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvCityConnections@@QAE@XZ ENDP			; CvCityConnections::CvCityConnections
PUBLIC	??1CvCityConnections@@QAE@XZ			; CvCityConnections::~CvCityConnections
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??1CvCityConnections@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvCityConnections@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvCityConnections@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvCityConnections@@QAE@XZ$2
__ehfuncinfo$??1CvCityConnections@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1CvCityConnections@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvcityconnections.cpp
xdata$x	ENDS
;	COMDAT ??1CvCityConnections@@QAE@XZ
_TEXT	SEGMENT
_this$ = -52						; size = 4
__$EHRec$ = -12						; size = 12
??1CvCityConnections@@QAE@XZ PROC			; CvCityConnections::~CvCityConnections, COMDAT
; _this$ = ecx

; 41   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvCityConnections@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 42   : 	Uninit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Uninit@CvCityConnections@@QAEXXZ	; CvCityConnections::Uninit

; 43   : }

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 340				; 00000154H
	call	??1?$FStaticVector@UPlotRouteInfo@CvCityConnections@@$0GE@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvCityConnections::PlotRouteInfo,100,1,297,0>::~FStaticVector<CvCityConnections::PlotRouteInfo,100,1,297,0>
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 284				; 0000011cH
	call	??1?$FStaticVector@W4BuildingTypes@@$09$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum BuildingTypes,10,1,297,0>::~FStaticVector<enum BuildingTypes,10,1,297,0>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??1?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<int,64,1,297,0>::~FStaticVector<int,64,1,297,0>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvCityConnections@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	??1?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<int,64,1,297,0>::~FStaticVector<int,64,1,297,0>
__unwindfunclet$??1CvCityConnections@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 284				; 0000011cH
	jmp	??1?$FStaticVector@W4BuildingTypes@@$09$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum BuildingTypes,10,1,297,0>::~FStaticVector<enum BuildingTypes,10,1,297,0>
__unwindfunclet$??1CvCityConnections@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 340				; 00000154H
	jmp	??1?$FStaticVector@UPlotRouteInfo@CvCityConnections@@$0GE@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvCityConnections::PlotRouteInfo,100,1,297,0>::~FStaticVector<CvCityConnections::PlotRouteInfo,100,1,297,0>
__ehhandler$??1CvCityConnections@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvCityConnections@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvCityConnections@@QAE@XZ ENDP			; CvCityConnections::~CvCityConnections
PUBLIC	?push_back@?$FStaticVector@W4BuildingTypes@@$09$00$0BCJ@$0A@@@QAEIABW4BuildingTypes@@@Z ; FStaticVector<enum BuildingTypes,10,1,297,0>::push_back
PUBLIC	?ResizeRouteInfo@CvCityConnections@@IAEXI@Z	; CvCityConnections::ResizeRouteInfo
PUBLIC	?Init@CvCityConnections@@QAEXPAVCvPlayer@@@Z	; CvCityConnections::Init
EXTRN	?AllowsWaterRoutes@CvBuildingEntry@@QBE_NXZ:PROC ; CvBuildingEntry::AllowsWaterRoutes
EXTRN	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z:PROC ; CvBuildingXMLEntries::GetEntry
EXTRN	?GetNumBuildings@CvBuildingXMLEntries@@QAEHXZ:PROC ; CvBuildingXMLEntries::GetNumBuildings
EXTRN	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ:PROC ; CvGlobals::GetGameBuildings
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Odtp
;	COMDAT ?Init@CvCityConnections@@QAEXPAVCvPlayer@@@Z
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T221205 = -52						; size = 4
_i$221200 = -48						; size = 4
$T221172 = -24						; size = 4
_i$221167 = -20						; size = 4
_eBuilding$220183 = -16					; size = 4
_pkBuildingInfo$220185 = -12				; size = 4
_i$220179 = -8						; size = 4
_pkBuildingEntries$ = -4				; size = 4
_pPlayer$ = 8						; size = 4
?Init@CvCityConnections@@QAEXPAVCvPlayer@@@Z PROC	; CvCityConnections::Init, COMDAT
; _this$ = ecx

; 47   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 48   : 	CvBuildingXMLEntries* pkBuildingEntries = GC.GetGameBuildings();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ ; CvGlobals::GetGameBuildings
	mov	DWORD PTR _pkBuildingEntries$[ebp], eax

; 49   : 	m_pPlayer = pPlayer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	mov	DWORD PTR [eax], ecx

; 50   : 
; 51   : 	m_uiRouteInfosDimension = 64;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 64			; 00000040H

; 52   : 	m_aRouteInfos = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 53   : 	ResizeRouteInfo(m_uiRouteInfosDimension);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResizeRouteInfo@CvCityConnections@@IAEXI@Z ; CvCityConnections::ResizeRouteInfo

; 54   : 
; 55   : 	m_aBuildingsAllowWaterRoutes.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 284				; 0000011cH
	mov	DWORD PTR $T221172[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN14@Init
	mov	DWORD PTR _i$221167[ebp], 0
	jmp	SHORT $LN12@Init
$LN11@Init:
	mov	edx, DWORD PTR _i$221167[ebp]
	add	edx, 1
	mov	DWORD PTR _i$221167[ebp], edx
$LN12@Init:
	mov	eax, DWORD PTR $T221172[ebp]
	mov	ecx, DWORD PTR _i$221167[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN14@Init
	jmp	SHORT $LN11@Init
$LN14@Init:
	mov	edx, DWORD PTR $T221172[ebp]
	mov	DWORD PTR [edx+4], 0

; 56   : #ifdef AUI_WARNING_FIXES
; 57   : 	for (uint i = 0; i < GC.GetGameBuildings()->GetNumBuildings(); i++)
; 58   : #else
; 59   : 	for(int i = 0; i < GC.GetGameBuildings()->GetNumBuildings(); i++)

	mov	DWORD PTR _i$220179[ebp], 0
	jmp	SHORT $LN5@Init
$LN4@Init:
	mov	eax, DWORD PTR _i$220179[ebp]
	add	eax, 1
	mov	DWORD PTR _i$220179[ebp], eax
$LN5@Init:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ ; CvGlobals::GetGameBuildings
	mov	ecx, eax
	call	?GetNumBuildings@CvBuildingXMLEntries@@QAEHXZ ; CvBuildingXMLEntries::GetNumBuildings
	cmp	DWORD PTR _i$220179[ebp], eax
	jge	SHORT $LN3@Init

; 60   : #endif
; 61   : 	{
; 62   : 		const BuildingTypes eBuilding = static_cast<BuildingTypes>(i);

	mov	ecx, DWORD PTR _i$220179[ebp]
	mov	DWORD PTR _eBuilding$220183[ebp], ecx

; 63   : 		CvBuildingEntry* pkBuildingInfo = pkBuildingEntries->GetEntry(eBuilding);

	mov	edx, DWORD PTR _eBuilding$220183[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkBuildingEntries$[ebp]
	call	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z ; CvBuildingXMLEntries::GetEntry
	mov	DWORD PTR _pkBuildingInfo$220185[ebp], eax

; 64   : 		if(pkBuildingInfo)

	cmp	DWORD PTR _pkBuildingInfo$220185[ebp], 0
	je	SHORT $LN2@Init

; 65   : 		{
; 66   : 			if(pkBuildingInfo->AllowsWaterRoutes())

	mov	ecx, DWORD PTR _pkBuildingInfo$220185[ebp]
	call	?AllowsWaterRoutes@CvBuildingEntry@@QBE_NXZ ; CvBuildingEntry::AllowsWaterRoutes
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Init

; 67   : 			{
; 68   : 				m_aBuildingsAllowWaterRoutes.push_back(eBuilding);

	lea	ecx, DWORD PTR _eBuilding$220183[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 284				; 0000011cH
	call	?push_back@?$FStaticVector@W4BuildingTypes@@$09$00$0BCJ@$0A@@@QAEIABW4BuildingTypes@@@Z ; FStaticVector<enum BuildingTypes,10,1,297,0>::push_back
$LN2@Init:

; 69   : 			}
; 70   : 		}
; 71   : 	}

	jmp	SHORT $LN4@Init
$LN3@Init:

; 72   : 
; 73   : 	m_aPlotRouteInfos.clear();

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 340				; 00000154H
	mov	DWORD PTR $T221205[ebp], edx
	xor	eax, eax
	je	SHORT $LN44@Init
	mov	DWORD PTR _i$221200[ebp], 0
	jmp	SHORT $LN42@Init
$LN41@Init:
	mov	ecx, DWORD PTR _i$221200[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$221200[ebp], ecx
$LN42@Init:
	mov	edx, DWORD PTR $T221205[ebp]
	mov	eax, DWORD PTR _i$221200[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jae	SHORT $LN44@Init
	jmp	SHORT $LN41@Init
$LN44@Init:
	mov	ecx, DWORD PTR $T221205[ebp]
	mov	DWORD PTR [ecx+4], 0

; 74   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Init@CvCityConnections@@QAEXPAVCvPlayer@@@Z ENDP	; CvCityConnections::Init
_TEXT	ENDS
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Odtp
;	COMDAT ?Uninit@CvCityConnections@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T221208 = -4						; size = 4
?Uninit@CvCityConnections@@QAEXXZ PROC			; CvCityConnections::Uninit, COMDAT
; _this$ = ecx

; 78   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 79   : 	m_pPlayer = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 80   : 	if(m_aRouteInfos)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN2@Uninit

; 81   : 	{
; 82   : 		delete [] m_aRouteInfos;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T221208[ebp], eax
	mov	ecx, DWORD PTR $T221208[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 83   : 		m_aRouteInfos = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
$LN2@Uninit:

; 84   : 	}
; 85   : #ifdef AUI_WARNING_FIXES
; 86   : 	m_uiRouteInfosDimension = 0;
; 87   : #endif
; 88   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Uninit@CvCityConnections@@QAEXXZ ENDP			; CvCityConnections::Uninit
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAEIABH@Z ; FStaticVector<int,64,1,297,0>::push_back
PUBLIC	?Read@CvCityConnections@@QAEXAAVFDataStream@@@Z	; CvCityConnections::Read
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Odtp
;	COMDAT ?Read@CvCityConnections@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -80						; size = 4
$T221246 = -36						; size = 4
_i$221241 = -32						; size = 4
$T221224 = -28						; size = 4
$T221220 = -24						; size = 4
_iValue$220208 = -20					; size = 4
_i$220204 = -16						; size = 4
_ui$220199 = -12					; size = 4
_iNumCityIDs$ = -8					; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Read@CvCityConnections@@QAEXAAVFDataStream@@@Z PROC	; CvCityConnections::Read, COMDAT
; _this$ = ecx

; 92   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 	// Version number to maintain backwards compatibility
; 94   : 	uint uiVersion;
; 95   : 	kStream >> uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 96   : 
; 97   : 	kStream >> m_uiRouteInfosDimension;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 98   : 	ResizeRouteInfo(m_uiRouteInfosDimension);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResizeRouteInfo@CvCityConnections@@IAEXI@Z ; CvCityConnections::ResizeRouteInfo

; 99   : 	for(uint ui = 0; ui < m_uiRouteInfosDimension * m_uiRouteInfosDimension; ui++)

	mov	DWORD PTR _ui$220199[ebp], 0
	jmp	SHORT $LN6@Read
$LN5@Read:
	mov	ecx, DWORD PTR _ui$220199[ebp]
	add	ecx, 1
	mov	DWORD PTR _ui$220199[ebp], ecx
$LN6@Read:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	imul	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR _ui$220199[ebp], ecx
	jae	SHORT $LN4@Read

; 100  : 	{
; 101  : 		kStream >> m_aRouteInfos[ui].m_cPassEval;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _ui$220199[ebp]
	lea	edx, DWORD PTR [eax+ecx*2+1]
	mov	DWORD PTR $T221220[ebp], edx
	mov	eax, DWORD PTR $T221220[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 102  : 		kStream >> m_aRouteInfos[ui].m_cRouteState;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _ui$220199[ebp]
	lea	ecx, DWORD PTR [edx+eax*2]
	mov	DWORD PTR $T221224[ebp], ecx
	mov	edx, DWORD PTR $T221224[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 103  : 	}

	jmp	SHORT $LN5@Read
$LN4@Read:

; 104  : 
; 105  : 	// read in city ids
; 106  : 	int iNumCityIDs;
; 107  : 	kStream >> iNumCityIDs;

	lea	eax, DWORD PTR _iNumCityIDs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 108  : 	m_aiCityPlotIDs.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR $T221246[ebp], ecx
	xor	edx, edx
	je	SHORT $LN25@Read
	mov	DWORD PTR _i$221241[ebp], 0
	jmp	SHORT $LN23@Read
$LN22@Read:
	mov	eax, DWORD PTR _i$221241[ebp]
	add	eax, 1
	mov	DWORD PTR _i$221241[ebp], eax
$LN23@Read:
	mov	ecx, DWORD PTR $T221246[ebp]
	mov	edx, DWORD PTR _i$221241[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jae	SHORT $LN25@Read
	jmp	SHORT $LN22@Read
$LN25@Read:
	mov	eax, DWORD PTR $T221246[ebp]
	mov	DWORD PTR [eax+4], 0

; 109  : 	for(int i = 0; i < iNumCityIDs; i++)

	mov	DWORD PTR _i$220204[ebp], 0
	jmp	SHORT $LN3@Read
$LN2@Read:
	mov	ecx, DWORD PTR _i$220204[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$220204[ebp], ecx
$LN3@Read:
	mov	edx, DWORD PTR _i$220204[ebp]
	cmp	edx, DWORD PTR _iNumCityIDs$[ebp]
	jge	SHORT $LN7@Read

; 110  : 	{
; 111  : 		int iValue;
; 112  : 		kStream >> iValue;

	lea	eax, DWORD PTR _iValue$220208[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 113  : 		m_aiCityPlotIDs.push_back(iValue);

	lea	ecx, DWORD PTR _iValue$220208[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?push_back@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAEIABH@Z ; FStaticVector<int,64,1,297,0>::push_back
	jmp	SHORT $LN2@Read
$LN7@Read:

; 114  : 	}
; 115  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Read@CvCityConnections@@QAEXAAVFDataStream@@@Z ENDP	; CvCityConnections::Read
_TEXT	ENDS
PUBLIC	?Write@CvCityConnections@@QBEXAAVFDataStream@@@Z ; CvCityConnections::Write
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Odtp
;	COMDAT ?Write@CvCityConnections@@QBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T221327 = -36						; size = 4
$T221320 = -32						; size = 4
$T221313 = -28						; size = 4
$T221309 = -24						; size = 4
$T221305 = -20						; size = 4
$T221295 = -16						; size = 4
_ui$220219 = -12					; size = 4
_ui$220214 = -8						; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Write@CvCityConnections@@QBEXAAVFDataStream@@@Z PROC	; CvCityConnections::Write, COMDAT
; _this$ = ecx

; 119  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 	// Current version number
; 121  : 	uint uiVersion = 1;

	mov	DWORD PTR _uiVersion$[ebp], 1

; 122  : 	kStream << uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 123  : 
; 124  : 	kStream << m_uiRouteInfosDimension;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 125  : 	for(uint ui = 0; ui < m_uiRouteInfosDimension * m_uiRouteInfosDimension; ui++)

	mov	DWORD PTR _ui$220214[ebp], 0
	jmp	SHORT $LN6@Write
$LN5@Write:
	mov	edx, DWORD PTR _ui$220214[ebp]
	add	edx, 1
	mov	DWORD PTR _ui$220214[ebp], edx
$LN6@Write:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	imul	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR _ui$220214[ebp], edx
	jae	SHORT $LN4@Write

; 126  : 	{
; 127  : 		kStream << m_aRouteInfos[ui].m_cPassEval;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _ui$220214[ebp]
	lea	eax, DWORD PTR [ecx+edx*2+1]
	mov	DWORD PTR $T221305[ebp], eax
	mov	ecx, DWORD PTR $T221305[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 128  : 		kStream << m_aRouteInfos[ui].m_cRouteState;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _ui$220214[ebp]
	lea	edx, DWORD PTR [eax+ecx*2]
	mov	DWORD PTR $T221309[ebp], edx
	mov	eax, DWORD PTR $T221309[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 129  : 	}

	jmp	SHORT $LN5@Write
$LN4@Write:

; 130  : 
; 131  : 	kStream << m_aiCityPlotIDs.size();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR $T221313[ebp], edx
	mov	eax, DWORD PTR $T221313[ebp]
	mov	DWORD PTR $T221295[ebp], eax
	lea	ecx, DWORD PTR $T221295[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 132  : 	for(uint ui = 0; ui < m_aiCityPlotIDs.size(); ui++)

	mov	DWORD PTR _ui$220219[ebp], 0
	jmp	SHORT $LN3@Write
$LN2@Write:
	mov	edx, DWORD PTR _ui$220219[ebp]
	add	edx, 1
	mov	DWORD PTR _ui$220219[ebp], edx
$LN3@Write:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR $T221320[ebp], ecx
	mov	edx, DWORD PTR _ui$220219[ebp]
	cmp	edx, DWORD PTR $T221320[ebp]
	jae	SHORT $LN7@Write

; 133  : 	{
; 134  : 		kStream << m_aiCityPlotIDs[ui];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _ui$220219[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T221327[ebp], eax
	mov	ecx, DWORD PTR $T221327[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 135  : 	}

	jmp	SHORT $LN2@Write
$LN7@Write:

; 136  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Write@CvCityConnections@@QBEXAAVFDataStream@@@Z ENDP	; CvCityConnections::Write
_TEXT	ENDS
PUBLIC	?BroadcastPlotRouteStateChanges@CvCityConnections@@IAEXXZ ; CvCityConnections::BroadcastPlotRouteStateChanges
PUBLIC	?UpdateRouteInfo@CvCityConnections@@QAEXXZ	; CvCityConnections::UpdateRouteInfo
PUBLIC	?UpdateCityPlotIDs@CvCityConnections@@QAEXXZ	; CvCityConnections::UpdateCityPlotIDs
PUBLIC	?UpdatePlotRouteStates@CvCityConnections@@IAEXXZ ; CvCityConnections::UpdatePlotRouteStates
PUBLIC	?Update@CvCityConnections@@QAEXXZ		; CvCityConnections::Update
EXTRN	?isBarbarian@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isBarbarian
; Function compile flags: /Odtp
;	COMDAT ?Update@CvCityConnections@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Update@CvCityConnections@@QAEXXZ PROC			; CvCityConnections::Update, COMDAT
; _this$ = ecx

; 140  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 141  : 	if(m_pPlayer->isBarbarian())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@Update

; 142  : 	{
; 143  : 		return;

	jmp	SHORT $LN2@Update
$LN1@Update:

; 144  : 	}
; 145  : 
; 146  : 	UpdatePlotRouteStates();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdatePlotRouteStates@CvCityConnections@@IAEXXZ ; CvCityConnections::UpdatePlotRouteStates

; 147  : 	UpdateCityPlotIDs();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateCityPlotIDs@CvCityConnections@@QAEXXZ ; CvCityConnections::UpdateCityPlotIDs

; 148  : 	UpdateRouteInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateRouteInfo@CvCityConnections@@QAEXXZ ; CvCityConnections::UpdateRouteInfo

; 149  : 	BroadcastPlotRouteStateChanges();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?BroadcastPlotRouteStateChanges@CvCityConnections@@IAEXXZ ; CvCityConnections::BroadcastPlotRouteStateChanges
$LN2@Update:

; 150  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Update@CvCityConnections@@QAEXXZ ENDP			; CvCityConnections::Update
_TEXT	ENDS
PUBLIC	?ShouldConnectToOtherPlayer@CvCityConnections@@QAE_NW4PlayerTypes@@@Z ; CvCityConnections::ShouldConnectToOtherPlayer
PUBLIC	?ResetCityPlotIDs@CvCityConnections@@QAEXXZ	; CvCityConnections::ResetCityPlotIDs
EXTRN	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ:PROC	; CvPlayer::getCapitalCity
EXTRN	?GetPlotIndex@CvPlot@@QBEHXZ:PROC		; CvPlot::GetPlotIndex
EXTRN	?plot@CvCity@@QBEPAVCvPlot@@XZ:PROC		; CvCity::plot
EXTRN	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::nextCity
EXTRN	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::firstCity
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Odtp
;	COMDAT ?UpdateCityPlotIDs@CvCityConnections@@QAEXXZ
_TEXT	SEGMENT
_this$ = -108						; size = 4
$T221375 = -68						; size = 4
$T221364 = -60						; size = 4
$T221360 = -56						; size = 4
$T221356 = -52						; size = 4
$T221339 = -48						; size = 4
$T221335 = -44						; size = 4
_iPlotIndex$220253 = -40				; size = 4
_pOtherCapital$220251 = -36				; size = 4
_iPlotIndex$220248 = -32				; size = 4
_ePlayer$220239 = -28					; size = 4
_eMyPlayerTeam$220243 = -24				; size = 4
_ePlayerTeam$220242 = -20				; size = 4
_ui$220235 = -16					; size = 4
_iIndex$ = -12						; size = 4
_pLoopCity$ = -8					; size = 4
_iLoop$ = -4						; size = 4
?UpdateCityPlotIDs@CvCityConnections@@QAEXXZ PROC	; CvCityConnections::UpdateCityPlotIDs, COMDAT
; _this$ = ecx

; 154  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 	ResetCityPlotIDs();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetCityPlotIDs@CvCityConnections@@QAEXXZ ; CvCityConnections::ResetCityPlotIDs

; 156  : 	int iIndex = 0;

	mov	DWORD PTR _iIndex$[ebp], 0

; 157  : 	int iLoop;
; 158  : 	CvCity* pLoopCity;
; 159  : 
; 160  : 	for(uint ui = 0; ui < MAX_CIV_PLAYERS; ui++)

	mov	DWORD PTR _ui$220235[ebp], 0
	jmp	SHORT $LN11@UpdateCity
$LN10@UpdateCity:
	mov	eax, DWORD PTR _ui$220235[ebp]
	add	eax, 1
	mov	DWORD PTR _ui$220235[ebp], eax
$LN11@UpdateCity:
	cmp	DWORD PTR _ui$220235[ebp], 63		; 0000003fH
	jae	$LN12@UpdateCity

; 161  : 	{
; 162  : 		PlayerTypes ePlayer = (PlayerTypes)ui;

	mov	ecx, DWORD PTR _ui$220235[ebp]
	mov	DWORD PTR _ePlayer$220239[ebp], ecx

; 163  : 		if(GET_PLAYER(ePlayer).isBarbarian())

	mov	edx, DWORD PTR _ePlayer$220239[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T221335[ebp], edx
	mov	ecx, DWORD PTR $T221335[ebp]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@UpdateCity

; 164  : 		{
; 165  : 			continue;

	jmp	SHORT $LN10@UpdateCity
$LN8@UpdateCity:

; 166  : 		}
; 167  : 
; 168  : 		TeamTypes ePlayerTeam = GET_PLAYER(ePlayer).getTeam();

	mov	ecx, DWORD PTR _ePlayer$220239[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T221339[ebp], ecx
	mov	edx, DWORD PTR $T221339[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _ePlayerTeam$220242[ebp], eax

; 169  : 		TeamTypes eMyPlayerTeam = m_pPlayer->getTeam();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T221356[ebp], edx
	mov	eax, DWORD PTR $T221356[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eMyPlayerTeam$220243[ebp], eax

; 170  : 
; 171  : 		if(ePlayerTeam == eMyPlayerTeam)

	mov	edx, DWORD PTR _ePlayerTeam$220242[ebp]
	cmp	edx, DWORD PTR _eMyPlayerTeam$220243[ebp]
	jne	SHORT $LN7@UpdateCity

; 172  : 		{
; 173  : 			// player's city
; 174  : 			for(pLoopCity = GET_PLAYER(ePlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iLoop))

	mov	eax, DWORD PTR _ePlayer$220239[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T221360[ebp], eax
	push	0
	lea	ecx, DWORD PTR _iLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T221360[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
	jmp	SHORT $LN6@UpdateCity
$LN5@UpdateCity:
	mov	edx, DWORD PTR _ePlayer$220239[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T221364[ebp], edx
	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T221364[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
$LN6@UpdateCity:
	cmp	DWORD PTR _pLoopCity$[ebp], 0
	je	SHORT $LN4@UpdateCity

; 175  : 			{
; 176  : 				CvAssertMsg(pLoopCity->plot(), "pLoopCity does not have a plot. What??");
; 177  : 				int iPlotIndex = pLoopCity->plot()->GetPlotIndex();

	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	ecx, eax
	call	?GetPlotIndex@CvPlot@@QBEHXZ		; CvPlot::GetPlotIndex
	mov	DWORD PTR _iPlotIndex$220248[ebp], eax

; 178  : 				m_aiCityPlotIDs.push_back(iPlotIndex);

	lea	ecx, DWORD PTR _iPlotIndex$220248[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?push_back@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAEIABH@Z ; FStaticVector<int,64,1,297,0>::push_back

; 179  : 				iIndex++;

	mov	edx, DWORD PTR _iIndex$[ebp]
	add	edx, 1
	mov	DWORD PTR _iIndex$[ebp], edx

; 180  : 			}

	jmp	SHORT $LN5@UpdateCity
$LN4@UpdateCity:

; 181  : 		}
; 182  : 		else if(ShouldConnectToOtherPlayer(ePlayer))

	jmp	SHORT $LN3@UpdateCity
$LN7@UpdateCity:
	mov	eax, DWORD PTR _ePlayer$220239[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShouldConnectToOtherPlayer@CvCityConnections@@QAE_NW4PlayerTypes@@@Z ; CvCityConnections::ShouldConnectToOtherPlayer
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@UpdateCity

; 183  : 		{
; 184  : 			CvCity* pOtherCapital = GET_PLAYER(ePlayer).getCapitalCity();

	mov	edx, DWORD PTR _ePlayer$220239[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T221375[ebp], edx
	mov	ecx, DWORD PTR $T221375[ebp]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	DWORD PTR _pOtherCapital$220251[ebp], eax

; 185  : 			if(pOtherCapital)

	cmp	DWORD PTR _pOtherCapital$220251[ebp], 0
	je	SHORT $LN3@UpdateCity

; 186  : 			{
; 187  : 				int iPlotIndex = pOtherCapital->plot()->GetPlotIndex();

	mov	ecx, DWORD PTR _pOtherCapital$220251[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	ecx, eax
	call	?GetPlotIndex@CvPlot@@QBEHXZ		; CvPlot::GetPlotIndex
	mov	DWORD PTR _iPlotIndex$220253[ebp], eax

; 188  : 				m_aiCityPlotIDs.push_back(iPlotIndex);

	lea	eax, DWORD PTR _iPlotIndex$220253[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?push_back@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAEIABH@Z ; FStaticVector<int,64,1,297,0>::push_back

; 189  : 				iIndex++;

	mov	ecx, DWORD PTR _iIndex$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iIndex$[ebp], ecx
$LN3@UpdateCity:

; 190  : 			}
; 191  : 		}

	jmp	$LN10@UpdateCity
$LN12@UpdateCity:

; 192  : 	}
; 193  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateCityPlotIDs@CvCityConnections@@QAEXXZ ENDP	; CvCityConnections::UpdateCityPlotIDs
_TEXT	ENDS
PUBLIC	?GetRouteInfo@CvCityConnections@@QAEPAURouteInfo@1@II@Z ; CvCityConnections::GetRouteInfo
; Function compile flags: /Odtp
;	COMDAT ?GetRouteInfo@CvCityConnections@@QAEPAURouteInfo@1@II@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_uiFirstCityIndex$ = 8					; size = 4
_uiSecondCityIndex$ = 12				; size = 4
?GetRouteInfo@CvCityConnections@@QAEPAURouteInfo@1@II@Z PROC ; CvCityConnections::GetRouteInfo, COMDAT
; _this$ = ecx

; 196  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 197  : 	if(uiFirstCityIndex >= m_uiRouteInfosDimension || uiSecondCityIndex >= m_uiRouteInfosDimension)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiFirstCityIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN1@GetRouteIn
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiSecondCityIndex$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jb	SHORT $LN2@GetRouteIn
$LN1@GetRouteIn:

; 198  : 	{
; 199  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN3@GetRouteIn
$LN2@GetRouteIn:

; 200  : 	}
; 201  : 
; 202  : 	return &(m_aRouteInfos[uiFirstCityIndex * m_uiRouteInfosDimension + uiSecondCityIndex]);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiFirstCityIndex$[ebp]
	imul	edx, DWORD PTR [ecx+4]
	add	edx, DWORD PTR _uiSecondCityIndex$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	lea	eax, DWORD PTR [ecx+edx*2]
$LN3@GetRouteIn:

; 203  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetRouteInfo@CvCityConnections@@QAEPAURouteInfo@1@II@Z ENDP ; CvCityConnections::GetRouteInfo
_TEXT	ENDS
PUBLIC	?ResetRouteInfo@CvCityConnections@@QAEXXZ	; CvCityConnections::ResetRouteInfo
; Function compile flags: /Odtp
;	COMDAT ?ResetRouteInfo@CvCityConnections@@QAEXXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
_ui2$220270 = -12					; size = 4
_ui$220266 = -8						; size = 4
_pRouteInfo$ = -4					; size = 4
?ResetRouteInfo@CvCityConnections@@QAEXXZ PROC		; CvCityConnections::ResetRouteInfo, COMDAT
; _this$ = ecx

; 207  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 208  : 	RouteInfo* pRouteInfo = NULL;

	mov	DWORD PTR _pRouteInfo$[ebp], 0

; 209  : 	for(uint ui = 0; ui < m_uiRouteInfosDimension; ui++)

	mov	DWORD PTR _ui$220266[ebp], 0
	jmp	SHORT $LN7@ResetRoute
$LN6@ResetRoute:
	mov	eax, DWORD PTR _ui$220266[ebp]
	add	eax, 1
	mov	DWORD PTR _ui$220266[ebp], eax
$LN7@ResetRoute:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _ui$220266[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jae	SHORT $LN8@ResetRoute

; 210  : 	{
; 211  : 		for(uint ui2 = 0; ui2 < m_uiRouteInfosDimension; ui2++)

	mov	DWORD PTR _ui2$220270[ebp], 0
	jmp	SHORT $LN4@ResetRoute
$LN3@ResetRoute:
	mov	eax, DWORD PTR _ui2$220270[ebp]
	add	eax, 1
	mov	DWORD PTR _ui2$220270[ebp], eax
$LN4@ResetRoute:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _ui2$220270[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jae	SHORT $LN2@ResetRoute

; 212  : 		{
; 213  : 			pRouteInfo = GetRouteInfo(ui, ui2);

	mov	eax, DWORD PTR _ui2$220270[ebp]
	push	eax
	mov	ecx, DWORD PTR _ui$220266[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRouteInfo@CvCityConnections@@QAEPAURouteInfo@1@II@Z ; CvCityConnections::GetRouteInfo
	mov	DWORD PTR _pRouteInfo$[ebp], eax

; 214  : 			if(!pRouteInfo)

	cmp	DWORD PTR _pRouteInfo$[ebp], 0
	jne	SHORT $LN1@ResetRoute

; 215  : 			{
; 216  : 				continue;

	jmp	SHORT $LN3@ResetRoute
$LN1@ResetRoute:

; 217  : 			}
; 218  : 
; 219  : 			pRouteInfo->m_cRouteState = 0;

	mov	edx, DWORD PTR _pRouteInfo$[ebp]
	mov	BYTE PTR [edx], 0

; 220  : 			pRouteInfo->m_cPassEval = -1;

	mov	eax, DWORD PTR _pRouteInfo$[ebp]
	mov	BYTE PTR [eax+1], -1

; 221  : 		}

	jmp	SHORT $LN3@ResetRoute
$LN2@ResetRoute:

; 222  : 	}

	jmp	SHORT $LN6@ResetRoute
$LN8@ResetRoute:

; 223  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ResetRouteInfo@CvCityConnections@@QAEXXZ ENDP		; CvCityConnections::ResetRouteInfo
_TEXT	ENDS
PUBLIC	?ConnectPlotRoute@CvCityConnections@@IAEXPAVCvPlot@@@Z ; CvCityConnections::ConnectPlotRoute
PUBLIC	?GetIndexFromCity@CvCityConnections@@QAEIPAVCvCity@@@Z ; CvCityConnections::GetIndexFromCity
PUBLIC	??1?$FStaticVector@PAVCvCity@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvCity *,64,1,297,0>::~FStaticVector<CvCity *,64,1,297,0>
PUBLIC	__real@3fc00000
PUBLIC	?push_back@?$FStaticVector@PAVCvCity@@$0EA@$00$0BCJ@$0A@@@QAEIABQAVCvCity@@@Z ; FStaticVector<CvCity *,64,1,297,0>::push_back
PUBLIC	??0?$FStaticVector@PAVCvCity@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvCity *,64,1,297,0>::FStaticVector<CvCity *,64,1,297,0>
PUBLIC	__$ArrayPad$
EXTRN	?isCapital@CvCity@@QBE_NXZ:PROC			; CvCity::isCapital
EXTRN	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z:PROC	; CvAStar::GeneratePath
EXTRN	?GetWaterRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ:PROC ; CvGlobals::GetWaterRouteFinder
EXTRN	?IsBlockaded@CvCity@@QBE_NXZ:PROC		; CvCity::IsBlockaded
EXTRN	?getRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ:PROC ; CvGlobals::getRouteFinder
EXTRN	?GetNumActiveBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z:PROC ; CvCityBuildings::GetNumActiveBuilding
EXTRN	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ:PROC ; CvCity::GetCityBuildings
EXTRN	?SetRouteToCapitalConnected@CvCity@@QAEX_N@Z:PROC ; CvCity::SetRouteToCapitalConnected
EXTRN	?getBestRoute@CvPlayer@@QBE?AW4RouteTypes@@PAVCvPlot@@@Z:PROC ; CvPlayer::getBestRoute
EXTRN	__fltused:DWORD
;	COMDAT __real@3fc00000
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
__real@3fc00000 DD 03fc00000r			; 1.5
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?UpdateRouteInfo@CvCityConnections@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdateRouteInfo@CvCityConnections@@QAEXXZ$0
__ehfuncinfo$?UpdateRouteInfo@CvCityConnections@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?UpdateRouteInfo@CvCityConnections@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvcityconnections.cpp
xdata$x	ENDS
;	COMDAT ?UpdateRouteInfo@CvCityConnections@@QAEXXZ
_TEXT	SEGMENT
tv607 = -604						; size = 4
tv654 = -600						; size = 4
tv718 = -596						; size = 8
tv716 = -588						; size = 4
tv713 = -582						; size = 2
tv710 = -580						; size = 8
_this$ = -572						; size = 4
$T221742 = -556						; size = 4
$T221741 = -552						; size = 4
$T221696 = -548						; size = 4
$T221683 = -544						; size = 4
$T221679 = -540						; size = 4
$T221665 = -536						; size = 4
$T221661 = -529						; size = 1
$T221650 = -528						; size = 4
$T221646 = -521						; size = 1
_iMapY$221740 = -520					; size = 4
_iMapX$221739 = -516					; size = 4
$T221639 = -512						; size = 4
$T221632 = -508						; size = 4
$T221623 = -504						; size = 4
$T221614 = -500						; size = 4
$T221605 = -496						; size = 4
$T221596 = -492						; size = 4
$T221587 = -488						; size = 4
$T221578 = -484						; size = 4
$T221569 = -480						; size = 4
$T221560 = -476						; size = 4
$T221551 = -472						; size = 4
$T221542 = -468						; size = 4
$T221533 = -464						; size = 4
$T221524 = -460						; size = 4
$T221515 = -456						; size = 4
$T221506 = -452						; size = 4
$T221497 = -448						; size = 4
$T221493 = -444						; size = 4
$T221489 = -440						; size = 4
$T221482 = -436						; size = 4
$T221475 = -432						; size = 4
$T221459 = -420						; size = 4
$T221448 = -412						; size = 4
$T221444 = -408						; size = 4
$T221440 = -404						; size = 4
$T221429 = -396						; size = 4
$T221420 = -392						; size = 4
_pPlot$220511 = -388					; size = 4
_pNode$220512 = -384					; size = 4
_bAnyRouteFound$220498 = -378				; size = 1
_bBestRouteFound$220499 = -377				; size = 1
_iRouteValue$220500 = -376				; size = 4
_iPathfinderFlags$220501 = -372				; size = 4
_i$220487 = -368					; size = 4
_bFirstCityHasHarbor$220485 = -362			; size = 1
_bSecondCityHasHarbor$220486 = -361			; size = 1
_pInverseRouteInfo$220478 = -360			; size = 4
_pRouteInfo$220477 = -356				; size = 4
_iSecondCityArrayIndex$220476 = -352			; size = 4
_uiSecondCityIndex$220471 = -348			; size = 4
_iFirstCityArrayIndex$220470 = -344			; size = 4
_uiFirstCityIndex$220466 = -340				; size = 4
_pkLandRouteFinder$220465 = -336			; size = 4
_pFirstCity$220463 = -332				; size = 4
_pSecondCity$220464 = -328				; size = 4
_iPass$220456 = -324					; size = 4
_pOtherCapital$220450 = -320				; size = 4
_uiBuildingTypes$220443 = -316				; size = 4
_ePlayer$220435 = -312					; size = 4
_ui$220431 = -308					; size = 4
_bAllowWaterRoutes$ = -301				; size = 1
_vpCities$ = -300					; size = 272
__$ArrayPad$ = -28					; size = 4
_eBestRouteType$ = -24					; size = 4
_pLoopCity$ = -20					; size = 4
_iLoop$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?UpdateRouteInfo@CvCityConnections@@QAEXXZ PROC		; CvCityConnections::UpdateRouteInfo, COMDAT
; _this$ = ecx

; 226  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?UpdateRouteInfo@CvCityConnections@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 592				; 00000250H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 227  : 	RouteTypes eBestRouteType = m_pPlayer->getBestRoute();

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getBestRoute@CvPlayer@@QBE?AW4RouteTypes@@PAVCvPlot@@@Z ; CvPlayer::getBestRoute
	mov	DWORD PTR _eBestRouteType$[ebp], eax

; 228  : 
; 229  : 	// build city list
; 230  : 	FStaticVector<CvCity*, SAFE_ESTIMATE_NUM_CITIES, true, c_eCiv5GameplayDLL, 0> vpCities;

	lea	ecx, DWORD PTR _vpCities$[ebp]
	call	??0?$FStaticVector@PAVCvCity@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvCity *,64,1,297,0>::FStaticVector<CvCity *,64,1,297,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 231  : 	CvCity* pLoopCity = NULL;

	mov	DWORD PTR _pLoopCity$[ebp], 0

; 232  : 	int iLoop;
; 233  : 
; 234  : 	bool bAllowWaterRoutes = false;

	mov	BYTE PTR _bAllowWaterRoutes$[ebp], 0

; 235  : 
; 236  : 	// add all the cities we control and those that we want to connect to
; 237  : 	for(uint ui = 0; ui < MAX_CIV_PLAYERS; ui++)

	mov	DWORD PTR _ui$220431[ebp], 0
	jmp	SHORT $LN57@UpdateRout
$LN56@UpdateRout:
	mov	ecx, DWORD PTR _ui$220431[ebp]
	add	ecx, 1
	mov	DWORD PTR _ui$220431[ebp], ecx
$LN57@UpdateRout:
	cmp	DWORD PTR _ui$220431[ebp], 63		; 0000003fH
	jae	$LN55@UpdateRout

; 238  : 	{
; 239  : 		PlayerTypes ePlayer = (PlayerTypes)ui;

	mov	edx, DWORD PTR _ui$220431[ebp]
	mov	DWORD PTR _ePlayer$220435[ebp], edx

; 240  : 		if(GET_PLAYER(ePlayer).isBarbarian())

	mov	eax, DWORD PTR _ePlayer$220435[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T221420[ebp], eax
	mov	ecx, DWORD PTR $T221420[ebp]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN54@UpdateRout

; 241  : 		{
; 242  : 			continue;

	jmp	SHORT $LN56@UpdateRout
$LN54@UpdateRout:

; 243  : 		}
; 244  : 
; 245  : 		if(ePlayer == m_pPlayer->GetID())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T221429[ebp], ecx
	mov	edx, DWORD PTR _ePlayer$220435[ebp]
	cmp	edx, DWORD PTR $T221429[ebp]
	jne	$LN53@UpdateRout

; 246  : 		{
; 247  : 			// player's city
; 248  : 			for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
	jmp	SHORT $LN52@UpdateRout
$LN51@UpdateRout:
	push	0
	lea	edx, DWORD PTR _iLoop$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
$LN52@UpdateRout:
	cmp	DWORD PTR _pLoopCity$[ebp], 0
	je	$LN50@UpdateRout

; 249  : 			{
; 250  : 				vpCities.push_back(pLoopCity);

	lea	ecx, DWORD PTR _pLoopCity$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _vpCities$[ebp]
	call	?push_back@?$FStaticVector@PAVCvCity@@$0EA@$00$0BCJ@$0A@@@QAEIABQAVCvCity@@@Z ; FStaticVector<CvCity *,64,1,297,0>::push_back

; 251  : 				pLoopCity->SetRouteToCapitalConnected(false);

	push	0
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?SetRouteToCapitalConnected@CvCity@@QAEX_N@Z ; CvCity::SetRouteToCapitalConnected

; 252  : 
; 253  : 				if(!bAllowWaterRoutes)

	movzx	edx, BYTE PTR _bAllowWaterRoutes$[ebp]
	test	edx, edx
	jne	SHORT $LN46@UpdateRout

; 254  : 				{
; 255  : 					for(uint uiBuildingTypes = 0; uiBuildingTypes < m_aBuildingsAllowWaterRoutes.size(); uiBuildingTypes++)

	mov	DWORD PTR _uiBuildingTypes$220443[ebp], 0
	jmp	SHORT $LN48@UpdateRout
$LN47@UpdateRout:
	mov	eax, DWORD PTR _uiBuildingTypes$220443[ebp]
	add	eax, 1
	mov	DWORD PTR _uiBuildingTypes$220443[ebp], eax
$LN48@UpdateRout:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+288]
	mov	DWORD PTR $T221440[ebp], edx
	mov	eax, DWORD PTR _uiBuildingTypes$220443[ebp]
	cmp	eax, DWORD PTR $T221440[ebp]
	jae	SHORT $LN46@UpdateRout

; 256  : 					{
; 257  : 						if(pLoopCity->GetCityBuildings()->GetNumActiveBuilding(m_aBuildingsAllowWaterRoutes[uiBuildingTypes]) > 0)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+284]
	mov	eax, DWORD PTR _uiBuildingTypes$220443[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T221444[ebp], ecx
	mov	edx, DWORD PTR $T221444[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumActiveBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumActiveBuilding
	test	eax, eax
	jle	SHORT $LN45@UpdateRout

; 258  : 						{
; 259  : 							bAllowWaterRoutes = true;

	mov	BYTE PTR _bAllowWaterRoutes$[ebp], 1
$LN45@UpdateRout:

; 260  : 						}
; 261  : 					}

	jmp	SHORT $LN47@UpdateRout
$LN46@UpdateRout:

; 262  : 				}
; 263  : 			}

	jmp	$LN51@UpdateRout
$LN50@UpdateRout:

; 264  : 		}
; 265  : 		else if(ShouldConnectToOtherPlayer(ePlayer))

	jmp	SHORT $LN42@UpdateRout
$LN53@UpdateRout:
	mov	ecx, DWORD PTR _ePlayer$220435[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShouldConnectToOtherPlayer@CvCityConnections@@QAE_NW4PlayerTypes@@@Z ; CvCityConnections::ShouldConnectToOtherPlayer
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN42@UpdateRout

; 266  : 		{
; 267  : 			CvCity* pOtherCapital = GET_PLAYER(ePlayer).getCapitalCity();

	mov	eax, DWORD PTR _ePlayer$220435[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T221448[ebp], eax
	mov	ecx, DWORD PTR $T221448[ebp]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	DWORD PTR _pOtherCapital$220450[ebp], eax

; 268  : 			if(pOtherCapital)

	cmp	DWORD PTR _pOtherCapital$220450[ebp], 0
	je	SHORT $LN42@UpdateRout

; 269  : 			{
; 270  : 				vpCities.push_back(pOtherCapital);

	lea	ecx, DWORD PTR _pOtherCapital$220450[ebp]
	push	ecx
	lea	ecx, DWORD PTR _vpCities$[ebp]
	call	?push_back@?$FStaticVector@PAVCvCity@@$0EA@$00$0BCJ@$0A@@@QAEIABQAVCvCity@@@Z ; FStaticVector<CvCity *,64,1,297,0>::push_back
$LN42@UpdateRout:

; 271  : 			}
; 272  : 		}
; 273  : 	}

	jmp	$LN56@UpdateRout
$LN55@UpdateRout:

; 274  : 
; 275  : 	if(vpCities.size() > m_uiRouteInfosDimension)

	mov	edx, DWORD PTR _vpCities$[ebp+4]
	mov	DWORD PTR $T221459[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T221459[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jbe	SHORT $LN41@UpdateRout

; 276  : 	{
; 277  : 		ResizeRouteInfo((uint)((float)m_uiRouteInfosDimension * 1.5f));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR tv710[ebp], eax
	mov	DWORD PTR tv710[ebp+4], 0
	fild	QWORD PTR tv710[ebp]
	fmul	DWORD PTR __real@3fc00000
	fnstcw	WORD PTR tv713[ebp]
	movzx	eax, WORD PTR tv713[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv716[ebp], eax
	fldcw	WORD PTR tv716[ebp]
	fistp	QWORD PTR tv718[ebp]
	fldcw	WORD PTR tv713[ebp]
	mov	ecx, DWORD PTR tv718[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResizeRouteInfo@CvCityConnections@@IAEXI@Z ; CvCityConnections::ResizeRouteInfo
$LN41@UpdateRout:

; 278  : 	}
; 279  : 	ResetRouteInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetRouteInfo@CvCityConnections@@QAEXXZ ; CvCityConnections::ResetRouteInfo

; 280  : 
; 281  : 	// if the player can't build any routes, then we don't need to check this
; 282  : 	if(eBestRouteType == NO_ROUTE && !bAllowWaterRoutes)

	cmp	DWORD PTR _eBestRouteType$[ebp], -1
	jne	SHORT $LN40@UpdateRout
	movzx	edx, BYTE PTR _bAllowWaterRoutes$[ebp]
	test	edx, edx
	jne	SHORT $LN40@UpdateRout

; 283  : 	{
; 284  : 		return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _vpCities$[ebp]
	call	??1?$FStaticVector@PAVCvCity@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvCity *,64,1,297,0>::~FStaticVector<CvCity *,64,1,297,0>
	jmp	$LN58@UpdateRout
$LN40@UpdateRout:

; 285  : 	}
; 286  : 
; 287  : 	// pass 0 = can cities connect via water routes
; 288  : 	// pass 1 = can cities connect via land and water routes
; 289  : #ifdef AUI_WARNING_FIXES
; 290  : 	for (char iPass = 0; iPass < 2; iPass++)
; 291  : #else
; 292  : 	for(int iPass = 0; iPass < 2; iPass++)

	mov	DWORD PTR _iPass$220456[ebp], 0
	jmp	SHORT $LN39@UpdateRout
$LN38@UpdateRout:
	mov	eax, DWORD PTR _iPass$220456[ebp]
	add	eax, 1
	mov	DWORD PTR _iPass$220456[ebp], eax
$LN39@UpdateRout:
	cmp	DWORD PTR _iPass$220456[ebp], 2
	jge	$LN37@UpdateRout

; 293  : #endif
; 294  : 	{
; 295  : 		if(iPass == 0 && !bAllowWaterRoutes)  // if in the first pass, we can't embark, skip

	cmp	DWORD PTR _iPass$220456[ebp], 0
	jne	SHORT $LN36@UpdateRout
	movzx	ecx, BYTE PTR _bAllowWaterRoutes$[ebp]
	test	ecx, ecx
	jne	SHORT $LN36@UpdateRout
	jmp	SHORT $LN38@UpdateRout

; 296  : 		{
; 297  : 			continue;

	jmp	SHORT $LN34@UpdateRout
$LN36@UpdateRout:

; 298  : 		}
; 299  : 		else if(iPass == 1 && eBestRouteType == NO_ROUTE)  // if in the second pass, we can't build a road, skip

	cmp	DWORD PTR _iPass$220456[ebp], 1
	jne	SHORT $LN34@UpdateRout
	cmp	DWORD PTR _eBestRouteType$[ebp], -1
	jne	SHORT $LN34@UpdateRout

; 300  : 		{
; 301  : 			continue;

	jmp	SHORT $LN38@UpdateRout
$LN34@UpdateRout:

; 302  : 		}
; 303  : 
; 304  : 		CvCity* pFirstCity = NULL;

	mov	DWORD PTR _pFirstCity$220463[ebp], 0

; 305  : 		CvCity* pSecondCity = NULL;

	mov	DWORD PTR _pSecondCity$220464[ebp], 0

; 306  : 
; 307  : 		CvAStar* pkLandRouteFinder;
; 308  : 		pkLandRouteFinder = &GC.getRouteFinder();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::getRouteFinder
	mov	DWORD PTR _pkLandRouteFinder$220465[ebp], eax

; 309  : 
; 310  : 		for(uint uiFirstCityIndex = 0; uiFirstCityIndex < vpCities.size(); uiFirstCityIndex++)

	mov	DWORD PTR _uiFirstCityIndex$220466[ebp], 0
	jmp	SHORT $LN33@UpdateRout
$LN32@UpdateRout:
	mov	edx, DWORD PTR _uiFirstCityIndex$220466[ebp]
	add	edx, 1
	mov	DWORD PTR _uiFirstCityIndex$220466[ebp], edx
$LN33@UpdateRout:
	mov	eax, DWORD PTR _vpCities$[ebp+4]
	mov	DWORD PTR $T221475[ebp], eax
	mov	ecx, DWORD PTR _uiFirstCityIndex$220466[ebp]
	cmp	ecx, DWORD PTR $T221475[ebp]
	jae	$LN31@UpdateRout

; 311  : 		{
; 312  : 			pFirstCity = vpCities[uiFirstCityIndex];

	mov	edx, DWORD PTR _uiFirstCityIndex$220466[ebp]
	mov	eax, DWORD PTR _vpCities$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _pFirstCity$220463[ebp], ecx

; 313  : 			int iFirstCityArrayIndex = GetIndexFromCity(pFirstCity);

	mov	edx, DWORD PTR _pFirstCity$220463[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIndexFromCity@CvCityConnections@@QAEIPAVCvCity@@@Z ; CvCityConnections::GetIndexFromCity
	mov	DWORD PTR _iFirstCityArrayIndex$220470[ebp], eax

; 314  : 
; 315  : 			for(uint uiSecondCityIndex = 0; uiSecondCityIndex < vpCities.size(); uiSecondCityIndex++)

	mov	DWORD PTR _uiSecondCityIndex$220471[ebp], 0
	jmp	SHORT $LN30@UpdateRout
$LN29@UpdateRout:
	mov	eax, DWORD PTR _uiSecondCityIndex$220471[ebp]
	add	eax, 1
	mov	DWORD PTR _uiSecondCityIndex$220471[ebp], eax
$LN30@UpdateRout:
	mov	ecx, DWORD PTR _vpCities$[ebp+4]
	mov	DWORD PTR $T221482[ebp], ecx
	mov	edx, DWORD PTR _uiSecondCityIndex$220471[ebp]
	cmp	edx, DWORD PTR $T221482[ebp]
	jae	$LN28@UpdateRout

; 316  : 			{
; 317  : 				// same city! ignore
; 318  : 				if(uiSecondCityIndex == uiFirstCityIndex)

	mov	eax, DWORD PTR _uiSecondCityIndex$220471[ebp]
	cmp	eax, DWORD PTR _uiFirstCityIndex$220466[ebp]
	jne	SHORT $LN27@UpdateRout

; 319  : 				{
; 320  : 					continue;

	jmp	SHORT $LN29@UpdateRout
$LN27@UpdateRout:

; 321  : 				}
; 322  : 				pSecondCity = vpCities[uiSecondCityIndex];

	mov	ecx, DWORD PTR _uiSecondCityIndex$220471[ebp]
	mov	edx, DWORD PTR _vpCities$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _pSecondCity$220464[ebp], eax

; 323  : 				int iSecondCityArrayIndex = GetIndexFromCity(pSecondCity);

	mov	ecx, DWORD PTR _pSecondCity$220464[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIndexFromCity@CvCityConnections@@QAEIPAVCvCity@@@Z ; CvCityConnections::GetIndexFromCity
	mov	DWORD PTR _iSecondCityArrayIndex$220476[ebp], eax

; 324  : 
; 325  : 				RouteInfo* pRouteInfo = GetRouteInfo(iFirstCityArrayIndex, iSecondCityArrayIndex);

	mov	edx, DWORD PTR _iSecondCityArrayIndex$220476[ebp]
	push	edx
	mov	eax, DWORD PTR _iFirstCityArrayIndex$220470[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRouteInfo@CvCityConnections@@QAEPAURouteInfo@1@II@Z ; CvCityConnections::GetRouteInfo
	mov	DWORD PTR _pRouteInfo$220477[ebp], eax

; 326  : 				RouteInfo* pInverseRouteInfo = GetRouteInfo(iSecondCityArrayIndex, iFirstCityArrayIndex);

	mov	ecx, DWORD PTR _iFirstCityArrayIndex$220470[ebp]
	push	ecx
	mov	edx, DWORD PTR _iSecondCityArrayIndex$220476[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRouteInfo@CvCityConnections@@QAEPAURouteInfo@1@II@Z ; CvCityConnections::GetRouteInfo
	mov	DWORD PTR _pInverseRouteInfo$220478[ebp], eax

; 327  : 
; 328  : 				// bail if either are null
; 329  : 				if(!pRouteInfo || !pInverseRouteInfo)

	cmp	DWORD PTR _pRouteInfo$220477[ebp], 0
	je	SHORT $LN25@UpdateRout
	cmp	DWORD PTR _pInverseRouteInfo$220478[ebp], 0
	jne	SHORT $LN26@UpdateRout
$LN25@UpdateRout:

; 330  : 				{
; 331  : 					continue;

	jmp	$LN29@UpdateRout
$LN26@UpdateRout:

; 332  : 				}
; 333  : 
; 334  : 				// if the route has already been evaluated, copy the data
; 335  : 				if(pInverseRouteInfo->m_cPassEval > iPass)

	mov	eax, DWORD PTR _pInverseRouteInfo$220478[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, DWORD PTR _iPass$220456[ebp]
	jle	SHORT $LN24@UpdateRout

; 336  : 				{
; 337  : 					pRouteInfo->m_cPassEval = pInverseRouteInfo->m_cPassEval;

	mov	edx, DWORD PTR _pRouteInfo$220477[ebp]
	mov	eax, DWORD PTR _pInverseRouteInfo$220478[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR [edx+1], cl

; 338  : 					pRouteInfo->m_cRouteState = pInverseRouteInfo->m_cRouteState;

	mov	edx, DWORD PTR _pRouteInfo$220477[ebp]
	mov	eax, DWORD PTR _pInverseRouteInfo$220478[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl

; 339  : 					continue;

	jmp	$LN29@UpdateRout
$LN24@UpdateRout:

; 340  : 				}
; 341  : 
; 342  : 				// this path already has an existing route (usually water)
; 343  : 				//if(pRouteInfo->m_cRouteState & (HAS_ANY_ROUTE | HAS_BEST_ROUTE | HAS_WATER_ROUTE))
; 344  : 				//{
; 345  : 				//	continue;
; 346  : 				//}
; 347  : 
; 348  : 				pRouteInfo->m_cPassEval = iPass + 1;

	mov	edx, DWORD PTR _iPass$220456[ebp]
	add	edx, 1
	mov	eax, DWORD PTR _pRouteInfo$220477[ebp]
	mov	BYTE PTR [eax+1], dl

; 349  : 
; 350  : 				if(iPass == 0)  // check water route

	cmp	DWORD PTR _iPass$220456[ebp], 0
	jne	$LN23@UpdateRout

; 351  : 				{
; 352  : 					// if either city is blockaded, don't consider a water connection
; 353  : 					if(pFirstCity->IsBlockaded() || pSecondCity->IsBlockaded())

	mov	ecx, DWORD PTR _pFirstCity$220463[ebp]
	call	?IsBlockaded@CvCity@@QBE_NXZ		; CvCity::IsBlockaded
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN21@UpdateRout
	mov	ecx, DWORD PTR _pSecondCity$220464[ebp]
	call	?IsBlockaded@CvCity@@QBE_NXZ		; CvCity::IsBlockaded
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN22@UpdateRout
$LN21@UpdateRout:

; 354  : 					{
; 355  : 						continue;

	jmp	$LN29@UpdateRout
$LN22@UpdateRout:

; 356  : 					}
; 357  : 
; 358  : 					bool bFirstCityHasHarbor = false;

	mov	BYTE PTR _bFirstCityHasHarbor$220485[ebp], 0

; 359  : 					bool bSecondCityHasHarbor = false;

	mov	BYTE PTR _bSecondCityHasHarbor$220486[ebp], 0

; 360  : 
; 361  : 					// Loop through adding the available buildings
; 362  : 					for(int i = 0; i < (int)m_aBuildingsAllowWaterRoutes.size(); i++)

	mov	DWORD PTR _i$220487[ebp], 0
	jmp	SHORT $LN20@UpdateRout
$LN19@UpdateRout:
	mov	eax, DWORD PTR _i$220487[ebp]
	add	eax, 1
	mov	DWORD PTR _i$220487[ebp], eax
$LN20@UpdateRout:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+288]
	mov	DWORD PTR $T221489[ebp], edx
	mov	eax, DWORD PTR _i$220487[ebp]
	cmp	eax, DWORD PTR $T221489[ebp]
	jge	$LN18@UpdateRout

; 363  : 					{
; 364  : 						if(pFirstCity->GetCityBuildings()->GetNumActiveBuilding(m_aBuildingsAllowWaterRoutes[i]) > 0)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+284]
	mov	eax, DWORD PTR _i$220487[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T221493[ebp], ecx
	mov	edx, DWORD PTR $T221493[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pFirstCity$220463[ebp]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumActiveBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumActiveBuilding
	test	eax, eax
	jle	SHORT $LN17@UpdateRout

; 365  : 						{
; 366  : 							bFirstCityHasHarbor = true;

	mov	BYTE PTR _bFirstCityHasHarbor$220485[ebp], 1
$LN17@UpdateRout:

; 367  : 						}
; 368  : 
; 369  : 						if(pSecondCity->GetCityBuildings()->GetNumActiveBuilding(m_aBuildingsAllowWaterRoutes[i]) > 0)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+284]
	mov	eax, DWORD PTR _i$220487[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T221497[ebp], ecx
	mov	edx, DWORD PTR $T221497[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pSecondCity$220464[ebp]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumActiveBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumActiveBuilding
	test	eax, eax
	jle	SHORT $LN16@UpdateRout

; 370  : 						{
; 371  : 							bSecondCityHasHarbor = true;

	mov	BYTE PTR _bSecondCityHasHarbor$220486[ebp], 1
$LN16@UpdateRout:

; 372  : 						}
; 373  : 					}

	jmp	$LN19@UpdateRout
$LN18@UpdateRout:

; 374  : 
; 375  : 					if(bFirstCityHasHarbor && bSecondCityHasHarbor)

	movzx	ecx, BYTE PTR _bFirstCityHasHarbor$220485[ebp]
	test	ecx, ecx
	je	$LN14@UpdateRout
	movzx	edx, BYTE PTR _bSecondCityHasHarbor$220486[ebp]
	test	edx, edx
	je	$LN14@UpdateRout

; 376  : 					{
; 377  : 						if(GC.GetWaterRouteFinder().GeneratePath(pFirstCity->getX(), pFirstCity->getY(), pSecondCity->getX(), pSecondCity->getY(), m_pPlayer->GetID(), true))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T221506[ebp], edx
	mov	eax, DWORD PTR _pSecondCity$220464[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR $T221515[ebp], ecx
	mov	edx, DWORD PTR _pSecondCity$220464[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR $T221524[ebp], eax
	mov	ecx, DWORD PTR _pFirstCity$220463[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR $T221533[ebp], edx
	mov	eax, DWORD PTR _pFirstCity$220463[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR $T221542[ebp], ecx
	push	1
	mov	edx, DWORD PTR $T221506[ebp]
	push	edx
	mov	eax, DWORD PTR $T221515[ebp]
	push	eax
	mov	ecx, DWORD PTR $T221524[ebp]
	push	ecx
	mov	edx, DWORD PTR $T221533[ebp]
	push	edx
	mov	eax, DWORD PTR $T221542[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetWaterRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetWaterRouteFinder
	mov	ecx, eax
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN14@UpdateRout

; 378  : 						{
; 379  : 							pRouteInfo->m_cRouteState |= HAS_ANY_ROUTE | HAS_WATER_ROUTE;

	mov	edx, DWORD PTR _pRouteInfo$220477[ebp]
	movsx	eax, BYTE PTR [edx]
	or	eax, 3
	mov	ecx, DWORD PTR _pRouteInfo$220477[ebp]
	mov	BYTE PTR [ecx], al
$LN14@UpdateRout:

; 380  : 						}
; 381  : 					}
; 382  : 				}

	jmp	$LN3@UpdateRout
$LN23@UpdateRout:

; 383  : 				else if(iPass == 1)  // check land route

	cmp	DWORD PTR _iPass$220456[ebp], 1
	jne	$LN3@UpdateRout

; 384  : 				{
; 385  : 					bool bAnyRouteFound = false;

	mov	BYTE PTR _bAnyRouteFound$220498[ebp], 0

; 386  : 					bool bBestRouteFound = false;

	mov	BYTE PTR _bBestRouteFound$220499[ebp], 0

; 387  : 
; 388  : 					// assuming that there are fewer than 256 players
; 389  : 					int iRouteValue = eBestRouteType + 1;

	mov	edx, DWORD PTR _eBestRouteType$[ebp]
	add	edx, 1
	mov	DWORD PTR _iRouteValue$220500[ebp], edx

; 390  : 					int iPathfinderFlags = (iRouteValue << 8);

	mov	eax, DWORD PTR _iRouteValue$220500[ebp]
	shl	eax, 8
	mov	DWORD PTR _iPathfinderFlags$220501[ebp], eax

; 391  : 
; 392  : 					if(pkLandRouteFinder->GeneratePath(pFirstCity->getX(), pFirstCity->getY(), pSecondCity->getX(), pSecondCity->getY(), iPathfinderFlags | m_pPlayer->GetID(), true))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T221551[ebp], eax
	mov	ecx, DWORD PTR _pSecondCity$220464[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR $T221560[ebp], edx
	mov	eax, DWORD PTR _pSecondCity$220464[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR $T221569[ebp], ecx
	mov	edx, DWORD PTR _pFirstCity$220463[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR $T221578[ebp], eax
	mov	ecx, DWORD PTR _pFirstCity$220463[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR $T221587[ebp], edx
	push	1
	mov	eax, DWORD PTR _iPathfinderFlags$220501[ebp]
	or	eax, DWORD PTR $T221551[ebp]
	push	eax
	mov	ecx, DWORD PTR $T221560[ebp]
	push	ecx
	mov	edx, DWORD PTR $T221569[ebp]
	push	edx
	mov	eax, DWORD PTR $T221578[ebp]
	push	eax
	mov	ecx, DWORD PTR $T221587[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkLandRouteFinder$220465[ebp]
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN11@UpdateRout

; 393  : 					{
; 394  : 						bAnyRouteFound = true;

	mov	BYTE PTR _bAnyRouteFound$220498[ebp], 1

; 395  : 						bBestRouteFound = true;

	mov	BYTE PTR _bBestRouteFound$220499[ebp], 1
$LN11@UpdateRout:

; 396  : 					}
; 397  : 
; 398  : 					if(!bBestRouteFound)

	movzx	eax, BYTE PTR _bBestRouteFound$220499[ebp]
	test	eax, eax
	jne	$LN9@UpdateRout

; 399  : 					{
; 400  : 						if(pkLandRouteFinder->GeneratePath(pFirstCity->getX(), pFirstCity->getY(), pSecondCity->getX(), pSecondCity->getY(), MOVE_ANY_ROUTE | m_pPlayer->GetID(), true))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T221596[ebp], eax
	mov	ecx, DWORD PTR _pSecondCity$220464[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR $T221605[ebp], edx
	mov	eax, DWORD PTR _pSecondCity$220464[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR $T221614[ebp], ecx
	mov	edx, DWORD PTR _pFirstCity$220463[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR $T221623[ebp], eax
	mov	ecx, DWORD PTR _pFirstCity$220463[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR $T221632[ebp], edx
	push	1
	mov	eax, DWORD PTR $T221596[ebp]
	or	eax, -2147483648			; 80000000H
	push	eax
	mov	ecx, DWORD PTR $T221605[ebp]
	push	ecx
	mov	edx, DWORD PTR $T221614[ebp]
	push	edx
	mov	eax, DWORD PTR $T221623[ebp]
	push	eax
	mov	ecx, DWORD PTR $T221632[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkLandRouteFinder$220465[ebp]
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN9@UpdateRout

; 401  : 						{
; 402  : 							bAnyRouteFound = true;

	mov	BYTE PTR _bAnyRouteFound$220498[ebp], 1
$LN9@UpdateRout:

; 403  : 						}
; 404  : 					}
; 405  : 
; 406  : 					if(bBestRouteFound)

	movzx	eax, BYTE PTR _bBestRouteFound$220499[ebp]
	test	eax, eax
	je	SHORT $LN8@UpdateRout

; 407  : 					{
; 408  : 						pRouteInfo->m_cRouteState |= HAS_BEST_ROUTE | HAS_ANY_ROUTE;

	mov	ecx, DWORD PTR _pRouteInfo$220477[ebp]
	movsx	edx, BYTE PTR [ecx]
	or	edx, 5
	mov	eax, DWORD PTR _pRouteInfo$220477[ebp]
	mov	BYTE PTR [eax], dl
	jmp	SHORT $LN6@UpdateRout
$LN8@UpdateRout:

; 409  : 					}
; 410  : 					else if(bAnyRouteFound)

	movzx	ecx, BYTE PTR _bAnyRouteFound$220498[ebp]
	test	ecx, ecx
	je	SHORT $LN6@UpdateRout

; 411  : 					{
; 412  : 						pRouteInfo->m_cRouteState |= HAS_ANY_ROUTE;

	mov	edx, DWORD PTR _pRouteInfo$220477[ebp]
	movsx	eax, BYTE PTR [edx]
	or	eax, 1
	mov	ecx, DWORD PTR _pRouteInfo$220477[ebp]
	mov	BYTE PTR [ecx], al
$LN6@UpdateRout:

; 413  : 					}
; 414  : 
; 415  : 					// walk through the nodes for plot route info
; 416  : 					if(pFirstCity->isCapital() || pSecondCity->isCapital())

	mov	ecx, DWORD PTR _pFirstCity$220463[ebp]
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN4@UpdateRout
	mov	ecx, DWORD PTR _pSecondCity$220464[ebp]
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	movzx	eax, al
	test	eax, eax
	je	$LN3@UpdateRout
$LN4@UpdateRout:

; 417  : 					{
; 418  : 						if(bAnyRouteFound)

	movzx	ecx, BYTE PTR _bAnyRouteFound$220498[ebp]
	test	ecx, ecx
	je	$LN3@UpdateRout

; 419  : 						{
; 420  : 							CvPlot* pPlot = NULL;

	mov	DWORD PTR _pPlot$220511[ebp], 0

; 421  : 							CvAStarNode* pNode = pkLandRouteFinder->GetLastNode();

	mov	edx, DWORD PTR _pkLandRouteFinder$220465[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR _pNode$220512[ebp], eax
$LN177@UpdateRout:

; 422  : 							while(pNode)

	cmp	DWORD PTR _pNode$220512[ebp], 0
	je	$LN1@UpdateRout

; 423  : 							{
; 424  : 								pPlot = GC.getMap().plot(pNode->m_iX, pNode->m_iY);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T221639[ebp], ecx
	mov	edx, DWORD PTR _pNode$220512[ebp]
	movsx	eax, WORD PTR [edx+82]
	mov	DWORD PTR $T221742[ebp], eax
	mov	ecx, DWORD PTR _pNode$220512[ebp]
	movsx	edx, WORD PTR [ecx+80]
	mov	DWORD PTR $T221741[ebp], edx
	cmp	DWORD PTR $T221741[ebp], -2147483647	; 80000001H
	je	SHORT $LN181@UpdateRout
	cmp	DWORD PTR $T221742[ebp], -2147483647	; 80000001H
	jne	SHORT $LN182@UpdateRout
$LN181@UpdateRout:
	mov	DWORD PTR _pPlot$220511[ebp], 0
	jmp	$LN183@UpdateRout
$LN182@UpdateRout:
	mov	eax, DWORD PTR $T221639[ebp]
	mov	cl, BYTE PTR [eax+4056]
	mov	BYTE PTR $T221646[ebp], cl
	mov	edx, DWORD PTR $T221639[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T221650[ebp], eax
	movzx	ecx, BYTE PTR $T221646[ebp]
	test	ecx, ecx
	je	SHORT $LN191@UpdateRout
	cmp	DWORD PTR $T221741[ebp], 0
	jge	SHORT $LN193@UpdateRout
	mov	eax, DWORD PTR $T221741[ebp]
	cdq
	idiv	DWORD PTR $T221650[ebp]
	add	edx, DWORD PTR $T221650[ebp]
	mov	DWORD PTR _iMapX$221739[ebp], edx
	jmp	SHORT $LN195@UpdateRout
	jmp	SHORT $LN191@UpdateRout
$LN193@UpdateRout:
	mov	edx, DWORD PTR $T221741[ebp]
	cmp	edx, DWORD PTR $T221650[ebp]
	jl	SHORT $LN191@UpdateRout
	mov	eax, DWORD PTR $T221741[ebp]
	cdq
	idiv	DWORD PTR $T221650[ebp]
	mov	DWORD PTR _iMapX$221739[ebp], edx
	jmp	SHORT $LN195@UpdateRout
$LN191@UpdateRout:
	mov	eax, DWORD PTR $T221741[ebp]
	mov	DWORD PTR _iMapX$221739[ebp], eax
$LN195@UpdateRout:
	mov	ecx, DWORD PTR $T221639[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T221661[ebp], dl
	mov	eax, DWORD PTR $T221639[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T221665[ebp], ecx
	movzx	edx, BYTE PTR $T221661[ebp]
	test	edx, edx
	je	SHORT $LN201@UpdateRout
	cmp	DWORD PTR $T221742[ebp], 0
	jge	SHORT $LN203@UpdateRout
	mov	eax, DWORD PTR $T221742[ebp]
	cdq
	idiv	DWORD PTR $T221665[ebp]
	add	edx, DWORD PTR $T221665[ebp]
	mov	DWORD PTR _iMapY$221740[ebp], edx
	jmp	SHORT $LN205@UpdateRout
	jmp	SHORT $LN201@UpdateRout
$LN203@UpdateRout:
	mov	eax, DWORD PTR $T221742[ebp]
	cmp	eax, DWORD PTR $T221665[ebp]
	jl	SHORT $LN201@UpdateRout
	mov	eax, DWORD PTR $T221742[ebp]
	cdq
	idiv	DWORD PTR $T221665[ebp]
	mov	DWORD PTR _iMapY$221740[ebp], edx
	jmp	SHORT $LN205@UpdateRout
$LN201@UpdateRout:
	mov	ecx, DWORD PTR $T221742[ebp]
	mov	DWORD PTR _iMapY$221740[ebp], ecx
$LN205@UpdateRout:
	cmp	DWORD PTR _iMapX$221739[ebp], 0
	jl	SHORT $LN209@UpdateRout
	mov	edx, DWORD PTR $T221639[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T221679[ebp], eax
	mov	ecx, DWORD PTR _iMapX$221739[ebp]
	cmp	ecx, DWORD PTR $T221679[ebp]
	jge	SHORT $LN209@UpdateRout
	cmp	DWORD PTR _iMapY$221740[ebp], 0
	jl	SHORT $LN209@UpdateRout
	mov	edx, DWORD PTR $T221639[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T221683[ebp], eax
	mov	ecx, DWORD PTR _iMapY$221740[ebp]
	cmp	ecx, DWORD PTR $T221683[ebp]
	jge	SHORT $LN209@UpdateRout
	mov	DWORD PTR tv654[ebp], 1
	jmp	SHORT $LN210@UpdateRout
$LN209@UpdateRout:
	mov	DWORD PTR tv654[ebp], 0
$LN210@UpdateRout:
	cmp	DWORD PTR tv654[ebp], 0
	je	SHORT $LN185@UpdateRout
	mov	edx, DWORD PTR $T221639[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T221696[ebp], eax
	mov	ecx, DWORD PTR _iMapY$221740[ebp]
	imul	ecx, DWORD PTR $T221696[ebp]
	add	ecx, DWORD PTR _iMapX$221739[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T221639[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv607[ebp], ecx
	jmp	SHORT $LN186@UpdateRout
$LN185@UpdateRout:
	mov	DWORD PTR tv607[ebp], 0
$LN186@UpdateRout:
	mov	eax, DWORD PTR tv607[ebp]
	mov	DWORD PTR _pPlot$220511[ebp], eax
$LN183@UpdateRout:

; 425  : 								ConnectPlotRoute(pPlot);

	mov	ecx, DWORD PTR _pPlot$220511[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ConnectPlotRoute@CvCityConnections@@IAEXPAVCvPlot@@@Z ; CvCityConnections::ConnectPlotRoute

; 426  : 								pNode = pNode->m_pParent;

	mov	edx, DWORD PTR _pNode$220512[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _pNode$220512[ebp], eax

; 427  : 							}

	jmp	$LN177@UpdateRout
$LN1@UpdateRout:

; 428  : 
; 429  : 							pFirstCity->SetRouteToCapitalConnected(true);

	push	1
	mov	ecx, DWORD PTR _pFirstCity$220463[ebp]
	call	?SetRouteToCapitalConnected@CvCity@@QAEX_N@Z ; CvCity::SetRouteToCapitalConnected

; 430  : 							pSecondCity->SetRouteToCapitalConnected(true);

	push	1
	mov	ecx, DWORD PTR _pSecondCity$220464[ebp]
	call	?SetRouteToCapitalConnected@CvCity@@QAEX_N@Z ; CvCity::SetRouteToCapitalConnected
$LN3@UpdateRout:

; 431  : 						}
; 432  : 					}
; 433  : 				}
; 434  : 			}

	jmp	$LN29@UpdateRout
$LN28@UpdateRout:

; 435  : 		}

	jmp	$LN32@UpdateRout
$LN31@UpdateRout:

; 436  : 	}

	jmp	$LN38@UpdateRout
$LN37@UpdateRout:

; 437  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _vpCities$[ebp]
	call	??1?$FStaticVector@PAVCvCity@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvCity *,64,1,297,0>::~FStaticVector<CvCity *,64,1,297,0>
$LN58@UpdateRout:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?UpdateRouteInfo@CvCityConnections@@QAEXXZ$0:
	lea	ecx, DWORD PTR _vpCities$[ebp]
	jmp	??1?$FStaticVector@PAVCvCity@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvCity *,64,1,297,0>::~FStaticVector<CvCity *,64,1,297,0>
__ehhandler$?UpdateRouteInfo@CvCityConnections@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-596]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?UpdateRouteInfo@CvCityConnections@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?UpdateRouteInfo@CvCityConnections@@QAEXXZ ENDP		; CvCityConnections::UpdateRouteInfo
; Function compile flags: /Odtp
;	COMDAT ?ResetCityPlotIDs@CvCityConnections@@QAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T221799 = -8						; size = 4
_i$221794 = -4						; size = 4
?ResetCityPlotIDs@CvCityConnections@@QAEXXZ PROC	; CvCityConnections::ResetCityPlotIDs, COMDAT
; _this$ = ecx

; 441  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 442  : 	m_aiCityPlotIDs.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T221799[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN9@ResetCityP
	mov	DWORD PTR _i$221794[ebp], 0
	jmp	SHORT $LN7@ResetCityP
$LN6@ResetCityP:
	mov	edx, DWORD PTR _i$221794[ebp]
	add	edx, 1
	mov	DWORD PTR _i$221794[ebp], edx
$LN7@ResetCityP:
	mov	eax, DWORD PTR $T221799[ebp]
	mov	ecx, DWORD PTR _i$221794[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN9@ResetCityP
	jmp	SHORT $LN6@ResetCityP
$LN9@ResetCityP:
	mov	edx, DWORD PTR $T221799[ebp]
	mov	DWORD PTR [edx+4], 0

; 443  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ResetCityPlotIDs@CvCityConnections@@QAEXXZ ENDP	; CvCityConnections::ResetCityPlotIDs
_TEXT	ENDS
PUBLIC	?IsEmpty@CvCityConnections@@QAE_NXZ		; CvCityConnections::IsEmpty
; Function compile flags: /Odtp
;	COMDAT ?IsEmpty@CvCityConnections@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T221805 = -4						; size = 4
?IsEmpty@CvCityConnections@@QAE_NXZ PROC		; CvCityConnections::IsEmpty, COMDAT
; _this$ = ecx

; 447  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 448  : 	if(m_aiCityPlotIDs.size() > 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR $T221805[ebp], ecx
	cmp	DWORD PTR $T221805[ebp], 0
	jbe	SHORT $LN2@IsEmpty

; 449  : 	{
; 450  : 		return false;

	xor	al, al
	jmp	SHORT $LN3@IsEmpty

; 451  : 	}
; 452  : 	else

	jmp	SHORT $LN3@IsEmpty
$LN2@IsEmpty:

; 453  : 	{
; 454  : 		return true;

	mov	al, 1
$LN3@IsEmpty:

; 455  : 	}
; 456  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsEmpty@CvCityConnections@@QAE_NXZ ENDP		; CvCityConnections::IsEmpty
_TEXT	ENDS
PUBLIC	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ		; CvPlot::getPlotCity
; Function compile flags: /Odtp
;	COMDAT ?GetIndexFromCity@CvCityConnections@@QAEIPAVCvCity@@@Z
_TEXT	SEGMENT
tv129 = -40						; size = 4
_this$ = -36						; size = 4
$T221825 = -28						; size = 4
$T221818 = -24						; size = 4
$T221811 = -20						; size = 4
_iPlotIndex$220535 = -16				; size = 4
_pPlot$220536 = -12					; size = 4
_ui$220531 = -8						; size = 4
_pOtherCity$ = -4					; size = 4
_pCity$ = 8						; size = 4
?GetIndexFromCity@CvCityConnections@@QAEIPAVCvCity@@@Z PROC ; CvCityConnections::GetIndexFromCity, COMDAT
; _this$ = ecx

; 460  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 461  : 	CvCity* pOtherCity = NULL;

	mov	DWORD PTR _pOtherCity$[ebp], 0

; 462  : 	for(uint ui = 0; ui < m_aiCityPlotIDs.size(); ui++)

	mov	DWORD PTR _ui$220531[ebp], 0
	jmp	SHORT $LN5@GetIndexFr
$LN4@GetIndexFr:
	mov	eax, DWORD PTR _ui$220531[ebp]
	add	eax, 1
	mov	DWORD PTR _ui$220531[ebp], eax
$LN5@GetIndexFr:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR $T221811[ebp], edx
	mov	eax, DWORD PTR _ui$220531[ebp]
	cmp	eax, DWORD PTR $T221811[ebp]
	jae	SHORT $LN3@GetIndexFr

; 463  : 	{
; 464  : 		int iPlotIndex = m_aiCityPlotIDs[ui];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _ui$220531[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _iPlotIndex$220535[ebp], ecx

; 465  : 		CvPlot* pPlot = GC.getMap().plotByIndex(iPlotIndex);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T221818[ebp], edx
	cmp	DWORD PTR _iPlotIndex$220535[ebp], 0
	jl	SHORT $LN16@GetIndexFr
	mov	eax, DWORD PTR $T221818[ebp]
	mov	ecx, DWORD PTR [eax+4028]
	mov	DWORD PTR $T221825[ebp], ecx
	mov	edx, DWORD PTR _iPlotIndex$220535[ebp]
	cmp	edx, DWORD PTR $T221825[ebp]
	jge	SHORT $LN16@GetIndexFr
	mov	eax, DWORD PTR _iPlotIndex$220535[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T221818[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv129[ebp], eax
	jmp	SHORT $LN14@GetIndexFr
$LN16@GetIndexFr:
	mov	DWORD PTR tv129[ebp], 0
$LN14@GetIndexFr:
	mov	edx, DWORD PTR tv129[ebp]
	mov	DWORD PTR _pPlot$220536[ebp], edx

; 466  : 		CvAssertMsg(pPlot, "invalid plot. whut??");
; 467  : 		if(pPlot)

	cmp	DWORD PTR _pPlot$220536[ebp], 0
	je	SHORT $LN2@GetIndexFr

; 468  : 		{
; 469  : 			pOtherCity = pPlot->getPlotCity();

	mov	ecx, DWORD PTR _pPlot$220536[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pOtherCity$[ebp], eax

; 470  : 			CvAssertMsg(pOtherCity, "No city on this plot. Whut?");
; 471  : 
; 472  : 			if(pOtherCity == pCity)

	mov	eax, DWORD PTR _pOtherCity$[ebp]
	cmp	eax, DWORD PTR _pCity$[ebp]
	jne	SHORT $LN2@GetIndexFr

; 473  : 			{
; 474  : 				return ui;

	mov	eax, DWORD PTR _ui$220531[ebp]
	jmp	SHORT $LN6@GetIndexFr
$LN2@GetIndexFr:

; 475  : 			}
; 476  : 		}
; 477  : 	}

	jmp	$LN4@GetIndexFr
$LN3@GetIndexFr:

; 478  : 
; 479  : 	CvAssertMsg(false, "City not found");
; 480  : 	return UINT_MAX;

	or	eax, -1
$LN6@GetIndexFr:

; 481  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetIndexFromCity@CvCityConnections@@QAEIPAVCvCity@@@Z ENDP ; CvCityConnections::GetIndexFromCity
_TEXT	ENDS
PUBLIC	?GetCityFromIndex@CvCityConnections@@QAEPAVCvCity@@H@Z ; CvCityConnections::GetCityFromIndex
; Function compile flags: /Odtp
;	COMDAT ?GetCityFromIndex@CvCityConnections@@QAEPAVCvCity@@H@Z
_TEXT	SEGMENT
tv87 = -32						; size = 4
_this$ = -28						; size = 4
$T221852 = -20						; size = 4
$T221845 = -16						; size = 4
_iPlotIndex$ = -12					; size = 4
_pPlot$ = -8						; size = 4
_pCity$ = -4						; size = 4
_iIndex$ = 8						; size = 4
?GetCityFromIndex@CvCityConnections@@QAEPAVCvCity@@H@Z PROC ; CvCityConnections::GetCityFromIndex, COMDAT
; _this$ = ecx

; 484  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 485  : 	int iPlotIndex = m_aiCityPlotIDs[iIndex];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _iIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _iPlotIndex$[ebp], eax

; 486  : 	CvPlot* pPlot = GC.getMap().plotByIndex(iPlotIndex);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T221845[ebp], ecx
	cmp	DWORD PTR _iPlotIndex$[ebp], 0
	jl	SHORT $LN10@GetCityFro
	mov	edx, DWORD PTR $T221845[ebp]
	mov	eax, DWORD PTR [edx+4028]
	mov	DWORD PTR $T221852[ebp], eax
	mov	ecx, DWORD PTR _iPlotIndex$[ebp]
	cmp	ecx, DWORD PTR $T221852[ebp]
	jge	SHORT $LN10@GetCityFro
	mov	edx, DWORD PTR _iPlotIndex$[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T221845[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv87[ebp], edx
	jmp	SHORT $LN8@GetCityFro
$LN10@GetCityFro:
	mov	DWORD PTR tv87[ebp], 0
$LN8@GetCityFro:
	mov	ecx, DWORD PTR tv87[ebp]
	mov	DWORD PTR _pPlot$[ebp], ecx

; 487  : 	CvAssertMsg(pPlot, "invalid plot. whut??");
; 488  : 
; 489  : 	if(!pPlot) return 0;

	cmp	DWORD PTR _pPlot$[ebp], 0
	jne	SHORT $LN1@GetCityFro
	xor	eax, eax
	jmp	SHORT $LN2@GetCityFro
$LN1@GetCityFro:

; 490  : 
; 491  : 	CvCity* pCity = pPlot->getPlotCity();

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pCity$[ebp], eax

; 492  : 	CvAssertMsg(pCity, "No city on this plot. Whut?");
; 493  : 
; 494  : 	return pCity;

	mov	eax, DWORD PTR _pCity$[ebp]
$LN2@GetCityFro:

; 495  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetCityFromIndex@CvCityConnections@@QAEPAVCvCity@@H@Z ENDP ; CvCityConnections::GetCityFromIndex
_TEXT	ENDS
PUBLIC	?GetNumConnectableCities@CvCityConnections@@QAEIXZ ; CvCityConnections::GetNumConnectableCities
; Function compile flags: /Odtp
;	COMDAT ?GetNumConnectableCities@CvCityConnections@@QAEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T221869 = -4						; size = 4
?GetNumConnectableCities@CvCityConnections@@QAEIXZ PROC	; CvCityConnections::GetNumConnectableCities, COMDAT
; _this$ = ecx

; 498  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 499  : 	return m_aiCityPlotIDs.size();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR $T221869[ebp], ecx
	mov	eax, DWORD PTR $T221869[ebp]

; 500  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumConnectableCities@CvCityConnections@@QAEIXZ ENDP	; CvCityConnections::GetNumConnectableCities
_TEXT	ENDS
EXTRN	?IsWantToRouteConnectToMinor@CvDiplomacyAI@@QAE_NW4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::IsWantToRouteConnectToMinor
EXTRN	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ:PROC ; CvPlayer::GetDiplomacyAI
EXTRN	?IsActiveQuestForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4MinorCivQuestTypes@@@Z:PROC ; CvMinorCivAI::IsActiveQuestForPlayer
EXTRN	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ:PROC ; CvPlayer::GetMinorCivAI
EXTRN	?isHuman@CvPlayer@@QBE_NXZ:PROC			; CvPlayer::isHuman
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
; Function compile flags: /Odtp
;	COMDAT ?ShouldConnectToOtherPlayer@CvCityConnections@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T221936 = -52						; size = 4
$T221927 = -48						; size = 4
$T221918 = -41						; size = 1
$T221909 = -40						; size = 4
$T221897 = -36						; size = 4
$T221893 = -29						; size = 1
$T221884 = -28						; size = 4
$T221880 = -24						; size = 4
_pMinorPlayer$220567 = -20				; size = 4
_pMajorCiv$220563 = -16					; size = 4
_result$ = -9						; size = 1
_pOtherPlayer$ = -8					; size = 4
_bMajorMinor$ = -1					; size = 1
_eOtherPlayer$ = 8					; size = 4
?ShouldConnectToOtherPlayer@CvCityConnections@@QAE_NW4PlayerTypes@@@Z PROC ; CvCityConnections::ShouldConnectToOtherPlayer, COMDAT
; _this$ = ecx

; 504  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 505  : 	bool result = false;

	mov	BYTE PTR _result$[ebp], 0

; 506  : 
; 507  : 	// shouldn't be able to connect to yourself
; 508  : 	if(m_pPlayer->GetID() == eOtherPlayer)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T221880[ebp], edx
	mov	eax, DWORD PTR $T221880[ebp]
	cmp	eax, DWORD PTR _eOtherPlayer$[ebp]
	jne	SHORT $LN12@ShouldConn

; 509  : 	{
; 510  : 		return false;

	xor	al, al
	jmp	$LN13@ShouldConn
$LN12@ShouldConn:

; 511  : 	}
; 512  : 
; 513  : 	if(!GET_PLAYER(eOtherPlayer).isAlive())

	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T221884[ebp], ecx
	mov	edx, DWORD PTR $T221884[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T221893[ebp], al
	movzx	ecx, BYTE PTR $T221893[ebp]
	test	ecx, ecx
	jne	SHORT $LN11@ShouldConn

; 514  : 	{
; 515  : 		return false;

	xor	al, al
	jmp	$LN13@ShouldConn
$LN11@ShouldConn:

; 516  : 	}
; 517  : 
; 518  : 	if(GET_PLAYER(eOtherPlayer).isBarbarian())

	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T221897[ebp], edx
	mov	ecx, DWORD PTR $T221897[ebp]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN27@ShouldConn

; 519  : 	{
; 520  : 		return false;

	xor	al, al
	jmp	$LN13@ShouldConn

; 521  : 	}
; 522  : 
; 523  : 	CvPlayer* pOtherPlayer = &(GET_PLAYER(eOtherPlayer));

$LN27@ShouldConn:
	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _pOtherPlayer$[ebp], ecx

; 524  : 
; 525  : 	// only majors and minors should connect to each other at this point.
; 526  : 	bool bMajorMinor = m_pPlayer->isMinorCiv() != pOtherPlayer->isMinorCiv();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	esi, al
	mov	ecx, DWORD PTR _pOtherPlayer$[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	eax, al
	xor	ecx, ecx
	cmp	esi, eax
	setne	cl
	mov	BYTE PTR _bMajorMinor$[ebp], cl

; 527  : 	if(!bMajorMinor)

	movzx	edx, BYTE PTR _bMajorMinor$[ebp]
	test	edx, edx
	jne	SHORT $LN9@ShouldConn

; 528  : 	{
; 529  : 		return false;

	xor	al, al
	jmp	$LN13@ShouldConn
$LN9@ShouldConn:

; 530  : 	}
; 531  : 
; 532  : 	if(m_pPlayer->isMinorCiv())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN8@ShouldConn

; 533  : 	{
; 534  : 		CvPlayer* pMajorCiv = pOtherPlayer;

	mov	edx, DWORD PTR _pOtherPlayer$[ebp]
	mov	DWORD PTR _pMajorCiv$220563[ebp], edx

; 535  : 
; 536  : 		// If the major is a human, don't decide a connection to a minor is desirable on their behalf
; 537  : 		if(pMajorCiv->isHuman())

	mov	ecx, DWORD PTR _pMajorCiv$220563[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN31@ShouldConn

; 538  : 		{
; 539  : 			return false;

	xor	al, al
	jmp	$LN13@ShouldConn

; 540  : 		}
; 541  : 
; 542  : 		if(!m_pPlayer->GetMinorCivAI()->IsActiveQuestForPlayer(pMajorCiv->GetID(), MINOR_CIV_QUEST_ROUTE))

$LN31@ShouldConn:
	mov	ecx, DWORD PTR _pMajorCiv$220563[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T221909[ebp], edx
	push	0
	mov	eax, DWORD PTR $T221909[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?IsActiveQuestForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::IsActiveQuestForPlayer
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN6@ShouldConn

; 543  : 		{
; 544  : 			return false;

	xor	al, al
	jmp	$LN13@ShouldConn
$LN6@ShouldConn:

; 545  : 		}
; 546  : 
; 547  : 		result = true;

	mov	BYTE PTR _result$[ebp], 1

; 548  : 	}
; 549  : 	else // player is a major

	jmp	$LN5@ShouldConn
$LN8@ShouldConn:

; 550  : 	{
; 551  : 		CvPlayer* pMinorPlayer = pOtherPlayer;

	mov	eax, DWORD PTR _pOtherPlayer$[ebp]
	mov	DWORD PTR _pMinorPlayer$220567[ebp], eax

; 552  : 		if(!pMinorPlayer->isAlive())

	mov	ecx, DWORD PTR _pMinorPlayer$220567[ebp]
	mov	dl, BYTE PTR [ecx+2256]
	mov	BYTE PTR $T221918[ebp], dl
	movzx	eax, BYTE PTR $T221918[ebp]
	test	eax, eax
	jne	SHORT $LN4@ShouldConn

; 553  : 		{
; 554  : 			return false;

	xor	al, al
	jmp	SHORT $LN13@ShouldConn
$LN4@ShouldConn:

; 555  : 		}
; 556  : 
; 557  : 		// If the major is a human, don't decide a connection to a minor is desirable on their behalf
; 558  : 		if(m_pPlayer->isHuman())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN39@ShouldConn

; 559  : 		{
; 560  : 			return false;

	xor	al, al
	jmp	SHORT $LN13@ShouldConn

; 561  : 		}
; 562  : 
; 563  : 		if(!m_pPlayer->GetDiplomacyAI()->IsWantToRouteConnectToMinor(pMinorPlayer->GetID()))

$LN39@ShouldConn:
	mov	eax, DWORD PTR _pMinorPlayer$220567[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T221927[ebp], ecx
	mov	edx, DWORD PTR $T221927[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsWantToRouteConnectToMinor@CvDiplomacyAI@@QAE_NW4PlayerTypes@@@Z ; CvDiplomacyAI::IsWantToRouteConnectToMinor
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN43@ShouldConn

; 564  : 		{
; 565  : 			return false;

	xor	al, al
	jmp	SHORT $LN13@ShouldConn

; 566  : 		}
; 567  : 
; 568  : 		if(!pMinorPlayer->GetMinorCivAI()->IsActiveQuestForPlayer(m_pPlayer->GetID(), MINOR_CIV_QUEST_ROUTE))

$LN43@ShouldConn:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T221936[ebp], ecx
	push	0
	mov	edx, DWORD PTR $T221936[ebp]
	push	edx
	mov	ecx, DWORD PTR _pMinorPlayer$220567[ebp]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?IsActiveQuestForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::IsActiveQuestForPlayer
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@ShouldConn

; 569  : 		{
; 570  : 			return false;

	xor	al, al
	jmp	SHORT $LN13@ShouldConn
$LN1@ShouldConn:

; 571  : 		}
; 572  : 
; 573  : 		result = true;

	mov	BYTE PTR _result$[ebp], 1
$LN5@ShouldConn:

; 574  : 	}
; 575  : 
; 576  : 	return result;

	mov	al, BYTE PTR _result$[ebp]
$LN13@ShouldConn:

; 577  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?ShouldConnectToOtherPlayer@CvCityConnections@@QAE_NW4PlayerTypes@@@Z ENDP ; CvCityConnections::ShouldConnectToOtherPlayer
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?UpdatePlotRouteStates@CvCityConnections@@IAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T221942 = -8						; size = 4
_ui$220576 = -4						; size = 4
?UpdatePlotRouteStates@CvCityConnections@@IAEXXZ PROC	; CvCityConnections::UpdatePlotRouteStates, COMDAT
; _this$ = ecx

; 580  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 581  : 	for(uint ui = 0; ui < m_aPlotRouteInfos.size(); ui++)

	mov	DWORD PTR _ui$220576[ebp], 0
	jmp	SHORT $LN5@UpdatePlot
$LN4@UpdatePlot:
	mov	eax, DWORD PTR _ui$220576[ebp]
	add	eax, 1
	mov	DWORD PTR _ui$220576[ebp], eax
$LN5@UpdatePlot:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+344]
	mov	DWORD PTR $T221942[ebp], edx
	mov	eax, DWORD PTR _ui$220576[ebp]
	cmp	eax, DWORD PTR $T221942[ebp]
	jae	SHORT $LN6@UpdatePlot

; 582  : 	{
; 583  : 		if(m_aPlotRouteInfos[ui].m_bPlotRouteState & CONNECTION)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+340]
	mov	eax, DWORD PTR _ui$220576[ebp]
	movzx	ecx, BYTE PTR [edx+eax*8+4]
	and	ecx, 1
	je	SHORT $LN14@UpdatePlot

; 584  : 		{
; 585  : 			m_aPlotRouteInfos[ui].m_bPlotRouteState = CONNECTION_LAST_TURN;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+340]
	mov	ecx, DWORD PTR _ui$220576[ebp]
	mov	BYTE PTR [eax+ecx*8+4], 2

; 586  : 		}
; 587  : 		else

	jmp	SHORT $LN1@UpdatePlot

; 588  : 		{
; 589  : 			m_aPlotRouteInfos[ui].m_bPlotRouteState = NO_CONNECTION;

$LN14@UpdatePlot:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+340]
	mov	ecx, DWORD PTR _ui$220576[ebp]
	mov	BYTE PTR [eax+ecx*8+4], 0
$LN1@UpdatePlot:

; 590  : 		}

	jmp	SHORT $LN4@UpdatePlot
$LN6@UpdatePlot:

; 591  : 	}
; 592  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?UpdatePlotRouteStates@CvCityConnections@@IAEXXZ ENDP	; CvCityConnections::UpdatePlotRouteStates
_TEXT	ENDS
EXTRN	?SetTradeRoute@CvPlot@@QAEXW4PlayerTypes@@_N@Z:PROC ; CvPlot::SetTradeRoute
; Function compile flags: /Odtp
;	COMDAT ?BroadcastPlotRouteStateChanges@CvCityConnections@@IAEXXZ
_TEXT	SEGMENT
tv192 = -68						; size = 4
tv184 = -64						; size = 4
_this$ = -60						; size = 4
$T222028 = -56						; size = 4
$T222019 = -52						; size = 4
$T222012 = -48						; size = 4
$T222005 = -44						; size = 4
$T222001 = -40						; size = 4
$T221994 = -36						; size = 4
$T221985 = -32						; size = 4
$T221978 = -28						; size = 4
$T221971 = -24						; size = 4
$T221967 = -20						; size = 4
$T221957 = -16						; size = 4
_pPlot$220595 = -12					; size = 4
_pPlot$220592 = -8					; size = 4
_ui$220586 = -4						; size = 4
?BroadcastPlotRouteStateChanges@CvCityConnections@@IAEXXZ PROC ; CvCityConnections::BroadcastPlotRouteStateChanges, COMDAT
; _this$ = ecx

; 595  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 596  : 	for(uint ui = 0; ui < m_aPlotRouteInfos.size(); ui++)

	mov	DWORD PTR _ui$220586[ebp], 0
	jmp	SHORT $LN7@BroadcastP
$LN6@BroadcastP:
	mov	eax, DWORD PTR _ui$220586[ebp]
	add	eax, 1
	mov	DWORD PTR _ui$220586[ebp], eax
$LN7@BroadcastP:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+344]
	mov	DWORD PTR $T221957[ebp], edx
	mov	eax, DWORD PTR _ui$220586[ebp]
	cmp	eax, DWORD PTR $T221957[ebp]
	jae	$LN8@BroadcastP

; 597  : 	{
; 598  : 		if(m_aPlotRouteInfos[ui].m_bPlotRouteState & CONNECTION_LAST_TURN)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+340]
	mov	eax, DWORD PTR _ui$220586[ebp]
	movzx	ecx, BYTE PTR [edx+eax*8+4]
	and	ecx, 2
	je	$LN30@BroadcastP

; 599  : 		{
; 600  : 			if(!(m_aPlotRouteInfos[ui].m_bPlotRouteState & CONNECTION))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+340]
	mov	ecx, DWORD PTR _ui$220586[ebp]
	movzx	edx, BYTE PTR [eax+ecx*8+4]
	and	edx, 1
	jne	SHORT $LN3@BroadcastP

; 601  : 			{
; 602  : 				// indicate removed route
; 603  : 				CvPlot* pPlot = GC.getMap().plotByIndex(m_aPlotRouteInfos[ui].m_iPlotIndex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+340]
	mov	edx, DWORD PTR _ui$220586[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	DWORD PTR $T221967[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T221971[ebp], ecx
	mov	edx, DWORD PTR $T221967[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T221985[ebp], eax
	cmp	DWORD PTR $T221985[ebp], 0
	jl	SHORT $LN22@BroadcastP
	mov	ecx, DWORD PTR $T221971[ebp]
	mov	edx, DWORD PTR [ecx+4028]
	mov	DWORD PTR $T221978[ebp], edx
	mov	eax, DWORD PTR $T221985[ebp]
	cmp	eax, DWORD PTR $T221978[ebp]
	jge	SHORT $LN22@BroadcastP
	mov	ecx, DWORD PTR $T221985[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T221971[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv184[ebp], ecx
	jmp	SHORT $LN20@BroadcastP
$LN22@BroadcastP:
	mov	DWORD PTR tv184[ebp], 0
$LN20@BroadcastP:
	mov	eax, DWORD PTR tv184[ebp]
	mov	DWORD PTR _pPlot$220592[ebp], eax

; 604  : 				pPlot->SetTradeRoute(m_pPlayer->GetID(), false);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T221994[ebp], eax
	push	0
	mov	ecx, DWORD PTR $T221994[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlot$220592[ebp]
	call	?SetTradeRoute@CvPlot@@QAEXW4PlayerTypes@@_N@Z ; CvPlot::SetTradeRoute
$LN3@BroadcastP:

; 605  : 			}
; 606  : 		}
; 607  : 		else

	jmp	$LN2@BroadcastP

; 608  : 		{
; 609  : 			if(m_aPlotRouteInfos[ui].m_bPlotRouteState & CONNECTION)

$LN30@BroadcastP:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+340]
	mov	ecx, DWORD PTR _ui$220586[ebp]
	movzx	edx, BYTE PTR [eax+ecx*8+4]
	and	edx, 1
	je	SHORT $LN2@BroadcastP

; 610  : 			{
; 611  : 				// broadcast new connected trade route
; 612  : 				CvPlot* pPlot = GC.getMap().plotByIndex(m_aPlotRouteInfos[ui].m_iPlotIndex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+340]
	mov	edx, DWORD PTR _ui$220586[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	DWORD PTR $T222001[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T222005[ebp], ecx
	mov	edx, DWORD PTR $T222001[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T222019[ebp], eax
	cmp	DWORD PTR $T222019[ebp], 0
	jl	SHORT $LN38@BroadcastP
	mov	ecx, DWORD PTR $T222005[ebp]
	mov	edx, DWORD PTR [ecx+4028]
	mov	DWORD PTR $T222012[ebp], edx
	mov	eax, DWORD PTR $T222019[ebp]
	cmp	eax, DWORD PTR $T222012[ebp]
	jge	SHORT $LN38@BroadcastP
	mov	ecx, DWORD PTR $T222019[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T222005[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv192[ebp], ecx
	jmp	SHORT $LN36@BroadcastP
$LN38@BroadcastP:
	mov	DWORD PTR tv192[ebp], 0
$LN36@BroadcastP:
	mov	eax, DWORD PTR tv192[ebp]
	mov	DWORD PTR _pPlot$220595[ebp], eax

; 613  : 				pPlot->SetTradeRoute(m_pPlayer->GetID(), true);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T222028[ebp], eax
	push	1
	mov	ecx, DWORD PTR $T222028[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlot$220595[ebp]
	call	?SetTradeRoute@CvPlot@@QAEXW4PlayerTypes@@_N@Z ; CvPlot::SetTradeRoute
$LN2@BroadcastP:

; 614  : 			}
; 615  : 		}

	jmp	$LN6@BroadcastP
$LN8@BroadcastP:

; 616  : 	}
; 617  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?BroadcastPlotRouteStateChanges@CvCityConnections@@IAEXXZ ENDP ; CvCityConnections::BroadcastPlotRouteStateChanges
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@UPlotRouteInfo@CvCityConnections@@$0GE@$00$0BCJ@$0A@@@QAEIABUPlotRouteInfo@CvCityConnections@@@Z ; FStaticVector<CvCityConnections::PlotRouteInfo,100,1,297,0>::push_back
; Function compile flags: /Odtp
;	COMDAT ?ConnectPlotRoute@CvCityConnections@@IAEXPAVCvPlot@@@Z
_TEXT	SEGMENT
tv173 = -40						; size = 4
_this$ = -36						; size = 4
$T222044 = -28						; size = 4
$T222034 = -24						; size = 4
_info$220610 = -20					; size = 8
_ui$220602 = -12					; size = 4
_iPlotIndex$ = -8					; size = 4
_uiTargetIndex$ = -4					; size = 4
_pPlot$ = 8						; size = 4
?ConnectPlotRoute@CvCityConnections@@IAEXPAVCvPlot@@@Z PROC ; CvCityConnections::ConnectPlotRoute, COMDAT
; _this$ = ecx

; 620  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 621  : 	int iPlotIndex = pPlot->GetPlotIndex();

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?GetPlotIndex@CvPlot@@QBEHXZ		; CvPlot::GetPlotIndex
	mov	DWORD PTR _iPlotIndex$[ebp], eax

; 622  : 	uint uiTargetIndex = MAX_UNSIGNED_INT;

	mov	DWORD PTR _uiTargetIndex$[ebp], -1

; 623  : 
; 624  : 	for(uint ui = 0; ui < m_aPlotRouteInfos.size(); ui++)

	mov	DWORD PTR _ui$220602[ebp], 0
	jmp	SHORT $LN7@ConnectPlo
$LN6@ConnectPlo:
	mov	eax, DWORD PTR _ui$220602[ebp]
	add	eax, 1
	mov	DWORD PTR _ui$220602[ebp], eax
$LN7@ConnectPlo:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+344]
	mov	DWORD PTR $T222034[ebp], edx
	mov	eax, DWORD PTR _ui$220602[ebp]
	cmp	eax, DWORD PTR $T222034[ebp]
	jae	SHORT $LN5@ConnectPlo

; 625  : 	{
; 626  : 		if(m_aPlotRouteInfos[ui].m_iPlotIndex == iPlotIndex)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+340]
	mov	eax, DWORD PTR _ui$220602[ebp]
	mov	ecx, DWORD PTR [edx+eax*8]
	cmp	ecx, DWORD PTR _iPlotIndex$[ebp]
	jne	SHORT $LN4@ConnectPlo

; 627  : 		{
; 628  : 			uiTargetIndex = ui;

	mov	edx, DWORD PTR _ui$220602[ebp]
	mov	DWORD PTR _uiTargetIndex$[ebp], edx
	jmp	SHORT $LN5@ConnectPlo

; 629  : 			break;

	jmp	SHORT $LN3@ConnectPlo
$LN4@ConnectPlo:

; 630  : 		}
; 631  : 		else if(uiTargetIndex == MAX_UNSIGNED_INT && m_aPlotRouteInfos[ui].m_bPlotRouteState == NO_CONNECTION)

	cmp	DWORD PTR _uiTargetIndex$[ebp], -1
	jne	SHORT $LN3@ConnectPlo
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+340]
	mov	edx, DWORD PTR _ui$220602[ebp]
	movzx	eax, BYTE PTR [ecx+edx*8+4]
	test	eax, eax
	jne	SHORT $LN3@ConnectPlo

; 632  : 		{
; 633  : 			uiTargetIndex = ui;

	mov	ecx, DWORD PTR _ui$220602[ebp]
	mov	DWORD PTR _uiTargetIndex$[ebp], ecx
$LN3@ConnectPlo:

; 634  : 		}
; 635  : 	}

	jmp	SHORT $LN6@ConnectPlo
$LN5@ConnectPlo:

; 636  : 
; 637  : 	if(uiTargetIndex >= m_aPlotRouteInfos.size())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+344]
	mov	DWORD PTR $T222044[ebp], eax
	mov	ecx, DWORD PTR _uiTargetIndex$[ebp]
	cmp	ecx, DWORD PTR $T222044[ebp]
	jb	SHORT $LN31@ConnectPlo

; 638  : 	{
; 639  : 		uiTargetIndex = m_aPlotRouteInfos.size();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+344]
	mov	DWORD PTR _uiTargetIndex$[ebp], eax

; 640  : 		PlotRouteInfo info;

	mov	DWORD PTR _info$220610[ebp], -1
	mov	BYTE PTR _info$220610[ebp+4], 0

; 641  : 		m_aPlotRouteInfos.push_back(info);

	lea	ecx, DWORD PTR _info$220610[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 340				; 00000154H
	call	?push_back@?$FStaticVector@UPlotRouteInfo@CvCityConnections@@$0GE@$00$0BCJ@$0A@@@QAEIABUPlotRouteInfo@CvCityConnections@@@Z ; FStaticVector<CvCityConnections::PlotRouteInfo,100,1,297,0>::push_back

; 642  : 		m_aPlotRouteInfos[uiTargetIndex].m_bPlotRouteState = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+340]
	mov	ecx, DWORD PTR _uiTargetIndex$[ebp]
	mov	BYTE PTR [eax+ecx*8+4], 0

; 643  : 	}
; 644  : 
; 645  : 	m_aPlotRouteInfos[uiTargetIndex].m_iPlotIndex = iPlotIndex;

$LN31@ConnectPlo:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+340]
	mov	ecx, DWORD PTR _uiTargetIndex$[ebp]
	mov	edx, DWORD PTR _iPlotIndex$[ebp]
	mov	DWORD PTR [eax+ecx*8], edx

; 646  : 	m_aPlotRouteInfos[uiTargetIndex].m_bPlotRouteState |= CONNECTION;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+340]
	mov	edx, DWORD PTR _uiTargetIndex$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8+4]
	mov	DWORD PTR tv173[ebp], eax
	mov	ecx, DWORD PTR tv173[ebp]
	movzx	edx, BYTE PTR [ecx]
	or	edx, 1
	mov	eax, DWORD PTR tv173[ebp]
	mov	BYTE PTR [eax], dl

; 647  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ConnectPlotRoute@CvCityConnections@@IAEXPAVCvPlot@@@Z ENDP ; CvCityConnections::ConnectPlotRoute
_TEXT	ENDS
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
; Function compile flags: /Odtp
;	COMDAT ?ResizeRouteInfo@CvCityConnections@@IAEXI@Z
_TEXT	SEGMENT
tv85 = -32						; size = 4
_this$ = -28						; size = 4
$T222087 = -24						; size = 4
$T222086 = -20						; size = 4
$T222072 = -16						; size = 4
$T222071 = -12						; size = 4
$T222070 = -8						; size = 4
$T222069 = -4						; size = 4
_uiNewSize$ = 8						; size = 4
?ResizeRouteInfo@CvCityConnections@@IAEXI@Z PROC	; CvCityConnections::ResizeRouteInfo, COMDAT
; _this$ = ecx

; 650  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 	if(m_aRouteInfos)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN1@ResizeRout

; 652  : 	{
; 653  : 		delete [] m_aRouteInfos;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T222069[ebp], edx
	mov	eax, DWORD PTR $T222069[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 654  : 		m_aRouteInfos = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
$LN1@ResizeRout:

; 655  : 	}
; 656  : 
; 657  : 	m_aRouteInfos = new RouteInfo[uiNewSize * uiNewSize];

	mov	edx, DWORD PTR _uiNewSize$[ebp]
	imul	edx, DWORD PTR _uiNewSize$[ebp]
	mov	DWORD PTR $T222070[ebp], edx
	xor	ecx, ecx
	mov	eax, DWORD PTR $T222070[ebp]
	mov	edx, 2
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T222072[ebp], eax
	cmp	DWORD PTR $T222072[ebp], 0
	je	SHORT $LN4@ResizeRout
	mov	eax, DWORD PTR $T222070[ebp]
	mov	DWORD PTR $T222087[ebp], eax
	mov	ecx, DWORD PTR $T222072[ebp]
	mov	DWORD PTR $T222086[ebp], ecx
$LN8@ResizeRout:
	mov	edx, DWORD PTR $T222087[ebp]
	sub	edx, 1
	mov	DWORD PTR $T222087[ebp], edx
	js	SHORT $LN9@ResizeRout
	mov	eax, DWORD PTR $T222086[ebp]
	mov	BYTE PTR [eax], 0
	mov	ecx, DWORD PTR $T222086[ebp]
	mov	BYTE PTR [ecx+1], 0
	mov	edx, DWORD PTR $T222086[ebp]
	add	edx, 2
	mov	DWORD PTR $T222086[ebp], edx
	jmp	SHORT $LN8@ResizeRout
$LN9@ResizeRout:
	mov	eax, DWORD PTR $T222072[ebp]
	mov	DWORD PTR tv85[ebp], eax
	jmp	SHORT $LN5@ResizeRout
$LN4@ResizeRout:
	mov	DWORD PTR tv85[ebp], 0
$LN5@ResizeRout:
	mov	ecx, DWORD PTR tv85[ebp]
	mov	DWORD PTR $T222071[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T222071[ebp]
	mov	DWORD PTR [edx+8], eax

; 658  : 	CvAssertMsg(m_aRouteInfos, "m_aRouteInfo null");
; 659  : 	m_uiRouteInfosDimension = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 660  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ResizeRouteInfo@CvCityConnections@@IAEXI@Z ENDP	; CvCityConnections::ResizeRouteInfo
_TEXT	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Odtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
$LN2@vector:
	mov	eax, DWORD PTR ___n$[ebp]
	sub	eax, 1
	mov	DWORD PTR ___n$[ebp], eax
	js	SHORT $LN3@vector
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	ecx, DWORD PTR ___t$[ebp]
	add	ecx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], ecx
	jmp	SHORT $LN2@vector
$LN3@vector:
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??1?$BaseVector@H$00@@QAE@XZ			; BaseVector<int,1>::~BaseVector<int,1>
PUBLIC	??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ ; `string'
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ DB 'd:\sources\'
	DB	'lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\FF'
	DB	'astVector.h', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T222102 = -20						; size = 4
_pRet$222098 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ PROC	; FStaticVector<int,64,1,297,0>::FStaticVector<int,64,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 64			; 00000040H

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T222102[ebp], edx
	cmp	DWORD PTR $T222102[ebp], 64		; 00000040H
	jbe	SHORT $LN7@FStaticVec
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T222102[ebp]
	shl	eax, 2
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$222098[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T222102[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec
$LN7@FStaticVec:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$222098[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 64			; 00000040H
$LN8@FStaticVec:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$222098[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@H$00@@QAE@XZ		; BaseVector<int,1>::~BaseVector<int,1>
__ehhandler$??0?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ ENDP	; FStaticVector<int,64,1,297,0>::FStaticVector<int,64,1,297,0>
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T222133 = -24						; size = 4
$T222132 = -20						; size = 4
_i$222127 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ PROC	; FStaticVector<int,64,1,297,0>::~FStaticVector<int,64,1,297,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T222133[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T222132[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN5@FStaticVec@2
	xor	edx, edx
	je	SHORT $LN5@FStaticVec@2
	mov	DWORD PTR _i$222127[ebp], 0
	jmp	SHORT $LN10@FStaticVec@2
$LN9@FStaticVec@2:
	mov	eax, DWORD PTR _i$222127[ebp]
	add	eax, 1
	mov	DWORD PTR _i$222127[ebp], eax
$LN10@FStaticVec@2:
	mov	ecx, DWORD PTR _i$222127[ebp]
	cmp	ecx, DWORD PTR $T222133[ebp]
	jae	SHORT $LN5@FStaticVec@2
	jmp	SHORT $LN9@FStaticVec@2
$LN5@FStaticVec@2:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T222132[ebp], edx
	je	SHORT $LN1@FStaticVec@2
	mov	eax, DWORD PTR $T222132[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@FStaticVec@2:

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@H$00@@QAE@XZ		; BaseVector<int,1>::~BaseVector<int,1>
__ehhandler$??1?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ ENDP	; FStaticVector<int,64,1,297,0>::~FStaticVector<int,64,1,297,0>
PUBLIC	?GrowSize@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<int,64,1,297,0>::GrowSize
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAEIABH@Z
_TEXT	SEGMENT
tv140 = -52						; size = 4
tv131 = -48						; size = 4
_this$ = -44						; size = 4
$T222145 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAEIABH@Z PROC ; FStaticVector<int,64,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+268], 0

; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN35@push_back

; 679  : 			GrowSize(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<int,64,1,297,0>::GrowSize

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN35@push_back:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T222145[ebp], ecx
	cmp	DWORD PTR $T222145[ebp], 0
	je	SHORT $LN4@push_back
	mov	edx, DWORD PTR $T222145[ebp]
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T222145[ebp]
	mov	DWORD PTR tv131[ebp], edx
	jmp	SHORT $LN5@push_back
$LN4@push_back:
	mov	DWORD PTR tv131[ebp], 0
$LN5@push_back:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv140[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR tv140[ebp]

; 682  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAEIABH@Z ENDP ; FStaticVector<int,64,1,297,0>::push_back
_TEXT	ENDS
PUBLIC	??1?$BaseVector@W4BuildingTypes@@$00@@QAE@XZ	; BaseVector<enum BuildingTypes,1>::~BaseVector<enum BuildingTypes,1>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@W4BuildingTypes@@$09$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@W4BuildingTypes@@$09$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@W4BuildingTypes@@$09$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@W4BuildingTypes@@$09$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@W4BuildingTypes@@$09$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T222199 = -20						; size = 4
_pRet$222195 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@W4BuildingTypes@@$09$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<enum BuildingTypes,10,1,297,0>::FStaticVector<enum BuildingTypes,10,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@W4BuildingTypes@@$09$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 10			; 0000000aH

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T222199[ebp], edx
	cmp	DWORD PTR $T222199[ebp], 10		; 0000000aH
	jbe	SHORT $LN7@FStaticVec@3
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T222199[ebp]
	shl	eax, 2
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$222195[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T222199[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec@3
$LN7@FStaticVec@3:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$222195[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 10			; 0000000aH
$LN8@FStaticVec@3:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$222195[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@W4BuildingTypes@@$09$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@W4BuildingTypes@@$00@@QAE@XZ ; BaseVector<enum BuildingTypes,1>::~BaseVector<enum BuildingTypes,1>
__ehhandler$??0?$FStaticVector@W4BuildingTypes@@$09$00$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@W4BuildingTypes@@$09$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@W4BuildingTypes@@$09$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<enum BuildingTypes,10,1,297,0>::FStaticVector<enum BuildingTypes,10,1,297,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@W4BuildingTypes@@$09$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@W4BuildingTypes@@$09$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@W4BuildingTypes@@$09$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@W4BuildingTypes@@$09$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@W4BuildingTypes@@$09$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T222230 = -24						; size = 4
$T222229 = -20						; size = 4
_i$222222 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@W4BuildingTypes@@$09$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<enum BuildingTypes,10,1,297,0>::~FStaticVector<enum BuildingTypes,10,1,297,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@W4BuildingTypes@@$09$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T222230[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T222229[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN5@FStaticVec@4
	xor	edx, edx
	je	SHORT $LN5@FStaticVec@4
	mov	DWORD PTR _i$222222[ebp], 0
	jmp	SHORT $LN10@FStaticVec@4
$LN9@FStaticVec@4:
	mov	eax, DWORD PTR _i$222222[ebp]
	add	eax, 1
	mov	DWORD PTR _i$222222[ebp], eax
$LN10@FStaticVec@4:
	mov	ecx, DWORD PTR _i$222222[ebp]
	cmp	ecx, DWORD PTR $T222230[ebp]
	jae	SHORT $LN5@FStaticVec@4
	jmp	SHORT $LN9@FStaticVec@4
$LN5@FStaticVec@4:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T222229[ebp], edx
	je	SHORT $LN1@FStaticVec@4
	mov	eax, DWORD PTR $T222229[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@FStaticVec@4:

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@W4BuildingTypes@@$09$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@W4BuildingTypes@@$00@@QAE@XZ ; BaseVector<enum BuildingTypes,1>::~BaseVector<enum BuildingTypes,1>
__ehhandler$??1?$FStaticVector@W4BuildingTypes@@$09$00$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@W4BuildingTypes@@$09$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@W4BuildingTypes@@$09$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<enum BuildingTypes,10,1,297,0>::~FStaticVector<enum BuildingTypes,10,1,297,0>
PUBLIC	?GrowSize@?$FStaticVector@W4BuildingTypes@@$09$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<enum BuildingTypes,10,1,297,0>::GrowSize
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$FStaticVector@W4BuildingTypes@@$09$00$0BCJ@$0A@@@QAEIABW4BuildingTypes@@@Z
_TEXT	SEGMENT
tv140 = -52						; size = 4
tv131 = -48						; size = 4
_this$ = -44						; size = 4
$T222242 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FStaticVector@W4BuildingTypes@@$09$00$0BCJ@$0A@@@QAEIABW4BuildingTypes@@@Z PROC ; FStaticVector<enum BuildingTypes,10,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+52], 0

; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN35@push_back@2

; 679  : 			GrowSize(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@W4BuildingTypes@@$09$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<enum BuildingTypes,10,1,297,0>::GrowSize

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN35@push_back@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T222242[ebp], ecx
	cmp	DWORD PTR $T222242[ebp], 0
	je	SHORT $LN4@push_back@2
	mov	edx, DWORD PTR $T222242[ebp]
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T222242[ebp]
	mov	DWORD PTR tv131[ebp], edx
	jmp	SHORT $LN5@push_back@2
$LN4@push_back@2:
	mov	DWORD PTR tv131[ebp], 0
$LN5@push_back@2:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv140[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR tv140[ebp]

; 682  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FStaticVector@W4BuildingTypes@@$09$00$0BCJ@$0A@@@QAEIABW4BuildingTypes@@@Z ENDP ; FStaticVector<enum BuildingTypes,10,1,297,0>::push_back
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UPlotRouteInfo@CvCityConnections@@$00@@QAE@XZ ; BaseVector<CvCityConnections::PlotRouteInfo,1>::~BaseVector<CvCityConnections::PlotRouteInfo,1>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@UPlotRouteInfo@CvCityConnections@@$0GE@$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@UPlotRouteInfo@CvCityConnections@@$0GE@$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@UPlotRouteInfo@CvCityConnections@@$0GE@$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@UPlotRouteInfo@CvCityConnections@@$0GE@$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@UPlotRouteInfo@CvCityConnections@@$0GE@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T222296 = -20						; size = 4
_pRet$222293 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@UPlotRouteInfo@CvCityConnections@@$0GE@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvCityConnections::PlotRouteInfo,100,1,297,0>::FStaticVector<CvCityConnections::PlotRouteInfo,100,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@UPlotRouteInfo@CvCityConnections@@$0GE@$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 100			; 00000064H

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T222296[ebp], edx
	cmp	DWORD PTR $T222296[ebp], 100		; 00000064H
	jbe	SHORT $LN7@FStaticVec@5
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T222296[ebp]
	shl	eax, 3
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$222293[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T222296[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec@5
$LN7@FStaticVec@5:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$222293[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 100			; 00000064H
$LN8@FStaticVec@5:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$222293[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@UPlotRouteInfo@CvCityConnections@@$0GE@$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UPlotRouteInfo@CvCityConnections@@$00@@QAE@XZ ; BaseVector<CvCityConnections::PlotRouteInfo,1>::~BaseVector<CvCityConnections::PlotRouteInfo,1>
__ehhandler$??0?$FStaticVector@UPlotRouteInfo@CvCityConnections@@$0GE@$00$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@UPlotRouteInfo@CvCityConnections@@$0GE@$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@UPlotRouteInfo@CvCityConnections@@$0GE@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvCityConnections::PlotRouteInfo,100,1,297,0>::FStaticVector<CvCityConnections::PlotRouteInfo,100,1,297,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@UPlotRouteInfo@CvCityConnections@@$0GE@$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@UPlotRouteInfo@CvCityConnections@@$0GE@$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@UPlotRouteInfo@CvCityConnections@@$0GE@$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@UPlotRouteInfo@CvCityConnections@@$0GE@$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@UPlotRouteInfo@CvCityConnections@@$0GE@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T222327 = -24						; size = 4
$T222326 = -20						; size = 4
_i$222319 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@UPlotRouteInfo@CvCityConnections@@$0GE@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvCityConnections::PlotRouteInfo,100,1,297,0>::~FStaticVector<CvCityConnections::PlotRouteInfo,100,1,297,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@UPlotRouteInfo@CvCityConnections@@$0GE@$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T222327[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T222326[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN5@FStaticVec@6
	xor	edx, edx
	je	SHORT $LN5@FStaticVec@6
	mov	DWORD PTR _i$222319[ebp], 0
	jmp	SHORT $LN10@FStaticVec@6
$LN9@FStaticVec@6:
	mov	eax, DWORD PTR _i$222319[ebp]
	add	eax, 1
	mov	DWORD PTR _i$222319[ebp], eax
$LN10@FStaticVec@6:
	mov	ecx, DWORD PTR _i$222319[ebp]
	cmp	ecx, DWORD PTR $T222327[ebp]
	jae	SHORT $LN5@FStaticVec@6
	jmp	SHORT $LN9@FStaticVec@6
$LN5@FStaticVec@6:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T222326[ebp], edx
	je	SHORT $LN1@FStaticVec@6
	mov	eax, DWORD PTR $T222326[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@FStaticVec@6:

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@UPlotRouteInfo@CvCityConnections@@$0GE@$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UPlotRouteInfo@CvCityConnections@@$00@@QAE@XZ ; BaseVector<CvCityConnections::PlotRouteInfo,1>::~BaseVector<CvCityConnections::PlotRouteInfo,1>
__ehhandler$??1?$FStaticVector@UPlotRouteInfo@CvCityConnections@@$0GE@$00$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@UPlotRouteInfo@CvCityConnections@@$0GE@$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@UPlotRouteInfo@CvCityConnections@@$0GE@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvCityConnections::PlotRouteInfo,100,1,297,0>::~FStaticVector<CvCityConnections::PlotRouteInfo,100,1,297,0>
PUBLIC	?GrowSize@?$FStaticVector@UPlotRouteInfo@CvCityConnections@@$0GE@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvCityConnections::PlotRouteInfo,100,1,297,0>::GrowSize
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$FStaticVector@UPlotRouteInfo@CvCityConnections@@$0GE@$00$0BCJ@$0A@@@QAEIABUPlotRouteInfo@CvCityConnections@@@Z
_TEXT	SEGMENT
tv141 = -52						; size = 4
tv132 = -48						; size = 4
_this$ = -44						; size = 4
$T222339 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UPlotRouteInfo@CvCityConnections@@$0GE@$00$0BCJ@$0A@@@QAEIABUPlotRouteInfo@CvCityConnections@@@Z PROC ; FStaticVector<CvCityConnections::PlotRouteInfo,100,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+812], 0

; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN35@push_back@3

; 679  : 			GrowSize(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@UPlotRouteInfo@CvCityConnections@@$0GE@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvCityConnections::PlotRouteInfo,100,1,297,0>::GrowSize

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN35@push_back@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T222339[ebp], ecx
	cmp	DWORD PTR $T222339[ebp], 0
	je	SHORT $LN4@push_back@3
	mov	edx, DWORD PTR _element$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T222339[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T222339[ebp]
	mov	DWORD PTR tv132[ebp], eax
	jmp	SHORT $LN5@push_back@3
$LN4@push_back@3:
	mov	DWORD PTR tv132[ebp], 0
$LN5@push_back@3:

; 681  : 		return m_uiCurrSize++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv141[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR tv141[ebp]

; 682  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FStaticVector@UPlotRouteInfo@CvCityConnections@@$0GE@$00$0BCJ@$0A@@@QAEIABUPlotRouteInfo@CvCityConnections@@@Z ENDP ; FStaticVector<CvCityConnections::PlotRouteInfo,100,1,297,0>::push_back
_TEXT	ENDS
PUBLIC	??1?$BaseVector@PAVCvCity@@$00@@QAE@XZ		; BaseVector<CvCity *,1>::~BaseVector<CvCity *,1>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@PAVCvCity@@$0EA@$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@PAVCvCity@@$0EA@$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@PAVCvCity@@$0EA@$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@PAVCvCity@@$0EA@$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@PAVCvCity@@$0EA@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T222393 = -20						; size = 4
_pRet$222390 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@PAVCvCity@@$0EA@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvCity *,64,1,297,0>::FStaticVector<CvCity *,64,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@PAVCvCity@@$0EA@$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 64			; 00000040H

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T222393[ebp], edx
	cmp	DWORD PTR $T222393[ebp], 64		; 00000040H
	jbe	SHORT $LN7@FStaticVec@7
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T222393[ebp]
	shl	eax, 2
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$222390[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T222393[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec@7
$LN7@FStaticVec@7:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$222390[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 64			; 00000040H
$LN8@FStaticVec@7:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$222390[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@PAVCvCity@@$0EA@$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@PAVCvCity@@$00@@QAE@XZ	; BaseVector<CvCity *,1>::~BaseVector<CvCity *,1>
__ehhandler$??0?$FStaticVector@PAVCvCity@@$0EA@$00$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@PAVCvCity@@$0EA@$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@PAVCvCity@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvCity *,64,1,297,0>::FStaticVector<CvCity *,64,1,297,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@PAVCvCity@@$0EA@$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@PAVCvCity@@$0EA@$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@PAVCvCity@@$0EA@$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@PAVCvCity@@$0EA@$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@PAVCvCity@@$0EA@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T222424 = -24						; size = 4
$T222423 = -20						; size = 4
_i$222416 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@PAVCvCity@@$0EA@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvCity *,64,1,297,0>::~FStaticVector<CvCity *,64,1,297,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@PAVCvCity@@$0EA@$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T222424[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T222423[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN5@FStaticVec@8
	xor	edx, edx
	je	SHORT $LN5@FStaticVec@8
	mov	DWORD PTR _i$222416[ebp], 0
	jmp	SHORT $LN10@FStaticVec@8
$LN9@FStaticVec@8:
	mov	eax, DWORD PTR _i$222416[ebp]
	add	eax, 1
	mov	DWORD PTR _i$222416[ebp], eax
$LN10@FStaticVec@8:
	mov	ecx, DWORD PTR _i$222416[ebp]
	cmp	ecx, DWORD PTR $T222424[ebp]
	jae	SHORT $LN5@FStaticVec@8
	jmp	SHORT $LN9@FStaticVec@8
$LN5@FStaticVec@8:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T222423[ebp], edx
	je	SHORT $LN1@FStaticVec@8
	mov	eax, DWORD PTR $T222423[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@FStaticVec@8:

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@PAVCvCity@@$0EA@$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@PAVCvCity@@$00@@QAE@XZ	; BaseVector<CvCity *,1>::~BaseVector<CvCity *,1>
__ehhandler$??1?$FStaticVector@PAVCvCity@@$0EA@$00$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@PAVCvCity@@$0EA@$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@PAVCvCity@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvCity *,64,1,297,0>::~FStaticVector<CvCity *,64,1,297,0>
PUBLIC	?GrowSize@?$FStaticVector@PAVCvCity@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvCity *,64,1,297,0>::GrowSize
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$FStaticVector@PAVCvCity@@$0EA@$00$0BCJ@$0A@@@QAEIABQAVCvCity@@@Z
_TEXT	SEGMENT
tv140 = -52						; size = 4
tv131 = -48						; size = 4
_this$ = -44						; size = 4
$T222436 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FStaticVector@PAVCvCity@@$0EA@$00$0BCJ@$0A@@@QAEIABQAVCvCity@@@Z PROC ; FStaticVector<CvCity *,64,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+268], 0

; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN35@push_back@4

; 679  : 			GrowSize(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@PAVCvCity@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvCity *,64,1,297,0>::GrowSize

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN35@push_back@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T222436[ebp], ecx
	cmp	DWORD PTR $T222436[ebp], 0
	je	SHORT $LN4@push_back@4
	mov	edx, DWORD PTR $T222436[ebp]
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T222436[ebp]
	mov	DWORD PTR tv131[ebp], edx
	jmp	SHORT $LN5@push_back@4
$LN4@push_back@4:
	mov	DWORD PTR tv131[ebp], 0
$LN5@push_back@4:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv140[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR tv140[ebp]

; 682  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FStaticVector@PAVCvCity@@$0EA@$00$0BCJ@$0A@@@QAEIABQAVCvCity@@@Z ENDP ; FStaticVector<CvCity *,64,1,297,0>::push_back
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@H$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@H$00@@QAE@XZ PROC			; BaseVector<int,1>::~BaseVector<int,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@H$00@@QAE@XZ ENDP			; BaseVector<int,1>::~BaseVector<int,1>
_TEXT	ENDS
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp
;	COMDAT ?GrowSize@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv178 = -44						; size = 4
_this$ = -40						; size = 4
$T222516 = -36						; size = 4
$T222515 = -32						; size = 4
_i$222508 = -28						; size = 4
$T222491 = -24						; size = 4
_pRet$222488 = -20					; size = 4
$T222482 = -16						; size = 4
_i$220723 = -12						; size = 4
_uiNewSize$220715 = -8					; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<int,64,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@GrowSize
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jb	SHORT $LN7@GrowSize

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	DWORD PTR _uiNewSize$220715[ebp], edx

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$220715[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN6@GrowSize

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 754  : 				break;

	jmp	SHORT $LN7@GrowSize
$LN6@GrowSize:

; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$220715[ebp]
	mov	DWORD PTR [ecx+8], edx

; 759  : 		}

	jmp	SHORT $LN8@GrowSize
$LN7@GrowSize:

; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T222491[ebp], ecx
	cmp	DWORD PTR $T222491[ebp], 64		; 00000040H
	jbe	SHORT $LN15@GrowSize
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T222491[ebp]
	shl	edx, 2
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$222488[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T222491[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN16@GrowSize
$LN15@GrowSize:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$222488[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 64			; 00000040H
$LN16@GrowSize:
	mov	ecx, DWORD PTR _pRet$222488[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 762  : 		if( bPODType ){

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@GrowSize

; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 764  : 		}else{

	jmp	SHORT $LN4@GrowSize
$LN5@GrowSize:

; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$220723[ebp], 0
	jmp	SHORT $LN3@GrowSize
$LN2@GrowSize:
	mov	edx, DWORD PTR _i$220723[ebp]
	add	edx, 1
	mov	DWORD PTR _i$220723[ebp], edx
$LN3@GrowSize:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$220723[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN4@GrowSize

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$220723[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T222482[ebp], ecx
	cmp	DWORD PTR $T222482[ebp], 0
	je	SHORT $LN12@GrowSize
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T222482[ebp]
	mov	edx, DWORD PTR _i$220723[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T222482[ebp]
	mov	DWORD PTR tv178[ebp], ecx
	jmp	SHORT $LN13@GrowSize
$LN12@GrowSize:
	mov	DWORD PTR tv178[ebp], 0
$LN13@GrowSize:
	jmp	SHORT $LN2@GrowSize
$LN4@GrowSize:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T222516[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T222515[ebp], edx
	xor	eax, eax
	je	SHORT $LN21@GrowSize
	xor	ecx, ecx
	je	SHORT $LN21@GrowSize
	mov	DWORD PTR _i$222508[ebp], 0
	jmp	SHORT $LN26@GrowSize
$LN25@GrowSize:
	mov	edx, DWORD PTR _i$222508[ebp]
	add	edx, 1
	mov	DWORD PTR _i$222508[ebp], edx
$LN26@GrowSize:
	mov	eax, DWORD PTR _i$222508[ebp]
	cmp	eax, DWORD PTR $T222516[ebp]
	jae	SHORT $LN21@GrowSize
	jmp	SHORT $LN25@GrowSize
$LN21@GrowSize:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	cmp	DWORD PTR $T222515[ebp], ecx
	je	SHORT $LN22@GrowSize
	mov	edx, DWORD PTR $T222515[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN22@GrowSize:

; 769  : 		m_pData = pTemp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], ecx

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+268], 1

; 772  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<int,64,1,297,0>::GrowSize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GrowSize@?$FStaticVector@W4BuildingTypes@@$09$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv178 = -44						; size = 4
_this$ = -40						; size = 4
$T222554 = -36						; size = 4
$T222553 = -32						; size = 4
_i$222546 = -28						; size = 4
$T222529 = -24						; size = 4
_pRet$222526 = -20					; size = 4
$T222520 = -16						; size = 4
_i$220759 = -12						; size = 4
_uiNewSize$220751 = -8					; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@W4BuildingTypes@@$09$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<enum BuildingTypes,10,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@GrowSize@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@GrowSize@2:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jb	SHORT $LN7@GrowSize@2

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	DWORD PTR _uiNewSize$220751[ebp], edx

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$220751[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN6@GrowSize@2

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 754  : 				break;

	jmp	SHORT $LN7@GrowSize@2
$LN6@GrowSize@2:

; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$220751[ebp]
	mov	DWORD PTR [ecx+8], edx

; 759  : 		}

	jmp	SHORT $LN8@GrowSize@2
$LN7@GrowSize@2:

; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T222529[ebp], ecx
	cmp	DWORD PTR $T222529[ebp], 10		; 0000000aH
	jbe	SHORT $LN15@GrowSize@2
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T222529[ebp]
	shl	edx, 2
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$222526[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T222529[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN16@GrowSize@2
$LN15@GrowSize@2:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$222526[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 10			; 0000000aH
$LN16@GrowSize@2:
	mov	ecx, DWORD PTR _pRet$222526[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 762  : 		if( bPODType ){

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@GrowSize@2

; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 764  : 		}else{

	jmp	SHORT $LN4@GrowSize@2
$LN5@GrowSize@2:

; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$220759[ebp], 0
	jmp	SHORT $LN3@GrowSize@2
$LN2@GrowSize@2:
	mov	edx, DWORD PTR _i$220759[ebp]
	add	edx, 1
	mov	DWORD PTR _i$220759[ebp], edx
$LN3@GrowSize@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$220759[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN4@GrowSize@2

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$220759[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T222520[ebp], ecx
	cmp	DWORD PTR $T222520[ebp], 0
	je	SHORT $LN12@GrowSize@2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T222520[ebp]
	mov	edx, DWORD PTR _i$220759[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T222520[ebp]
	mov	DWORD PTR tv178[ebp], ecx
	jmp	SHORT $LN13@GrowSize@2
$LN12@GrowSize@2:
	mov	DWORD PTR tv178[ebp], 0
$LN13@GrowSize@2:
	jmp	SHORT $LN2@GrowSize@2
$LN4@GrowSize@2:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T222554[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T222553[ebp], edx
	xor	eax, eax
	je	SHORT $LN21@GrowSize@2
	xor	ecx, ecx
	je	SHORT $LN21@GrowSize@2
	mov	DWORD PTR _i$222546[ebp], 0
	jmp	SHORT $LN26@GrowSize@2
$LN25@GrowSize@2:
	mov	edx, DWORD PTR _i$222546[ebp]
	add	edx, 1
	mov	DWORD PTR _i$222546[ebp], edx
$LN26@GrowSize@2:
	mov	eax, DWORD PTR _i$222546[ebp]
	cmp	eax, DWORD PTR $T222554[ebp]
	jae	SHORT $LN21@GrowSize@2
	jmp	SHORT $LN25@GrowSize@2
$LN21@GrowSize@2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	cmp	DWORD PTR $T222553[ebp], ecx
	je	SHORT $LN22@GrowSize@2
	mov	edx, DWORD PTR $T222553[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN22@GrowSize@2:

; 769  : 		m_pData = pTemp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], ecx

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+52], 1

; 772  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FStaticVector@W4BuildingTypes@@$09$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<enum BuildingTypes,10,1,297,0>::GrowSize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@W4BuildingTypes@@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@W4BuildingTypes@@$00@@QAE@XZ PROC	; BaseVector<enum BuildingTypes,1>::~BaseVector<enum BuildingTypes,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@W4BuildingTypes@@$00@@QAE@XZ ENDP	; BaseVector<enum BuildingTypes,1>::~BaseVector<enum BuildingTypes,1>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GrowSize@?$FStaticVector@UPlotRouteInfo@CvCityConnections@@$0GE@$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv179 = -44						; size = 4
_this$ = -40						; size = 4
$T222593 = -36						; size = 4
$T222592 = -32						; size = 4
_i$222585 = -28						; size = 4
$T222568 = -24						; size = 4
_pRet$222565 = -20					; size = 4
$T222559 = -16						; size = 4
_i$220806 = -12						; size = 4
_uiNewSize$220798 = -8					; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UPlotRouteInfo@CvCityConnections@@$0GE@$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<CvCityConnections::PlotRouteInfo,100,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@GrowSize@3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@GrowSize@3:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jb	SHORT $LN7@GrowSize@3

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	DWORD PTR _uiNewSize$220798[ebp], edx

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$220798[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN6@GrowSize@3

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 754  : 				break;

	jmp	SHORT $LN7@GrowSize@3
$LN6@GrowSize@3:

; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$220798[ebp]
	mov	DWORD PTR [ecx+8], edx

; 759  : 		}

	jmp	SHORT $LN8@GrowSize@3
$LN7@GrowSize@3:

; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T222568[ebp], ecx
	cmp	DWORD PTR $T222568[ebp], 100		; 00000064H
	jbe	SHORT $LN15@GrowSize@3
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T222568[ebp]
	shl	edx, 3
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$222565[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T222568[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN16@GrowSize@3
$LN15@GrowSize@3:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$222565[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 100			; 00000064H
$LN16@GrowSize@3:
	mov	ecx, DWORD PTR _pRet$222565[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 762  : 		if( bPODType ){

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@GrowSize@3

; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 764  : 		}else{

	jmp	SHORT $LN4@GrowSize@3
$LN5@GrowSize@3:

; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$220806[ebp], 0
	jmp	SHORT $LN3@GrowSize@3
$LN2@GrowSize@3:
	mov	edx, DWORD PTR _i$220806[ebp]
	add	edx, 1
	mov	DWORD PTR _i$220806[ebp], edx
$LN3@GrowSize@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$220806[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN4@GrowSize@3

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$220806[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T222559[ebp], ecx
	cmp	DWORD PTR $T222559[ebp], 0
	je	SHORT $LN12@GrowSize@3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _i$220806[ebp]
	mov	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR [eax+ecx*8+4]
	mov	ecx, DWORD PTR $T222559[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T222559[ebp]
	mov	DWORD PTR tv179[ebp], edx
	jmp	SHORT $LN13@GrowSize@3
$LN12@GrowSize@3:
	mov	DWORD PTR tv179[ebp], 0
$LN13@GrowSize@3:
	jmp	SHORT $LN2@GrowSize@3
$LN4@GrowSize@3:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T222593[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T222592[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN21@GrowSize@3
	xor	edx, edx
	je	SHORT $LN21@GrowSize@3
	mov	DWORD PTR _i$222585[ebp], 0
	jmp	SHORT $LN26@GrowSize@3
$LN25@GrowSize@3:
	mov	eax, DWORD PTR _i$222585[ebp]
	add	eax, 1
	mov	DWORD PTR _i$222585[ebp], eax
$LN26@GrowSize@3:
	mov	ecx, DWORD PTR _i$222585[ebp]
	cmp	ecx, DWORD PTR $T222593[ebp]
	jae	SHORT $LN21@GrowSize@3
	jmp	SHORT $LN25@GrowSize@3
$LN21@GrowSize@3:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T222592[ebp], edx
	je	SHORT $LN22@GrowSize@3
	mov	eax, DWORD PTR $T222592[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN22@GrowSize@3:

; 769  : 		m_pData = pTemp;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx], edx

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+812], 1

; 772  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FStaticVector@UPlotRouteInfo@CvCityConnections@@$0GE@$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvCityConnections::PlotRouteInfo,100,1,297,0>::GrowSize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@UPlotRouteInfo@CvCityConnections@@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@UPlotRouteInfo@CvCityConnections@@$00@@QAE@XZ PROC ; BaseVector<CvCityConnections::PlotRouteInfo,1>::~BaseVector<CvCityConnections::PlotRouteInfo,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@UPlotRouteInfo@CvCityConnections@@$00@@QAE@XZ ENDP ; BaseVector<CvCityConnections::PlotRouteInfo,1>::~BaseVector<CvCityConnections::PlotRouteInfo,1>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GrowSize@?$FStaticVector@PAVCvCity@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv178 = -44						; size = 4
_this$ = -40						; size = 4
$T222632 = -36						; size = 4
$T222631 = -32						; size = 4
_i$222624 = -28						; size = 4
$T222607 = -24						; size = 4
_pRet$222604 = -20					; size = 4
$T222598 = -16						; size = 4
_i$220853 = -12						; size = 4
_uiNewSize$220845 = -8					; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@PAVCvCity@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<CvCity *,64,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@GrowSize@4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@GrowSize@4:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jb	SHORT $LN7@GrowSize@4

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	DWORD PTR _uiNewSize$220845[ebp], edx

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$220845[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN6@GrowSize@4

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 754  : 				break;

	jmp	SHORT $LN7@GrowSize@4
$LN6@GrowSize@4:

; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$220845[ebp]
	mov	DWORD PTR [ecx+8], edx

; 759  : 		}

	jmp	SHORT $LN8@GrowSize@4
$LN7@GrowSize@4:

; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T222607[ebp], ecx
	cmp	DWORD PTR $T222607[ebp], 64		; 00000040H
	jbe	SHORT $LN15@GrowSize@4
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T222607[ebp]
	shl	edx, 2
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$222604[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T222607[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN16@GrowSize@4
$LN15@GrowSize@4:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$222604[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 64			; 00000040H
$LN16@GrowSize@4:
	mov	ecx, DWORD PTR _pRet$222604[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 762  : 		if( bPODType ){

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@GrowSize@4

; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 764  : 		}else{

	jmp	SHORT $LN4@GrowSize@4
$LN5@GrowSize@4:

; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$220853[ebp], 0
	jmp	SHORT $LN3@GrowSize@4
$LN2@GrowSize@4:
	mov	edx, DWORD PTR _i$220853[ebp]
	add	edx, 1
	mov	DWORD PTR _i$220853[ebp], edx
$LN3@GrowSize@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$220853[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN4@GrowSize@4

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$220853[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T222598[ebp], ecx
	cmp	DWORD PTR $T222598[ebp], 0
	je	SHORT $LN12@GrowSize@4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T222598[ebp]
	mov	edx, DWORD PTR _i$220853[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T222598[ebp]
	mov	DWORD PTR tv178[ebp], ecx
	jmp	SHORT $LN13@GrowSize@4
$LN12@GrowSize@4:
	mov	DWORD PTR tv178[ebp], 0
$LN13@GrowSize@4:
	jmp	SHORT $LN2@GrowSize@4
$LN4@GrowSize@4:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T222632[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T222631[ebp], edx
	xor	eax, eax
	je	SHORT $LN21@GrowSize@4
	xor	ecx, ecx
	je	SHORT $LN21@GrowSize@4
	mov	DWORD PTR _i$222624[ebp], 0
	jmp	SHORT $LN26@GrowSize@4
$LN25@GrowSize@4:
	mov	edx, DWORD PTR _i$222624[ebp]
	add	edx, 1
	mov	DWORD PTR _i$222624[ebp], edx
$LN26@GrowSize@4:
	mov	eax, DWORD PTR _i$222624[ebp]
	cmp	eax, DWORD PTR $T222632[ebp]
	jae	SHORT $LN21@GrowSize@4
	jmp	SHORT $LN25@GrowSize@4
$LN21@GrowSize@4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	cmp	DWORD PTR $T222631[ebp], ecx
	je	SHORT $LN22@GrowSize@4
	mov	edx, DWORD PTR $T222631[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN22@GrowSize@4:

; 769  : 		m_pData = pTemp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], ecx

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+268], 1

; 772  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FStaticVector@PAVCvCity@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvCity *,64,1,297,0>::GrowSize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@PAVCvCity@@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@PAVCvCity@@$00@@QAE@XZ PROC		; BaseVector<CvCity *,1>::~BaseVector<CvCity *,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@PAVCvCity@@$00@@QAE@XZ ENDP		; BaseVector<CvCity *,1>::~BaseVector<CvCity *,1>
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT

; 298  : {

	push	ebp
	mov	ebp, esp

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	DWORD PTR _p$[ebp], 0
	jl	SHORT $LN1@teamType
	cmp	DWORD PTR _p$[ebp], 64			; 00000040H
	jge	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	eax, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN2@teamType
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1
$LN2@teamType:

; 302  : }

	pop	ebp
	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T222645 = -4						; size = 4
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ PROC		; CvPlot::getPlotCity, COMDAT
; _this$ = ecx

; 532  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 533  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+104], 0
	jl	SHORT $LN1@getPlotCit
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+104], 64			; 00000040H
	jge	SHORT $LN1@getPlotCit

; 534  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T222645[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	mov	ecx, DWORD PTR $T222645[ebp]
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	jmp	SHORT $LN2@getPlotCit
$LN1@getPlotCit:

; 535  : 
; 536  : 		return NULL;

	xor	eax, eax
$LN2@getPlotCit:

; 537  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ ENDP		; CvPlot::getPlotCity
_TEXT	ENDS
END
