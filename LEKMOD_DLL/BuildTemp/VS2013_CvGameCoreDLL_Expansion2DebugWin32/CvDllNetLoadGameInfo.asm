; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvDllNetLoadGameInfo.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_05OCFELOIJ@1?40?40?$AA@			; `string'
CONST	SEGMENT
_guidICvUnknown DD 0d89ba82fH
	DW	09fa3H
	DW	04696H
	DB	0b3H
	DB	0f4H
	DB	052H
	DB	0bdH
	DB	0b1H
	DB	01H
	DB	0cfH
	DB	0b2H
_guidICvNetLoadGameInfo1 DD 047189636H
	DW	0a5d4H
	DW	04d0bH
	DB	0aaH
	DB	079H
	DB	0f9H
	DB	070H
	DB	065H
	DB	06fH
	DB	014H
	DB	0ebH
CONST	ENDS
_DATA	SEGMENT
_CIV5_XP2_DLL_VERSION DD FLAT:??_C@_05OCFELOIJ@1?40?40?$AA@
_DATA	ENDS
;	COMDAT ??_C@_05OCFELOIJ@1?40?40?$AA@
CONST	SEGMENT
??_C@_05OCFELOIJ@1?40?40?$AA@ DB '1.0.0', 00H		; `string'
CONST	ENDS
PUBLIC	??1?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@QAE@XZ ; std::vector<enum SlotStatus,std::allocator<enum SlotStatus> >::~vector<enum SlotStatus,std::allocator<enum SlotStatus> >
PUBLIC	??1?$_Vector_val@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@QAE@XZ ; std::_Vector_val<enum SlotStatus,std::allocator<enum SlotStatus> >::~_Vector_val<enum SlotStatus,std::allocator<enum SlotStatus> >
PUBLIC	??4?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<enum SlotStatus,std::allocator<enum SlotStatus> >::operator=
PUBLIC	?_Buy@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@IAE_NI@Z ; std::vector<enum SlotStatus,std::allocator<enum SlotStatus> >::_Buy
PUBLIC	??_7CvDllNetLoadGameInfo@@6B@			; CvDllNetLoadGameInfo::`vftable'
PUBLIC	??_7ICvNetLoadGameInfo1@@6B@			; ICvNetLoadGameInfo1::`vftable'
PUBLIC	??_7ICvUnknown@@6B@				; ICvUnknown::`vftable'
PUBLIC	??0CvDllNetLoadGameInfo@@QAE@XZ			; CvDllNetLoadGameInfo::CvDllNetLoadGameInfo
PUBLIC	?QueryInterface@CvDllNetLoadGameInfo@@UAGPAXU_GUID@@@Z ; CvDllNetLoadGameInfo::QueryInterface
PUBLIC	?Destroy@CvDllNetLoadGameInfo@@EAGXXZ		; CvDllNetLoadGameInfo::Destroy
PUBLIC	?Read@CvDllNetLoadGameInfo@@UAG_NAAVFDataStream@@@Z ; CvDllNetLoadGameInfo::Read
PUBLIC	?Write@CvDllNetLoadGameInfo@@UAG_NAAVFDataStream@@@Z ; CvDllNetLoadGameInfo::Write
PUBLIC	?Commit@CvDllNetLoadGameInfo@@UAG_NXZ		; CvDllNetLoadGameInfo::Commit
EXTRN	?GetSlotStatus@CvPreGame@@YAABV?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@XZ:PROC ; CvPreGame::GetSlotStatus
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	__purecall:PROC
;	COMDAT ??_7CvDllNetLoadGameInfo@@6B@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
CONST	SEGMENT
??_7CvDllNetLoadGameInfo@@6B@ DD FLAT:?QueryInterface@CvDllNetLoadGameInfo@@UAGPAXU_GUID@@@Z ; CvDllNetLoadGameInfo::`vftable'
	DD	FLAT:?Destroy@CvDllNetLoadGameInfo@@EAGXXZ
	DD	FLAT:?Read@CvDllNetLoadGameInfo@@UAG_NAAVFDataStream@@@Z
	DD	FLAT:?Write@CvDllNetLoadGameInfo@@UAG_NAAVFDataStream@@@Z
	DD	FLAT:?Commit@CvDllNetLoadGameInfo@@UAG_NXZ
CONST	ENDS
;	COMDAT ??_7ICvNetLoadGameInfo1@@6B@
CONST	SEGMENT
??_7ICvNetLoadGameInfo1@@6B@ DD FLAT:__purecall		; ICvNetLoadGameInfo1::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_7ICvUnknown@@6B@
CONST	SEGMENT
??_7ICvUnknown@@6B@ DD FLAT:__purecall			; ICvUnknown::`vftable'
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CvDllNetLoadGameInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvDllNetLoadGameInfo@@QAE@XZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvDllNetLoadGameInfo@@QAE@XZ$0
__ehfuncinfo$??0CvDllNetLoadGameInfo@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CvDllNetLoadGameInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdllnetloadgameinfo.cpp
xdata$x	ENDS
;	COMDAT ??0CvDllNetLoadGameInfo@@QAE@XZ
_TEXT	SEGMENT
tv150 = -296						; size = 4
tv175 = -292						; size = 4
_this$ = -288						; size = 4
$T219352 = -124						; size = 4
$T219302 = -30						; size = 1
$T219289 = -29						; size = 1
$T219285 = -28						; size = 4
$T219278 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0CvDllNetLoadGameInfo@@QAE@XZ PROC			; CvDllNetLoadGameInfo::CvDllNetLoadGameInfo, COMDAT
; _this$ = ecx

; 15   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvDllNetLoadGameInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 284				; 0000011cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7ICvUnknown@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7ICvNetLoadGameInfo1@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], OFFSET ??_7CvDllNetLoadGameInfo@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR $T219352[ebp], eax
	lea	ecx, DWORD PTR $T219302[ebp]
	mov	DWORD PTR $T219278[ebp], ecx
	lea	edx, DWORD PTR $T219289[ebp]
	mov	DWORD PTR $T219285[ebp], edx
	mov	eax, DWORD PTR $T219352[ebp]
	mov	DWORD PTR tv175[ebp], eax
	mov	ecx, DWORD PTR $T219352[ebp]
	mov	DWORD PTR tv150[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	0
	mov	ecx, DWORD PTR $T219352[ebp]
	call	?_Buy@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@IAE_NI@Z ; std::vector<enum SlotStatus,std::allocator<enum SlotStatus> >::_Buy
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 1

; 16   : 	m_slotStatus = CvPreGame::GetSlotStatus();

	call	?GetSlotStatus@CvPreGame@@YAABV?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@XZ ; CvPreGame::GetSlotStatus
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??4?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<enum SlotStatus,std::allocator<enum SlotStatus> >::operator=

; 17   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvDllNetLoadGameInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR $T219352[ebp]
	jmp	??1?$_Vector_val@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@QAE@XZ
__unwindfunclet$??0CvDllNetLoadGameInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@QAE@XZ ; std::vector<enum SlotStatus,std::allocator<enum SlotStatus> >::~vector<enum SlotStatus,std::allocator<enum SlotStatus> >
__ehhandler$??0CvDllNetLoadGameInfo@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-288]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvDllNetLoadGameInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvDllNetLoadGameInfo@@QAE@XZ ENDP			; CvDllNetLoadGameInfo::CvDllNetLoadGameInfo
PUBLIC	?_Tidy@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@IAEXXZ ; std::vector<enum SlotStatus,std::allocator<enum SlotStatus> >::_Tidy
PUBLIC	??1CvDllNetLoadGameInfo@@QAE@XZ			; CvDllNetLoadGameInfo::~CvDllNetLoadGameInfo
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1CvDllNetLoadGameInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvDllNetLoadGameInfo@@QAE@XZ$1
__ehfuncinfo$??1CvDllNetLoadGameInfo@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CvDllNetLoadGameInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdllnetloadgameinfo.cpp
xdata$x	ENDS
;	COMDAT ??1CvDllNetLoadGameInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T219751 = -48						; size = 4
__$EHRec$ = -12						; size = 12
??1CvDllNetLoadGameInfo@@QAE@XZ PROC			; CvDllNetLoadGameInfo::~CvDllNetLoadGameInfo, COMDAT
; _this$ = ecx

; 20   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvDllNetLoadGameInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvDllNetLoadGameInfo@@6B@

; 21   : }

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	mov	DWORD PTR $T219751[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR $T219751[ebp]
	call	?_Tidy@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@IAEXXZ ; std::vector<enum SlotStatus,std::allocator<enum SlotStatus> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvDllNetLoadGameInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR $T219751[ebp]
	jmp	??1?$_Vector_val@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@QAE@XZ
__ehhandler$??1CvDllNetLoadGameInfo@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvDllNetLoadGameInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvDllNetLoadGameInfo@@QAE@XZ ENDP			; CvDllNetLoadGameInfo::~CvDllNetLoadGameInfo
PUBLIC	?IncrementReference@CvDllNetLoadGameInfo@@QAEIXZ ; CvDllNetLoadGameInfo::IncrementReference
; Function compile flags: /Odtp
;	COMDAT ?QueryInterface@CvDllNetLoadGameInfo@@UAGPAXU_GUID@@@Z
_TEXT	SEGMENT
tv90 = -88						; size = 4
tv161 = -84						; size = 4
tv85 = -80						; size = 4
tv137 = -76						; size = 4
$T219764 = -72						; size = 16
$T219763 = -56						; size = 16
$T219762 = -40						; size = 16
$T219761 = -20						; size = 16
_this$ = 8						; size = 4
_guidInterface$ = 12					; size = 16
?QueryInterface@CvDllNetLoadGameInfo@@UAGPAXU_GUID@@@Z PROC ; CvDllNetLoadGameInfo::QueryInterface, COMDAT

; 24   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	esi
	push	edi

; 25   : 	if(guidInterface == ICvUnknown::GetInterfaceId() ||
; 26   : 	        guidInterface == ICvNetLoadGameInfo1::GetInterfaceId())

	mov	eax, DWORD PTR _guidICvUnknown
	mov	DWORD PTR $T219762[ebp], eax
	mov	ecx, DWORD PTR _guidICvUnknown+4
	mov	DWORD PTR $T219762[ebp+4], ecx
	mov	edx, DWORD PTR _guidICvUnknown+8
	mov	DWORD PTR $T219762[ebp+8], edx
	mov	eax, DWORD PTR _guidICvUnknown+12
	mov	DWORD PTR $T219762[ebp+12], eax
	mov	ecx, DWORD PTR $T219762[ebp]
	mov	DWORD PTR $T219761[ebp], ecx
	mov	edx, DWORD PTR $T219762[ebp+4]
	mov	DWORD PTR $T219761[ebp+4], edx
	mov	eax, DWORD PTR $T219762[ebp+8]
	mov	DWORD PTR $T219761[ebp+8], eax
	mov	ecx, DWORD PTR $T219762[ebp+12]
	mov	DWORD PTR $T219761[ebp+12], ecx
	mov	ecx, 16					; 00000010H
	lea	edi, DWORD PTR $T219761[ebp]
	lea	esi, DWORD PTR _guidInterface$[ebp]
	xor	edx, edx
	mov	DWORD PTR tv137[ebp], edx
	repe cmpsb
	je	SHORT $LN17@QueryInter
	sbb	eax, eax
	sbb	eax, -1
	mov	DWORD PTR tv137[ebp], eax
$LN17@QueryInter:
	mov	ecx, DWORD PTR tv137[ebp]
	mov	DWORD PTR tv85[ebp], ecx
	xor	edx, edx
	cmp	DWORD PTR tv85[ebp], 0
	sete	dl
	test	edx, edx
	jne	SHORT $LN1@QueryInter
	mov	eax, DWORD PTR _guidICvNetLoadGameInfo1
	mov	DWORD PTR $T219764[ebp], eax
	mov	ecx, DWORD PTR _guidICvNetLoadGameInfo1+4
	mov	DWORD PTR $T219764[ebp+4], ecx
	mov	edx, DWORD PTR _guidICvNetLoadGameInfo1+8
	mov	DWORD PTR $T219764[ebp+8], edx
	mov	eax, DWORD PTR _guidICvNetLoadGameInfo1+12
	mov	DWORD PTR $T219764[ebp+12], eax
	mov	ecx, DWORD PTR $T219764[ebp]
	mov	DWORD PTR $T219763[ebp], ecx
	mov	edx, DWORD PTR $T219764[ebp+4]
	mov	DWORD PTR $T219763[ebp+4], edx
	mov	eax, DWORD PTR $T219764[ebp+8]
	mov	DWORD PTR $T219763[ebp+8], eax
	mov	ecx, DWORD PTR $T219764[ebp+12]
	mov	DWORD PTR $T219763[ebp+12], ecx
	mov	ecx, 16					; 00000010H
	lea	edi, DWORD PTR $T219763[ebp]
	lea	esi, DWORD PTR _guidInterface$[ebp]
	xor	edx, edx
	mov	DWORD PTR tv161[ebp], edx
	repe cmpsb
	je	SHORT $LN18@QueryInter
	sbb	eax, eax
	sbb	eax, -1
	mov	DWORD PTR tv161[ebp], eax
$LN18@QueryInter:
	mov	ecx, DWORD PTR tv161[ebp]
	mov	DWORD PTR tv90[ebp], ecx
	xor	edx, edx
	cmp	DWORD PTR tv90[ebp], 0
	sete	dl
	test	edx, edx
	je	SHORT $LN2@QueryInter
$LN1@QueryInter:

; 27   : 	{
; 28   : 		IncrementReference();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IncrementReference@CvDllNetLoadGameInfo@@QAEIXZ ; CvDllNetLoadGameInfo::IncrementReference

; 29   : 		return this;

	mov	eax, DWORD PTR _this$[ebp]
	jmp	SHORT $LN3@QueryInter
$LN2@QueryInter:

; 30   : 	}
; 31   : 
; 32   : 	return NULL;

	xor	eax, eax
$LN3@QueryInter:

; 33   : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?QueryInterface@CvDllNetLoadGameInfo@@UAGPAXU_GUID@@@Z ENDP ; CvDllNetLoadGameInfo::QueryInterface
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IncrementReference@CvDllNetLoadGameInfo@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IncrementReference@CvDllNetLoadGameInfo@@QAEIXZ PROC	; CvDllNetLoadGameInfo::IncrementReference, COMDAT
; _this$ = ecx

; 36   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 37   : 	++m_uiRefCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 38   : 	return m_uiRefCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]

; 39   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IncrementReference@CvDllNetLoadGameInfo@@QAEIXZ ENDP	; CvDllNetLoadGameInfo::IncrementReference
_TEXT	ENDS
PUBLIC	??3CvDllNetLoadGameInfo@@SAXPAX@Z		; CvDllNetLoadGameInfo::operator delete
PUBLIC	?DecrementReference@CvDllNetLoadGameInfo@@QAEIXZ ; CvDllNetLoadGameInfo::DecrementReference
; Function compile flags: /Odtp
;	COMDAT ?DecrementReference@CvDllNetLoadGameInfo@@QAEIXZ
_TEXT	SEGMENT
tv70 = -16						; size = 4
_this$ = -12						; size = 4
$T219796 = -8						; size = 4
$T219795 = -4						; size = 4
?DecrementReference@CvDllNetLoadGameInfo@@QAEIXZ PROC	; CvDllNetLoadGameInfo::DecrementReference, COMDAT
; _this$ = ecx

; 42   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 43   : 	if(m_uiRefCount == 1)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 1
	jne	SHORT $LN2@DecrementR

; 44   : 	{
; 45   : 		delete this;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T219796[ebp], ecx
	mov	edx, DWORD PTR $T219796[ebp]
	mov	DWORD PTR $T219795[ebp], edx
	cmp	DWORD PTR $T219795[ebp], 0
	je	SHORT $LN5@DecrementR
	mov	ecx, DWORD PTR $T219795[ebp]
	call	??1CvDllNetLoadGameInfo@@QAE@XZ		; CvDllNetLoadGameInfo::~CvDllNetLoadGameInfo
	mov	eax, 1
	and	eax, 1
	je	SHORT $LN8@DecrementR
	mov	ecx, DWORD PTR $T219795[ebp]
	push	ecx
	call	??3CvDllNetLoadGameInfo@@SAXPAX@Z	; CvDllNetLoadGameInfo::operator delete
	add	esp, 4
$LN8@DecrementR:
	mov	edx, DWORD PTR $T219795[ebp]
	mov	DWORD PTR tv70[ebp], edx
	jmp	SHORT $LN6@DecrementR
$LN5@DecrementR:
	mov	DWORD PTR tv70[ebp], 0
$LN6@DecrementR:

; 46   : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN3@DecrementR

; 47   : 	}
; 48   : 	else

	jmp	SHORT $LN3@DecrementR
$LN2@DecrementR:

; 49   : 	{
; 50   : 		--m_uiRefCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 51   : 		return m_uiRefCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]
$LN3@DecrementR:

; 52   : 	}
; 53   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DecrementReference@CvDllNetLoadGameInfo@@QAEIXZ ENDP	; CvDllNetLoadGameInfo::DecrementReference
_TEXT	ENDS
PUBLIC	?GetReferenceCount@CvDllNetLoadGameInfo@@QAEIXZ	; CvDllNetLoadGameInfo::GetReferenceCount
; Function compile flags: /Odtp
;	COMDAT ?GetReferenceCount@CvDllNetLoadGameInfo@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetReferenceCount@CvDllNetLoadGameInfo@@QAEIXZ PROC	; CvDllNetLoadGameInfo::GetReferenceCount, COMDAT
; _this$ = ecx

; 56   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 57   : 	return m_uiRefCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]

; 58   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetReferenceCount@CvDllNetLoadGameInfo@@QAEIXZ ENDP	; CvDllNetLoadGameInfo::GetReferenceCount
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Destroy@CvDllNetLoadGameInfo@@EAGXXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?Destroy@CvDllNetLoadGameInfo@@EAGXXZ PROC		; CvDllNetLoadGameInfo::Destroy, COMDAT

; 61   : {

	push	ebp
	mov	ebp, esp

; 62   : 	DecrementReference();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DecrementReference@CvDllNetLoadGameInfo@@QAEIXZ ; CvDllNetLoadGameInfo::DecrementReference

; 63   : }

	pop	ebp
	ret	4
?Destroy@CvDllNetLoadGameInfo@@EAGXXZ ENDP		; CvDllNetLoadGameInfo::Destroy
_TEXT	ENDS
EXTRN	?Free@CvDllGameContext@@SAXPAX@Z:PROC		; CvDllGameContext::Free
; Function compile flags: /Odtp
;	COMDAT ??3CvDllNetLoadGameInfo@@SAXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
??3CvDllNetLoadGameInfo@@SAXPAX@Z PROC			; CvDllNetLoadGameInfo::operator delete, COMDAT

; 66   : {

	push	ebp
	mov	ebp, esp

; 67   : 	CvDllGameContext::Free(p);

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	?Free@CvDllGameContext@@SAXPAX@Z	; CvDllGameContext::Free
	add	esp, 4

; 68   : }

	pop	ebp
	ret	0
??3CvDllNetLoadGameInfo@@SAXPAX@Z ENDP			; CvDllNetLoadGameInfo::operator delete
_TEXT	ENDS
PUBLIC	??2CvDllNetLoadGameInfo@@SAPAXI@Z		; CvDllNetLoadGameInfo::operator new
EXTRN	?Allocate@CvDllGameContext@@SAPAXI@Z:PROC	; CvDllGameContext::Allocate
; Function compile flags: /Odtp
;	COMDAT ??2CvDllNetLoadGameInfo@@SAPAXI@Z
_TEXT	SEGMENT
_bytes$ = 8						; size = 4
??2CvDllNetLoadGameInfo@@SAPAXI@Z PROC			; CvDllNetLoadGameInfo::operator new, COMDAT

; 71   : {

	push	ebp
	mov	ebp, esp

; 72   : 	return CvDllGameContext::Allocate(bytes);

	mov	eax, DWORD PTR _bytes$[ebp]
	push	eax
	call	?Allocate@CvDllGameContext@@SAPAXI@Z	; CvDllGameContext::Allocate
	add	esp, 4

; 73   : }

	pop	ebp
	ret	0
??2CvDllNetLoadGameInfo@@SAPAXI@Z ENDP			; CvDllNetLoadGameInfo::operator new
_TEXT	ENDS
PUBLIC	??$?5W4SlotStatus@@@@YAAAVFDataStream@@AAV0@AAV?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@@Z ; operator>><enum SlotStatus>
; Function compile flags: /Odtp
;	COMDAT ?Read@CvDllNetLoadGameInfo@@UAG_NAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_kStream$ = 12						; size = 4
?Read@CvDllNetLoadGameInfo@@UAG_NAAVFDataStream@@@Z PROC ; CvDllNetLoadGameInfo::Read, COMDAT

; 76   : {

	push	ebp
	mov	ebp, esp

; 77   : 	kStream >> m_slotStatus;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?5W4SlotStatus@@@@YAAAVFDataStream@@AAV0@AAV?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@@Z ; operator>><enum SlotStatus>
	add	esp, 8

; 78   : 	return true;

	mov	al, 1

; 79   : }

	pop	ebp
	ret	8
?Read@CvDllNetLoadGameInfo@@UAG_NAAVFDataStream@@@Z ENDP ; CvDllNetLoadGameInfo::Read
_TEXT	ENDS
PUBLIC	??$?6W4SlotStatus@@@@YAAAVFDataStream@@AAV0@ABV?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@@Z ; operator<<<enum SlotStatus>
; Function compile flags: /Odtp
;	COMDAT ?Write@CvDllNetLoadGameInfo@@UAG_NAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_kStream$ = 12						; size = 4
?Write@CvDllNetLoadGameInfo@@UAG_NAAVFDataStream@@@Z PROC ; CvDllNetLoadGameInfo::Write, COMDAT

; 82   : {

	push	ebp
	mov	ebp, esp

; 83   : 	kStream << m_slotStatus;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?6W4SlotStatus@@@@YAAAVFDataStream@@AAV0@ABV?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@@Z ; operator<<<enum SlotStatus>
	add	esp, 8

; 84   : 	return true;

	mov	al, 1

; 85   : }

	pop	ebp
	ret	8
?Write@CvDllNetLoadGameInfo@@UAG_NAAVFDataStream@@@Z ENDP ; CvDllNetLoadGameInfo::Write
_TEXT	ENDS
EXTRN	?setAllSlotStatus@CvPreGame@@YAXABV?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@@Z:PROC ; CvPreGame::setAllSlotStatus
; Function compile flags: /Odtp
;	COMDAT ?Commit@CvDllNetLoadGameInfo@@UAG_NXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?Commit@CvDllNetLoadGameInfo@@UAG_NXZ PROC		; CvDllNetLoadGameInfo::Commit, COMDAT

; 88   : {

	push	ebp
	mov	ebp, esp

; 89   : 	CvPreGame::setAllSlotStatus(m_slotStatus);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	call	?setAllSlotStatus@CvPreGame@@YAXABV?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@@Z ; CvPreGame::setAllSlotStatus
	add	esp, 4

; 90   : 	return true;

	mov	al, 1

; 91   : }

	pop	ebp
	ret	4
?Commit@CvDllNetLoadGameInfo@@UAG_NXZ ENDP		; CvDllNetLoadGameInfo::Commit
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@QAE@XZ PROC ; std::vector<enum SlotStatus,std::allocator<enum SlotStatus> >::~vector<enum SlotStatus,std::allocator<enum SlotStatus> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@IAEXXZ ; std::vector<enum SlotStatus,std::allocator<enum SlotStatus> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@QAE@XZ ENDP ; std::vector<enum SlotStatus,std::allocator<enum SlotStatus> >::~vector<enum SlotStatus,std::allocator<enum SlotStatus> >
PUBLIC	??$_Uninit_copy@PAW4SlotStatus@@PAW41@V?$allocator@W4SlotStatus@@@std@@@std@@YAPAW4SlotStatus@@PAW41@00AAV?$allocator@W4SlotStatus@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum SlotStatus *,enum SlotStatus *,std::allocator<enum SlotStatus> >
PUBLIC	?erase@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@QAE?AV?$_Vector_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@V?$_Vector_const_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@0@Z ; std::vector<enum SlotStatus,std::allocator<enum SlotStatus> >::erase
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
tv239 = -300						; size = 4
_this$ = -296						; size = 4
$T220292 = -292						; size = 4
$T220291 = -288						; size = 4
$T220290 = -284						; size = 4
$T220280 = -280						; size = 4
$T220279 = -276						; size = 4
__Cat$220287 = -271					; size = 1
$T220284 = -270						; size = 1
$T220283 = -269						; size = 1
$T220229 = -180						; size = 4
$T220225 = -176						; size = 4
$T220224 = -172						; size = 4
$T220220 = -168						; size = 4
$T220219 = -164						; size = 4
$T220201 = -160						; size = 4
$T220200 = -156						; size = 4
$T220184 = -152						; size = 4
__Cat$220206 = -146					; size = 1
$T220203 = -145						; size = 1
$T220158 = -144						; size = 4
$T220157 = -140						; size = 4
$T220147 = -136						; size = 4
$T220146 = -132						; size = 4
__Cat$220155 = -127					; size = 1
$T220153 = -126						; size = 1
$T220152 = -125						; size = 1
$T220130 = -124						; size = 4
$T220129 = -120						; size = 4
$T220112 = -114						; size = 1
$T220111 = -113						; size = 1
$T220110 = -112						; size = 4
$T220109 = -108						; size = 4
__Cat$220119 = -100					; size = 1
$T220117 = -99						; size = 1
$T220116 = -98						; size = 1
$T220115 = -97						; size = 1
$T220080 = -96						; size = 4
$T220073 = -92						; size = 4
$T220055 = -88						; size = 4
$T220054 = -84						; size = 4
$T220038 = -80						; size = 4
__Cat$220062 = -74					; size = 1
$T220060 = -73						; size = 1
$T220012 = -72						; size = 4
$T220011 = -68						; size = 4
$T220010 = -64						; size = 4
$T219993 = -58						; size = 1
$T219992 = -57						; size = 1
$T219991 = -56						; size = 4
$T219990 = -52						; size = 4
__Cat$220000 = -44					; size = 1
$T219998 = -43						; size = 1
$T219997 = -42						; size = 1
$T219996 = -41						; size = 1
$T219968 = -40						; size = 4
$T219939 = -36						; size = 4
$T219923 = -32						; size = 4
$T219952 = -28						; size = 4
$T219951 = -24						; size = 4
$T219950 = -20						; size = 4
$T219949 = -16						; size = 4
$T219948 = -12						; size = 4
__Ptr$218268 = -8					; size = 4
__Ptr$218258 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<enum SlotStatus,std::allocator<enum SlotStatus> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 300				; 0000012cH
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	test	eax, eax
	jne	SHORT $LN8@operator

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T219923[ebp], edx
	mov	eax, DWORD PTR $T219923[ebp]
	mov	DWORD PTR $T219949[ebp], eax
	mov	ecx, DWORD PTR $T219949[ebp]
	mov	DWORD PTR $T219948[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T219939[ebp], eax
	mov	ecx, DWORD PTR $T219939[ebp]
	mov	DWORD PTR $T219951[ebp], ecx
	mov	edx, DWORD PTR $T219951[ebp]
	mov	DWORD PTR $T219950[ebp], edx
	mov	eax, DWORD PTR $T219948[ebp]
	push	eax
	mov	ecx, DWORD PTR $T219950[ebp]
	push	ecx
	lea	edx, DWORD PTR $T219952[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@QAE?AV?$_Vector_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@V?$_Vector_const_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@0@Z ; std::vector<enum SlotStatus,std::allocator<enum SlotStatus> >::erase

; 573  : 			else if (_Right.size() <= size())

	jmp	$LN9@operator
$LN8@operator:
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T219968[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	DWORD PTR $T219968[ebp], edx
	ja	$LN6@operator

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T220012[ebp], ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T220011[ebp], eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T220010[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T219996[ebp], al
	mov	cl, BYTE PTR __Cat$220000[ebp]
	mov	BYTE PTR $T219997[ebp], cl
	mov	dl, BYTE PTR $T219996[ebp]
	mov	BYTE PTR $T219993[ebp], dl
	mov	al, BYTE PTR $T219998[ebp]
	mov	BYTE PTR $T219992[ebp], al
	mov	ecx, DWORD PTR $T220012[ebp]
	mov	DWORD PTR $T219991[ebp], ecx
	mov	edx, DWORD PTR $T220010[ebp]
	mov	DWORD PTR $T219990[ebp], edx
	jmp	SHORT $LN40@operator
$LN39@operator:
	mov	eax, DWORD PTR $T219991[ebp]
	add	eax, 4
	mov	DWORD PTR $T219991[ebp], eax
	mov	ecx, DWORD PTR $T219990[ebp]
	add	ecx, 4
	mov	DWORD PTR $T219990[ebp], ecx
$LN40@operator:
	mov	edx, DWORD PTR $T219990[ebp]
	cmp	edx, DWORD PTR $T220011[ebp]
	je	SHORT $LN32@operator
	mov	eax, DWORD PTR $T219991[ebp]
	mov	ecx, DWORD PTR $T219990[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN39@operator
$LN32@operator:
	mov	eax, DWORD PTR $T219991[ebp]
	mov	DWORD PTR __Ptr$218258[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T220073[ebp], edx
	mov	eax, DWORD PTR $T220073[ebp]
	mov	DWORD PTR $T220055[ebp], eax
	mov	ecx, DWORD PTR __Ptr$218258[ebp]
	mov	DWORD PTR $T220054[ebp], ecx
	mov	dl, BYTE PTR __Cat$220062[ebp]
	mov	BYTE PTR $T220060[ebp], dl
	mov	eax, DWORD PTR $T220054[ebp]
	mov	DWORD PTR $T220038[ebp], eax
	jmp	SHORT $LN51@operator
$LN50@operator:
	mov	ecx, DWORD PTR $T220038[ebp]
	add	ecx, 4
	mov	DWORD PTR $T220038[ebp], ecx
$LN51@operator:
	mov	edx, DWORD PTR $T220038[ebp]
	cmp	edx, DWORD PTR $T220055[ebp]
	je	SHORT $LN58@operator
	jmp	SHORT $LN50@operator

; 578  : 				_Mylast = _Myfirst + _Right.size();

$LN58@operator:
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx
	jmp	$LN9@operator
$LN6@operator:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR $T220080[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN64@operator
	mov	DWORD PTR tv239[ebp], 0
	jmp	SHORT $LN62@operator
$LN64@operator:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR tv239[ebp], ecx
$LN62@operator:
	mov	edx, DWORD PTR $T220080[ebp]
	cmp	edx, DWORD PTR tv239[ebp]
	ja	$LN4@operator

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR __Ptr$218268[ebp], edx

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T220130[ebp], ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T220129[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T220115[ebp], cl
	mov	dl, BYTE PTR __Cat$220119[ebp]
	mov	BYTE PTR $T220116[ebp], dl
	mov	al, BYTE PTR $T220115[ebp]
	mov	BYTE PTR $T220112[ebp], al
	mov	cl, BYTE PTR $T220117[ebp]
	mov	BYTE PTR $T220111[ebp], cl
	mov	edx, DWORD PTR $T220130[ebp]
	mov	DWORD PTR $T220110[ebp], edx
	mov	eax, DWORD PTR $T220129[ebp]
	mov	DWORD PTR $T220109[ebp], eax
	jmp	SHORT $LN76@operator
$LN75@operator:
	mov	ecx, DWORD PTR $T220110[ebp]
	add	ecx, 4
	mov	DWORD PTR $T220110[ebp], ecx
	mov	edx, DWORD PTR $T220109[ebp]
	add	edx, 4
	mov	DWORD PTR $T220109[ebp], edx
$LN76@operator:
	mov	eax, DWORD PTR $T220109[ebp]
	cmp	eax, DWORD PTR __Ptr$218268[ebp]
	je	SHORT $LN68@operator
	mov	ecx, DWORD PTR $T220110[ebp]
	mov	edx, DWORD PTR $T220109[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN75@operator
$LN68@operator:

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T220158[ebp], edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T220157[ebp], ecx
	mov	edx, DWORD PTR $T220158[ebp]
	mov	DWORD PTR $T220147[ebp], edx
	mov	eax, DWORD PTR __Ptr$218268[ebp]
	mov	DWORD PTR $T220146[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T220152[ebp], cl
	mov	dl, BYTE PTR __Cat$220155[ebp]
	mov	BYTE PTR $T220153[ebp], dl
	movzx	eax, BYTE PTR $T220152[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T220153[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T220147[ebp]
	push	eax
	mov	ecx, DWORD PTR $T220157[ebp]
	push	ecx
	mov	edx, DWORD PTR $T220146[ebp]
	push	edx
	call	??$_Uninit_copy@PAW4SlotStatus@@PAW41@V?$allocator@W4SlotStatus@@@std@@@std@@YAPAW4SlotStatus@@PAW41@00AAV?$allocator@W4SlotStatus@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum SlotStatus *,enum SlotStatus *,std::allocator<enum SlotStatus> >
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 585  : 				}
; 586  : 			else

	jmp	$LN9@operator
$LN4@operator:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN2@operator

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T220220[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T220219[ebp], eax
	mov	ecx, DWORD PTR $T220220[ebp]
	mov	DWORD PTR $T220201[ebp], ecx
	mov	edx, DWORD PTR $T220219[ebp]
	mov	DWORD PTR $T220200[ebp], edx
	mov	al, BYTE PTR __Cat$220206[ebp]
	mov	BYTE PTR $T220203[ebp], al
	mov	ecx, DWORD PTR $T220200[ebp]
	mov	DWORD PTR $T220184[ebp], ecx
	jmp	SHORT $LN93@operator
$LN92@operator:
	mov	edx, DWORD PTR $T220184[ebp]
	add	edx, 4
	mov	DWORD PTR $T220184[ebp], edx
$LN93@operator:
	mov	eax, DWORD PTR $T220184[ebp]
	cmp	eax, DWORD PTR $T220201[ebp]
	je	SHORT $LN85@operator
	jmp	SHORT $LN92@operator
$LN85@operator:

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR $T220225[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T220224[ebp], edx
	mov	eax, DWORD PTR $T220224[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@operator:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR $T220229[ebp], eax
	mov	ecx, DWORD PTR $T220229[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@IAE_NI@Z ; std::vector<enum SlotStatus,std::allocator<enum SlotStatus> >::_Buy
	movzx	edx, al
	test	edx, edx
	je	$LN9@operator

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T220292[ebp], ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T220291[ebp], eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T220290[ebp], edx
	mov	eax, DWORD PTR $T220292[ebp]
	mov	DWORD PTR $T220280[ebp], eax
	mov	ecx, DWORD PTR $T220290[ebp]
	mov	DWORD PTR $T220279[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T220283[ebp], dl
	mov	al, BYTE PTR __Cat$220287[ebp]
	mov	BYTE PTR $T220284[ebp], al
	movzx	ecx, BYTE PTR $T220283[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T220284[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T220280[ebp]
	push	ecx
	mov	edx, DWORD PTR $T220291[ebp]
	push	edx
	mov	eax, DWORD PTR $T220279[ebp]
	push	eax
	call	??$_Uninit_copy@PAW4SlotStatus@@PAW41@V?$allocator@W4SlotStatus@@@std@@@std@@YAPAW4SlotStatus@@PAW41@00AAV?$allocator@W4SlotStatus@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum SlotStatus *,enum SlotStatus *,std::allocator<enum SlotStatus> >
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN9@operator:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<enum SlotStatus,std::allocator<enum SlotStatus> >::operator=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<enum SlotStatus,std::allocator<enum SlotStatus> >::~_Vector_val<enum SlotStatus,std::allocator<enum SlotStatus> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<enum SlotStatus,std::allocator<enum SlotStatus> >::~_Vector_val<enum SlotStatus,std::allocator<enum SlotStatus> >
_TEXT	ENDS
PUBLIC	??$_Allocate@W4SlotStatus@@@std@@YAPAW4SlotStatus@@IPAW41@@Z ; std::_Allocate<enum SlotStatus>
PUBLIC	?_Xlen@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@KAXXZ ; std::vector<enum SlotStatus,std::allocator<enum SlotStatus> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$220315 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@IAE_NI@Z PROC ; std::vector<enum SlotStatus,std::allocator<enum SlotStatus> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy
	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$220315[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$220315[ebp], 0
	jbe	SHORT $LN11@Buy
	mov	eax, DWORD PTR __Count$220315[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy
$LN11@Buy:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@KAXXZ ; std::vector<enum SlotStatus,std::allocator<enum SlotStatus> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@W4SlotStatus@@@std@@YAPAW4SlotStatus@@IPAW41@@Z ; std::_Allocate<enum SlotStatus>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<enum SlotStatus,std::allocator<enum SlotStatus> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T220409 = -32						; size = 4
$T220408 = -28						; size = 4
$T220404 = -24						; size = 4
$T220403 = -20						; size = 4
$T220385 = -16						; size = 4
$T220384 = -12						; size = 4
$T220368 = -8						; size = 4
__Cat$220391 = -2					; size = 1
$T220388 = -1						; size = 1
?_Tidy@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@IAEXXZ PROC ; std::vector<enum SlotStatus,std::allocator<enum SlotStatus> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T220404[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T220403[ebp], ecx
	mov	edx, DWORD PTR $T220404[ebp]
	mov	DWORD PTR $T220385[ebp], edx
	mov	eax, DWORD PTR $T220403[ebp]
	mov	DWORD PTR $T220384[ebp], eax
	mov	cl, BYTE PTR __Cat$220391[ebp]
	mov	BYTE PTR $T220388[ebp], cl
	mov	edx, DWORD PTR $T220384[ebp]
	mov	DWORD PTR $T220368[ebp], edx
	jmp	SHORT $LN12@Tidy
$LN11@Tidy:
	mov	eax, DWORD PTR $T220368[ebp]
	add	eax, 4
	mov	DWORD PTR $T220368[ebp], eax
$LN12@Tidy:
	mov	ecx, DWORD PTR $T220368[ebp]
	cmp	ecx, DWORD PTR $T220385[ebp]
	je	SHORT $LN4@Tidy
	jmp	SHORT $LN11@Tidy
$LN4@Tidy:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR $T220409[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T220408[ebp], eax
	mov	ecx, DWORD PTR $T220408[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@IAEXXZ ENDP ; std::vector<enum SlotStatus,std::allocator<enum SlotStatus> >::_Tidy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?erase@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@QAE?AV?$_Vector_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@V?$_Vector_const_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
$T220551 = -64						; size = 4
$T220533 = -60						; size = 4
$T220532 = -56						; size = 4
$T220516 = -52						; size = 4
__Cat$220540 = -46					; size = 1
$T220537 = -45						; size = 1
$T220490 = -44						; size = 4
$T220489 = -40						; size = 4
$T220488 = -36						; size = 4
$T220471 = -30						; size = 1
$T220470 = -29						; size = 1
$T220469 = -28						; size = 4
$T220468 = -24						; size = 4
__Cat$220478 = -16					; size = 1
$T220475 = -15						; size = 1
$T220474 = -14						; size = 1
$T220473 = -13						; size = 1
__Ptr$218482 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@QAE?AV?$_Vector_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@V?$_Vector_const_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@0@Z PROC ; std::vector<enum SlotStatus,std::allocator<enum SlotStatus> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	$LN1@erase

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T220490[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T220489[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T220488[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T220473[ebp], cl
	mov	dl, BYTE PTR __Cat$220478[ebp]
	mov	BYTE PTR $T220474[ebp], dl
	mov	al, BYTE PTR $T220473[ebp]
	mov	BYTE PTR $T220471[ebp], al
	mov	cl, BYTE PTR $T220475[ebp]
	mov	BYTE PTR $T220470[ebp], cl
	mov	edx, DWORD PTR $T220490[ebp]
	mov	DWORD PTR $T220469[ebp], edx
	mov	eax, DWORD PTR $T220488[ebp]
	mov	DWORD PTR $T220468[ebp], eax
	jmp	SHORT $LN28@erase
$LN27@erase:
	mov	ecx, DWORD PTR $T220469[ebp]
	add	ecx, 4
	mov	DWORD PTR $T220469[ebp], ecx
	mov	edx, DWORD PTR $T220468[ebp]
	add	edx, 4
	mov	DWORD PTR $T220468[ebp], edx
$LN28@erase:
	mov	eax, DWORD PTR $T220468[ebp]
	cmp	eax, DWORD PTR $T220489[ebp]
	je	SHORT $LN20@erase
	mov	ecx, DWORD PTR $T220469[ebp]
	mov	edx, DWORD PTR $T220468[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN27@erase
$LN20@erase:
	mov	ecx, DWORD PTR $T220469[ebp]
	mov	DWORD PTR __Ptr$218482[ebp], ecx

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T220551[ebp], eax
	mov	ecx, DWORD PTR $T220551[ebp]
	mov	DWORD PTR $T220533[ebp], ecx
	mov	edx, DWORD PTR __Ptr$218482[ebp]
	mov	DWORD PTR $T220532[ebp], edx
	mov	al, BYTE PTR __Cat$220540[ebp]
	mov	BYTE PTR $T220537[ebp], al
	mov	ecx, DWORD PTR $T220532[ebp]
	mov	DWORD PTR $T220516[ebp], ecx
	jmp	SHORT $LN39@erase
$LN38@erase:
	mov	edx, DWORD PTR $T220516[ebp]
	add	edx, 4
	mov	DWORD PTR $T220516[ebp], edx
$LN39@erase:
	mov	eax, DWORD PTR $T220516[ebp]
	cmp	eax, DWORD PTR $T220533[ebp]
	je	SHORT $LN31@erase
	jmp	SHORT $LN38@erase
$LN31@erase:

; 1049 : 			_Mylast = _Ptr;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Ptr$218482[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN1@erase:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@QAE?AV?$_Vector_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@V?$_Vector_const_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@0@Z ENDP ; std::vector<enum SlotStatus,std::allocator<enum SlotStatus> >::erase
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_Elength_error@std@@UAEPAXI@Z ; std::length_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_Elogic_error@std@@UAEPAXI@Z ; std::logic_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T220555 = -80						; size = 28
$T220554 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@KAXXZ PROC ; std::vector<enum SlotStatus,std::allocator<enum SlotStatus> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T220555[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T220554[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T220554[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T220555[ebp]
	push	eax
	lea	ecx, DWORD PTR $T220554[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T220554[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T220554[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T220555[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T220555[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T220554[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@KAXXZ ENDP ; std::vector<enum SlotStatus,std::allocator<enum SlotStatus> >::_Xlen
PUBLIC	??$SerializeToSequenceContainer@W4SlotStatus@@V?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@@Z ; SerializeToSequenceContainer<enum SlotStatus,std::vector<enum SlotStatus,std::allocator<enum SlotStatus> > >
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$?5W4SlotStatus@@@@YAAAVFDataStream@@AAV0@AAV?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5W4SlotStatus@@@@YAAAVFDataStream@@AAV0@AAV?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@@Z PROC ; operator>><enum SlotStatus>, COMDAT

; 225  : {

	push	ebp
	mov	ebp, esp

; 226  : 	// The functor needs to be instantiated to properly resize the container based 
; 227  : 	// on how many elements the stream says it should have before passing it along
; 228  : 	// to std::for_each
; 229  : 	SerializeToSequenceContainer<ElementType, std::vector<ElementType> >(loadFrom, writeTo);

	mov	eax, DWORD PTR _writeTo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	push	ecx
	call	??$SerializeToSequenceContainer@W4SlotStatus@@V?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@@Z ; SerializeToSequenceContainer<enum SlotStatus,std::vector<enum SlotStatus,std::allocator<enum SlotStatus> > >
	add	esp, 8

; 230  : 
; 231  : 	//std::for_each(writeTo.begin(), writeTo.end(), func);
; 232  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 233  : }

	pop	ebp
	ret	0
??$?5W4SlotStatus@@@@YAAAVFDataStream@@AAV0@AAV?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@@Z ENDP ; operator>><enum SlotStatus>
_TEXT	ENDS
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4SlotStatus@@@Z:PROC ; operator<<
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Odtp
;	COMDAT ??$?6W4SlotStatus@@@@YAAAVFDataStream@@AAV0@ABV?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@@Z
_TEXT	SEGMENT
$T220654 = -68						; size = 8
$T220653 = -60						; size = 4
$T220652 = -56						; size = 4
$T220634 = -52						; size = 4
__ChkFirst$220647 = -48					; size = 4
__ChkLast$220648 = -44					; size = 4
$T220611 = -40						; size = 4
$T220602 = -36						; size = 4
$T220590 = -32						; size = 4
$T220592 = -28						; size = 4
$T220581 = -24						; size = 8
$T220580 = -16						; size = 4
$T220579 = -12						; size = 4
$T220578 = -8						; size = 8
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??$?6W4SlotStatus@@@@YAAAVFDataStream@@AAV0@ABV?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@@Z PROC ; operator<<<enum SlotStatus>, COMDAT

; 198  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H

; 199  : 	std::for_each(readFrom.begin(), readFrom.end(), SerializeFromSequenceContainer<const ElementType, const std::vector<ElementType> >(saveTo, readFrom));

	mov	eax, DWORD PTR _saveTo$[ebp]
	mov	DWORD PTR $T220578[ebp], eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	DWORD PTR $T220578[ebp+4], ecx
	mov	edx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR $T220592[ebp], ecx
	mov	edx, DWORD PTR $T220578[ebp]
	mov	DWORD PTR $T220590[ebp], edx
	lea	eax, DWORD PTR $T220592[ebp]
	push	eax
	mov	ecx, DWORD PTR $T220590[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T220602[ebp], edx
	mov	eax, DWORD PTR $T220602[ebp]
	mov	DWORD PTR $T220579[ebp], eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T220611[ebp], edx
	mov	eax, DWORD PTR $T220611[ebp]
	mov	DWORD PTR $T220580[ebp], eax
	mov	ecx, DWORD PTR $T220578[ebp]
	mov	DWORD PTR $T220654[ebp], ecx
	mov	edx, DWORD PTR $T220578[ebp+4]
	mov	DWORD PTR $T220654[ebp+4], edx
	mov	eax, DWORD PTR $T220579[ebp]
	mov	DWORD PTR $T220653[ebp], eax
	mov	ecx, DWORD PTR $T220580[ebp]
	mov	DWORD PTR $T220652[ebp], ecx
	mov	edx, DWORD PTR $T220652[ebp]
	mov	DWORD PTR __ChkFirst$220647[ebp], edx
	mov	eax, DWORD PTR $T220653[ebp]
	mov	DWORD PTR __ChkLast$220648[ebp], eax
	jmp	SHORT $LN24@operator@2
$LN18@operator@2:
	mov	ecx, DWORD PTR __ChkFirst$220647[ebp]
	add	ecx, 4
	mov	DWORD PTR __ChkFirst$220647[ebp], ecx
$LN24@operator@2:
	mov	edx, DWORD PTR __ChkFirst$220647[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __ChkLast$220648[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN17@operator@2
	mov	eax, DWORD PTR __ChkFirst$220647[ebp]
	mov	DWORD PTR $T220634[ebp], eax
	mov	ecx, DWORD PTR $T220634[ebp]
	push	ecx
	mov	edx, DWORD PTR $T220654[ebp]
	push	edx
	call	??6@YAAAVFDataStream@@AAV0@ABW4SlotStatus@@@Z ; operator<<
	add	esp, 8
	jmp	SHORT $LN18@operator@2
$LN17@operator@2:
	mov	eax, DWORD PTR $T220654[ebp]
	mov	DWORD PTR $T220581[ebp], eax
	mov	ecx, DWORD PTR $T220654[ebp+4]
	mov	DWORD PTR $T220581[ebp+4], ecx

; 200  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 201  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?6W4SlotStatus@@@@YAAAVFDataStream@@AAV0@ABV?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@@Z ENDP ; operator<<<enum SlotStatus>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R0?AVbad_alloc@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
xdata$x	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_Ebad_alloc@std@@UAEPAXI@Z ; std::bad_alloc::`vftable'
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
CONST	ENDS
;	COMDAT ??$_Allocate@W4SlotStatus@@@std@@YAPAW4SlotStatus@@IPAW41@@Z
_TEXT	SEGMENT
$T220661 = -16						; size = 4
$T220657 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@W4SlotStatus@@@std@@YAPAW4SlotStatus@@IPAW41@@Z PROC ; std::_Allocate<enum SlotStatus>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T220661[ebp], 0
	lea	eax, DWORD PTR $T220661[ebp]
	push	eax
	lea	ecx, DWORD PTR $T220657[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T220657[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T220657[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@W4SlotStatus@@@std@@YAPAW4SlotStatus@@IPAW41@@Z ENDP ; std::_Allocate<enum SlotStatus>
_TEXT	ENDS
PUBLIC	?push_back@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@QAEXABW4SlotStatus@@@Z ; std::vector<enum SlotStatus,std::allocator<enum SlotStatus> >::push_back
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4SlotStatus@@@Z:PROC ; operator>>
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$SerializeToSequenceContainer@W4SlotStatus@@V?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@@Z
_TEXT	SEGMENT
$T220695 = -40						; size = 4
$T220679 = -36						; size = 4
$T220849 = -32						; size = 4
$T220848 = -28						; size = 4
$T220847 = -24						; size = 4
$T220846 = -20						; size = 4
$T220845 = -16						; size = 4
_v$218720 = -12						; size = 4
_i$ = -8						; size = 4
_count$ = -4						; size = 4
_loadFrom$ = 8						; size = 4
_container$ = 12					; size = 4
??$SerializeToSequenceContainer@W4SlotStatus@@V?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@@Z PROC ; SerializeToSequenceContainer<enum SlotStatus,std::vector<enum SlotStatus,std::allocator<enum SlotStatus> > >, COMDAT

; 83   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 160				; 000000a0H

; 84   : 	container.clear();

	mov	eax, DWORD PTR _container$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T220679[ebp], ecx
	mov	edx, DWORD PTR $T220679[ebp]
	mov	DWORD PTR $T220846[ebp], edx
	mov	eax, DWORD PTR $T220846[ebp]
	mov	DWORD PTR $T220845[ebp], eax
	mov	ecx, DWORD PTR _container$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T220695[ebp], edx
	mov	eax, DWORD PTR $T220695[ebp]
	mov	DWORD PTR $T220848[ebp], eax
	mov	ecx, DWORD PTR $T220848[ebp]
	mov	DWORD PTR $T220847[ebp], ecx
	mov	edx, DWORD PTR $T220845[ebp]
	push	edx
	mov	eax, DWORD PTR $T220847[ebp]
	push	eax
	lea	ecx, DWORD PTR $T220849[ebp]
	push	ecx
	mov	ecx, DWORD PTR _container$[ebp]
	call	?erase@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@QAE?AV?$_Vector_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@V?$_Vector_const_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@0@Z ; std::vector<enum SlotStatus,std::allocator<enum SlotStatus> >::erase

; 85   : 	ContainerType::size_type count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 86   : 	loadFrom >> count;

	lea	edx, DWORD PTR _count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 87   : 	ContainerType::size_type i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 88   : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@SerializeT
$LN2@SerializeT:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@SerializeT:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _count$[ebp]
	jae	SHORT $LN4@SerializeT

; 89   : 	{
; 90   : 		ElementType v;
; 91   : 		loadFrom >> v;

	lea	edx, DWORD PTR _v$218720[ebp]
	push	edx
	mov	eax, DWORD PTR _loadFrom$[ebp]
	push	eax
	call	??5@YAAAVFDataStream@@AAV0@AAW4SlotStatus@@@Z ; operator>>
	add	esp, 8

; 92   : 		container.push_back(v);

	lea	ecx, DWORD PTR _v$218720[ebp]
	push	ecx
	mov	ecx, DWORD PTR _container$[ebp]
	call	?push_back@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@QAEXABW4SlotStatus@@@Z ; std::vector<enum SlotStatus,std::allocator<enum SlotStatus> >::push_back

; 93   : 	}

	jmp	SHORT $LN2@SerializeT
$LN4@SerializeT:

; 94   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$SerializeToSequenceContainer@W4SlotStatus@@V?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@@Z ENDP ; SerializeToSequenceContainer<enum SlotStatus,std::vector<enum SlotStatus,std::allocator<enum SlotStatus> > >
_TEXT	ENDS
PUBLIC	?insert@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@QAE?AV?$_Vector_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@V?$_Vector_const_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@ABW4SlotStatus@@@Z ; std::vector<enum SlotStatus,std::allocator<enum SlotStatus> >::insert
PUBLIC	??$_Uninit_fill_n@PAW4SlotStatus@@IW41@V?$allocator@W4SlotStatus@@@std@@@std@@YAXPAW4SlotStatus@@IABW41@AAV?$allocator@W4SlotStatus@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum SlotStatus *,unsigned int,enum SlotStatus,std::allocator<enum SlotStatus> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?push_back@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@QAEXABW4SlotStatus@@@Z
_TEXT	SEGMENT
tv129 = -64						; size = 4
_this$ = -60						; size = 4
$T221032 = -32						; size = 4
$T221022 = -28						; size = 4
$T221012 = -24						; size = 4
__Cat$221020 = -19					; size = 1
$T221018 = -18						; size = 1
$T221017 = -17						; size = 1
$T220989 = -16						; size = 4
$T220985 = -12						; size = 4
$T220984 = -8						; size = 4
$T220983 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@QAEXABW4SlotStatus@@@Z PROC ; std::vector<enum SlotStatus,std::allocator<enum SlotStatus> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T220989[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN9@push_back
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN7@push_back
$LN9@push_back:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv129[ebp], eax
$LN7@push_back:
	mov	ecx, DWORD PTR $T220989[ebp]
	cmp	ecx, DWORD PTR tv129[ebp]
	jae	SHORT $LN2@push_back

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T221022[ebp], eax
	mov	ecx, DWORD PTR $T221022[ebp]
	mov	DWORD PTR $T221012[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T221017[ebp], dl
	mov	al, BYTE PTR __Cat$221020[ebp]
	mov	BYTE PTR $T221018[ebp], al
	movzx	ecx, BYTE PTR $T221017[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T221018[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR $T221012[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAW4SlotStatus@@IW41@V?$allocator@W4SlotStatus@@@std@@@std@@YAXPAW4SlotStatus@@IABW41@AAV?$allocator@W4SlotStatus@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum SlotStatus *,unsigned int,enum SlotStatus,std::allocator<enum SlotStatus> >
	add	esp, 24					; 00000018H
	mov	eax, 1
	shl	eax, 2
	add	eax, DWORD PTR $T221022[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back
$LN2@push_back:

; 823  : 			insert(end(), _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T221032[ebp], eax
	mov	ecx, DWORD PTR $T221032[ebp]
	mov	DWORD PTR $T220984[ebp], ecx
	mov	edx, DWORD PTR $T220984[ebp]
	mov	DWORD PTR $T220983[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T220983[ebp]
	push	ecx
	lea	edx, DWORD PTR $T220985[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@QAE?AV?$_Vector_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@V?$_Vector_const_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@ABW4SlotStatus@@@Z ; std::vector<enum SlotStatus,std::allocator<enum SlotStatus> >::insert
$LN3@push_back:

; 824  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@QAEXABW4SlotStatus@@@Z ENDP ; std::vector<enum SlotStatus,std::allocator<enum SlotStatus> >::push_back
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@IABW4SlotStatus@@@Z ; std::vector<enum SlotStatus,std::allocator<enum SlotStatus> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@QAE?AV?$_Vector_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@V?$_Vector_const_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@ABW4SlotStatus@@@Z
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
__Tmp$221152 = -24					; size = 4
$T221135 = -20						; size = 4
$T221116 = -16						; size = 4
$T221103 = -12						; size = 4
$T221100 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@QAE?AV?$_Vector_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@V?$_Vector_const_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@ABW4SlotStatus@@@Z PROC ; std::vector<enum SlotStatus,std::allocator<enum SlotStatus> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	test	edx, edx
	jne	SHORT $LN3@insert
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert
$LN3@insert:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T221116[ebp], ecx
	mov	edx, DWORD PTR $T221116[ebp]
	mov	DWORD PTR $T221100[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	sub	eax, DWORD PTR $T221100[ebp]
	sar	eax, 2
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@IABW4SlotStatus@@@Z ; std::vector<enum SlotStatus,std::allocator<enum SlotStatus> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T221135[ebp], edx
	mov	eax, DWORD PTR $T221135[ebp]
	mov	DWORD PTR $T221103[ebp], eax
	mov	ecx, DWORD PTR $T221103[ebp]
	mov	DWORD PTR __Tmp$221152[ebp], ecx
	mov	edx, DWORD PTR __Off$[ebp]
	mov	eax, DWORD PTR __Tmp$221152[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR __Tmp$221152[ebp], ecx
	mov	edx, DWORD PTR __Tmp$221152[ebp]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@QAE?AV?$_Vector_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@V?$_Vector_const_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@ABW4SlotStatus@@@Z ENDP ; std::vector<enum SlotStatus,std::allocator<enum SlotStatus> >::insert
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAW4SlotStatus@@PAW41@V?$allocator@W4SlotStatus@@@std@@@stdext@@YAPAW4SlotStatus@@PAW41@00AAV?$allocator@W4SlotStatus@@@std@@@Z ; stdext::unchecked_uninitialized_copy<enum SlotStatus *,enum SlotStatus *,std::allocator<enum SlotStatus> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@IABW4SlotStatus@@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@IABW4SlotStatus@@@Z$2
__catchsym$?_Insert_n@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@IABW4SlotStatus@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@IABW4SlotStatus@@@Z$0
__unwindtable$?_Insert_n@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@IABW4SlotStatus@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@IABW4SlotStatus@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@IABW4SlotStatus@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@IABW4SlotStatus@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@IABW4SlotStatus@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@IABW4SlotStatus@@@Z$5
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@IABW4SlotStatus@@@Z$6
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@IABW4SlotStatus@@@Z
_TEXT	SEGMENT
tv84 = -424						; size = 4
tv302 = -420						; size = 4
tv288 = -416						; size = 4
tv280 = -412						; size = 4
_this$ = -408						; size = 4
$T221841 = -404						; size = 4
$T221833 = -400						; size = 4
$T221832 = -396						; size = 4
$T221809 = -390						; size = 1
$T221808 = -389						; size = 1
$T221807 = -388						; size = 4
$T221806 = -384						; size = 4
$T221794 = -377						; size = 1
$T221793 = -376						; size = 4
$T221792 = -372						; size = 4
$T221791 = -368						; size = 4
__Cat$221825 = -364					; size = 1
$T221822 = -363						; size = 1
$T221821 = -362						; size = 1
__Cat$221816 = -360					; size = 1
$T221813 = -359						; size = 1
$T221812 = -358						; size = 1
$T221811 = -357						; size = 1
$T221766 = -356						; size = 4
$T221747 = -352						; size = 4
$T221730 = -345						; size = 1
$T221729 = -344						; size = 4
$T221719 = -340						; size = 4
$T221718 = -336						; size = 4
__Cat$221761 = -330					; size = 1
$T221758 = -329						; size = 1
$T221757 = -328						; size = 1
__Cat$221754 = -327					; size = 1
$T221751 = -326						; size = 1
$T221750 = -325						; size = 1
$T221694 = -324						; size = 4
$T221686 = -320						; size = 4
$T221678 = -316						; size = 4
$T221660 = -312						; size = 4
$T221659 = -308						; size = 4
$T221643 = -304						; size = 4
__Cat$221667 = -298					; size = 1
$T221664 = -297						; size = 1
$T221617 = -296						; size = 4
$T221616 = -292						; size = 4
$T221606 = -288						; size = 4
__Cat$221613 = -283					; size = 1
$T221610 = -282						; size = 1
$T221609 = -281						; size = 1
$T221590 = -280						; size = 4
$T221571 = -276						; size = 4
$T221554 = -269						; size = 1
$T221553 = -268						; size = 4
$T221543 = -264						; size = 4
$T221542 = -260						; size = 4
__Cat$221585 = -254					; size = 1
$T221582 = -253						; size = 1
$T221581 = -252						; size = 1
__Cat$221578 = -251					; size = 1
$T221575 = -250						; size = 1
$T221574 = -249						; size = 1
$T221518 = -248						; size = 4
$T221517 = -244						; size = 4
$T221513 = -240						; size = 4
$T221512 = -236						; size = 4
$T221494 = -232						; size = 4
$T221493 = -228						; size = 4
$T221477 = -224						; size = 4
__Cat$221500 = -218					; size = 1
$T221497 = -217						; size = 1
$T221428 = -216						; size = 4
$T221427 = -212						; size = 4
$T221411 = -208						; size = 4
__Cat$221434 = -202					; size = 1
$T221431 = -201						; size = 1
$T221368 = -200						; size = 4
$T221367 = -196						; size = 4
$T221351 = -192						; size = 4
__Cat$221374 = -186					; size = 1
$T221371 = -185						; size = 1
$T221325 = -184						; size = 4
$T221313 = -180						; size = 4
$T221303 = -173						; size = 1
$T221302 = -172						; size = 4
__Cat$221320 = -167					; size = 1
$T221317 = -166						; size = 1
$T221316 = -165						; size = 1
$T221290 = -164						; size = 4
$T221278 = -160						; size = 4
$T221268 = -153						; size = 1
$T221267 = -152						; size = 4
__Cat$221285 = -147					; size = 1
$T221282 = -146						; size = 1
$T221281 = -145						; size = 1
$T221255 = -144						; size = 4
$T221245 = -140						; size = 4
__Cat$221252 = -135					; size = 1
$T221249 = -134						; size = 1
$T221248 = -133						; size = 1
__Count$221217 = -120					; size = 4
__Count$221191 = -48					; size = 4
__Tmp$218856 = -44					; size = 4
__Oldend$218857 = -40					; size = 4
__Tmp$218846 = -36					; size = 4
__Ncopied$218833 = -32					; size = 4
__Newvec$218831 = -28					; size = 4
__Whereoff$218832 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@IABW4SlotStatus@@@Z PROC ; std::vector<enum SlotStatus,std::allocator<enum SlotStatus> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@IABW4SlotStatus@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 408				; 00000198H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN29@Insert_n
	mov	DWORD PTR tv280[ebp], 0
	jmp	SHORT $LN27@Insert_n
$LN29@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv280[ebp], eax
$LN27@Insert_n:
	mov	ecx, DWORD PTR tv280[ebp]
	mov	DWORD PTR __Capacity$[ebp], ecx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n
	jmp	$LN16@Insert_n
$LN14@Insert_n:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$221191[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$221191[ebp], 0
	jbe	SHORT $LN35@Insert_n
	mov	edx, DWORD PTR __Count$221191[ebp]
	mov	DWORD PTR tv288[ebp], edx
	jmp	SHORT $LN37@Insert_n
$LN35@Insert_n:
	mov	DWORD PTR tv288[ebp], 1
$LN37@Insert_n:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	eax, DWORD PTR tv288[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN42@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@KAXXZ ; std::vector<enum SlotStatus,std::allocator<enum SlotStatus> >::_Xlen
	jmp	$LN16@Insert_n

; 1167 : 		else if (_Capacity < size() + _Count)

$LN42@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$221217[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$221217[ebp], 0
	jbe	SHORT $LN48@Insert_n
	mov	ecx, DWORD PTR __Count$221217[ebp]
	mov	DWORD PTR tv302[ebp], ecx
	jmp	SHORT $LN44@Insert_n
$LN48@Insert_n:
	mov	DWORD PTR tv302[ebp], 1
$LN44@Insert_n:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	mov	eax, DWORD PTR tv302[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	add	ecx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], ecx
$LN18@Insert_n:
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1171 : 			if (_Capacity < size() + _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], edx
	jae	SHORT $LN54@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN54@Insert_n:
	push	0
	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	call	??$_Allocate@W4SlotStatus@@@std@@YAPAW4SlotStatus@@IPAW41@@Z ; std::_Allocate<enum SlotStatus>
	add	esp, 8
	mov	DWORD PTR __Newvec$218831[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR __Whereoff$218832[ebp], edx

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$218833[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Whereoff$218832[ebp]
	mov	ecx, DWORD PTR __Newvec$218831[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T221255[ebp], edx
	mov	eax, DWORD PTR $T221255[ebp]
	mov	DWORD PTR $T221245[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T221248[ebp], cl
	mov	dl, BYTE PTR __Cat$221252[ebp]
	mov	BYTE PTR $T221249[ebp], dl
	movzx	eax, BYTE PTR $T221248[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T221249[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T221245[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAW4SlotStatus@@IW41@V?$allocator@W4SlotStatus@@@std@@@std@@YAXPAW4SlotStatus@@IABW41@AAV?$allocator@W4SlotStatus@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum SlotStatus *,unsigned int,enum SlotStatus,std::allocator<enum SlotStatus> >
	add	esp, 24					; 00000018H

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$218833[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$218833[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T221290[ebp], edx
	mov	eax, DWORD PTR __Newvec$218831[ebp]
	mov	DWORD PTR $T221278[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T221281[ebp], cl
	mov	dl, BYTE PTR __Cat$221285[ebp]
	mov	BYTE PTR $T221282[ebp], dl
	mov	al, BYTE PTR $T221281[ebp]
	mov	BYTE PTR $T221268[ebp], al
	mov	ecx, DWORD PTR $T221278[ebp]
	mov	DWORD PTR $T221267[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T221267[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T221290[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@PAW4SlotStatus@@PAW41@V?$allocator@W4SlotStatus@@@std@@@stdext@@YAPAW4SlotStatus@@PAW41@00AAV?$allocator@W4SlotStatus@@@std@@@Z ; stdext::unchecked_uninitialized_copy<enum SlotStatus *,enum SlotStatus *,std::allocator<enum SlotStatus> >
	add	esp, 16					; 00000010H

; 1182 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$218833[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$218833[ebp], eax

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T221325[ebp], edx
	mov	eax, DWORD PTR __Whereoff$218832[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Newvec$218831[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T221313[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T221316[ebp], al
	mov	cl, BYTE PTR __Cat$221320[ebp]
	mov	BYTE PTR $T221317[ebp], cl
	mov	dl, BYTE PTR $T221316[ebp]
	mov	BYTE PTR $T221303[ebp], dl
	mov	eax, DWORD PTR $T221313[ebp]
	mov	DWORD PTR $T221302[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T221302[ebp]
	push	edx
	mov	eax, DWORD PTR $T221325[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	call	??$unchecked_uninitialized_copy@PAW4SlotStatus@@PAW41@V?$allocator@W4SlotStatus@@@std@@@stdext@@YAPAW4SlotStatus@@PAW41@00AAV?$allocator@W4SlotStatus@@@std@@@Z ; stdext::unchecked_uninitialized_copy<enum SlotStatus *,enum SlotStatus *,std::allocator<enum SlotStatus> >
	add	esp, 16					; 00000010H
	jmp	$LN19@Insert_n
__catch$?_Insert_n@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@IABW4SlotStatus@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$218833[ebp], 1
	jle	SHORT $LN7@Insert_n

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	edx, DWORD PTR __Whereoff$218832[ebp]
	mov	eax, DWORD PTR __Newvec$218831[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T221368[ebp], ecx
	mov	edx, DWORD PTR __Newvec$218831[ebp]
	mov	DWORD PTR $T221367[ebp], edx
	mov	al, BYTE PTR __Cat$221374[ebp]
	mov	BYTE PTR $T221371[ebp], al
	mov	ecx, DWORD PTR $T221367[ebp]
	mov	DWORD PTR $T221351[ebp], ecx
	jmp	SHORT $LN91@Insert_n
$LN90@Insert_n:
	mov	edx, DWORD PTR $T221351[ebp]
	add	edx, 4
	mov	DWORD PTR $T221351[ebp], edx
$LN91@Insert_n:
	mov	eax, DWORD PTR $T221351[ebp]
	cmp	eax, DWORD PTR $T221368[ebp]
	je	SHORT $LN7@Insert_n
	jmp	SHORT $LN90@Insert_n
$LN7@Insert_n:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$218833[ebp], 0
	jle	SHORT $LN6@Insert_n

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Whereoff$218832[ebp]
	mov	edx, DWORD PTR __Newvec$218831[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T221428[ebp], edx
	mov	eax, DWORD PTR __Whereoff$218832[ebp]
	mov	ecx, DWORD PTR __Newvec$218831[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T221427[ebp], edx
	mov	al, BYTE PTR __Cat$221434[ebp]
	mov	BYTE PTR $T221431[ebp], al
	mov	ecx, DWORD PTR $T221427[ebp]
	mov	DWORD PTR $T221411[ebp], ecx
	jmp	SHORT $LN106@Insert_n
$LN105@Insert_n:
	mov	edx, DWORD PTR $T221411[ebp]
	add	edx, 4
	mov	DWORD PTR $T221411[ebp], edx
$LN106@Insert_n:
	mov	eax, DWORD PTR $T221411[ebp]
	cmp	eax, DWORD PTR $T221428[ebp]
	je	SHORT $LN6@Insert_n
	jmp	SHORT $LN105@Insert_n
$LN6@Insert_n:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	ecx, DWORD PTR __Newvec$218831[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN115@Insert_n
	ret	0
$LN19@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN115@Insert_n:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], ecx

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN5@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T221513[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T221512[ebp], eax
	mov	ecx, DWORD PTR $T221513[ebp]
	mov	DWORD PTR $T221494[ebp], ecx
	mov	edx, DWORD PTR $T221512[ebp]
	mov	DWORD PTR $T221493[ebp], edx
	mov	al, BYTE PTR __Cat$221500[ebp]
	mov	BYTE PTR $T221497[ebp], al
	mov	ecx, DWORD PTR $T221493[ebp]
	mov	DWORD PTR $T221477[ebp], ecx
	jmp	SHORT $LN125@Insert_n
$LN124@Insert_n:
	mov	edx, DWORD PTR $T221477[ebp]
	add	edx, 4
	mov	DWORD PTR $T221477[ebp], edx
$LN125@Insert_n:
	mov	eax, DWORD PTR $T221477[ebp]
	cmp	eax, DWORD PTR $T221494[ebp]
	je	SHORT $LN117@Insert_n
	jmp	SHORT $LN124@Insert_n
$LN117@Insert_n:

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR $T221518[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T221517[ebp], edx
	mov	eax, DWORD PTR $T221517[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	ecx, DWORD PTR __Capacity$[ebp]
	mov	edx, DWORD PTR __Newvec$218831[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Newvec$218831[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newvec$218831[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	$LN16@Insert_n
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	sar	eax, 2
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$218846[ebp], edx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T221590[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T221571[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T221574[ebp], dl
	mov	al, BYTE PTR __Cat$221578[ebp]
	mov	BYTE PTR $T221575[ebp], al
	mov	cl, BYTE PTR $T221574[ebp]
	mov	BYTE PTR $T221554[ebp], cl
	mov	edx, DWORD PTR $T221571[ebp]
	mov	DWORD PTR $T221553[ebp], edx
	mov	eax, DWORD PTR $T221553[ebp]
	mov	DWORD PTR $T221543[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T221542[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T221581[ebp], dl
	mov	al, BYTE PTR __Cat$221585[ebp]
	mov	BYTE PTR $T221582[ebp], al
	movzx	ecx, BYTE PTR $T221581[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T221582[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T221543[ebp]
	push	ecx
	mov	edx, DWORD PTR $T221590[ebp]
	push	edx
	mov	eax, DWORD PTR $T221542[ebp]
	push	eax
	call	??$_Uninit_copy@PAW4SlotStatus@@PAW41@V?$allocator@W4SlotStatus@@@std@@@std@@YAPAW4SlotStatus@@PAW41@00AAV?$allocator@W4SlotStatus@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum SlotStatus *,enum SlotStatus *,std::allocator<enum SlotStatus> >
	add	esp, 24					; 00000018H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 2
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	mov	DWORD PTR $T221617[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T221616[ebp], edx
	mov	eax, DWORD PTR $T221616[ebp]
	mov	DWORD PTR $T221606[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T221609[ebp], cl
	mov	dl, BYTE PTR __Cat$221613[ebp]
	mov	BYTE PTR $T221610[ebp], dl
	movzx	eax, BYTE PTR $T221609[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T221610[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	lea	eax, DWORD PTR __Tmp$218846[ebp]
	push	eax
	mov	ecx, DWORD PTR $T221617[ebp]
	push	ecx
	mov	edx, DWORD PTR $T221606[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAW4SlotStatus@@IW41@V?$allocator@W4SlotStatus@@@std@@@std@@YAXPAW4SlotStatus@@IABW41@AAV?$allocator@W4SlotStatus@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum SlotStatus *,unsigned int,enum SlotStatus,std::allocator<enum SlotStatus> >
	add	esp, 24					; 00000018H
	jmp	SHORT $LN21@Insert_n
__catch$?_Insert_n@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@IABW4SlotStatus@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T221678[ebp], eax
	mov	ecx, DWORD PTR $T221678[ebp]
	mov	DWORD PTR $T221660[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T221659[ebp], ecx
	mov	dl, BYTE PTR __Cat$221667[ebp]
	mov	BYTE PTR $T221664[ebp], dl
	mov	eax, DWORD PTR $T221659[ebp]
	mov	DWORD PTR $T221643[ebp], eax
	jmp	SHORT $LN160@Insert_n
$LN159@Insert_n:
	mov	ecx, DWORD PTR $T221643[ebp]
	add	ecx, 4
	mov	DWORD PTR $T221643[ebp], ecx
$LN160@Insert_n:
	mov	edx, DWORD PTR $T221643[ebp]
	cmp	edx, DWORD PTR $T221660[ebp]
	je	SHORT $LN152@Insert_n
	jmp	SHORT $LN159@Insert_n
$LN152@Insert_n:

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@IABW4SlotStatus@@@Z$3
	ret	0
$LN21@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@IABW4SlotStatus@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, edx
	mov	DWORD PTR $T221694[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T221686[ebp], edx
	jmp	SHORT $LN171@Insert_n
$LN170@Insert_n:
	mov	eax, DWORD PTR $T221686[ebp]
	add	eax, 4
	mov	DWORD PTR $T221686[ebp], eax
$LN171@Insert_n:
	mov	ecx, DWORD PTR $T221686[ebp]
	cmp	ecx, DWORD PTR $T221694[ebp]
	je	SHORT $LN167@Insert_n
	mov	edx, DWORD PTR $T221686[ebp]
	mov	eax, DWORD PTR __Tmp$218846[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN170@Insert_n
$LN167@Insert_n:

; 1232 : 			}
; 1233 : 		else

	jmp	$LN16@Insert_n
$LN3@Insert_n:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$218856[ebp], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Oldend$218857[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T221766[ebp], eax
	mov	ecx, DWORD PTR $T221766[ebp]
	mov	DWORD PTR $T221747[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T221750[ebp], dl
	mov	al, BYTE PTR __Cat$221754[ebp]
	mov	BYTE PTR $T221751[ebp], al
	mov	cl, BYTE PTR $T221750[ebp]
	mov	BYTE PTR $T221730[ebp], cl
	mov	edx, DWORD PTR $T221747[ebp]
	mov	DWORD PTR $T221729[ebp], edx
	mov	eax, DWORD PTR $T221729[ebp]
	mov	DWORD PTR $T221719[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR __Oldend$218857[ebp]
	sub	edx, ecx
	mov	DWORD PTR $T221718[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T221757[ebp], al
	mov	cl, BYTE PTR __Cat$221761[ebp]
	mov	BYTE PTR $T221758[ebp], cl
	movzx	edx, BYTE PTR $T221757[ebp]
	push	edx
	movzx	eax, BYTE PTR $T221758[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T221719[ebp]
	push	edx
	mov	eax, DWORD PTR __Oldend$218857[ebp]
	push	eax
	mov	ecx, DWORD PTR $T221718[ebp]
	push	ecx
	call	??$_Uninit_copy@PAW4SlotStatus@@PAW41@V?$allocator@W4SlotStatus@@@std@@@std@@YAPAW4SlotStatus@@PAW41@00AAV?$allocator@W4SlotStatus@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum SlotStatus *,enum SlotStatus *,std::allocator<enum SlotStatus> >
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, DWORD PTR __Oldend$218857[ebp]
	mov	DWORD PTR $T221833[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T221832[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T221811[ebp], dl
	mov	al, BYTE PTR __Cat$221816[ebp]
	mov	BYTE PTR $T221812[ebp], al
	mov	cl, BYTE PTR $T221811[ebp]
	mov	BYTE PTR $T221809[ebp], cl
	mov	dl, BYTE PTR $T221813[ebp]
	mov	BYTE PTR $T221808[ebp], dl
	mov	eax, DWORD PTR $T221833[ebp]
	mov	DWORD PTR $T221807[ebp], eax
	mov	ecx, DWORD PTR $T221832[ebp]
	mov	DWORD PTR $T221806[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T221821[ebp], dl
	mov	al, BYTE PTR __Cat$221825[ebp]
	mov	BYTE PTR $T221822[ebp], al
	mov	cl, BYTE PTR $T221821[ebp]
	mov	BYTE PTR $T221794[ebp], cl
	mov	edx, DWORD PTR $T221807[ebp]
	mov	DWORD PTR $T221793[ebp], edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Oldend$218857[ebp]
	sub	ecx, eax
	mov	DWORD PTR $T221792[ebp], ecx
	mov	edx, DWORD PTR $T221806[ebp]
	mov	DWORD PTR $T221791[ebp], edx
$LN197@Insert_n:
	mov	eax, DWORD PTR $T221791[ebp]
	cmp	eax, DWORD PTR $T221792[ebp]
	je	SHORT $LN186@Insert_n
	mov	ecx, DWORD PTR $T221792[ebp]
	sub	ecx, 4
	mov	DWORD PTR $T221792[ebp], ecx
	mov	edx, DWORD PTR $T221793[ebp]
	sub	edx, 4
	mov	DWORD PTR $T221793[ebp], edx
	mov	eax, DWORD PTR $T221793[ebp]
	mov	ecx, DWORD PTR $T221792[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN197@Insert_n
$LN186@Insert_n:

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T221841[ebp], eax
	jmp	SHORT $LN204@Insert_n
$LN203@Insert_n:
	mov	ecx, DWORD PTR $T221841[ebp]
	add	ecx, 4
	mov	DWORD PTR $T221841[ebp], ecx
$LN204@Insert_n:
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	cmp	DWORD PTR $T221841[ebp], ecx
	je	SHORT $LN16@Insert_n
	mov	edx, DWORD PTR $T221841[ebp]
	mov	eax, DWORD PTR __Tmp$218856[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN203@Insert_n
$LN16@Insert_n:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@IABW4SlotStatus@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-428]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@IABW4SlotStatus@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4SlotStatus@@V?$allocator@W4SlotStatus@@@std@@@2@IABW4SlotStatus@@@Z ENDP ; std::vector<enum SlotStatus,std::allocator<enum SlotStatus> >::_Insert_n
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAW4SlotStatus@@PAW41@V?$allocator@W4SlotStatus@@@std@@@stdext@@YAPAW4SlotStatus@@PAW41@00AAV?$allocator@W4SlotStatus@@@std@@@Z
_TEXT	SEGMENT
__Cat$221866 = -3					; size = 1
$T221863 = -2						; size = 1
$T221862 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAW4SlotStatus@@PAW41@V?$allocator@W4SlotStatus@@@std@@@stdext@@YAPAW4SlotStatus@@PAW41@00AAV?$allocator@W4SlotStatus@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<enum SlotStatus *,enum SlotStatus *,std::allocator<enum SlotStatus> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T221862[ebp], al
	mov	cl, BYTE PTR __Cat$221866[ebp]
	mov	BYTE PTR $T221863[ebp], cl
	movzx	edx, BYTE PTR $T221862[ebp]
	push	edx
	movzx	eax, BYTE PTR $T221863[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninit_copy@PAW4SlotStatus@@PAW41@V?$allocator@W4SlotStatus@@@std@@@std@@YAPAW4SlotStatus@@PAW41@00AAV?$allocator@W4SlotStatus@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum SlotStatus *,enum SlotStatus *,std::allocator<enum SlotStatus> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAW4SlotStatus@@PAW41@V?$allocator@W4SlotStatus@@@std@@@stdext@@YAPAW4SlotStatus@@PAW41@00AAV?$allocator@W4SlotStatus@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<enum SlotStatus *,enum SlotStatus *,std::allocator<enum SlotStatus> >
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAW4SlotStatus@@PAW41@V?$allocator@W4SlotStatus@@@std@@@std@@YAPAW4SlotStatus@@PAW41@00AAV?$allocator@W4SlotStatus@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAW4SlotStatus@@PAW41@V?$allocator@W4SlotStatus@@@std@@@std@@YAPAW4SlotStatus@@PAW41@00AAV?$allocator@W4SlotStatus@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAW4SlotStatus@@PAW41@V?$allocator@W4SlotStatus@@@std@@@std@@YAPAW4SlotStatus@@PAW41@00AAV?$allocator@W4SlotStatus@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAW4SlotStatus@@PAW41@V?$allocator@W4SlotStatus@@@std@@@std@@YAPAW4SlotStatus@@PAW41@00AAV?$allocator@W4SlotStatus@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAW4SlotStatus@@PAW41@V?$allocator@W4SlotStatus@@@std@@@std@@YAPAW4SlotStatus@@PAW41@00AAV?$allocator@W4SlotStatus@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAW4SlotStatus@@PAW41@V?$allocator@W4SlotStatus@@@std@@@std@@YAPAW4SlotStatus@@PAW41@00AAV?$allocator@W4SlotStatus@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAW4SlotStatus@@PAW41@V?$allocator@W4SlotStatus@@@std@@@std@@YAPAW4SlotStatus@@PAW41@00AAV?$allocator@W4SlotStatus@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAW4SlotStatus@@PAW41@V?$allocator@W4SlotStatus@@@std@@@std@@YAPAW4SlotStatus@@PAW41@00AAV?$allocator@W4SlotStatus@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAW4SlotStatus@@PAW41@V?$allocator@W4SlotStatus@@@std@@@std@@YAPAW4SlotStatus@@PAW41@00AAV?$allocator@W4SlotStatus@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv83 = -32						; size = 4
$T221892 = -28						; size = 4
__Vptr$221898 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAW4SlotStatus@@PAW41@V?$allocator@W4SlotStatus@@@std@@@std@@YAPAW4SlotStatus@@PAW41@00AAV?$allocator@W4SlotStatus@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<enum SlotStatus *,enum SlotStatus *,std::allocator<enum SlotStatus> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAW4SlotStatus@@PAW41@V?$allocator@W4SlotStatus@@@std@@@std@@YAPAW4SlotStatus@@PAW41@00AAV?$allocator@W4SlotStatus@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop
$LN5@Uninit_cop:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 4
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 4
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$221898[ebp], ecx
	mov	edx, DWORD PTR __Vptr$221898[ebp]
	mov	DWORD PTR $T221892[ebp], edx
	cmp	DWORD PTR $T221892[ebp], 0
	je	SHORT $LN18@Uninit_cop
	mov	eax, DWORD PTR $T221892[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR $T221892[ebp]
	mov	DWORD PTR tv83[ebp], eax
	jmp	SHORT $LN14@Uninit_cop
$LN18@Uninit_cop:
	mov	DWORD PTR tv83[ebp], 0
$LN14@Uninit_cop:
	jmp	SHORT $LN5@Uninit_cop
$LN4@Uninit_cop:
	jmp	SHORT $LN10@Uninit_cop
__catch$??$_Uninit_copy@PAW4SlotStatus@@PAW41@V?$allocator@W4SlotStatus@@@std@@@std@@YAPAW4SlotStatus@@PAW41@00AAV?$allocator@W4SlotStatus@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop
$LN2@Uninit_cop:
	mov	ecx, DWORD PTR __Next$[ebp]
	add	ecx, 4
	mov	DWORD PTR __Next$[ebp], ecx
$LN3@Uninit_cop:
	mov	edx, DWORD PTR __Next$[ebp]
	cmp	edx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop

; 134  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_cop
$LN1@Uninit_cop:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAW4SlotStatus@@PAW41@V?$allocator@W4SlotStatus@@@std@@@std@@YAPAW4SlotStatus@@PAW41@00AAV?$allocator@W4SlotStatus@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAW4SlotStatus@@PAW41@V?$allocator@W4SlotStatus@@@std@@@std@@YAPAW4SlotStatus@@PAW41@00AAV?$allocator@W4SlotStatus@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAW4SlotStatus@@PAW41@V?$allocator@W4SlotStatus@@@std@@@std@@YAPAW4SlotStatus@@PAW41@00AAV?$allocator@W4SlotStatus@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAW4SlotStatus@@PAW41@V?$allocator@W4SlotStatus@@@std@@@std@@YAPAW4SlotStatus@@PAW41@00AAV?$allocator@W4SlotStatus@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAW4SlotStatus@@PAW41@V?$allocator@W4SlotStatus@@@std@@@std@@YAPAW4SlotStatus@@PAW41@00AAV?$allocator@W4SlotStatus@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<enum SlotStatus *,enum SlotStatus *,std::allocator<enum SlotStatus> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAW4SlotStatus@@IW41@V?$allocator@W4SlotStatus@@@std@@@std@@YAXPAW4SlotStatus@@IABW41@AAV?$allocator@W4SlotStatus@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAW4SlotStatus@@IW41@V?$allocator@W4SlotStatus@@@std@@@std@@YAXPAW4SlotStatus@@IABW41@AAV?$allocator@W4SlotStatus@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAW4SlotStatus@@IW41@V?$allocator@W4SlotStatus@@@std@@@std@@YAXPAW4SlotStatus@@IABW41@AAV?$allocator@W4SlotStatus@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAW4SlotStatus@@IW41@V?$allocator@W4SlotStatus@@@std@@@std@@YAXPAW4SlotStatus@@IABW41@AAV?$allocator@W4SlotStatus@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAW4SlotStatus@@IW41@V?$allocator@W4SlotStatus@@@std@@@std@@YAXPAW4SlotStatus@@IABW41@AAV?$allocator@W4SlotStatus@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_fill_n@PAW4SlotStatus@@IW41@V?$allocator@W4SlotStatus@@@std@@@std@@YAXPAW4SlotStatus@@IABW41@AAV?$allocator@W4SlotStatus@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAW4SlotStatus@@IW41@V?$allocator@W4SlotStatus@@@std@@@std@@YAXPAW4SlotStatus@@IABW41@AAV?$allocator@W4SlotStatus@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAW4SlotStatus@@IW41@V?$allocator@W4SlotStatus@@@std@@@std@@YAXPAW4SlotStatus@@IABW41@AAV?$allocator@W4SlotStatus@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAW4SlotStatus@@IW41@V?$allocator@W4SlotStatus@@@std@@@std@@YAXPAW4SlotStatus@@IABW41@AAV?$allocator@W4SlotStatus@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv83 = -32						; size = 4
$T221941 = -28						; size = 4
__Vptr$221947 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAW4SlotStatus@@IW41@V?$allocator@W4SlotStatus@@@std@@@std@@YAXPAW4SlotStatus@@IABW41@AAV?$allocator@W4SlotStatus@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<enum SlotStatus *,unsigned int,enum SlotStatus,std::allocator<enum SlotStatus> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAW4SlotStatus@@IW41@V?$allocator@W4SlotStatus@@@std@@@std@@YAXPAW4SlotStatus@@IABW41@AAV?$allocator@W4SlotStatus@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil
$LN5@Uninit_fil:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 4
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Vptr$221947[ebp], eax
	mov	ecx, DWORD PTR __Vptr$221947[ebp]
	mov	DWORD PTR $T221941[ebp], ecx
	cmp	DWORD PTR $T221941[ebp], 0
	je	SHORT $LN18@Uninit_fil
	mov	edx, DWORD PTR $T221941[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T221941[ebp]
	mov	DWORD PTR tv83[ebp], edx
	jmp	SHORT $LN14@Uninit_fil
$LN18@Uninit_fil:
	mov	DWORD PTR tv83[ebp], 0
$LN14@Uninit_fil:
	jmp	SHORT $LN5@Uninit_fil
$LN4@Uninit_fil:
	jmp	SHORT $LN10@Uninit_fil
__catch$??$_Uninit_fill_n@PAW4SlotStatus@@IW41@V?$allocator@W4SlotStatus@@@std@@@std@@YAXPAW4SlotStatus@@IABW41@AAV?$allocator@W4SlotStatus@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil
$LN2@Uninit_fil:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 4
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_fil:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil

; 407  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_fil
$LN1@Uninit_fil:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil
	ret	0
$LN10@Uninit_fil:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAW4SlotStatus@@IW41@V?$allocator@W4SlotStatus@@@std@@@std@@YAXPAW4SlotStatus@@IABW41@AAV?$allocator@W4SlotStatus@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAW4SlotStatus@@IW41@V?$allocator@W4SlotStatus@@@std@@@std@@YAXPAW4SlotStatus@@IABW41@AAV?$allocator@W4SlotStatus@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAW4SlotStatus@@IW41@V?$allocator@W4SlotStatus@@@std@@@std@@YAXPAW4SlotStatus@@IABW41@AAV?$allocator@W4SlotStatus@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<enum SlotStatus *,unsigned int,enum SlotStatus,std::allocator<enum SlotStatus> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 34   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 36   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar@2
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@

; 110  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	edx, DWORD PTR ___flags$[ebp]
	and	edx, 1
	je	SHORT $LN1@scalar@3
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0length_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
; Function compile flags: /Odtp
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
END
