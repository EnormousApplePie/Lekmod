; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvPlotManager.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??0CvSparseIDInfoGrid@@QAE@IIPAV?$FObjectPool@VCvIDInfoFixedVector@@@@@Z ; CvSparseIDInfoGrid::CvSparseIDInfoGrid
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	_memset:PROC
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplotmanager.cpp
;	COMDAT ??0CvSparseIDInfoGrid@@QAE@IIPAV?$FObjectPool@VCvIDInfoFixedVector@@@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T217897 = -4						; size = 4
_uiWidth$ = 8						; size = 4
_uiHeight$ = 12						; size = 4
_pkAllocator$ = 16					; size = 4
??0CvSparseIDInfoGrid@@QAE@IIPAV?$FObjectPool@VCvIDInfoFixedVector@@@@@Z PROC ; CvSparseIDInfoGrid::CvSparseIDInfoGrid, COMDAT
; _this$ = ecx

; 18   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 19   : 	m_uiWidth = uiWidth;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiWidth$[ebp]
	mov	DWORD PTR [eax], ecx

; 20   : 	m_uiHeight = uiHeight;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiHeight$[ebp]
	mov	DWORD PTR [edx+4], eax

; 21   : 	m_uiMaxIndex = uiWidth * uiHeight;

	mov	ecx, DWORD PTR _uiWidth$[ebp]
	imul	ecx, DWORD PTR _uiHeight$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 22   : 	m_uiNumAllocated = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 23   : 
; 24   : 	m_paEntries = FNEW(CvIDInfoFixedVector*[m_uiMaxIndex], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T217897[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T217897[ebp]
	mov	DWORD PTR [eax+16], ecx

; 25   : 	memset( &m_paEntries[0], 0, sizeof(CvIDInfoFixedVector*) * m_uiMaxIndex);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	shl	eax, 2
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 26   : 
; 27   : 	m_pkAllocator = pkAllocator;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pkAllocator$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 28   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0CvSparseIDInfoGrid@@QAE@IIPAV?$FObjectPool@VCvIDInfoFixedVector@@@@@Z ENDP ; CvSparseIDInfoGrid::CvSparseIDInfoGrid
_TEXT	ENDS
PUBLIC	?Release@?$FObjectPool@VCvIDInfoFixedVector@@@@QAEXPAVCvIDInfoFixedVector@@@Z ; FObjectPool<CvIDInfoFixedVector>::Release
PUBLIC	??1CvSparseIDInfoGrid@@QAE@XZ			; CvSparseIDInfoGrid::~CvSparseIDInfoGrid
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Odtp
;	COMDAT ??1CvSparseIDInfoGrid@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T217901 = -12						; size = 4
_uiIndex$216669 = -8					; size = 4
_pkEntry$216668 = -4					; size = 4
??1CvSparseIDInfoGrid@@QAE@XZ PROC			; CvSparseIDInfoGrid::~CvSparseIDInfoGrid, COMDAT
; _this$ = ecx

; 32   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 33   : 	if (m_paEntries)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN5@CvSparseID

; 34   : 	{
; 35   : 		CvIDInfoFixedVector** pkEntry = m_paEntries;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _pkEntry$216668[ebp], edx

; 36   : 		for (uint uiIndex = m_uiMaxIndex; --uiIndex;)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _uiIndex$216669[ebp], ecx
$LN3@CvSparseID:
	mov	edx, DWORD PTR _uiIndex$216669[ebp]
	sub	edx, 1
	mov	DWORD PTR _uiIndex$216669[ebp], edx
	je	SHORT $LN2@CvSparseID

; 37   : 		{
; 38   : 			if (*pkEntry)

	mov	eax, DWORD PTR _pkEntry$216668[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@CvSparseID

; 39   : 				m_pkAllocator->Release(*pkEntry);

	mov	ecx, DWORD PTR _pkEntry$216668[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	call	?Release@?$FObjectPool@VCvIDInfoFixedVector@@@@QAEXPAVCvIDInfoFixedVector@@@Z ; FObjectPool<CvIDInfoFixedVector>::Release
$LN1@CvSparseID:

; 40   : 
; 41   : 			pkEntry++;

	mov	ecx, DWORD PTR _pkEntry$216668[ebp]
	add	ecx, 4
	mov	DWORD PTR _pkEntry$216668[ebp], ecx

; 42   : 		}

	jmp	SHORT $LN3@CvSparseID
$LN2@CvSparseID:

; 43   : 		delete []m_paEntries;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR $T217901[ebp], eax
	mov	ecx, DWORD PTR $T217901[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN5@CvSparseID:

; 44   : 	}
; 45   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1CvSparseIDInfoGrid@@QAE@XZ ENDP			; CvSparseIDInfoGrid::~CvSparseIDInfoGrid
_TEXT	ENDS
PUBLIC	?Get@CvSparseIDInfoGrid@@QBEPBVCvIDInfoFixedVector@@HH@Z ; CvSparseIDInfoGrid::Get
; Function compile flags: /Odtp
;	COMDAT ?Get@CvSparseIDInfoGrid@@QBEPBVCvIDInfoFixedVector@@HH@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_pkEntry$216684 = -8					; size = 4
_uiIndex$ = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?Get@CvSparseIDInfoGrid@@QBEPBVCvIDInfoFixedVector@@HH@Z PROC ; CvSparseIDInfoGrid::Get, COMDAT
; _this$ = ecx

; 48   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 49   : 	uint uiIndex = ((uint) iY * m_uiWidth) + (uint) iX;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iY$[ebp]
	imul	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _iX$[ebp]
	mov	DWORD PTR _uiIndex$[ebp], ecx

; 50   : 	if (uiIndex < m_uiMaxIndex)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiIndex$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN2@Get

; 51   : 	{
; 52   : 		CvIDInfoFixedVector* pkEntry = m_paEntries[uiIndex];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _uiIndex$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _pkEntry$216684[ebp], ecx

; 53   : 		if (pkEntry)

	cmp	DWORD PTR _pkEntry$216684[ebp], 0
	je	SHORT $LN2@Get

; 54   : 			return pkEntry;

	mov	eax, DWORD PTR _pkEntry$216684[ebp]
	jmp	SHORT $LN3@Get
$LN2@Get:

; 55   : 	}
; 56   : 
; 57   : 	return NULL;

	xor	eax, eax
$LN3@Get:

; 58   : }

	mov	esp, ebp
	pop	ebp
	ret	8
?Get@CvSparseIDInfoGrid@@QBEPBVCvIDInfoFixedVector@@HH@Z ENDP ; CvSparseIDInfoGrid::Get
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAEIABUIDInfo@@@Z ; FStaticVector<IDInfo,8,1,297,0>::push_back
PUBLIC	?Find@CvIDInfoFixedVector@@QAEPAUIDInfo@@ABU2@@Z ; CvIDInfoFixedVector::Find
PUBLIC	?GetFreeObject@?$FObjectPool@VCvIDInfoFixedVector@@@@QAEPAVCvIDInfoFixedVector@@XZ ; FObjectPool<CvIDInfoFixedVector>::GetFreeObject
PUBLIC	?Add@CvSparseIDInfoGrid@@QAE_NABUIDInfo@@HH@Z	; CvSparseIDInfoGrid::Add
; Function compile flags: /Odtp
;	COMDAT ?Add@CvSparseIDInfoGrid@@QAE_NABUIDInfo@@HH@Z
_TEXT	SEGMENT
_this$ = -56						; size = 4
_pkEntry$216696 = -8					; size = 4
_uiIndex$ = -4						; size = 4
_kInfo$ = 8						; size = 4
_iX$ = 12						; size = 4
_iY$ = 16						; size = 4
?Add@CvSparseIDInfoGrid@@QAE_NABUIDInfo@@HH@Z PROC	; CvSparseIDInfoGrid::Add, COMDAT
; _this$ = ecx

; 62   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 63   : 	uint uiIndex = ((uint) iY * m_uiWidth) + (uint) iX;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iY$[ebp]
	imul	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _iX$[ebp]
	mov	DWORD PTR _uiIndex$[ebp], ecx

; 64   : 	if (uiIndex < m_uiMaxIndex)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiIndex$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN3@Add

; 65   : 	{
; 66   : 		CvIDInfoFixedVector* pkEntry = m_paEntries[uiIndex];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _uiIndex$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _pkEntry$216696[ebp], ecx

; 67   : 		if (!pkEntry)

	cmp	DWORD PTR _pkEntry$216696[ebp], 0
	jne	SHORT $LN2@Add

; 68   : 		{
; 69   : 			pkEntry = m_pkAllocator->GetFreeObject();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	call	?GetFreeObject@?$FObjectPool@VCvIDInfoFixedVector@@@@QAEPAVCvIDInfoFixedVector@@XZ ; FObjectPool<CvIDInfoFixedVector>::GetFreeObject
	mov	DWORD PTR _pkEntry$216696[ebp], eax

; 70   : 			m_paEntries[uiIndex] = pkEntry;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _uiIndex$[ebp]
	mov	eax, DWORD PTR _pkEntry$216696[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN2@Add:

; 71   : 		}
; 72   : 
; 73   : 		if (pkEntry->Find(kInfo) == NULL)

	mov	ecx, DWORD PTR _kInfo$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkEntry$216696[ebp]
	call	?Find@CvIDInfoFixedVector@@QAEPAUIDInfo@@ABU2@@Z ; CvIDInfoFixedVector::Find
	test	eax, eax
	jne	SHORT $LN1@Add

; 74   : 		{
; 75   : 			pkEntry->push_back(kInfo);

	mov	edx, DWORD PTR _kInfo$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkEntry$216696[ebp]
	call	?push_back@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAEIABUIDInfo@@@Z ; FStaticVector<IDInfo,8,1,297,0>::push_back
$LN1@Add:

; 76   : 		}
; 77   : 		return true;

	mov	al, 1
	jmp	SHORT $LN4@Add
$LN3@Add:

; 78   : 	}
; 79   : 
; 80   : 	return false;

	xor	al, al
$LN4@Add:

; 81   : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Add@CvSparseIDInfoGrid@@QAE_NABUIDInfo@@HH@Z ENDP	; CvSparseIDInfoGrid::Add
_TEXT	ENDS
PUBLIC	?Remove@CvIDInfoFixedVector@@QAE_NABUIDInfo@@@Z	; CvIDInfoFixedVector::Remove
PUBLIC	?Remove@CvSparseIDInfoGrid@@QAEXABUIDInfo@@HH@Z	; CvSparseIDInfoGrid::Remove
; Function compile flags: /Odtp
;	COMDAT ?Remove@CvSparseIDInfoGrid@@QAEXABUIDInfo@@HH@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T217983 = -24						; size = 4
_pkEntry$216709 = -8					; size = 4
_uiIndex$ = -4						; size = 4
_kInfo$ = 8						; size = 4
_iX$ = 12						; size = 4
_iY$ = 16						; size = 4
?Remove@CvSparseIDInfoGrid@@QAEXABUIDInfo@@HH@Z PROC	; CvSparseIDInfoGrid::Remove, COMDAT
; _this$ = ecx

; 85   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 86   : 	uint uiIndex = ((uint) iY * m_uiWidth) + (uint) iX;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iY$[ebp]
	imul	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _iX$[ebp]
	mov	DWORD PTR _uiIndex$[ebp], ecx

; 87   : 	if (uiIndex < m_uiMaxIndex)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiIndex$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN5@Remove

; 88   : 	{
; 89   : 		CvIDInfoFixedVector* pkEntry = m_paEntries[uiIndex];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _uiIndex$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _pkEntry$216709[ebp], ecx

; 90   : 		if (pkEntry)

	cmp	DWORD PTR _pkEntry$216709[ebp], 0
	je	SHORT $LN5@Remove

; 91   : 		{
; 92   : 			if (pkEntry->Remove(kInfo))

	mov	edx, DWORD PTR _kInfo$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkEntry$216709[ebp]
	call	?Remove@CvIDInfoFixedVector@@QAE_NABUIDInfo@@@Z ; CvIDInfoFixedVector::Remove
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@Remove

; 93   : 			{
; 94   : 				if (pkEntry->size() == 0)

	mov	ecx, DWORD PTR _pkEntry$216709[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T217983[ebp], edx
	cmp	DWORD PTR $T217983[ebp], 0
	jne	SHORT $LN5@Remove

; 95   : 				{
; 96   : 					// Nothing there, release the array
; 97   : 					m_pkAllocator->Release(pkEntry);

	mov	eax, DWORD PTR _pkEntry$216709[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	call	?Release@?$FObjectPool@VCvIDInfoFixedVector@@@@QAEXPAVCvIDInfoFixedVector@@@Z ; FObjectPool<CvIDInfoFixedVector>::Release

; 98   : 					m_paEntries[uiIndex] = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _uiIndex$[ebp]
	mov	DWORD PTR [eax+ecx*4], 0
$LN5@Remove:

; 99   : 				}
; 100  : 			}
; 101  : 		}
; 102  : 	}
; 103  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Remove@CvSparseIDInfoGrid@@QAEXABUIDInfo@@HH@Z ENDP	; CvSparseIDInfoGrid::Remove
_TEXT	ENDS
PUBLIC	??1?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE@XZ ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::~vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >
PUBLIC	??1?$_Vector_val@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::~_Vector_val<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >
PUBLIC	??1CvIDInfoFixedVector@@QAE@XZ			; CvIDInfoFixedVector::~CvIDInfoFixedVector
PUBLIC	??0?$FObjectPool@VCvIDInfoFixedVector@@@@QAE@I_N@Z ; FObjectPool<CvIDInfoFixedVector>::FObjectPool<CvIDInfoFixedVector>
PUBLIC	?_Buy@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Buy
PUBLIC	??0?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<IDInfo,8,1,297,0>::FStaticVector<IDInfo,8,1,297,0>
PUBLIC	??0CvPlotManager@@QAE@XZ			; CvPlotManager::CvPlotManager
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0CvPlotManager@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvPlotManager@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvPlotManager@@QAE@XZ$5
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvPlotManager@@QAE@XZ$1
__ehfuncinfo$??0CvPlotManager@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0CvPlotManager@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplotmanager.cpp
xdata$x	ENDS
;	COMDAT ??0CvPlotManager@@QAE@XZ
_TEXT	SEGMENT
tv188 = -148						; size = 4
tv213 = -144						; size = 4
_this$ = -140						; size = 4
$T218093 = -136						; size = 4
$T218036 = -42						; size = 1
$T218023 = -41						; size = 1
$T218019 = -40						; size = 4
$T218012 = -32						; size = 4
$T218005 = -24						; size = 4
__$EHRec$ = -12						; size = 12
??0CvPlotManager@@QAE@XZ PROC				; CvPlotManager::CvPlotManager, COMDAT
; _this$ = ecx

; 111  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvPlotManager@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 136				; 00000088H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	mov	DWORD PTR $T218005[ebp], eax
	mov	ecx, DWORD PTR $T218005[ebp]
	call	??0?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<IDInfo,8,1,297,0>::FStaticVector<IDInfo,8,1,297,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	mov	DWORD PTR $T218093[ebp], ecx
	lea	edx, DWORD PTR $T218036[ebp]
	mov	DWORD PTR $T218012[ebp], edx
	lea	eax, DWORD PTR $T218023[ebp]
	mov	DWORD PTR $T218019[ebp], eax
	mov	ecx, DWORD PTR $T218093[ebp]
	mov	DWORD PTR tv213[ebp], ecx
	mov	edx, DWORD PTR $T218093[ebp]
	mov	DWORD PTR tv188[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	push	0
	mov	ecx, DWORD PTR $T218093[ebp]
	call	?_Buy@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Buy
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	push	1
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 104				; 00000068H
	call	??0?$FObjectPool@VCvIDInfoFixedVector@@@@QAE@I_N@Z ; FObjectPool<CvIDInfoFixedVector>::FObjectPool<CvIDInfoFixedVector>

; 112  : 	m_uiWidth = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 113  : 	m_uiHeight = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 114  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvPlotManager@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CvIDInfoFixedVector@@QAE@XZ
__unwindfunclet$??0CvPlotManager@@QAE@XZ$5:
	mov	ecx, DWORD PTR $T218093[ebp]
	jmp	??1?$_Vector_val@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE@XZ
__unwindfunclet$??0CvPlotManager@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	jmp	??1?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE@XZ ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::~vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >
__ehhandler$??0CvPlotManager@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-140]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvPlotManager@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvPlotManager@@QAE@XZ ENDP				; CvPlotManager::CvPlotManager
PUBLIC	??1?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<IDInfo,8,1,297,0>::~FStaticVector<IDInfo,8,1,297,0>
PUBLIC	?_Tidy@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXXZ ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Tidy
PUBLIC	??1?$FObjectPool@VCvIDInfoFixedVector@@@@UAE@XZ	; FObjectPool<CvIDInfoFixedVector>::~FObjectPool<CvIDInfoFixedVector>
PUBLIC	??1CvPlotManager@@QAE@XZ			; CvPlotManager::~CvPlotManager
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??1CvPlotManager@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvPlotManager@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvPlotManager@@QAE@XZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvPlotManager@@QAE@XZ$3
__ehfuncinfo$??1CvPlotManager@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1CvPlotManager@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplotmanager.cpp
xdata$x	ENDS
;	COMDAT ??1CvPlotManager@@QAE@XZ
_TEXT	SEGMENT
_this$ = -68						; size = 4
$T218227 = -64						; size = 4
$T218195 = -48						; size = 4
__$EHRec$ = -12						; size = 12
??1CvPlotManager@@QAE@XZ PROC				; CvPlotManager::~CvPlotManager, COMDAT
; _this$ = ecx

; 118  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvPlotManager@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 119  : 	
; 120  : }

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 104				; 00000068H
	call	??1?$FObjectPool@VCvIDInfoFixedVector@@@@UAE@XZ ; FObjectPool<CvIDInfoFixedVector>::~FObjectPool<CvIDInfoFixedVector>
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 88					; 00000058H
	mov	DWORD PTR $T218195[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR $T218195[ebp]
	call	?_Tidy@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXXZ ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	mov	DWORD PTR $T218227[ebp], ecx
	mov	ecx, DWORD PTR $T218227[ebp]
	call	??1?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<IDInfo,8,1,297,0>::~FStaticVector<IDInfo,8,1,297,0>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvPlotManager@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CvIDInfoFixedVector@@QAE@XZ
__unwindfunclet$??1CvPlotManager@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	jmp	??1?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE@XZ ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::~vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >
__unwindfunclet$??1CvPlotManager@@QAE@XZ$3:
	mov	ecx, DWORD PTR $T218195[ebp]
	jmp	??1?$_Vector_val@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE@XZ
__ehhandler$??1CvPlotManager@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-60]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvPlotManager@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvPlotManager@@QAE@XZ ENDP				; CvPlotManager::~CvPlotManager
PUBLIC	?Init@CvPlotManager@@QAEXII@Z			; CvPlotManager::Init
; Function compile flags: /Odtp
;	COMDAT ?Init@CvPlotManager@@QAEXII@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_uiWidth$ = 8						; size = 4
_uiHeight$ = 12						; size = 4
?Init@CvPlotManager@@QAEXII@Z PROC			; CvPlotManager::Init, COMDAT
; _this$ = ecx

; 124  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 125  : 	m_uiWidth = uiWidth;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiWidth$[ebp]
	mov	DWORD PTR [eax], ecx

; 126  : 	m_uiHeight = uiHeight;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiHeight$[ebp]
	mov	DWORD PTR [edx+4], eax

; 127  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?Init@CvPlotManager@@QAEXII@Z ENDP			; CvPlotManager::Init
_TEXT	ENDS
PUBLIC	?erase@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@V?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@0@Z ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::erase
PUBLIC	?Uninit@CvPlotManager@@QAEXXZ			; CvPlotManager::Uninit
; Function compile flags: /Odtp
;	COMDAT ?Uninit@CvPlotManager@@QAEXXZ
_TEXT	SEGMENT
_this$ = -100						; size = 4
$T218436 = -96						; size = 4
$T218269 = -28						; size = 4
$T218253 = -24						; size = 4
$T218422 = -20						; size = 4
$T218421 = -16						; size = 4
$T218420 = -12						; size = 4
$T218419 = -8						; size = 4
$T218418 = -4						; size = 4
?Uninit@CvPlotManager@@QAEXXZ PROC			; CvPlotManager::Uninit, COMDAT
; _this$ = ecx

; 131  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	DWORD PTR _this$[ebp], ecx

; 132  : 	m_aLayers.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 88					; 00000058H
	mov	DWORD PTR $T218436[ebp], eax
	mov	ecx, DWORD PTR $T218436[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T218253[ebp], edx
	mov	eax, DWORD PTR $T218253[ebp]
	mov	DWORD PTR $T218419[ebp], eax
	mov	ecx, DWORD PTR $T218419[ebp]
	mov	DWORD PTR $T218418[ebp], ecx
	mov	edx, DWORD PTR $T218436[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T218269[ebp], eax
	mov	ecx, DWORD PTR $T218269[ebp]
	mov	DWORD PTR $T218421[ebp], ecx
	mov	edx, DWORD PTR $T218421[ebp]
	mov	DWORD PTR $T218420[ebp], edx
	mov	eax, DWORD PTR $T218418[ebp]
	push	eax
	mov	ecx, DWORD PTR $T218420[ebp]
	push	ecx
	lea	edx, DWORD PTR $T218422[ebp]
	push	edx
	mov	ecx, DWORD PTR $T218436[ebp]
	call	?erase@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@V?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@0@Z ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::erase

; 133  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Uninit@CvPlotManager@@QAEXXZ ENDP			; CvPlotManager::Uninit
_TEXT	ENDS
PUBLIC	?GetNumLayers@CvPlotManager@@QBEHXZ		; CvPlotManager::GetNumLayers
; Function compile flags: /Odtp
;	COMDAT ?GetNumLayers@CvPlotManager@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T218442 = -4						; size = 4
?GetNumLayers@CvPlotManager@@QBEHXZ PROC		; CvPlotManager::GetNumLayers, COMDAT
; _this$ = ecx

; 137  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 138  : 	return (int)m_aLayers.size();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 88					; 00000058H
	mov	DWORD PTR $T218442[ebp], eax
	mov	ecx, DWORD PTR $T218442[ebp]
	mov	edx, DWORD PTR $T218442[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 3

; 139  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumLayers@CvPlotManager@@QBEHXZ ENDP		; CvPlotManager::GetNumLayers
_TEXT	ENDS
PUBLIC	?GetLayerIDIndex@CvPlotManager@@QBEHI@Z		; CvPlotManager::GetLayerIDIndex
; Function compile flags: /Odtp
;	COMDAT ?GetLayerIDIndex@CvPlotManager@@QBEHI@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T218462 = -20						; size = 4
$T218450 = -16						; size = 4
$T218445 = -12						; size = 4
_itr$216842 = -8					; size = 4
_iIndex$ = -4						; size = 4
_uiLayerID$ = 8						; size = 4
?GetLayerIDIndex@CvPlotManager@@QBEHI@Z PROC		; CvPlotManager::GetLayerIDIndex, COMDAT
; _this$ = ecx

; 143  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 144  : 	int iIndex = 0;

	mov	DWORD PTR _iIndex$[ebp], 0

; 145  : 	for (CvSparseIDInfoGridVector::const_iterator itr = m_aLayers.begin(); itr != m_aLayers.end(); ++itr)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	DWORD PTR $T218450[ebp], ecx
	mov	edx, DWORD PTR $T218450[ebp]
	mov	DWORD PTR _itr$216842[ebp], edx
	jmp	SHORT $LN4@GetLayerID
$LN3@GetLayerID:
	mov	eax, DWORD PTR _itr$216842[ebp]
	add	eax, 8
	mov	DWORD PTR _itr$216842[ebp], eax
$LN4@GetLayerID:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR $T218462[ebp], edx
	mov	eax, DWORD PTR $T218462[ebp]
	mov	DWORD PTR $T218445[ebp], eax
	mov	ecx, DWORD PTR _itr$216842[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T218445[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@GetLayerID

; 146  : 	{
; 147  : 		if ((*itr).m_uiID == uiLayerID)

	mov	edx, DWORD PTR _itr$216842[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _uiLayerID$[ebp]
	jne	SHORT $LN1@GetLayerID

; 148  : 		{
; 149  : 			return iIndex;

	mov	eax, DWORD PTR _iIndex$[ebp]
	jmp	SHORT $LN5@GetLayerID
$LN1@GetLayerID:

; 150  : 		}
; 151  : 		++iIndex;

	mov	ecx, DWORD PTR _iIndex$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iIndex$[ebp], ecx

; 152  : 	}

	jmp	SHORT $LN3@GetLayerID
$LN2@GetLayerID:

; 153  : 
; 154  : 	return -1;

	or	eax, -1
$LN5@GetLayerID:

; 155  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetLayerIDIndex@CvPlotManager@@QBEHI@Z ENDP		; CvPlotManager::GetLayerIDIndex
_TEXT	ENDS
PUBLIC	?GetLayerIndexID@CvPlotManager@@QBEIH@Z		; CvPlotManager::GetLayerIndexID
; Function compile flags: /Odtp
;	COMDAT ?GetLayerIndexID@CvPlotManager@@QBEIH@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T218491 = -12						; size = 4
$T218487 = -8						; size = 4
$T218483 = -4						; size = 4
_iLayerIndex$ = 8					; size = 4
?GetLayerIndexID@CvPlotManager@@QBEIH@Z PROC		; CvPlotManager::GetLayerIndexID, COMDAT
; _this$ = ecx

; 159  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 	if (iLayerIndex >= 0 && iLayerIndex < (int)m_aLayers.size())

	cmp	DWORD PTR _iLayerIndex$[ebp], 0
	jl	SHORT $LN1@GetLayerIn
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 88					; 00000058H
	mov	DWORD PTR $T218483[ebp], eax
	mov	ecx, DWORD PTR $T218483[ebp]
	mov	edx, DWORD PTR $T218483[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 3
	cmp	DWORD PTR _iLayerIndex$[ebp], eax
	jge	SHORT $LN1@GetLayerIn

; 161  : 		return m_aLayers[iLayerIndex].GetID();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	eax, DWORD PTR _iLayerIndex$[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	DWORD PTR $T218487[ebp], ecx
	mov	edx, DWORD PTR $T218487[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T218491[ebp], eax
	mov	eax, DWORD PTR $T218491[ebp]
	jmp	SHORT $LN2@GetLayerIn
$LN1@GetLayerIn:

; 162  : 
; 163  : 	return (uint)-1;

	or	eax, -1
$LN2@GetLayerIn:

; 164  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetLayerIndexID@CvPlotManager@@QBEIH@Z ENDP		; CvPlotManager::GetLayerIndexID
_TEXT	ENDS
PUBLIC	?push_back@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAEXABUCvSparseIDInfoGridEntry@@@Z ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::push_back
PUBLIC	?AddLayer@CvPlotManager@@IAEPAVCvSparseIDInfoGrid@@I@Z ; CvPlotManager::AddLayer
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$?AddLayer@CvPlotManager@@IAEPAVCvSparseIDInfoGrid@@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddLayer@CvPlotManager@@IAEPAVCvSparseIDInfoGrid@@I@Z$0
__ehfuncinfo$?AddLayer@CvPlotManager@@IAEPAVCvSparseIDInfoGrid@@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddLayer@CvPlotManager@@IAEPAVCvSparseIDInfoGrid@@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplotmanager.cpp
xdata$x	ENDS
;	COMDAT ?AddLayer@CvPlotManager@@IAEPAVCvSparseIDInfoGrid@@I@Z
_TEXT	SEGMENT
tv137 = -116						; size = 4
_this$ = -112						; size = 4
$T218530 = -52						; size = 4
$T218511 = -48						; size = 4
$T218500 = -44						; size = 8
$T218497 = -36						; size = 4
$T218496 = -32						; size = 4
$T218495 = -28						; size = 4
$T218494 = -24						; size = 4
_itr$216860 = -20					; size = 4
_pkLayer$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_uiLayerID$ = 8						; size = 4
?AddLayer@CvPlotManager@@IAEPAVCvSparseIDInfoGrid@@I@Z PROC ; CvPlotManager::AddLayer, COMDAT
; _this$ = ecx

; 168  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddLayer@CvPlotManager@@IAEPAVCvSparseIDInfoGrid@@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 169  : 	for (CvSparseIDInfoGridVector::const_iterator itr = m_aLayers.begin(); itr != m_aLayers.end(); ++itr)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	DWORD PTR $T218511[ebp], ecx
	mov	edx, DWORD PTR $T218511[ebp]
	mov	DWORD PTR $T218494[ebp], edx
	mov	eax, DWORD PTR $T218494[ebp]
	mov	DWORD PTR _itr$216860[ebp], eax
	jmp	SHORT $LN4@AddLayer
$LN3@AddLayer:
	mov	ecx, DWORD PTR _itr$216860[ebp]
	add	ecx, 8
	mov	DWORD PTR _itr$216860[ebp], ecx
$LN4@AddLayer:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR $T218530[ebp], eax
	mov	ecx, DWORD PTR $T218530[ebp]
	mov	DWORD PTR $T218495[ebp], ecx
	mov	edx, DWORD PTR _itr$216860[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T218495[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@AddLayer

; 170  : 	{
; 171  : 		if ((*itr).m_uiID == uiLayerID)

	mov	eax, DWORD PTR _itr$216860[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _uiLayerID$[ebp]
	jne	SHORT $LN1@AddLayer

; 172  : 		{
; 173  : 			return (*itr).m_pkGrid;

	mov	edx, DWORD PTR _itr$216860[ebp]
	mov	eax, DWORD PTR [edx+4]
	jmp	SHORT $LN5@AddLayer
$LN1@AddLayer:

; 174  : 		}
; 175  : 	}

	jmp	SHORT $LN3@AddLayer
$LN2@AddLayer:

; 176  : 
; 177  : 	CvSparseIDInfoGrid* pkLayer = new CvSparseIDInfoGrid(m_uiWidth, m_uiHeight, &m_kAllocator);

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T218497[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T218497[ebp], 0
	je	SHORT $LN7@AddLayer
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 104				; 00000068H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR $T218497[ebp]
	call	??0CvSparseIDInfoGrid@@QAE@IIPAV?$FObjectPool@VCvIDInfoFixedVector@@@@@Z ; CvSparseIDInfoGrid::CvSparseIDInfoGrid
	mov	DWORD PTR tv137[ebp], eax
	jmp	SHORT $LN8@AddLayer
$LN7@AddLayer:
	mov	DWORD PTR tv137[ebp], 0
$LN8@AddLayer:
	mov	edx, DWORD PTR tv137[ebp]
	mov	DWORD PTR $T218496[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T218496[ebp]
	mov	DWORD PTR _pkLayer$[ebp], eax

; 178  : 	m_aLayers.push_back(CvSparseIDInfoGridEntry(uiLayerID, pkLayer));

	mov	ecx, DWORD PTR _uiLayerID$[ebp]
	mov	DWORD PTR $T218500[ebp], ecx
	mov	edx, DWORD PTR _pkLayer$[ebp]
	mov	DWORD PTR $T218500[ebp+4], edx
	lea	eax, DWORD PTR $T218500[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	?push_back@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAEXABUCvSparseIDInfoGridEntry@@@Z ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::push_back

; 179  : 
; 180  : 	return pkLayer;

	mov	eax, DWORD PTR _pkLayer$[ebp]
$LN5@AddLayer:

; 181  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddLayer@CvPlotManager@@IAEPAVCvSparseIDInfoGrid@@I@Z$0:
	mov	eax, DWORD PTR $T218497[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?AddLayer@CvPlotManager@@IAEPAVCvSparseIDInfoGrid@@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-108]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AddLayer@CvPlotManager@@IAEPAVCvSparseIDInfoGrid@@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddLayer@CvPlotManager@@IAEPAVCvSparseIDInfoGrid@@I@Z ENDP ; CvPlotManager::AddLayer
PUBLIC	?FindLayer@CvPlotManager@@IAEPAVCvSparseIDInfoGrid@@I@Z ; CvPlotManager::FindLayer
; Function compile flags: /Odtp
;	COMDAT ?FindLayer@CvPlotManager@@IAEPAVCvSparseIDInfoGrid@@I@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T218708 = -20						; size = 4
$T218689 = -16						; size = 4
$T218679 = -12						; size = 4
$T218678 = -8						; size = 4
_itr$216920 = -4					; size = 4
_uiLayerID$ = 8						; size = 4
?FindLayer@CvPlotManager@@IAEPAVCvSparseIDInfoGrid@@I@Z PROC ; CvPlotManager::FindLayer, COMDAT
; _this$ = ecx

; 185  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 186  : 	for (CvSparseIDInfoGridVector::const_iterator itr = m_aLayers.begin(); itr != m_aLayers.end(); ++itr)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	DWORD PTR $T218689[ebp], ecx
	mov	edx, DWORD PTR $T218689[ebp]
	mov	DWORD PTR $T218678[ebp], edx
	mov	eax, DWORD PTR $T218678[ebp]
	mov	DWORD PTR _itr$216920[ebp], eax
	jmp	SHORT $LN4@FindLayer
$LN3@FindLayer:
	mov	ecx, DWORD PTR _itr$216920[ebp]
	add	ecx, 8
	mov	DWORD PTR _itr$216920[ebp], ecx
$LN4@FindLayer:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR $T218708[ebp], eax
	mov	ecx, DWORD PTR $T218708[ebp]
	mov	DWORD PTR $T218679[ebp], ecx
	mov	edx, DWORD PTR _itr$216920[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T218679[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@FindLayer

; 187  : 	{
; 188  : 		if ((*itr).m_uiID == uiLayerID)

	mov	eax, DWORD PTR _itr$216920[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _uiLayerID$[ebp]
	jne	SHORT $LN1@FindLayer

; 189  : 		{
; 190  : 			return (*itr).m_pkGrid;

	mov	edx, DWORD PTR _itr$216920[ebp]
	mov	eax, DWORD PTR [edx+4]
	jmp	SHORT $LN5@FindLayer
$LN1@FindLayer:

; 191  : 		}
; 192  : 	}

	jmp	SHORT $LN3@FindLayer
$LN2@FindLayer:

; 193  : 
; 194  : 	return NULL;

	xor	eax, eax
$LN5@FindLayer:

; 195  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?FindLayer@CvPlotManager@@IAEPAVCvSparseIDInfoGrid@@I@Z ENDP ; CvPlotManager::FindLayer
_TEXT	ENDS
PUBLIC	?FindLayer@CvPlotManager@@QBEPBVCvSparseIDInfoGrid@@I@Z ; CvPlotManager::FindLayer
; Function compile flags: /Odtp
;	COMDAT ?FindLayer@CvPlotManager@@QBEPBVCvSparseIDInfoGrid@@I@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T218748 = -16						; size = 4
$T218736 = -12						; size = 4
$T218731 = -8						; size = 4
_itr$216931 = -4					; size = 4
_uiLayerID$ = 8						; size = 4
?FindLayer@CvPlotManager@@QBEPBVCvSparseIDInfoGrid@@I@Z PROC ; CvPlotManager::FindLayer, COMDAT
; _this$ = ecx

; 199  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 200  : 	for (CvSparseIDInfoGridVector::const_iterator itr = m_aLayers.begin(); itr != m_aLayers.end(); ++itr)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	DWORD PTR $T218736[ebp], ecx
	mov	edx, DWORD PTR $T218736[ebp]
	mov	DWORD PTR _itr$216931[ebp], edx
	jmp	SHORT $LN4@FindLayer@2
$LN3@FindLayer@2:
	mov	eax, DWORD PTR _itr$216931[ebp]
	add	eax, 8
	mov	DWORD PTR _itr$216931[ebp], eax
$LN4@FindLayer@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR $T218748[ebp], edx
	mov	eax, DWORD PTR $T218748[ebp]
	mov	DWORD PTR $T218731[ebp], eax
	mov	ecx, DWORD PTR _itr$216931[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T218731[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@FindLayer@2

; 201  : 	{
; 202  : 		if ((*itr).m_uiID == uiLayerID)

	mov	edx, DWORD PTR _itr$216931[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _uiLayerID$[ebp]
	jne	SHORT $LN1@FindLayer@2

; 203  : 		{
; 204  : 			return (*itr).m_pkGrid;

	mov	ecx, DWORD PTR _itr$216931[ebp]
	mov	eax, DWORD PTR [ecx+4]
	jmp	SHORT $LN5@FindLayer@2
$LN1@FindLayer@2:

; 205  : 		}
; 206  : 	}

	jmp	SHORT $LN3@FindLayer@2
$LN2@FindLayer@2:

; 207  : 
; 208  : 	return NULL;

	xor	eax, eax
$LN5@FindLayer@2:

; 209  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?FindLayer@CvPlotManager@@QBEPBVCvSparseIDInfoGrid@@I@Z ENDP ; CvPlotManager::FindLayer
_TEXT	ENDS
PUBLIC	?GetUnits@CvPlotManager@@QBEABVCvIDInfoFixedVector@@HHI@Z ; CvPlotManager::GetUnits
; Function compile flags: /Odtp
;	COMDAT ?GetUnits@CvPlotManager@@QBEABVCvIDInfoFixedVector@@HHI@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T218805 = -24						; size = 4
$T218786 = -20						; size = 4
$T218774 = -16						; size = 4
$T218769 = -12						; size = 4
_pkEntry$216953 = -8					; size = 4
_itr$216946 = -4					; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_uiLayerID$ = 16					; size = 4
?GetUnits@CvPlotManager@@QBEABVCvIDInfoFixedVector@@HHI@Z PROC ; CvPlotManager::GetUnits, COMDAT
; _this$ = ecx

; 213  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 214  : 	if (uiLayerID != (uint)-1)

	cmp	DWORD PTR _uiLayerID$[ebp], -1
	je	SHORT $LN6@GetUnits

; 215  : 	{
; 216  : 		for (CvSparseIDInfoGridVector::const_iterator itr = m_aLayers.begin(); itr != m_aLayers.end(); ++itr)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	DWORD PTR $T218774[ebp], ecx
	mov	edx, DWORD PTR $T218774[ebp]
	mov	DWORD PTR _itr$216946[ebp], edx
	jmp	SHORT $LN5@GetUnits
$LN4@GetUnits:
	mov	eax, DWORD PTR _itr$216946[ebp]
	add	eax, 8
	mov	DWORD PTR _itr$216946[ebp], eax
$LN5@GetUnits:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR $T218786[ebp], edx
	mov	eax, DWORD PTR $T218786[ebp]
	mov	DWORD PTR $T218769[ebp], eax
	mov	ecx, DWORD PTR _itr$216946[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T218769[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@GetUnits

; 217  : 		{
; 218  : 			if ((*itr).m_uiID == uiLayerID)

	mov	edx, DWORD PTR _itr$216946[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _uiLayerID$[ebp]
	jne	SHORT $LN2@GetUnits

; 219  : 			{
; 220  : 				const CvIDInfoFixedVector* pkEntry = (*itr).m_pkGrid->Get(iX, iY);

	mov	ecx, DWORD PTR _itr$216946[ebp]
	mov	DWORD PTR $T218805[ebp], ecx
	mov	edx, DWORD PTR _iY$[ebp]
	push	edx
	mov	eax, DWORD PTR _iX$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T218805[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?Get@CvSparseIDInfoGrid@@QBEPBVCvIDInfoFixedVector@@HH@Z ; CvSparseIDInfoGrid::Get
	mov	DWORD PTR _pkEntry$216953[ebp], eax

; 221  : 				if (pkEntry)

	cmp	DWORD PTR _pkEntry$216953[ebp], 0
	je	SHORT $LN2@GetUnits

; 222  : 					return *pkEntry;

	mov	eax, DWORD PTR _pkEntry$216953[ebp]
	jmp	SHORT $LN7@GetUnits
$LN2@GetUnits:

; 223  : 			}
; 224  : 		}

	jmp	SHORT $LN4@GetUnits
$LN6@GetUnits:

; 225  : 	}
; 226  : 
; 227  : 	return m_kEmpty;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
$LN7@GetUnits:

; 228  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetUnits@CvPlotManager@@QBEABVCvIDInfoFixedVector@@HHI@Z ENDP ; CvPlotManager::GetUnits
_TEXT	ENDS
PUBLIC	?GetUnitsByIndex@CvPlotManager@@QBEABVCvIDInfoFixedVector@@HHH@Z ; CvPlotManager::GetUnitsByIndex
; Function compile flags: /Odtp
;	COMDAT ?GetUnitsByIndex@CvPlotManager@@QBEABVCvIDInfoFixedVector@@HHH@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T218819 = -16						; size = 4
$T218815 = -12						; size = 4
$T218811 = -8						; size = 4
_pkEntry$216963 = -4					; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iLayerIndex$ = 16					; size = 4
?GetUnitsByIndex@CvPlotManager@@QBEABVCvIDInfoFixedVector@@HHH@Z PROC ; CvPlotManager::GetUnitsByIndex, COMDAT
; _this$ = ecx

; 232  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 233  : 	if (iLayerIndex >= 0 && iLayerIndex < (int)m_aLayers.size())

	cmp	DWORD PTR _iLayerIndex$[ebp], 0
	jl	SHORT $LN2@GetUnitsBy
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 88					; 00000058H
	mov	DWORD PTR $T218811[ebp], eax
	mov	ecx, DWORD PTR $T218811[ebp]
	mov	edx, DWORD PTR $T218811[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 3
	cmp	DWORD PTR _iLayerIndex$[ebp], eax
	jge	SHORT $LN2@GetUnitsBy

; 234  : 	{
; 235  : 		const CvIDInfoFixedVector* pkEntry = m_aLayers[iLayerIndex].GetGrid()->Get(iX, iY);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	eax, DWORD PTR _iLayerIndex$[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	DWORD PTR $T218815[ebp], ecx
	mov	edx, DWORD PTR $T218815[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T218819[ebp], eax
	mov	ecx, DWORD PTR _iY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iX$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T218819[ebp]
	call	?Get@CvSparseIDInfoGrid@@QBEPBVCvIDInfoFixedVector@@HH@Z ; CvSparseIDInfoGrid::Get
	mov	DWORD PTR _pkEntry$216963[ebp], eax

; 236  : 		if (pkEntry)

	cmp	DWORD PTR _pkEntry$216963[ebp], 0
	je	SHORT $LN2@GetUnitsBy

; 237  : 			return *pkEntry;

	mov	eax, DWORD PTR _pkEntry$216963[ebp]
	jmp	SHORT $LN3@GetUnitsBy
$LN2@GetUnitsBy:

; 238  : 	}
; 239  : 
; 240  : 	return m_kEmpty;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
$LN3@GetUnitsBy:

; 241  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetUnitsByIndex@CvPlotManager@@QBEABVCvIDInfoFixedVector@@HHH@Z ENDP ; CvPlotManager::GetUnitsByIndex
_TEXT	ENDS
PUBLIC	?AddUnit@CvPlotManager@@QAEXABUIDInfo@@HHI@Z	; CvPlotManager::AddUnit
; Function compile flags: /Odtp
;	COMDAT ?AddUnit@CvPlotManager@@QAEXABUIDInfo@@HHI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pkLayer$ = -4						; size = 4
_kInfo$ = 8						; size = 4
_iX$ = 12						; size = 4
_iY$ = 16						; size = 4
_uiLayerID$ = 20					; size = 4
?AddUnit@CvPlotManager@@QAEXABUIDInfo@@HHI@Z PROC	; CvPlotManager::AddUnit, COMDAT
; _this$ = ecx

; 245  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 246  : 	CvSparseIDInfoGrid* pkLayer = AddLayer(uiLayerID);

	mov	eax, DWORD PTR _uiLayerID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddLayer@CvPlotManager@@IAEPAVCvSparseIDInfoGrid@@I@Z ; CvPlotManager::AddLayer
	mov	DWORD PTR _pkLayer$[ebp], eax

; 247  : 	if (pkLayer)

	cmp	DWORD PTR _pkLayer$[ebp], 0
	je	SHORT $LN2@AddUnit

; 248  : 	{
; 249  : 		pkLayer->Add(kInfo, iX, iY);

	mov	ecx, DWORD PTR _iY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iX$[ebp]
	push	edx
	mov	eax, DWORD PTR _kInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkLayer$[ebp]
	call	?Add@CvSparseIDInfoGrid@@QAE_NABUIDInfo@@HH@Z ; CvSparseIDInfoGrid::Add
$LN2@AddUnit:

; 250  : 	}
; 251  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?AddUnit@CvPlotManager@@QAEXABUIDInfo@@HHI@Z ENDP	; CvPlotManager::AddUnit
_TEXT	ENDS
PUBLIC	?RemoveUnit@CvPlotManager@@QAEXABUIDInfo@@HHI@Z	; CvPlotManager::RemoveUnit
; Function compile flags: /Odtp
;	COMDAT ?RemoveUnit@CvPlotManager@@QAEXABUIDInfo@@HHI@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T218876 = -36						; size = 4
$T218872 = -32						; size = 4
$T218854 = -28						; size = 4
$T218835 = -24						; size = 4
$T218825 = -20						; size = 4
$T218824 = -16						; size = 4
_itr$216986 = -12					; size = 4
_iIndex$216985 = -8					; size = 4
_pkLayer$216982 = -4					; size = 4
_kInfo$ = 8						; size = 4
_iX$ = 12						; size = 4
_iY$ = 16						; size = 4
_uiLayerID$ = 20					; size = 4
?RemoveUnit@CvPlotManager@@QAEXABUIDInfo@@HHI@Z PROC	; CvPlotManager::RemoveUnit, COMDAT
; _this$ = ecx

; 255  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 256  : #ifdef AUI_WARNING_FIXES
; 257  : 	if (uiLayerID != MAX_UNSIGNED_INT)
; 258  : #else
; 259  : 	if (uiLayerID != -1)

	cmp	DWORD PTR _uiLayerID$[ebp], -1
	je	SHORT $LN6@RemoveUnit

; 260  : #endif
; 261  : 	{
; 262  : 		CvSparseIDInfoGrid* pkLayer = FindLayer(uiLayerID);

	mov	eax, DWORD PTR _uiLayerID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindLayer@CvPlotManager@@IAEPAVCvSparseIDInfoGrid@@I@Z ; CvPlotManager::FindLayer
	mov	DWORD PTR _pkLayer$216982[ebp], eax

; 263  : 		if (pkLayer)

	cmp	DWORD PTR _pkLayer$216982[ebp], 0
	je	SHORT $LN5@RemoveUnit

; 264  : 		{
; 265  : 			pkLayer->Remove(kInfo, iX, iY);

	mov	ecx, DWORD PTR _iY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iX$[ebp]
	push	edx
	mov	eax, DWORD PTR _kInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkLayer$216982[ebp]
	call	?Remove@CvSparseIDInfoGrid@@QAEXABUIDInfo@@HH@Z ; CvSparseIDInfoGrid::Remove
$LN5@RemoveUnit:

; 266  : 		}
; 267  : 	}
; 268  : 	else

	jmp	SHORT $LN7@RemoveUnit
$LN6@RemoveUnit:

; 269  : 	{
; 270  : #ifndef AUI_WARNING_FIXES
; 271  : 		int iIndex = 0;

	mov	DWORD PTR _iIndex$216985[ebp], 0

; 272  : #endif
; 273  : 		for (CvSparseIDInfoGridVector::const_iterator itr = m_aLayers.begin(); itr != m_aLayers.end(); ++itr)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	DWORD PTR $T218835[ebp], edx
	mov	eax, DWORD PTR $T218835[ebp]
	mov	DWORD PTR $T218824[ebp], eax
	mov	ecx, DWORD PTR $T218824[ebp]
	mov	DWORD PTR _itr$216986[ebp], ecx
	jmp	SHORT $LN3@RemoveUnit
$LN2@RemoveUnit:
	mov	edx, DWORD PTR _itr$216986[ebp]
	add	edx, 8
	mov	DWORD PTR _itr$216986[ebp], edx
$LN3@RemoveUnit:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR $T218854[ebp], ecx
	mov	edx, DWORD PTR $T218854[ebp]
	mov	DWORD PTR $T218825[ebp], edx
	mov	eax, DWORD PTR _itr$216986[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T218825[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN7@RemoveUnit

; 274  : 		{
; 275  : 			(*itr).GetGrid()->Remove(kInfo, iX, iY);

	mov	ecx, DWORD PTR _itr$216986[ebp]
	mov	DWORD PTR $T218872[ebp], ecx
	mov	edx, DWORD PTR $T218872[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T218876[ebp], eax
	mov	ecx, DWORD PTR _iY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iX$[ebp]
	push	edx
	mov	eax, DWORD PTR _kInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T218876[ebp]
	call	?Remove@CvSparseIDInfoGrid@@QAEXABUIDInfo@@HH@Z ; CvSparseIDInfoGrid::Remove

; 276  : 		}

	jmp	SHORT $LN2@RemoveUnit
$LN7@RemoveUnit:

; 277  : 	}
; 278  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?RemoveUnit@CvPlotManager@@QAEXABUIDInfo@@HHI@Z ENDP	; CvPlotManager::RemoveUnit
_TEXT	ENDS
PUBLIC	?GetNumUnits@CvPlotManager@@QBEHHHI@Z		; CvPlotManager::GetNumUnits
; Function compile flags: /Odtp
;	COMDAT ?GetNumUnits@CvPlotManager@@QBEHHHI@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T218882 = -12						; size = 4
_pkUnits$217000 = -8					; size = 4
_pkLayer$ = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_uiLayerID$ = 16					; size = 4
?GetNumUnits@CvPlotManager@@QBEHHHI@Z PROC		; CvPlotManager::GetNumUnits, COMDAT
; _this$ = ecx

; 282  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 283  : 	const CvSparseIDInfoGrid* pkLayer = FindLayer(uiLayerID);

	mov	eax, DWORD PTR _uiLayerID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindLayer@CvPlotManager@@QBEPBVCvSparseIDInfoGrid@@I@Z ; CvPlotManager::FindLayer
	mov	DWORD PTR _pkLayer$[ebp], eax

; 284  : 	if (pkLayer)

	cmp	DWORD PTR _pkLayer$[ebp], 0
	je	SHORT $LN2@GetNumUnit

; 285  : 	{
; 286  : 		const CvIDInfoFixedVector* pkUnits = pkLayer->Get(iX, iY);

	mov	ecx, DWORD PTR _iY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iX$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkLayer$[ebp]
	call	?Get@CvSparseIDInfoGrid@@QBEPBVCvIDInfoFixedVector@@HH@Z ; CvSparseIDInfoGrid::Get
	mov	DWORD PTR _pkUnits$217000[ebp], eax

; 287  : 		if (pkUnits)

	cmp	DWORD PTR _pkUnits$217000[ebp], 0
	je	SHORT $LN2@GetNumUnit

; 288  : 			return pkUnits->size();

	mov	eax, DWORD PTR _pkUnits$217000[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T218882[ebp], ecx
	mov	eax, DWORD PTR $T218882[ebp]
	jmp	SHORT $LN3@GetNumUnit
$LN2@GetNumUnit:

; 289  : 	}
; 290  : 
; 291  : 	return 0;

	xor	eax, eax
$LN3@GetNumUnit:

; 292  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetNumUnits@CvPlotManager@@QBEHHHI@Z ENDP		; CvPlotManager::GetNumUnits
_TEXT	ENDS
PUBLIC	?GetNumUnitsByIndex@CvPlotManager@@QBEHHHH@Z	; CvPlotManager::GetNumUnitsByIndex
; Function compile flags: /Odtp
;	COMDAT ?GetNumUnitsByIndex@CvPlotManager@@QBEHHHH@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T218900 = -20						; size = 4
$T218896 = -16						; size = 4
$T218892 = -12						; size = 4
$T218888 = -8						; size = 4
_pkEntry$217010 = -4					; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iLayerIndex$ = 16					; size = 4
?GetNumUnitsByIndex@CvPlotManager@@QBEHHHH@Z PROC	; CvPlotManager::GetNumUnitsByIndex, COMDAT
; _this$ = ecx

; 296  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 297  : 	if (iLayerIndex >= 0 && iLayerIndex < (int)m_aLayers.size())

	cmp	DWORD PTR _iLayerIndex$[ebp], 0
	jl	SHORT $LN2@GetNumUnit@2
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 88					; 00000058H
	mov	DWORD PTR $T218888[ebp], eax
	mov	ecx, DWORD PTR $T218888[ebp]
	mov	edx, DWORD PTR $T218888[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 3
	cmp	DWORD PTR _iLayerIndex$[ebp], eax
	jge	SHORT $LN2@GetNumUnit@2

; 298  : 	{
; 299  : 		const CvIDInfoFixedVector* pkEntry = m_aLayers[iLayerIndex].GetGrid()->Get(iX, iY);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	eax, DWORD PTR _iLayerIndex$[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	DWORD PTR $T218892[ebp], ecx
	mov	edx, DWORD PTR $T218892[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T218896[ebp], eax
	mov	ecx, DWORD PTR _iY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iX$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T218896[ebp]
	call	?Get@CvSparseIDInfoGrid@@QBEPBVCvIDInfoFixedVector@@HH@Z ; CvSparseIDInfoGrid::Get
	mov	DWORD PTR _pkEntry$217010[ebp], eax

; 300  : 		if (pkEntry)

	cmp	DWORD PTR _pkEntry$217010[ebp], 0
	je	SHORT $LN2@GetNumUnit@2

; 301  : 			return (int)pkEntry->size();

	mov	eax, DWORD PTR _pkEntry$217010[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T218900[ebp], ecx
	mov	eax, DWORD PTR $T218900[ebp]
	jmp	SHORT $LN3@GetNumUnit@2
$LN2@GetNumUnit@2:

; 302  : 	}
; 303  : 
; 304  : 	return 0;

	xor	eax, eax
$LN3@GetNumUnit@2:

; 305  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetNumUnitsByIndex@CvPlotManager@@QBEHHHH@Z ENDP	; CvPlotManager::GetNumUnitsByIndex
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UIDInfo@@$00@@QAE@XZ		; BaseVector<IDInfo,1>::~BaseVector<IDInfo,1>
PUBLIC	??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ ; `string'
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ DB 'd:\sources\'
	DB	'lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\FF'
	DB	'astVector.h', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T218913 = -20						; size = 4
_pRet$218909 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<IDInfo,8,1,297,0>::FStaticVector<IDInfo,8,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 8

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T218913[ebp], edx
	cmp	DWORD PTR $T218913[ebp], 8
	jbe	SHORT $LN7@FStaticVec
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T218913[ebp]
	shl	eax, 3
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$218909[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T218913[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec
$LN7@FStaticVec:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$218909[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 8
$LN8@FStaticVec:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$218909[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UIDInfo@@$00@@QAE@XZ	; BaseVector<IDInfo,1>::~BaseVector<IDInfo,1>
__ehhandler$??0?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<IDInfo,8,1,297,0>::FStaticVector<IDInfo,8,1,297,0>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::~vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXXZ ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::~vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >
PUBLIC	?insert@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@V?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@ABUCvSparseIDInfoGridEntry@@@Z ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::insert
PUBLIC	??$_Uninit_fill_n@PAUCvSparseIDInfoGridEntry@@IU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAXPAUCvSparseIDInfoGridEntry@@IABU1@AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvSparseIDInfoGridEntry *,unsigned int,CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAEXABUCvSparseIDInfoGridEntry@@@Z
_TEXT	SEGMENT
tv129 = -64						; size = 4
_this$ = -60						; size = 4
$T219057 = -32						; size = 4
$T219047 = -28						; size = 4
$T219037 = -24						; size = 4
__Cat$219045 = -19					; size = 1
$T219043 = -18						; size = 1
$T219042 = -17						; size = 1
$T219014 = -16						; size = 4
$T219010 = -12						; size = 4
$T219009 = -8						; size = 4
$T219008 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAEXABUCvSparseIDInfoGridEntry@@@Z PROC ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 3
	mov	DWORD PTR $T219014[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN9@push_back
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN7@push_back
$LN9@push_back:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 3
	mov	DWORD PTR tv129[ebp], eax
$LN7@push_back:
	mov	ecx, DWORD PTR $T219014[ebp]
	cmp	ecx, DWORD PTR tv129[ebp]
	jae	SHORT $LN2@push_back

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T219047[ebp], eax
	mov	ecx, DWORD PTR $T219047[ebp]
	mov	DWORD PTR $T219037[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T219042[ebp], dl
	mov	al, BYTE PTR __Cat$219045[ebp]
	mov	BYTE PTR $T219043[ebp], al
	movzx	ecx, BYTE PTR $T219042[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T219043[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR $T219037[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAUCvSparseIDInfoGridEntry@@IU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAXPAUCvSparseIDInfoGridEntry@@IABU1@AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvSparseIDInfoGridEntry *,unsigned int,CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >
	add	esp, 24					; 00000018H
	mov	eax, 1
	shl	eax, 3
	add	eax, DWORD PTR $T219047[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back
$LN2@push_back:

; 823  : 			insert(end(), _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T219057[ebp], eax
	mov	ecx, DWORD PTR $T219057[ebp]
	mov	DWORD PTR $T219009[ebp], ecx
	mov	edx, DWORD PTR $T219009[ebp]
	mov	DWORD PTR $T219008[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T219008[ebp]
	push	ecx
	lea	edx, DWORD PTR $T219010[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@V?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@ABUCvSparseIDInfoGridEntry@@@Z ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::insert
$LN3@push_back:

; 824  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAEXABUCvSparseIDInfoGridEntry@@@Z ENDP ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::push_back
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::~_Vector_val<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::~_Vector_val<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@V?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@ABUCvSparseIDInfoGridEntry@@@Z
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
__Tmp$219188 = -24					; size = 4
$T219166 = -20						; size = 4
$T219147 = -16						; size = 4
$T219134 = -12						; size = 4
$T219131 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@V?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@ABUCvSparseIDInfoGridEntry@@@Z PROC ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 3
	test	edx, edx
	jne	SHORT $LN3@insert
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert
$LN3@insert:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T219147[ebp], ecx
	mov	edx, DWORD PTR $T219147[ebp]
	mov	DWORD PTR $T219131[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	sub	eax, DWORD PTR $T219131[ebp]
	sar	eax, 3
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T219166[ebp], edx
	mov	eax, DWORD PTR $T219166[ebp]
	mov	DWORD PTR $T219134[ebp], eax
	mov	ecx, DWORD PTR $T219134[ebp]
	mov	DWORD PTR __Tmp$219188[ebp], ecx
	mov	edx, DWORD PTR __Off$[ebp]
	mov	eax, DWORD PTR __Tmp$219188[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR __Tmp$219188[ebp], ecx
	mov	edx, DWORD PTR __Tmp$219188[ebp]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@V?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@ABUCvSparseIDInfoGridEntry@@@Z ENDP ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::insert
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?erase@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@V?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
$T219330 = -64						; size = 4
$T219312 = -60						; size = 4
$T219311 = -56						; size = 4
$T219295 = -52						; size = 4
__Cat$219319 = -46					; size = 1
$T219316 = -45						; size = 1
$T219269 = -44						; size = 4
$T219268 = -40						; size = 4
$T219267 = -36						; size = 4
$T219250 = -30						; size = 1
$T219249 = -29						; size = 1
$T219248 = -28						; size = 4
$T219247 = -24						; size = 4
__Cat$219257 = -16					; size = 1
$T219254 = -15						; size = 1
$T219253 = -14						; size = 1
$T219252 = -13						; size = 1
__Ptr$217091 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@V?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@0@Z PROC ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	$LN1@erase

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T219269[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T219268[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T219267[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T219252[ebp], cl
	mov	dl, BYTE PTR __Cat$219257[ebp]
	mov	BYTE PTR $T219253[ebp], dl
	mov	al, BYTE PTR $T219252[ebp]
	mov	BYTE PTR $T219250[ebp], al
	mov	cl, BYTE PTR $T219254[ebp]
	mov	BYTE PTR $T219249[ebp], cl
	mov	edx, DWORD PTR $T219269[ebp]
	mov	DWORD PTR $T219248[ebp], edx
	mov	eax, DWORD PTR $T219267[ebp]
	mov	DWORD PTR $T219247[ebp], eax
	jmp	SHORT $LN28@erase
$LN27@erase:
	mov	ecx, DWORD PTR $T219248[ebp]
	add	ecx, 8
	mov	DWORD PTR $T219248[ebp], ecx
	mov	edx, DWORD PTR $T219247[ebp]
	add	edx, 8
	mov	DWORD PTR $T219247[ebp], edx
$LN28@erase:
	mov	eax, DWORD PTR $T219247[ebp]
	cmp	eax, DWORD PTR $T219268[ebp]
	je	SHORT $LN20@erase
	mov	ecx, DWORD PTR $T219247[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T219248[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN27@erase
$LN20@erase:
	mov	edx, DWORD PTR $T219248[ebp]
	mov	DWORD PTR __Ptr$217091[ebp], edx

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T219330[ebp], ecx
	mov	edx, DWORD PTR $T219330[ebp]
	mov	DWORD PTR $T219312[ebp], edx
	mov	eax, DWORD PTR __Ptr$217091[ebp]
	mov	DWORD PTR $T219311[ebp], eax
	mov	cl, BYTE PTR __Cat$219319[ebp]
	mov	BYTE PTR $T219316[ebp], cl
	mov	edx, DWORD PTR $T219311[ebp]
	mov	DWORD PTR $T219295[ebp], edx
	jmp	SHORT $LN39@erase
$LN38@erase:
	mov	eax, DWORD PTR $T219295[ebp]
	add	eax, 8
	mov	DWORD PTR $T219295[ebp], eax
$LN39@erase:
	mov	ecx, DWORD PTR $T219295[ebp]
	cmp	ecx, DWORD PTR $T219312[ebp]
	je	SHORT $LN31@erase
	jmp	SHORT $LN38@erase
$LN31@erase:

; 1049 : 			_Mylast = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$217091[ebp]
	mov	DWORD PTR [edx+8], eax
$LN1@erase:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@V?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@0@Z ENDP ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::erase
_TEXT	ENDS
PUBLIC	??$_Allocate@UCvSparseIDInfoGridEntry@@@std@@YAPAUCvSparseIDInfoGridEntry@@IPAU1@@Z ; std::_Allocate<CvSparseIDInfoGridEntry>
PUBLIC	?_Xlen@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@KAXXZ ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$219345 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy
	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$219345[ebp], 536870911 ; 1fffffffH
	cmp	DWORD PTR __Count$219345[ebp], 0
	jbe	SHORT $LN11@Buy
	mov	eax, DWORD PTR __Count$219345[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy
$LN11@Buy:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@KAXXZ ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@UCvSparseIDInfoGridEntry@@@std@@YAPAUCvSparseIDInfoGridEntry@@IPAU1@@Z ; std::_Allocate<CvSparseIDInfoGridEntry>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T219441 = -32						; size = 4
$T219440 = -28						; size = 4
$T219436 = -24						; size = 4
$T219435 = -20						; size = 4
$T219417 = -16						; size = 4
$T219416 = -12						; size = 4
$T219400 = -8						; size = 4
__Cat$219424 = -2					; size = 1
$T219421 = -1						; size = 1
?_Tidy@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXXZ PROC ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T219436[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T219435[ebp], ecx
	mov	edx, DWORD PTR $T219436[ebp]
	mov	DWORD PTR $T219417[ebp], edx
	mov	eax, DWORD PTR $T219435[ebp]
	mov	DWORD PTR $T219416[ebp], eax
	mov	cl, BYTE PTR __Cat$219424[ebp]
	mov	BYTE PTR $T219421[ebp], cl
	mov	edx, DWORD PTR $T219416[ebp]
	mov	DWORD PTR $T219400[ebp], edx
	jmp	SHORT $LN12@Tidy
$LN11@Tidy:
	mov	eax, DWORD PTR $T219400[ebp]
	add	eax, 8
	mov	DWORD PTR $T219400[ebp], eax
$LN12@Tidy:
	mov	ecx, DWORD PTR $T219400[ebp]
	cmp	ecx, DWORD PTR $T219417[ebp]
	je	SHORT $LN4@Tidy
	jmp	SHORT $LN11@Tidy
$LN4@Tidy:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 3
	mov	DWORD PTR $T219441[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T219440[ebp], eax
	mov	ecx, DWORD PTR $T219440[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Tidy
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *,std::allocator<CvSparseIDInfoGridEntry> >
PUBLIC	??$unchecked_uninitialized_copy@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@stdext@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *,std::allocator<CvSparseIDInfoGridEntry> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z$2
__catchsym$?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z$0
__unwindtable$?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z$5
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z$6
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z
_TEXT	SEGMENT
tv84 = -432						; size = 4
tv304 = -428						; size = 4
tv290 = -424						; size = 4
tv282 = -420						; size = 4
_this$ = -416						; size = 4
$T220125 = -412						; size = 4
$T220117 = -408						; size = 4
$T220116 = -404						; size = 4
$T220093 = -398						; size = 1
$T220092 = -397						; size = 1
$T220091 = -396						; size = 4
$T220090 = -392						; size = 4
$T220078 = -385						; size = 1
$T220077 = -384						; size = 4
$T220076 = -380						; size = 4
$T220075 = -376						; size = 4
__Cat$220110 = -372					; size = 1
$T220108 = -371						; size = 1
$T220107 = -370						; size = 1
__Cat$220100 = -368					; size = 1
$T220098 = -367						; size = 1
$T220097 = -366						; size = 1
$T220096 = -365						; size = 1
$T220050 = -364						; size = 4
$T220031 = -360						; size = 4
$T220014 = -353						; size = 1
$T220013 = -352						; size = 4
$T220003 = -348						; size = 4
$T220002 = -344						; size = 4
__Cat$220048 = -338					; size = 1
$T220046 = -337						; size = 1
$T220045 = -336						; size = 1
__Cat$220039 = -335					; size = 1
$T220037 = -334						; size = 1
$T220036 = -333						; size = 1
$T219978 = -332						; size = 4
$T219970 = -328						; size = 4
$T219962 = -324						; size = 4
$T219944 = -320						; size = 4
$T219943 = -316						; size = 4
$T219927 = -312						; size = 4
__Cat$219951 = -306					; size = 1
$T219949 = -305						; size = 1
$T219901 = -304						; size = 4
$T219900 = -300						; size = 4
$T219890 = -296						; size = 4
__Cat$219898 = -291					; size = 1
$T219896 = -290						; size = 1
$T219895 = -289						; size = 1
$T219874 = -288						; size = 4
$T219855 = -284						; size = 4
$T219838 = -277						; size = 1
$T219837 = -276						; size = 4
$T219827 = -272						; size = 4
$T219826 = -268						; size = 4
__Cat$219872 = -262					; size = 1
$T219870 = -261						; size = 1
$T219869 = -260						; size = 1
__Cat$219863 = -259					; size = 1
$T219861 = -258						; size = 1
$T219860 = -257						; size = 1
$T219802 = -256						; size = 4
$T219801 = -252						; size = 4
$T219797 = -248						; size = 4
$T219796 = -244						; size = 4
$T219778 = -240						; size = 4
$T219777 = -236						; size = 4
$T219761 = -232						; size = 4
__Cat$219785 = -226					; size = 1
$T219783 = -225						; size = 1
$T219712 = -224						; size = 4
$T219711 = -220						; size = 4
$T219695 = -216						; size = 4
__Cat$219719 = -210					; size = 1
$T219717 = -209						; size = 1
$T219652 = -208						; size = 4
$T219651 = -204						; size = 4
$T219635 = -200						; size = 4
__Cat$219659 = -194					; size = 1
$T219657 = -193						; size = 1
$T219609 = -192						; size = 4
$T219597 = -188						; size = 4
$T219587 = -181						; size = 1
$T219586 = -180						; size = 4
__Cat$219605 = -175					; size = 1
$T219602 = -174						; size = 1
$T219601 = -173						; size = 1
$T219574 = -172						; size = 4
$T219562 = -168						; size = 4
$T219552 = -161						; size = 1
$T219551 = -160						; size = 4
__Cat$219570 = -155					; size = 1
$T219567 = -154						; size = 1
$T219566 = -153						; size = 1
$T219539 = -152						; size = 4
$T219529 = -148						; size = 4
__Cat$219538 = -143					; size = 1
$T219535 = -142						; size = 1
$T219534 = -141						; size = 1
__Count$219499 = -128					; size = 4
__Count$219473 = -56					; size = 4
__Tmp$217182 = -52					; size = 8
__Oldend$217183 = -44					; size = 4
__Tmp$217172 = -40					; size = 8
__Ncopied$217159 = -32					; size = 4
__Newvec$217157 = -28					; size = 4
__Whereoff$217158 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z PROC ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 416				; 000001a0H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN29@Insert_n
	mov	DWORD PTR tv282[ebp], 0
	jmp	SHORT $LN27@Insert_n
$LN29@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 3
	mov	DWORD PTR tv282[ebp], eax
$LN27@Insert_n:
	mov	ecx, DWORD PTR tv282[ebp]
	mov	DWORD PTR __Capacity$[ebp], ecx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n
	jmp	$LN16@Insert_n
$LN14@Insert_n:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$219473[ebp], 536870911 ; 1fffffffH
	cmp	DWORD PTR __Count$219473[ebp], 0
	jbe	SHORT $LN35@Insert_n
	mov	edx, DWORD PTR __Count$219473[ebp]
	mov	DWORD PTR tv290[ebp], edx
	jmp	SHORT $LN37@Insert_n
$LN35@Insert_n:
	mov	DWORD PTR tv290[ebp], 1
$LN37@Insert_n:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 3
	mov	eax, DWORD PTR tv290[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN42@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@KAXXZ ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Xlen
	jmp	$LN16@Insert_n

; 1167 : 		else if (_Capacity < size() + _Count)

$LN42@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 3
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$219499[ebp], 536870911 ; 1fffffffH
	cmp	DWORD PTR __Count$219499[ebp], 0
	jbe	SHORT $LN48@Insert_n
	mov	ecx, DWORD PTR __Count$219499[ebp]
	mov	DWORD PTR tv304[ebp], ecx
	jmp	SHORT $LN44@Insert_n
$LN48@Insert_n:
	mov	DWORD PTR tv304[ebp], 1
$LN44@Insert_n:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	mov	eax, DWORD PTR tv304[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	add	ecx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], ecx
$LN18@Insert_n:
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1171 : 			if (_Capacity < size() + _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 3
	add	edx, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], edx
	jae	SHORT $LN54@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 3
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN54@Insert_n:
	push	0
	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	call	??$_Allocate@UCvSparseIDInfoGridEntry@@@std@@YAPAUCvSparseIDInfoGridEntry@@IPAU1@@Z ; std::_Allocate<CvSparseIDInfoGridEntry>
	add	esp, 8
	mov	DWORD PTR __Newvec$217157[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 3
	mov	DWORD PTR __Whereoff$217158[ebp], edx

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$217159[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Whereoff$217158[ebp]
	mov	ecx, DWORD PTR __Newvec$217157[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR $T219539[ebp], edx
	mov	eax, DWORD PTR $T219539[ebp]
	mov	DWORD PTR $T219529[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T219534[ebp], cl
	mov	dl, BYTE PTR __Cat$219538[ebp]
	mov	BYTE PTR $T219535[ebp], dl
	movzx	eax, BYTE PTR $T219534[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T219535[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T219529[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAUCvSparseIDInfoGridEntry@@IU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAXPAUCvSparseIDInfoGridEntry@@IABU1@AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvSparseIDInfoGridEntry *,unsigned int,CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >
	add	esp, 24					; 00000018H

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$217159[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$217159[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T219574[ebp], edx
	mov	eax, DWORD PTR __Newvec$217157[ebp]
	mov	DWORD PTR $T219562[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T219566[ebp], cl
	mov	dl, BYTE PTR __Cat$219570[ebp]
	mov	BYTE PTR $T219567[ebp], dl
	mov	al, BYTE PTR $T219566[ebp]
	mov	BYTE PTR $T219552[ebp], al
	mov	ecx, DWORD PTR $T219562[ebp]
	mov	DWORD PTR $T219551[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T219551[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T219574[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@stdext@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *,std::allocator<CvSparseIDInfoGridEntry> >
	add	esp, 16					; 00000010H

; 1182 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$217159[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$217159[ebp], eax

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T219609[ebp], edx
	mov	eax, DWORD PTR __Whereoff$217158[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Newvec$217157[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR $T219597[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T219601[ebp], al
	mov	cl, BYTE PTR __Cat$219605[ebp]
	mov	BYTE PTR $T219602[ebp], cl
	mov	dl, BYTE PTR $T219601[ebp]
	mov	BYTE PTR $T219587[ebp], dl
	mov	eax, DWORD PTR $T219597[ebp]
	mov	DWORD PTR $T219586[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T219586[ebp]
	push	edx
	mov	eax, DWORD PTR $T219609[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	call	??$unchecked_uninitialized_copy@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@stdext@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *,std::allocator<CvSparseIDInfoGridEntry> >
	add	esp, 16					; 00000010H
	jmp	$LN19@Insert_n
__catch$?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$217159[ebp], 1
	jle	SHORT $LN7@Insert_n

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	edx, DWORD PTR __Whereoff$217158[ebp]
	mov	eax, DWORD PTR __Newvec$217157[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T219652[ebp], ecx
	mov	edx, DWORD PTR __Newvec$217157[ebp]
	mov	DWORD PTR $T219651[ebp], edx
	mov	al, BYTE PTR __Cat$219659[ebp]
	mov	BYTE PTR $T219657[ebp], al
	mov	ecx, DWORD PTR $T219651[ebp]
	mov	DWORD PTR $T219635[ebp], ecx
	jmp	SHORT $LN91@Insert_n
$LN90@Insert_n:
	mov	edx, DWORD PTR $T219635[ebp]
	add	edx, 8
	mov	DWORD PTR $T219635[ebp], edx
$LN91@Insert_n:
	mov	eax, DWORD PTR $T219635[ebp]
	cmp	eax, DWORD PTR $T219652[ebp]
	je	SHORT $LN7@Insert_n
	jmp	SHORT $LN90@Insert_n
$LN7@Insert_n:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$217159[ebp], 0
	jle	SHORT $LN6@Insert_n

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Whereoff$217158[ebp]
	mov	edx, DWORD PTR __Newvec$217157[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T219712[ebp], edx
	mov	eax, DWORD PTR __Whereoff$217158[ebp]
	mov	ecx, DWORD PTR __Newvec$217157[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR $T219711[ebp], edx
	mov	al, BYTE PTR __Cat$219719[ebp]
	mov	BYTE PTR $T219717[ebp], al
	mov	ecx, DWORD PTR $T219711[ebp]
	mov	DWORD PTR $T219695[ebp], ecx
	jmp	SHORT $LN106@Insert_n
$LN105@Insert_n:
	mov	edx, DWORD PTR $T219695[ebp]
	add	edx, 8
	mov	DWORD PTR $T219695[ebp], edx
$LN106@Insert_n:
	mov	eax, DWORD PTR $T219695[ebp]
	cmp	eax, DWORD PTR $T219712[ebp]
	je	SHORT $LN6@Insert_n
	jmp	SHORT $LN105@Insert_n
$LN6@Insert_n:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	ecx, DWORD PTR __Newvec$217157[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN115@Insert_n
	ret	0
$LN19@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN115@Insert_n:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 3
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], ecx

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN5@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T219797[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T219796[ebp], eax
	mov	ecx, DWORD PTR $T219797[ebp]
	mov	DWORD PTR $T219778[ebp], ecx
	mov	edx, DWORD PTR $T219796[ebp]
	mov	DWORD PTR $T219777[ebp], edx
	mov	al, BYTE PTR __Cat$219785[ebp]
	mov	BYTE PTR $T219783[ebp], al
	mov	ecx, DWORD PTR $T219777[ebp]
	mov	DWORD PTR $T219761[ebp], ecx
	jmp	SHORT $LN125@Insert_n
$LN124@Insert_n:
	mov	edx, DWORD PTR $T219761[ebp]
	add	edx, 8
	mov	DWORD PTR $T219761[ebp], edx
$LN125@Insert_n:
	mov	eax, DWORD PTR $T219761[ebp]
	cmp	eax, DWORD PTR $T219778[ebp]
	je	SHORT $LN117@Insert_n
	jmp	SHORT $LN124@Insert_n
$LN117@Insert_n:

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 3
	mov	DWORD PTR $T219802[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T219801[ebp], edx
	mov	eax, DWORD PTR $T219801[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	ecx, DWORD PTR __Capacity$[ebp]
	mov	edx, DWORD PTR __Newvec$217157[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Newvec$217157[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newvec$217157[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	$LN16@Insert_n
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	sar	eax, 3
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$217172[ebp], edx
	mov	DWORD PTR __Tmp$217172[ebp+4], eax

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T219874[ebp], edx
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR $T219855[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T219860[ebp], al
	mov	cl, BYTE PTR __Cat$219863[ebp]
	mov	BYTE PTR $T219861[ebp], cl
	mov	dl, BYTE PTR $T219860[ebp]
	mov	BYTE PTR $T219838[ebp], dl
	mov	eax, DWORD PTR $T219855[ebp]
	mov	DWORD PTR $T219837[ebp], eax
	mov	ecx, DWORD PTR $T219837[ebp]
	mov	DWORD PTR $T219827[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T219826[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T219869[ebp], al
	mov	cl, BYTE PTR __Cat$219872[ebp]
	mov	BYTE PTR $T219870[ebp], cl
	movzx	edx, BYTE PTR $T219869[ebp]
	push	edx
	movzx	eax, BYTE PTR $T219870[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T219827[ebp]
	push	edx
	mov	eax, DWORD PTR $T219874[ebp]
	push	eax
	mov	ecx, DWORD PTR $T219826[ebp]
	push	ecx
	call	??$_Uninit_copy@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *,std::allocator<CvSparseIDInfoGridEntry> >
	add	esp, 24					; 00000018H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	sar	eax, 3
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, eax
	mov	DWORD PTR $T219901[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T219900[ebp], eax
	mov	ecx, DWORD PTR $T219900[ebp]
	mov	DWORD PTR $T219890[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T219895[ebp], dl
	mov	al, BYTE PTR __Cat$219898[ebp]
	mov	BYTE PTR $T219896[ebp], al
	movzx	ecx, BYTE PTR $T219895[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T219896[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$217172[ebp]
	push	ecx
	mov	edx, DWORD PTR $T219901[ebp]
	push	edx
	mov	eax, DWORD PTR $T219890[ebp]
	push	eax
	call	??$_Uninit_fill_n@PAUCvSparseIDInfoGridEntry@@IU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAXPAUCvSparseIDInfoGridEntry@@IABU1@AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvSparseIDInfoGridEntry *,unsigned int,CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >
	add	esp, 24					; 00000018H
	jmp	SHORT $LN21@Insert_n
__catch$?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	DWORD PTR $T219962[ebp], ecx
	mov	edx, DWORD PTR $T219962[ebp]
	mov	DWORD PTR $T219944[ebp], edx
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR $T219943[ebp], edx
	mov	al, BYTE PTR __Cat$219951[ebp]
	mov	BYTE PTR $T219949[ebp], al
	mov	ecx, DWORD PTR $T219943[ebp]
	mov	DWORD PTR $T219927[ebp], ecx
	jmp	SHORT $LN160@Insert_n
$LN159@Insert_n:
	mov	edx, DWORD PTR $T219927[ebp]
	add	edx, 8
	mov	DWORD PTR $T219927[ebp], edx
$LN160@Insert_n:
	mov	eax, DWORD PTR $T219927[ebp]
	cmp	eax, DWORD PTR $T219944[ebp]
	je	SHORT $LN152@Insert_n
	jmp	SHORT $LN159@Insert_n
$LN152@Insert_n:

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z$3
	ret	0
$LN21@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, eax
	mov	DWORD PTR $T219978[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T219970[ebp], eax
	jmp	SHORT $LN171@Insert_n
$LN170@Insert_n:
	mov	ecx, DWORD PTR $T219970[ebp]
	add	ecx, 8
	mov	DWORD PTR $T219970[ebp], ecx
$LN171@Insert_n:
	mov	edx, DWORD PTR $T219970[ebp]
	cmp	edx, DWORD PTR $T219978[ebp]
	je	SHORT $LN167@Insert_n
	mov	eax, DWORD PTR __Tmp$217172[ebp]
	mov	ecx, DWORD PTR __Tmp$217172[ebp+4]
	mov	edx, DWORD PTR $T219970[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN170@Insert_n
$LN167@Insert_n:

; 1232 : 			}
; 1233 : 		else

	jmp	$LN16@Insert_n
$LN3@Insert_n:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$217182[ebp], ecx
	mov	DWORD PTR __Tmp$217182[ebp+4], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Oldend$217183[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T220050[ebp], eax
	mov	ecx, DWORD PTR $T220050[ebp]
	mov	DWORD PTR $T220031[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T220036[ebp], dl
	mov	al, BYTE PTR __Cat$220039[ebp]
	mov	BYTE PTR $T220037[ebp], al
	mov	cl, BYTE PTR $T220036[ebp]
	mov	BYTE PTR $T220014[ebp], cl
	mov	edx, DWORD PTR $T220031[ebp]
	mov	DWORD PTR $T220013[ebp], edx
	mov	eax, DWORD PTR $T220013[ebp]
	mov	DWORD PTR $T220003[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 3
	mov	edx, DWORD PTR __Oldend$217183[ebp]
	sub	edx, ecx
	mov	DWORD PTR $T220002[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T220045[ebp], al
	mov	cl, BYTE PTR __Cat$220048[ebp]
	mov	BYTE PTR $T220046[ebp], cl
	movzx	edx, BYTE PTR $T220045[ebp]
	push	edx
	movzx	eax, BYTE PTR $T220046[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T220003[ebp]
	push	edx
	mov	eax, DWORD PTR __Oldend$217183[ebp]
	push	eax
	mov	ecx, DWORD PTR $T220002[ebp]
	push	ecx
	call	??$_Uninit_copy@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *,std::allocator<CvSparseIDInfoGridEntry> >
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, DWORD PTR __Oldend$217183[ebp]
	mov	DWORD PTR $T220117[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T220116[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T220096[ebp], dl
	mov	al, BYTE PTR __Cat$220100[ebp]
	mov	BYTE PTR $T220097[ebp], al
	mov	cl, BYTE PTR $T220096[ebp]
	mov	BYTE PTR $T220093[ebp], cl
	mov	dl, BYTE PTR $T220098[ebp]
	mov	BYTE PTR $T220092[ebp], dl
	mov	eax, DWORD PTR $T220117[ebp]
	mov	DWORD PTR $T220091[ebp], eax
	mov	ecx, DWORD PTR $T220116[ebp]
	mov	DWORD PTR $T220090[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T220107[ebp], dl
	mov	al, BYTE PTR __Cat$220110[ebp]
	mov	BYTE PTR $T220108[ebp], al
	mov	cl, BYTE PTR $T220107[ebp]
	mov	BYTE PTR $T220078[ebp], cl
	mov	edx, DWORD PTR $T220091[ebp]
	mov	DWORD PTR $T220077[ebp], edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR __Oldend$217183[ebp]
	sub	ecx, eax
	mov	DWORD PTR $T220076[ebp], ecx
	mov	edx, DWORD PTR $T220090[ebp]
	mov	DWORD PTR $T220075[ebp], edx
$LN197@Insert_n:
	mov	eax, DWORD PTR $T220075[ebp]
	cmp	eax, DWORD PTR $T220076[ebp]
	je	SHORT $LN186@Insert_n
	mov	ecx, DWORD PTR $T220076[ebp]
	sub	ecx, 8
	mov	DWORD PTR $T220076[ebp], ecx
	mov	edx, DWORD PTR $T220077[ebp]
	sub	edx, 8
	mov	DWORD PTR $T220077[ebp], edx
	mov	eax, DWORD PTR $T220076[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T220077[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN197@Insert_n
$LN186@Insert_n:

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T220125[ebp], ecx
	jmp	SHORT $LN204@Insert_n
$LN203@Insert_n:
	mov	edx, DWORD PTR $T220125[ebp]
	add	edx, 8
	mov	DWORD PTR $T220125[ebp], edx
$LN204@Insert_n:
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	cmp	DWORD PTR $T220125[ebp], edx
	je	SHORT $LN16@Insert_n
	mov	eax, DWORD PTR __Tmp$217182[ebp]
	mov	ecx, DWORD PTR __Tmp$217182[ebp+4]
	mov	edx, DWORD PTR $T220125[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN203@Insert_n
$LN16@Insert_n:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-436]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z ENDP ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Insert_n
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_Elength_error@std@@UAEPAXI@Z ; std::length_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_Elogic_error@std@@UAEPAXI@Z ; std::logic_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T220147 = -80						; size = 28
$T220146 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@KAXXZ PROC ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T220147[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T220146[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T220146[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T220147[ebp]
	push	eax
	lea	ecx, DWORD PTR $T220146[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T220146[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T220146[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T220147[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T220147[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T220146[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@KAXXZ ENDP ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Xlen
PUBLIC	__TI1H
PUBLIC	??_7?$FObjectPool@VCvIDInfoFixedVector@@@@6B@	; FObjectPool<CvIDInfoFixedVector>::`vftable'
PUBLIC	__CTA1H
PUBLIC	__CT??_R0H@84
PUBLIC	??_R0H@8					; int `RTTI Type Descriptor'
EXTRN	??1FCriticalSection@@QAE@XZ:PROC		; FCriticalSection::~FCriticalSection
EXTRN	??0FCriticalSection@@QAE@XZ:PROC		; FCriticalSection::FCriticalSection
EXTRN	??_E?$FObjectPool@VCvIDInfoFixedVector@@@@UAEPAXI@Z:PROC ; FObjectPool<CvIDInfoFixedVector>::`vector deleting destructor'
;	COMDAT ??_R0H@8
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
_DATA	SEGMENT
??_R0H@8 DD	FLAT:??_7type_info@@6B@			; int `RTTI Type Descriptor'
	DD	00H
	DB	'.H', 00H
_DATA	ENDS
;	COMDAT __CT??_R0H@84
xdata$x	SEGMENT
__CT??_R0H@84 DD 01H
	DD	FLAT:??_R0H@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT __CTA1H
xdata$x	SEGMENT
__CTA1H	DD	01H
	DD	FLAT:__CT??_R0H@84
xdata$x	ENDS
;	COMDAT __TI1H
xdata$x	SEGMENT
__TI1H	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA1H
xdata$x	ENDS
;	COMDAT ??_7?$FObjectPool@VCvIDInfoFixedVector@@@@6B@
CONST	SEGMENT
??_7?$FObjectPool@VCvIDInfoFixedVector@@@@6B@ DD FLAT:??_E?$FObjectPool@VCvIDInfoFixedVector@@@@UAEPAXI@Z ; FObjectPool<CvIDInfoFixedVector>::`vftable'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FObjectPool@VCvIDInfoFixedVector@@@@QAE@I_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FObjectPool@VCvIDInfoFixedVector@@@@QAE@I_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$FObjectPool@VCvIDInfoFixedVector@@@@QAE@I_N@Z$1
__ehfuncinfo$??0?$FObjectPool@VCvIDInfoFixedVector@@@@QAE@I_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$FObjectPool@VCvIDInfoFixedVector@@@@QAE@I_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjectpool.h
xdata$x	ENDS
;	COMDAT ??0?$FObjectPool@VCvIDInfoFixedVector@@@@QAE@I_N@Z
_TEXT	SEGMENT
tv93 = -48						; size = 4
_this$ = -44						; size = 4
$T220171 = -32						; size = 4
$T220170 = -28						; size = 4
$T220169 = -24						; size = 4
$T220168 = -20						; size = 4
_i$217240 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_uiSize$ = 8						; size = 4
_bGrow$ = 12						; size = 1
??0?$FObjectPool@VCvIDInfoFixedVector@@@@QAE@I_N@Z PROC	; FObjectPool<CvIDInfoFixedVector>::FObjectPool<CvIDInfoFixedVector>, COMDAT
; _this$ = ecx

; 95   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FObjectPool@VCvIDInfoFixedVector@@@@QAE@I_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$FObjectPool@VCvIDInfoFixedVector@@@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0FCriticalSection@@QAE@XZ		; FCriticalSection::FCriticalSection
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 96   : 	// Allocate the array memory
; 97   : 	m_pStorage = FNEW( FPoolNode[uiSize], c_eMPoolTypeContainer, 0 );

	xor	ecx, ecx
	mov	eax, DWORD PTR _uiSize$[ebp]
	mov	edx, 8
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T220168[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T220168[ebp]
	mov	DWORD PTR [eax+4], ecx

; 98   : 
; 99   : 	#ifndef		_NDS
; 100  : 	if (!m_pStorage)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN4@FObjectPoo

; 101  : 		throw(-1);

	mov	DWORD PTR $T220169[ebp], -1
	push	OFFSET __TI1H
	lea	eax, DWORD PTR $T220169[ebp]
	push	eax
	call	__CxxThrowException@8
$LN4@FObjectPoo:

; 102  : 	#endif	//	!_NDS
; 103  : 
; 104  : 	// Now pre-allocated each object in that array
; 105  : 	for (uint i = 0; i < uiSize; ++i)

	mov	DWORD PTR _i$217240[ebp], 0
	jmp	SHORT $LN3@FObjectPoo
$LN2@FObjectPoo:
	mov	ecx, DWORD PTR _i$217240[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$217240[ebp], ecx
$LN3@FObjectPoo:
	mov	edx, DWORD PTR _i$217240[ebp]
	cmp	edx, DWORD PTR _uiSize$[ebp]
	jae	SHORT $LN1@FObjectPoo

; 106  : 	{
; 107  : 		m_pStorage[i].pObject = FNEW( T, c_eMPoolTypeContainer, 0 );

	push	80					; 00000050H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T220171[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T220171[ebp], 0
	je	SHORT $LN7@FObjectPoo
	mov	ecx, DWORD PTR $T220171[ebp]
	call	??0?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<IDInfo,8,1,297,0>::FStaticVector<IDInfo,8,1,297,0>
	mov	eax, DWORD PTR $T220171[ebp]
	mov	DWORD PTR tv93[ebp], eax
	jmp	SHORT $LN8@FObjectPoo
$LN7@FObjectPoo:
	mov	DWORD PTR tv93[ebp], 0
$LN8@FObjectPoo:
	mov	ecx, DWORD PTR tv93[ebp]
	mov	DWORD PTR $T220170[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$217240[ebp]
	mov	edx, DWORD PTR $T220170[ebp]
	mov	DWORD PTR [eax+ecx*8], edx

; 108  : 		m_pStorage[i].bFree = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$217240[ebp]
	mov	BYTE PTR [ecx+edx*8+4], 1

; 109  : 	}

	jmp	SHORT $LN2@FObjectPoo
$LN1@FObjectPoo:

; 110  : 
; 111  : 	m_uiSize = uiSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiSize$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 112  : 	m_bGrow = bGrow;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR _bGrow$[ebp]
	mov	BYTE PTR [edx+36], al

; 113  : 	m_bFull = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+37], 0

; 114  : 	m_uiFirstFreeIndex = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+40], 0

; 115  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN6@FObjectPoo:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FObjectPool@VCvIDInfoFixedVector@@@@QAE@I_N@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1FCriticalSection@@QAE@XZ		; FCriticalSection::~FCriticalSection
__unwindfunclet$??0?$FObjectPool@VCvIDInfoFixedVector@@@@QAE@I_N@Z$1:
	mov	eax, DWORD PTR $T220171[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$??0?$FObjectPool@VCvIDInfoFixedVector@@@@QAE@I_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FObjectPool@VCvIDInfoFixedVector@@@@QAE@I_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FObjectPool@VCvIDInfoFixedVector@@@@QAE@I_N@Z ENDP	; FObjectPool<CvIDInfoFixedVector>::FObjectPool<CvIDInfoFixedVector>
PUBLIC	?GetNextFreeIndex@?$FObjectPool@VCvIDInfoFixedVector@@@@IAEIXZ ; FObjectPool<CvIDInfoFixedVector>::GetNextFreeIndex
EXTRN	?Leave@FCriticalSection@@QAEXXZ:PROC		; FCriticalSection::Leave
EXTRN	__imp__memmove:PROC
EXTRN	?Enter@FCriticalSection@@QAEXXZ:PROC		; FCriticalSection::Enter
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetFreeObject@?$FObjectPool@VCvIDInfoFixedVector@@@@QAEPAVCvIDInfoFixedVector@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFreeObject@?$FObjectPool@VCvIDInfoFixedVector@@@@QAEPAVCvIDInfoFixedVector@@XZ$0
__ehfuncinfo$?GetFreeObject@?$FObjectPool@VCvIDInfoFixedVector@@@@QAEPAVCvIDInfoFixedVector@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetFreeObject@?$FObjectPool@VCvIDInfoFixedVector@@@@QAEPAVCvIDInfoFixedVector@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?GetFreeObject@?$FObjectPool@VCvIDInfoFixedVector@@@@QAEPAVCvIDInfoFixedVector@@XZ
_TEXT	SEGMENT
tv140 = -60						; size = 4
_this$ = -56						; size = 4
$T220213 = -44						; size = 4
$T220203 = -40						; size = 4
$T220202 = -36						; size = 4
$T220201 = -32						; size = 4
$T220200 = -28						; size = 4
_i$217262 = -24						; size = 4
_pOldStorage$217256 = -20				; size = 4
_pReturnObj$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?GetFreeObject@?$FObjectPool@VCvIDInfoFixedVector@@@@QAEPAVCvIDInfoFixedVector@@XZ PROC ; FObjectPool<CvIDInfoFixedVector>::GetFreeObject, COMDAT
; _this$ = ecx

; 228  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetFreeObject@?$FObjectPool@VCvIDInfoFixedVector@@@@QAEPAVCvIDInfoFixedVector@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 229  : 	Lock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?Enter@FCriticalSection@@QAEXXZ		; FCriticalSection::Enter

; 230  : 
; 231  : 	T* pReturnObj = NULL;

	mov	DWORD PTR _pReturnObj$[ebp], 0

; 232  : 
; 233  : 	// Do we have any allocated objects not being used?
; 234  : 	if (m_bFull)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+37]
	test	ecx, ecx
	je	$LN7@GetFreeObj

; 235  : 	{
; 236  : 		// If we have no available objects, see if we should grow
; 237  : 		if (m_bGrow)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+36]
	test	eax, eax
	je	$LN7@GetFreeObj

; 238  : 		{
; 239  : 			// We want to grow - double the size of the storage and pre-allocate all the objects
; 240  : 			// (This is where we eat it to save time later)
; 241  : 			FPoolNode *pOldStorage = m_pStorage;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _pOldStorage$217256[ebp], edx

; 242  : 			m_pStorage = FNEW( FPoolNode[ m_uiSize * 2 ], c_eMPoolTypeFireWorks, 0);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+32]
	shl	eax, 1
	xor	ecx, ecx
	mov	edx, 8
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T220200[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T220200[ebp]
	mov	DWORD PTR [eax+4], ecx

; 243  : 			memmove( m_pStorage, pOldStorage, sizeof( FPoolNode ) * m_uiSize );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	shl	eax, 3
	push	eax
	mov	ecx, DWORD PTR _pOldStorage$217256[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 244  : 			SAFE_DELETE_ARRAY( pOldStorage );

	mov	ecx, DWORD PTR _pOldStorage$217256[ebp]
	mov	DWORD PTR $T220213[ebp], ecx
	mov	edx, DWORD PTR $T220213[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR _pOldStorage$217256[ebp], 0

; 245  : 
; 246  : 			// If we get a memory error, bad bad things will happen.  Just bail
; 247  : 			#ifndef		_NDS
; 248  : 			if (!m_pStorage)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN5@GetFreeObj

; 249  : 				throw(-1);

	mov	DWORD PTR $T220201[ebp], -1
	push	OFFSET __TI1H
	lea	ecx, DWORD PTR $T220201[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN5@GetFreeObj:

; 250  : 			#endif	//	!_NDS
; 251  : 
; 252  : 			// Pre-allocate and set each object in the array
; 253  : 			for (uint i = m_uiSize; i < (2*m_uiSize); ++i)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR _i$217262[ebp], eax
	jmp	SHORT $LN4@GetFreeObj
$LN3@GetFreeObj:
	mov	ecx, DWORD PTR _i$217262[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$217262[ebp], ecx
$LN4@GetFreeObj:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	shl	eax, 1
	cmp	DWORD PTR _i$217262[ebp], eax
	jae	SHORT $LN2@GetFreeObj

; 254  : 			{
; 255  : 				m_pStorage[i].pObject = FNEW( T, c_eMPoolTypeContainer, 0 );

	push	80					; 00000050H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T220203[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T220203[ebp], 0
	je	SHORT $LN10@GetFreeObj
	mov	ecx, DWORD PTR $T220203[ebp]
	call	??0?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<IDInfo,8,1,297,0>::FStaticVector<IDInfo,8,1,297,0>
	mov	ecx, DWORD PTR $T220203[ebp]
	mov	DWORD PTR tv140[ebp], ecx
	jmp	SHORT $LN11@GetFreeObj
$LN10@GetFreeObj:
	mov	DWORD PTR tv140[ebp], 0
$LN11@GetFreeObj:
	mov	edx, DWORD PTR tv140[ebp]
	mov	DWORD PTR $T220202[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$217262[ebp]
	mov	eax, DWORD PTR $T220202[ebp]
	mov	DWORD PTR [ecx+edx*8], eax

; 256  : 				m_pStorage[i].bFree = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$217262[ebp]
	mov	BYTE PTR [edx+eax*8+4], 1

; 257  : 			}

	jmp	SHORT $LN3@GetFreeObj
$LN2@GetFreeObj:

; 258  : 
; 259  : 			m_uiFirstFreeIndex = m_uiSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx+40], eax

; 260  : 			m_uiSize *= 2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	shl	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32], edx

; 261  : 			m_bFull = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+37], 0
$LN7@GetFreeObj:

; 262  : 		}
; 263  : 	}
; 264  : 
; 265  : 	// If we have free objects, give one to the caller
; 266  : 	if (!m_bFull)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+37]
	test	eax, eax
	jne	SHORT $LN1@GetFreeObj

; 267  : 	{
; 268  : 		// Set the free pointer
; 269  : 		pReturnObj = m_pStorage[m_uiFirstFreeIndex].pObject;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+edx*8]
	mov	DWORD PTR _pReturnObj$[ebp], edx

; 270  : 		m_pStorage[m_uiFirstFreeIndex].bFree = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	BYTE PTR [eax+ecx*8+4], 0

; 271  : 
; 272  : 		m_uiFirstFreeIndex = GetNextFreeIndex();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextFreeIndex@?$FObjectPool@VCvIDInfoFixedVector@@@@IAEIXZ ; FObjectPool<CvIDInfoFixedVector>::GetNextFreeIndex
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+40], eax
$LN1@GetFreeObj:

; 273  : 	}
; 274  : 
; 275  : 	Unlock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?Leave@FCriticalSection@@QAEXXZ		; FCriticalSection::Leave

; 276  : 
; 277  : 	return pReturnObj;

	mov	eax, DWORD PTR _pReturnObj$[ebp]
$LN9@GetFreeObj:

; 278  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetFreeObject@?$FObjectPool@VCvIDInfoFixedVector@@@@QAEPAVCvIDInfoFixedVector@@XZ$0:
	mov	eax, DWORD PTR $T220203[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?GetFreeObject@?$FObjectPool@VCvIDInfoFixedVector@@@@QAEPAVCvIDInfoFixedVector@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetFreeObject@?$FObjectPool@VCvIDInfoFixedVector@@@@QAEPAVCvIDInfoFixedVector@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetFreeObject@?$FObjectPool@VCvIDInfoFixedVector@@@@QAEPAVCvIDInfoFixedVector@@XZ ENDP ; FObjectPool<CvIDInfoFixedVector>::GetFreeObject
; Function compile flags: /Odtp
;	COMDAT ?Release@?$FObjectPool@VCvIDInfoFixedVector@@@@QAEXPAVCvIDInfoFixedVector@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$217277 = -4						; size = 4
_pObject$ = 8						; size = 4
?Release@?$FObjectPool@VCvIDInfoFixedVector@@@@QAEXPAVCvIDInfoFixedVector@@@Z PROC ; FObjectPool<CvIDInfoFixedVector>::Release, COMDAT
; _this$ = ecx

; 289  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 290  : 	// Thread-safety
; 291  : 	Lock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?Enter@FCriticalSection@@QAEXXZ		; FCriticalSection::Enter

; 292  : 
; 293  : 	// Find this pointer -> can we do better than linear search here?
; 294  : 	for (uint i = 0; i < m_uiSize; ++i)

	mov	DWORD PTR _i$217277[ebp], 0
	jmp	SHORT $LN5@Release
$LN4@Release:
	mov	eax, DWORD PTR _i$217277[ebp]
	add	eax, 1
	mov	DWORD PTR _i$217277[ebp], eax
$LN5@Release:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$217277[ebp]
	cmp	edx, DWORD PTR [ecx+32]
	jae	SHORT $LN3@Release

; 295  : 	{
; 296  : 		if (m_pStorage[i].pObject == pObject)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$217277[ebp]
	mov	eax, DWORD PTR [ecx+edx*8]
	cmp	eax, DWORD PTR _pObject$[ebp]
	jne	SHORT $LN2@Release

; 297  : 		{
; 298  : 			// We found it
; 299  : 			m_pStorage[i].bFree = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$217277[ebp]
	mov	BYTE PTR [edx+eax*8+4], 1

; 300  : 			m_bFull = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+37], 0

; 301  : 
; 302  : 			// See if we can move the first available index
; 303  : 			if (i < m_uiFirstFreeIndex)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$217277[ebp]
	cmp	eax, DWORD PTR [edx+40]
	jae	SHORT $LN1@Release

; 304  : 				m_uiFirstFreeIndex = i;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$217277[ebp]
	mov	DWORD PTR [ecx+40], edx
$LN1@Release:

; 305  : 
; 306  : 			break;

	jmp	SHORT $LN3@Release
$LN2@Release:

; 307  : 		}
; 308  : 	}

	jmp	SHORT $LN4@Release
$LN3@Release:

; 309  : 
; 310  : 	Unlock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?Leave@FCriticalSection@@QAEXXZ		; FCriticalSection::Leave

; 311  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Release@?$FObjectPool@VCvIDInfoFixedVector@@@@QAEXPAVCvIDInfoFixedVector@@@Z ENDP ; FObjectPool<CvIDInfoFixedVector>::Release
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R0?AVbad_alloc@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
xdata$x	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_Ebad_alloc@std@@UAEPAXI@Z ; std::bad_alloc::`vftable'
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
CONST	ENDS
;	COMDAT ??$_Allocate@UCvSparseIDInfoGridEntry@@@std@@YAPAUCvSparseIDInfoGridEntry@@IPAU1@@Z
_TEXT	SEGMENT
$T220254 = -16						; size = 4
$T220250 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UCvSparseIDInfoGridEntry@@@std@@YAPAUCvSparseIDInfoGridEntry@@IPAU1@@Z PROC ; std::_Allocate<CvSparseIDInfoGridEntry>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 8
	jae	SHORT $LN2@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T220254[ebp], 0
	lea	eax, DWORD PTR $T220254[ebp]
	push	eax
	lea	ecx, DWORD PTR $T220250[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T220250[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T220250[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 3
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@UCvSparseIDInfoGridEntry@@@std@@YAPAUCvSparseIDInfoGridEntry@@IPAU1@@Z ENDP ; std::_Allocate<CvSparseIDInfoGridEntry>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjectpool.h
_TEXT	ENDS
;	COMDAT ?GetNextFreeIndex@?$FObjectPool@VCvIDInfoFixedVector@@@@IAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNextFreeIndex@?$FObjectPool@VCvIDInfoFixedVector@@@@IAEIXZ PROC ; FObjectPool<CvIDInfoFixedVector>::GetNextFreeIndex, COMDAT
; _this$ = ecx

; 322  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 323  : 	// Find the next free index
; 324  : 	m_bFull = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+37], 1

; 325  : 	for (; m_uiFirstFreeIndex < m_uiSize; ++m_uiFirstFreeIndex)

	jmp	SHORT $LN4@GetNextFre@2
$LN3@GetNextFre@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+40], edx
$LN4@GetNextFre@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+40]
	cmp	eax, DWORD PTR [edx+32]
	jae	SHORT $LN2@GetNextFre@2

; 326  : 	{
; 327  : 		if (m_pStorage[m_uiFirstFreeIndex].bFree)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx+edx*8+4]
	test	edx, edx
	je	SHORT $LN1@GetNextFre@2

; 328  : 		{
; 329  : 			m_bFull = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+37], 0

; 330  : 			break;

	jmp	SHORT $LN2@GetNextFre@2
$LN1@GetNextFre@2:

; 331  : 		}
; 332  : 	}

	jmp	SHORT $LN3@GetNextFre@2
$LN2@GetNextFre@2:

; 333  : 
; 334  : 	return m_uiFirstFreeIndex;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+40]

; 335  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNextFreeIndex@?$FObjectPool@VCvIDInfoFixedVector@@@@IAEIXZ ENDP ; FObjectPool<CvIDInfoFixedVector>::GetNextFreeIndex
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAUCvSparseIDInfoGridEntry@@IU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAXPAUCvSparseIDInfoGridEntry@@IABU1@AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAUCvSparseIDInfoGridEntry@@IU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAXPAUCvSparseIDInfoGridEntry@@IABU1@AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAUCvSparseIDInfoGridEntry@@IU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAXPAUCvSparseIDInfoGridEntry@@IABU1@AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAUCvSparseIDInfoGridEntry@@IU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAXPAUCvSparseIDInfoGridEntry@@IABU1@AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAUCvSparseIDInfoGridEntry@@IU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAXPAUCvSparseIDInfoGridEntry@@IABU1@AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_fill_n@PAUCvSparseIDInfoGridEntry@@IU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAXPAUCvSparseIDInfoGridEntry@@IABU1@AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAUCvSparseIDInfoGridEntry@@IU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAXPAUCvSparseIDInfoGridEntry@@IABU1@AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAUCvSparseIDInfoGridEntry@@IU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAXPAUCvSparseIDInfoGridEntry@@IABU1@AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUCvSparseIDInfoGridEntry@@IU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAXPAUCvSparseIDInfoGridEntry@@IABU1@AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv84 = -32						; size = 4
$T220288 = -28						; size = 4
__Vptr$220294 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAUCvSparseIDInfoGridEntry@@IU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAXPAUCvSparseIDInfoGridEntry@@IABU1@AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<CvSparseIDInfoGridEntry *,unsigned int,CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAUCvSparseIDInfoGridEntry@@IU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAXPAUCvSparseIDInfoGridEntry@@IABU1@AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil
$LN5@Uninit_fil:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 8
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Vptr$220294[ebp], eax
	mov	ecx, DWORD PTR __Vptr$220294[ebp]
	mov	DWORD PTR $T220288[ebp], ecx
	cmp	DWORD PTR $T220288[ebp], 0
	je	SHORT $LN18@Uninit_fil
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T220288[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T220288[ebp]
	mov	DWORD PTR tv84[ebp], eax
	jmp	SHORT $LN14@Uninit_fil
$LN18@Uninit_fil:
	mov	DWORD PTR tv84[ebp], 0
$LN14@Uninit_fil:
	jmp	SHORT $LN5@Uninit_fil
$LN4@Uninit_fil:
	jmp	SHORT $LN10@Uninit_fil
__catch$??$_Uninit_fill_n@PAUCvSparseIDInfoGridEntry@@IU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAXPAUCvSparseIDInfoGridEntry@@IABU1@AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil
$LN2@Uninit_fil:
	mov	ecx, DWORD PTR __Next$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Next$[ebp], ecx
$LN3@Uninit_fil:
	mov	edx, DWORD PTR __Next$[ebp]
	cmp	edx, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil

; 407  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_fil
$LN1@Uninit_fil:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil
	ret	0
$LN10@Uninit_fil:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAUCvSparseIDInfoGridEntry@@IU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAXPAUCvSparseIDInfoGridEntry@@IABU1@AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAUCvSparseIDInfoGridEntry@@IU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAXPAUCvSparseIDInfoGridEntry@@IABU1@AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAUCvSparseIDInfoGridEntry@@IU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAXPAUCvSparseIDInfoGridEntry@@IABU1@AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CvSparseIDInfoGridEntry *,unsigned int,CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 34   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 36   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar@2
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@stdext@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@std@@@Z
_TEXT	SEGMENT
__Cat$220327 = -3					; size = 1
$T220323 = -2						; size = 1
$T220322 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@stdext@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *,std::allocator<CvSparseIDInfoGridEntry> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T220322[ebp], al
	mov	cl, BYTE PTR __Cat$220327[ebp]
	mov	BYTE PTR $T220323[ebp], cl
	movzx	edx, BYTE PTR $T220322[ebp]
	push	edx
	movzx	eax, BYTE PTR $T220323[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninit_copy@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *,std::allocator<CvSparseIDInfoGridEntry> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@stdext@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *,std::allocator<CvSparseIDInfoGridEntry> >
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv84 = -32						; size = 4
$T220352 = -28						; size = 4
__Vptr$220358 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *,std::allocator<CvSparseIDInfoGridEntry> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop
$LN5@Uninit_cop:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 8
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$220358[ebp], ecx
	mov	edx, DWORD PTR __Vptr$220358[ebp]
	mov	DWORD PTR $T220352[ebp], edx
	cmp	DWORD PTR $T220352[ebp], 0
	je	SHORT $LN18@Uninit_cop
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T220352[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR $T220352[ebp]
	mov	DWORD PTR tv84[ebp], ecx
	jmp	SHORT $LN14@Uninit_cop
$LN18@Uninit_cop:
	mov	DWORD PTR tv84[ebp], 0
$LN14@Uninit_cop:
	jmp	SHORT $LN5@Uninit_cop
$LN4@Uninit_cop:
	jmp	SHORT $LN10@Uninit_cop
__catch$??$_Uninit_copy@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop
$LN2@Uninit_cop:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 8
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_cop:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop

; 134  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_cop
$LN1@Uninit_cop:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *,std::allocator<CvSparseIDInfoGridEntry> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@

; 110  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	edx, DWORD PTR ___flags$[ebp]
	and	edx, 1
	je	SHORT $LN1@scalar@3
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplotmanager.h
;	COMDAT ?Find@CvIDInfoFixedVector@@QAEPAUIDInfo@@ABU2@@Z
_TEXT	SEGMENT
tv87 = -12						; size = 4
_this$ = -8						; size = 4
_itr$160440 = -4					; size = 4
_kInfo$ = 8						; size = 4
?Find@CvIDInfoFixedVector@@QAEPAUIDInfo@@ABU2@@Z PROC	; CvIDInfoFixedVector::Find, COMDAT
; _this$ = ecx

; 15   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 16   : 		for (iterator itr = begin(); itr != end(); ++itr)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _itr$160440[ebp], ecx
	jmp	SHORT $LN9@Find
$LN3@Find:
	mov	edx, DWORD PTR _itr$160440[ebp]
	add	edx, 8
	mov	DWORD PTR _itr$160440[ebp], edx
$LN9@Find:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*8]
	cmp	DWORD PTR _itr$160440[ebp], ecx
	je	SHORT $LN2@Find

; 17   : 		{
; 18   : 			if ((*itr) == kInfo)

	mov	edx, DWORD PTR _itr$160440[ebp]
	mov	eax, DWORD PTR _kInfo$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN13@Find
	mov	edx, DWORD PTR _itr$160440[ebp]
	mov	eax, DWORD PTR _kInfo$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN13@Find
	mov	DWORD PTR tv87[ebp], 1
	jmp	SHORT $LN11@Find
$LN13@Find:
	mov	DWORD PTR tv87[ebp], 0
$LN11@Find:
	movzx	edx, BYTE PTR tv87[ebp]
	test	edx, edx
	je	SHORT $LN1@Find

; 19   : 				return &(*itr);

	mov	eax, DWORD PTR _itr$160440[ebp]
	jmp	SHORT $LN5@Find
$LN1@Find:

; 20   : 		}

	jmp	SHORT $LN3@Find
$LN2@Find:

; 21   : 		return NULL;

	xor	eax, eax
$LN5@Find:

; 22   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?Find@CvIDInfoFixedVector@@QAEPAUIDInfo@@ABU2@@Z ENDP	; CvIDInfoFixedVector::Find
_TEXT	ENDS
PUBLIC	?erase@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAEXPAUIDInfo@@@Z ; FStaticVector<IDInfo,8,1,297,0>::erase
; Function compile flags: /Odtp
;	COMDAT ?Remove@CvIDInfoFixedVector@@QAE_NABUIDInfo@@@Z
_TEXT	SEGMENT
tv93 = -20						; size = 4
_this$ = -16						; size = 4
_itr$160457 = -4					; size = 4
_kInfo$ = 8						; size = 4
?Remove@CvIDInfoFixedVector@@QAE_NABUIDInfo@@@Z PROC	; CvIDInfoFixedVector::Remove, COMDAT
; _this$ = ecx

; 42   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 43   : 		for (iterator itr = begin(); itr != end(); ++itr)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _itr$160457[ebp], ecx
	jmp	SHORT $LN9@Remove@2
$LN3@Remove@2:
	mov	edx, DWORD PTR _itr$160457[ebp]
	add	edx, 8
	mov	DWORD PTR _itr$160457[ebp], edx
$LN9@Remove@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*8]
	cmp	DWORD PTR _itr$160457[ebp], ecx
	je	SHORT $LN2@Remove@2

; 44   : 		{
; 45   : 			if ((*itr) == kInfo)

	mov	edx, DWORD PTR _itr$160457[ebp]
	mov	eax, DWORD PTR _kInfo$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN13@Remove@2
	mov	edx, DWORD PTR _itr$160457[ebp]
	mov	eax, DWORD PTR _kInfo$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN13@Remove@2
	mov	DWORD PTR tv93[ebp], 1
	jmp	SHORT $LN11@Remove@2
$LN13@Remove@2:
	mov	DWORD PTR tv93[ebp], 0
$LN11@Remove@2:
	movzx	edx, BYTE PTR tv93[ebp]
	test	edx, edx
	je	SHORT $LN1@Remove@2

; 46   : 			{
; 47   : 				erase(itr);

	mov	eax, DWORD PTR _itr$160457[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAEXPAUIDInfo@@@Z ; FStaticVector<IDInfo,8,1,297,0>::erase

; 48   : 				return true;

	mov	al, 1
	jmp	SHORT $LN5@Remove@2
$LN1@Remove@2:

; 49   : 			}
; 50   : 		}

	jmp	SHORT $LN3@Remove@2
$LN2@Remove@2:

; 51   : 		return false;

	xor	al, al
$LN5@Remove@2:

; 52   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?Remove@CvIDInfoFixedVector@@QAE_NABUIDInfo@@@Z ENDP	; CvIDInfoFixedVector::Remove
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<IDInfo,8,1,297,0>::GrowSize
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?push_back@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAEIABUIDInfo@@@Z
_TEXT	SEGMENT
tv141 = -52						; size = 4
tv132 = -48						; size = 4
_this$ = -44						; size = 4
$T220435 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAEIABUIDInfo@@@Z PROC ; FStaticVector<IDInfo,8,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+76], 0

; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN35@push_back@2

; 679  : 			GrowSize(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<IDInfo,8,1,297,0>::GrowSize

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN35@push_back@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T220435[ebp], ecx
	cmp	DWORD PTR $T220435[ebp], 0
	je	SHORT $LN4@push_back@2
	mov	edx, DWORD PTR _element$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T220435[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T220435[ebp]
	mov	DWORD PTR tv132[ebp], eax
	jmp	SHORT $LN5@push_back@2
$LN4@push_back@2:
	mov	DWORD PTR tv132[ebp], 0
$LN5@push_back@2:

; 681  : 		return m_uiCurrSize++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv141[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR tv141[ebp]

; 682  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAEIABUIDInfo@@@Z ENDP ; FStaticVector<IDInfo,8,1,297,0>::push_back
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?erase@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAEXPAUIDInfo@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_i$199929 = -8						; size = 4
_uIndex$ = -4						; size = 4
_it$ = 8						; size = 4
?erase@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAEXPAUIDInfo@@@Z PROC ; FStaticVector<IDInfo,8,1,297,0>::erase, COMDAT
; _this$ = ecx

; 702  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 703  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+76], 0

; 704  : 
; 705  : 		unsigned int uIndex = it - m_pData;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _it$[ebp]
	sub	edx, DWORD PTR [ecx]
	sar	edx, 3
	mov	DWORD PTR _uIndex$[ebp], edx

; 706  : 
; 707  :         for(unsigned int i = uIndex; i + 1< m_uiCurrSize; ++i)

	mov	eax, DWORD PTR _uIndex$[ebp]
	mov	DWORD PTR _i$199929[ebp], eax
	jmp	SHORT $LN3@erase@2
$LN2@erase@2:
	mov	ecx, DWORD PTR _i$199929[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$199929[ebp], ecx
$LN3@erase@2:
	mov	edx, DWORD PTR _i$199929[ebp]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR [eax+4]
	jae	SHORT $LN1@erase@2

; 708  :         {
; 709  :             m_pData[i] = m_pData[i+1];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _i$199929[ebp]
	mov	ecx, DWORD PTR [edx+eax*8+8]
	mov	edx, DWORD PTR [edx+eax*8+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	esi, DWORD PTR _i$199929[ebp]
	mov	DWORD PTR [eax+esi*8], ecx
	mov	DWORD PTR [eax+esi*8+4], edx

; 710  :         }

	jmp	SHORT $LN2@erase@2
$LN1@erase@2:

; 711  : 		
; 712  : 		--m_uiCurrSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 713  : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAEXPAUIDInfo@@@Z ENDP ; FStaticVector<IDInfo,8,1,297,0>::erase
_TEXT	ENDS
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp
;	COMDAT ?GrowSize@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv179 = -44						; size = 4
_this$ = -40						; size = 4
$T220515 = -36						; size = 4
$T220514 = -32						; size = 4
_i$220510 = -28						; size = 4
$T220490 = -24						; size = 4
_pRet$220486 = -20					; size = 4
$T220481 = -16						; size = 4
_i$201554 = -12						; size = 4
_uiNewSize$201546 = -8					; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<IDInfo,8,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@GrowSize
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jb	SHORT $LN7@GrowSize

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	DWORD PTR _uiNewSize$201546[ebp], edx

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$201546[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN6@GrowSize

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 754  : 				break;

	jmp	SHORT $LN7@GrowSize
$LN6@GrowSize:

; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$201546[ebp]
	mov	DWORD PTR [ecx+8], edx

; 759  : 		}

	jmp	SHORT $LN8@GrowSize
$LN7@GrowSize:

; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T220490[ebp], ecx
	cmp	DWORD PTR $T220490[ebp], 8
	jbe	SHORT $LN15@GrowSize
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T220490[ebp]
	shl	edx, 3
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$220486[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T220490[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN16@GrowSize
$LN15@GrowSize:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$220486[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 8
$LN16@GrowSize:
	mov	ecx, DWORD PTR _pRet$220486[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 762  : 		if( bPODType ){

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@GrowSize

; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 764  : 		}else{

	jmp	SHORT $LN4@GrowSize
$LN5@GrowSize:

; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$201554[ebp], 0
	jmp	SHORT $LN3@GrowSize
$LN2@GrowSize:
	mov	edx, DWORD PTR _i$201554[ebp]
	add	edx, 1
	mov	DWORD PTR _i$201554[ebp], edx
$LN3@GrowSize:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$201554[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN4@GrowSize

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$201554[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T220481[ebp], ecx
	cmp	DWORD PTR $T220481[ebp], 0
	je	SHORT $LN12@GrowSize
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _i$201554[ebp]
	mov	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR [eax+ecx*8+4]
	mov	ecx, DWORD PTR $T220481[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T220481[ebp]
	mov	DWORD PTR tv179[ebp], edx
	jmp	SHORT $LN13@GrowSize
$LN12@GrowSize:
	mov	DWORD PTR tv179[ebp], 0
$LN13@GrowSize:
	jmp	SHORT $LN2@GrowSize
$LN4@GrowSize:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T220515[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T220514[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN21@GrowSize
	xor	edx, edx
	je	SHORT $LN21@GrowSize
	mov	DWORD PTR _i$220510[ebp], 0
	jmp	SHORT $LN26@GrowSize
$LN25@GrowSize:
	mov	eax, DWORD PTR _i$220510[ebp]
	add	eax, 1
	mov	DWORD PTR _i$220510[ebp], eax
$LN26@GrowSize:
	mov	ecx, DWORD PTR _i$220510[ebp]
	cmp	ecx, DWORD PTR $T220515[ebp]
	jae	SHORT $LN21@GrowSize
	jmp	SHORT $LN25@GrowSize
$LN21@GrowSize:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T220514[ebp], edx
	je	SHORT $LN22@GrowSize
	mov	eax, DWORD PTR $T220514[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN22@GrowSize:

; 769  : 		m_pData = pTemp;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx], edx

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+76], 1

; 772  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<IDInfo,8,1,297,0>::GrowSize
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0length_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjectpool.h
xdata$x	SEGMENT
__unwindtable$??1?$FObjectPool@VCvIDInfoFixedVector@@@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FObjectPool@VCvIDInfoFixedVector@@@@UAE@XZ$0
__ehfuncinfo$??1?$FObjectPool@VCvIDInfoFixedVector@@@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FObjectPool@VCvIDInfoFixedVector@@@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FObjectPool@VCvIDInfoFixedVector@@@@UAE@XZ
_TEXT	SEGMENT
tv81 = -52						; size = 4
_this$ = -48						; size = 4
$T220583 = -44						; size = 4
$T220581 = -40						; size = 4
$T220534 = -24						; size = 4
$T220533 = -20						; size = 4
_i$207752 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FObjectPool@VCvIDInfoFixedVector@@@@UAE@XZ PROC	; FObjectPool<CvIDInfoFixedVector>::~FObjectPool<CvIDInfoFixedVector>, COMDAT
; _this$ = ecx

; 204  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FObjectPool@VCvIDInfoFixedVector@@@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$FObjectPool@VCvIDInfoFixedVector@@@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 205  : 	Lock(); 

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?Enter@FCriticalSection@@QAEXXZ		; FCriticalSection::Enter

; 206  : 
; 207  : 	// Get rid of each allocated object
; 208  : 	for (uint i = 0; i < m_uiSize; ++i)

	mov	DWORD PTR _i$207752[ebp], 0
	jmp	SHORT $LN4@FObjectPoo@2
$LN3@FObjectPoo@2:
	mov	ecx, DWORD PTR _i$207752[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$207752[ebp], ecx
$LN4@FObjectPoo@2:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$207752[ebp]
	cmp	eax, DWORD PTR [edx+32]
	jae	SHORT $LN2@FObjectPoo@2

; 209  : 	{
; 210  : 		if (m_pStorage[i].pObject)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$207752[ebp]
	cmp	DWORD PTR [edx+eax*8], 0
	je	SHORT $LN1@FObjectPoo@2

; 211  : 			delete m_pStorage[i].pObject;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$207752[ebp]
	mov	ecx, DWORD PTR [edx+eax*8]
	mov	DWORD PTR $T220534[ebp], ecx
	mov	edx, DWORD PTR $T220534[ebp]
	mov	DWORD PTR $T220533[ebp], edx
	cmp	DWORD PTR $T220533[ebp], 0
	je	SHORT $LN7@FObjectPoo@2
	mov	ecx, DWORD PTR $T220533[ebp]
	call	??1?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<IDInfo,8,1,297,0>::~FStaticVector<IDInfo,8,1,297,0>
	mov	eax, 1
	and	eax, 1
	je	SHORT $LN13@FObjectPoo@2
	mov	ecx, DWORD PTR $T220533[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN13@FObjectPoo@2:
	mov	edx, DWORD PTR $T220533[ebp]
	mov	DWORD PTR tv81[ebp], edx
	jmp	SHORT $LN1@FObjectPoo@2
$LN7@FObjectPoo@2:
	mov	DWORD PTR tv81[ebp], 0
$LN1@FObjectPoo@2:

; 212  : 	}

	jmp	SHORT $LN3@FObjectPoo@2
$LN2@FObjectPoo@2:

; 213  : 
; 214  : 	// Get rid of the array
; 215  : 	SAFE_DELETE_ARRAY(m_pStorage);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR $T220583[ebp], eax
	mov	ecx, DWORD PTR $T220583[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T220581[ebp], edx
	mov	eax, DWORD PTR $T220581[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T220583[ebp]
	mov	DWORD PTR [ecx], 0

; 216  : 	Unlock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?Leave@FCriticalSection@@QAEXXZ		; FCriticalSection::Leave

; 217  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1FCriticalSection@@QAE@XZ		; FCriticalSection::~FCriticalSection
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FObjectPool@VCvIDInfoFixedVector@@@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1FCriticalSection@@QAE@XZ		; FCriticalSection::~FCriticalSection
__ehhandler$??1?$FObjectPool@VCvIDInfoFixedVector@@@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FObjectPool@VCvIDInfoFixedVector@@@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FObjectPool@VCvIDInfoFixedVector@@@@UAE@XZ ENDP	; FObjectPool<CvIDInfoFixedVector>::~FObjectPool<CvIDInfoFixedVector>
; Function compile flags: /Odtp
;	COMDAT ??_G?$FObjectPool@VCvIDInfoFixedVector@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$FObjectPool@VCvIDInfoFixedVector@@@@UAEPAXI@Z PROC ; FObjectPool<CvIDInfoFixedVector>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$FObjectPool@VCvIDInfoFixedVector@@@@UAE@XZ ; FObjectPool<CvIDInfoFixedVector>::~FObjectPool<CvIDInfoFixedVector>
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@4
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$FObjectPool@VCvIDInfoFixedVector@@@@UAEPAXI@Z ENDP ; FObjectPool<CvIDInfoFixedVector>::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1CvIDInfoFixedVector@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
??1CvIDInfoFixedVector@@QAE@XZ PROC			; CvIDInfoFixedVector::~CvIDInfoFixedVector, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<IDInfo,8,1,297,0>::~FStaticVector<IDInfo,8,1,297,0>
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvIDInfoFixedVector@@QAE@XZ ENDP			; CvIDInfoFixedVector::~CvIDInfoFixedVector
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T220652 = -24						; size = 4
$T220651 = -20						; size = 4
_i$220647 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<IDInfo,8,1,297,0>::~FStaticVector<IDInfo,8,1,297,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T220652[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T220651[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN5@FStaticVec@3
	xor	edx, edx
	je	SHORT $LN5@FStaticVec@3
	mov	DWORD PTR _i$220647[ebp], 0
	jmp	SHORT $LN10@FStaticVec@3
$LN9@FStaticVec@3:
	mov	eax, DWORD PTR _i$220647[ebp]
	add	eax, 1
	mov	DWORD PTR _i$220647[ebp], eax
$LN10@FStaticVec@3:
	mov	ecx, DWORD PTR _i$220647[ebp]
	cmp	ecx, DWORD PTR $T220652[ebp]
	jae	SHORT $LN5@FStaticVec@3
	jmp	SHORT $LN9@FStaticVec@3
$LN5@FStaticVec@3:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T220651[ebp], edx
	je	SHORT $LN1@FStaticVec@3
	mov	eax, DWORD PTR $T220651[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@FStaticVec@3:

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UIDInfo@@$00@@QAE@XZ	; BaseVector<IDInfo,1>::~BaseVector<IDInfo,1>
__ehhandler$??1?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<IDInfo,8,1,297,0>::~FStaticVector<IDInfo,8,1,297,0>
; Function compile flags: /Odtp
;	COMDAT ??1?$BaseVector@UIDInfo@@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@UIDInfo@@$00@@QAE@XZ PROC		; BaseVector<IDInfo,1>::~BaseVector<IDInfo,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@UIDInfo@@$00@@QAE@XZ ENDP		; BaseVector<IDInfo,1>::~BaseVector<IDInfo,1>
_TEXT	ENDS
END
