; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvDealClasses.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAW4TradeableItems@@@Z ; operator>>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAW4TradeableItems@@@Z
_TEXT	SEGMENT
_v$ = -4						; size = 4
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAW4TradeableItems@@@Z PROC	; operator>>, COMDAT

; 24   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 25   : 	int v;
; 26   : 	loadFrom >> v;

	lea	eax, DWORD PTR _v$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 27   : 	writeTo = static_cast<TradeableItems>(v);

	mov	ecx, DWORD PTR _writeTo$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx], edx

; 28   : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 29   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??5@YAAAVFDataStream@@AAV0@AAW4TradeableItems@@@Z ENDP	; operator>>
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABW4TradeableItems@@@Z ; operator<<
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
; Function compile flags: /Odtp
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABW4TradeableItems@@@Z
_TEXT	SEGMENT
$T224801 = -4						; size = 4
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABW4TradeableItems@@@Z PROC	; operator<<, COMDAT

; 33   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 34   : 	saveTo << static_cast<int>(readFrom);

	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T224801[ebp], ecx
	lea	edx, DWORD PTR $T224801[ebp]
	push	edx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 35   : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 36   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??6@YAAAVFDataStream@@AAV0@ABW4TradeableItems@@@Z ENDP	; operator<<
_TEXT	ENDS
PUBLIC	??0CvTradedItem@@QAE@XZ				; CvTradedItem::CvTradedItem
; Function compile flags: /Odtp
;	COMDAT ??0CvTradedItem@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvTradedItem@@QAE@XZ PROC				; CvTradedItem::CvTradedItem, COMDAT
; _this$ = ecx

; 44   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 45   : 	m_eItemType = TRADE_ITEM_NONE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], -1

; 46   : 	m_iDuration = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 47   : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 48   : 	m_iTurnsRemaining = -1;
; 49   : #else
; 50   : 	m_iFinalTurn = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 51   : #endif
; 52   : 	m_iData1 = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 53   : 	m_iData2 = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 54   : 	m_iData3 = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 55   : 	m_bFlag1 = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+24], 0

; 56   : 	m_eFromPlayer = NO_PLAYER;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], -1

; 57   : 	m_bFromRenewed = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+32], 0

; 58   : 	m_bToRenewed = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+33], 0

; 59   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvTradedItem@@QAE@XZ ENDP				; CvTradedItem::CvTradedItem
_TEXT	ENDS
PUBLIC	??8CvTradedItem@@QBE_NABU0@@Z			; CvTradedItem::operator==
; Function compile flags: /Odtp
;	COMDAT ??8CvTradedItem@@QBE_NABU0@@Z
_TEXT	SEGMENT
tv88 = -8						; size = 4
_this$ = -4						; size = 4
_rhs$ = 8						; size = 4
??8CvTradedItem@@QBE_NABU0@@Z PROC			; CvTradedItem::operator==, COMDAT
; _this$ = ecx

; 63   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 64   : 	return (m_eItemType == rhs.m_eItemType &&
; 65   : 	        m_iData1 == rhs.m_iData1 &&
; 66   : 	        m_iData2 == rhs.m_iData2 &&
; 67   : 			m_iData3 == rhs.m_iData3 &&
; 68   : 			m_bFlag1 == rhs.m_bFlag1 &&
; 69   : 	        m_eFromPlayer == rhs.m_eFromPlayer &&
; 70   : 	        m_iDuration == rhs.m_iDuration &&
; 71   : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 72   : 			m_iTurnsRemaining == rhs.m_iTurnsRemaining);
; 73   : #else
; 74   : 	        m_iFinalTurn == rhs.m_iFinalTurn);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN3@operator
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $LN3@operator
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax+16]
	cmp	edx, DWORD PTR [ecx+16]
	jne	SHORT $LN3@operator
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax+20]
	cmp	edx, DWORD PTR [ecx+20]
	jne	SHORT $LN3@operator
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+24]
	mov	edx, DWORD PTR _rhs$[ebp]
	movzx	eax, BYTE PTR [edx+24]
	cmp	ecx, eax
	jne	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _rhs$[ebp]
	mov	eax, DWORD PTR [ecx+28]
	cmp	eax, DWORD PTR [edx+28]
	jne	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _rhs$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _rhs$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv88[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv88[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv88[ebp]

; 75   : #endif
; 76   : }

	mov	esp, ebp
	pop	ebp
	ret	4
??8CvTradedItem@@QBE_NABU0@@Z ENDP			; CvTradedItem::operator==
_TEXT	ENDS
PUBLIC	?OldLoad@@YAAAVFDataStream@@AAV1@AAUCvTradedItem@@@Z ; OldLoad
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z:PROC ; operator>>
; Function compile flags: /Odtp
;	COMDAT ?OldLoad@@YAAAVFDataStream@@AAV1@AAUCvTradedItem@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
?OldLoad@@YAAAVFDataStream@@AAV1@AAUCvTradedItem@@@Z PROC ; OldLoad, COMDAT

; 79   : {

	push	ebp
	mov	ebp, esp

; 80   : 	loadFrom >> writeTo.m_eItemType;

	mov	eax, DWORD PTR _writeTo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	push	ecx
	call	??5@YAAAVFDataStream@@AAV0@AAW4TradeableItems@@@Z ; operator>>
	add	esp, 8

; 81   : 	loadFrom >> writeTo.m_iDuration;

	mov	edx, DWORD PTR _writeTo$[ebp]
	add	edx, 4
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 82   : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 83   : 	loadFrom >> writeTo.m_iTurnsRemaining;
; 84   : #else
; 85   : 	loadFrom >> writeTo.m_iFinalTurn;

	mov	eax, DWORD PTR _writeTo$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 86   : #endif
; 87   : 	loadFrom >> writeTo.m_iData1;

	mov	ecx, DWORD PTR _writeTo$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 88   : 	loadFrom >> writeTo.m_iData2;

	mov	edx, DWORD PTR _writeTo$[ebp]
	add	edx, 16					; 00000010H
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 89   : 	loadFrom >> writeTo.m_eFromPlayer;

	mov	eax, DWORD PTR _writeTo$[ebp]
	add	eax, 28					; 0000001cH
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	push	ecx
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 90   : 	writeTo.m_bFromRenewed = false;

	mov	edx, DWORD PTR _writeTo$[ebp]
	mov	BYTE PTR [edx+32], 0

; 91   : 	writeTo.m_bToRenewed = false;

	mov	eax, DWORD PTR _writeTo$[ebp]
	mov	BYTE PTR [eax+33], 0

; 92   : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 93   : }

	pop	ebp
	ret	0
?OldLoad@@YAAAVFDataStream@@AAV1@AAUCvTradedItem@@@Z ENDP ; OldLoad
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAUCvTradedItem@@@Z	; operator>>
EXTRN	?Read@FDataStream@@IAEXAA_N@Z:PROC		; FDataStream::Read
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Odtp
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAUCvTradedItem@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAUCvTradedItem@@@Z PROC	; operator>>, COMDAT

; 97   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 98   : 	uint uiVersion;
; 99   : 	loadFrom >> uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 100  : 	loadFrom >> writeTo.m_eItemType;

	mov	ecx, DWORD PTR _writeTo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _loadFrom$[ebp]
	push	edx
	call	??5@YAAAVFDataStream@@AAV0@AAW4TradeableItems@@@Z ; operator>>
	add	esp, 8

; 101  : 	loadFrom >> writeTo.m_iDuration;

	mov	eax, DWORD PTR _writeTo$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 102  : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 103  : 	loadFrom >> writeTo.m_iTurnsRemaining;
; 104  : #else
; 105  : 	loadFrom >> writeTo.m_iFinalTurn;

	mov	ecx, DWORD PTR _writeTo$[ebp]
	add	ecx, 8
	push	ecx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 106  : #endif
; 107  : 	loadFrom >> writeTo.m_iData1;

	mov	edx, DWORD PTR _writeTo$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 108  : 	loadFrom >> writeTo.m_iData2;

	mov	eax, DWORD PTR _writeTo$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 109  : 	if (uiVersion >= 2)

	cmp	DWORD PTR _uiVersion$[ebp], 2
	jb	SHORT $LN2@operator@2

; 110  : 	{
; 111  : 		loadFrom >> writeTo.m_iData3;

	mov	ecx, DWORD PTR _writeTo$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 112  : 		loadFrom >> writeTo.m_bFlag1;

	mov	edx, DWORD PTR _writeTo$[ebp]
	add	edx, 24					; 00000018H
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 113  : 	}
; 114  : 	else

	jmp	SHORT $LN1@operator@2
$LN2@operator@2:

; 115  : 	{
; 116  : 		writeTo.m_iData3 = 0;

	mov	eax, DWORD PTR _writeTo$[ebp]
	mov	DWORD PTR [eax+20], 0

; 117  : 		writeTo.m_bFlag1 = false;

	mov	ecx, DWORD PTR _writeTo$[ebp]
	mov	BYTE PTR [ecx+24], 0
$LN1@operator@2:

; 118  : 	}
; 119  : 	loadFrom >> writeTo.m_eFromPlayer;

	mov	edx, DWORD PTR _writeTo$[ebp]
	add	edx, 28					; 0000001cH
	push	edx
	mov	eax, DWORD PTR _loadFrom$[ebp]
	push	eax
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 120  : 	loadFrom >> writeTo.m_bFromRenewed;

	mov	ecx, DWORD PTR _writeTo$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 121  : 	loadFrom >> writeTo.m_bToRenewed;

	mov	edx, DWORD PTR _writeTo$[ebp]
	add	edx, 33					; 00000021H
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 122  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 123  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??5@YAAAVFDataStream@@AAV0@AAUCvTradedItem@@@Z ENDP	; operator>>
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABUCvTradedItem@@@Z	; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z:PROC ; operator<<
EXTRN	?Write@FDataStream@@IAEXAB_N@Z:PROC		; FDataStream::Write
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Odtp
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABUCvTradedItem@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABUCvTradedItem@@@Z PROC	; operator<<, COMDAT

; 127  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 128  : 	uint uiVersion = 2;

	mov	DWORD PTR _uiVersion$[ebp], 2

; 129  : 	saveTo << uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 130  : 	saveTo << readFrom.m_eItemType;

	mov	ecx, DWORD PTR _readFrom$[ebp]
	push	ecx
	mov	edx, DWORD PTR _saveTo$[ebp]
	push	edx
	call	??6@YAAAVFDataStream@@AAV0@ABW4TradeableItems@@@Z ; operator<<
	add	esp, 8

; 131  : 	saveTo << readFrom.m_iDuration;

	mov	eax, DWORD PTR _readFrom$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 132  : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 133  : 	saveTo << readFrom.m_iTurnsRemaining;
; 134  : #else
; 135  : 	saveTo << readFrom.m_iFinalTurn;

	mov	ecx, DWORD PTR _readFrom$[ebp]
	add	ecx, 8
	push	ecx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 136  : #endif
; 137  : 	saveTo << readFrom.m_iData1;

	mov	edx, DWORD PTR _readFrom$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 138  : 	saveTo << readFrom.m_iData2;

	mov	eax, DWORD PTR _readFrom$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 139  : 	saveTo << readFrom.m_iData3;

	mov	ecx, DWORD PTR _readFrom$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 140  : 	saveTo << readFrom.m_bFlag1;

	mov	edx, DWORD PTR _readFrom$[ebp]
	add	edx, 24					; 00000018H
	push	edx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 141  : 	saveTo << readFrom.m_eFromPlayer;

	mov	eax, DWORD PTR _readFrom$[ebp]
	add	eax, 28					; 0000001cH
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	push	ecx
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 8

; 142  : 	saveTo << readFrom.m_bFromRenewed;

	mov	edx, DWORD PTR _readFrom$[ebp]
	add	edx, 32					; 00000020H
	push	edx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 143  : 	saveTo << readFrom.m_bToRenewed;

	mov	eax, DWORD PTR _readFrom$[ebp]
	add	eax, 33					; 00000021H
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 144  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 145  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??6@YAAAVFDataStream@@AAV0@ABUCvTradedItem@@@Z ENDP	; operator<<
_TEXT	ENDS
PUBLIC	??1?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ	; FFastList<CvTradedItem,21,0>::~FFastList<CvTradedItem,21,0>
PUBLIC	?UnLink@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAEXII@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::UnLink
PUBLIC	??0?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAE@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >
PUBLIC	??_7CvDeal@@6B@					; CvDeal::`vftable'
PUBLIC	??0CvDeal@@QAE@XZ				; CvDeal::CvDeal
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	??_ECvDeal@@UAEPAXI@Z:PROC			; CvDeal::`vector deleting destructor'
;	COMDAT ??_7CvDeal@@6B@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
CONST	SEGMENT
??_7CvDeal@@6B@ DD FLAT:??_ECvDeal@@UAEPAXI@Z		; CvDeal::`vftable'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CvDeal@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvDeal@@QAE@XZ$0
__ehfuncinfo$??0CvDeal@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvDeal@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ??0CvDeal@@QAE@XZ
_TEXT	SEGMENT
_this$ = -76						; size = 4
$T225046 = -72						; size = 4
$T224924 = -24						; size = 4
__$EHRec$ = -12						; size = 12
??0CvDeal@@QAE@XZ PROC					; CvDeal::CvDeal, COMDAT
; _this$ = ecx

; 153  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvDeal@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvDeal@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	mov	DWORD PTR $T224924[ebp], ecx
	mov	ecx, DWORD PTR $T224924[ebp]
	call	??0?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAE@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 154  : 	m_eFromPlayer = NO_PLAYER;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], -1

; 155  : 	m_eToPlayer = NO_PLAYER;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], -1

; 156  : 	m_ePeaceTreatyType = NO_PEACE_TREATY_TYPE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], -1

; 157  : 	m_eSurrenderingPlayer = NO_PLAYER;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], -1

; 158  : 	m_eDemandingPlayer = NO_PLAYER;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32], -1

; 159  : 	m_eRequestingPlayer = NO_PLAYER;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+36], -1

; 160  : 	m_TradedItems.clear();

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 44					; 0000002cH
	mov	DWORD PTR $T225046[ebp], edx
	push	268435455				; 0fffffffH
	mov	eax, DWORD PTR $T225046[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	ecx, DWORD PTR $T225046[ebp]
	call	?UnLink@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAEXII@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::UnLink

; 161  : 	m_iStartTurn = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 162  : #ifdef AUI_WARNING_FIXES
; 163  : 	m_iFinalTurn = 0;
; 164  : 	m_iDuration = 0;
; 165  : #endif
; 166  : 	m_bConsideringForRenewal = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+40], 0

; 167  : 	m_bCheckedForRenewal = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+41], 0

; 168  : 	m_bDealCancelled = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+42], 0

; 169  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvDeal@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	jmp	??1?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ
__ehhandler$??0CvDeal@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-68]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvDeal@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvDeal@@QAE@XZ ENDP					; CvDeal::CvDeal
PUBLIC	??1CvDeal@@UAE@XZ				; CvDeal::~CvDeal
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp
;	COMDAT ??_GCvDeal@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCvDeal@@UAEPAXI@Z PROC				; CvDeal::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvDeal@@UAE@XZ			; CvDeal::~CvDeal
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCvDeal@@UAEPAXI@Z ENDP				; CvDeal::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@IAE@XZ ; FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> >::~FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> >
; Function compile flags: /Odtp
;	COMDAT ??1?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
??1?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ PROC	; FFastList<CvTradedItem,21,0>::~FFastList<CvTradedItem,21,0>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@IAE@XZ ; FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> >::~FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> >
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ENDP	; FFastList<CvTradedItem,21,0>::~FFastList<CvTradedItem,21,0>
_TEXT	ENDS
PUBLIC	??0CvDeal@@QAE@W4PlayerTypes@@0@Z		; CvDeal::CvDeal
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
xdata$x	SEGMENT
__unwindtable$??0CvDeal@@QAE@W4PlayerTypes@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvDeal@@QAE@W4PlayerTypes@@0@Z$0
__ehfuncinfo$??0CvDeal@@QAE@W4PlayerTypes@@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvDeal@@QAE@W4PlayerTypes@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ??0CvDeal@@QAE@W4PlayerTypes@@0@Z
_TEXT	SEGMENT
_this$ = -76						; size = 4
$T225319 = -72						; size = 4
$T225197 = -24						; size = 4
__$EHRec$ = -12						; size = 12
_eFromPlayer$ = 8					; size = 4
_eToPlayer$ = 12					; size = 4
??0CvDeal@@QAE@W4PlayerTypes@@0@Z PROC			; CvDeal::CvDeal, COMDAT
; _this$ = ecx

; 173  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvDeal@@QAE@W4PlayerTypes@@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvDeal@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	mov	DWORD PTR $T225197[ebp], ecx
	mov	ecx, DWORD PTR $T225197[ebp]
	call	??0?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAE@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 174  : 	m_eFromPlayer = eFromPlayer;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _eFromPlayer$[ebp]
	mov	DWORD PTR [edx+4], eax

; 175  : 	m_eToPlayer = eToPlayer;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _eToPlayer$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 176  : 	m_TradedItems.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	mov	DWORD PTR $T225319[ebp], eax
	push	268435455				; 0fffffffH
	mov	ecx, DWORD PTR $T225319[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	ecx, DWORD PTR $T225319[ebp]
	call	?UnLink@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAEXII@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::UnLink

; 177  : 	m_bConsideringForRenewal = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+40], 0

; 178  : 	m_bCheckedForRenewal = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+41], 0

; 179  : 	m_bDealCancelled = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+42], 0

; 180  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvDeal@@QAE@W4PlayerTypes@@0@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	jmp	??1?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ
__ehhandler$??0CvDeal@@QAE@W4PlayerTypes@@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-68]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvDeal@@QAE@W4PlayerTypes@@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvDeal@@QAE@W4PlayerTypes@@0@Z ENDP			; CvDeal::CvDeal
PUBLIC	??1const_iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::const_iterator::~const_iterator
PUBLIC	?push_back_existing@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEXI@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::push_back_existing
PUBLIC	?Alloc@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::Alloc
PUBLIC	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QBE?AVconst_iterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
PUBLIC	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QBE?AVconst_iterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
PUBLIC	??0CvDeal@@QAE@ABV0@@Z				; CvDeal::CvDeal
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
xdata$x	SEGMENT
__unwindtable$??0CvDeal@@QAE@ABV0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvDeal@@QAE@ABV0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvDeal@@QAE@ABV0@@Z$1
__ehfuncinfo$??0CvDeal@@QAE@ABV0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CvDeal@@QAE@ABV0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ??0CvDeal@@QAE@ABV0@@Z
_TEXT	SEGMENT
tv170 = -160						; size = 4
_this$ = -156						; size = 4
$T225544 = -152						; size = 4
$T225543 = -148						; size = 4
_uiNewIndex$225538 = -116				; size = 4
$T225534 = -112						; size = 44
$T225454 = -68						; size = 4
$T225431 = -64						; size = 4
$T225415 = -60						; size = 4
$T225411 = -56						; size = 4
$T225402 = -52						; size = 4
$T225354 = -48						; size = 4
$T225345 = -44						; size = 4
$T225330 = -40						; size = 8
$T225329 = -29						; size = 1
$T225328 = -28						; size = 8
_it$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_source$ = 8						; size = 4
??0CvDeal@@QAE@ABV0@@Z PROC				; CvDeal::CvDeal, COMDAT
; _this$ = ecx

; 184  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvDeal@@QAE@ABV0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 148				; 00000094H
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvDeal@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	mov	DWORD PTR $T225345[ebp], ecx
	mov	ecx, DWORD PTR $T225345[ebp]
	call	??0?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAE@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 185  : 	m_eFromPlayer = source.m_eFromPlayer;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 186  : 	m_eToPlayer = source.m_eToPlayer;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx

; 187  : 	m_iDuration = source.m_iDuration;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+20], ecx

; 188  : 	m_iFinalTurn = source.m_iFinalTurn;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], ecx

; 189  : 	m_iStartTurn = source.m_iStartTurn;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], ecx

; 190  : 	m_ePeaceTreatyType = source.m_ePeaceTreatyType;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [edx+24], ecx

; 191  : 	m_eSurrenderingPlayer = source.m_eSurrenderingPlayer;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR [edx+28], ecx

; 192  : 	m_eDemandingPlayer = source.m_eDemandingPlayer;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR [edx+32], ecx

; 193  : 	m_eRequestingPlayer = source.m_eRequestingPlayer;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [edx+36], ecx

; 194  : 	m_bConsideringForRenewal = source.m_bConsideringForRenewal;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _source$[ebp]
	mov	cl, BYTE PTR [eax+40]
	mov	BYTE PTR [edx+40], cl

; 195  : 	m_bCheckedForRenewal = source.m_bCheckedForRenewal;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _source$[ebp]
	mov	cl, BYTE PTR [eax+41]
	mov	BYTE PTR [edx+41], cl

; 196  : 	m_bDealCancelled = source.m_bDealCancelled;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _source$[ebp]
	mov	cl, BYTE PTR [eax+42]
	mov	BYTE PTR [edx+42], cl

; 197  : 	m_TradedItems.clear();

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 44					; 0000002cH
	mov	DWORD PTR $T225354[ebp], edx
	push	268435455				; 0fffffffH
	mov	eax, DWORD PTR $T225354[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	ecx, DWORD PTR $T225354[ebp]
	call	?UnLink@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAEXII@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::UnLink

; 198  : 	TradedItemList::const_iterator it;

	mov	DWORD PTR _it$[ebp], 0
	mov	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 199  : 	for(it = source.m_TradedItems.begin(); it != source.m_TradedItems.end(); ++it)

	lea	edx, DWORD PTR $T225328[ebp]
	push	edx
	mov	ecx, DWORD PTR _source$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QBE?AVconst_iterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv170[ebp], eax
	mov	eax, DWORD PTR tv170[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _it$[ebp], ecx
	mov	DWORD PTR _it$[ebp+4], edx
	jmp	SHORT $LN3@CvDeal
$LN2@CvDeal:
	cmp	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	jne	SHORT $LN39@CvDeal
	mov	eax, DWORD PTR _it$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _it$[ebp+4], ecx
	jmp	SHORT $LN3@CvDeal
$LN39@CvDeal:
	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T225402[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T225402[ebp]
	add	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR $T225411[ebp], eax
	mov	edx, DWORD PTR $T225411[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T225415[ebp], eax
	mov	ecx, DWORD PTR $T225415[ebp]
	mov	DWORD PTR _it$[ebp+4], ecx
$LN3@CvDeal:
	lea	edx, DWORD PTR $T225330[ebp]
	push	edx
	mov	ecx, DWORD PTR _source$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QBE?AVconst_iterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T225431[ebp], eax
	mov	eax, DWORD PTR $T225431[ebp]
	mov	ecx, DWORD PTR _it$[ebp+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setne	dl
	mov	BYTE PTR $T225329[ebp], dl
	movzx	eax, BYTE PTR $T225329[ebp]
	test	eax, eax
	je	SHORT $LN1@CvDeal

; 200  : 	{
; 201  : 		m_TradedItems.push_back(*it);

	mov	ecx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T225454[ebp], ecx
	mov	edx, DWORD PTR _it$[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T225454[ebp]
	mov	ecx, DWORD PTR [eax+8]
	lea	edx, DWORD PTR [ecx+edx+8]
	mov	DWORD PTR $T225544[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	mov	DWORD PTR $T225543[ebp], eax
	mov	esi, DWORD PTR $T225544[ebp]
	lea	edi, DWORD PTR $T225534[ebp+8]
	mov	ecx, 9
	rep movsd
	lea	ecx, DWORD PTR $T225534[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T225543[ebp]
	call	?Alloc@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::Alloc
	mov	DWORD PTR _uiNewIndex$225538[ebp], eax
	mov	edx, DWORD PTR _uiNewIndex$225538[ebp]
	push	edx
	mov	ecx, DWORD PTR $T225543[ebp]
	call	?push_back_existing@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEXI@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::push_back_existing

; 202  : 	}

	jmp	$LN2@CvDeal
$LN1@CvDeal:

; 203  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvDeal@@QAE@ABV0@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	jmp	??1?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ
__unwindfunclet$??0CvDeal@@QAE@ABV0@@Z$1:
	lea	ecx, DWORD PTR _it$[ebp]
	jmp	??1const_iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::const_iterator::~const_iterator
__ehhandler$??0CvDeal@@QAE@ABV0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-160]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvDeal@@QAE@ABV0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvDeal@@QAE@ABV0@@Z ENDP				; CvDeal::CvDeal
; Function compile flags: /Odtp
;	COMDAT ??1CvDeal@@UAE@XZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T225672 = -28						; size = 4
??1CvDeal@@UAE@XZ PROC					; CvDeal::~CvDeal, COMDAT
; _this$ = ecx

; 207  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvDeal@@6B@

; 208  : #ifdef AUI_EXPLICIT_DESTRUCTION
; 209  : 	m_TradedItems.clear();
; 210  : #endif
; 211  : }

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	mov	DWORD PTR $T225672[ebp], ecx
	mov	ecx, DWORD PTR $T225672[ebp]
	call	??1?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@IAE@XZ ; FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> >::~FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> >
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvDeal@@UAE@XZ ENDP					; CvDeal::~CvDeal
_TEXT	ENDS
PUBLIC	??4CvDeal@@QAEAAV0@ABV0@@Z			; CvDeal::operator=
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
xdata$x	SEGMENT
__unwindtable$??4CvDeal@@QAEAAV0@ABV0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??4CvDeal@@QAEAAV0@ABV0@@Z$0
__ehfuncinfo$??4CvDeal@@QAEAAV0@ABV0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??4CvDeal@@QAEAAV0@ABV0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ??4CvDeal@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
tv163 = -160						; size = 4
_this$ = -156						; size = 4
$T225880 = -152						; size = 4
$T225879 = -148						; size = 4
_uiNewIndex$225874 = -116				; size = 4
$T225870 = -112						; size = 44
$T225790 = -68						; size = 4
$T225767 = -64						; size = 4
$T225751 = -60						; size = 4
$T225747 = -56						; size = 4
$T225738 = -52						; size = 4
$T225690 = -48						; size = 4
$T225678 = -44						; size = 4
$T225677 = -40						; size = 8
$T225676 = -29						; size = 1
$T225675 = -28						; size = 8
_it$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_source$ = 8						; size = 4
??4CvDeal@@QAEAAV0@ABV0@@Z PROC				; CvDeal::operator=, COMDAT
; _this$ = ecx

; 215  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??4CvDeal@@QAEAAV0@ABV0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 148				; 00000094H
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 	m_eFromPlayer = source.m_eFromPlayer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _source$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 217  : 	m_eToPlayer = source.m_eToPlayer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _source$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 218  : 	m_iDuration = source.m_iDuration;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _source$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx

; 219  : 	m_iFinalTurn = source.m_iFinalTurn;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _source$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 220  : 	m_iStartTurn = source.m_iStartTurn;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _source$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx

; 221  : 	m_ePeaceTreatyType = source.m_ePeaceTreatyType;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _source$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx

; 222  : 	m_eSurrenderingPlayer = source.m_eSurrenderingPlayer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _source$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], edx

; 223  : 	m_eDemandingPlayer = source.m_eDemandingPlayer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _source$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+32], edx

; 224  : 	m_eRequestingPlayer = source.m_eRequestingPlayer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _source$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+36], edx

; 225  : 	m_bConsideringForRenewal = source.m_bConsideringForRenewal;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _source$[ebp]
	mov	dl, BYTE PTR [ecx+40]
	mov	BYTE PTR [eax+40], dl

; 226  : 	m_bCheckedForRenewal = source.m_bCheckedForRenewal;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _source$[ebp]
	mov	dl, BYTE PTR [ecx+41]
	mov	BYTE PTR [eax+41], dl

; 227  : 	m_bDealCancelled = source.m_bDealCancelled;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _source$[ebp]
	mov	dl, BYTE PTR [ecx+42]
	mov	BYTE PTR [eax+42], dl

; 228  : 	m_TradedItems.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	mov	DWORD PTR $T225690[ebp], eax
	push	268435455				; 0fffffffH
	mov	ecx, DWORD PTR $T225690[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	ecx, DWORD PTR $T225690[ebp]
	call	?UnLink@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAEXII@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::UnLink

; 229  : 	TradedItemList::const_iterator it;

	mov	DWORD PTR _it$[ebp], 0
	mov	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 230  : 	for(it = source.m_TradedItems.begin(); it != source.m_TradedItems.end(); ++it)

	lea	eax, DWORD PTR $T225675[ebp]
	push	eax
	mov	ecx, DWORD PTR _source$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QBE?AVconst_iterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv163[ebp], eax
	mov	ecx, DWORD PTR tv163[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _it$[ebp], edx
	mov	DWORD PTR _it$[ebp+4], eax
	jmp	SHORT $LN3@operator@3
$LN2@operator@3:
	cmp	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	jne	SHORT $LN32@operator@3
	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _it$[ebp+4], edx
	jmp	SHORT $LN3@operator@3
$LN32@operator@3:
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T225738[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T225738[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T225747[ebp], ecx
	mov	eax, DWORD PTR $T225747[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T225751[ebp], ecx
	mov	edx, DWORD PTR $T225751[ebp]
	mov	DWORD PTR _it$[ebp+4], edx
$LN3@operator@3:
	lea	eax, DWORD PTR $T225677[ebp]
	push	eax
	mov	ecx, DWORD PTR _source$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QBE?AVconst_iterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T225767[ebp], eax
	mov	ecx, DWORD PTR $T225767[ebp]
	mov	edx, DWORD PTR _it$[ebp+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setne	al
	mov	BYTE PTR $T225676[ebp], al
	movzx	ecx, BYTE PTR $T225676[ebp]
	test	ecx, ecx
	je	SHORT $LN1@operator@3

; 231  : 	{
; 232  : 		m_TradedItems.push_back(*it);

	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T225790[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T225790[ebp]
	mov	edx, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [edx+eax+8]
	mov	DWORD PTR $T225880[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	mov	DWORD PTR $T225879[ebp], ecx
	mov	esi, DWORD PTR $T225880[ebp]
	lea	edi, DWORD PTR $T225870[ebp+8]
	mov	ecx, 9
	rep movsd
	lea	edx, DWORD PTR $T225870[ebp]
	push	edx
	mov	ecx, DWORD PTR $T225879[ebp]
	call	?Alloc@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::Alloc
	mov	DWORD PTR _uiNewIndex$225874[ebp], eax
	mov	eax, DWORD PTR _uiNewIndex$225874[ebp]
	push	eax
	mov	ecx, DWORD PTR $T225879[ebp]
	call	?push_back_existing@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEXI@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::push_back_existing

; 233  : 	}

	jmp	$LN2@operator@3
$LN1@operator@3:

; 234  : 
; 235  : 	return (*this);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T225678[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T225678[ebp]

; 236  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??4CvDeal@@QAEAAV0@ABV0@@Z$0:
	lea	ecx, DWORD PTR _it$[ebp]
	jmp	??1const_iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::const_iterator::~const_iterator
__ehhandler$??4CvDeal@@QAEAAV0@ABV0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-160]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??4CvDeal@@QAEAAV0@ABV0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??4CvDeal@@QAEAAV0@ABV0@@Z ENDP				; CvDeal::operator=
PUBLIC	?SetRequestingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z ; CvDeal::SetRequestingPlayer
PUBLIC	?SetDemandingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z ; CvDeal::SetDemandingPlayer
PUBLIC	?SetSurrenderingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z ; CvDeal::SetSurrenderingPlayer
PUBLIC	?SetPeaceTreatyType@CvDeal@@QAEXW4PeaceTreatyTypes@@@Z ; CvDeal::SetPeaceTreatyType
PUBLIC	?ClearItems@CvDeal@@QAEXXZ			; CvDeal::ClearItems
; Function compile flags: /Odtp
;	COMDAT ?ClearItems@CvDeal@@QAEXXZ
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T226027 = -48						; size = 4
?ClearItems@CvDeal@@QAEXXZ PROC				; CvDeal::ClearItems, COMDAT
; _this$ = ecx

; 240  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 241  : 	m_TradedItems.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	mov	DWORD PTR $T226027[ebp], eax
	push	268435455				; 0fffffffH
	mov	ecx, DWORD PTR $T226027[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	ecx, DWORD PTR $T226027[ebp]
	call	?UnLink@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAEXII@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::UnLink

; 242  : 
; 243  : 	m_iFinalTurn = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], -1

; 244  : 	m_iDuration = -1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], -1

; 245  : 	m_iStartTurn = -1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], -1

; 246  : 	m_bConsideringForRenewal = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+40], 0

; 247  : 	m_bCheckedForRenewal = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+41], 0

; 248  : 	m_bDealCancelled = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+42], 0

; 249  : 
; 250  : 	SetPeaceTreatyType(NO_PEACE_TREATY_TYPE);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPeaceTreatyType@CvDeal@@QAEXW4PeaceTreatyTypes@@@Z ; CvDeal::SetPeaceTreatyType

; 251  : 	SetSurrenderingPlayer(NO_PLAYER);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSurrenderingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z ; CvDeal::SetSurrenderingPlayer

; 252  : 	SetDemandingPlayer(NO_PLAYER);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDemandingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z ; CvDeal::SetDemandingPlayer

; 253  : 	SetRequestingPlayer(NO_PLAYER);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetRequestingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z ; CvDeal::SetRequestingPlayer

; 254  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ClearItems@CvDeal@@QAEXXZ ENDP				; CvDeal::ClearItems
_TEXT	ENDS
PUBLIC	?GetNumItems@CvDeal@@QAEHXZ			; CvDeal::GetNumItems
; Function compile flags: /Odtp
;	COMDAT ?GetNumItems@CvDeal@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T226034 = -4						; size = 4
?GetNumItems@CvDeal@@QAEHXZ PROC			; CvDeal::GetNumItems, COMDAT
; _this$ = ecx

; 258  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 259  : 	return m_TradedItems.size();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR $T226034[ebp], ecx
	mov	eax, DWORD PTR $T226034[ebp]

; 260  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumItems@CvDeal@@QAEHXZ ENDP			; CvDeal::GetNumItems
_TEXT	ENDS
PUBLIC	?SetFromPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z	; CvDeal::SetFromPlayer
; Function compile flags: /Odtp
;	COMDAT ?SetFromPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ePlayer$ = 8						; size = 4
?SetFromPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z PROC	; CvDeal::SetFromPlayer, COMDAT
; _this$ = ecx

; 264  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 265  : 	CvAssertMsg(ePlayer >= 0, "DEAL: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 266  : 	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DEAL: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 267  : 
; 268  : 	m_eFromPlayer = ePlayer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _ePlayer$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 269  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetFromPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z ENDP	; CvDeal::SetFromPlayer
_TEXT	ENDS
PUBLIC	?SetToPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z	; CvDeal::SetToPlayer
; Function compile flags: /Odtp
;	COMDAT ?SetToPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ePlayer$ = 8						; size = 4
?SetToPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z PROC		; CvDeal::SetToPlayer, COMDAT
; _this$ = ecx

; 273  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 274  : 	CvAssertMsg(ePlayer >= 0, "DEAL: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 275  : 	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DEAL: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 276  : 
; 277  : 	m_eToPlayer = ePlayer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _ePlayer$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 278  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetToPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z ENDP		; CvDeal::SetToPlayer
_TEXT	ENDS
PUBLIC	?GetOtherPlayer@CvDeal@@QBE?AW4PlayerTypes@@W42@@Z ; CvDeal::GetOtherPlayer
; Function compile flags: /Odtp
;	COMDAT ?GetOtherPlayer@CvDeal@@QBE?AW4PlayerTypes@@W42@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eFromPlayer$ = 8					; size = 4
?GetOtherPlayer@CvDeal@@QBE?AW4PlayerTypes@@W42@@Z PROC	; CvDeal::GetOtherPlayer, COMDAT
; _this$ = ecx

; 282  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 283  : 	CvAssertMsg(eFromPlayer >= 0, "DEAL: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 284  : 	CvAssertMsg(eFromPlayer < MAX_CIV_PLAYERS, "DEAL: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 285  : 
; 286  : 	if(m_eFromPlayer != eFromPlayer)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _eFromPlayer$[ebp]
	je	SHORT $LN2@GetOtherPl

; 287  : 	{
; 288  : 		return m_eFromPlayer;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	jmp	SHORT $LN3@GetOtherPl

; 289  : 	}
; 290  : 	else

	jmp	SHORT $LN3@GetOtherPl
$LN2@GetOtherPl:

; 291  : 	{
; 292  : 		return m_eToPlayer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
$LN3@GetOtherPl:

; 293  : 	}
; 294  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetOtherPlayer@CvDeal@@QBE?AW4PlayerTypes@@W42@@Z ENDP	; CvDeal::GetOtherPlayer
_TEXT	ENDS
PUBLIC	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
PUBLIC	?GetTradeItemGoldCost@CvGameDeals@@QBEHW4TradeableItems@@W4PlayerTypes@@1@Z ; CvGameDeals::GetTradeItemGoldCost
PUBLIC	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
PUBLIC	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
PUBLIC	?GetGoldTrade@CvDeal@@QAEHW4PlayerTypes@@@Z	; CvDeal::GetGoldTrade
PUBLIC	?GetGoldAvailable@CvDeal@@QAEHW4PlayerTypes@@W4TradeableItems@@@Z ; CvDeal::GetGoldAvailable
EXTRN	?GetGameDeals@CvGame@@QAEPAVCvGameDeals@@XZ:PROC ; CvGame::GetGameDeals
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
EXTRN	?GetGold@CvTreasury@@QBEHXZ:PROC		; CvTreasury::GetGold
EXTRN	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ:PROC ; CvPlayer::GetTreasury
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
xdata$x	SEGMENT
__unwindtable$?GetGoldAvailable@CvDeal@@QAEHW4PlayerTypes@@W4TradeableItems@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetGoldAvailable@CvDeal@@QAEHW4PlayerTypes@@W4TradeableItems@@@Z$0
__ehfuncinfo$?GetGoldAvailable@CvDeal@@QAEHW4PlayerTypes@@W4TradeableItems@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetGoldAvailable@CvDeal@@QAEHW4PlayerTypes@@W4TradeableItems@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetGoldAvailable@CvDeal@@QAEHW4PlayerTypes@@W4TradeableItems@@@Z
_TEXT	SEGMENT
tv169 = -100						; size = 4
_this$ = -96						; size = 4
$T226252 = -92						; size = 4
$T226248 = -88						; size = 4
$T226221 = -84						; size = 4
$T226189 = -80						; size = 4
$T226157 = -76						; size = 4
$T226134 = -72						; size = 4
$T226118 = -68						; size = 4
$T226114 = -64						; size = 4
$T226105 = -60						; size = 4
$T226057 = -56						; size = 4
$T226050 = -52						; size = 4
$T226049 = -48						; size = 8
$T226048 = -37						; size = 1
$T226047 = -36						; size = 8
_iGoldAvailable$ = -28					; size = 4
_iGoldCost$ = -24					; size = 4
_it$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_ePlayer$ = 8						; size = 4
_eItemToBeChanged$ = 12					; size = 4
?GetGoldAvailable@CvDeal@@QAEHW4PlayerTypes@@W4TradeableItems@@@Z PROC ; CvDeal::GetGoldAvailable, COMDAT
; _this$ = ecx

; 298  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetGoldAvailable@CvDeal@@QAEHW4PlayerTypes@@W4TradeableItems@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 299  : 	int iGoldAvailable = GET_PLAYER(ePlayer).GetTreasury()->GetGold();

	mov	eax, DWORD PTR _ePlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T226057[ebp], eax
	mov	ecx, DWORD PTR $T226057[ebp]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?GetGold@CvTreasury@@QBEHXZ		; CvTreasury::GetGold
	mov	DWORD PTR _iGoldAvailable$[ebp], eax

; 300  : 
; 301  : 	// Remove Gold we're sending to the other player in this deal (unless we're changing it)
; 302  : 	if(eItemToBeChanged != TRADE_ITEM_GOLD)

	cmp	DWORD PTR _eItemToBeChanged$[ebp], 0
	je	SHORT $LN7@GetGoldAva

; 303  : 	{
; 304  : 		iGoldAvailable -= GetGoldTrade(ePlayer);

	mov	ecx, DWORD PTR _ePlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetGoldTrade@CvDeal@@QAEHW4PlayerTypes@@@Z ; CvDeal::GetGoldTrade
	mov	edx, DWORD PTR _iGoldAvailable$[ebp]
	sub	edx, eax
	mov	DWORD PTR _iGoldAvailable$[ebp], edx
$LN7@GetGoldAva:

; 305  : 	}
; 306  : 
; 307  : 	int iGoldCost;
; 308  : 
; 309  : 	// Loop through all trade items to see if they have a cost
; 310  : 	TradedItemList::iterator it;

	mov	DWORD PTR _it$[ebp], 0
	mov	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 311  : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	eax, DWORD PTR $T226047[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv169[ebp], eax
	mov	ecx, DWORD PTR tv169[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _it$[ebp], edx
	mov	DWORD PTR _it$[ebp+4], eax
	jmp	SHORT $LN6@GetGoldAva
$LN5@GetGoldAva:
	cmp	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	jne	SHORT $LN34@GetGoldAva
	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _it$[ebp+4], edx
	jmp	SHORT $LN6@GetGoldAva
$LN34@GetGoldAva:
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T226105[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T226105[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T226114[ebp], ecx
	mov	eax, DWORD PTR $T226114[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T226118[ebp], ecx
	mov	edx, DWORD PTR $T226118[ebp]
	mov	DWORD PTR _it$[ebp+4], edx
$LN6@GetGoldAva:
	lea	eax, DWORD PTR $T226049[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T226134[ebp], eax
	mov	ecx, DWORD PTR $T226134[ebp]
	mov	edx, DWORD PTR _it$[ebp+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setne	al
	mov	BYTE PTR $T226048[ebp], al
	movzx	ecx, BYTE PTR $T226048[ebp]
	test	ecx, ecx
	je	$LN4@GetGoldAva

; 312  : 	{
; 313  : 		// Don't count something against itself when trying to add it
; 314  : 		if(it->m_eItemType != eItemToBeChanged)

	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T226157[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T226157[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+eax+8]
	cmp	eax, DWORD PTR _eItemToBeChanged$[ebp]
	je	SHORT $LN3@GetGoldAva

; 315  : 		{
; 316  : 			if(it->m_eFromPlayer == ePlayer)

	mov	ecx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T226189[ebp], ecx
	mov	edx, DWORD PTR _it$[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T226189[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+edx+36]
	cmp	edx, DWORD PTR _ePlayer$[ebp]
	jne	SHORT $LN3@GetGoldAva

; 317  : 			{
; 318  : 				iGoldCost = GC.getGame().GetGameDeals()->GetTradeItemGoldCost(it->m_eItemType, m_eFromPlayer, m_eToPlayer);

	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T226221[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T226221[ebp]
	mov	eax, DWORD PTR [edx+8]
	lea	ecx, DWORD PTR [eax+ecx+8]
	mov	DWORD PTR $T226248[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T226252[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR $T226248[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR $T226252[ebp]
	call	?GetGameDeals@CvGame@@QAEPAVCvGameDeals@@XZ ; CvGame::GetGameDeals
	mov	ecx, eax
	call	?GetTradeItemGoldCost@CvGameDeals@@QBEHW4TradeableItems@@W4PlayerTypes@@1@Z ; CvGameDeals::GetTradeItemGoldCost
	mov	DWORD PTR _iGoldCost$[ebp], eax

; 319  : 
; 320  : 				if(iGoldCost != 0)		// Negative cost valid?  Maybe ;-O

	cmp	DWORD PTR _iGoldCost$[ebp], 0
	je	SHORT $LN3@GetGoldAva

; 321  : 				{
; 322  : 					iGoldAvailable -= iGoldCost;

	mov	eax, DWORD PTR _iGoldAvailable$[ebp]
	sub	eax, DWORD PTR _iGoldCost$[ebp]
	mov	DWORD PTR _iGoldAvailable$[ebp], eax
$LN3@GetGoldAva:

; 323  : 				}
; 324  : 			}
; 325  : 		}
; 326  : 	}

	jmp	$LN5@GetGoldAva
$LN4@GetGoldAva:

; 327  : 
; 328  : 	return iGoldAvailable;

	mov	ecx, DWORD PTR _iGoldAvailable$[ebp]
	mov	DWORD PTR $T226050[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T226050[ebp]

; 329  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetGoldAvailable@CvDeal@@QAEHW4PlayerTypes@@W4TradeableItems@@@Z$0:
	lea	ecx, DWORD PTR _it$[ebp]
	jmp	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
__ehhandler$?GetGoldAvailable@CvDeal@@QAEHW4PlayerTypes@@W4TradeableItems@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-92]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetGoldAvailable@CvDeal@@QAEHW4PlayerTypes@@W4TradeableItems@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetGoldAvailable@CvDeal@@QAEHW4PlayerTypes@@W4TradeableItems@@@Z ENDP ; CvDeal::GetGoldAvailable
PUBLIC	?IsVoteCommitmentTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ; CvDeal::IsVoteCommitmentTrade
PUBLIC	??_C@_0BC@DGMBGGHK@IsAbleToMakePeace?$AA@	; `string'
PUBLIC	?IsCityTrade@CvDeal@@QAE_NW4PlayerTypes@@HH@Z	; CvDeal::IsCityTrade
PUBLIC	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ		; CvPlot::getPlotCity
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
PUBLIC	?IsResourceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4ResourceTypes@@@Z ; CvDeal::IsResourceTrade
PUBLIC	?IsPeaceTreatyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ; CvDeal::IsPeaceTreatyTrade
PUBLIC	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
EXTRN	?CanCommitVote@CvLeagueAI@@QAE_NW4PlayerTypes@@PAVCvString@@@Z:PROC ; CvLeagueAI::CanCommitVote
EXTRN	?GetLeagueAI@CvPlayer@@QBEPAVCvLeagueAI@@XZ:PROC ; CvPlayer::GetLeagueAI
EXTRN	?IsProposed@CvLeague@@QAE_NH_N0@Z:PROC		; CvLeague::IsProposed
EXTRN	?GetActiveLeague@CvGameLeagues@@QAEPAVCvLeague@@XZ:PROC ; CvGameLeagues::GetActiveLeague
EXTRN	?GetNumActiveLeagues@CvGameLeagues@@QAEHXZ:PROC	; CvGameLeagues::GetNumActiveLeagues
EXTRN	?isMinorCiv@CvTeam@@QBE_NXZ:PROC		; CvTeam::isMinorCiv
EXTRN	?canDeclareWar@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC ; CvTeam::canDeclareWar
EXTRN	?IsWantsPeaceWithPlayer@CvDiplomacyAI@@QBE_NW4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::IsWantsPeaceWithPlayer
EXTRN	?GetWarGoal@CvDiplomacyAI@@QBE?AW4WarGoalTypes@@W4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetWarGoal
EXTRN	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ:PROC ; CvMinorCivAI::GetAlly
EXTRN	?IsPeaceBlocked@CvMinorCivAI@@QBE_NW4TeamTypes@@@Z:PROC ; CvMinorCivAI::IsPeaceBlocked
EXTRN	?IsPermanentWar@CvMinorCivAI@@QBE_NW4TeamTypes@@@Z:PROC ; CvMinorCivAI::IsPermanentWar
EXTRN	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ:PROC ; CvPlayer::GetMinorCivAI
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
EXTRN	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ:PROC ; CvTeam::getLeaderID
EXTRN	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC	; CvTeam::isHasMet
EXTRN	??1CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::~CvLuaArgsHandle
EXTRN	?CallTestAll@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z:PROC ; LuaSupport::CallTestAll
EXTRN	??0CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::CvLuaArgsHandle
EXTRN	?IsHasTradeAgreement@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC ; CvTeam::IsHasTradeAgreement
EXTRN	?IsTradeAgreementTradingAllowed@CvTeam@@QBE_NXZ:PROC ; CvTeam::IsTradeAgreementTradingAllowed
EXTRN	?HasResearchedAllTechs@CvTeamTechs@@QBE_NXZ:PROC ; CvTeamTechs::HasResearchedAllTechs
EXTRN	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ:PROC ; CvTeam::GetTeamTechs
EXTRN	?IsHasResearchAgreement@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC ; CvTeam::IsHasResearchAgreement
EXTRN	?IsResearchAgreementTradingAllowed@CvTeam@@QBE_NXZ:PROC ; CvTeam::IsResearchAgreementTradingAllowed
EXTRN	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC	; CvTeam::isAtWar
EXTRN	?IsHasDefensivePact@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC ; CvTeam::IsHasDefensivePact
EXTRN	?IsAllowsOpenBordersToTeam@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC ; CvTeam::IsAllowsOpenBordersToTeam
EXTRN	?getGameTurn@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurn
EXTRN	?isOpenBordersTradingAllowed@CvTeam@@QBE_NXZ:PROC ; CvTeam::isOpenBordersTradingAllowed
EXTRN	?HasEmbassyAtTeam@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC ; CvTeam::HasEmbassyAtTeam
EXTRN	?isAllowEmbassyTradingAllowed@CvTeam@@QBE_NXZ:PROC ; CvTeam::isAllowEmbassyTradingAllowed
EXTRN	?getNumCities@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getNumCities
EXTRN	?isHuman@CvPlayer@@QBE_NXZ:PROC			; CvPlayer::isHuman
EXTRN	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z:PROC ; CvGame::isOption
EXTRN	?isCapital@CvCity@@QBE_NXZ:PROC			; CvCity::isCapital
EXTRN	?IsResourceObsolete@CvTeam@@QAE_NW4ResourceTypes@@@Z:PROC ; CvTeam::IsResourceObsolete
EXTRN	?isHuman@CvTeam@@QBE_NXZ:PROC			; CvTeam::isHuman
EXTRN	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ:PROC ; CvResourceInfo::getResourceUsage
EXTRN	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z:PROC ; CvGlobals::getResourceInfo
EXTRN	?getNumResourceAvailable@CvPlayer@@QBEHW4ResourceTypes@@_N@Z:PROC ; CvPlayer::getNumResourceAvailable
EXTRN	?IsLuxuryHappinessBanned@CvGameLeagues@@QAE_NW4PlayerTypes@@W4ResourceTypes@@@Z:PROC ; CvGameLeagues::IsLuxuryHappinessBanned
EXTRN	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ:PROC ; CvGame::GetGameLeagues
EXTRN	?calculateGoldRate@CvPlayer@@QBEHXZ:PROC	; CvPlayer::calculateGoldRate
EXTRN	?IsDoFAccepted@CvDiplomacyAI@@QBE_NW4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::IsDoFAccepted
EXTRN	?GetDealToRenew@CvDiplomacyAI@@QAEPAVCvDeal@@PAH@Z:PROC ; CvDiplomacyAI::GetDealToRenew
EXTRN	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ:PROC ; CvPlayer::GetDiplomacyAI
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
;	COMDAT ??_C@_0BC@DGMBGGHK@IsAbleToMakePeace?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
CONST	SEGMENT
??_C@_0BC@DGMBGGHK@IsAbleToMakePeace?$AA@ DB 'IsAbleToMakePeace', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z$8
__ehfuncinfo$?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z
_TEXT	SEGMENT
tv682 = -480						; size = 4
tv675 = -476						; size = 4
tv664 = -472						; size = 4
tv901 = -468						; size = 4
tv1365 = -464						; size = 4
tv1329 = -460						; size = 4
tv896 = -456						; size = 4
tv892 = -452						; size = 4
_this$ = -448						; size = 4
$T227212 = -444						; size = 4
$T227208 = -440						; size = 4
$T227204 = -436						; size = 4
$T227203 = -432						; size = 4
$T227199 = -428						; size = 4
$T227195 = -424						; size = 4
$T227188 = -420						; size = 4
$T227184 = -416						; size = 4
$T227175 = -412						; size = 4
$T227171 = -408						; size = 4
$T227164 = -404						; size = 4
$T227160 = -400						; size = 4
$T227150 = -396						; size = 4
$T227146 = -392						; size = 4
$T227125 = -388						; size = 4
$T227095 = -384						; size = 4
$T227063 = -380						; size = 4
$T227031 = -376						; size = 4
$T226999 = -372						; size = 4
$T226976 = -368						; size = 4
$T226960 = -364						; size = 4
$T226956 = -360						; size = 4
$T226947 = -356						; size = 4
$T226899 = -352						; size = 4
$T226895 = -348						; size = 4
$T226891 = -344						; size = 4
$T226841 = -336						; size = 4
$T226829 = -332						; size = 4
$T226825 = -325						; size = 1
$T226814 = -324						; size = 4
$T226810 = -317						; size = 1
_iMapY$226877 = -316					; size = 4
_iMapX$226876 = -312					; size = 4
$T226803 = -308						; size = 4
$T226796 = -304						; size = 4
$T226747 = -300						; size = 4
$T226715 = -296						; size = 4
$T226683 = -292						; size = 4
$T226651 = -288						; size = 4
$T226628 = -284						; size = 4
$T226612 = -280						; size = 4
$T226608 = -276						; size = 4
$T226599 = -272						; size = 4
$T226551 = -268						; size = 4
$T226519 = -264						; size = 4
$T226487 = -260						; size = 4
$T226455 = -256						; size = 4
$T226432 = -252						; size = 4
$T226416 = -248						; size = 4
$T226412 = -244						; size = 4
$T226403 = -240						; size = 4
$T226355 = -236						; size = 4
$T226351 = -232						; size = 4
$T226339 = -228						; size = 4
$T226330 = -224						; size = 4
$T226289 = -217						; size = 1
$T226288 = -216						; size = 8
$T226287 = -205						; size = 1
$T226286 = -204						; size = 8
$T226285 = -196						; size = 4
$T226284 = -192						; size = 4
$T226283 = -188						; size = 8
$T226282 = -177						; size = 1
$T226281 = -176						; size = 8
$T226280 = -168						; size = 8
$T226279 = -157						; size = 1
$T226278 = -156						; size = 8
_pLeague$221119 = -148					; size = 4
_bRepeal$221117 = -141					; size = 1
_iID$221116 = -140					; size = 4
_eThirdTeam$221096 = -136				; size = 4
_eThirdTeam$221075 = -132				; size = 4
_pOtherPlayer$221083 = -128				; size = 4
_bResult$221068 = -121					; size = 1
_args$221067 = -120					; size = 4
_pkScriptSystem$221065 = -116				; size = 4
_iEndingTurn$221013 = -112				; size = 4
_it$221014 = -108					; size = 8
_bIgnoreExistingOP$221011 = -97				; size = 1
_pPlot$220991 = -96					; size = 4
_pCity$220990 = -92					; size = 4
_it$220962 = -88					; size = 8
_iResourceQuantity$220954 = -80				; size = 4
_iNumAvailable$220958 = -76				; size = 4
_iNumInExistingDeal$220960 = -72			; size = 4
_eUsage$220980 = -68					; size = 4
_iNumInRenewDeal$220959 = -64				; size = 4
_eResource$220951 = -60					; size = 4
_iGoldPerTurn$220945 = -56				; size = 4
_iGold$220941 = -52					; size = 4
_pToTeam$ = -48						; size = 4
_pFromPlayer$ = -44					; size = 4
_pFromTeam$ = -40					; size = 4
_pRenewDeal$ = -36					; size = 4
_eFromTeam$ = -32					; size = 4
_iGoldAvailable$ = -28					; size = 4
_pToPlayer$ = -24					; size = 4
_eToTeam$ = -20						; size = 4
_iCost$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_ePlayer$ = 8						; size = 4
_eToPlayer$ = 12					; size = 4
_eItem$ = 16						; size = 4
_iData1$ = 20						; size = 4
_iData2$ = 24						; size = 4
_iData3$ = 28						; size = 4
_bFlag1$ = 32						; size = 1
_bCheckOtherPlayerValidity$ = 36			; size = 1
_bFinalizing$ = 40					; size = 1
?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z PROC ; CvDeal::IsPossibleToTradeItem, COMDAT
; _this$ = ecx

; 333  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 468				; 000001d4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 334  : 	// The Data parameters can be -1, which means we don't care about whatever data is stored there (e.g. -1 for Gold means can we trade ANY amount of Gold?)
; 335  : 	CvPlayer* pFromPlayer = &GET_PLAYER(ePlayer);

	mov	eax, DWORD PTR _ePlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _pFromPlayer$[ebp], eax

; 336  : 	CvPlayer* pToPlayer = &GET_PLAYER(eToPlayer);

	mov	ecx, DWORD PTR _eToPlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _pToPlayer$[ebp], ecx

; 337  : 
; 338  : 	TeamTypes eFromTeam = pFromPlayer->getTeam();

	mov	edx, DWORD PTR _pFromPlayer$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eFromTeam$[ebp], eax

; 339  : 	TeamTypes eToTeam = pToPlayer->getTeam();

	mov	ecx, DWORD PTR _pToPlayer$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eToTeam$[ebp], eax

; 340  : 
; 341  : 	CvTeam* pFromTeam = &GET_TEAM(eFromTeam);

	mov	eax, DWORD PTR _eFromTeam$[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR _pFromTeam$[ebp], eax

; 342  : 	CvTeam* pToTeam = &GET_TEAM(eToTeam);

	mov	ecx, DWORD PTR _eToTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR _pToTeam$[ebp], ecx

; 343  : 
; 344  : 	CvDeal* pRenewDeal = pFromPlayer->GetDiplomacyAI()->GetDealToRenew();

	push	0
	mov	ecx, DWORD PTR _pFromPlayer$[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetDealToRenew@CvDiplomacyAI@@QAEPAVCvDeal@@PAH@Z ; CvDiplomacyAI::GetDealToRenew
	mov	DWORD PTR _pRenewDeal$[ebp], eax

; 345  : 	if (!pRenewDeal)

	cmp	DWORD PTR _pRenewDeal$[ebp], 0
	jne	SHORT $LN148@IsPossible

; 346  : 	{
; 347  : 		pRenewDeal = pToPlayer->GetDiplomacyAI()->GetDealToRenew();

	push	0
	mov	ecx, DWORD PTR _pToPlayer$[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetDealToRenew@CvDiplomacyAI@@QAEPAVCvDeal@@PAH@Z ; CvDiplomacyAI::GetDealToRenew
	mov	DWORD PTR _pRenewDeal$[ebp], eax
$LN148@IsPossible:

; 348  : 	}
; 349  : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 350  : 	CvGameDeals* pGameDeals = GC.getGame().GetGameDeals();
; 351  : 	uint uiCurrentlyEndingDeals = pGameDeals->GetNumCurrentlyEndingDeals(ePlayer, eToPlayer);
; 352  : #endif
; 353  : 
; 354  : 	int iGoldAvailable = GetGoldAvailable(ePlayer, eItem);

	mov	edx, DWORD PTR _eItem$[ebp]
	push	edx
	mov	eax, DWORD PTR _ePlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetGoldAvailable@CvDeal@@QAEHW4PlayerTypes@@W4TradeableItems@@@Z ; CvDeal::GetGoldAvailable
	mov	DWORD PTR _iGoldAvailable$[ebp], eax

; 355  : 
; 356  : 	// Some items require gold be spent (e.g. Research and Trade Agreements)
; 357  : 	int iCost = GC.getGame().GetGameDeals()->GetTradeItemGoldCost(eItem, ePlayer, eToPlayer);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T226330[ebp], ecx
	mov	edx, DWORD PTR _eToPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _ePlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eItem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T226330[ebp]
	call	?GetGameDeals@CvGame@@QAEPAVCvGameDeals@@XZ ; CvGame::GetGameDeals
	mov	ecx, eax
	call	?GetTradeItemGoldCost@CvGameDeals@@QBEHW4TradeableItems@@W4PlayerTypes@@1@Z ; CvGameDeals::GetTradeItemGoldCost
	mov	DWORD PTR _iCost$[ebp], eax

; 358  : 	if(iCost > 0 && iGoldAvailable < iCost)

	cmp	DWORD PTR _iCost$[ebp], 0
	jle	SHORT $LN147@IsPossible
	mov	edx, DWORD PTR _iGoldAvailable$[ebp]
	cmp	edx, DWORD PTR _iCost$[ebp]
	jge	SHORT $LN147@IsPossible

; 359  : 		return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN147@IsPossible:

; 360  : 
; 361  : 	iGoldAvailable -= iCost;

	mov	eax, DWORD PTR _iGoldAvailable$[ebp]
	sub	eax, DWORD PTR _iCost$[ebp]
	mov	DWORD PTR _iGoldAvailable$[ebp], eax

; 362  : 
; 363  : 	////////////////////////////////////////////////////
; 364  : 
; 365  : 	// Gold
; 366  : 	if(eItem == TRADE_ITEM_GOLD)

	cmp	DWORD PTR _eItem$[ebp], 0
	jne	$LN146@IsPossible

; 367  : 	{
; 368  : 		// DoF has not been made with this player
; 369  : 		if (!this->IsPeaceTreatyTrade(eToPlayer) && !this->IsPeaceTreatyTrade(ePlayer))

	mov	ecx, DWORD PTR _eToPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPeaceTreatyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ; CvDeal::IsPeaceTreatyTrade
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN145@IsPossible
	mov	eax, DWORD PTR _ePlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPeaceTreatyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ; CvDeal::IsPeaceTreatyTrade
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN145@IsPossible

; 370  : 		{
; 371  : 			if (pFromPlayer->getTeam() != pToPlayer->getTeam() && (!pFromPlayer->GetDiplomacyAI()->IsDoFAccepted(eToPlayer) || !pToPlayer->GetDiplomacyAI()->IsDoFAccepted(ePlayer)))

	mov	edx, DWORD PTR _pFromPlayer$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T226339[ebp], eax
	mov	ecx, DWORD PTR _pToPlayer$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	DWORD PTR $T226339[ebp], eax
	je	SHORT $LN145@IsPossible
	mov	eax, DWORD PTR _eToPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFromPlayer$[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsDoFAccepted@CvDiplomacyAI@@QBE_NW4PlayerTypes@@@Z ; CvDiplomacyAI::IsDoFAccepted
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN143@IsPossible
	mov	edx, DWORD PTR _ePlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pToPlayer$[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsDoFAccepted@CvDiplomacyAI@@QBE_NW4PlayerTypes@@@Z ; CvDiplomacyAI::IsDoFAccepted
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN145@IsPossible
$LN143@IsPossible:

; 372  : 				return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN145@IsPossible:

; 373  : 		}
; 374  : 
; 375  : 		// Can't trade more Gold than you have
; 376  : 		int iGold = iData1;

	mov	ecx, DWORD PTR _iData1$[ebp]
	mov	DWORD PTR _iGold$220941[ebp], ecx

; 377  : 		if(iGold != -1 && iGoldAvailable < iGold)

	cmp	DWORD PTR _iGold$220941[ebp], -1
	je	SHORT $LN142@IsPossible
	mov	edx, DWORD PTR _iGoldAvailable$[ebp]
	cmp	edx, DWORD PTR _iGold$220941[ebp]
	jge	SHORT $LN142@IsPossible

; 378  : 			return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN142@IsPossible:

; 379  : 	}

	jmp	$LN141@IsPossible
$LN146@IsPossible:

; 380  : 	// Gold per Turn
; 381  : 	else if(eItem == TRADE_ITEM_GOLD_PER_TURN)

	cmp	DWORD PTR _eItem$[ebp], 1
	jne	SHORT $LN140@IsPossible

; 382  : 	{
; 383  : 		// Can't trade more GPT than you're making
; 384  : 		int iGoldPerTurn = iData1;

	mov	eax, DWORD PTR _iData1$[ebp]
	mov	DWORD PTR _iGoldPerTurn$220945[ebp], eax

; 385  : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 386  : 		if (pRenewDeal || uiCurrentlyEndingDeals > 0)
; 387  : 		{
; 388  : 			CvDeal* pLoopDeal = NULL;
; 389  : 			TradedItemList::iterator it;
; 390  : 			if (pRenewDeal)
; 391  : 			{
; 392  : 				for (it = pRenewDeal->m_TradedItems.begin(); it != pRenewDeal->m_TradedItems.end(); ++it)
; 393  : 				{
; 394  : 					if (it->m_eItemType == TRADE_ITEM_GOLD_PER_TURN && it->m_eFromPlayer == ePlayer)
; 395  : 					{
; 396  : 						// credit the amount
; 397  : 						iGoldPerTurn += it->m_iData1;
; 398  : 					}
; 399  : 				}
; 400  : 			}
; 401  : 			for (uint uiI = 0; uiI < uiCurrentlyEndingDeals; uiI++)
; 402  : 			{
; 403  : 				pLoopDeal = pGameDeals->GetCurrentlyEndingDeal(ePlayer, eToPlayer, uiI);
; 404  : 				for (it = pLoopDeal->m_TradedItems.begin(); it != pLoopDeal->m_TradedItems.end(); ++it)
; 405  : 				{
; 406  : 					if (it->m_eItemType == TRADE_ITEM_GOLD_PER_TURN && it->m_eFromPlayer == ePlayer)
; 407  : 					{
; 408  : 						iGoldPerTurn += it->m_iData1;
; 409  : 					}
; 410  : 				}
; 411  : 			}
; 412  : 			// remove any that are in this deal
; 413  : 			for (it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)
; 414  : 			{
; 415  : 				if (it->m_eItemType == TRADE_ITEM_GOLD_PER_TURN && it->m_eFromPlayer == ePlayer)
; 416  : 				{
; 417  : 					iGoldPerTurn -= it->m_iData1;
; 418  : 				}
; 419  : 			}
; 420  : 		}
; 421  : #endif
; 422  : 		if(iGoldPerTurn != -1 && pFromPlayer->calculateGoldRate() < iGoldPerTurn)

	cmp	DWORD PTR _iGoldPerTurn$220945[ebp], -1
	je	SHORT $LN139@IsPossible
	mov	ecx, DWORD PTR _pFromPlayer$[ebp]
	call	?calculateGoldRate@CvPlayer@@QBEHXZ	; CvPlayer::calculateGoldRate
	cmp	eax, DWORD PTR _iGoldPerTurn$220945[ebp]
	jge	SHORT $LN139@IsPossible

; 423  : 			return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN139@IsPossible:

; 424  : 
; 425  : 		//int iDuration = iData2;
; 426  : 		//if (iDuration != GC.getGame().GetDealDuration())
; 427  : 		//	return false;
; 428  : 	}

	jmp	$LN141@IsPossible
$LN140@IsPossible:

; 429  : 	// Map
; 430  : 	else if(eItem == TRADE_ITEM_MAPS)

	cmp	DWORD PTR _eItem$[ebp], 2
	jne	SHORT $LN137@IsPossible

; 431  : 	{
; 432  : 		return false;

	xor	al, al
	jmp	$LN149@IsPossible
	jmp	$LN141@IsPossible
$LN137@IsPossible:

; 433  : 	}
; 434  : 	// Resource
; 435  : 	else if(eItem == TRADE_ITEM_RESOURCES)

	cmp	DWORD PTR _eItem$[ebp], 3
	jne	$LN135@IsPossible

; 436  : 	{
; 437  : 		ResourceTypes eResource = (ResourceTypes) iData1;

	mov	ecx, DWORD PTR _iData1$[ebp]
	mov	DWORD PTR _eResource$220951[ebp], ecx

; 438  : 		if(eResource != NO_RESOURCE)

	cmp	DWORD PTR _eResource$220951[ebp], -1
	je	$LN134@IsPossible

; 439  : 		{
; 440  : 			int iResourceQuantity = iData2;

	mov	edx, DWORD PTR _iData2$[ebp]
	mov	DWORD PTR _iResourceQuantity$220954[ebp], edx

; 441  : 
; 442  : 			// Can't trade a negative amount of something!
; 443  : 			if(iResourceQuantity < 0)

	cmp	DWORD PTR _iResourceQuantity$220954[ebp], 0
	jge	SHORT $LN133@IsPossible

; 444  : 				return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN133@IsPossible:

; 445  : 
; 446  : 			if (GC.getGame().GetGameLeagues()->IsLuxuryHappinessBanned(ePlayer, eResource) || GC.getGame().GetGameLeagues()->IsLuxuryHappinessBanned(eToPlayer, eResource))

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T226351[ebp], eax
	mov	ecx, DWORD PTR _eResource$220951[ebp]
	push	ecx
	mov	edx, DWORD PTR _ePlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T226351[ebp]
	call	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ ; CvGame::GetGameLeagues
	mov	ecx, eax
	call	?IsLuxuryHappinessBanned@CvGameLeagues@@QAE_NW4PlayerTypes@@W4ResourceTypes@@@Z ; CvGameLeagues::IsLuxuryHappinessBanned
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN131@IsPossible
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T226355[ebp], ecx
	mov	edx, DWORD PTR _eResource$220951[ebp]
	push	edx
	mov	eax, DWORD PTR _eToPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226355[ebp]
	call	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ ; CvGame::GetGameLeagues
	mov	ecx, eax
	call	?IsLuxuryHappinessBanned@CvGameLeagues@@QAE_NW4PlayerTypes@@W4ResourceTypes@@@Z ; CvGameLeagues::IsLuxuryHappinessBanned
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN132@IsPossible
$LN131@IsPossible:

; 447  : 			{
; 448  : 				return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN132@IsPossible:

; 449  : 			}
; 450  : 
; 451  : 			//int iNumAvailable = GetNumResource(ePlayer, eResource, true);
; 452  : 
; 453  : 			int iNumAvailable = pFromPlayer->getNumResourceAvailable(eResource, false);

	push	0
	mov	edx, DWORD PTR _eResource$220951[ebp]
	push	edx
	mov	ecx, DWORD PTR _pFromPlayer$[ebp]
	call	?getNumResourceAvailable@CvPlayer@@QBEHW4ResourceTypes@@_N@Z ; CvPlayer::getNumResourceAvailable
	mov	DWORD PTR _iNumAvailable$220958[ebp], eax

; 454  : 			int iNumInRenewDeal = 0;

	mov	DWORD PTR _iNumInRenewDeal$220959[ebp], 0

; 455  : 			int iNumInExistingDeal = 0;

	mov	DWORD PTR _iNumInExistingDeal$220960[ebp], 0

; 456  : 
; 457  : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 458  : 			if (pRenewDeal || uiCurrentlyEndingDeals > 0)
; 459  : #else
; 460  : 			if (pRenewDeal)

	cmp	DWORD PTR _pRenewDeal$[ebp], 0
	je	$LN130@IsPossible

; 461  : #endif
; 462  : 			{
; 463  : 				// count any that are in the renew deal
; 464  : 				TradedItemList::iterator it;

	mov	DWORD PTR _it$220962[ebp], 0
	mov	DWORD PTR _it$220962[ebp+4], 268435455	; 0fffffffH
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 465  : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 466  : 				if (pRenewDeal)
; 467  : 				{
; 468  : #endif
; 469  : 				for(it = pRenewDeal->m_TradedItems.begin(); it != pRenewDeal->m_TradedItems.end(); ++it)

	lea	eax, DWORD PTR $T226278[ebp]
	push	eax
	mov	ecx, DWORD PTR _pRenewDeal$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv892[ebp], eax
	mov	ecx, DWORD PTR tv892[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _it$220962[ebp], edx
	mov	DWORD PTR _it$220962[ebp+4], eax
	jmp	SHORT $LN129@IsPossible
$LN128@IsPossible:
	cmp	DWORD PTR _it$220962[ebp+4], 268435455	; 0fffffffH
	jne	SHORT $LN209@IsPossible
	mov	ecx, DWORD PTR _it$220962[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _it$220962[ebp+4], edx
	jmp	SHORT $LN129@IsPossible
$LN209@IsPossible:
	mov	eax, DWORD PTR _it$220962[ebp]
	mov	DWORD PTR $T226403[ebp], eax
	mov	ecx, DWORD PTR _it$220962[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T226403[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T226412[ebp], ecx
	mov	eax, DWORD PTR $T226412[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T226416[ebp], ecx
	mov	edx, DWORD PTR $T226416[ebp]
	mov	DWORD PTR _it$220962[ebp+4], edx
$LN129@IsPossible:
	lea	eax, DWORD PTR $T226280[ebp]
	push	eax
	mov	ecx, DWORD PTR _pRenewDeal$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T226432[ebp], eax
	mov	ecx, DWORD PTR $T226432[ebp]
	mov	edx, DWORD PTR _it$220962[ebp+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setne	al
	mov	BYTE PTR $T226279[ebp], al
	movzx	ecx, BYTE PTR $T226279[ebp]
	test	ecx, ecx
	je	$LN127@IsPossible

; 470  : 				{
; 471  : 					if(it->m_eItemType == TRADE_ITEM_RESOURCES && it->m_eFromPlayer == ePlayer && (ResourceTypes)it->m_iData1 == eResource)

	mov	edx, DWORD PTR _it$220962[ebp]
	mov	DWORD PTR $T226455[ebp], edx
	mov	eax, DWORD PTR _it$220962[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T226455[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+eax+8], 3
	jne	SHORT $LN126@IsPossible
	mov	eax, DWORD PTR _it$220962[ebp]
	mov	DWORD PTR $T226487[ebp], eax
	mov	ecx, DWORD PTR _it$220962[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T226487[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+ecx+36]
	cmp	ecx, DWORD PTR _ePlayer$[ebp]
	jne	SHORT $LN126@IsPossible
	mov	edx, DWORD PTR _it$220962[ebp]
	mov	DWORD PTR $T226519[ebp], edx
	mov	eax, DWORD PTR _it$220962[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T226519[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+eax+20]
	cmp	eax, DWORD PTR _eResource$220951[ebp]
	jne	SHORT $LN126@IsPossible

; 472  : 					{
; 473  : 						// credit the amount
; 474  : 						iNumInRenewDeal += it->m_iData2;

	mov	ecx, DWORD PTR _it$220962[ebp]
	mov	DWORD PTR $T226551[ebp], ecx
	mov	edx, DWORD PTR _it$220962[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T226551[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR _iNumInRenewDeal$220959[ebp]
	add	eax, DWORD PTR [ecx+edx+24]
	mov	DWORD PTR _iNumInRenewDeal$220959[ebp], eax
$LN126@IsPossible:

; 475  : 					}
; 476  : 				}

	jmp	$LN128@IsPossible
$LN127@IsPossible:

; 477  : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 478  : 				}
; 479  : 
; 480  : 				CvDeal* pLoopDeal = NULL;
; 481  : 				for (uint uiI = 0; uiI < uiCurrentlyEndingDeals; uiI++)
; 482  : 				{
; 483  : 					pLoopDeal = pGameDeals->GetCurrentlyEndingDeal(ePlayer, eToPlayer, uiI);
; 484  : 					for (it = pLoopDeal->m_TradedItems.begin(); it != pLoopDeal->m_TradedItems.end(); ++it)
; 485  : 					{
; 486  : 						if (it->m_eItemType == TRADE_ITEM_RESOURCES && it->m_eFromPlayer == ePlayer && (ResourceTypes)it->m_iData1 == eResource)
; 487  : 						{
; 488  : 							// credit the amount
; 489  : 							iNumInRenewDeal += it->m_iData2;
; 490  : 						}
; 491  : 					}
; 492  : 				}
; 493  : #endif
; 494  : 
; 495  : 				// remove any that are in this deal
; 496  : 				for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	ecx, DWORD PTR $T226281[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv896[ebp], eax
	mov	edx, DWORD PTR tv896[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _it$220962[ebp], eax
	mov	DWORD PTR _it$220962[ebp+4], ecx
	jmp	SHORT $LN125@IsPossible
$LN124@IsPossible:
	cmp	DWORD PTR _it$220962[ebp+4], 268435455	; 0fffffffH
	jne	SHORT $LN279@IsPossible
	mov	edx, DWORD PTR _it$220962[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _it$220962[ebp+4], eax
	jmp	SHORT $LN125@IsPossible
$LN279@IsPossible:
	mov	ecx, DWORD PTR _it$220962[ebp]
	mov	DWORD PTR $T226599[ebp], ecx
	mov	edx, DWORD PTR _it$220962[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T226599[ebp]
	add	edx, DWORD PTR [eax+8]
	mov	DWORD PTR $T226608[ebp], edx
	mov	ecx, DWORD PTR $T226608[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T226612[ebp], edx
	mov	eax, DWORD PTR $T226612[ebp]
	mov	DWORD PTR _it$220962[ebp+4], eax
$LN125@IsPossible:
	lea	ecx, DWORD PTR $T226283[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T226628[ebp], eax
	mov	edx, DWORD PTR $T226628[ebp]
	mov	eax, DWORD PTR _it$220962[ebp+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setne	cl
	mov	BYTE PTR $T226282[ebp], cl
	movzx	edx, BYTE PTR $T226282[ebp]
	test	edx, edx
	je	$LN123@IsPossible

; 497  : 				{
; 498  : 					if(it->m_eItemType == TRADE_ITEM_RESOURCES && it->m_eFromPlayer == ePlayer && (ResourceTypes)it->m_iData1 == eResource)

	mov	eax, DWORD PTR _it$220962[ebp]
	mov	DWORD PTR $T226651[ebp], eax
	mov	ecx, DWORD PTR _it$220962[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T226651[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	DWORD PTR [eax+ecx+8], 3
	jne	SHORT $LN122@IsPossible
	mov	ecx, DWORD PTR _it$220962[ebp]
	mov	DWORD PTR $T226683[ebp], ecx
	mov	edx, DWORD PTR _it$220962[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T226683[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+edx+36]
	cmp	edx, DWORD PTR _ePlayer$[ebp]
	jne	SHORT $LN122@IsPossible
	mov	eax, DWORD PTR _it$220962[ebp]
	mov	DWORD PTR $T226715[ebp], eax
	mov	ecx, DWORD PTR _it$220962[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T226715[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+ecx+20]
	cmp	ecx, DWORD PTR _eResource$220951[ebp]
	jne	SHORT $LN122@IsPossible

; 499  : 					{
; 500  : 						iNumInExistingDeal += it->m_iData2;

	mov	edx, DWORD PTR _it$220962[ebp]
	mov	DWORD PTR $T226747[ebp], edx
	mov	eax, DWORD PTR _it$220962[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T226747[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR _iNumInExistingDeal$220960[ebp]
	add	ecx, DWORD PTR [edx+eax+24]
	mov	DWORD PTR _iNumInExistingDeal$220960[ebp], ecx
$LN122@IsPossible:

; 501  : 					}
; 502  : 				}

	jmp	$LN124@IsPossible
$LN123@IsPossible:

; 503  : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN130@IsPossible:

; 504  : 
; 505  : 			// Offering up more of a Resource than we have available
; 506  : 			if(iNumAvailable + iNumInRenewDeal - iNumInExistingDeal < iResourceQuantity)

	mov	edx, DWORD PTR _iNumAvailable$220958[ebp]
	add	edx, DWORD PTR _iNumInRenewDeal$220959[ebp]
	sub	edx, DWORD PTR _iNumInExistingDeal$220960[ebp]
	cmp	edx, DWORD PTR _iResourceQuantity$220954[ebp]
	jge	SHORT $LN121@IsPossible

; 507  : 				return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN121@IsPossible:

; 508  : 
; 509  : 			// Must be a Luxury or a Strategic Resource
; 510  : 			ResourceUsageTypes eUsage = GC.getResourceInfo(eResource)->getResourceUsage();

	mov	eax, DWORD PTR _eResource$220951[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	mov	DWORD PTR _eUsage$220980[ebp], eax

; 511  : 			if(eUsage != RESOURCEUSAGE_LUXURY && eUsage != RESOURCEUSAGE_STRATEGIC)

	cmp	DWORD PTR _eUsage$220980[ebp], 2
	je	SHORT $LN120@IsPossible
	cmp	DWORD PTR _eUsage$220980[ebp], 1
	je	SHORT $LN120@IsPossible

; 512  : 				return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN120@IsPossible:

; 513  : 
; 514  : 			if(eUsage == RESOURCEUSAGE_LUXURY)

	cmp	DWORD PTR _eUsage$220980[ebp], 2
	jne	SHORT $LN119@IsPossible

; 515  : 			{
; 516  : 				// Can't trade Luxury if the other player already has one
; 517  : 				if(pToPlayer->getNumResourceAvailable(eResource) > MAX(iNumInRenewDeal - iNumInExistingDeal, 0))

	mov	DWORD PTR $T226284[ebp], 0
	mov	ecx, DWORD PTR _iNumInRenewDeal$220959[ebp]
	sub	ecx, DWORD PTR _iNumInExistingDeal$220960[ebp]
	mov	DWORD PTR $T226285[ebp], ecx
	mov	edx, DWORD PTR $T226285[ebp]
	cmp	edx, DWORD PTR $T226284[ebp]
	jge	SHORT $LN350@IsPossible
	lea	eax, DWORD PTR $T226284[ebp]
	mov	DWORD PTR tv1329[ebp], eax
	jmp	SHORT $LN351@IsPossible
$LN350@IsPossible:
	lea	ecx, DWORD PTR $T226285[ebp]
	mov	DWORD PTR tv1329[ebp], ecx
$LN351@IsPossible:
	mov	edx, DWORD PTR tv1329[ebp]
	mov	DWORD PTR $T226796[ebp], edx
	push	1
	mov	eax, DWORD PTR _eResource$220951[ebp]
	push	eax
	mov	ecx, DWORD PTR _pToPlayer$[ebp]
	call	?getNumResourceAvailable@CvPlayer@@QBEHW4ResourceTypes@@_N@Z ; CvPlayer::getNumResourceAvailable
	mov	ecx, DWORD PTR $T226796[ebp]
	cmp	eax, DWORD PTR [ecx]
	jle	SHORT $LN119@IsPossible

; 518  : 				{
; 519  : 					return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN119@IsPossible:

; 520  : 				}
; 521  : 			}
; 522  : 
; 523  : 			// Can't trade them something they're already giving us in the deal
; 524  : 			if(IsResourceTrade(eToPlayer, eResource))

	mov	edx, DWORD PTR _eResource$220951[ebp]
	push	edx
	mov	eax, DWORD PTR _eToPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsResourceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4ResourceTypes@@@Z ; CvDeal::IsResourceTrade
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN117@IsPossible

; 525  : 				return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN117@IsPossible:

; 526  : 
; 527  : 			// AI can't trade an obsolete resource
; 528  : 			if (!pFromTeam->isHuman() && pFromTeam->IsResourceObsolete(eResource))

	mov	ecx, DWORD PTR _pFromTeam$[ebp]
	call	?isHuman@CvTeam@@QBE_NXZ		; CvTeam::isHuman
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN134@IsPossible
	mov	eax, DWORD PTR _eResource$220951[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFromTeam$[ebp]
	call	?IsResourceObsolete@CvTeam@@QAE_NW4ResourceTypes@@@Z ; CvTeam::IsResourceObsolete
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN134@IsPossible

; 529  : 			{
; 530  : 				return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN134@IsPossible:

; 531  : 			}
; 532  : 		}
; 533  : 	}

	jmp	$LN141@IsPossible
$LN135@IsPossible:

; 534  : 	// City
; 535  : 	else if(eItem == TRADE_ITEM_CITIES)

	cmp	DWORD PTR _eItem$[ebp], 4
	jne	$LN114@IsPossible

; 536  : 	{
; 537  : 		CvCity* pCity = NULL;

	mov	DWORD PTR _pCity$220990[ebp], 0

; 538  : 		CvPlot* pPlot = GC.getMap().plot(iData1, iData2);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T226803[ebp], edx
	cmp	DWORD PTR _iData1$[ebp], -2147483647	; 80000001H
	je	SHORT $LN354@IsPossible
	cmp	DWORD PTR _iData2$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN355@IsPossible
$LN354@IsPossible:
	mov	DWORD PTR _pPlot$220991[ebp], 0
	jmp	$LN356@IsPossible
$LN355@IsPossible:
	mov	eax, DWORD PTR $T226803[ebp]
	mov	cl, BYTE PTR [eax+4056]
	mov	BYTE PTR $T226810[ebp], cl
	mov	edx, DWORD PTR $T226803[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T226814[ebp], eax
	movzx	ecx, BYTE PTR $T226810[ebp]
	test	ecx, ecx
	je	SHORT $LN367@IsPossible
	cmp	DWORD PTR _iData1$[ebp], 0
	jge	SHORT $LN366@IsPossible
	mov	eax, DWORD PTR _iData1$[ebp]
	cdq
	idiv	DWORD PTR $T226814[ebp]
	add	edx, DWORD PTR $T226814[ebp]
	mov	DWORD PTR _iMapX$226876[ebp], edx
	jmp	SHORT $LN368@IsPossible
	jmp	SHORT $LN367@IsPossible
$LN366@IsPossible:
	mov	edx, DWORD PTR _iData1$[ebp]
	cmp	edx, DWORD PTR $T226814[ebp]
	jl	SHORT $LN367@IsPossible
	mov	eax, DWORD PTR _iData1$[ebp]
	cdq
	idiv	DWORD PTR $T226814[ebp]
	mov	DWORD PTR _iMapX$226876[ebp], edx
	jmp	SHORT $LN368@IsPossible
$LN367@IsPossible:
	mov	eax, DWORD PTR _iData1$[ebp]
	mov	DWORD PTR _iMapX$226876[ebp], eax
$LN368@IsPossible:
	mov	ecx, DWORD PTR $T226803[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T226825[ebp], dl
	mov	eax, DWORD PTR $T226803[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T226829[ebp], ecx
	movzx	edx, BYTE PTR $T226825[ebp]
	test	edx, edx
	je	SHORT $LN377@IsPossible
	cmp	DWORD PTR _iData2$[ebp], 0
	jge	SHORT $LN376@IsPossible
	mov	eax, DWORD PTR _iData2$[ebp]
	cdq
	idiv	DWORD PTR $T226829[ebp]
	add	edx, DWORD PTR $T226829[ebp]
	mov	DWORD PTR _iMapY$226877[ebp], edx
	jmp	SHORT $LN378@IsPossible
	jmp	SHORT $LN377@IsPossible
$LN376@IsPossible:
	mov	eax, DWORD PTR _iData2$[ebp]
	cmp	eax, DWORD PTR $T226829[ebp]
	jl	SHORT $LN377@IsPossible
	mov	eax, DWORD PTR _iData2$[ebp]
	cdq
	idiv	DWORD PTR $T226829[ebp]
	mov	DWORD PTR _iMapY$226877[ebp], edx
	jmp	SHORT $LN378@IsPossible
$LN377@IsPossible:
	mov	ecx, DWORD PTR _iData2$[ebp]
	mov	DWORD PTR _iMapY$226877[ebp], ecx
$LN378@IsPossible:
	mov	edx, DWORD PTR _iMapY$226877[ebp]
	push	edx
	mov	eax, DWORD PTR _iMapX$226876[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226803[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN358@IsPossible
	mov	ecx, DWORD PTR $T226803[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T226841[ebp], edx
	mov	eax, DWORD PTR _iMapY$226877[ebp]
	imul	eax, DWORD PTR $T226841[ebp]
	add	eax, DWORD PTR _iMapX$226876[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T226803[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv1365[ebp], eax
	jmp	SHORT $LN359@IsPossible
$LN358@IsPossible:
	mov	DWORD PTR tv1365[ebp], 0
$LN359@IsPossible:
	mov	edx, DWORD PTR tv1365[ebp]
	mov	DWORD PTR _pPlot$220991[ebp], edx
$LN356@IsPossible:

; 539  : 		if(pPlot != NULL)

	cmp	DWORD PTR _pPlot$220991[ebp], 0
	je	SHORT $LN113@IsPossible

; 540  : 			pCity = pPlot->getPlotCity();

	mov	ecx, DWORD PTR _pPlot$220991[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pCity$220990[ebp], eax
$LN113@IsPossible:

; 541  : 
; 542  : 		if(pCity != NULL)

	cmp	DWORD PTR _pCity$220990[ebp], 0
	je	$LN112@IsPossible

; 543  : 		{
; 544  : 			// Can't trade someone else's city
; 545  : 			if(pCity->getOwner() != ePlayer)

	mov	eax, DWORD PTR _pCity$220990[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T226891[ebp], ecx
	mov	edx, DWORD PTR $T226891[ebp]
	cmp	edx, DWORD PTR _ePlayer$[ebp]
	je	SHORT $LN111@IsPossible

; 546  : 				return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN111@IsPossible:

; 547  : 
; 548  : 			// Can't trade one's capital
; 549  : #ifdef AUI_DEAL_ALLOW_CAPITOL_GIFTING
; 550  : 			if (pCity->isCapital() && !GC.getGame().isOption("GAMEOPTION_ALLOW_CAPITOL_GIFTING"))
; 551  : #else
; 552  : 			if(pCity->isCapital())

	mov	ecx, DWORD PTR _pCity$220990[ebp]
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN110@IsPossible

; 553  : #endif
; 554  : 				return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN110@IsPossible:

; 555  : 
; 556  : 			// Can't trade a city to a human in an OCC game
; 557  : 			if(GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && GET_PLAYER(eToPlayer).isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T226895[ebp], ecx
	push	5
	mov	ecx, DWORD PTR $T226895[ebp]
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN109@IsPossible
	mov	eax, DWORD PTR _eToPlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T226899[ebp], eax
	mov	ecx, DWORD PTR $T226899[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN109@IsPossible

; 558  : 				return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN109@IsPossible:

; 559  : 		}
; 560  : 		// Can't trade a null city
; 561  : 		else

	jmp	SHORT $LN108@IsPossible
$LN112@IsPossible:

; 562  : 			return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN108@IsPossible:

; 563  : 
; 564  : 		// Can't already have this city in the deal
; 565  : 		if(!bFinalizing && IsCityTrade(ePlayer, iData1, iData2))

	movzx	edx, BYTE PTR _bFinalizing$[ebp]
	test	edx, edx
	jne	SHORT $LN107@IsPossible
	mov	eax, DWORD PTR _iData2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iData1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ePlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsCityTrade@CvDeal@@QAE_NW4PlayerTypes@@HH@Z ; CvDeal::IsCityTrade
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN107@IsPossible

; 566  : 			return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN107@IsPossible:

; 567  : 	}

	jmp	$LN141@IsPossible
$LN114@IsPossible:

; 568  : 	// Unit
; 569  : 	else if(eItem == TRADE_ITEM_UNITS)

	cmp	DWORD PTR _eItem$[ebp], 5
	jne	SHORT $LN105@IsPossible

; 570  : 	{
; 571  : 		return false;

	xor	al, al
	jmp	$LN149@IsPossible
	jmp	$LN141@IsPossible
$LN105@IsPossible:

; 572  : 	}
; 573  : 	// Embassy
; 574  : 	else if(eItem == TRADE_ITEM_ALLOW_EMBASSY)

	cmp	DWORD PTR _eItem$[ebp], 17		; 00000011H
	jne	SHORT $LN103@IsPossible

; 575  : 	{
; 576  : 		// too few cities
; 577  : 		if (pToPlayer->getNumCities() < 1)

	mov	ecx, DWORD PTR _pToPlayer$[ebp]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	cmp	eax, 1
	jge	SHORT $LN102@IsPossible

; 578  : 			return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN102@IsPossible:

; 579  : 		// Does not have tech for Embassy trading
; 580  : 		if(!pToTeam->isAllowEmbassyTradingAllowed())

	mov	ecx, DWORD PTR _pToTeam$[ebp]
	call	?isAllowEmbassyTradingAllowed@CvTeam@@QBE_NXZ ; CvTeam::isAllowEmbassyTradingAllowed
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN101@IsPossible

; 581  : 			return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN101@IsPossible:

; 582  : 		// Already has embassy
; 583  : 		if(pToTeam->HasEmbassyAtTeam(eFromTeam))

	mov	edx, DWORD PTR _eFromTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pToTeam$[ebp]
	call	?HasEmbassyAtTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::HasEmbassyAtTeam
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN100@IsPossible

; 584  : 			return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN100@IsPossible:

; 585  : 		// Same team
; 586  : 		if(eFromTeam == eToTeam)

	mov	ecx, DWORD PTR _eFromTeam$[ebp]
	cmp	ecx, DWORD PTR _eToTeam$[ebp]
	jne	SHORT $LN99@IsPossible

; 587  : 			return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN99@IsPossible:

; 588  : 	}

	jmp	$LN141@IsPossible
$LN103@IsPossible:

; 589  : 	// Open Borders
; 590  : 	else if(eItem == TRADE_ITEM_OPEN_BORDERS)

	cmp	DWORD PTR _eItem$[ebp], 6
	jne	$LN97@IsPossible

; 591  : 	{
; 592  : 		// Neither of us yet has the Tech for OP
; 593  : 		if(!pFromTeam->isOpenBordersTradingAllowed() && !pToTeam->isOpenBordersTradingAllowed())

	mov	ecx, DWORD PTR _pFromTeam$[ebp]
	call	?isOpenBordersTradingAllowed@CvTeam@@QBE_NXZ ; CvTeam::isOpenBordersTradingAllowed
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN96@IsPossible
	mov	ecx, DWORD PTR _pToTeam$[ebp]
	call	?isOpenBordersTradingAllowed@CvTeam@@QBE_NXZ ; CvTeam::isOpenBordersTradingAllowed
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN96@IsPossible

; 594  : 			return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN96@IsPossible:

; 595  : 		// Embassy has not been established
; 596  : 		if(!pFromTeam->HasEmbassyAtTeam(eToTeam))

	mov	ecx, DWORD PTR _eToTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pFromTeam$[ebp]
	call	?HasEmbassyAtTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::HasEmbassyAtTeam
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN95@IsPossible

; 597  : 			return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN95@IsPossible:

; 598  : 		
; 599  : 		bool bIgnoreExistingOP = true;

	mov	BYTE PTR _bIgnoreExistingOP$221011[ebp], 1

; 600  : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 601  : 		TradedItemList::iterator it;
; 602  : #endif
; 603  : 		if (pRenewDeal)

	cmp	DWORD PTR _pRenewDeal$[ebp], 0
	je	$LN94@IsPossible

; 604  : 		{
; 605  : 			// count any that are in the renew deal
; 606  : #ifndef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 607  : 			int iEndingTurn = -1;

	mov	DWORD PTR _iEndingTurn$221013[ebp], -1

; 608  : 			TradedItemList::iterator it;

	mov	DWORD PTR _it$221014[ebp], 0
	mov	DWORD PTR _it$221014[ebp+4], 268435455	; 0fffffffH
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 609  : #endif
; 610  : 			for(it = pRenewDeal->m_TradedItems.begin(); it != pRenewDeal->m_TradedItems.end(); ++it)

	lea	eax, DWORD PTR $T226286[ebp]
	push	eax
	mov	ecx, DWORD PTR _pRenewDeal$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv901[ebp], eax
	mov	ecx, DWORD PTR tv901[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _it$221014[ebp], edx
	mov	DWORD PTR _it$221014[ebp+4], eax
	jmp	SHORT $LN93@IsPossible
$LN92@IsPossible:
	cmp	DWORD PTR _it$221014[ebp+4], 268435455	; 0fffffffH
	jne	SHORT $LN416@IsPossible
	mov	ecx, DWORD PTR _it$221014[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _it$221014[ebp+4], edx
	jmp	SHORT $LN93@IsPossible
$LN416@IsPossible:
	mov	eax, DWORD PTR _it$221014[ebp]
	mov	DWORD PTR $T226947[ebp], eax
	mov	ecx, DWORD PTR _it$221014[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T226947[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T226956[ebp], ecx
	mov	eax, DWORD PTR $T226956[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T226960[ebp], ecx
	mov	edx, DWORD PTR $T226960[ebp]
	mov	DWORD PTR _it$221014[ebp+4], edx
$LN93@IsPossible:
	lea	eax, DWORD PTR $T226288[ebp]
	push	eax
	mov	ecx, DWORD PTR _pRenewDeal$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T226976[ebp], eax
	mov	ecx, DWORD PTR $T226976[ebp]
	mov	edx, DWORD PTR _it$221014[ebp+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setne	al
	mov	BYTE PTR $T226287[ebp], al
	movzx	ecx, BYTE PTR $T226287[ebp]
	test	ecx, ecx
	je	$LN91@IsPossible

; 611  : 			{
; 612  : 				if(it->m_eItemType == TRADE_ITEM_OPEN_BORDERS && (it->m_eFromPlayer == ePlayer || it->m_eFromPlayer == eToPlayer == ePlayer))

	mov	edx, DWORD PTR _it$221014[ebp]
	mov	DWORD PTR $T226999[ebp], edx
	mov	eax, DWORD PTR _it$221014[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T226999[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+eax+8], 6
	jne	SHORT $LN90@IsPossible
	mov	eax, DWORD PTR _it$221014[ebp]
	mov	DWORD PTR $T227031[ebp], eax
	mov	ecx, DWORD PTR _it$221014[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T227031[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+ecx+36]
	cmp	ecx, DWORD PTR _ePlayer$[ebp]
	je	SHORT $LN89@IsPossible
	mov	edx, DWORD PTR _it$221014[ebp]
	mov	DWORD PTR $T227063[ebp], edx
	mov	eax, DWORD PTR _it$221014[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T227063[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+eax+36]
	xor	ecx, ecx
	cmp	eax, DWORD PTR _eToPlayer$[ebp]
	sete	cl
	cmp	ecx, DWORD PTR _ePlayer$[ebp]
	jne	SHORT $LN90@IsPossible
$LN89@IsPossible:

; 613  : 				{
; 614  : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 615  : 					if (it->m_iTurnsRemaining == 0)
; 616  : 					{
; 617  : 						bIgnoreExistingOP = false;
; 618  : 						goto EndCheckCurrentlyEndingForOP;
; 619  : 					}
; 620  : #else
; 621  : 					iEndingTurn = it->m_iFinalTurn;

	mov	edx, DWORD PTR _it$221014[ebp]
	mov	DWORD PTR $T227095[ebp], edx
	mov	eax, DWORD PTR _it$221014[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T227095[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+eax+16]
	mov	DWORD PTR _iEndingTurn$221013[ebp], eax
$LN90@IsPossible:

; 622  : #endif
; 623  : 				}
; 624  : 			}

	jmp	$LN92@IsPossible
$LN91@IsPossible:

; 625  : 
; 626  : #ifndef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 627  : 			if (iEndingTurn == GC.getGame().getGameTurn())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T227125[ebp], ecx
	mov	ecx, DWORD PTR $T227125[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	cmp	DWORD PTR _iEndingTurn$221013[ebp], eax
	jne	SHORT $LN88@IsPossible

; 628  : 			{
; 629  : 				bIgnoreExistingOP = false;

	mov	BYTE PTR _bIgnoreExistingOP$221011[ebp], 0
$LN88@IsPossible:

; 630  : 			}
; 631  : #endif
; 632  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN94@IsPossible:

; 633  : 
; 634  : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 635  : 		CvDeal* pLoopDeal = NULL;
; 636  : 		for (uint uiI = 0; uiI < uiCurrentlyEndingDeals; uiI++)
; 637  : 		{
; 638  : 			pLoopDeal = pGameDeals->GetCurrentlyEndingDeal(ePlayer, eToPlayer, uiI);
; 639  : 			for (it = pLoopDeal->m_TradedItems.begin(); it != pLoopDeal->m_TradedItems.end(); ++it)
; 640  : 			{
; 641  : 				if (it->m_eItemType == TRADE_ITEM_OPEN_BORDERS && it->m_eFromPlayer == ePlayer)
; 642  : 				{
; 643  : 					bIgnoreExistingOP = false;
; 644  : 					goto EndCheckCurrentlyEndingForOP;
; 645  : 				}
; 646  : 			}
; 647  : 		}
; 648  : 	EndCheckCurrentlyEndingForOP:;
; 649  : #endif
; 650  : 
; 651  : 		// Already has OP
; 652  : 		if(pFromTeam->IsAllowsOpenBordersToTeam(eToTeam) && bIgnoreExistingOP)

	mov	edx, DWORD PTR _eToTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pFromTeam$[ebp]
	call	?IsAllowsOpenBordersToTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsAllowsOpenBordersToTeam
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN87@IsPossible
	movzx	ecx, BYTE PTR _bIgnoreExistingOP$221011[ebp]
	test	ecx, ecx
	je	SHORT $LN87@IsPossible

; 653  : 			return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN87@IsPossible:

; 654  : 		// Same Team
; 655  : 		if(eFromTeam == eToTeam)

	mov	edx, DWORD PTR _eFromTeam$[ebp]
	cmp	edx, DWORD PTR _eToTeam$[ebp]
	jne	SHORT $LN86@IsPossible

; 656  : 			return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN86@IsPossible:

; 657  : 	}

	jmp	$LN141@IsPossible
$LN97@IsPossible:

; 658  : 	// Defensive Pact
; 659  : 	else if(eItem == TRADE_ITEM_DEFENSIVE_PACT)

	cmp	DWORD PTR _eItem$[ebp], 7
	jne	$LN84@IsPossible

; 660  : 	{
; 661  : 		
; 662  : #ifndef NEW_DEFENSIVE_PACT //EAP: from Immos
; 663  : 		// Neither of us yet has the Tech for DP
; 664  : 		if(!pFromTeam->isDefensivePactTradingAllowed() && !pToTeam->isDefensivePactTradingAllowed())
; 665  : 			return false;
; 666  : 		// Embassy has not been established
; 667  : 		if(!pFromTeam->HasEmbassyAtTeam(eToTeam) || !pToTeam->HasEmbassyAtTeam(eFromTeam))
; 668  : 			return false;
; 669  : 
; 670  : #endif
; 671  : 		// Already has DP
; 672  : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 673  : 		bool bConsiderExistingDefensivePact = true;
; 674  : 		CvDeal* pLoopDeal = NULL;
; 675  : 		TradedItemList::iterator it;
; 676  : 		if (pRenewDeal)
; 677  : 		{
; 678  : 			// count any that are in the renew deal
; 679  : 			for (it = pRenewDeal->m_TradedItems.begin(); it != pRenewDeal->m_TradedItems.end(); ++it)
; 680  : 			{
; 681  : 				if (it->m_eItemType == TRADE_ITEM_DEFENSIVE_PACT && it->m_eFromPlayer == ePlayer)
; 682  : 				{
; 683  : 					if (it->m_iTurnsRemaining == 0)
; 684  : 					{
; 685  : 						bConsiderExistingDefensivePact = false;
; 686  : 						goto EndCheckCurrentlyEndingForDP;
; 687  : 					}
; 688  : 				}
; 689  : 			}
; 690  : 		}
; 691  : 		for (uint uiI = 0; uiI < uiCurrentlyEndingDeals; uiI++)
; 692  : 		{
; 693  : 			pLoopDeal = pGameDeals->GetCurrentlyEndingDeal(ePlayer, eToPlayer, uiI);
; 694  : 			for (it = pLoopDeal->m_TradedItems.begin(); it != pLoopDeal->m_TradedItems.end(); ++it)
; 695  : 			{
; 696  : 				if (it->m_eItemType == TRADE_ITEM_DEFENSIVE_PACT && it->m_eFromPlayer == ePlayer)
; 697  : 				{
; 698  : 					bConsiderExistingDefensivePact = false;
; 699  : 					goto EndCheckCurrentlyEndingForDP;
; 700  : 				}
; 701  : 			}
; 702  : 		}
; 703  : 	EndCheckCurrentlyEndingForDP:;
; 704  : 		if (bConsiderExistingDefensivePact && pFromTeam->IsHasDefensivePact(eToTeam))
; 705  : #else
; 706  : 		if(pFromTeam->IsHasDefensivePact(eToTeam))

	mov	eax, DWORD PTR _eToTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFromTeam$[ebp]
	call	?IsHasDefensivePact@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsHasDefensivePact
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN83@IsPossible

; 707  : #endif
; 708  : 			return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN83@IsPossible:

; 709  : #ifdef NEW_DEFENSIVE_PACT
; 710  : 		// EAP: can send if at war
; 711  : 		if(pFromTeam->isAtWar(eToTeam))

	mov	edx, DWORD PTR _eToTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pFromTeam$[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN82@IsPossible

; 712  : 			return true;

	mov	al, 1
	jmp	$LN149@IsPossible
$LN82@IsPossible:

; 713  : 
; 714  : 		if(pToTeam->isAtWar(eFromTeam))

	mov	ecx, DWORD PTR _eFromTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pToTeam$[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN81@IsPossible

; 715  : 			return true;

	mov	al, 1
	jmp	$LN149@IsPossible
$LN81@IsPossible:

; 716  : 
; 717  : #endif
; 718  : 		// Same Team
; 719  : 		if(eFromTeam == eToTeam)

	mov	eax, DWORD PTR _eFromTeam$[ebp]
	cmp	eax, DWORD PTR _eToTeam$[ebp]
	jne	SHORT $LN80@IsPossible

; 720  : 			return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN80@IsPossible:

; 721  : 
; 722  : 		// Check to see if the other player can trade this item to us as well.  If we can't, we can't trade it either
; 723  : 		if(bCheckOtherPlayerValidity)

	movzx	ecx, BYTE PTR _bCheckOtherPlayerValidity$[ebp]
	test	ecx, ecx
	je	SHORT $LN79@IsPossible

; 724  : 		{
; 725  : 			if(!IsPossibleToTradeItem(eToPlayer, ePlayer, eItem, iData1, iData2, iData3, bFlag1, /*bCheckOtherPlayerValidity*/ false))

	push	0
	push	0
	movzx	edx, BYTE PTR _bFlag1$[ebp]
	push	edx
	mov	eax, DWORD PTR _iData3$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iData2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iData1$[ebp]
	push	edx
	mov	eax, DWORD PTR _eItem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ePlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eToPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN79@IsPossible

; 726  : 				return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN79@IsPossible:

; 727  : 		}
; 728  : 	}

	jmp	$LN141@IsPossible
$LN84@IsPossible:

; 729  : 	// Research Agreement
; 730  : 	else if(eItem == TRADE_ITEM_RESEARCH_AGREEMENT)

	cmp	DWORD PTR _eItem$[ebp], 8
	jne	$LN76@IsPossible

; 731  : 	{
; 732  : 		if(GC.getGame().isOption(GAMEOPTION_NO_SCIENCE))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T227146[ebp], ecx
	push	17					; 00000011H
	mov	ecx, DWORD PTR $T227146[ebp]
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN75@IsPossible

; 733  : 			return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN75@IsPossible:

; 734  : 
; 735  : 		// Neither of us yet has the Tech for RA
; 736  : 		if(!pFromTeam->IsResearchAgreementTradingAllowed() && !pToTeam->IsResearchAgreementTradingAllowed())

	mov	ecx, DWORD PTR _pFromTeam$[ebp]
	call	?IsResearchAgreementTradingAllowed@CvTeam@@QBE_NXZ ; CvTeam::IsResearchAgreementTradingAllowed
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN74@IsPossible
	mov	ecx, DWORD PTR _pToTeam$[ebp]
	call	?IsResearchAgreementTradingAllowed@CvTeam@@QBE_NXZ ; CvTeam::IsResearchAgreementTradingAllowed
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN74@IsPossible

; 737  : 			return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN74@IsPossible:

; 738  : 		// Embassy has not been established with this team
; 739  : 		if(!pFromTeam->HasEmbassyAtTeam(eToTeam) || !pToTeam->HasEmbassyAtTeam(eFromTeam))

	mov	edx, DWORD PTR _eToTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pFromTeam$[ebp]
	call	?HasEmbassyAtTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::HasEmbassyAtTeam
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN72@IsPossible
	mov	ecx, DWORD PTR _eFromTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pToTeam$[ebp]
	call	?HasEmbassyAtTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::HasEmbassyAtTeam
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN73@IsPossible
$LN72@IsPossible:

; 740  : 			return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN73@IsPossible:

; 741  : 		// DoF has not been made with this player
; 742  : 		if(!pFromPlayer->GetDiplomacyAI()->IsDoFAccepted(eToPlayer) || !pToPlayer->GetDiplomacyAI()->IsDoFAccepted(ePlayer))

	mov	eax, DWORD PTR _eToPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFromPlayer$[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsDoFAccepted@CvDiplomacyAI@@QBE_NW4PlayerTypes@@@Z ; CvDiplomacyAI::IsDoFAccepted
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN70@IsPossible
	mov	edx, DWORD PTR _ePlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pToPlayer$[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsDoFAccepted@CvDiplomacyAI@@QBE_NW4PlayerTypes@@@Z ; CvDiplomacyAI::IsDoFAccepted
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN71@IsPossible
$LN70@IsPossible:

; 743  : 			return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN71@IsPossible:

; 744  : 		// Already has RA
; 745  : 		if(pFromTeam->IsHasResearchAgreement(eToTeam))

	mov	ecx, DWORD PTR _eToTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pFromTeam$[ebp]
	call	?IsHasResearchAgreement@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsHasResearchAgreement
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN69@IsPossible

; 746  : 			return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN69@IsPossible:

; 747  : 		// Same Team
; 748  : 		if(eFromTeam == eToTeam)

	mov	eax, DWORD PTR _eFromTeam$[ebp]
	cmp	eax, DWORD PTR _eToTeam$[ebp]
	jne	SHORT $LN68@IsPossible

; 749  : 			return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN68@IsPossible:

; 750  : 		// Someone already has all techs
; 751  : 		if(pFromTeam->GetTeamTechs()->HasResearchedAllTechs() || pToTeam->GetTeamTechs()->HasResearchedAllTechs())

	mov	ecx, DWORD PTR _pFromTeam$[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasResearchedAllTechs@CvTeamTechs@@QBE_NXZ ; CvTeamTechs::HasResearchedAllTechs
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN66@IsPossible
	mov	ecx, DWORD PTR _pToTeam$[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasResearchedAllTechs@CvTeamTechs@@QBE_NXZ ; CvTeamTechs::HasResearchedAllTechs
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN67@IsPossible
$LN66@IsPossible:

; 752  : 			return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN67@IsPossible:

; 753  : 
; 754  : 		// Check to see if the other player can trade this item to us as well.  If we can't, we can't trade it either
; 755  : 		if(bCheckOtherPlayerValidity)

	movzx	eax, BYTE PTR _bCheckOtherPlayerValidity$[ebp]
	test	eax, eax
	je	SHORT $LN65@IsPossible

; 756  : 		{
; 757  : 			if(!IsPossibleToTradeItem(eToPlayer, ePlayer, eItem, iData1, iData2, iData3, bFlag1, /*bCheckOtherPlayerValidity*/ false))

	push	0
	push	0
	movzx	ecx, BYTE PTR _bFlag1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iData3$[ebp]
	push	edx
	mov	eax, DWORD PTR _iData2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iData1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eItem$[ebp]
	push	edx
	mov	eax, DWORD PTR _ePlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eToPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN65@IsPossible

; 758  : 				return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN65@IsPossible:

; 759  : 		}
; 760  : 	}

	jmp	$LN141@IsPossible
$LN76@IsPossible:

; 761  : 	// Trade Agreement
; 762  : 	else if(eItem == TRADE_ITEM_TRADE_AGREEMENT)

	cmp	DWORD PTR _eItem$[ebp], 9
	jne	$LN62@IsPossible

; 763  : 	{
; 764  : 		// Neither of us yet has the Tech for TA
; 765  : 		if(!pFromTeam->IsTradeAgreementTradingAllowed() && !pToTeam->IsTradeAgreementTradingAllowed())

	mov	ecx, DWORD PTR _pFromTeam$[ebp]
	call	?IsTradeAgreementTradingAllowed@CvTeam@@QBE_NXZ ; CvTeam::IsTradeAgreementTradingAllowed
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN61@IsPossible
	mov	ecx, DWORD PTR _pToTeam$[ebp]
	call	?IsTradeAgreementTradingAllowed@CvTeam@@QBE_NXZ ; CvTeam::IsTradeAgreementTradingAllowed
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN61@IsPossible

; 766  : 			return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN61@IsPossible:

; 767  : 		// Already has TA
; 768  : 		if(pFromTeam->IsHasTradeAgreement(eToTeam))

	mov	edx, DWORD PTR _eToTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pFromTeam$[ebp]
	call	?IsHasTradeAgreement@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsHasTradeAgreement
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN60@IsPossible

; 769  : 			return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN60@IsPossible:

; 770  : 		// Same Team
; 771  : 		if(eFromTeam == eToTeam)

	mov	ecx, DWORD PTR _eFromTeam$[ebp]
	cmp	ecx, DWORD PTR _eToTeam$[ebp]
	jne	SHORT $LN59@IsPossible

; 772  : 			return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN59@IsPossible:

; 773  : 
; 774  : 		// Check to see if the other player can trade this item to us as well.  If we can't, we can't trade it either
; 775  : 		if(bCheckOtherPlayerValidity)

	movzx	edx, BYTE PTR _bCheckOtherPlayerValidity$[ebp]
	test	edx, edx
	je	SHORT $LN58@IsPossible

; 776  : 		{
; 777  : 			if(!IsPossibleToTradeItem(eToPlayer, ePlayer, eItem, iData1, iData2, iData3, bFlag1, /*bCheckOtherPlayerValidity*/ false))

	push	0
	push	0
	movzx	eax, BYTE PTR _bFlag1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iData3$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iData2$[ebp]
	push	edx
	mov	eax, DWORD PTR _iData1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eItem$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ePlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _eToPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN58@IsPossible

; 778  : 				return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN58@IsPossible:

; 779  : 		}
; 780  : 	}

	jmp	$LN141@IsPossible
$LN62@IsPossible:

; 781  : 	// Permanent Alliance
; 782  : 	else if(eItem == TRADE_ITEM_PERMANENT_ALLIANCE)

	cmp	DWORD PTR _eItem$[ebp], 10		; 0000000aH
	jne	SHORT $LN55@IsPossible

; 783  : 		return false;

	xor	al, al
	jmp	$LN149@IsPossible
	jmp	$LN141@IsPossible
$LN55@IsPossible:

; 784  : 	// Surrender
; 785  : 	else if(eItem == TRADE_ITEM_SURRENDER)

	cmp	DWORD PTR _eItem$[ebp], 11		; 0000000bH
	jne	SHORT $LN53@IsPossible

; 786  : 		return false;

	xor	al, al
	jmp	$LN149@IsPossible
	jmp	$LN141@IsPossible
$LN53@IsPossible:

; 787  : 	// Truce
; 788  : 	else if(eItem == TRADE_ITEM_TRUCE)

	cmp	DWORD PTR _eItem$[ebp], 12		; 0000000cH
	jne	SHORT $LN51@IsPossible

; 789  : 		return false;

	xor	al, al
	jmp	$LN149@IsPossible
	jmp	$LN141@IsPossible
$LN51@IsPossible:

; 790  : 	// Peace Treaty
; 791  : 	else if(eItem == TRADE_ITEM_PEACE_TREATY)

	cmp	DWORD PTR _eItem$[ebp], 13		; 0000000dH
	jne	$LN49@IsPossible

; 792  : 	{
; 793  : 		if(!pFromTeam->isAtWar(eToTeam))

	mov	edx, DWORD PTR _eToTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pFromTeam$[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN48@IsPossible

; 794  : 			return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN48@IsPossible:

; 795  : 
; 796  : 		if(!pToTeam->isAtWar(eFromTeam))

	mov	ecx, DWORD PTR _eFromTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pToTeam$[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN47@IsPossible

; 797  : 			return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN47@IsPossible:

; 798  : 
; 799  : 		ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	eax, DWORD PTR $T227150[ebp]
	mov	DWORD PTR tv664[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv664[ebp], ecx
	mov	edx, DWORD PTR tv664[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv664[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	DWORD PTR _pkScriptSystem$221065[ebp], eax

; 800  : 		if (pkScriptSystem)

	cmp	DWORD PTR _pkScriptSystem$221065[ebp], 0
	je	$LN46@IsPossible

; 801  : 		{
; 802  : 			// Construct and push in some event arguments.
; 803  : 			CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$221067[ebp]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle
	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 804  : 			args->Push(ePlayer);

	mov	eax, DWORD PTR _args$221067[ebp]
	mov	DWORD PTR tv675[ebp], eax
	mov	ecx, DWORD PTR _ePlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv675[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv675[ebp]
	mov	edx, DWORD PTR [eax+8]
	call	edx

; 805  : 			args->Push(eToTeam);

	mov	eax, DWORD PTR _args$221067[ebp]
	mov	DWORD PTR tv682[ebp], eax
	mov	ecx, DWORD PTR _eToTeam$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv682[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv682[ebp]
	mov	edx, DWORD PTR [eax+8]
	call	edx

; 806  : 
; 807  : 			// Attempt to execute the game events.
; 808  : 			// Will return false if there are no registered listeners.
; 809  : 			bool bResult = false;

	mov	BYTE PTR _bResult$221068[ebp], 0

; 810  : 			if (LuaSupport::CallTestAll(pkScriptSystem, "IsAbleToMakePeace", args.get(), bResult)) 

	mov	eax, DWORD PTR _args$221067[ebp]
	mov	DWORD PTR $T227160[ebp], eax
	lea	ecx, DWORD PTR _bResult$221068[ebp]
	push	ecx
	mov	edx, DWORD PTR $T227160[ebp]
	push	edx
	push	OFFSET ??_C@_0BC@DGMBGGHK@IsAbleToMakePeace?$AA@
	mov	eax, DWORD PTR _pkScriptSystem$221065[ebp]
	push	eax
	call	?CallTestAll@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallTestAll
	add	esp, 16					; 00000010H
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN45@IsPossible

; 811  : 			{
; 812  : 				// Check the result.
; 813  : 				if (bResult == false)

	movzx	edx, BYTE PTR _bResult$221068[ebp]
	test	edx, edx
	jne	SHORT $LN45@IsPossible

; 814  : 				{
; 815  : 					return false;

	mov	BYTE PTR $T226289[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _args$221067[ebp]
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
	mov	al, BYTE PTR $T226289[ebp]
	jmp	$LN149@IsPossible
$LN45@IsPossible:

; 816  : 				}
; 817  : 			}
; 818  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _args$221067[ebp]
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN46@IsPossible:

; 819  : 	}

	jmp	$LN141@IsPossible
$LN49@IsPossible:

; 820  : 	// Third Party Peace
; 821  : 	else if(eItem == TRADE_ITEM_THIRD_PARTY_PEACE)

	cmp	DWORD PTR _eItem$[ebp], 14		; 0000000eH
	jne	$LN42@IsPossible

; 822  : 	{
; 823  : 		TeamTypes eThirdTeam = (TeamTypes) iData1;

	mov	eax, DWORD PTR _iData1$[ebp]
	mov	DWORD PTR _eThirdTeam$221075[ebp], eax

; 824  : 
; 825  : 		// Can't be the same team
; 826  : 		if(eFromTeam == eThirdTeam)

	mov	ecx, DWORD PTR _eFromTeam$[ebp]
	cmp	ecx, DWORD PTR _eThirdTeam$221075[ebp]
	jne	SHORT $LN41@IsPossible

; 827  : 			return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN41@IsPossible:

; 828  : 
; 829  : 		// Can't ask teammates
; 830  : 		if(eToTeam == eFromTeam)

	mov	edx, DWORD PTR _eToTeam$[ebp]
	cmp	edx, DWORD PTR _eFromTeam$[ebp]
	jne	SHORT $LN40@IsPossible

; 831  : 			return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN40@IsPossible:

; 832  : 
; 833  : 		// Must be alive
; 834  : 		if(!GET_TEAM(eThirdTeam).isAlive())

	mov	eax, DWORD PTR _eThirdTeam$221075[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T227164[ebp], eax
	mov	ecx, DWORD PTR $T227164[ebp]
	xor	edx, edx
	cmp	DWORD PTR [ecx+12], 0
	setg	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN39@IsPossible

; 835  : 			return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN39@IsPossible:

; 836  : 
; 837  : 		// Player that wants Peace hasn't yet met the 3rd Team
; 838  : 		if(!pToTeam->isHasMet(eThirdTeam))

	mov	ecx, DWORD PTR _eThirdTeam$221075[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pToTeam$[ebp]
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN38@IsPossible

; 839  : 			return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN38@IsPossible:

; 840  : 		// Player that would go to Peace hasn't yet met the 3rd Team
; 841  : 		if(!pFromTeam->isHasMet(eThirdTeam))

	mov	eax, DWORD PTR _eThirdTeam$221075[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFromTeam$[ebp]
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN37@IsPossible

; 842  : 			return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN37@IsPossible:

; 843  : 		// Player that would go to peace is already at peace with the 3rd Team
; 844  : 		if(!pFromTeam->isAtWar(eThirdTeam))

	mov	edx, DWORD PTR _eThirdTeam$221075[ebp]
	push	edx
	mov	ecx, DWORD PTR _pFromTeam$[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN36@IsPossible

; 845  : 			return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN36@IsPossible:

; 846  : 
; 847  : 		// Can't already have this in the deal
; 848  : 		//if (IsThirdPartyPeaceTrade( ePlayer, GET_TEAM(eThirdTeam).getLeaderID() ))
; 849  : 		//	return false;
; 850  : 
; 851  : 		// If eThirdTeam is an AI then they have to want peace with ToTeam
; 852  : 		CvPlayer* pOtherPlayer = &GET_PLAYER(GET_TEAM(eThirdTeam).getLeaderID());

	mov	ecx, DWORD PTR _eThirdTeam$221075[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T227171[ebp], ecx
	mov	ecx, DWORD PTR $T227171[ebp]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	mov	DWORD PTR $T227175[ebp], eax
	mov	edx, DWORD PTR $T227175[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _pOtherPlayer$221083[ebp], edx

; 853  : 		// Minor civ
; 854  : 		if(pOtherPlayer->isMinorCiv())

	mov	ecx, DWORD PTR _pOtherPlayer$221083[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN35@IsPossible

; 855  : 		{
; 856  : 			// Minor at permanent war with this player
; 857  : 			if(pOtherPlayer->GetMinorCivAI()->IsPermanentWar(eFromTeam))

	mov	ecx, DWORD PTR _eFromTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pOtherPlayer$221083[ebp]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?IsPermanentWar@CvMinorCivAI@@QBE_NW4TeamTypes@@@Z ; CvMinorCivAI::IsPermanentWar
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN34@IsPossible

; 858  : 				return false;

	xor	al, al
	jmp	$LN149@IsPossible
	jmp	SHORT $LN33@IsPossible
$LN34@IsPossible:

; 859  : 
; 860  : 			// Minor's ally at war with this player?
; 861  : 			else if(pOtherPlayer->GetMinorCivAI()->IsPeaceBlocked(eFromTeam))

	mov	eax, DWORD PTR _eFromTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pOtherPlayer$221083[ebp]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?IsPeaceBlocked@CvMinorCivAI@@QBE_NW4TeamTypes@@@Z ; CvMinorCivAI::IsPeaceBlocked
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN33@IsPossible

; 862  : 			{
; 863  : 				// If the ally is us, don't block peace here
; 864  : 				if(pOtherPlayer->GetMinorCivAI()->GetAlly() != eToPlayer)

	mov	ecx, DWORD PTR _pOtherPlayer$221083[ebp]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetAlly
	cmp	eax, DWORD PTR _eToPlayer$[ebp]
	je	SHORT $LN33@IsPossible

; 865  : 					return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN33@IsPossible:

; 866  : 			}
; 867  : 		}
; 868  : 		// Major civ
; 869  : 		else

	jmp	SHORT $LN30@IsPossible
$LN35@IsPossible:

; 870  : 		{
; 871  : 			// Can't ask them to make peace with a human, because we have no way of knowing if the human wants peace
; 872  : 			if(pOtherPlayer->isHuman())

	mov	ecx, DWORD PTR _pOtherPlayer$221083[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN29@IsPossible

; 873  : 				return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN29@IsPossible:

; 874  : 
; 875  : 			// Player does not want peace with eOtherPlayer
; 876  : 			if(pFromPlayer->isHuman() || pFromPlayer->GetDiplomacyAI()->GetWarGoal(pOtherPlayer->GetID()) < WAR_GOAL_DAMAGE)

	mov	ecx, DWORD PTR _pFromPlayer$[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN27@IsPossible
	mov	ecx, DWORD PTR _pOtherPlayer$221083[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T227184[ebp], edx
	mov	eax, DWORD PTR $T227184[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFromPlayer$[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetWarGoal@CvDiplomacyAI@@QBE?AW4WarGoalTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetWarGoal
	cmp	eax, 3
	jge	SHORT $LN28@IsPossible
$LN27@IsPossible:

; 877  : 				return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN28@IsPossible:

; 878  : 
; 879  : 			// Other player does not want peace with eToPlayer
; 880  : 			if(!pOtherPlayer->GetDiplomacyAI()->IsWantsPeaceWithPlayer(ePlayer))

	mov	ecx, DWORD PTR _ePlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pOtherPlayer$221083[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsWantsPeaceWithPlayer@CvDiplomacyAI@@QBE_NW4PlayerTypes@@@Z ; CvDiplomacyAI::IsWantsPeaceWithPlayer
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN30@IsPossible

; 881  : 				return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN30@IsPossible:

; 882  : 		}

	jmp	$LN141@IsPossible
$LN42@IsPossible:

; 883  : 	}
; 884  : 	// Third Party War
; 885  : 	else if(eItem == TRADE_ITEM_THIRD_PARTY_WAR)

	cmp	DWORD PTR _eItem$[ebp], 15		; 0000000fH
	jne	$LN24@IsPossible

; 886  : 	{
; 887  : 		TeamTypes eThirdTeam = (TeamTypes) iData1;

	mov	eax, DWORD PTR _iData1$[ebp]
	mov	DWORD PTR _eThirdTeam$221096[ebp], eax

; 888  : 
; 889  : 		// Can't be the same team
; 890  : 		if(eFromTeam == eThirdTeam)

	mov	ecx, DWORD PTR _eFromTeam$[ebp]
	cmp	ecx, DWORD PTR _eThirdTeam$221096[ebp]
	jne	SHORT $LN23@IsPossible

; 891  : 			return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN23@IsPossible:

; 892  : 
; 893  : 		// Can't ask teammates
; 894  : 		if(eToTeam == eFromTeam)

	mov	edx, DWORD PTR _eToTeam$[ebp]
	cmp	edx, DWORD PTR _eFromTeam$[ebp]
	jne	SHORT $LN22@IsPossible

; 895  : 			return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN22@IsPossible:

; 896  : 
; 897  : 		// Must be alive
; 898  : 		if(!GET_TEAM(eThirdTeam).isAlive())

	mov	eax, DWORD PTR _eThirdTeam$221096[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T227188[ebp], eax
	mov	ecx, DWORD PTR $T227188[ebp]
	xor	edx, edx
	cmp	DWORD PTR [ecx+12], 0
	setg	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN21@IsPossible

; 899  : 			return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN21@IsPossible:

; 900  : 
; 901  : 		// Player that would go to war hasn't yet met the 3rd Team
; 902  : 		if(!pToTeam->isHasMet(eThirdTeam))

	mov	ecx, DWORD PTR _eThirdTeam$221096[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pToTeam$[ebp]
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN20@IsPossible

; 903  : 			return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN20@IsPossible:

; 904  : 		// Player that wants war not met this team
; 905  : 		if(!pFromTeam->isHasMet(eThirdTeam))

	mov	eax, DWORD PTR _eThirdTeam$221096[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFromTeam$[ebp]
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN19@IsPossible

; 906  : 			return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN19@IsPossible:

; 907  : 
; 908  : 		// Player that would go to war is already at war with the 3rd Team
; 909  : 		if(pFromTeam->isAtWar(eThirdTeam))

	mov	edx, DWORD PTR _eThirdTeam$221096[ebp]
	push	edx
	mov	ecx, DWORD PTR _pFromTeam$[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN18@IsPossible

; 910  : 			return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN18@IsPossible:

; 911  : 
; 912  : 		// Can this player actually declare war?
; 913  : 		if(!pFromTeam->canDeclareWar(eThirdTeam))

	mov	ecx, DWORD PTR _eThirdTeam$221096[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pFromTeam$[ebp]
	call	?canDeclareWar@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::canDeclareWar
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN17@IsPossible

; 914  : 			return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN17@IsPossible:

; 915  : 
; 916  : 		// Can't already have this in the deal
; 917  : 		//if (IsThirdPartyWarTrade( ePlayer, GET_TEAM(eThirdTeam).getLeaderID() ))
; 918  : 		//	return false;
; 919  : 
; 920  : 		// Can't ask a player to declare war on their ally
; 921  : 		if(GET_TEAM(eThirdTeam).isMinorCiv())

	mov	eax, DWORD PTR _eThirdTeam$221096[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T227195[ebp], eax
	mov	ecx, DWORD PTR $T227195[ebp]
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN16@IsPossible

; 922  : 		{
; 923  : 			if(GET_PLAYER(GET_TEAM(eThirdTeam).getLeaderID()).GetMinorCivAI()->GetAlly() == ePlayer)

	mov	edx, DWORD PTR _eThirdTeam$221096[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T227199[ebp], edx
	mov	ecx, DWORD PTR $T227199[ebp]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	mov	DWORD PTR $T227203[ebp], eax
	mov	eax, DWORD PTR $T227203[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T227204[ebp], eax
	mov	ecx, DWORD PTR $T227204[ebp]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetAlly
	cmp	eax, DWORD PTR _ePlayer$[ebp]
	jne	SHORT $LN16@IsPossible

; 924  : 				return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN16@IsPossible:

; 925  : 		}
; 926  : 	}

	jmp	$LN141@IsPossible
$LN24@IsPossible:

; 927  : 	// Third Party Embargo
; 928  : 	else if(eItem == TRADE_ITEM_THIRD_PARTY_EMBARGO)

	cmp	DWORD PTR _eItem$[ebp], 16		; 00000010H
	jne	SHORT $LN13@IsPossible

; 929  : 	{
; 930  : 		return false;

	xor	al, al
	jmp	$LN149@IsPossible
	jmp	$LN141@IsPossible
$LN13@IsPossible:

; 931  : 	}
; 932  : 	// Declaration of friendship
; 933  : 	else if(eItem == TRADE_ITEM_DECLARATION_OF_FRIENDSHIP)

	cmp	DWORD PTR _eItem$[ebp], 18		; 00000012H
	jne	SHORT $LN11@IsPossible

; 934  : 	{
; 935  : 		// If we are at war, then we can't until we make peace
; 936  : 		if(pFromTeam->isAtWar(eToTeam))

	mov	ecx, DWORD PTR _eToTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pFromTeam$[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN10@IsPossible

; 937  : 			return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN10@IsPossible:

; 938  : 
; 939  : 		// Already have a DoF?
; 940  : 		if (pFromPlayer->GetDiplomacyAI()->IsDoFAccepted(eToPlayer) && pToPlayer->GetDiplomacyAI()->IsDoFAccepted(ePlayer))

	mov	eax, DWORD PTR _eToPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFromPlayer$[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsDoFAccepted@CvDiplomacyAI@@QBE_NW4PlayerTypes@@@Z ; CvDiplomacyAI::IsDoFAccepted
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN9@IsPossible
	mov	edx, DWORD PTR _ePlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pToPlayer$[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsDoFAccepted@CvDiplomacyAI@@QBE_NW4PlayerTypes@@@Z ; CvDiplomacyAI::IsDoFAccepted
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@IsPossible

; 941  : 			return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN9@IsPossible:

; 942  : 	}

	jmp	$LN141@IsPossible
$LN11@IsPossible:

; 943  : 	// Promise to Vote in upcoming league session
; 944  : 	else if (eItem == TRADE_ITEM_VOTE_COMMITMENT)

	cmp	DWORD PTR _eItem$[ebp], 19		; 00000013H
	jne	$LN141@IsPossible

; 945  : 	{
; 946  : 		// If we are at war, then we can't until we make peace
; 947  : 		if(pFromTeam->isAtWar(eToTeam))

	mov	ecx, DWORD PTR _eToTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pFromTeam$[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN6@IsPossible

; 948  : 			return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN6@IsPossible:

; 949  : 
; 950  : 		int iID = iData1;

	mov	eax, DWORD PTR _iData1$[ebp]
	mov	DWORD PTR _iID$221116[ebp], eax

; 951  : 		//antonjs: todo: verify iChoice is valid as well:
; 952  : 		//int iChoice = iData2;
; 953  : #ifdef CVASSERT_ENABLE
; 954  : 		int iNumVotes = iData3;
; 955  : #endif
; 956  : 		bool bRepeal = bFlag1;

	mov	cl, BYTE PTR _bFlag1$[ebp]
	mov	BYTE PTR _bRepeal$221117[ebp], cl

; 957  : 
; 958  : #ifdef CVASSERT_ENABLE
; 959  : 		DEBUG_VARIABLE(iNumVotes);
; 960  : #endif
; 961  : 
; 962  : #ifndef AUI_LEAGUES_FIX_POSSIBLE_DEALLOCATION_CRASH
; 963  : 		if(GC.getGame().GetGameLeagues()->GetNumActiveLeagues() == 0)

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T227208[ebp], edx
	mov	ecx, DWORD PTR $T227208[ebp]
	call	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ ; CvGame::GetGameLeagues
	mov	ecx, eax
	call	?GetNumActiveLeagues@CvGameLeagues@@QAEHXZ ; CvGameLeagues::GetNumActiveLeagues
	test	eax, eax
	jne	SHORT $LN5@IsPossible

; 964  : 			return false;

	xor	al, al
	jmp	$LN149@IsPossible
$LN5@IsPossible:

; 965  : #endif
; 966  : 
; 967  : 		CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T227212[ebp], eax
	mov	ecx, DWORD PTR $T227212[ebp]
	call	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ ; CvGame::GetGameLeagues
	mov	ecx, eax
	call	?GetActiveLeague@CvGameLeagues@@QAEPAVCvLeague@@XZ ; CvGameLeagues::GetActiveLeague
	mov	DWORD PTR _pLeague$221119[ebp], eax

; 968  : 		if(pLeague == NULL)

	cmp	DWORD PTR _pLeague$221119[ebp], 0
	jne	SHORT $LN4@IsPossible

; 969  : 			return false;

	xor	al, al
	jmp	SHORT $LN149@IsPossible
$LN4@IsPossible:

; 970  : 
; 971  : 		CvAssert(pLeague->IsProposed(iID, bRepeal));
; 972  : #ifdef CVASSERT_ENABLE
; 973  : 		CvAssert(iNumVotes <= pLeague->GetCoreVotesForMember(ePlayer));
; 974  : #endif
; 975  : 		
; 976  : 		// Can't already have a vote commitment in the deal
; 977  : 		if(!bFinalizing && IsVoteCommitmentTrade(ePlayer))

	movzx	ecx, BYTE PTR _bFinalizing$[ebp]
	test	ecx, ecx
	jne	SHORT $LN3@IsPossible
	mov	edx, DWORD PTR _ePlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsVoteCommitmentTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ; CvDeal::IsVoteCommitmentTrade
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@IsPossible

; 978  : 			return false;

	xor	al, al
	jmp	SHORT $LN149@IsPossible
$LN3@IsPossible:

; 979  : 
; 980  : 		// Must be a valid proposal
; 981  : 		if(!pLeague->IsProposed(iID, bRepeal))

	push	0
	movzx	ecx, BYTE PTR _bRepeal$221117[ebp]
	push	ecx
	mov	edx, DWORD PTR _iID$221116[ebp]
	push	edx
	mov	ecx, DWORD PTR _pLeague$221119[ebp]
	call	?IsProposed@CvLeague@@QAE_NH_N0@Z	; CvLeague::IsProposed
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@IsPossible

; 982  : 			return false;

	xor	al, al
	jmp	SHORT $LN149@IsPossible
$LN2@IsPossible:

; 983  : 
; 984  : 		// This player must be allowed to
; 985  : 		if(!pFromPlayer->GetLeagueAI()->CanCommitVote(eToPlayer))

	push	0
	mov	ecx, DWORD PTR _eToPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pFromPlayer$[ebp]
	call	?GetLeagueAI@CvPlayer@@QBEPAVCvLeagueAI@@XZ ; CvPlayer::GetLeagueAI
	mov	ecx, eax
	call	?CanCommitVote@CvLeagueAI@@QAE_NW4PlayerTypes@@PAVCvString@@@Z ; CvLeagueAI::CanCommitVote
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN141@IsPossible

; 986  : 			return false;

	xor	al, al
	jmp	SHORT $LN149@IsPossible
$LN141@IsPossible:

; 987  : 	}
; 988  : 
; 989  : 	return true;

	mov	al, 1
$LN149@IsPossible:

; 990  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z$0:
	lea	ecx, DWORD PTR _it$220962[ebp]
	jmp	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
__unwindfunclet$?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z$5:
	lea	ecx, DWORD PTR _it$221014[ebp]
	jmp	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
__unwindfunclet$?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z$8:
	lea	ecx, DWORD PTR _args$221067[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__ehhandler$?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-472]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ENDP ; CvDeal::IsPossibleToTradeItem
PUBLIC	?GetNumResource@CvDeal@@QAEHW4PlayerTypes@@W4ResourceTypes@@@Z ; CvDeal::GetNumResource
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
xdata$x	SEGMENT
__unwindtable$?GetNumResource@CvDeal@@QAEHW4PlayerTypes@@W4ResourceTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetNumResource@CvDeal@@QAEHW4PlayerTypes@@W4ResourceTypes@@@Z$0
__ehfuncinfo$?GetNumResource@CvDeal@@QAEHW4PlayerTypes@@W4ResourceTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetNumResource@CvDeal@@QAEHW4PlayerTypes@@W4ResourceTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetNumResource@CvDeal@@QAEHW4PlayerTypes@@W4ResourceTypes@@@Z
_TEXT	SEGMENT
tv237 = -168						; size = 4
tv233 = -164						; size = 4
_this$ = -160						; size = 4
$T227635 = -156						; size = 4
$T227603 = -152						; size = 4
$T227571 = -148						; size = 4
$T227539 = -144						; size = 4
$T227516 = -140						; size = 4
$T227500 = -136						; size = 4
$T227496 = -132						; size = 4
$T227487 = -128						; size = 4
$T227439 = -124						; size = 4
$T227407 = -120						; size = 4
$T227375 = -116						; size = 4
$T227343 = -112						; size = 4
$T227320 = -108						; size = 4
$T227304 = -104						; size = 4
$T227300 = -100						; size = 4
$T227291 = -96						; size = 4
$T227243 = -92						; size = 4
$T227239 = -88						; size = 4
$T227235 = -84						; size = 4
$T227226 = -80						; size = 8
$T227225 = -69						; size = 1
$T227224 = -68						; size = 8
$T227223 = -60						; size = 8
$T227222 = -49						; size = 1
$T227221 = -48						; size = 8
_it$221137 = -40					; size = 8
_eOtherPlayer$221134 = -32				; size = 4
_iNumAvailable$ = -28					; size = 4
_pRenewDeal$ = -24					; size = 4
_iNumInExistingDeal$ = -20				; size = 4
_iNumInRenewDeal$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_ePlayer$ = 8						; size = 4
_eResource$ = 12					; size = 4
?GetNumResource@CvDeal@@QAEHW4PlayerTypes@@W4ResourceTypes@@@Z PROC ; CvDeal::GetNumResource, COMDAT
; _this$ = ecx

; 994  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetNumResource@CvDeal@@QAEHW4PlayerTypes@@W4ResourceTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 156				; 0000009cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 995  : 	int iNumAvailable = GET_PLAYER(ePlayer).getNumResourceAvailable(eResource, false);

	mov	eax, DWORD PTR _ePlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T227235[ebp], eax
	push	0
	mov	ecx, DWORD PTR _eResource$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T227235[ebp]
	call	?getNumResourceAvailable@CvPlayer@@QBEHW4ResourceTypes@@_N@Z ; CvPlayer::getNumResourceAvailable
	mov	DWORD PTR _iNumAvailable$[ebp], eax

; 996  : 	int iNumInRenewDeal = 0;

	mov	DWORD PTR _iNumInRenewDeal$[ebp], 0

; 997  : 	int iNumInExistingDeal = 0;

	mov	DWORD PTR _iNumInExistingDeal$[ebp], 0

; 998  : 
; 999  : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1000 : 	PlayerTypes eOtherPlayer = GetOtherPlayer(ePlayer);
; 1001 : 	CvGameDeals* pGameDeals = GC.getGame().GetGameDeals();
; 1002 : 	uint uiCurrentlyEndingDeals = pGameDeals->GetNumCurrentlyEndingDeals(ePlayer, eOtherPlayer);
; 1003 : #endif
; 1004 : 	CvDeal* pRenewDeal = GET_PLAYER(ePlayer).GetDiplomacyAI()->GetDealToRenew();

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T227239[ebp], edx
	push	0
	mov	ecx, DWORD PTR $T227239[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetDealToRenew@CvDiplomacyAI@@QAEPAVCvDeal@@PAH@Z ; CvDiplomacyAI::GetDealToRenew
	mov	DWORD PTR _pRenewDeal$[ebp], eax

; 1005 : 	if (!pRenewDeal)

	cmp	DWORD PTR _pRenewDeal$[ebp], 0
	jne	SHORT $LN11@GetNumReso

; 1006 : 	{
; 1007 : #ifndef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1008 : 		PlayerTypes eOtherPlayer = GetOtherPlayer(ePlayer);

	mov	eax, DWORD PTR _ePlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOtherPlayer@CvDeal@@QBE?AW4PlayerTypes@@W42@@Z ; CvDeal::GetOtherPlayer
	mov	DWORD PTR _eOtherPlayer$221134[ebp], eax

; 1009 : #endif
; 1010 : 		if (eOtherPlayer != NO_PLAYER)

	cmp	DWORD PTR _eOtherPlayer$221134[ebp], -1
	je	SHORT $LN11@GetNumReso

; 1011 : 		{
; 1012 : 			pRenewDeal = GET_PLAYER(eOtherPlayer).GetDiplomacyAI()->GetDealToRenew();

	mov	ecx, DWORD PTR _eOtherPlayer$221134[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T227243[ebp], ecx
	push	0
	mov	ecx, DWORD PTR $T227243[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetDealToRenew@CvDiplomacyAI@@QAEPAVCvDeal@@PAH@Z ; CvDiplomacyAI::GetDealToRenew
	mov	DWORD PTR _pRenewDeal$[ebp], eax
$LN11@GetNumReso:

; 1013 : 		}
; 1014 : 	}
; 1015 : 
; 1016 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1017 : 	if (pRenewDeal || uiCurrentlyEndingDeals > 0)
; 1018 : #else
; 1019 : 	if (pRenewDeal)

	cmp	DWORD PTR _pRenewDeal$[ebp], 0
	je	$LN9@GetNumReso

; 1020 : #endif
; 1021 : 	{
; 1022 : 		// count any that are in the renew deal
; 1023 : 		TradedItemList::iterator it;

	mov	DWORD PTR _it$221137[ebp], 0
	mov	DWORD PTR _it$221137[ebp+4], 268435455	; 0fffffffH
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1024 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1025 : 		if (pRenewDeal)
; 1026 : 		{
; 1027 : #endif
; 1028 : 		for(it = pRenewDeal->m_TradedItems.begin(); it != pRenewDeal->m_TradedItems.end(); ++it)

	lea	edx, DWORD PTR $T227221[ebp]
	push	edx
	mov	ecx, DWORD PTR _pRenewDeal$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv233[ebp], eax
	mov	eax, DWORD PTR tv233[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _it$221137[ebp], ecx
	mov	DWORD PTR _it$221137[ebp+4], edx
	jmp	SHORT $LN8@GetNumReso
$LN7@GetNumReso:
	cmp	DWORD PTR _it$221137[ebp+4], 268435455	; 0fffffffH
	jne	SHORT $LN44@GetNumReso
	mov	eax, DWORD PTR _it$221137[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _it$221137[ebp+4], ecx
	jmp	SHORT $LN8@GetNumReso
$LN44@GetNumReso:
	mov	edx, DWORD PTR _it$221137[ebp]
	mov	DWORD PTR $T227291[ebp], edx
	mov	eax, DWORD PTR _it$221137[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T227291[ebp]
	add	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR $T227300[ebp], eax
	mov	edx, DWORD PTR $T227300[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T227304[ebp], eax
	mov	ecx, DWORD PTR $T227304[ebp]
	mov	DWORD PTR _it$221137[ebp+4], ecx
$LN8@GetNumReso:
	lea	edx, DWORD PTR $T227223[ebp]
	push	edx
	mov	ecx, DWORD PTR _pRenewDeal$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T227320[ebp], eax
	mov	eax, DWORD PTR $T227320[ebp]
	mov	ecx, DWORD PTR _it$221137[ebp+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setne	dl
	mov	BYTE PTR $T227222[ebp], dl
	movzx	eax, BYTE PTR $T227222[ebp]
	test	eax, eax
	je	SHORT $LN6@GetNumReso

; 1029 : 		{
; 1030 : 			if(it->m_eItemType == TRADE_ITEM_RESOURCES && it->m_eFromPlayer == ePlayer && (ResourceTypes)it->m_iData1 == eResource)

	mov	ecx, DWORD PTR _it$221137[ebp]
	mov	DWORD PTR $T227343[ebp], ecx
	mov	edx, DWORD PTR _it$221137[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T227343[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	DWORD PTR [ecx+edx+8], 3
	jne	SHORT $LN5@GetNumReso
	mov	edx, DWORD PTR _it$221137[ebp]
	mov	DWORD PTR $T227375[ebp], edx
	mov	eax, DWORD PTR _it$221137[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T227375[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+eax+36]
	cmp	eax, DWORD PTR _ePlayer$[ebp]
	jne	SHORT $LN5@GetNumReso
	mov	ecx, DWORD PTR _it$221137[ebp]
	mov	DWORD PTR $T227407[ebp], ecx
	mov	edx, DWORD PTR _it$221137[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T227407[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+edx+20]
	cmp	edx, DWORD PTR _eResource$[ebp]
	jne	SHORT $LN5@GetNumReso

; 1031 : 			{
; 1032 : 				// credit the amount
; 1033 : 				iNumInRenewDeal += it->m_iData2;

	mov	eax, DWORD PTR _it$221137[ebp]
	mov	DWORD PTR $T227439[ebp], eax
	mov	ecx, DWORD PTR _it$221137[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T227439[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _iNumInRenewDeal$[ebp]
	add	edx, DWORD PTR [eax+ecx+24]
	mov	DWORD PTR _iNumInRenewDeal$[ebp], edx
$LN5@GetNumReso:

; 1034 : 			}
; 1035 : 		}

	jmp	$LN7@GetNumReso
$LN6@GetNumReso:

; 1036 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1037 : 		}
; 1038 : 
; 1039 : 		CvDeal* pLoopDeal = NULL;
; 1040 : 		for (uint uiI = 0; uiI < uiCurrentlyEndingDeals; uiI++)
; 1041 : 		{
; 1042 : 			pLoopDeal = pGameDeals->GetCurrentlyEndingDeal(ePlayer, eOtherPlayer, uiI);
; 1043 : 			for (it = pLoopDeal->m_TradedItems.begin(); it != pLoopDeal->m_TradedItems.end(); ++it)
; 1044 : 			{
; 1045 : 				if (it->m_eItemType == TRADE_ITEM_RESOURCES && it->m_eFromPlayer == ePlayer && (ResourceTypes)it->m_iData1 == eResource)
; 1046 : 				{
; 1047 : 					// credit the amount
; 1048 : 					iNumInRenewDeal += it->m_iData2;
; 1049 : 				}
; 1050 : 			}
; 1051 : 		}
; 1052 : #endif
; 1053 : 
; 1054 : 		// remove any that are in this deal
; 1055 : 		for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	eax, DWORD PTR $T227224[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv237[ebp], eax
	mov	ecx, DWORD PTR tv237[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _it$221137[ebp], edx
	mov	DWORD PTR _it$221137[ebp+4], eax
	jmp	SHORT $LN4@GetNumReso
$LN3@GetNumReso:
	cmp	DWORD PTR _it$221137[ebp+4], 268435455	; 0fffffffH
	jne	SHORT $LN114@GetNumReso
	mov	ecx, DWORD PTR _it$221137[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _it$221137[ebp+4], edx
	jmp	SHORT $LN4@GetNumReso
$LN114@GetNumReso:
	mov	eax, DWORD PTR _it$221137[ebp]
	mov	DWORD PTR $T227487[ebp], eax
	mov	ecx, DWORD PTR _it$221137[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T227487[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T227496[ebp], ecx
	mov	eax, DWORD PTR $T227496[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T227500[ebp], ecx
	mov	edx, DWORD PTR $T227500[ebp]
	mov	DWORD PTR _it$221137[ebp+4], edx
$LN4@GetNumReso:
	lea	eax, DWORD PTR $T227226[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T227516[ebp], eax
	mov	ecx, DWORD PTR $T227516[ebp]
	mov	edx, DWORD PTR _it$221137[ebp+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setne	al
	mov	BYTE PTR $T227225[ebp], al
	movzx	ecx, BYTE PTR $T227225[ebp]
	test	ecx, ecx
	je	$LN2@GetNumReso

; 1056 : 		{
; 1057 : 			if(it->m_eItemType == TRADE_ITEM_RESOURCES && it->m_eFromPlayer == ePlayer && (ResourceTypes)it->m_iData1 == eResource)

	mov	edx, DWORD PTR _it$221137[ebp]
	mov	DWORD PTR $T227539[ebp], edx
	mov	eax, DWORD PTR _it$221137[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T227539[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+eax+8], 3
	jne	SHORT $LN1@GetNumReso
	mov	eax, DWORD PTR _it$221137[ebp]
	mov	DWORD PTR $T227571[ebp], eax
	mov	ecx, DWORD PTR _it$221137[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T227571[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+ecx+36]
	cmp	ecx, DWORD PTR _ePlayer$[ebp]
	jne	SHORT $LN1@GetNumReso
	mov	edx, DWORD PTR _it$221137[ebp]
	mov	DWORD PTR $T227603[ebp], edx
	mov	eax, DWORD PTR _it$221137[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T227603[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+eax+20]
	cmp	eax, DWORD PTR _eResource$[ebp]
	jne	SHORT $LN1@GetNumReso

; 1058 : 			{
; 1059 : 				iNumInExistingDeal += it->m_iData2;

	mov	ecx, DWORD PTR _it$221137[ebp]
	mov	DWORD PTR $T227635[ebp], ecx
	mov	edx, DWORD PTR _it$221137[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T227635[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR _iNumInExistingDeal$[ebp]
	add	eax, DWORD PTR [ecx+edx+24]
	mov	DWORD PTR _iNumInExistingDeal$[ebp], eax
$LN1@GetNumReso:

; 1060 : 			}
; 1061 : 		}

	jmp	$LN3@GetNumReso
$LN2@GetNumReso:

; 1062 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN9@GetNumReso:

; 1063 : 
; 1064 : 	return iNumAvailable + iNumInRenewDeal - iNumInExistingDeal;

	mov	eax, DWORD PTR _iNumAvailable$[ebp]
	add	eax, DWORD PTR _iNumInRenewDeal$[ebp]
	sub	eax, DWORD PTR _iNumInExistingDeal$[ebp]

; 1065 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetNumResource@CvDeal@@QAEHW4PlayerTypes@@W4ResourceTypes@@@Z$0:
	lea	ecx, DWORD PTR _it$221137[ebp]
	jmp	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
__ehhandler$?GetNumResource@CvDeal@@QAEHW4PlayerTypes@@W4ResourceTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-160]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetNumResource@CvDeal@@QAEHW4PlayerTypes@@W4ResourceTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetNumResource@CvDeal@@QAEHW4PlayerTypes@@W4ResourceTypes@@@Z ENDP ; CvDeal::GetNumResource
PUBLIC	?GetPeaceTreatyType@CvDeal@@QBE?AW4PeaceTreatyTypes@@XZ ; CvDeal::GetPeaceTreatyType
; Function compile flags: /Odtp
;	COMDAT ?GetPeaceTreatyType@CvDeal@@QBE?AW4PeaceTreatyTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPeaceTreatyType@CvDeal@@QBE?AW4PeaceTreatyTypes@@XZ PROC ; CvDeal::GetPeaceTreatyType, COMDAT
; _this$ = ecx

; 1070 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1071 : 	return m_ePeaceTreatyType;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+24]

; 1072 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPeaceTreatyType@CvDeal@@QBE?AW4PeaceTreatyTypes@@XZ ENDP ; CvDeal::GetPeaceTreatyType
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?SetPeaceTreatyType@CvDeal@@QAEXW4PeaceTreatyTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eTreaty$ = 8						; size = 4
?SetPeaceTreatyType@CvDeal@@QAEXW4PeaceTreatyTypes@@@Z PROC ; CvDeal::SetPeaceTreatyType, COMDAT
; _this$ = ecx

; 1076 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1077 : 	CvAssertMsg(eTreaty >= NO_PEACE_TREATY_TYPE, "DEAL: Invalid PeaceTreatyType index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");	// NO_PEACE_TREATY_TYPE is valid because we could be clearing the deal out for other uses
; 1078 : 	CvAssertMsg(eTreaty < NUM_PEACE_TREATY_TYPES, "DEAL: Invalid PeaceTreatyType index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1079 : 
; 1080 : 	m_ePeaceTreatyType = eTreaty;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _eTreaty$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 1081 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetPeaceTreatyType@CvDeal@@QAEXW4PeaceTreatyTypes@@@Z ENDP ; CvDeal::SetPeaceTreatyType
_TEXT	ENDS
PUBLIC	?GetSurrenderingPlayer@CvDeal@@QBE?AW4PlayerTypes@@XZ ; CvDeal::GetSurrenderingPlayer
; Function compile flags: /Odtp
;	COMDAT ?GetSurrenderingPlayer@CvDeal@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSurrenderingPlayer@CvDeal@@QBE?AW4PlayerTypes@@XZ PROC ; CvDeal::GetSurrenderingPlayer, COMDAT
; _this$ = ecx

; 1085 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1086 : 	return m_eSurrenderingPlayer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+28]

; 1087 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetSurrenderingPlayer@CvDeal@@QBE?AW4PlayerTypes@@XZ ENDP ; CvDeal::GetSurrenderingPlayer
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?SetSurrenderingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ePlayer$ = 8						; size = 4
?SetSurrenderingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z PROC ; CvDeal::SetSurrenderingPlayer, COMDAT
; _this$ = ecx

; 1091 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1092 : 	CvAssertMsg(ePlayer >= NO_PLAYER, "DEAL: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");	// NO_PLAYER is valid because we could be clearing the deal out for other uses
; 1093 : 	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DEAL: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1094 : 
; 1095 : 	m_eSurrenderingPlayer = ePlayer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _ePlayer$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 1096 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetSurrenderingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z ENDP ; CvDeal::SetSurrenderingPlayer
_TEXT	ENDS
PUBLIC	?GetDemandingPlayer@CvDeal@@QBE?AW4PlayerTypes@@XZ ; CvDeal::GetDemandingPlayer
; Function compile flags: /Odtp
;	COMDAT ?GetDemandingPlayer@CvDeal@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDemandingPlayer@CvDeal@@QBE?AW4PlayerTypes@@XZ PROC	; CvDeal::GetDemandingPlayer, COMDAT
; _this$ = ecx

; 1100 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1101 : 	return m_eDemandingPlayer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+32]

; 1102 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetDemandingPlayer@CvDeal@@QBE?AW4PlayerTypes@@XZ ENDP	; CvDeal::GetDemandingPlayer
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?SetDemandingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ePlayer$ = 8						; size = 4
?SetDemandingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z PROC	; CvDeal::SetDemandingPlayer, COMDAT
; _this$ = ecx

; 1106 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1107 : 	CvAssertMsg(ePlayer >= NO_PLAYER, "DEAL: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");	// NO_PLAYER is valid because we could be clearing the deal out for other uses
; 1108 : 	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DEAL: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1109 : 
; 1110 : 	m_eDemandingPlayer = ePlayer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _ePlayer$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 1111 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetDemandingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z ENDP	; CvDeal::SetDemandingPlayer
_TEXT	ENDS
PUBLIC	?GetRequestingPlayer@CvDeal@@QBE?AW4PlayerTypes@@XZ ; CvDeal::GetRequestingPlayer
; Function compile flags: /Odtp
;	COMDAT ?GetRequestingPlayer@CvDeal@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRequestingPlayer@CvDeal@@QBE?AW4PlayerTypes@@XZ PROC ; CvDeal::GetRequestingPlayer, COMDAT
; _this$ = ecx

; 1115 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1116 : 	return m_eRequestingPlayer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+36]

; 1117 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetRequestingPlayer@CvDeal@@QBE?AW4PlayerTypes@@XZ ENDP ; CvDeal::GetRequestingPlayer
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?SetRequestingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ePlayer$ = 8						; size = 4
?SetRequestingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z PROC	; CvDeal::SetRequestingPlayer, COMDAT
; _this$ = ecx

; 1121 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1122 : 	CvAssertMsg(ePlayer >= NO_PLAYER, "DEAL: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");	// NO_PLAYER is valid because we could be clearing the deal out for other uses
; 1123 : 	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "DEAL: Invalid Player Index.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1124 : 
; 1125 : 	m_eRequestingPlayer = ePlayer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _ePlayer$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 1126 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetRequestingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z ENDP	; CvDeal::SetRequestingPlayer
_TEXT	ENDS
PUBLIC	?AddGoldTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z	; CvDeal::AddGoldTrade
; Function compile flags: /Odtp
;	COMDAT ?AddGoldTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_this$ = -140						; size = 4
$T227828 = -136						; size = 4
_uiNewIndex$227823 = -84				; size = 4
$T227819 = -80						; size = 44
_item$221188 = -36					; size = 36
_eFrom$ = 8						; size = 4
_iAmount$ = 12						; size = 4
?AddGoldTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z PROC	; CvDeal::AddGoldTrade, COMDAT
; _this$ = ecx

; 1133 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1134 : 	CvAssertMsg(iAmount >= 0, "DEAL: Trying to add a negative amount of Gold to a deal.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1135 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Adding deal item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1136 : 
; 1137 : 	if(IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_GOLD, iAmount))

	push	0
	push	1
	push	0
	push	-1
	push	-1
	mov	eax, DWORD PTR _iAmount$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _eFrom$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOtherPlayer@CvDeal@@QBE?AW4PlayerTypes@@W42@@Z ; CvDeal::GetOtherPlayer
	push	eax
	mov	edx, DWORD PTR _eFrom$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@AddGoldTra

; 1138 : 	{
; 1139 : 		CvTradedItem item;

	lea	ecx, DWORD PTR _item$221188[ebp]
	call	??0CvTradedItem@@QAE@XZ			; CvTradedItem::CvTradedItem

; 1140 : 		item.m_eItemType = TRADE_ITEM_GOLD;

	mov	DWORD PTR _item$221188[ebp], 0

; 1141 : 		item.m_iDuration = 0;

	mov	DWORD PTR _item$221188[ebp+4], 0

; 1142 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1143 : 		item.m_iTurnsRemaining = -1;
; 1144 : #else
; 1145 : 		item.m_iFinalTurn = -1;

	mov	DWORD PTR _item$221188[ebp+8], -1

; 1146 : #endif
; 1147 : 		item.m_iData1 = iAmount;

	mov	ecx, DWORD PTR _iAmount$[ebp]
	mov	DWORD PTR _item$221188[ebp+12], ecx

; 1148 : 		item.m_eFromPlayer = eFrom;

	mov	edx, DWORD PTR _eFrom$[ebp]
	mov	DWORD PTR _item$221188[ebp+28], edx

; 1149 : 		m_TradedItems.push_back(item);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	mov	DWORD PTR $T227828[ebp], eax
	lea	edi, DWORD PTR $T227819[ebp+8]
	mov	ecx, 9
	lea	esi, DWORD PTR _item$221188[ebp]
	rep movsd
	lea	ecx, DWORD PTR $T227819[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T227828[ebp]
	call	?Alloc@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::Alloc
	mov	DWORD PTR _uiNewIndex$227823[ebp], eax
	mov	edx, DWORD PTR _uiNewIndex$227823[ebp]
	push	edx
	mov	ecx, DWORD PTR $T227828[ebp]
	call	?push_back_existing@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEXI@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::push_back_existing
$LN2@AddGoldTra:

; 1150 : 	}
; 1151 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?AddGoldTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z ENDP	; CvDeal::AddGoldTrade
_TEXT	ENDS
PUBLIC	?AddGoldPerTurnTrade@CvDeal@@QAEXW4PlayerTypes@@HH@Z ; CvDeal::AddGoldPerTurnTrade
; Function compile flags: /Odtp
;	COMDAT ?AddGoldPerTurnTrade@CvDeal@@QAEXW4PlayerTypes@@HH@Z
_TEXT	SEGMENT
_this$ = -140						; size = 4
$T227956 = -136						; size = 4
_uiNewIndex$227951 = -84				; size = 4
$T227947 = -80						; size = 44
_item$221196 = -36					; size = 36
_eFrom$ = 8						; size = 4
_iAmount$ = 12						; size = 4
_iDuration$ = 16					; size = 4
?AddGoldPerTurnTrade@CvDeal@@QAEXW4PlayerTypes@@HH@Z PROC ; CvDeal::AddGoldPerTurnTrade, COMDAT
; _this$ = ecx

; 1155 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1156 : 	CvAssertMsg(iAmount >= 0, "DEAL: Trying to add a negative amount of GPT to a deal.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1157 : 	CvAssertMsg(iDuration >= 0, "DEAL: Trying to add a negative duration to a TradeItem.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1158 : 	CvAssertMsg(iDuration < GC.getGame().getEstimateEndTurn() * 2, "DEAL: Trade item has a crazy long duration (probably invalid).  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1159 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Adding deal item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1160 : 
; 1161 : 	if(IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_GOLD_PER_TURN, iAmount, iDuration))

	push	0
	push	1
	push	0
	push	-1
	mov	eax, DWORD PTR _iDuration$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iAmount$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _eFrom$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOtherPlayer@CvDeal@@QBE?AW4PlayerTypes@@W42@@Z ; CvDeal::GetOtherPlayer
	push	eax
	mov	eax, DWORD PTR _eFrom$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@AddGoldPer

; 1162 : 	{
; 1163 : 		CvTradedItem item;

	lea	ecx, DWORD PTR _item$221196[ebp]
	call	??0CvTradedItem@@QAE@XZ			; CvTradedItem::CvTradedItem

; 1164 : 		item.m_eItemType = TRADE_ITEM_GOLD_PER_TURN;

	mov	DWORD PTR _item$221196[ebp], 1

; 1165 : 		item.m_iDuration = iDuration;

	mov	edx, DWORD PTR _iDuration$[ebp]
	mov	DWORD PTR _item$221196[ebp+4], edx

; 1166 : 		//item.m_iFinalTurn = iDuration + GC.getGame().getGameTurn();
; 1167 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1168 : 		item.m_iTurnsRemaining = -1;
; 1169 : #else
; 1170 : 		item.m_iFinalTurn = -1;

	mov	DWORD PTR _item$221196[ebp+8], -1

; 1171 : #endif
; 1172 : 		item.m_iData1 = iAmount;

	mov	eax, DWORD PTR _iAmount$[ebp]
	mov	DWORD PTR _item$221196[ebp+12], eax

; 1173 : 		item.m_eFromPlayer = eFrom;

	mov	ecx, DWORD PTR _eFrom$[ebp]
	mov	DWORD PTR _item$221196[ebp+28], ecx

; 1174 : 		m_TradedItems.push_back(item);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 44					; 0000002cH
	mov	DWORD PTR $T227956[ebp], edx
	lea	edi, DWORD PTR $T227947[ebp+8]
	mov	ecx, 9
	lea	esi, DWORD PTR _item$221196[ebp]
	rep movsd
	lea	eax, DWORD PTR $T227947[ebp]
	push	eax
	mov	ecx, DWORD PTR $T227956[ebp]
	call	?Alloc@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::Alloc
	mov	DWORD PTR _uiNewIndex$227951[ebp], eax
	mov	ecx, DWORD PTR _uiNewIndex$227951[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T227956[ebp]
	call	?push_back_existing@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEXI@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::push_back_existing
$LN3@AddGoldPer:

; 1175 : 	}
; 1176 : 	else
; 1177 : 	{
; 1178 : 		CvAssertMsg(false, "DEAL: Trying to add an invalid GPT amount to a deal");
; 1179 : 	}
; 1180 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?AddGoldPerTurnTrade@CvDeal@@QAEXW4PlayerTypes@@HH@Z ENDP ; CvDeal::AddGoldPerTurnTrade
_TEXT	ENDS
PUBLIC	?AddMapTrade@CvDeal@@QAEXW4PlayerTypes@@@Z	; CvDeal::AddMapTrade
; Function compile flags: /Odtp
;	COMDAT ?AddMapTrade@CvDeal@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -140						; size = 4
$T228084 = -136						; size = 4
_uiNewIndex$228079 = -84				; size = 4
$T228075 = -80						; size = 44
_item$221203 = -36					; size = 36
_eFrom$ = 8						; size = 4
?AddMapTrade@CvDeal@@QAEXW4PlayerTypes@@@Z PROC		; CvDeal::AddMapTrade, COMDAT
; _this$ = ecx

; 1184 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1185 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Adding deal item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1186 : 
; 1187 : 	if(IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_MAPS))

	push	0
	push	1
	push	0
	push	-1
	push	-1
	push	-1
	push	2
	mov	eax, DWORD PTR _eFrom$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOtherPlayer@CvDeal@@QBE?AW4PlayerTypes@@W42@@Z ; CvDeal::GetOtherPlayer
	push	eax
	mov	ecx, DWORD PTR _eFrom$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@AddMapTrad

; 1188 : 	{
; 1189 : 		CvTradedItem item;

	lea	ecx, DWORD PTR _item$221203[ebp]
	call	??0CvTradedItem@@QAE@XZ			; CvTradedItem::CvTradedItem

; 1190 : 		item.m_eItemType = TRADE_ITEM_MAPS;

	mov	DWORD PTR _item$221203[ebp], 2

; 1191 : 		item.m_iDuration = 0;

	mov	DWORD PTR _item$221203[ebp+4], 0

; 1192 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1193 : 		item.m_iTurnsRemaining = -1;
; 1194 : #else
; 1195 : 		item.m_iFinalTurn = -1;

	mov	DWORD PTR _item$221203[ebp+8], -1

; 1196 : #endif
; 1197 : 		item.m_eFromPlayer = eFrom;

	mov	eax, DWORD PTR _eFrom$[ebp]
	mov	DWORD PTR _item$221203[ebp+28], eax

; 1198 : 		m_TradedItems.push_back(item);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	mov	DWORD PTR $T228084[ebp], ecx
	lea	edi, DWORD PTR $T228075[ebp+8]
	mov	ecx, 9
	lea	esi, DWORD PTR _item$221203[ebp]
	rep movsd
	lea	edx, DWORD PTR $T228075[ebp]
	push	edx
	mov	ecx, DWORD PTR $T228084[ebp]
	call	?Alloc@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::Alloc
	mov	DWORD PTR _uiNewIndex$228079[ebp], eax
	mov	eax, DWORD PTR _uiNewIndex$228079[ebp]
	push	eax
	mov	ecx, DWORD PTR $T228084[ebp]
	call	?push_back_existing@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEXI@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::push_back_existing
$LN3@AddMapTrad:

; 1199 : 	}
; 1200 : 	else
; 1201 : 	{
; 1202 : 		CvAssertMsg(false, "DEAL: Trying to add an invalid Map item to a deal");
; 1203 : 	}
; 1204 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?AddMapTrade@CvDeal@@QAEXW4PlayerTypes@@@Z ENDP		; CvDeal::AddMapTrade
_TEXT	ENDS
PUBLIC	?AddResourceTrade@CvDeal@@QAEXW4PlayerTypes@@W4ResourceTypes@@HH@Z ; CvDeal::AddResourceTrade
; Function compile flags: /Odtp
;	COMDAT ?AddResourceTrade@CvDeal@@QAEXW4PlayerTypes@@W4ResourceTypes@@HH@Z
_TEXT	SEGMENT
_this$ = -140						; size = 4
$T228212 = -136						; size = 4
_uiNewIndex$228207 = -84				; size = 4
$T228203 = -80						; size = 44
_item$221213 = -36					; size = 36
_eFrom$ = 8						; size = 4
_eResource$ = 12					; size = 4
_iAmount$ = 16						; size = 4
_iDuration$ = 20					; size = 4
?AddResourceTrade@CvDeal@@QAEXW4PlayerTypes@@W4ResourceTypes@@HH@Z PROC ; CvDeal::AddResourceTrade, COMDAT
; _this$ = ecx

; 1208 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1209 : 	CvAssertMsg(iAmount >= 0, "DEAL: Trying to add a negative amount of a Resource to a deal.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1210 : 	CvAssertMsg(iDuration >= 0, "DEAL: Trying to add a negative duration to a TradeItem.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1211 : 	CvAssertMsg(iDuration < GC.getGame().getEstimateEndTurn() * 2, "DEAL: Trade item has a crazy long duration (probably invalid).  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1212 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Adding deal item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1213 : 
; 1214 : 	if(IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_RESOURCES, eResource, iAmount))

	push	0
	push	1
	push	0
	push	-1
	mov	eax, DWORD PTR _iAmount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eResource$[ebp]
	push	ecx
	push	3
	mov	edx, DWORD PTR _eFrom$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOtherPlayer@CvDeal@@QBE?AW4PlayerTypes@@W42@@Z ; CvDeal::GetOtherPlayer
	push	eax
	mov	eax, DWORD PTR _eFrom$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@AddResourc

; 1215 : 	{
; 1216 : 		CvTradedItem item;

	lea	ecx, DWORD PTR _item$221213[ebp]
	call	??0CvTradedItem@@QAE@XZ			; CvTradedItem::CvTradedItem

; 1217 : 		item.m_eItemType = TRADE_ITEM_RESOURCES;

	mov	DWORD PTR _item$221213[ebp], 3

; 1218 : 		item.m_iDuration = iDuration;

	mov	edx, DWORD PTR _iDuration$[ebp]
	mov	DWORD PTR _item$221213[ebp+4], edx

; 1219 : 		//item.m_iFinalTurn = iDuration + GC.getGame().getGameTurn();
; 1220 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1221 : 		item.m_iTurnsRemaining = -1;
; 1222 : #else
; 1223 : 		item.m_iFinalTurn = -1;

	mov	DWORD PTR _item$221213[ebp+8], -1

; 1224 : #endif
; 1225 : 		item.m_iData1 = (int)eResource;

	mov	eax, DWORD PTR _eResource$[ebp]
	mov	DWORD PTR _item$221213[ebp+12], eax

; 1226 : 		item.m_iData2 = iAmount;

	mov	ecx, DWORD PTR _iAmount$[ebp]
	mov	DWORD PTR _item$221213[ebp+16], ecx

; 1227 : 		item.m_eFromPlayer = eFrom;

	mov	edx, DWORD PTR _eFrom$[ebp]
	mov	DWORD PTR _item$221213[ebp+28], edx

; 1228 : 		m_TradedItems.push_back(item);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	mov	DWORD PTR $T228212[ebp], eax
	lea	edi, DWORD PTR $T228203[ebp+8]
	mov	ecx, 9
	lea	esi, DWORD PTR _item$221213[ebp]
	rep movsd
	lea	ecx, DWORD PTR $T228203[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T228212[ebp]
	call	?Alloc@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::Alloc
	mov	DWORD PTR _uiNewIndex$228207[ebp], eax
	mov	edx, DWORD PTR _uiNewIndex$228207[ebp]
	push	edx
	mov	ecx, DWORD PTR $T228212[ebp]
	call	?push_back_existing@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEXI@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::push_back_existing
$LN3@AddResourc:

; 1229 : 	}
; 1230 : 	else
; 1231 : 	{
; 1232 : 		CvAssertMsg(false, "DEAL: Trying to add an invalid Resource to a deal");
; 1233 : 	}
; 1234 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?AddResourceTrade@CvDeal@@QAEXW4PlayerTypes@@W4ResourceTypes@@HH@Z ENDP ; CvDeal::AddResourceTrade
_TEXT	ENDS
PUBLIC	?AddCityTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z	; CvDeal::AddCityTrade
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
; Function compile flags: /Odtp
;	COMDAT ?AddCityTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_this$ = -156						; size = 4
$T228360 = -152						; size = 4
_uiNewIndex$228356 = -100				; size = 4
$T228351 = -96						; size = 44
$T228218 = -52						; size = 4
_item$221225 = -48					; size = 36
_pCity$ = -12						; size = 4
_x$ = -8						; size = 4
_y$ = -4						; size = 4
_eFrom$ = 8						; size = 4
_iCityID$ = 12						; size = 4
?AddCityTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z PROC	; CvDeal::AddCityTrade, COMDAT
; _this$ = ecx

; 1238 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1239 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Adding deal item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1240 : 
; 1241 : 	CvCity* pCity = GET_PLAYER(eFrom).getCity(iCityID);

	mov	eax, DWORD PTR _eFrom$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T228218[ebp], eax
	mov	ecx, DWORD PTR _iCityID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T228218[ebp]
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	DWORD PTR _pCity$[ebp], eax

; 1242 : 	int x = pCity->getX();

	mov	edx, DWORD PTR _pCity$[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR _x$[ebp], eax

; 1243 : 	int y = pCity->getY();

	mov	ecx, DWORD PTR _pCity$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR _y$[ebp], edx

; 1244 : 
; 1245 : 	if(IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_CITIES, x, y))

	push	0
	push	1
	push	0
	push	-1
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	push	4
	mov	edx, DWORD PTR _eFrom$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOtherPlayer@CvDeal@@QBE?AW4PlayerTypes@@W42@@Z ; CvDeal::GetOtherPlayer
	push	eax
	mov	eax, DWORD PTR _eFrom$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@AddCityTra

; 1246 : 	{
; 1247 : 		CvTradedItem item;

	lea	ecx, DWORD PTR _item$221225[ebp]
	call	??0CvTradedItem@@QAE@XZ			; CvTradedItem::CvTradedItem

; 1248 : 		item.m_eItemType = TRADE_ITEM_CITIES;

	mov	DWORD PTR _item$221225[ebp], 4

; 1249 : 		item.m_iDuration = 0;

	mov	DWORD PTR _item$221225[ebp+4], 0

; 1250 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1251 : 		item.m_iTurnsRemaining = -1;
; 1252 : #else
; 1253 : 		item.m_iFinalTurn = -1;

	mov	DWORD PTR _item$221225[ebp+8], -1

; 1254 : #endif
; 1255 : 
; 1256 : 		item.m_iData1 = x;

	mov	edx, DWORD PTR _x$[ebp]
	mov	DWORD PTR _item$221225[ebp+12], edx

; 1257 : 		item.m_iData2 = y;

	mov	eax, DWORD PTR _y$[ebp]
	mov	DWORD PTR _item$221225[ebp+16], eax

; 1258 : 
; 1259 : 		item.m_eFromPlayer = eFrom;

	mov	ecx, DWORD PTR _eFrom$[ebp]
	mov	DWORD PTR _item$221225[ebp+28], ecx

; 1260 : 		m_TradedItems.push_back(item);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 44					; 0000002cH
	mov	DWORD PTR $T228360[ebp], edx
	lea	edi, DWORD PTR $T228351[ebp+8]
	mov	ecx, 9
	lea	esi, DWORD PTR _item$221225[ebp]
	rep movsd
	lea	eax, DWORD PTR $T228351[ebp]
	push	eax
	mov	ecx, DWORD PTR $T228360[ebp]
	call	?Alloc@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::Alloc
	mov	DWORD PTR _uiNewIndex$228356[ebp], eax
	mov	ecx, DWORD PTR _uiNewIndex$228356[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T228360[ebp]
	call	?push_back_existing@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEXI@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::push_back_existing
$LN3@AddCityTra:

; 1261 : 	}
; 1262 : 	else
; 1263 : 	{
; 1264 : 		CvAssertMsg(false, "DEAL: Trying to add an invalid City to a deal");
; 1265 : 	}
; 1266 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?AddCityTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z ENDP	; CvDeal::AddCityTrade
_TEXT	ENDS
PUBLIC	?AddUnitTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z	; CvDeal::AddUnitTrade
; Function compile flags: /Odtp
;	COMDAT ?AddUnitTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_this$ = -140						; size = 4
$T228488 = -136						; size = 4
_uiNewIndex$228486 = -84				; size = 4
$T228479 = -80						; size = 44
_item$221233 = -36					; size = 36
_eFrom$ = 8						; size = 4
_iUnitID$ = 12						; size = 4
?AddUnitTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z PROC	; CvDeal::AddUnitTrade, COMDAT
; _this$ = ecx

; 1270 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1271 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Adding deal item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1272 : 
; 1273 : 	if(IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_UNITS, iUnitID))

	push	0
	push	1
	push	0
	push	-1
	push	-1
	mov	eax, DWORD PTR _iUnitID$[ebp]
	push	eax
	push	5
	mov	ecx, DWORD PTR _eFrom$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOtherPlayer@CvDeal@@QBE?AW4PlayerTypes@@W42@@Z ; CvDeal::GetOtherPlayer
	push	eax
	mov	edx, DWORD PTR _eFrom$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@AddUnitTra

; 1274 : 	{
; 1275 : 		CvTradedItem item;

	lea	ecx, DWORD PTR _item$221233[ebp]
	call	??0CvTradedItem@@QAE@XZ			; CvTradedItem::CvTradedItem

; 1276 : 		item.m_eItemType = TRADE_ITEM_UNITS;

	mov	DWORD PTR _item$221233[ebp], 5

; 1277 : 		item.m_iDuration = 0;

	mov	DWORD PTR _item$221233[ebp+4], 0

; 1278 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1279 : 		item.m_iTurnsRemaining = -1;
; 1280 : #else
; 1281 : 		item.m_iFinalTurn = -1;

	mov	DWORD PTR _item$221233[ebp+8], -1

; 1282 : #endif
; 1283 : 		item.m_iData1 = iUnitID;

	mov	ecx, DWORD PTR _iUnitID$[ebp]
	mov	DWORD PTR _item$221233[ebp+12], ecx

; 1284 : 		item.m_eFromPlayer = eFrom;

	mov	edx, DWORD PTR _eFrom$[ebp]
	mov	DWORD PTR _item$221233[ebp+28], edx

; 1285 : 		m_TradedItems.push_back(item);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	mov	DWORD PTR $T228488[ebp], eax
	lea	edi, DWORD PTR $T228479[ebp+8]
	mov	ecx, 9
	lea	esi, DWORD PTR _item$221233[ebp]
	rep movsd
	lea	ecx, DWORD PTR $T228479[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T228488[ebp]
	call	?Alloc@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::Alloc
	mov	DWORD PTR _uiNewIndex$228486[ebp], eax
	mov	edx, DWORD PTR _uiNewIndex$228486[ebp]
	push	edx
	mov	ecx, DWORD PTR $T228488[ebp]
	call	?push_back_existing@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEXI@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::push_back_existing
$LN3@AddUnitTra:

; 1286 : 	}
; 1287 : 	else
; 1288 : 	{
; 1289 : 		CvAssertMsg(false, "DEAL: Trying to add an invalid Unit to a deal");
; 1290 : 	}
; 1291 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?AddUnitTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z ENDP	; CvDeal::AddUnitTrade
_TEXT	ENDS
PUBLIC	?AddAllowEmbassy@CvDeal@@QAEXW4PlayerTypes@@@Z	; CvDeal::AddAllowEmbassy
; Function compile flags: /Odtp
;	COMDAT ?AddAllowEmbassy@CvDeal@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -140						; size = 4
$T228616 = -136						; size = 4
_uiNewIndex$228611 = -84				; size = 4
$T228607 = -80						; size = 44
_item$221240 = -36					; size = 36
_eFrom$ = 8						; size = 4
?AddAllowEmbassy@CvDeal@@QAEXW4PlayerTypes@@@Z PROC	; CvDeal::AddAllowEmbassy, COMDAT
; _this$ = ecx

; 1295 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1296 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Adding deal item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1297 : 
; 1298 : 	if(IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_ALLOW_EMBASSY))

	push	0
	push	1
	push	0
	push	-1
	push	-1
	push	-1
	push	17					; 00000011H
	mov	eax, DWORD PTR _eFrom$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOtherPlayer@CvDeal@@QBE?AW4PlayerTypes@@W42@@Z ; CvDeal::GetOtherPlayer
	push	eax
	mov	ecx, DWORD PTR _eFrom$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@AddAllowEm

; 1299 : 	{
; 1300 : 		CvTradedItem item;

	lea	ecx, DWORD PTR _item$221240[ebp]
	call	??0CvTradedItem@@QAE@XZ			; CvTradedItem::CvTradedItem

; 1301 : 		item.m_eItemType = TRADE_ITEM_ALLOW_EMBASSY;

	mov	DWORD PTR _item$221240[ebp], 17		; 00000011H

; 1302 : 		item.m_eFromPlayer = eFrom;

	mov	eax, DWORD PTR _eFrom$[ebp]
	mov	DWORD PTR _item$221240[ebp+28], eax

; 1303 : 		m_TradedItems.push_back(item);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	mov	DWORD PTR $T228616[ebp], ecx
	lea	edi, DWORD PTR $T228607[ebp+8]
	mov	ecx, 9
	lea	esi, DWORD PTR _item$221240[ebp]
	rep movsd
	lea	edx, DWORD PTR $T228607[ebp]
	push	edx
	mov	ecx, DWORD PTR $T228616[ebp]
	call	?Alloc@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::Alloc
	mov	DWORD PTR _uiNewIndex$228611[ebp], eax
	mov	eax, DWORD PTR _uiNewIndex$228611[ebp]
	push	eax
	mov	ecx, DWORD PTR $T228616[ebp]
	call	?push_back_existing@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEXI@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::push_back_existing
$LN3@AddAllowEm:

; 1304 : 	}
; 1305 : 	else
; 1306 : 	{
; 1307 : 		CvAssertMsg(false, "DEAL: Trying to add an invalid Allow Embassy item to a deal");
; 1308 : 	}
; 1309 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?AddAllowEmbassy@CvDeal@@QAEXW4PlayerTypes@@@Z ENDP	; CvDeal::AddAllowEmbassy
_TEXT	ENDS
PUBLIC	?AddOpenBorders@CvDeal@@QAEXW4PlayerTypes@@H@Z	; CvDeal::AddOpenBorders
; Function compile flags: /Odtp
;	COMDAT ?AddOpenBorders@CvDeal@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_this$ = -140						; size = 4
$T228744 = -136						; size = 4
_uiNewIndex$228739 = -84				; size = 4
$T228735 = -80						; size = 44
_item$221248 = -36					; size = 36
_eFrom$ = 8						; size = 4
_iDuration$ = 12					; size = 4
?AddOpenBorders@CvDeal@@QAEXW4PlayerTypes@@H@Z PROC	; CvDeal::AddOpenBorders, COMDAT
; _this$ = ecx

; 1313 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1314 : 	CvAssertMsg(iDuration >= 0, "DEAL: Trying to add a negative duration to a TradeItem.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1315 : 	CvAssertMsg(iDuration < GC.getGame().getEstimateEndTurn() * 2, "DEAL: Trade item has a crazy long duration (probably invalid).  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1316 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Adding deal item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1317 : 
; 1318 : 	if(IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_OPEN_BORDERS, iDuration))

	push	0
	push	1
	push	0
	push	-1
	push	-1
	mov	eax, DWORD PTR _iDuration$[ebp]
	push	eax
	push	6
	mov	ecx, DWORD PTR _eFrom$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOtherPlayer@CvDeal@@QBE?AW4PlayerTypes@@W42@@Z ; CvDeal::GetOtherPlayer
	push	eax
	mov	edx, DWORD PTR _eFrom$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@AddOpenBor

; 1319 : 	{
; 1320 : 		CvTradedItem item;

	lea	ecx, DWORD PTR _item$221248[ebp]
	call	??0CvTradedItem@@QAE@XZ			; CvTradedItem::CvTradedItem

; 1321 : 		item.m_eItemType = TRADE_ITEM_OPEN_BORDERS;

	mov	DWORD PTR _item$221248[ebp], 6

; 1322 : 		item.m_iDuration = iDuration;

	mov	ecx, DWORD PTR _iDuration$[ebp]
	mov	DWORD PTR _item$221248[ebp+4], ecx

; 1323 : 		//item.m_iFinalTurn = iDuration + GC.getGame().getGameTurn();
; 1324 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1325 : 		item.m_iTurnsRemaining = -1;
; 1326 : #else
; 1327 : 		item.m_iFinalTurn = -1;

	mov	DWORD PTR _item$221248[ebp+8], -1

; 1328 : #endif
; 1329 : 		item.m_eFromPlayer = eFrom;

	mov	edx, DWORD PTR _eFrom$[ebp]
	mov	DWORD PTR _item$221248[ebp+28], edx

; 1330 : 		m_TradedItems.push_back(item);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	mov	DWORD PTR $T228744[ebp], eax
	lea	edi, DWORD PTR $T228735[ebp+8]
	mov	ecx, 9
	lea	esi, DWORD PTR _item$221248[ebp]
	rep movsd
	lea	ecx, DWORD PTR $T228735[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T228744[ebp]
	call	?Alloc@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::Alloc
	mov	DWORD PTR _uiNewIndex$228739[ebp], eax
	mov	edx, DWORD PTR _uiNewIndex$228739[ebp]
	push	edx
	mov	ecx, DWORD PTR $T228744[ebp]
	call	?push_back_existing@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEXI@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::push_back_existing
$LN3@AddOpenBor:

; 1331 : 	}
; 1332 : 	else
; 1333 : 	{
; 1334 : 		CvAssertMsg(false, "DEAL: Trying to add an invalid Open Borders item to a deal");
; 1335 : 	}
; 1336 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?AddOpenBorders@CvDeal@@QAEXW4PlayerTypes@@H@Z ENDP	; CvDeal::AddOpenBorders
_TEXT	ENDS
PUBLIC	?AddDefensivePact@CvDeal@@QAEXW4PlayerTypes@@H@Z ; CvDeal::AddDefensivePact
; Function compile flags: /Odtp
;	COMDAT ?AddDefensivePact@CvDeal@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_this$ = -140						; size = 4
$T228872 = -136						; size = 4
_uiNewIndex$228867 = -84				; size = 4
$T228863 = -80						; size = 44
_item$221256 = -36					; size = 36
_eFrom$ = 8						; size = 4
_iDuration$ = 12					; size = 4
?AddDefensivePact@CvDeal@@QAEXW4PlayerTypes@@H@Z PROC	; CvDeal::AddDefensivePact, COMDAT
; _this$ = ecx

; 1340 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1341 : 	CvAssertMsg(iDuration >= 0, "DEAL: Trying to add a negative duration to a TradeItem.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1342 : 	CvAssertMsg(iDuration < GC.getGame().getEstimateEndTurn() * 2, "DEAL: Trade item has a crazy long duration (probably invalid).  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1343 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Adding deal item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1344 : 
; 1345 : 	if(IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_DEFENSIVE_PACT, iDuration))

	push	0
	push	1
	push	0
	push	-1
	push	-1
	mov	eax, DWORD PTR _iDuration$[ebp]
	push	eax
	push	7
	mov	ecx, DWORD PTR _eFrom$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOtherPlayer@CvDeal@@QBE?AW4PlayerTypes@@W42@@Z ; CvDeal::GetOtherPlayer
	push	eax
	mov	edx, DWORD PTR _eFrom$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@AddDefensi

; 1346 : 	{
; 1347 : 		CvTradedItem item;

	lea	ecx, DWORD PTR _item$221256[ebp]
	call	??0CvTradedItem@@QAE@XZ			; CvTradedItem::CvTradedItem

; 1348 : 		item.m_eItemType = TRADE_ITEM_DEFENSIVE_PACT;

	mov	DWORD PTR _item$221256[ebp], 7

; 1349 : #ifdef NEW_DEFENSIVE_PACT // EAP: From Immos, but we want the turn amount to always be 10.
; 1350 : 		item.m_iDuration = 10;

	mov	DWORD PTR _item$221256[ebp+4], 10	; 0000000aH

; 1351 : #else
; 1352 : 		item.m_iDuration = iDuration;
; 1353 : #endif
; 1354 : 		//item.m_iFinalTurn = iDuration + GC.getGame().getGameTurn();
; 1355 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1356 : 		item.m_iTurnsRemaining = -1;
; 1357 : #else
; 1358 : 		item.m_iFinalTurn = -1;

	mov	DWORD PTR _item$221256[ebp+8], -1

; 1359 : #endif
; 1360 : 		item.m_eFromPlayer = eFrom;

	mov	ecx, DWORD PTR _eFrom$[ebp]
	mov	DWORD PTR _item$221256[ebp+28], ecx

; 1361 : 		m_TradedItems.push_back(item);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 44					; 0000002cH
	mov	DWORD PTR $T228872[ebp], edx
	lea	edi, DWORD PTR $T228863[ebp+8]
	mov	ecx, 9
	lea	esi, DWORD PTR _item$221256[ebp]
	rep movsd
	lea	eax, DWORD PTR $T228863[ebp]
	push	eax
	mov	ecx, DWORD PTR $T228872[ebp]
	call	?Alloc@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::Alloc
	mov	DWORD PTR _uiNewIndex$228867[ebp], eax
	mov	ecx, DWORD PTR _uiNewIndex$228867[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T228872[ebp]
	call	?push_back_existing@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEXI@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::push_back_existing
$LN3@AddDefensi:

; 1362 : 	}
; 1363 : 	else
; 1364 : 	{
; 1365 : 		CvAssertMsg(false, "DEAL: Trying to add an invalid Defensive Pact item to a deal");
; 1366 : 	}
; 1367 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?AddDefensivePact@CvDeal@@QAEXW4PlayerTypes@@H@Z ENDP	; CvDeal::AddDefensivePact
_TEXT	ENDS
PUBLIC	?AddResearchAgreement@CvDeal@@QAEXW4PlayerTypes@@H@Z ; CvDeal::AddResearchAgreement
; Function compile flags: /Odtp
;	COMDAT ?AddResearchAgreement@CvDeal@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_this$ = -140						; size = 4
$T229000 = -136						; size = 4
_uiNewIndex$228995 = -84				; size = 4
$T228991 = -80						; size = 44
_item$221264 = -36					; size = 36
_eFrom$ = 8						; size = 4
_iDuration$ = 12					; size = 4
?AddResearchAgreement@CvDeal@@QAEXW4PlayerTypes@@H@Z PROC ; CvDeal::AddResearchAgreement, COMDAT
; _this$ = ecx

; 1371 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1372 : 	CvAssertMsg(iDuration >= 0, "DEAL: Trying to add a negative duration to a TradeItem.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1373 : 	CvAssertMsg(iDuration < GC.getGame().getEstimateEndTurn() * 2, "DEAL: Trade item has a crazy long duration (probably invalid).  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1374 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Adding deal item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1375 : 
; 1376 : 	if(IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_RESEARCH_AGREEMENT, iDuration))

	push	0
	push	1
	push	0
	push	-1
	push	-1
	mov	eax, DWORD PTR _iDuration$[ebp]
	push	eax
	push	8
	mov	ecx, DWORD PTR _eFrom$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOtherPlayer@CvDeal@@QBE?AW4PlayerTypes@@W42@@Z ; CvDeal::GetOtherPlayer
	push	eax
	mov	edx, DWORD PTR _eFrom$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@AddResearc

; 1377 : 	{
; 1378 : 		CvTradedItem item;

	lea	ecx, DWORD PTR _item$221264[ebp]
	call	??0CvTradedItem@@QAE@XZ			; CvTradedItem::CvTradedItem

; 1379 : 		item.m_eItemType = TRADE_ITEM_RESEARCH_AGREEMENT;

	mov	DWORD PTR _item$221264[ebp], 8

; 1380 : 		item.m_iDuration = iDuration;

	mov	ecx, DWORD PTR _iDuration$[ebp]
	mov	DWORD PTR _item$221264[ebp+4], ecx

; 1381 : 		//item.m_iFinalTurn = iDuration + GC.getGame().getGameTurn();
; 1382 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1383 : 		item.m_iTurnsRemaining = -1;
; 1384 : #else
; 1385 : 		item.m_iFinalTurn = -1;

	mov	DWORD PTR _item$221264[ebp+8], -1

; 1386 : #endif
; 1387 : 		item.m_eFromPlayer = eFrom;

	mov	edx, DWORD PTR _eFrom$[ebp]
	mov	DWORD PTR _item$221264[ebp+28], edx

; 1388 : 		m_TradedItems.push_back(item);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	mov	DWORD PTR $T229000[ebp], eax
	lea	edi, DWORD PTR $T228991[ebp+8]
	mov	ecx, 9
	lea	esi, DWORD PTR _item$221264[ebp]
	rep movsd
	lea	ecx, DWORD PTR $T228991[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T229000[ebp]
	call	?Alloc@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::Alloc
	mov	DWORD PTR _uiNewIndex$228995[ebp], eax
	mov	edx, DWORD PTR _uiNewIndex$228995[ebp]
	push	edx
	mov	ecx, DWORD PTR $T229000[ebp]
	call	?push_back_existing@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEXI@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::push_back_existing
$LN3@AddResearc:

; 1389 : 	}
; 1390 : 	else
; 1391 : 	{
; 1392 : 		CvAssertMsg(false, "DEAL: Trying to add an invalid Research Agreement item to a deal");
; 1393 : 	}
; 1394 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?AddResearchAgreement@CvDeal@@QAEXW4PlayerTypes@@H@Z ENDP ; CvDeal::AddResearchAgreement
_TEXT	ENDS
PUBLIC	?AddTradeAgreement@CvDeal@@QAEXW4PlayerTypes@@H@Z ; CvDeal::AddTradeAgreement
; Function compile flags: /Odtp
;	COMDAT ?AddTradeAgreement@CvDeal@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_this$ = -140						; size = 4
$T229128 = -136						; size = 4
_uiNewIndex$229123 = -84				; size = 4
$T229119 = -80						; size = 44
_item$221272 = -36					; size = 36
_eFrom$ = 8						; size = 4
_iDuration$ = 12					; size = 4
?AddTradeAgreement@CvDeal@@QAEXW4PlayerTypes@@H@Z PROC	; CvDeal::AddTradeAgreement, COMDAT
; _this$ = ecx

; 1398 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1399 : 	CvAssertMsg(iDuration >= 0, "DEAL: Trying to add a negative duration to a TradeItem.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1400 : 	CvAssertMsg(iDuration < GC.getGame().getEstimateEndTurn() * 2, "DEAL: Trade item has a crazy long duration (probably invalid).  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1401 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Adding deal item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1402 : 
; 1403 : 	if(IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_TRADE_AGREEMENT, iDuration))

	push	0
	push	1
	push	0
	push	-1
	push	-1
	mov	eax, DWORD PTR _iDuration$[ebp]
	push	eax
	push	9
	mov	ecx, DWORD PTR _eFrom$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOtherPlayer@CvDeal@@QBE?AW4PlayerTypes@@W42@@Z ; CvDeal::GetOtherPlayer
	push	eax
	mov	edx, DWORD PTR _eFrom$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@AddTradeAg

; 1404 : 	{
; 1405 : 		CvTradedItem item;

	lea	ecx, DWORD PTR _item$221272[ebp]
	call	??0CvTradedItem@@QAE@XZ			; CvTradedItem::CvTradedItem

; 1406 : 		item.m_eItemType = TRADE_ITEM_TRADE_AGREEMENT;

	mov	DWORD PTR _item$221272[ebp], 9

; 1407 : 		item.m_iDuration = iDuration;

	mov	ecx, DWORD PTR _iDuration$[ebp]
	mov	DWORD PTR _item$221272[ebp+4], ecx

; 1408 : 		//item.m_iFinalTurn = iDuration + GC.getGame().getGameTurn();
; 1409 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1410 : 		item.m_iTurnsRemaining = -1;
; 1411 : #else
; 1412 : 		item.m_iFinalTurn = -1;

	mov	DWORD PTR _item$221272[ebp+8], -1

; 1413 : #endif
; 1414 : 		item.m_eFromPlayer = eFrom;

	mov	edx, DWORD PTR _eFrom$[ebp]
	mov	DWORD PTR _item$221272[ebp+28], edx

; 1415 : 		m_TradedItems.push_back(item);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	mov	DWORD PTR $T229128[ebp], eax
	lea	edi, DWORD PTR $T229119[ebp+8]
	mov	ecx, 9
	lea	esi, DWORD PTR _item$221272[ebp]
	rep movsd
	lea	ecx, DWORD PTR $T229119[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T229128[ebp]
	call	?Alloc@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::Alloc
	mov	DWORD PTR _uiNewIndex$229123[ebp], eax
	mov	edx, DWORD PTR _uiNewIndex$229123[ebp]
	push	edx
	mov	ecx, DWORD PTR $T229128[ebp]
	call	?push_back_existing@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEXI@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::push_back_existing
$LN3@AddTradeAg:

; 1416 : 	}
; 1417 : 	else
; 1418 : 	{
; 1419 : 		CvAssertMsg(false, "DEAL: Trying to add an invalid Trade Agreement item to a deal");
; 1420 : 	}
; 1421 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?AddTradeAgreement@CvDeal@@QAEXW4PlayerTypes@@H@Z ENDP	; CvDeal::AddTradeAgreement
_TEXT	ENDS
PUBLIC	?AddPermamentAlliance@CvDeal@@QAEXXZ		; CvDeal::AddPermamentAlliance
; Function compile flags: /Odtp
;	COMDAT ?AddPermamentAlliance@CvDeal@@QAEXXZ
_TEXT	SEGMENT
_this$ = -140						; size = 4
$T229256 = -136						; size = 4
_uiNewIndex$229251 = -84				; size = 4
$T229247 = -80						; size = 44
_item$221277 = -36					; size = 36
?AddPermamentAlliance@CvDeal@@QAEXXZ PROC		; CvDeal::AddPermamentAlliance, COMDAT
; _this$ = ecx

; 1425 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1426 : //	if (IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_PERMANENT_ALLIANCE, iDuration))
; 1427 : 	{
; 1428 : 		CvTradedItem item;

	lea	ecx, DWORD PTR _item$221277[ebp]
	call	??0CvTradedItem@@QAE@XZ			; CvTradedItem::CvTradedItem

; 1429 : 		item.m_eItemType = TRADE_ITEM_PERMANENT_ALLIANCE;

	mov	DWORD PTR _item$221277[ebp], 10		; 0000000aH

; 1430 : 		item.m_iDuration = 0;

	mov	DWORD PTR _item$221277[ebp+4], 0

; 1431 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1432 : 		item.m_iTurnsRemaining = -1;
; 1433 : #else
; 1434 : 		item.m_iFinalTurn = -1;

	mov	DWORD PTR _item$221277[ebp+8], -1

; 1435 : #endif
; 1436 : 		m_TradedItems.push_back(item);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	mov	DWORD PTR $T229256[ebp], eax
	lea	edi, DWORD PTR $T229247[ebp+8]
	mov	ecx, 9
	lea	esi, DWORD PTR _item$221277[ebp]
	rep movsd
	lea	ecx, DWORD PTR $T229247[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T229256[ebp]
	call	?Alloc@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::Alloc
	mov	DWORD PTR _uiNewIndex$229251[ebp], eax
	mov	edx, DWORD PTR _uiNewIndex$229251[ebp]
	push	edx
	mov	ecx, DWORD PTR $T229256[ebp]
	call	?push_back_existing@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEXI@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::push_back_existing

; 1437 : 	}
; 1438 : //	else
; 1439 : 	{
; 1440 : 		CvAssertMsg(false, "DEAL: Trying to add an invalid Permanent Alliance item to a deal");
; 1441 : 	}
; 1442 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?AddPermamentAlliance@CvDeal@@QAEXXZ ENDP		; CvDeal::AddPermamentAlliance
_TEXT	ENDS
PUBLIC	?AddSurrender@CvDeal@@QAEXW4PlayerTypes@@@Z	; CvDeal::AddSurrender
; Function compile flags: /Odtp
;	COMDAT ?AddSurrender@CvDeal@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -140						; size = 4
$T229384 = -136						; size = 4
_uiNewIndex$229380 = -84				; size = 4
$T229375 = -80						; size = 44
_item$221283 = -36					; size = 36
_eFrom$ = 8						; size = 4
?AddSurrender@CvDeal@@QAEXW4PlayerTypes@@@Z PROC	; CvDeal::AddSurrender, COMDAT
; _this$ = ecx

; 1446 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1447 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Adding deal item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1448 : 
; 1449 : 	if(IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_SURRENDER))

	push	0
	push	1
	push	0
	push	-1
	push	-1
	push	-1
	push	11					; 0000000bH
	mov	eax, DWORD PTR _eFrom$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOtherPlayer@CvDeal@@QBE?AW4PlayerTypes@@W42@@Z ; CvDeal::GetOtherPlayer
	push	eax
	mov	ecx, DWORD PTR _eFrom$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@AddSurrend

; 1450 : 	{
; 1451 : 		CvTradedItem item;

	lea	ecx, DWORD PTR _item$221283[ebp]
	call	??0CvTradedItem@@QAE@XZ			; CvTradedItem::CvTradedItem

; 1452 : 		item.m_eItemType = TRADE_ITEM_SURRENDER;

	mov	DWORD PTR _item$221283[ebp], 11		; 0000000bH

; 1453 : 		item.m_iDuration = 0;

	mov	DWORD PTR _item$221283[ebp+4], 0

; 1454 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1455 : 		item.m_iTurnsRemaining = -1;
; 1456 : #else
; 1457 : 		item.m_iFinalTurn = -1;

	mov	DWORD PTR _item$221283[ebp+8], -1

; 1458 : #endif
; 1459 : 		item.m_eFromPlayer = eFrom;

	mov	eax, DWORD PTR _eFrom$[ebp]
	mov	DWORD PTR _item$221283[ebp+28], eax

; 1460 : 		m_TradedItems.push_back(item);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	mov	DWORD PTR $T229384[ebp], ecx
	lea	edi, DWORD PTR $T229375[ebp+8]
	mov	ecx, 9
	lea	esi, DWORD PTR _item$221283[ebp]
	rep movsd
	lea	edx, DWORD PTR $T229375[ebp]
	push	edx
	mov	ecx, DWORD PTR $T229384[ebp]
	call	?Alloc@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::Alloc
	mov	DWORD PTR _uiNewIndex$229380[ebp], eax
	mov	eax, DWORD PTR _uiNewIndex$229380[ebp]
	push	eax
	mov	ecx, DWORD PTR $T229384[ebp]
	call	?push_back_existing@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEXI@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::push_back_existing
$LN3@AddSurrend:

; 1461 : 	}
; 1462 : 	else
; 1463 : 	{
; 1464 : 		CvAssertMsg(false, "DEAL: Trying to add an invalid Surrender item to a deal");
; 1465 : 	}
; 1466 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?AddSurrender@CvDeal@@QAEXW4PlayerTypes@@@Z ENDP	; CvDeal::AddSurrender
_TEXT	ENDS
PUBLIC	?AddTruce@CvDeal@@QAEXXZ			; CvDeal::AddTruce
; Function compile flags: /Odtp
;	COMDAT ?AddTruce@CvDeal@@QAEXXZ
_TEXT	SEGMENT
_this$ = -140						; size = 4
$T229512 = -136						; size = 4
_uiNewIndex$229510 = -84				; size = 4
$T229503 = -80						; size = 44
_item$221288 = -36					; size = 36
?AddTruce@CvDeal@@QAEXXZ PROC				; CvDeal::AddTruce, COMDAT
; _this$ = ecx

; 1470 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1471 : //	if (IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_TRUCE))
; 1472 : 	{
; 1473 : 		CvTradedItem item;

	lea	ecx, DWORD PTR _item$221288[ebp]
	call	??0CvTradedItem@@QAE@XZ			; CvTradedItem::CvTradedItem

; 1474 : 		item.m_eItemType = TRADE_ITEM_TRUCE;

	mov	DWORD PTR _item$221288[ebp], 12		; 0000000cH

; 1475 : 		item.m_iDuration = 0;

	mov	DWORD PTR _item$221288[ebp+4], 0

; 1476 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1477 : 		item.m_iTurnsRemaining = -1;
; 1478 : #else
; 1479 : 		item.m_iFinalTurn = -1;

	mov	DWORD PTR _item$221288[ebp+8], -1

; 1480 : #endif
; 1481 : 		m_TradedItems.push_back(item);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	mov	DWORD PTR $T229512[ebp], eax
	lea	edi, DWORD PTR $T229503[ebp+8]
	mov	ecx, 9
	lea	esi, DWORD PTR _item$221288[ebp]
	rep movsd
	lea	ecx, DWORD PTR $T229503[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T229512[ebp]
	call	?Alloc@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::Alloc
	mov	DWORD PTR _uiNewIndex$229510[ebp], eax
	mov	edx, DWORD PTR _uiNewIndex$229510[ebp]
	push	edx
	mov	ecx, DWORD PTR $T229512[ebp]
	call	?push_back_existing@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEXI@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::push_back_existing

; 1482 : 	}
; 1483 : //	else
; 1484 : 	{
; 1485 : 		CvAssertMsg(false, "DEAL: Trying to add an invalid Truce item to a deal");
; 1486 : 	}
; 1487 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?AddTruce@CvDeal@@QAEXXZ ENDP				; CvDeal::AddTruce
_TEXT	ENDS
PUBLIC	?AddPeaceTreaty@CvDeal@@QAEXW4PlayerTypes@@H@Z	; CvDeal::AddPeaceTreaty
; Function compile flags: /Odtp
;	COMDAT ?AddPeaceTreaty@CvDeal@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_this$ = -140						; size = 4
$T229640 = -136						; size = 4
_uiNewIndex$229635 = -84				; size = 4
$T229631 = -80						; size = 44
_item$221295 = -36					; size = 36
_eFrom$ = 8						; size = 4
_iDuration$ = 12					; size = 4
?AddPeaceTreaty@CvDeal@@QAEXW4PlayerTypes@@H@Z PROC	; CvDeal::AddPeaceTreaty, COMDAT
; _this$ = ecx

; 1491 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1492 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Adding deal item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1493 : 
; 1494 : 	if(IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_PEACE_TREATY))

	push	0
	push	1
	push	0
	push	-1
	push	-1
	push	-1
	push	13					; 0000000dH
	mov	eax, DWORD PTR _eFrom$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOtherPlayer@CvDeal@@QBE?AW4PlayerTypes@@W42@@Z ; CvDeal::GetOtherPlayer
	push	eax
	mov	ecx, DWORD PTR _eFrom$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@AddPeaceTr

; 1495 : 	{
; 1496 : 		CvTradedItem item;

	lea	ecx, DWORD PTR _item$221295[ebp]
	call	??0CvTradedItem@@QAE@XZ			; CvTradedItem::CvTradedItem

; 1497 : 		item.m_eItemType = TRADE_ITEM_PEACE_TREATY;

	mov	DWORD PTR _item$221295[ebp], 13		; 0000000dH

; 1498 : 		item.m_iDuration = iDuration;

	mov	eax, DWORD PTR _iDuration$[ebp]
	mov	DWORD PTR _item$221295[ebp+4], eax

; 1499 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1500 : 		item.m_iTurnsRemaining = -1;
; 1501 : #else
; 1502 : 		item.m_iFinalTurn = -1;

	mov	DWORD PTR _item$221295[ebp+8], -1

; 1503 : #endif
; 1504 : 		item.m_eFromPlayer = eFrom;

	mov	ecx, DWORD PTR _eFrom$[ebp]
	mov	DWORD PTR _item$221295[ebp+28], ecx

; 1505 : 		m_TradedItems.push_back(item);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 44					; 0000002cH
	mov	DWORD PTR $T229640[ebp], edx
	lea	edi, DWORD PTR $T229631[ebp+8]
	mov	ecx, 9
	lea	esi, DWORD PTR _item$221295[ebp]
	rep movsd
	lea	eax, DWORD PTR $T229631[ebp]
	push	eax
	mov	ecx, DWORD PTR $T229640[ebp]
	call	?Alloc@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::Alloc
	mov	DWORD PTR _uiNewIndex$229635[ebp], eax
	mov	ecx, DWORD PTR _uiNewIndex$229635[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T229640[ebp]
	call	?push_back_existing@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEXI@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::push_back_existing
$LN3@AddPeaceTr:

; 1506 : 	}
; 1507 : 	else
; 1508 : 	{
; 1509 : 		CvAssertMsg(false, "DEAL: Trying to add an invalid Peace Treaty item to a deal");
; 1510 : 	}
; 1511 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?AddPeaceTreaty@CvDeal@@QAEXW4PlayerTypes@@H@Z ENDP	; CvDeal::AddPeaceTreaty
_TEXT	ENDS
PUBLIC	?AddThirdPartyPeace@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z ; CvDeal::AddThirdPartyPeace
; Function compile flags: /Odtp
;	COMDAT ?AddThirdPartyPeace@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z
_TEXT	SEGMENT
_this$ = -140						; size = 4
$T229768 = -136						; size = 4
_uiNewIndex$229763 = -84				; size = 4
$T229759 = -80						; size = 44
_item$221304 = -36					; size = 36
_eFrom$ = 8						; size = 4
_eThirdPartyTeam$ = 12					; size = 4
_iDuration$ = 16					; size = 4
?AddThirdPartyPeace@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z PROC ; CvDeal::AddThirdPartyPeace, COMDAT
; _this$ = ecx

; 1515 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1516 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Adding deal item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1517 : 
; 1518 : 	if(IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_THIRD_PARTY_PEACE, eThirdPartyTeam))

	push	0
	push	1
	push	0
	push	-1
	push	-1
	mov	eax, DWORD PTR _eThirdPartyTeam$[ebp]
	push	eax
	push	14					; 0000000eH
	mov	ecx, DWORD PTR _eFrom$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOtherPlayer@CvDeal@@QBE?AW4PlayerTypes@@W42@@Z ; CvDeal::GetOtherPlayer
	push	eax
	mov	edx, DWORD PTR _eFrom$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@AddThirdPa

; 1519 : 	{
; 1520 : 		CvTradedItem item;

	lea	ecx, DWORD PTR _item$221304[ebp]
	call	??0CvTradedItem@@QAE@XZ			; CvTradedItem::CvTradedItem

; 1521 : 		item.m_eItemType = TRADE_ITEM_THIRD_PARTY_PEACE;

	mov	DWORD PTR _item$221304[ebp], 14		; 0000000eH

; 1522 : 		item.m_iDuration = iDuration;

	mov	ecx, DWORD PTR _iDuration$[ebp]
	mov	DWORD PTR _item$221304[ebp+4], ecx

; 1523 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1524 : 		item.m_iTurnsRemaining = -1;
; 1525 : #else
; 1526 : 		item.m_iFinalTurn = -1;

	mov	DWORD PTR _item$221304[ebp+8], -1

; 1527 : #endif
; 1528 : 		item.m_iData1 = eThirdPartyTeam;

	mov	edx, DWORD PTR _eThirdPartyTeam$[ebp]
	mov	DWORD PTR _item$221304[ebp+12], edx

; 1529 : 		item.m_eFromPlayer = eFrom;

	mov	eax, DWORD PTR _eFrom$[ebp]
	mov	DWORD PTR _item$221304[ebp+28], eax

; 1530 : 		m_TradedItems.push_back(item);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	mov	DWORD PTR $T229768[ebp], ecx
	lea	edi, DWORD PTR $T229759[ebp+8]
	mov	ecx, 9
	lea	esi, DWORD PTR _item$221304[ebp]
	rep movsd
	lea	edx, DWORD PTR $T229759[ebp]
	push	edx
	mov	ecx, DWORD PTR $T229768[ebp]
	call	?Alloc@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::Alloc
	mov	DWORD PTR _uiNewIndex$229763[ebp], eax
	mov	eax, DWORD PTR _uiNewIndex$229763[ebp]
	push	eax
	mov	ecx, DWORD PTR $T229768[ebp]
	call	?push_back_existing@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEXI@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::push_back_existing
$LN3@AddThirdPa:

; 1531 : 	}
; 1532 : 	else
; 1533 : 	{
; 1534 : 		CvAssertMsg(false, "DEAL: Trying to add an invalid Third Party Peace item to a deal");
; 1535 : 	}
; 1536 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?AddThirdPartyPeace@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z ENDP ; CvDeal::AddThirdPartyPeace
_TEXT	ENDS
PUBLIC	?AddThirdPartyWar@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z ; CvDeal::AddThirdPartyWar
; Function compile flags: /Odtp
;	COMDAT ?AddThirdPartyWar@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -140						; size = 4
$T229896 = -136						; size = 4
_uiNewIndex$229891 = -84				; size = 4
$T229887 = -80						; size = 44
_item$221312 = -36					; size = 36
_eFrom$ = 8						; size = 4
_eThirdPartyTeam$ = 12					; size = 4
?AddThirdPartyWar@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z PROC ; CvDeal::AddThirdPartyWar, COMDAT
; _this$ = ecx

; 1540 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1541 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Adding deal item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1542 : 
; 1543 : 	if(IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_THIRD_PARTY_WAR, eThirdPartyTeam))

	push	0
	push	1
	push	0
	push	-1
	push	-1
	mov	eax, DWORD PTR _eThirdPartyTeam$[ebp]
	push	eax
	push	15					; 0000000fH
	mov	ecx, DWORD PTR _eFrom$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOtherPlayer@CvDeal@@QBE?AW4PlayerTypes@@W42@@Z ; CvDeal::GetOtherPlayer
	push	eax
	mov	edx, DWORD PTR _eFrom$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@AddThirdPa@2

; 1544 : 	{
; 1545 : 		CvTradedItem item;

	lea	ecx, DWORD PTR _item$221312[ebp]
	call	??0CvTradedItem@@QAE@XZ			; CvTradedItem::CvTradedItem

; 1546 : 		item.m_eItemType = TRADE_ITEM_THIRD_PARTY_WAR;

	mov	DWORD PTR _item$221312[ebp], 15		; 0000000fH

; 1547 : 		item.m_iDuration = 0;

	mov	DWORD PTR _item$221312[ebp+4], 0

; 1548 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1549 : 		item.m_iTurnsRemaining = -1;
; 1550 : #else
; 1551 : 		item.m_iFinalTurn = -1;

	mov	DWORD PTR _item$221312[ebp+8], -1

; 1552 : #endif
; 1553 : 		item.m_iData1 = eThirdPartyTeam;

	mov	ecx, DWORD PTR _eThirdPartyTeam$[ebp]
	mov	DWORD PTR _item$221312[ebp+12], ecx

; 1554 : 		item.m_eFromPlayer = eFrom;

	mov	edx, DWORD PTR _eFrom$[ebp]
	mov	DWORD PTR _item$221312[ebp+28], edx

; 1555 : 		m_TradedItems.push_back(item);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	mov	DWORD PTR $T229896[ebp], eax
	lea	edi, DWORD PTR $T229887[ebp+8]
	mov	ecx, 9
	lea	esi, DWORD PTR _item$221312[ebp]
	rep movsd
	lea	ecx, DWORD PTR $T229887[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T229896[ebp]
	call	?Alloc@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::Alloc
	mov	DWORD PTR _uiNewIndex$229891[ebp], eax
	mov	edx, DWORD PTR _uiNewIndex$229891[ebp]
	push	edx
	mov	ecx, DWORD PTR $T229896[ebp]
	call	?push_back_existing@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEXI@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::push_back_existing
$LN3@AddThirdPa@2:

; 1556 : 	}
; 1557 : 	else
; 1558 : 	{
; 1559 : 		CvAssertMsg(false, "DEAL: Trying to add an invalid Third Party War item to a deal");
; 1560 : 	}
; 1561 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?AddThirdPartyWar@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z ENDP ; CvDeal::AddThirdPartyWar
_TEXT	ENDS
PUBLIC	?AddThirdPartyEmbargo@CvDeal@@QAEXW4PlayerTypes@@0H@Z ; CvDeal::AddThirdPartyEmbargo
; Function compile flags: /Odtp
;	COMDAT ?AddThirdPartyEmbargo@CvDeal@@QAEXW4PlayerTypes@@0H@Z
_TEXT	SEGMENT
_this$ = -140						; size = 4
$T230024 = -136						; size = 4
_uiNewIndex$230019 = -84				; size = 4
$T230015 = -80						; size = 44
_item$221321 = -36					; size = 36
_eFrom$ = 8						; size = 4
_eThirdParty$ = 12					; size = 4
_iDuration$ = 16					; size = 4
?AddThirdPartyEmbargo@CvDeal@@QAEXW4PlayerTypes@@0H@Z PROC ; CvDeal::AddThirdPartyEmbargo, COMDAT
; _this$ = ecx

; 1565 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1566 : 	CvAssertMsg(iDuration >= 0, "DEAL: Trying to add a negative duration to a TradeItem.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1567 : 	CvAssertMsg(iDuration < GC.getGame().getEstimateEndTurn() * 2, "DEAL: Trade item has a crazy long duration (probably invalid).  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1568 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Adding deal item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1569 : 
; 1570 : 	if(IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_THIRD_PARTY_EMBARGO, eThirdParty, iDuration))

	push	0
	push	1
	push	0
	push	-1
	mov	eax, DWORD PTR _iDuration$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eThirdParty$[ebp]
	push	ecx
	push	16					; 00000010H
	mov	edx, DWORD PTR _eFrom$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOtherPlayer@CvDeal@@QBE?AW4PlayerTypes@@W42@@Z ; CvDeal::GetOtherPlayer
	push	eax
	mov	eax, DWORD PTR _eFrom$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@AddThirdPa@3

; 1571 : 	{
; 1572 : 		CvTradedItem item;

	lea	ecx, DWORD PTR _item$221321[ebp]
	call	??0CvTradedItem@@QAE@XZ			; CvTradedItem::CvTradedItem

; 1573 : 		item.m_eItemType = TRADE_ITEM_THIRD_PARTY_EMBARGO;

	mov	DWORD PTR _item$221321[ebp], 16		; 00000010H

; 1574 : 		item.m_iDuration = iDuration;

	mov	edx, DWORD PTR _iDuration$[ebp]
	mov	DWORD PTR _item$221321[ebp+4], edx

; 1575 : 		//item.m_iFinalTurn = iDuration + GC.getGame().getGameTurn();
; 1576 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1577 : 		item.m_iTurnsRemaining = -1;
; 1578 : #else
; 1579 : 		item.m_iFinalTurn = -1;

	mov	DWORD PTR _item$221321[ebp+8], -1

; 1580 : #endif
; 1581 : 		item.m_iData1 = eThirdParty;

	mov	eax, DWORD PTR _eThirdParty$[ebp]
	mov	DWORD PTR _item$221321[ebp+12], eax

; 1582 : 		item.m_eFromPlayer = eFrom;

	mov	ecx, DWORD PTR _eFrom$[ebp]
	mov	DWORD PTR _item$221321[ebp+28], ecx

; 1583 : 		m_TradedItems.push_back(item);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 44					; 0000002cH
	mov	DWORD PTR $T230024[ebp], edx
	lea	edi, DWORD PTR $T230015[ebp+8]
	mov	ecx, 9
	lea	esi, DWORD PTR _item$221321[ebp]
	rep movsd
	lea	eax, DWORD PTR $T230015[ebp]
	push	eax
	mov	ecx, DWORD PTR $T230024[ebp]
	call	?Alloc@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::Alloc
	mov	DWORD PTR _uiNewIndex$230019[ebp], eax
	mov	ecx, DWORD PTR _uiNewIndex$230019[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T230024[ebp]
	call	?push_back_existing@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEXI@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::push_back_existing
$LN3@AddThirdPa@3:

; 1584 : 	}
; 1585 : 	else
; 1586 : 	{
; 1587 : 		CvAssertMsg(false, "DEAL: Trying to add an invalid Third Party Embargo item to a deal");
; 1588 : 	}
; 1589 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?AddThirdPartyEmbargo@CvDeal@@QAEXW4PlayerTypes@@0H@Z ENDP ; CvDeal::AddThirdPartyEmbargo
_TEXT	ENDS
PUBLIC	?ContainsItemType@CvDeal@@QAE_NW4TradeableItems@@W4PlayerTypes@@@Z ; CvDeal::ContainsItemType
PUBLIC	?AddDeclarationOfFriendship@CvDeal@@QAEXW4PlayerTypes@@@Z ; CvDeal::AddDeclarationOfFriendship
; Function compile flags: /Odtp
;	COMDAT ?AddDeclarationOfFriendship@CvDeal@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -140						; size = 4
$T230152 = -136						; size = 4
_uiNewIndex$230147 = -84				; size = 4
$T230143 = -80						; size = 44
_item$221329 = -36					; size = 36
_eFrom$ = 8						; size = 4
?AddDeclarationOfFriendship@CvDeal@@QAEXW4PlayerTypes@@@Z PROC ; CvDeal::AddDeclarationOfFriendship, COMDAT
; _this$ = ecx

; 1593 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1594 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Adding deal item for a player that's not actually in this deal!");
; 1595 : 
; 1596 : 	if(IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_DECLARATION_OF_FRIENDSHIP))

	push	0
	push	1
	push	0
	push	-1
	push	-1
	push	-1
	push	18					; 00000012H
	mov	eax, DWORD PTR _eFrom$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOtherPlayer@CvDeal@@QBE?AW4PlayerTypes@@W42@@Z ; CvDeal::GetOtherPlayer
	push	eax
	mov	ecx, DWORD PTR _eFrom$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN4@AddDeclara

; 1597 : 	{
; 1598 : 		if (!ContainsItemType(TRADE_ITEM_DECLARATION_OF_FRIENDSHIP, eFrom))

	mov	eax, DWORD PTR _eFrom$[ebp]
	push	eax
	push	18					; 00000012H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ContainsItemType@CvDeal@@QAE_NW4TradeableItems@@W4PlayerTypes@@@Z ; CvDeal::ContainsItemType
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN4@AddDeclara

; 1599 : 		{
; 1600 : 			CvTradedItem item;

	lea	ecx, DWORD PTR _item$221329[ebp]
	call	??0CvTradedItem@@QAE@XZ			; CvTradedItem::CvTradedItem

; 1601 : 			item.m_eItemType = TRADE_ITEM_DECLARATION_OF_FRIENDSHIP;

	mov	DWORD PTR _item$221329[ebp], 18		; 00000012H

; 1602 : 			item.m_eFromPlayer = eFrom;

	mov	edx, DWORD PTR _eFrom$[ebp]
	mov	DWORD PTR _item$221329[ebp+28], edx

; 1603 : 			m_TradedItems.push_back(item);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	mov	DWORD PTR $T230152[ebp], eax
	lea	edi, DWORD PTR $T230143[ebp+8]
	mov	ecx, 9
	lea	esi, DWORD PTR _item$221329[ebp]
	rep movsd
	lea	ecx, DWORD PTR $T230143[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T230152[ebp]
	call	?Alloc@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::Alloc
	mov	DWORD PTR _uiNewIndex$230147[ebp], eax
	mov	edx, DWORD PTR _uiNewIndex$230147[ebp]
	push	edx
	mov	ecx, DWORD PTR $T230152[ebp]
	call	?push_back_existing@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEXI@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::push_back_existing
$LN4@AddDeclara:

; 1604 : 		}
; 1605 : 	}
; 1606 : 	else
; 1607 : 	{
; 1608 : 		CvAssertMsg(false, "DEAL: Trying to add an invalid Declaration of Friendship item to a deal");
; 1609 : 	}
; 1610 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?AddDeclarationOfFriendship@CvDeal@@QAEXW4PlayerTypes@@@Z ENDP ; CvDeal::AddDeclarationOfFriendship
_TEXT	ENDS
PUBLIC	?AddVoteCommitment@CvDeal@@QAEXW4PlayerTypes@@HHH_N@Z ; CvDeal::AddVoteCommitment
; Function compile flags: /Odtp
;	COMDAT ?AddVoteCommitment@CvDeal@@QAEXW4PlayerTypes@@HHH_N@Z
_TEXT	SEGMENT
_this$ = -140						; size = 4
$T230280 = -136						; size = 4
_uiNewIndex$230275 = -84				; size = 4
$T230271 = -80						; size = 44
_item$221340 = -36					; size = 36
_eFrom$ = 8						; size = 4
_iResolutionID$ = 12					; size = 4
_iVoteChoice$ = 16					; size = 4
_iNumVotes$ = 20					; size = 4
_bRepeal$ = 24						; size = 1
?AddVoteCommitment@CvDeal@@QAEXW4PlayerTypes@@HHH_N@Z PROC ; CvDeal::AddVoteCommitment, COMDAT
; _this$ = ecx

; 1614 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1615 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Adding deal item for a player that's not actually in this deal!");
; 1616 : 
; 1617 : 	if(IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_VOTE_COMMITMENT, iResolutionID, iVoteChoice, iNumVotes, bRepeal))

	push	0
	push	1
	movzx	eax, BYTE PTR _bRepeal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iNumVotes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iVoteChoice$[ebp]
	push	edx
	mov	eax, DWORD PTR _iResolutionID$[ebp]
	push	eax
	push	19					; 00000013H
	mov	ecx, DWORD PTR _eFrom$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOtherPlayer@CvDeal@@QBE?AW4PlayerTypes@@W42@@Z ; CvDeal::GetOtherPlayer
	push	eax
	mov	edx, DWORD PTR _eFrom$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@AddVoteCom

; 1618 : 	{
; 1619 : 		CvTradedItem item;

	lea	ecx, DWORD PTR _item$221340[ebp]
	call	??0CvTradedItem@@QAE@XZ			; CvTradedItem::CvTradedItem

; 1620 : 		item.m_eItemType = TRADE_ITEM_VOTE_COMMITMENT;

	mov	DWORD PTR _item$221340[ebp], 19		; 00000013H

; 1621 : 		item.m_eFromPlayer = eFrom;

	mov	ecx, DWORD PTR _eFrom$[ebp]
	mov	DWORD PTR _item$221340[ebp+28], ecx

; 1622 : 		item.m_iData1 = iResolutionID;

	mov	edx, DWORD PTR _iResolutionID$[ebp]
	mov	DWORD PTR _item$221340[ebp+12], edx

; 1623 : 		item.m_iData2 = iVoteChoice;

	mov	eax, DWORD PTR _iVoteChoice$[ebp]
	mov	DWORD PTR _item$221340[ebp+16], eax

; 1624 : 		item.m_iData3 = iNumVotes;

	mov	ecx, DWORD PTR _iNumVotes$[ebp]
	mov	DWORD PTR _item$221340[ebp+20], ecx

; 1625 : 		item.m_bFlag1 = bRepeal;

	mov	dl, BYTE PTR _bRepeal$[ebp]
	mov	BYTE PTR _item$221340[ebp+24], dl

; 1626 : 		m_TradedItems.push_back(item);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	mov	DWORD PTR $T230280[ebp], eax
	lea	edi, DWORD PTR $T230271[ebp+8]
	mov	ecx, 9
	lea	esi, DWORD PTR _item$221340[ebp]
	rep movsd
	lea	ecx, DWORD PTR $T230271[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T230280[ebp]
	call	?Alloc@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::Alloc
	mov	DWORD PTR _uiNewIndex$230275[ebp], eax
	mov	edx, DWORD PTR _uiNewIndex$230275[ebp]
	push	edx
	mov	ecx, DWORD PTR $T230280[ebp]
	call	?push_back_existing@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEXI@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::push_back_existing
$LN3@AddVoteCom:

; 1627 : 	}
; 1628 : 	else
; 1629 : 	{
; 1630 : 		CvAssertMsg(false, "DEAL: Trying to add an invalid Vote Commitment item to a deal");
; 1631 : 	}
; 1632 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?AddVoteCommitment@CvDeal@@QAEXW4PlayerTypes@@HHH_N@Z ENDP ; CvDeal::AddVoteCommitment
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
xdata$x	SEGMENT
__unwindtable$?GetGoldTrade@CvDeal@@QAEHW4PlayerTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetGoldTrade@CvDeal@@QAEHW4PlayerTypes@@@Z$0
__ehfuncinfo$?GetGoldTrade@CvDeal@@QAEHW4PlayerTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetGoldTrade@CvDeal@@QAEHW4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetGoldTrade@CvDeal@@QAEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
tv142 = -84						; size = 4
_this$ = -80						; size = 4
$T230454 = -76						; size = 4
$T230422 = -72						; size = 4
$T230390 = -68						; size = 4
$T230367 = -64						; size = 4
$T230351 = -60						; size = 4
$T230347 = -56						; size = 4
$T230338 = -52						; size = 4
$T230287 = -48						; size = 4
$T230286 = -44						; size = 4
$T230285 = -40						; size = 8
$T230284 = -29						; size = 1
$T230283 = -28						; size = 8
_it$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_eFrom$ = 8						; size = 4
?GetGoldTrade@CvDeal@@QAEHW4PlayerTypes@@@Z PROC	; CvDeal::GetGoldTrade, COMDAT
; _this$ = ecx

; 1635 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetGoldTrade@CvDeal@@QAEHW4PlayerTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1636 : 	TradedItemList::iterator it;

	mov	DWORD PTR _it$[ebp], 0
	mov	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1637 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	eax, DWORD PTR $T230283[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv142[ebp], eax
	mov	ecx, DWORD PTR tv142[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _it$[ebp], edx
	mov	DWORD PTR _it$[ebp+4], eax
	jmp	SHORT $LN4@GetGoldTra
$LN3@GetGoldTra:
	cmp	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	jne	SHORT $LN29@GetGoldTra
	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _it$[ebp+4], edx
	jmp	SHORT $LN4@GetGoldTra
$LN29@GetGoldTra:
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T230338[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T230338[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T230347[ebp], ecx
	mov	eax, DWORD PTR $T230347[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T230351[ebp], ecx
	mov	edx, DWORD PTR $T230351[ebp]
	mov	DWORD PTR _it$[ebp+4], edx
$LN4@GetGoldTra:
	lea	eax, DWORD PTR $T230285[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T230367[ebp], eax
	mov	ecx, DWORD PTR $T230367[ebp]
	mov	edx, DWORD PTR _it$[ebp+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setne	al
	mov	BYTE PTR $T230284[ebp], al
	movzx	ecx, BYTE PTR $T230284[ebp]
	test	ecx, ecx
	je	SHORT $LN2@GetGoldTra

; 1638 : 	{
; 1639 : 		if(it->m_eItemType == TRADE_ITEM_GOLD && it->m_eFromPlayer == eFrom)

	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T230390[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T230390[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+eax+8], 0
	jne	SHORT $LN1@GetGoldTra
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T230422[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T230422[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+ecx+36]
	cmp	ecx, DWORD PTR _eFrom$[ebp]
	jne	SHORT $LN1@GetGoldTra

; 1640 : 		{
; 1641 : 			return it->m_iData1;

	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T230454[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T230454[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+eax+20]
	mov	DWORD PTR $T230286[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T230286[ebp]
	jmp	SHORT $LN5@GetGoldTra
$LN1@GetGoldTra:

; 1642 : 		}
; 1643 : 	}

	jmp	$LN3@GetGoldTra
$LN2@GetGoldTra:

; 1644 : 	return 0;

	mov	DWORD PTR $T230287[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T230287[ebp]
$LN5@GetGoldTra:

; 1645 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetGoldTrade@CvDeal@@QAEHW4PlayerTypes@@@Z$0:
	lea	ecx, DWORD PTR _it$[ebp]
	jmp	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
__ehhandler$?GetGoldTrade@CvDeal@@QAEHW4PlayerTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetGoldTrade@CvDeal@@QAEHW4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetGoldTrade@CvDeal@@QAEHW4PlayerTypes@@@Z ENDP	; CvDeal::GetGoldTrade
PUBLIC	?ChangeGoldTrade@CvDeal@@QAE_NW4PlayerTypes@@H@Z ; CvDeal::ChangeGoldTrade
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
xdata$x	SEGMENT
__unwindtable$?ChangeGoldTrade@CvDeal@@QAE_NW4PlayerTypes@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ChangeGoldTrade@CvDeal@@QAE_NW4PlayerTypes@@H@Z$0
__ehfuncinfo$?ChangeGoldTrade@CvDeal@@QAE_NW4PlayerTypes@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ChangeGoldTrade@CvDeal@@QAE_NW4PlayerTypes@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?ChangeGoldTrade@CvDeal@@QAE_NW4PlayerTypes@@H@Z
_TEXT	SEGMENT
tv167 = -96						; size = 4
_this$ = -92						; size = 4
$T230807 = -88						; size = 4
$T230758 = -84						; size = 4
$T230726 = -80						; size = 4
$T230694 = -76						; size = 4
$T230662 = -72						; size = 4
$T230630 = -68						; size = 4
$T230607 = -64						; size = 4
$T230591 = -60						; size = 4
$T230587 = -56						; size = 4
$T230578 = -52						; size = 4
$T230527 = -46						; size = 1
$T230526 = -45						; size = 1
$T230525 = -44						; size = 8
$T230524 = -33						; size = 1
$T230523 = -32						; size = 8
_iOldValue$ = -24					; size = 4
_it$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_eFrom$ = 8						; size = 4
_iNewAmount$ = 12					; size = 4
?ChangeGoldTrade@CvDeal@@QAE_NW4PlayerTypes@@H@Z PROC	; CvDeal::ChangeGoldTrade, COMDAT
; _this$ = ecx

; 1648 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ChangeGoldTrade@CvDeal@@QAE_NW4PlayerTypes@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1649 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Changing deal item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1650 : 
; 1651 : 	int iOldValue;
; 1652 : 
; 1653 : 	TradedItemList::iterator it;

	mov	DWORD PTR _it$[ebp], 0
	mov	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1654 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	eax, DWORD PTR $T230523[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv167[ebp], eax
	mov	ecx, DWORD PTR tv167[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _it$[ebp], edx
	mov	DWORD PTR _it$[ebp+4], eax
	jmp	SHORT $LN6@ChangeGold
$LN5@ChangeGold:
	cmp	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	jne	SHORT $LN31@ChangeGold
	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _it$[ebp+4], edx
	jmp	SHORT $LN6@ChangeGold
$LN31@ChangeGold:
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T230578[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T230578[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T230587[ebp], ecx
	mov	eax, DWORD PTR $T230587[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T230591[ebp], ecx
	mov	edx, DWORD PTR $T230591[ebp]
	mov	DWORD PTR _it$[ebp+4], edx
$LN6@ChangeGold:
	lea	eax, DWORD PTR $T230525[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T230607[ebp], eax
	mov	ecx, DWORD PTR $T230607[ebp]
	mov	edx, DWORD PTR _it$[ebp+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setne	al
	mov	BYTE PTR $T230524[ebp], al
	movzx	ecx, BYTE PTR $T230524[ebp]
	test	ecx, ecx
	je	$LN4@ChangeGold

; 1655 : 	{
; 1656 : 		if(it->m_eItemType == TRADE_ITEM_GOLD && it->m_eFromPlayer == eFrom)

	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T230630[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T230630[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+eax+8], 0
	jne	$LN3@ChangeGold
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T230662[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T230662[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+ecx+36]
	cmp	ecx, DWORD PTR _eFrom$[ebp]
	jne	$LN3@ChangeGold

; 1657 : 		{
; 1658 : 			// Reduce Gold value to 0 first, because otherwise IsPossibleToTradeItem will think we're trying to spend more than we have
; 1659 : 			iOldValue = it->m_iData1;

	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T230694[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T230694[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+eax+20]
	mov	DWORD PTR _iOldValue$[ebp], eax

; 1660 : 			it->m_iData1 = 0;

	mov	ecx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T230726[ebp], ecx
	mov	edx, DWORD PTR _it$[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T230726[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+edx+20], 0

; 1661 : 
; 1662 : 			if(IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_GOLD, iNewAmount))

	push	0
	push	1
	push	0
	push	-1
	push	-1
	mov	edx, DWORD PTR _iNewAmount$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _eFrom$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOtherPlayer@CvDeal@@QBE?AW4PlayerTypes@@W42@@Z ; CvDeal::GetOtherPlayer
	push	eax
	mov	ecx, DWORD PTR _eFrom$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@ChangeGold

; 1663 : 			{
; 1664 : 				it->m_iData1 = iNewAmount;

	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T230758[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T230758[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _iNewAmount$[ebp]
	mov	DWORD PTR [eax+ecx+20], edx

; 1665 : 				return true;

	mov	BYTE PTR $T230526[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	al, BYTE PTR $T230526[ebp]
	jmp	SHORT $LN7@ChangeGold

; 1666 : 			}
; 1667 : 			// If we can't do this then restore the previous Gold quantity
; 1668 : 			else

	jmp	SHORT $LN3@ChangeGold
$LN2@ChangeGold:

; 1669 : 			{
; 1670 : 				it->m_iData1 = iOldValue;

	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T230807[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T230807[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _iOldValue$[ebp]
	mov	DWORD PTR [eax+ecx+20], edx
$LN3@ChangeGold:

; 1671 : 			}
; 1672 : 		}
; 1673 : 	}

	jmp	$LN5@ChangeGold
$LN4@ChangeGold:

; 1674 : 	return false;

	mov	BYTE PTR $T230527[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	al, BYTE PTR $T230527[ebp]
$LN7@ChangeGold:

; 1675 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ChangeGoldTrade@CvDeal@@QAE_NW4PlayerTypes@@H@Z$0:
	lea	ecx, DWORD PTR _it$[ebp]
	jmp	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
__ehhandler$?ChangeGoldTrade@CvDeal@@QAE_NW4PlayerTypes@@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-88]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ChangeGoldTrade@CvDeal@@QAE_NW4PlayerTypes@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ChangeGoldTrade@CvDeal@@QAE_NW4PlayerTypes@@H@Z ENDP	; CvDeal::ChangeGoldTrade
PUBLIC	?GetGoldPerTurnTrade@CvDeal@@QAEHW4PlayerTypes@@@Z ; CvDeal::GetGoldPerTurnTrade
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
xdata$x	SEGMENT
__unwindtable$?GetGoldPerTurnTrade@CvDeal@@QAEHW4PlayerTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetGoldPerTurnTrade@CvDeal@@QAEHW4PlayerTypes@@@Z$0
__ehfuncinfo$?GetGoldPerTurnTrade@CvDeal@@QAEHW4PlayerTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetGoldPerTurnTrade@CvDeal@@QAEHW4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetGoldPerTurnTrade@CvDeal@@QAEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
tv142 = -84						; size = 4
_this$ = -80						; size = 4
$T231030 = -76						; size = 4
$T230998 = -72						; size = 4
$T230966 = -68						; size = 4
$T230943 = -64						; size = 4
$T230927 = -60						; size = 4
$T230923 = -56						; size = 4
$T230914 = -52						; size = 4
$T230863 = -48						; size = 4
$T230862 = -44						; size = 4
$T230861 = -40						; size = 8
$T230860 = -29						; size = 1
$T230859 = -28						; size = 8
_it$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_eFrom$ = 8						; size = 4
?GetGoldPerTurnTrade@CvDeal@@QAEHW4PlayerTypes@@@Z PROC	; CvDeal::GetGoldPerTurnTrade, COMDAT
; _this$ = ecx

; 1678 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetGoldPerTurnTrade@CvDeal@@QAEHW4PlayerTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1679 : 	TradedItemList::iterator it;

	mov	DWORD PTR _it$[ebp], 0
	mov	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1680 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	eax, DWORD PTR $T230859[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv142[ebp], eax
	mov	ecx, DWORD PTR tv142[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _it$[ebp], edx
	mov	DWORD PTR _it$[ebp+4], eax
	jmp	SHORT $LN4@GetGoldPer
$LN3@GetGoldPer:
	cmp	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	jne	SHORT $LN29@GetGoldPer
	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _it$[ebp+4], edx
	jmp	SHORT $LN4@GetGoldPer
$LN29@GetGoldPer:
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T230914[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T230914[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T230923[ebp], ecx
	mov	eax, DWORD PTR $T230923[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T230927[ebp], ecx
	mov	edx, DWORD PTR $T230927[ebp]
	mov	DWORD PTR _it$[ebp+4], edx
$LN4@GetGoldPer:
	lea	eax, DWORD PTR $T230861[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T230943[ebp], eax
	mov	ecx, DWORD PTR $T230943[ebp]
	mov	edx, DWORD PTR _it$[ebp+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setne	al
	mov	BYTE PTR $T230860[ebp], al
	movzx	ecx, BYTE PTR $T230860[ebp]
	test	ecx, ecx
	je	SHORT $LN2@GetGoldPer

; 1681 : 	{
; 1682 : 		if(it->m_eItemType == TRADE_ITEM_GOLD_PER_TURN && it->m_eFromPlayer == eFrom)

	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T230966[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T230966[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+eax+8], 1
	jne	SHORT $LN1@GetGoldPer
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T230998[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T230998[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+ecx+36]
	cmp	ecx, DWORD PTR _eFrom$[ebp]
	jne	SHORT $LN1@GetGoldPer

; 1683 : 		{
; 1684 : 			return it->m_iData1;

	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T231030[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T231030[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+eax+20]
	mov	DWORD PTR $T230862[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T230862[ebp]
	jmp	SHORT $LN5@GetGoldPer
$LN1@GetGoldPer:

; 1685 : 		}
; 1686 : 	}

	jmp	$LN3@GetGoldPer
$LN2@GetGoldPer:

; 1687 : 	return 0;

	mov	DWORD PTR $T230863[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T230863[ebp]
$LN5@GetGoldPer:

; 1688 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetGoldPerTurnTrade@CvDeal@@QAEHW4PlayerTypes@@@Z$0:
	lea	ecx, DWORD PTR _it$[ebp]
	jmp	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
__ehhandler$?GetGoldPerTurnTrade@CvDeal@@QAEHW4PlayerTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetGoldPerTurnTrade@CvDeal@@QAEHW4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetGoldPerTurnTrade@CvDeal@@QAEHW4PlayerTypes@@@Z ENDP	; CvDeal::GetGoldPerTurnTrade
PUBLIC	?ChangeGoldPerTurnTrade@CvDeal@@QAE_NW4PlayerTypes@@HH@Z ; CvDeal::ChangeGoldPerTurnTrade
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
xdata$x	SEGMENT
__unwindtable$?ChangeGoldPerTurnTrade@CvDeal@@QAE_NW4PlayerTypes@@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ChangeGoldPerTurnTrade@CvDeal@@QAE_NW4PlayerTypes@@HH@Z$0
__ehfuncinfo$?ChangeGoldPerTurnTrade@CvDeal@@QAE_NW4PlayerTypes@@HH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ChangeGoldPerTurnTrade@CvDeal@@QAE_NW4PlayerTypes@@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?ChangeGoldPerTurnTrade@CvDeal@@QAE_NW4PlayerTypes@@HH@Z
_TEXT	SEGMENT
tv169 = -96						; size = 4
_this$ = -92						; size = 4
$T231365 = -88						; size = 4
$T231338 = -84						; size = 4
$T231332 = -80						; size = 4
$T231302 = -76						; size = 4
$T231270 = -72						; size = 4
$T231238 = -68						; size = 4
$T231206 = -64						; size = 4
$T231183 = -60						; size = 4
$T231167 = -56						; size = 4
$T231163 = -52						; size = 4
$T231154 = -48						; size = 4
$T231103 = -42						; size = 1
$T231102 = -41						; size = 1
$T231101 = -40						; size = 8
$T231100 = -29						; size = 1
$T231099 = -28						; size = 8
_it$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_eFrom$ = 8						; size = 4
_iNewAmount$ = 12					; size = 4
_iDuration$ = 16					; size = 4
?ChangeGoldPerTurnTrade@CvDeal@@QAE_NW4PlayerTypes@@HH@Z PROC ; CvDeal::ChangeGoldPerTurnTrade, COMDAT
; _this$ = ecx

; 1691 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ChangeGoldPerTurnTrade@CvDeal@@QAE_NW4PlayerTypes@@HH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1692 : 	CvAssertMsg(iDuration >= 0, "DEAL: Trying to add a negative duration to a TradeItem.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1693 : 	CvAssertMsg(iDuration < GC.getGame().getEstimateEndTurn() * 2, "DEAL: Trade item has a crazy long duration (probably invalid).  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1694 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Changing deal item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1695 : 
; 1696 : 	TradedItemList::iterator it;

	mov	DWORD PTR _it$[ebp], 0
	mov	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1697 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	eax, DWORD PTR $T231099[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv169[ebp], eax
	mov	ecx, DWORD PTR tv169[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _it$[ebp], edx
	mov	DWORD PTR _it$[ebp+4], eax
	jmp	SHORT $LN5@ChangeGold@2
$LN4@ChangeGold@2:
	cmp	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	jne	SHORT $LN30@ChangeGold@2
	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _it$[ebp+4], edx
	jmp	SHORT $LN5@ChangeGold@2
$LN30@ChangeGold@2:
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T231154[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T231154[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T231163[ebp], ecx
	mov	eax, DWORD PTR $T231163[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T231167[ebp], ecx
	mov	edx, DWORD PTR $T231167[ebp]
	mov	DWORD PTR _it$[ebp+4], edx
$LN5@ChangeGold@2:
	lea	eax, DWORD PTR $T231101[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T231183[ebp], eax
	mov	ecx, DWORD PTR $T231183[ebp]
	mov	edx, DWORD PTR _it$[ebp+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setne	al
	mov	BYTE PTR $T231100[ebp], al
	movzx	ecx, BYTE PTR $T231100[ebp]
	test	ecx, ecx
	je	$LN3@ChangeGold@2

; 1698 : 	{
; 1699 : 		if(it->m_eItemType == TRADE_ITEM_GOLD_PER_TURN && it->m_eFromPlayer == eFrom)

	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T231206[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T231206[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+eax+8], 1
	jne	$LN2@ChangeGold@2
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T231238[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T231238[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+ecx+36]
	cmp	ecx, DWORD PTR _eFrom$[ebp]
	jne	$LN2@ChangeGold@2

; 1700 : 		{
; 1701 : 			if(IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_GOLD_PER_TURN, iNewAmount, iDuration))

	push	0
	push	1
	push	0
	push	-1
	mov	edx, DWORD PTR _iDuration$[ebp]
	push	edx
	mov	eax, DWORD PTR _iNewAmount$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _eFrom$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOtherPlayer@CvDeal@@QBE?AW4PlayerTypes@@W42@@Z ; CvDeal::GetOtherPlayer
	push	eax
	mov	edx, DWORD PTR _eFrom$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@ChangeGold@2

; 1702 : 			{
; 1703 : 				it->m_iData1 = iNewAmount;

	mov	ecx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T231270[ebp], ecx
	mov	edx, DWORD PTR _it$[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T231270[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR _iNewAmount$[ebp]
	mov	DWORD PTR [ecx+edx+20], eax

; 1704 : 				it->m_iDuration = iDuration;

	mov	ecx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T231302[ebp], ecx
	mov	edx, DWORD PTR _it$[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T231302[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR _iDuration$[ebp]
	mov	DWORD PTR [ecx+edx+12], eax

; 1705 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1706 : 				it->m_iTurnsRemaining = iDuration;
; 1707 : #else
; 1708 : 				it->m_iFinalTurn = iDuration + GC.getGame().getGameTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T231332[ebp], ecx
	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T231338[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T231338[ebp]
	mov	edx, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [edx+eax+8]
	mov	DWORD PTR $T231365[ebp], eax
	mov	ecx, DWORD PTR $T231332[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	add	eax, DWORD PTR _iDuration$[ebp]
	mov	ecx, DWORD PTR $T231365[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1709 : #endif
; 1710 : 				return true;

	mov	BYTE PTR $T231102[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	al, BYTE PTR $T231102[ebp]
	jmp	SHORT $LN6@ChangeGold@2
$LN2@ChangeGold@2:

; 1711 : 			}
; 1712 : 		}
; 1713 : 	}

	jmp	$LN4@ChangeGold@2
$LN3@ChangeGold@2:

; 1714 : 	return false;

	mov	BYTE PTR $T231103[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	al, BYTE PTR $T231103[ebp]
$LN6@ChangeGold@2:

; 1715 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ChangeGoldPerTurnTrade@CvDeal@@QAE_NW4PlayerTypes@@HH@Z$0:
	lea	ecx, DWORD PTR _it$[ebp]
	jmp	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
__ehhandler$?ChangeGoldPerTurnTrade@CvDeal@@QAE_NW4PlayerTypes@@HH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-88]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ChangeGoldPerTurnTrade@CvDeal@@QAE_NW4PlayerTypes@@HH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ChangeGoldPerTurnTrade@CvDeal@@QAE_NW4PlayerTypes@@HH@Z ENDP ; CvDeal::ChangeGoldPerTurnTrade
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
xdata$x	SEGMENT
__unwindtable$?IsResourceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4ResourceTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?IsResourceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4ResourceTypes@@@Z$0
__ehfuncinfo$?IsResourceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4ResourceTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?IsResourceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4ResourceTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?IsResourceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4ResourceTypes@@@Z
_TEXT	SEGMENT
tv143 = -80						; size = 4
_this$ = -76						; size = 4
$T231579 = -72						; size = 4
$T231547 = -68						; size = 4
$T231515 = -64						; size = 4
$T231492 = -60						; size = 4
$T231476 = -56						; size = 4
$T231472 = -52						; size = 4
$T231463 = -48						; size = 4
$T231412 = -42						; size = 1
$T231411 = -41						; size = 1
$T231410 = -40						; size = 8
$T231409 = -29						; size = 1
$T231408 = -28						; size = 8
_it$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_eFrom$ = 8						; size = 4
_eResource$ = 12					; size = 4
?IsResourceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4ResourceTypes@@@Z PROC ; CvDeal::IsResourceTrade, COMDAT
; _this$ = ecx

; 1718 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?IsResourceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4ResourceTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1719 : 	TradedItemList::iterator it;

	mov	DWORD PTR _it$[ebp], 0
	mov	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1720 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	eax, DWORD PTR $T231408[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv143[ebp], eax
	mov	ecx, DWORD PTR tv143[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _it$[ebp], edx
	mov	DWORD PTR _it$[ebp+4], eax
	jmp	SHORT $LN4@IsResource
$LN3@IsResource:
	cmp	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	jne	SHORT $LN29@IsResource
	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _it$[ebp+4], edx
	jmp	SHORT $LN4@IsResource
$LN29@IsResource:
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T231463[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T231463[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T231472[ebp], ecx
	mov	eax, DWORD PTR $T231472[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T231476[ebp], ecx
	mov	edx, DWORD PTR $T231476[ebp]
	mov	DWORD PTR _it$[ebp+4], edx
$LN4@IsResource:
	lea	eax, DWORD PTR $T231410[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T231492[ebp], eax
	mov	ecx, DWORD PTR $T231492[ebp]
	mov	edx, DWORD PTR _it$[ebp+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setne	al
	mov	BYTE PTR $T231409[ebp], al
	movzx	ecx, BYTE PTR $T231409[ebp]
	test	ecx, ecx
	je	SHORT $LN2@IsResource

; 1721 : 	{
; 1722 : 		if(it->m_eItemType == TRADE_ITEM_RESOURCES &&
; 1723 : 		        it->m_eFromPlayer == eFrom &&
; 1724 : 		        (ResourceTypes)it->m_iData1 == eResource)

	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T231515[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T231515[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+eax+8], 3
	jne	SHORT $LN1@IsResource
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T231547[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T231547[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+ecx+36]
	cmp	ecx, DWORD PTR _eFrom$[ebp]
	jne	SHORT $LN1@IsResource
	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T231579[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T231579[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+eax+20]
	cmp	eax, DWORD PTR _eResource$[ebp]
	jne	SHORT $LN1@IsResource

; 1725 : 		{
; 1726 : 			return true;

	mov	BYTE PTR $T231411[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	al, BYTE PTR $T231411[ebp]
	jmp	SHORT $LN5@IsResource
$LN1@IsResource:

; 1727 : 		}
; 1728 : 	}

	jmp	$LN3@IsResource
$LN2@IsResource:

; 1729 : 	return false;

	mov	BYTE PTR $T231412[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	al, BYTE PTR $T231412[ebp]
$LN5@IsResource:

; 1730 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?IsResourceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4ResourceTypes@@@Z$0:
	lea	ecx, DWORD PTR _it$[ebp]
	jmp	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
__ehhandler$?IsResourceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4ResourceTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?IsResourceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4ResourceTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?IsResourceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4ResourceTypes@@@Z ENDP ; CvDeal::IsResourceTrade
PUBLIC	?ChangeResourceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4ResourceTypes@@HH@Z ; CvDeal::ChangeResourceTrade
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
xdata$x	SEGMENT
__unwindtable$?ChangeResourceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4ResourceTypes@@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ChangeResourceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4ResourceTypes@@HH@Z$0
__ehfuncinfo$?ChangeResourceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4ResourceTypes@@HH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ChangeResourceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4ResourceTypes@@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?ChangeResourceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4ResourceTypes@@HH@Z
_TEXT	SEGMENT
tv173 = -100						; size = 4
_this$ = -96						; size = 4
$T231946 = -92						; size = 4
$T231919 = -88						; size = 4
$T231913 = -84						; size = 4
$T231883 = -80						; size = 4
$T231851 = -76						; size = 4
$T231819 = -72						; size = 4
$T231787 = -68						; size = 4
$T231755 = -64						; size = 4
$T231732 = -60						; size = 4
$T231716 = -56						; size = 4
$T231712 = -52						; size = 4
$T231703 = -48						; size = 4
$T231652 = -42						; size = 1
$T231651 = -41						; size = 1
$T231650 = -40						; size = 8
$T231649 = -29						; size = 1
$T231648 = -28						; size = 8
_it$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_eFrom$ = 8						; size = 4
_eResource$ = 12					; size = 4
_iAmount$ = 16						; size = 4
_iDuration$ = 20					; size = 4
?ChangeResourceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4ResourceTypes@@HH@Z PROC ; CvDeal::ChangeResourceTrade, COMDAT
; _this$ = ecx

; 1733 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ChangeResourceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4ResourceTypes@@HH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1734 : 	CvAssertMsg(iDuration >= 0, "DEAL: Trying to add a negative duration to a TradeItem.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1735 : 	CvAssertMsg(iDuration < GC.getGame().getEstimateEndTurn() * 2, "DEAL: Trade item has a crazy long duration (probably invalid).  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1736 : 	CvAssertMsg(eFrom == m_eFromPlayer || eFrom == m_eToPlayer, "DEAL: Changing deal item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1737 : 
; 1738 : 	TradedItemList::iterator it;

	mov	DWORD PTR _it$[ebp], 0
	mov	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1739 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	eax, DWORD PTR $T231648[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv173[ebp], eax
	mov	ecx, DWORD PTR tv173[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _it$[ebp], edx
	mov	DWORD PTR _it$[ebp+4], eax
	jmp	SHORT $LN5@ChangeReso
$LN4@ChangeReso:
	cmp	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	jne	SHORT $LN30@ChangeReso
	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _it$[ebp+4], edx
	jmp	SHORT $LN5@ChangeReso
$LN30@ChangeReso:
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T231703[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T231703[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T231712[ebp], ecx
	mov	eax, DWORD PTR $T231712[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T231716[ebp], ecx
	mov	edx, DWORD PTR $T231716[ebp]
	mov	DWORD PTR _it$[ebp+4], edx
$LN5@ChangeReso:
	lea	eax, DWORD PTR $T231650[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T231732[ebp], eax
	mov	ecx, DWORD PTR $T231732[ebp]
	mov	edx, DWORD PTR _it$[ebp+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setne	al
	mov	BYTE PTR $T231649[ebp], al
	movzx	ecx, BYTE PTR $T231649[ebp]
	test	ecx, ecx
	je	$LN3@ChangeReso

; 1740 : 	{
; 1741 : 		if(it->m_eItemType == TRADE_ITEM_RESOURCES &&
; 1742 : 		        it->m_eFromPlayer == eFrom &&
; 1743 : 		        (ResourceTypes)it->m_iData1 == eResource)

	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T231755[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T231755[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+eax+8], 3
	jne	$LN2@ChangeReso
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T231787[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T231787[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+ecx+36]
	cmp	ecx, DWORD PTR _eFrom$[ebp]
	jne	$LN2@ChangeReso
	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T231819[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T231819[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+eax+20]
	cmp	eax, DWORD PTR _eResource$[ebp]
	jne	$LN2@ChangeReso

; 1744 : 		{
; 1745 : 			if(IsPossibleToTradeItem(eFrom, GetOtherPlayer(eFrom), TRADE_ITEM_RESOURCES, eResource, iAmount))

	push	0
	push	1
	push	0
	push	-1
	mov	ecx, DWORD PTR _iAmount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eResource$[ebp]
	push	edx
	push	3
	mov	eax, DWORD PTR _eFrom$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOtherPlayer@CvDeal@@QBE?AW4PlayerTypes@@W42@@Z ; CvDeal::GetOtherPlayer
	push	eax
	mov	ecx, DWORD PTR _eFrom$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@ChangeReso

; 1746 : 			{
; 1747 : 				it->m_iData2 = iAmount;

	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T231851[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T231851[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _iAmount$[ebp]
	mov	DWORD PTR [eax+ecx+24], edx

; 1748 : 				it->m_iDuration = iDuration;

	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T231883[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T231883[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _iDuration$[ebp]
	mov	DWORD PTR [eax+ecx+12], edx

; 1749 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1750 : 				it->m_iTurnsRemaining = iDuration;
; 1751 : #else
; 1752 : 				it->m_iFinalTurn = iDuration + GC.getGame().getGameTurn();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T231913[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T231919[ebp], ecx
	mov	edx, DWORD PTR _it$[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T231919[ebp]
	mov	ecx, DWORD PTR [eax+8]
	lea	edx, DWORD PTR [ecx+edx+8]
	mov	DWORD PTR $T231946[ebp], edx
	mov	ecx, DWORD PTR $T231913[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	add	eax, DWORD PTR _iDuration$[ebp]
	mov	ecx, DWORD PTR $T231946[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1753 : #endif
; 1754 : 				return true;

	mov	BYTE PTR $T231651[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	al, BYTE PTR $T231651[ebp]
	jmp	SHORT $LN6@ChangeReso
$LN2@ChangeReso:

; 1755 : 			}
; 1756 : 		}
; 1757 : 	}

	jmp	$LN4@ChangeReso
$LN3@ChangeReso:

; 1758 : 	return false;

	mov	BYTE PTR $T231652[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	al, BYTE PTR $T231652[ebp]
$LN6@ChangeReso:

; 1759 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ChangeResourceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4ResourceTypes@@HH@Z$0:
	lea	ecx, DWORD PTR _it$[ebp]
	jmp	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
__ehhandler$?ChangeResourceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4ResourceTypes@@HH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-92]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ChangeResourceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4ResourceTypes@@HH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ChangeResourceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4ResourceTypes@@HH@Z ENDP ; CvDeal::ChangeResourceTrade
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
xdata$x	SEGMENT
__unwindtable$?IsCityTrade@CvDeal@@QAE_NW4PlayerTypes@@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?IsCityTrade@CvDeal@@QAE_NW4PlayerTypes@@HH@Z$0
__ehfuncinfo$?IsCityTrade@CvDeal@@QAE_NW4PlayerTypes@@HH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?IsCityTrade@CvDeal@@QAE_NW4PlayerTypes@@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?IsCityTrade@CvDeal@@QAE_NW4PlayerTypes@@HH@Z
_TEXT	SEGMENT
tv147 = -84						; size = 4
_this$ = -80						; size = 4
$T232192 = -76						; size = 4
$T232160 = -72						; size = 4
$T232128 = -68						; size = 4
$T232096 = -64						; size = 4
$T232073 = -60						; size = 4
$T232057 = -56						; size = 4
$T232053 = -52						; size = 4
$T232044 = -48						; size = 4
$T231993 = -42						; size = 1
$T231992 = -41						; size = 1
$T231991 = -40						; size = 8
$T231990 = -29						; size = 1
$T231989 = -28						; size = 8
_it$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_eFrom$ = 8						; size = 4
_cityX$ = 12						; size = 4
_cityY$ = 16						; size = 4
?IsCityTrade@CvDeal@@QAE_NW4PlayerTypes@@HH@Z PROC	; CvDeal::IsCityTrade, COMDAT
; _this$ = ecx

; 1762 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?IsCityTrade@CvDeal@@QAE_NW4PlayerTypes@@HH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1763 : 	TradedItemList::iterator it;

	mov	DWORD PTR _it$[ebp], 0
	mov	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1764 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	eax, DWORD PTR $T231989[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv147[ebp], eax
	mov	ecx, DWORD PTR tv147[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _it$[ebp], edx
	mov	DWORD PTR _it$[ebp+4], eax
	jmp	SHORT $LN4@IsCityTrad
$LN3@IsCityTrad:
	cmp	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	jne	SHORT $LN29@IsCityTrad
	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _it$[ebp+4], edx
	jmp	SHORT $LN4@IsCityTrad
$LN29@IsCityTrad:
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T232044[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T232044[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T232053[ebp], ecx
	mov	eax, DWORD PTR $T232053[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T232057[ebp], ecx
	mov	edx, DWORD PTR $T232057[ebp]
	mov	DWORD PTR _it$[ebp+4], edx
$LN4@IsCityTrad:
	lea	eax, DWORD PTR $T231991[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T232073[ebp], eax
	mov	ecx, DWORD PTR $T232073[ebp]
	mov	edx, DWORD PTR _it$[ebp+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setne	al
	mov	BYTE PTR $T231990[ebp], al
	movzx	ecx, BYTE PTR $T231990[ebp]
	test	ecx, ecx
	je	SHORT $LN2@IsCityTrad

; 1765 : 	{
; 1766 : 		if(it->m_eItemType   == TRADE_ITEM_CITIES &&
; 1767 : 		        it->m_eFromPlayer == eFrom &&
; 1768 : 		        it->m_iData1 == cityX &&
; 1769 : 		        it->m_iData2 == cityY)

	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T232096[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T232096[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+eax+8], 4
	jne	SHORT $LN1@IsCityTrad
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T232128[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T232128[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+ecx+36]
	cmp	ecx, DWORD PTR _eFrom$[ebp]
	jne	SHORT $LN1@IsCityTrad
	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T232160[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T232160[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+eax+20]
	cmp	eax, DWORD PTR _cityX$[ebp]
	jne	SHORT $LN1@IsCityTrad
	mov	ecx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T232192[ebp], ecx
	mov	edx, DWORD PTR _it$[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T232192[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+edx+24]
	cmp	edx, DWORD PTR _cityY$[ebp]
	jne	SHORT $LN1@IsCityTrad

; 1770 : 		{
; 1771 : 			return true;

	mov	BYTE PTR $T231992[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	al, BYTE PTR $T231992[ebp]
	jmp	SHORT $LN5@IsCityTrad
$LN1@IsCityTrad:

; 1772 : 		}
; 1773 : 	}

	jmp	$LN3@IsCityTrad
$LN2@IsCityTrad:

; 1774 : 	return false;

	mov	BYTE PTR $T231993[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	al, BYTE PTR $T231993[ebp]
$LN5@IsCityTrad:

; 1775 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?IsCityTrade@CvDeal@@QAE_NW4PlayerTypes@@HH@Z$0:
	lea	ecx, DWORD PTR _it$[ebp]
	jmp	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
__ehhandler$?IsCityTrade@CvDeal@@QAE_NW4PlayerTypes@@HH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?IsCityTrade@CvDeal@@QAE_NW4PlayerTypes@@HH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?IsCityTrade@CvDeal@@QAE_NW4PlayerTypes@@HH@Z ENDP	; CvDeal::IsCityTrade
PUBLIC	?IsAllowEmbassyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ; CvDeal::IsAllowEmbassyTrade
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
xdata$x	SEGMENT
__unwindtable$?IsAllowEmbassyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?IsAllowEmbassyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z$0
__ehfuncinfo$?IsAllowEmbassyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?IsAllowEmbassyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?IsAllowEmbassyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
tv139 = -76						; size = 4
_this$ = -72						; size = 4
$T232400 = -68						; size = 4
$T232368 = -64						; size = 4
$T232345 = -60						; size = 4
$T232329 = -56						; size = 4
$T232325 = -52						; size = 4
$T232316 = -48						; size = 4
$T232265 = -42						; size = 1
$T232264 = -41						; size = 1
$T232263 = -40						; size = 8
$T232262 = -29						; size = 1
$T232261 = -28						; size = 8
_it$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_eFrom$ = 8						; size = 4
?IsAllowEmbassyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z PROC ; CvDeal::IsAllowEmbassyTrade, COMDAT
; _this$ = ecx

; 1778 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?IsAllowEmbassyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1779 : 	TradedItemList::iterator it;

	mov	DWORD PTR _it$[ebp], 0
	mov	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1780 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	eax, DWORD PTR $T232261[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv139[ebp], eax
	mov	ecx, DWORD PTR tv139[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _it$[ebp], edx
	mov	DWORD PTR _it$[ebp+4], eax
	jmp	SHORT $LN4@IsAllowEmb
$LN3@IsAllowEmb:
	cmp	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	jne	SHORT $LN29@IsAllowEmb
	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _it$[ebp+4], edx
	jmp	SHORT $LN4@IsAllowEmb
$LN29@IsAllowEmb:
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T232316[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T232316[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T232325[ebp], ecx
	mov	eax, DWORD PTR $T232325[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T232329[ebp], ecx
	mov	edx, DWORD PTR $T232329[ebp]
	mov	DWORD PTR _it$[ebp+4], edx
$LN4@IsAllowEmb:
	lea	eax, DWORD PTR $T232263[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T232345[ebp], eax
	mov	ecx, DWORD PTR $T232345[ebp]
	mov	edx, DWORD PTR _it$[ebp+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setne	al
	mov	BYTE PTR $T232262[ebp], al
	movzx	ecx, BYTE PTR $T232262[ebp]
	test	ecx, ecx
	je	SHORT $LN2@IsAllowEmb

; 1781 : 	{
; 1782 : 		if(it->m_eItemType == TRADE_ITEM_ALLOW_EMBASSY && it->m_eFromPlayer == eFrom)

	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T232368[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T232368[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+eax+8], 17		; 00000011H
	jne	SHORT $LN1@IsAllowEmb
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T232400[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T232400[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+ecx+36]
	cmp	ecx, DWORD PTR _eFrom$[ebp]
	jne	SHORT $LN1@IsAllowEmb

; 1783 : 		{
; 1784 : 			return true;

	mov	BYTE PTR $T232264[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	al, BYTE PTR $T232264[ebp]
	jmp	SHORT $LN5@IsAllowEmb
$LN1@IsAllowEmb:

; 1785 : 		}
; 1786 : 	}

	jmp	$LN3@IsAllowEmb
$LN2@IsAllowEmb:

; 1787 : 	return 0;

	mov	BYTE PTR $T232265[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	al, BYTE PTR $T232265[ebp]
$LN5@IsAllowEmb:

; 1788 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?IsAllowEmbassyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z$0:
	lea	ecx, DWORD PTR _it$[ebp]
	jmp	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
__ehhandler$?IsAllowEmbassyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-68]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?IsAllowEmbassyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?IsAllowEmbassyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ENDP ; CvDeal::IsAllowEmbassyTrade
PUBLIC	?IsOpenBordersTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ; CvDeal::IsOpenBordersTrade
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
xdata$x	SEGMENT
__unwindtable$?IsOpenBordersTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?IsOpenBordersTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z$0
__ehfuncinfo$?IsOpenBordersTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?IsOpenBordersTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?IsOpenBordersTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
tv139 = -76						; size = 4
_this$ = -72						; size = 4
$T232608 = -68						; size = 4
$T232576 = -64						; size = 4
$T232553 = -60						; size = 4
$T232537 = -56						; size = 4
$T232533 = -52						; size = 4
$T232524 = -48						; size = 4
$T232473 = -42						; size = 1
$T232472 = -41						; size = 1
$T232471 = -40						; size = 8
$T232470 = -29						; size = 1
$T232469 = -28						; size = 8
_it$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_eFrom$ = 8						; size = 4
?IsOpenBordersTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z PROC	; CvDeal::IsOpenBordersTrade, COMDAT
; _this$ = ecx

; 1791 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?IsOpenBordersTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1792 : 	TradedItemList::iterator it;

	mov	DWORD PTR _it$[ebp], 0
	mov	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1793 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	eax, DWORD PTR $T232469[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv139[ebp], eax
	mov	ecx, DWORD PTR tv139[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _it$[ebp], edx
	mov	DWORD PTR _it$[ebp+4], eax
	jmp	SHORT $LN4@IsOpenBord
$LN3@IsOpenBord:
	cmp	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	jne	SHORT $LN29@IsOpenBord
	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _it$[ebp+4], edx
	jmp	SHORT $LN4@IsOpenBord
$LN29@IsOpenBord:
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T232524[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T232524[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T232533[ebp], ecx
	mov	eax, DWORD PTR $T232533[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T232537[ebp], ecx
	mov	edx, DWORD PTR $T232537[ebp]
	mov	DWORD PTR _it$[ebp+4], edx
$LN4@IsOpenBord:
	lea	eax, DWORD PTR $T232471[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T232553[ebp], eax
	mov	ecx, DWORD PTR $T232553[ebp]
	mov	edx, DWORD PTR _it$[ebp+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setne	al
	mov	BYTE PTR $T232470[ebp], al
	movzx	ecx, BYTE PTR $T232470[ebp]
	test	ecx, ecx
	je	SHORT $LN2@IsOpenBord

; 1794 : 	{
; 1795 : 		if(it->m_eItemType == TRADE_ITEM_OPEN_BORDERS && it->m_eFromPlayer == eFrom)

	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T232576[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T232576[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+eax+8], 6
	jne	SHORT $LN1@IsOpenBord
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T232608[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T232608[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+ecx+36]
	cmp	ecx, DWORD PTR _eFrom$[ebp]
	jne	SHORT $LN1@IsOpenBord

; 1796 : 		{
; 1797 : 			return true;

	mov	BYTE PTR $T232472[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	al, BYTE PTR $T232472[ebp]
	jmp	SHORT $LN5@IsOpenBord
$LN1@IsOpenBord:

; 1798 : 		}
; 1799 : 	}

	jmp	$LN3@IsOpenBord
$LN2@IsOpenBord:

; 1800 : 	return 0;

	mov	BYTE PTR $T232473[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	al, BYTE PTR $T232473[ebp]
$LN5@IsOpenBord:

; 1801 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?IsOpenBordersTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z$0:
	lea	ecx, DWORD PTR _it$[ebp]
	jmp	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
__ehhandler$?IsOpenBordersTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-68]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?IsOpenBordersTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?IsOpenBordersTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ENDP	; CvDeal::IsOpenBordersTrade
PUBLIC	?IsDefensivePactTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ; CvDeal::IsDefensivePactTrade
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
xdata$x	SEGMENT
__unwindtable$?IsDefensivePactTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?IsDefensivePactTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z$0
__ehfuncinfo$?IsDefensivePactTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?IsDefensivePactTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?IsDefensivePactTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
tv139 = -76						; size = 4
_this$ = -72						; size = 4
$T232816 = -68						; size = 4
$T232784 = -64						; size = 4
$T232761 = -60						; size = 4
$T232745 = -56						; size = 4
$T232741 = -52						; size = 4
$T232732 = -48						; size = 4
$T232681 = -42						; size = 1
$T232680 = -41						; size = 1
$T232679 = -40						; size = 8
$T232678 = -29						; size = 1
$T232677 = -28						; size = 8
_it$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_eFrom$ = 8						; size = 4
?IsDefensivePactTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z PROC ; CvDeal::IsDefensivePactTrade, COMDAT
; _this$ = ecx

; 1804 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?IsDefensivePactTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1805 : 	TradedItemList::iterator it;

	mov	DWORD PTR _it$[ebp], 0
	mov	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1806 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	eax, DWORD PTR $T232677[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv139[ebp], eax
	mov	ecx, DWORD PTR tv139[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _it$[ebp], edx
	mov	DWORD PTR _it$[ebp+4], eax
	jmp	SHORT $LN4@IsDefensiv
$LN3@IsDefensiv:
	cmp	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	jne	SHORT $LN29@IsDefensiv
	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _it$[ebp+4], edx
	jmp	SHORT $LN4@IsDefensiv
$LN29@IsDefensiv:
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T232732[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T232732[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T232741[ebp], ecx
	mov	eax, DWORD PTR $T232741[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T232745[ebp], ecx
	mov	edx, DWORD PTR $T232745[ebp]
	mov	DWORD PTR _it$[ebp+4], edx
$LN4@IsDefensiv:
	lea	eax, DWORD PTR $T232679[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T232761[ebp], eax
	mov	ecx, DWORD PTR $T232761[ebp]
	mov	edx, DWORD PTR _it$[ebp+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setne	al
	mov	BYTE PTR $T232678[ebp], al
	movzx	ecx, BYTE PTR $T232678[ebp]
	test	ecx, ecx
	je	SHORT $LN2@IsDefensiv

; 1807 : 	{
; 1808 : 		if(it->m_eItemType == TRADE_ITEM_DEFENSIVE_PACT && it->m_eFromPlayer == eFrom)

	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T232784[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T232784[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+eax+8], 7
	jne	SHORT $LN1@IsDefensiv
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T232816[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T232816[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+ecx+36]
	cmp	ecx, DWORD PTR _eFrom$[ebp]
	jne	SHORT $LN1@IsDefensiv

; 1809 : 		{
; 1810 : 			return true;

	mov	BYTE PTR $T232680[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	al, BYTE PTR $T232680[ebp]
	jmp	SHORT $LN5@IsDefensiv
$LN1@IsDefensiv:

; 1811 : 		}
; 1812 : 	}

	jmp	$LN3@IsDefensiv
$LN2@IsDefensiv:

; 1813 : 	return 0;

	mov	BYTE PTR $T232681[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	al, BYTE PTR $T232681[ebp]
$LN5@IsDefensiv:

; 1814 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?IsDefensivePactTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z$0:
	lea	ecx, DWORD PTR _it$[ebp]
	jmp	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
__ehhandler$?IsDefensivePactTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-68]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?IsDefensivePactTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?IsDefensivePactTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ENDP ; CvDeal::IsDefensivePactTrade
PUBLIC	?IsResearchAgreementTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ; CvDeal::IsResearchAgreementTrade
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
xdata$x	SEGMENT
__unwindtable$?IsResearchAgreementTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?IsResearchAgreementTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z$0
__ehfuncinfo$?IsResearchAgreementTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?IsResearchAgreementTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?IsResearchAgreementTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
tv139 = -76						; size = 4
_this$ = -72						; size = 4
$T233024 = -68						; size = 4
$T232992 = -64						; size = 4
$T232969 = -60						; size = 4
$T232953 = -56						; size = 4
$T232949 = -52						; size = 4
$T232940 = -48						; size = 4
$T232889 = -42						; size = 1
$T232888 = -41						; size = 1
$T232887 = -40						; size = 8
$T232886 = -29						; size = 1
$T232885 = -28						; size = 8
_it$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_eFrom$ = 8						; size = 4
?IsResearchAgreementTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z PROC ; CvDeal::IsResearchAgreementTrade, COMDAT
; _this$ = ecx

; 1817 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?IsResearchAgreementTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1818 : 	TradedItemList::iterator it;

	mov	DWORD PTR _it$[ebp], 0
	mov	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1819 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	eax, DWORD PTR $T232885[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv139[ebp], eax
	mov	ecx, DWORD PTR tv139[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _it$[ebp], edx
	mov	DWORD PTR _it$[ebp+4], eax
	jmp	SHORT $LN4@IsResearch
$LN3@IsResearch:
	cmp	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	jne	SHORT $LN29@IsResearch
	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _it$[ebp+4], edx
	jmp	SHORT $LN4@IsResearch
$LN29@IsResearch:
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T232940[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T232940[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T232949[ebp], ecx
	mov	eax, DWORD PTR $T232949[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T232953[ebp], ecx
	mov	edx, DWORD PTR $T232953[ebp]
	mov	DWORD PTR _it$[ebp+4], edx
$LN4@IsResearch:
	lea	eax, DWORD PTR $T232887[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T232969[ebp], eax
	mov	ecx, DWORD PTR $T232969[ebp]
	mov	edx, DWORD PTR _it$[ebp+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setne	al
	mov	BYTE PTR $T232886[ebp], al
	movzx	ecx, BYTE PTR $T232886[ebp]
	test	ecx, ecx
	je	SHORT $LN2@IsResearch

; 1820 : 	{
; 1821 : 		if(it->m_eItemType == TRADE_ITEM_RESEARCH_AGREEMENT && it->m_eFromPlayer == eFrom)

	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T232992[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T232992[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+eax+8], 8
	jne	SHORT $LN1@IsResearch
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T233024[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T233024[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+ecx+36]
	cmp	ecx, DWORD PTR _eFrom$[ebp]
	jne	SHORT $LN1@IsResearch

; 1822 : 		{
; 1823 : 			return true;

	mov	BYTE PTR $T232888[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	al, BYTE PTR $T232888[ebp]
	jmp	SHORT $LN5@IsResearch
$LN1@IsResearch:

; 1824 : 		}
; 1825 : 	}

	jmp	$LN3@IsResearch
$LN2@IsResearch:

; 1826 : 	return 0;

	mov	BYTE PTR $T232889[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	al, BYTE PTR $T232889[ebp]
$LN5@IsResearch:

; 1827 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?IsResearchAgreementTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z$0:
	lea	ecx, DWORD PTR _it$[ebp]
	jmp	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
__ehhandler$?IsResearchAgreementTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-68]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?IsResearchAgreementTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?IsResearchAgreementTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ENDP ; CvDeal::IsResearchAgreementTrade
PUBLIC	?IsTradeAgreementTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ; CvDeal::IsTradeAgreementTrade
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
xdata$x	SEGMENT
__unwindtable$?IsTradeAgreementTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?IsTradeAgreementTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z$0
__ehfuncinfo$?IsTradeAgreementTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?IsTradeAgreementTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?IsTradeAgreementTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
tv139 = -76						; size = 4
_this$ = -72						; size = 4
$T233232 = -68						; size = 4
$T233200 = -64						; size = 4
$T233177 = -60						; size = 4
$T233161 = -56						; size = 4
$T233157 = -52						; size = 4
$T233148 = -48						; size = 4
$T233097 = -42						; size = 1
$T233096 = -41						; size = 1
$T233095 = -40						; size = 8
$T233094 = -29						; size = 1
$T233093 = -28						; size = 8
_it$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_eFrom$ = 8						; size = 4
?IsTradeAgreementTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z PROC ; CvDeal::IsTradeAgreementTrade, COMDAT
; _this$ = ecx

; 1830 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?IsTradeAgreementTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1831 : 	TradedItemList::iterator it;

	mov	DWORD PTR _it$[ebp], 0
	mov	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1832 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	eax, DWORD PTR $T233093[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv139[ebp], eax
	mov	ecx, DWORD PTR tv139[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _it$[ebp], edx
	mov	DWORD PTR _it$[ebp+4], eax
	jmp	SHORT $LN4@IsTradeAgr
$LN3@IsTradeAgr:
	cmp	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	jne	SHORT $LN29@IsTradeAgr
	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _it$[ebp+4], edx
	jmp	SHORT $LN4@IsTradeAgr
$LN29@IsTradeAgr:
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T233148[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T233148[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T233157[ebp], ecx
	mov	eax, DWORD PTR $T233157[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T233161[ebp], ecx
	mov	edx, DWORD PTR $T233161[ebp]
	mov	DWORD PTR _it$[ebp+4], edx
$LN4@IsTradeAgr:
	lea	eax, DWORD PTR $T233095[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T233177[ebp], eax
	mov	ecx, DWORD PTR $T233177[ebp]
	mov	edx, DWORD PTR _it$[ebp+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setne	al
	mov	BYTE PTR $T233094[ebp], al
	movzx	ecx, BYTE PTR $T233094[ebp]
	test	ecx, ecx
	je	SHORT $LN2@IsTradeAgr

; 1833 : 	{
; 1834 : 		if(it->m_eItemType == TRADE_ITEM_TRADE_AGREEMENT && it->m_eFromPlayer == eFrom)

	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T233200[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T233200[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+eax+8], 9
	jne	SHORT $LN1@IsTradeAgr
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T233232[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T233232[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+ecx+36]
	cmp	ecx, DWORD PTR _eFrom$[ebp]
	jne	SHORT $LN1@IsTradeAgr

; 1835 : 		{
; 1836 : 			return true;

	mov	BYTE PTR $T233096[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	al, BYTE PTR $T233096[ebp]
	jmp	SHORT $LN5@IsTradeAgr
$LN1@IsTradeAgr:

; 1837 : 		}
; 1838 : 	}

	jmp	$LN3@IsTradeAgr
$LN2@IsTradeAgr:

; 1839 : 	return 0;

	mov	BYTE PTR $T233097[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	al, BYTE PTR $T233097[ebp]
$LN5@IsTradeAgr:

; 1840 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?IsTradeAgreementTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z$0:
	lea	ecx, DWORD PTR _it$[ebp]
	jmp	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
__ehhandler$?IsTradeAgreementTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-68]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?IsTradeAgreementTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?IsTradeAgreementTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ENDP ; CvDeal::IsTradeAgreementTrade
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
xdata$x	SEGMENT
__unwindtable$?IsPeaceTreatyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?IsPeaceTreatyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z$0
__ehfuncinfo$?IsPeaceTreatyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?IsPeaceTreatyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?IsPeaceTreatyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
tv139 = -76						; size = 4
_this$ = -72						; size = 4
$T233440 = -68						; size = 4
$T233408 = -64						; size = 4
$T233385 = -60						; size = 4
$T233369 = -56						; size = 4
$T233365 = -52						; size = 4
$T233356 = -48						; size = 4
$T233305 = -42						; size = 1
$T233304 = -41						; size = 1
$T233303 = -40						; size = 8
$T233302 = -29						; size = 1
$T233301 = -28						; size = 8
_it$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_eFrom$ = 8						; size = 4
?IsPeaceTreatyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z PROC	; CvDeal::IsPeaceTreatyTrade, COMDAT
; _this$ = ecx

; 1843 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?IsPeaceTreatyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1844 : 	TradedItemList::iterator it;

	mov	DWORD PTR _it$[ebp], 0
	mov	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1845 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	eax, DWORD PTR $T233301[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv139[ebp], eax
	mov	ecx, DWORD PTR tv139[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _it$[ebp], edx
	mov	DWORD PTR _it$[ebp+4], eax
	jmp	SHORT $LN4@IsPeaceTre
$LN3@IsPeaceTre:
	cmp	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	jne	SHORT $LN29@IsPeaceTre
	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _it$[ebp+4], edx
	jmp	SHORT $LN4@IsPeaceTre
$LN29@IsPeaceTre:
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T233356[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T233356[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T233365[ebp], ecx
	mov	eax, DWORD PTR $T233365[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T233369[ebp], ecx
	mov	edx, DWORD PTR $T233369[ebp]
	mov	DWORD PTR _it$[ebp+4], edx
$LN4@IsPeaceTre:
	lea	eax, DWORD PTR $T233303[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T233385[ebp], eax
	mov	ecx, DWORD PTR $T233385[ebp]
	mov	edx, DWORD PTR _it$[ebp+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setne	al
	mov	BYTE PTR $T233302[ebp], al
	movzx	ecx, BYTE PTR $T233302[ebp]
	test	ecx, ecx
	je	SHORT $LN2@IsPeaceTre

; 1846 : 	{
; 1847 : 		if(it->m_eItemType == TRADE_ITEM_PEACE_TREATY && it->m_eFromPlayer == eFrom)

	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T233408[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T233408[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+eax+8], 13		; 0000000dH
	jne	SHORT $LN1@IsPeaceTre
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T233440[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T233440[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+ecx+36]
	cmp	ecx, DWORD PTR _eFrom$[ebp]
	jne	SHORT $LN1@IsPeaceTre

; 1848 : 		{
; 1849 : 			return true;

	mov	BYTE PTR $T233304[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	al, BYTE PTR $T233304[ebp]
	jmp	SHORT $LN5@IsPeaceTre
$LN1@IsPeaceTre:

; 1850 : 		}
; 1851 : 	}

	jmp	$LN3@IsPeaceTre
$LN2@IsPeaceTre:

; 1852 : 	return 0;

	mov	BYTE PTR $T233305[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	al, BYTE PTR $T233305[ebp]
$LN5@IsPeaceTre:

; 1853 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?IsPeaceTreatyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z$0:
	lea	ecx, DWORD PTR _it$[ebp]
	jmp	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
__ehhandler$?IsPeaceTreatyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-68]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?IsPeaceTreatyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?IsPeaceTreatyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ENDP	; CvDeal::IsPeaceTreatyTrade
PUBLIC	?IsThirdPartyPeaceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4TeamTypes@@@Z ; CvDeal::IsThirdPartyPeaceTrade
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
xdata$x	SEGMENT
__unwindtable$?IsThirdPartyPeaceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4TeamTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?IsThirdPartyPeaceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4TeamTypes@@@Z$0
__ehfuncinfo$?IsThirdPartyPeaceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4TeamTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?IsThirdPartyPeaceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4TeamTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?IsThirdPartyPeaceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4TeamTypes@@@Z
_TEXT	SEGMENT
tv143 = -80						; size = 4
_this$ = -76						; size = 4
$T233680 = -72						; size = 4
$T233648 = -68						; size = 4
$T233616 = -64						; size = 4
$T233593 = -60						; size = 4
$T233577 = -56						; size = 4
$T233573 = -52						; size = 4
$T233564 = -48						; size = 4
$T233513 = -42						; size = 1
$T233512 = -41						; size = 1
$T233511 = -40						; size = 8
$T233510 = -29						; size = 1
$T233509 = -28						; size = 8
_it$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_eFrom$ = 8						; size = 4
_eThirdPartyTeam$ = 12					; size = 4
?IsThirdPartyPeaceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4TeamTypes@@@Z PROC ; CvDeal::IsThirdPartyPeaceTrade, COMDAT
; _this$ = ecx

; 1856 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?IsThirdPartyPeaceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4TeamTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1857 : 	TradedItemList::iterator it;

	mov	DWORD PTR _it$[ebp], 0
	mov	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1858 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	eax, DWORD PTR $T233509[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv143[ebp], eax
	mov	ecx, DWORD PTR tv143[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _it$[ebp], edx
	mov	DWORD PTR _it$[ebp+4], eax
	jmp	SHORT $LN4@IsThirdPar
$LN3@IsThirdPar:
	cmp	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	jne	SHORT $LN29@IsThirdPar
	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _it$[ebp+4], edx
	jmp	SHORT $LN4@IsThirdPar
$LN29@IsThirdPar:
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T233564[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T233564[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T233573[ebp], ecx
	mov	eax, DWORD PTR $T233573[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T233577[ebp], ecx
	mov	edx, DWORD PTR $T233577[ebp]
	mov	DWORD PTR _it$[ebp+4], edx
$LN4@IsThirdPar:
	lea	eax, DWORD PTR $T233511[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T233593[ebp], eax
	mov	ecx, DWORD PTR $T233593[ebp]
	mov	edx, DWORD PTR _it$[ebp+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setne	al
	mov	BYTE PTR $T233510[ebp], al
	movzx	ecx, BYTE PTR $T233510[ebp]
	test	ecx, ecx
	je	SHORT $LN2@IsThirdPar

; 1859 : 	{
; 1860 : 		if(it->m_eItemType == TRADE_ITEM_THIRD_PARTY_PEACE && it->m_eFromPlayer == eFrom && it->m_iData1 == eThirdPartyTeam)

	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T233616[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T233616[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+eax+8], 14		; 0000000eH
	jne	SHORT $LN1@IsThirdPar
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T233648[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T233648[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+ecx+36]
	cmp	ecx, DWORD PTR _eFrom$[ebp]
	jne	SHORT $LN1@IsThirdPar
	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T233680[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T233680[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+eax+20]
	cmp	eax, DWORD PTR _eThirdPartyTeam$[ebp]
	jne	SHORT $LN1@IsThirdPar

; 1861 : 		{
; 1862 : 			return true;

	mov	BYTE PTR $T233512[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	al, BYTE PTR $T233512[ebp]
	jmp	SHORT $LN5@IsThirdPar
$LN1@IsThirdPar:

; 1863 : 		}
; 1864 : 	}

	jmp	$LN3@IsThirdPar
$LN2@IsThirdPar:

; 1865 : 	return 0;

	mov	BYTE PTR $T233513[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	al, BYTE PTR $T233513[ebp]
$LN5@IsThirdPar:

; 1866 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?IsThirdPartyPeaceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4TeamTypes@@@Z$0:
	lea	ecx, DWORD PTR _it$[ebp]
	jmp	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
__ehhandler$?IsThirdPartyPeaceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4TeamTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?IsThirdPartyPeaceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4TeamTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?IsThirdPartyPeaceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4TeamTypes@@@Z ENDP ; CvDeal::IsThirdPartyPeaceTrade
PUBLIC	?IsThirdPartyWarTrade@CvDeal@@QAE_NW4PlayerTypes@@W4TeamTypes@@@Z ; CvDeal::IsThirdPartyWarTrade
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
xdata$x	SEGMENT
__unwindtable$?IsThirdPartyWarTrade@CvDeal@@QAE_NW4PlayerTypes@@W4TeamTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?IsThirdPartyWarTrade@CvDeal@@QAE_NW4PlayerTypes@@W4TeamTypes@@@Z$0
__ehfuncinfo$?IsThirdPartyWarTrade@CvDeal@@QAE_NW4PlayerTypes@@W4TeamTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?IsThirdPartyWarTrade@CvDeal@@QAE_NW4PlayerTypes@@W4TeamTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?IsThirdPartyWarTrade@CvDeal@@QAE_NW4PlayerTypes@@W4TeamTypes@@@Z
_TEXT	SEGMENT
tv143 = -80						; size = 4
_this$ = -76						; size = 4
$T233920 = -72						; size = 4
$T233888 = -68						; size = 4
$T233856 = -64						; size = 4
$T233833 = -60						; size = 4
$T233817 = -56						; size = 4
$T233813 = -52						; size = 4
$T233804 = -48						; size = 4
$T233753 = -42						; size = 1
$T233752 = -41						; size = 1
$T233751 = -40						; size = 8
$T233750 = -29						; size = 1
$T233749 = -28						; size = 8
_it$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_eFrom$ = 8						; size = 4
_eThirdPartyTeam$ = 12					; size = 4
?IsThirdPartyWarTrade@CvDeal@@QAE_NW4PlayerTypes@@W4TeamTypes@@@Z PROC ; CvDeal::IsThirdPartyWarTrade, COMDAT
; _this$ = ecx

; 1869 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?IsThirdPartyWarTrade@CvDeal@@QAE_NW4PlayerTypes@@W4TeamTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1870 : 	TradedItemList::iterator it;

	mov	DWORD PTR _it$[ebp], 0
	mov	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1871 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	eax, DWORD PTR $T233749[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv143[ebp], eax
	mov	ecx, DWORD PTR tv143[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _it$[ebp], edx
	mov	DWORD PTR _it$[ebp+4], eax
	jmp	SHORT $LN4@IsThirdPar@2
$LN3@IsThirdPar@2:
	cmp	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	jne	SHORT $LN29@IsThirdPar@2
	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _it$[ebp+4], edx
	jmp	SHORT $LN4@IsThirdPar@2
$LN29@IsThirdPar@2:
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T233804[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T233804[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T233813[ebp], ecx
	mov	eax, DWORD PTR $T233813[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T233817[ebp], ecx
	mov	edx, DWORD PTR $T233817[ebp]
	mov	DWORD PTR _it$[ebp+4], edx
$LN4@IsThirdPar@2:
	lea	eax, DWORD PTR $T233751[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T233833[ebp], eax
	mov	ecx, DWORD PTR $T233833[ebp]
	mov	edx, DWORD PTR _it$[ebp+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setne	al
	mov	BYTE PTR $T233750[ebp], al
	movzx	ecx, BYTE PTR $T233750[ebp]
	test	ecx, ecx
	je	SHORT $LN2@IsThirdPar@2

; 1872 : 	{
; 1873 : 		if(it->m_eItemType == TRADE_ITEM_THIRD_PARTY_WAR && it->m_eFromPlayer == eFrom && it->m_iData1 == eThirdPartyTeam)

	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T233856[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T233856[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+eax+8], 15		; 0000000fH
	jne	SHORT $LN1@IsThirdPar@2
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T233888[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T233888[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+ecx+36]
	cmp	ecx, DWORD PTR _eFrom$[ebp]
	jne	SHORT $LN1@IsThirdPar@2
	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T233920[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T233920[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+eax+20]
	cmp	eax, DWORD PTR _eThirdPartyTeam$[ebp]
	jne	SHORT $LN1@IsThirdPar@2

; 1874 : 		{
; 1875 : 			return true;

	mov	BYTE PTR $T233752[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	al, BYTE PTR $T233752[ebp]
	jmp	SHORT $LN5@IsThirdPar@2
$LN1@IsThirdPar@2:

; 1876 : 		}
; 1877 : 	}

	jmp	$LN3@IsThirdPar@2
$LN2@IsThirdPar@2:

; 1878 : 	return 0;

	mov	BYTE PTR $T233753[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	al, BYTE PTR $T233753[ebp]
$LN5@IsThirdPar@2:

; 1879 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?IsThirdPartyWarTrade@CvDeal@@QAE_NW4PlayerTypes@@W4TeamTypes@@@Z$0:
	lea	ecx, DWORD PTR _it$[ebp]
	jmp	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
__ehhandler$?IsThirdPartyWarTrade@CvDeal@@QAE_NW4PlayerTypes@@W4TeamTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?IsThirdPartyWarTrade@CvDeal@@QAE_NW4PlayerTypes@@W4TeamTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?IsThirdPartyWarTrade@CvDeal@@QAE_NW4PlayerTypes@@W4TeamTypes@@@Z ENDP ; CvDeal::IsThirdPartyWarTrade
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
xdata$x	SEGMENT
__unwindtable$?IsVoteCommitmentTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?IsVoteCommitmentTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z$0
__ehfuncinfo$?IsVoteCommitmentTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?IsVoteCommitmentTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?IsVoteCommitmentTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
tv139 = -76						; size = 4
_this$ = -72						; size = 4
$T234128 = -68						; size = 4
$T234096 = -64						; size = 4
$T234073 = -60						; size = 4
$T234057 = -56						; size = 4
$T234053 = -52						; size = 4
$T234044 = -48						; size = 4
$T233993 = -42						; size = 1
$T233992 = -41						; size = 1
$T233991 = -40						; size = 8
$T233990 = -29						; size = 1
$T233989 = -28						; size = 8
_it$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_eFrom$ = 8						; size = 4
?IsVoteCommitmentTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z PROC ; CvDeal::IsVoteCommitmentTrade, COMDAT
; _this$ = ecx

; 1882 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?IsVoteCommitmentTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1883 : 	TradedItemList::iterator it;

	mov	DWORD PTR _it$[ebp], 0
	mov	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1884 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	eax, DWORD PTR $T233989[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv139[ebp], eax
	mov	ecx, DWORD PTR tv139[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _it$[ebp], edx
	mov	DWORD PTR _it$[ebp+4], eax
	jmp	SHORT $LN4@IsVoteComm
$LN3@IsVoteComm:
	cmp	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	jne	SHORT $LN29@IsVoteComm
	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _it$[ebp+4], edx
	jmp	SHORT $LN4@IsVoteComm
$LN29@IsVoteComm:
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T234044[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T234044[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T234053[ebp], ecx
	mov	eax, DWORD PTR $T234053[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T234057[ebp], ecx
	mov	edx, DWORD PTR $T234057[ebp]
	mov	DWORD PTR _it$[ebp+4], edx
$LN4@IsVoteComm:
	lea	eax, DWORD PTR $T233991[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T234073[ebp], eax
	mov	ecx, DWORD PTR $T234073[ebp]
	mov	edx, DWORD PTR _it$[ebp+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setne	al
	mov	BYTE PTR $T233990[ebp], al
	movzx	ecx, BYTE PTR $T233990[ebp]
	test	ecx, ecx
	je	SHORT $LN2@IsVoteComm

; 1885 : 	{
; 1886 : 		if(it->m_eItemType == TRADE_ITEM_VOTE_COMMITMENT && it->m_eFromPlayer == eFrom)

	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T234096[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T234096[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+eax+8], 19		; 00000013H
	jne	SHORT $LN1@IsVoteComm
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T234128[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T234128[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+ecx+36]
	cmp	ecx, DWORD PTR _eFrom$[ebp]
	jne	SHORT $LN1@IsVoteComm

; 1887 : 		{
; 1888 : 			return true;

	mov	BYTE PTR $T233992[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	al, BYTE PTR $T233992[ebp]
	jmp	SHORT $LN5@IsVoteComm
$LN1@IsVoteComm:

; 1889 : 		}
; 1890 : 	}

	jmp	$LN3@IsVoteComm
$LN2@IsVoteComm:

; 1891 : 	return false;

	mov	BYTE PTR $T233993[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	al, BYTE PTR $T233993[ebp]
$LN5@IsVoteComm:

; 1892 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?IsVoteCommitmentTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z$0:
	lea	ecx, DWORD PTR _it$[ebp]
	jmp	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
__ehhandler$?IsVoteCommitmentTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-68]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?IsVoteCommitmentTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?IsVoteCommitmentTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ENDP ; CvDeal::IsVoteCommitmentTrade
PUBLIC	?GetItemTradeableState@CvDeal@@SA?AW4DealRenewStatus@1@W4TradeableItems@@@Z ; CvDeal::GetItemTradeableState
; Function compile flags: /Odtp
;	COMDAT ?GetItemTradeableState@CvDeal@@SA?AW4DealRenewStatus@1@W4TradeableItems@@@Z
_TEXT	SEGMENT
tv64 = -4						; size = 4
_eTradeItem$ = 8					; size = 4
?GetItemTradeableState@CvDeal@@SA?AW4DealRenewStatus@1@W4TradeableItems@@@Z PROC ; CvDeal::GetItemTradeableState, COMDAT

; 1895 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1896 : 	switch(eTradeItem)

	mov	eax, DWORD PTR _eTradeItem$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 19			; 00000013H
	ja	SHORT $LN4@GetItemTra
	mov	ecx, DWORD PTR tv64[ebp]
	movzx	edx, BYTE PTR $LN8@GetItemTra[ecx]
	jmp	DWORD PTR $LN9@GetItemTra[edx*4]
$LN3@GetItemTra:

; 1897 : 	{
; 1898 : 		// not renewable
; 1899 : 	case TRADE_ITEM_ALLOW_EMBASSY:
; 1900 : 	case TRADE_ITEM_CITIES:
; 1901 : 	case TRADE_ITEM_UNITS:
; 1902 : 	case TRADE_ITEM_SURRENDER:
; 1903 : 	case TRADE_ITEM_TRUCE:
; 1904 : 	case TRADE_ITEM_PEACE_TREATY:
; 1905 : 	case TRADE_ITEM_PERMANENT_ALLIANCE:
; 1906 : 	case TRADE_ITEM_THIRD_PARTY_PEACE:
; 1907 : 	case TRADE_ITEM_THIRD_PARTY_WAR:
; 1908 : 	case TRADE_ITEM_VOTE_COMMITMENT:
; 1909 : 		return DEAL_NONRENEWABLE;

	mov	eax, 1
	jmp	SHORT $LN6@GetItemTra

; 1910 : 		break;

	jmp	SHORT $LN4@GetItemTra
$LN2@GetItemTra:

; 1911 : 
; 1912 : 		// renewable
; 1913 : 	case TRADE_ITEM_GOLD_PER_TURN:
; 1914 : 	case TRADE_ITEM_RESOURCES:
; 1915 : 	case TRADE_ITEM_OPEN_BORDERS:
; 1916 : 	case TRADE_ITEM_DEFENSIVE_PACT:
; 1917 : 	case TRADE_ITEM_THIRD_PARTY_EMBARGO: // dead!
; 1918 : 		return DEAL_RENEWABLE;

	xor	eax, eax
	jmp	SHORT $LN6@GetItemTra

; 1919 : 		break;

	jmp	SHORT $LN4@GetItemTra
$LN1@GetItemTra:

; 1920 : 
; 1921 : 		// doesn't matter
; 1922 : 	case TRADE_ITEM_TRADE_AGREEMENT:
; 1923 : 	case TRADE_ITEM_GOLD:
; 1924 : 	case TRADE_ITEM_MAPS:
; 1925 : 	case TRADE_ITEM_RESEARCH_AGREEMENT:
; 1926 : 		return DEAL_SUPPLEMENTAL;

	mov	eax, 2
	jmp	SHORT $LN6@GetItemTra
$LN4@GetItemTra:

; 1927 : 		break;
; 1928 : 	}
; 1929 : 
; 1930 : 	CvAssertMsg(false, "unknown eTradeItem passed in");
; 1931 : 	return DEAL_NONRENEWABLE;

	mov	eax, 1
$LN6@GetItemTra:

; 1932 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@GetItemTra:
	DD	$LN1@GetItemTra
	DD	$LN2@GetItemTra
	DD	$LN3@GetItemTra
	DD	$LN4@GetItemTra
$LN8@GetItemTra:
	DB	0
	DB	1
	DB	0
	DB	1
	DB	2
	DB	2
	DB	1
	DB	1
	DB	0
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	1
	DB	2
	DB	3
	DB	2
?GetItemTradeableState@CvDeal@@SA?AW4DealRenewStatus@1@W4TradeableItems@@@Z ENDP ; CvDeal::GetItemTradeableState
_TEXT	ENDS
PUBLIC	?IsPotentiallyRenewable@CvDeal@@QAE_NXZ		; CvDeal::IsPotentiallyRenewable
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
xdata$x	SEGMENT
__unwindtable$?IsPotentiallyRenewable@CvDeal@@QAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?IsPotentiallyRenewable@CvDeal@@QAE_NXZ$0
__ehfuncinfo$?IsPotentiallyRenewable@CvDeal@@QAE_NXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?IsPotentiallyRenewable@CvDeal@@QAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?IsPotentiallyRenewable@CvDeal@@QAE_NXZ
_TEXT	SEGMENT
tv134 = -84						; size = 4
tv139 = -80						; size = 4
_this$ = -76						; size = 4
$T234335 = -72						; size = 4
$T234308 = -68						; size = 4
$T234285 = -64						; size = 4
$T234269 = -60						; size = 4
$T234265 = -56						; size = 4
$T234256 = -52						; size = 4
$T234205 = -46						; size = 1
$T234204 = -45						; size = 1
$T234203 = -44						; size = 8
$T234202 = -33						; size = 1
$T234201 = -32						; size = 8
_bHasValidTradeItem$ = -21				; size = 1
_it$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
?IsPotentiallyRenewable@CvDeal@@QAE_NXZ PROC		; CvDeal::IsPotentiallyRenewable, COMDAT
; _this$ = ecx

; 1935 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?IsPotentiallyRenewable@CvDeal@@QAE_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1936 : 	TradedItemList::iterator it;

	mov	DWORD PTR _it$[ebp], 0
	mov	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1937 : 	bool bHasValidTradeItem = false;

	mov	BYTE PTR _bHasValidTradeItem$[ebp], 0

; 1938 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	eax, DWORD PTR $T234201[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv139[ebp], eax
	mov	ecx, DWORD PTR tv139[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _it$[ebp], edx
	mov	DWORD PTR _it$[ebp+4], eax
	jmp	SHORT $LN8@IsPotentia
$LN7@IsPotentia:
	cmp	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	jne	SHORT $LN33@IsPotentia
	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _it$[ebp+4], edx
	jmp	SHORT $LN8@IsPotentia
$LN33@IsPotentia:
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T234256[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T234256[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T234265[ebp], ecx
	mov	eax, DWORD PTR $T234265[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T234269[ebp], ecx
	mov	edx, DWORD PTR $T234269[ebp]
	mov	DWORD PTR _it$[ebp+4], edx
$LN8@IsPotentia:
	lea	eax, DWORD PTR $T234203[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T234285[ebp], eax
	mov	ecx, DWORD PTR $T234285[ebp]
	mov	edx, DWORD PTR _it$[ebp+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setne	al
	mov	BYTE PTR $T234202[ebp], al
	movzx	ecx, BYTE PTR $T234202[ebp]
	test	ecx, ecx
	je	SHORT $LN6@IsPotentia

; 1939 : 	{
; 1940 : 		switch(GetItemTradeableState(it->m_eItemType))

	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T234308[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T234308[ebp]
	mov	edx, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [edx+eax+8]
	mov	DWORD PTR $T234335[ebp], eax
	mov	ecx, DWORD PTR $T234335[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?GetItemTradeableState@CvDeal@@SA?AW4DealRenewStatus@1@W4TradeableItems@@@Z ; CvDeal::GetItemTradeableState
	add	esp, 4
	mov	DWORD PTR tv134[ebp], eax
	cmp	DWORD PTR tv134[ebp], 0
	je	SHORT $LN2@IsPotentia
	cmp	DWORD PTR tv134[ebp], 1
	je	SHORT $LN3@IsPotentia
	jmp	SHORT $LN4@IsPotentia
$LN3@IsPotentia:

; 1941 : 		{
; 1942 : 		case DEAL_NONRENEWABLE:
; 1943 : 			return false;

	mov	BYTE PTR $T234204[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	al, BYTE PTR $T234204[ebp]
	jmp	SHORT $LN9@IsPotentia
$LN2@IsPotentia:

; 1944 : 		case DEAL_RENEWABLE:
; 1945 : 			bHasValidTradeItem = true;

	mov	BYTE PTR _bHasValidTradeItem$[ebp], 1
$LN4@IsPotentia:

; 1946 : 			break;
; 1947 : 		case DEAL_SUPPLEMENTAL:
; 1948 : 			break;
; 1949 : 		}
; 1950 : 	}

	jmp	$LN7@IsPotentia
$LN6@IsPotentia:

; 1951 : 	return bHasValidTradeItem;

	mov	al, BYTE PTR _bHasValidTradeItem$[ebp]
	mov	BYTE PTR $T234205[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	al, BYTE PTR $T234205[ebp]
$LN9@IsPotentia:

; 1952 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?IsPotentiallyRenewable@CvDeal@@QAE_NXZ$0:
	lea	ecx, DWORD PTR _it$[ebp]
	jmp	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
__ehhandler$?IsPotentiallyRenewable@CvDeal@@QAE_NXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?IsPotentiallyRenewable@CvDeal@@QAE_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?IsPotentiallyRenewable@CvDeal@@QAE_NXZ ENDP		; CvDeal::IsPotentiallyRenewable
PUBLIC	?erase@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@V21@@Z ; FFastList<CvTradedItem,21,0>::erase
PUBLIC	?RemoveByType@CvDeal@@QAEXW4TradeableItems@@W4PlayerTypes@@@Z ; CvDeal::RemoveByType
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
xdata$x	SEGMENT
__unwindtable$?RemoveByType@CvDeal@@QAEXW4TradeableItems@@W4PlayerTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RemoveByType@CvDeal@@QAEXW4TradeableItems@@W4PlayerTypes@@@Z$0
__ehfuncinfo$?RemoveByType@CvDeal@@QAEXW4TradeableItems@@W4PlayerTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?RemoveByType@CvDeal@@QAEXW4TradeableItems@@W4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?RemoveByType@CvDeal@@QAEXW4TradeableItems@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
tv146 = -80						; size = 4
_this$ = -76						; size = 4
$T234517 = -72						; size = 4
$T234485 = -68						; size = 4
$T234462 = -64						; size = 4
$T234446 = -60						; size = 4
$T234442 = -56						; size = 4
$T234433 = -52						; size = 4
$T234381 = -48						; size = 8
$T234380 = -40						; size = 8
$T234379 = -29						; size = 1
$T234378 = -28						; size = 8
_it$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_eItemType$ = 8						; size = 4
_eFrom$ = 12						; size = 4
?RemoveByType@CvDeal@@QAEXW4TradeableItems@@W4PlayerTypes@@@Z PROC ; CvDeal::RemoveByType, COMDAT
; _this$ = ecx

; 1956 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?RemoveByType@CvDeal@@QAEXW4TradeableItems@@W4PlayerTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1957 : 	TradedItemList::iterator it;

	mov	DWORD PTR _it$[ebp], 0
	mov	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1958 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	eax, DWORD PTR $T234378[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv146[ebp], eax
	mov	ecx, DWORD PTR tv146[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _it$[ebp], edx
	mov	DWORD PTR _it$[ebp+4], eax
	jmp	SHORT $LN5@RemoveByTy
$LN4@RemoveByTy:
	cmp	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	jne	SHORT $LN31@RemoveByTy
	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _it$[ebp+4], edx
	jmp	SHORT $LN5@RemoveByTy
$LN31@RemoveByTy:
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T234433[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T234433[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T234442[ebp], ecx
	mov	eax, DWORD PTR $T234442[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T234446[ebp], ecx
	mov	edx, DWORD PTR $T234446[ebp]
	mov	DWORD PTR _it$[ebp+4], edx
$LN5@RemoveByTy:
	lea	eax, DWORD PTR $T234380[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T234462[ebp], eax
	mov	ecx, DWORD PTR $T234462[ebp]
	mov	edx, DWORD PTR _it$[ebp+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setne	al
	mov	BYTE PTR $T234379[ebp], al
	movzx	ecx, BYTE PTR $T234379[ebp]
	test	ecx, ecx
	je	SHORT $LN3@RemoveByTy

; 1959 : 	{
; 1960 : 		if(it->m_eItemType == eItemType &&
; 1961 : 		        (eFrom == NO_PLAYER || eFrom == it->m_eFromPlayer))

	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T234485[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T234485[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+eax+8]
	cmp	eax, DWORD PTR _eItemType$[ebp]
	jne	SHORT $LN2@RemoveByTy
	cmp	DWORD PTR _eFrom$[ebp], -1
	je	SHORT $LN1@RemoveByTy
	mov	ecx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T234517[ebp], ecx
	mov	edx, DWORD PTR _it$[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T234517[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR _eFrom$[ebp]
	cmp	eax, DWORD PTR [ecx+edx+36]
	jne	SHORT $LN2@RemoveByTy
$LN1@RemoveByTy:

; 1962 : 		{
; 1963 : 			m_TradedItems.erase(it);

	mov	ecx, DWORD PTR _it$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _it$[ebp]
	push	edx
	lea	eax, DWORD PTR $T234381[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?erase@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@V21@@Z ; FFastList<CvTradedItem,21,0>::erase

; 1964 : 			break;

	jmp	SHORT $LN3@RemoveByTy
$LN2@RemoveByTy:

; 1965 : 		}
; 1966 : 	}

	jmp	$LN4@RemoveByTy
$LN3@RemoveByTy:

; 1967 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RemoveByType@CvDeal@@QAEXW4TradeableItems@@W4PlayerTypes@@@Z$0:
	lea	ecx, DWORD PTR _it$[ebp]
	jmp	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
__ehhandler$?RemoveByType@CvDeal@@QAEXW4TradeableItems@@W4PlayerTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?RemoveByType@CvDeal@@QAEXW4TradeableItems@@W4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?RemoveByType@CvDeal@@QAEXW4TradeableItems@@W4PlayerTypes@@@Z ENDP ; CvDeal::RemoveByType
PUBLIC	?RemoveResourceTrade@CvDeal@@QAEXW4ResourceTypes@@@Z ; CvDeal::RemoveResourceTrade
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
xdata$x	SEGMENT
__unwindtable$?RemoveResourceTrade@CvDeal@@QAEXW4ResourceTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RemoveResourceTrade@CvDeal@@QAEXW4ResourceTypes@@@Z$0
__ehfuncinfo$?RemoveResourceTrade@CvDeal@@QAEXW4ResourceTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?RemoveResourceTrade@CvDeal@@QAEXW4ResourceTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?RemoveResourceTrade@CvDeal@@QAEXW4ResourceTypes@@@Z
_TEXT	SEGMENT
tv145 = -80						; size = 4
_this$ = -76						; size = 4
$T234725 = -72						; size = 4
$T234693 = -68						; size = 4
$T234670 = -64						; size = 4
$T234654 = -60						; size = 4
$T234650 = -56						; size = 4
$T234641 = -52						; size = 4
$T234589 = -48						; size = 8
$T234588 = -40						; size = 8
$T234587 = -29						; size = 1
$T234586 = -28						; size = 8
_it$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_eResource$ = 8						; size = 4
?RemoveResourceTrade@CvDeal@@QAEXW4ResourceTypes@@@Z PROC ; CvDeal::RemoveResourceTrade, COMDAT
; _this$ = ecx

; 1971 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?RemoveResourceTrade@CvDeal@@QAEXW4ResourceTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1972 : 	TradedItemList::iterator it;

	mov	DWORD PTR _it$[ebp], 0
	mov	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1973 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	eax, DWORD PTR $T234586[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv145[ebp], eax
	mov	ecx, DWORD PTR tv145[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _it$[ebp], edx
	mov	DWORD PTR _it$[ebp+4], eax
	jmp	SHORT $LN4@RemoveReso
$LN3@RemoveReso:
	cmp	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	jne	SHORT $LN30@RemoveReso
	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _it$[ebp+4], edx
	jmp	SHORT $LN4@RemoveReso
$LN30@RemoveReso:
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T234641[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T234641[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T234650[ebp], ecx
	mov	eax, DWORD PTR $T234650[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T234654[ebp], ecx
	mov	edx, DWORD PTR $T234654[ebp]
	mov	DWORD PTR _it$[ebp+4], edx
$LN4@RemoveReso:
	lea	eax, DWORD PTR $T234588[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T234670[ebp], eax
	mov	ecx, DWORD PTR $T234670[ebp]
	mov	edx, DWORD PTR _it$[ebp+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setne	al
	mov	BYTE PTR $T234587[ebp], al
	movzx	ecx, BYTE PTR $T234587[ebp]
	test	ecx, ecx
	je	SHORT $LN2@RemoveReso

; 1974 : 	{
; 1975 : 		if(it->m_eItemType == TRADE_ITEM_RESOURCES &&
; 1976 : 		        (ResourceTypes)it->m_iData1 == eResource)

	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T234693[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T234693[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+eax+8], 3
	jne	SHORT $LN1@RemoveReso
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T234725[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T234725[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+ecx+20]
	cmp	ecx, DWORD PTR _eResource$[ebp]
	jne	SHORT $LN1@RemoveReso

; 1977 : 		{
; 1978 : 			m_TradedItems.erase(it);

	mov	edx, DWORD PTR _it$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _it$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T234589[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?erase@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@V21@@Z ; FFastList<CvTradedItem,21,0>::erase

; 1979 : 			break;

	jmp	SHORT $LN2@RemoveReso
$LN1@RemoveReso:

; 1980 : 		}
; 1981 : 	}

	jmp	$LN3@RemoveReso
$LN2@RemoveReso:

; 1982 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RemoveResourceTrade@CvDeal@@QAEXW4ResourceTypes@@@Z$0:
	lea	ecx, DWORD PTR _it$[ebp]
	jmp	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
__ehhandler$?RemoveResourceTrade@CvDeal@@QAEXW4ResourceTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?RemoveResourceTrade@CvDeal@@QAEXW4ResourceTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?RemoveResourceTrade@CvDeal@@QAEXW4ResourceTypes@@@Z ENDP ; CvDeal::RemoveResourceTrade
PUBLIC	?RemoveCityTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z	; CvDeal::RemoveCityTrade
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
xdata$x	SEGMENT
__unwindtable$?RemoveCityTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RemoveCityTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z$0
__ehfuncinfo$?RemoveCityTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?RemoveCityTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?RemoveCityTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
tv166 = -112						; size = 4
_this$ = -108						; size = 4
$T235047 = -104						; size = 4
$T235038 = -100						; size = 4
$T235011 = -96						; size = 4
$T235005 = -92						; size = 4
$T234996 = -88						; size = 4
$T234969 = -84						; size = 4
$T234963 = -80						; size = 4
$T234933 = -76						; size = 4
$T234901 = -72						; size = 4
$T234878 = -68						; size = 4
$T234862 = -64						; size = 4
$T234858 = -60						; size = 4
$T234849 = -56						; size = 4
$T234797 = -52						; size = 8
$T234796 = -44						; size = 8
$T234795 = -33						; size = 1
$T234794 = -32						; size = 8
_pCity$221656 = -24					; size = 4
_it$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_eFrom$ = 8						; size = 4
_iCityID$ = 12						; size = 4
?RemoveCityTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z PROC	; CvDeal::RemoveCityTrade, COMDAT
; _this$ = ecx

; 1986 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?RemoveCityTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1987 : 	TradedItemList::iterator it;

	mov	DWORD PTR _it$[ebp], 0
	mov	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1988 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	eax, DWORD PTR $T234794[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv166[ebp], eax
	mov	ecx, DWORD PTR tv166[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _it$[ebp], edx
	mov	DWORD PTR _it$[ebp+4], eax
	jmp	SHORT $LN5@RemoveCity
$LN4@RemoveCity:
	cmp	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	jne	SHORT $LN31@RemoveCity
	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _it$[ebp+4], edx
	jmp	SHORT $LN5@RemoveCity
$LN31@RemoveCity:
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T234849[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T234849[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T234858[ebp], ecx
	mov	eax, DWORD PTR $T234858[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T234862[ebp], ecx
	mov	edx, DWORD PTR $T234862[ebp]
	mov	DWORD PTR _it$[ebp+4], edx
$LN5@RemoveCity:
	lea	eax, DWORD PTR $T234796[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T234878[ebp], eax
	mov	ecx, DWORD PTR $T234878[ebp]
	mov	edx, DWORD PTR _it$[ebp+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setne	al
	mov	BYTE PTR $T234795[ebp], al
	movzx	ecx, BYTE PTR $T234795[ebp]
	test	ecx, ecx
	je	$LN3@RemoveCity

; 1989 : 	{
; 1990 : 		if(it->m_eItemType == TRADE_ITEM_CITIES &&
; 1991 : 		        it->m_eFromPlayer == eFrom)

	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T234901[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T234901[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+eax+8], 4
	jne	$LN2@RemoveCity
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T234933[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T234933[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+ecx+36]
	cmp	ecx, DWORD PTR _eFrom$[ebp]
	jne	$LN2@RemoveCity

; 1992 : 		{
; 1993 : 			CvCity* pCity = GET_PLAYER(eFrom).getCity(iCityID);

	mov	edx, DWORD PTR _eFrom$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T234963[ebp], edx
	mov	eax, DWORD PTR _iCityID$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234963[ebp]
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	DWORD PTR _pCity$221656[ebp], eax

; 1994 : 			if(it->m_iData1 == pCity->getX() &&
; 1995 : 			        it->m_iData2 == pCity->getY())

	mov	ecx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T234969[ebp], ecx
	mov	edx, DWORD PTR _it$[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T234969[ebp]
	mov	ecx, DWORD PTR [eax+8]
	lea	edx, DWORD PTR [ecx+edx+8]
	mov	DWORD PTR $T234996[ebp], edx
	mov	eax, DWORD PTR _pCity$221656[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR $T235005[ebp], ecx
	mov	edx, DWORD PTR $T234996[ebp]
	mov	eax, DWORD PTR [edx+12]
	cmp	eax, DWORD PTR $T235005[ebp]
	jne	SHORT $LN2@RemoveCity
	mov	ecx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T235011[ebp], ecx
	mov	edx, DWORD PTR _it$[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T235011[ebp]
	mov	ecx, DWORD PTR [eax+8]
	lea	edx, DWORD PTR [ecx+edx+8]
	mov	DWORD PTR $T235038[ebp], edx
	mov	eax, DWORD PTR _pCity$221656[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR $T235047[ebp], ecx
	mov	edx, DWORD PTR $T235038[ebp]
	mov	eax, DWORD PTR [edx+16]
	cmp	eax, DWORD PTR $T235047[ebp]
	jne	SHORT $LN2@RemoveCity

; 1996 : 			{
; 1997 : 				m_TradedItems.erase(it);

	mov	ecx, DWORD PTR _it$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _it$[ebp]
	push	edx
	lea	eax, DWORD PTR $T234797[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?erase@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@V21@@Z ; FFastList<CvTradedItem,21,0>::erase

; 1998 : 				return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	jmp	SHORT $LN6@RemoveCity
$LN2@RemoveCity:

; 1999 : 			}
; 2000 : 		}
; 2001 : 	}

	jmp	$LN4@RemoveCity
$LN3@RemoveCity:

; 2002 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN6@RemoveCity:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RemoveCityTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z$0:
	lea	ecx, DWORD PTR _it$[ebp]
	jmp	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
__ehhandler$?RemoveCityTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-104]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?RemoveCityTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?RemoveCityTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z ENDP	; CvDeal::RemoveCityTrade
PUBLIC	?RemoveUnitTrade@CvDeal@@QAEXH@Z		; CvDeal::RemoveUnitTrade
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
xdata$x	SEGMENT
__unwindtable$?RemoveUnitTrade@CvDeal@@QAEXH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RemoveUnitTrade@CvDeal@@QAEXH@Z$0
__ehfuncinfo$?RemoveUnitTrade@CvDeal@@QAEXH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?RemoveUnitTrade@CvDeal@@QAEXH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?RemoveUnitTrade@CvDeal@@QAEXH@Z
_TEXT	SEGMENT
tv145 = -80						; size = 4
_this$ = -76						; size = 4
$T235246 = -72						; size = 4
$T235214 = -68						; size = 4
$T235191 = -64						; size = 4
$T235175 = -60						; size = 4
$T235171 = -56						; size = 4
$T235162 = -52						; size = 4
$T235110 = -48						; size = 8
$T235109 = -40						; size = 8
$T235108 = -29						; size = 1
$T235107 = -28						; size = 8
_it$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_iUnitID$ = 8						; size = 4
?RemoveUnitTrade@CvDeal@@QAEXH@Z PROC			; CvDeal::RemoveUnitTrade, COMDAT
; _this$ = ecx

; 2006 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?RemoveUnitTrade@CvDeal@@QAEXH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2007 : 	TradedItemList::iterator it;

	mov	DWORD PTR _it$[ebp], 0
	mov	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2008 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	eax, DWORD PTR $T235107[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv145[ebp], eax
	mov	ecx, DWORD PTR tv145[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _it$[ebp], edx
	mov	DWORD PTR _it$[ebp+4], eax
	jmp	SHORT $LN4@RemoveUnit
$LN3@RemoveUnit:
	cmp	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	jne	SHORT $LN30@RemoveUnit
	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _it$[ebp+4], edx
	jmp	SHORT $LN4@RemoveUnit
$LN30@RemoveUnit:
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T235162[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T235162[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T235171[ebp], ecx
	mov	eax, DWORD PTR $T235171[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T235175[ebp], ecx
	mov	edx, DWORD PTR $T235175[ebp]
	mov	DWORD PTR _it$[ebp+4], edx
$LN4@RemoveUnit:
	lea	eax, DWORD PTR $T235109[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T235191[ebp], eax
	mov	ecx, DWORD PTR $T235191[ebp]
	mov	edx, DWORD PTR _it$[ebp+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setne	al
	mov	BYTE PTR $T235108[ebp], al
	movzx	ecx, BYTE PTR $T235108[ebp]
	test	ecx, ecx
	je	SHORT $LN2@RemoveUnit

; 2009 : 	{
; 2010 : 		if(it->m_eItemType == TRADE_ITEM_UNITS &&
; 2011 : 		        it->m_iData1 == iUnitID)

	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T235214[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T235214[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+eax+8], 5
	jne	SHORT $LN1@RemoveUnit
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T235246[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T235246[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+ecx+20]
	cmp	ecx, DWORD PTR _iUnitID$[ebp]
	jne	SHORT $LN1@RemoveUnit

; 2012 : 		{
; 2013 : 			m_TradedItems.erase(it);

	mov	edx, DWORD PTR _it$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _it$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T235110[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?erase@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@V21@@Z ; FFastList<CvTradedItem,21,0>::erase

; 2014 : 			break;

	jmp	SHORT $LN2@RemoveUnit
$LN1@RemoveUnit:

; 2015 : 		}
; 2016 : 	}

	jmp	$LN3@RemoveUnit
$LN2@RemoveUnit:

; 2017 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RemoveUnitTrade@CvDeal@@QAEXH@Z$0:
	lea	ecx, DWORD PTR _it$[ebp]
	jmp	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
__ehhandler$?RemoveUnitTrade@CvDeal@@QAEXH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?RemoveUnitTrade@CvDeal@@QAEXH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?RemoveUnitTrade@CvDeal@@QAEXH@Z ENDP			; CvDeal::RemoveUnitTrade
PUBLIC	?RemoveThirdPartyPeace@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z ; CvDeal::RemoveThirdPartyPeace
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
xdata$x	SEGMENT
__unwindtable$?RemoveThirdPartyPeace@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RemoveThirdPartyPeace@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z$0
__ehfuncinfo$?RemoveThirdPartyPeace@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?RemoveThirdPartyPeace@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?RemoveThirdPartyPeace@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z
_TEXT	SEGMENT
tv149 = -84						; size = 4
_this$ = -80						; size = 4
$T235486 = -76						; size = 4
$T235454 = -72						; size = 4
$T235422 = -68						; size = 4
$T235399 = -64						; size = 4
$T235383 = -60						; size = 4
$T235379 = -56						; size = 4
$T235370 = -52						; size = 4
$T235318 = -48						; size = 8
$T235317 = -40						; size = 8
$T235316 = -29						; size = 1
$T235315 = -28						; size = 8
_it$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_eFrom$ = 8						; size = 4
_eThirdPartyTeam$ = 12					; size = 4
?RemoveThirdPartyPeace@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z PROC ; CvDeal::RemoveThirdPartyPeace, COMDAT
; _this$ = ecx

; 2021 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?RemoveThirdPartyPeace@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2022 : 	TradedItemList::iterator it;

	mov	DWORD PTR _it$[ebp], 0
	mov	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2023 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	eax, DWORD PTR $T235315[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv149[ebp], eax
	mov	ecx, DWORD PTR tv149[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _it$[ebp], edx
	mov	DWORD PTR _it$[ebp+4], eax
	jmp	SHORT $LN4@RemoveThir
$LN3@RemoveThir:
	cmp	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	jne	SHORT $LN30@RemoveThir
	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _it$[ebp+4], edx
	jmp	SHORT $LN4@RemoveThir
$LN30@RemoveThir:
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T235370[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T235370[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T235379[ebp], ecx
	mov	eax, DWORD PTR $T235379[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T235383[ebp], ecx
	mov	edx, DWORD PTR $T235383[ebp]
	mov	DWORD PTR _it$[ebp+4], edx
$LN4@RemoveThir:
	lea	eax, DWORD PTR $T235317[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T235399[ebp], eax
	mov	ecx, DWORD PTR $T235399[ebp]
	mov	edx, DWORD PTR _it$[ebp+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setne	al
	mov	BYTE PTR $T235316[ebp], al
	movzx	ecx, BYTE PTR $T235316[ebp]
	test	ecx, ecx
	je	SHORT $LN2@RemoveThir

; 2024 : 	{
; 2025 : 		if(it->m_eItemType == TRADE_ITEM_THIRD_PARTY_PEACE &&
; 2026 : 		        (TeamTypes)it->m_iData1 == eThirdPartyTeam &&
; 2027 : 		        (PlayerTypes)it->m_eFromPlayer == eFrom)

	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T235422[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T235422[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+eax+8], 14		; 0000000eH
	jne	SHORT $LN1@RemoveThir
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T235454[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T235454[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+ecx+20]
	cmp	ecx, DWORD PTR _eThirdPartyTeam$[ebp]
	jne	SHORT $LN1@RemoveThir
	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T235486[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T235486[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+eax+36]
	cmp	eax, DWORD PTR _eFrom$[ebp]
	jne	SHORT $LN1@RemoveThir

; 2028 : 		{
; 2029 : 			m_TradedItems.erase(it);

	mov	ecx, DWORD PTR _it$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _it$[ebp]
	push	edx
	lea	eax, DWORD PTR $T235318[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?erase@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@V21@@Z ; FFastList<CvTradedItem,21,0>::erase

; 2030 : 			break;

	jmp	SHORT $LN2@RemoveThir
$LN1@RemoveThir:

; 2031 : 		}
; 2032 : 	}

	jmp	$LN3@RemoveThir
$LN2@RemoveThir:

; 2033 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RemoveThirdPartyPeace@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z$0:
	lea	ecx, DWORD PTR _it$[ebp]
	jmp	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
__ehhandler$?RemoveThirdPartyPeace@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?RemoveThirdPartyPeace@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?RemoveThirdPartyPeace@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z ENDP ; CvDeal::RemoveThirdPartyPeace
PUBLIC	?RemoveThirdPartyWar@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z ; CvDeal::RemoveThirdPartyWar
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
xdata$x	SEGMENT
__unwindtable$?RemoveThirdPartyWar@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RemoveThirdPartyWar@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z$0
__ehfuncinfo$?RemoveThirdPartyWar@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?RemoveThirdPartyWar@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?RemoveThirdPartyWar@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z
_TEXT	SEGMENT
tv149 = -84						; size = 4
_this$ = -80						; size = 4
$T235726 = -76						; size = 4
$T235694 = -72						; size = 4
$T235662 = -68						; size = 4
$T235639 = -64						; size = 4
$T235623 = -60						; size = 4
$T235619 = -56						; size = 4
$T235610 = -52						; size = 4
$T235558 = -48						; size = 8
$T235557 = -40						; size = 8
$T235556 = -29						; size = 1
$T235555 = -28						; size = 8
_it$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_eFrom$ = 8						; size = 4
_eThirdPartyTeam$ = 12					; size = 4
?RemoveThirdPartyWar@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z PROC ; CvDeal::RemoveThirdPartyWar, COMDAT
; _this$ = ecx

; 2037 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?RemoveThirdPartyWar@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2038 : 	TradedItemList::iterator it;

	mov	DWORD PTR _it$[ebp], 0
	mov	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2039 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	eax, DWORD PTR $T235555[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv149[ebp], eax
	mov	ecx, DWORD PTR tv149[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _it$[ebp], edx
	mov	DWORD PTR _it$[ebp+4], eax
	jmp	SHORT $LN4@RemoveThir@2
$LN3@RemoveThir@2:
	cmp	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	jne	SHORT $LN30@RemoveThir@2
	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _it$[ebp+4], edx
	jmp	SHORT $LN4@RemoveThir@2
$LN30@RemoveThir@2:
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T235610[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T235610[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T235619[ebp], ecx
	mov	eax, DWORD PTR $T235619[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T235623[ebp], ecx
	mov	edx, DWORD PTR $T235623[ebp]
	mov	DWORD PTR _it$[ebp+4], edx
$LN4@RemoveThir@2:
	lea	eax, DWORD PTR $T235557[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T235639[ebp], eax
	mov	ecx, DWORD PTR $T235639[ebp]
	mov	edx, DWORD PTR _it$[ebp+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setne	al
	mov	BYTE PTR $T235556[ebp], al
	movzx	ecx, BYTE PTR $T235556[ebp]
	test	ecx, ecx
	je	SHORT $LN2@RemoveThir@2

; 2040 : 	{
; 2041 : 		if(it->m_eItemType == TRADE_ITEM_THIRD_PARTY_WAR &&
; 2042 : #ifdef AUI_WARNING_FIXES
; 2043 : 				(TeamTypes)it->m_iData1 == eThirdPartyTeam &&
; 2044 : #else
; 2045 : 		        (PlayerTypes)it->m_iData1 == eThirdPartyTeam &&
; 2046 : #endif
; 2047 : 		        (PlayerTypes)it->m_eFromPlayer == eFrom)

	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T235662[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T235662[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+eax+8], 15		; 0000000fH
	jne	SHORT $LN1@RemoveThir@2
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T235694[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T235694[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+ecx+20]
	cmp	ecx, DWORD PTR _eThirdPartyTeam$[ebp]
	jne	SHORT $LN1@RemoveThir@2
	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T235726[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T235726[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+eax+36]
	cmp	eax, DWORD PTR _eFrom$[ebp]
	jne	SHORT $LN1@RemoveThir@2

; 2048 : 		{
; 2049 : 			m_TradedItems.erase(it);

	mov	ecx, DWORD PTR _it$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _it$[ebp]
	push	edx
	lea	eax, DWORD PTR $T235558[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?erase@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@V21@@Z ; FFastList<CvTradedItem,21,0>::erase

; 2050 : 			break;

	jmp	SHORT $LN2@RemoveThir@2
$LN1@RemoveThir@2:

; 2051 : 		}
; 2052 : 	}

	jmp	$LN3@RemoveThir@2
$LN2@RemoveThir@2:

; 2053 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RemoveThirdPartyWar@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z$0:
	lea	ecx, DWORD PTR _it$[ebp]
	jmp	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
__ehhandler$?RemoveThirdPartyWar@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?RemoveThirdPartyWar@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?RemoveThirdPartyWar@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z ENDP ; CvDeal::RemoveThirdPartyWar
PUBLIC	?RemoveThirdPartyEmbargo@CvDeal@@QAEXW4PlayerTypes@@0@Z ; CvDeal::RemoveThirdPartyEmbargo
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
xdata$x	SEGMENT
__unwindtable$?RemoveThirdPartyEmbargo@CvDeal@@QAEXW4PlayerTypes@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RemoveThirdPartyEmbargo@CvDeal@@QAEXW4PlayerTypes@@0@Z$0
__ehfuncinfo$?RemoveThirdPartyEmbargo@CvDeal@@QAEXW4PlayerTypes@@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?RemoveThirdPartyEmbargo@CvDeal@@QAEXW4PlayerTypes@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?RemoveThirdPartyEmbargo@CvDeal@@QAEXW4PlayerTypes@@0@Z
_TEXT	SEGMENT
tv149 = -84						; size = 4
_this$ = -80						; size = 4
$T235966 = -76						; size = 4
$T235934 = -72						; size = 4
$T235902 = -68						; size = 4
$T235879 = -64						; size = 4
$T235863 = -60						; size = 4
$T235859 = -56						; size = 4
$T235850 = -52						; size = 4
$T235798 = -48						; size = 8
$T235797 = -40						; size = 8
$T235796 = -29						; size = 1
$T235795 = -28						; size = 8
_it$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_eFrom$ = 8						; size = 4
_eThirdParty$ = 12					; size = 4
?RemoveThirdPartyEmbargo@CvDeal@@QAEXW4PlayerTypes@@0@Z PROC ; CvDeal::RemoveThirdPartyEmbargo, COMDAT
; _this$ = ecx

; 2057 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?RemoveThirdPartyEmbargo@CvDeal@@QAEXW4PlayerTypes@@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2058 : 	TradedItemList::iterator it;

	mov	DWORD PTR _it$[ebp], 0
	mov	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2059 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	eax, DWORD PTR $T235795[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv149[ebp], eax
	mov	ecx, DWORD PTR tv149[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _it$[ebp], edx
	mov	DWORD PTR _it$[ebp+4], eax
	jmp	SHORT $LN4@RemoveThir@3
$LN3@RemoveThir@3:
	cmp	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	jne	SHORT $LN30@RemoveThir@3
	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _it$[ebp+4], edx
	jmp	SHORT $LN4@RemoveThir@3
$LN30@RemoveThir@3:
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T235850[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T235850[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T235859[ebp], ecx
	mov	eax, DWORD PTR $T235859[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T235863[ebp], ecx
	mov	edx, DWORD PTR $T235863[ebp]
	mov	DWORD PTR _it$[ebp+4], edx
$LN4@RemoveThir@3:
	lea	eax, DWORD PTR $T235797[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T235879[ebp], eax
	mov	ecx, DWORD PTR $T235879[ebp]
	mov	edx, DWORD PTR _it$[ebp+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setne	al
	mov	BYTE PTR $T235796[ebp], al
	movzx	ecx, BYTE PTR $T235796[ebp]
	test	ecx, ecx
	je	SHORT $LN2@RemoveThir@3

; 2060 : 	{
; 2061 : 		if(it->m_eItemType == TRADE_ITEM_THIRD_PARTY_EMBARGO &&
; 2062 : 		        (PlayerTypes)it->m_iData1 == eThirdParty &&
; 2063 : 		        (PlayerTypes)it->m_eFromPlayer == eFrom)

	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T235902[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T235902[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+eax+8], 16		; 00000010H
	jne	SHORT $LN1@RemoveThir@3
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T235934[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T235934[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+ecx+20]
	cmp	ecx, DWORD PTR _eThirdParty$[ebp]
	jne	SHORT $LN1@RemoveThir@3
	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T235966[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T235966[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+eax+36]
	cmp	eax, DWORD PTR _eFrom$[ebp]
	jne	SHORT $LN1@RemoveThir@3

; 2064 : 		{
; 2065 : 			m_TradedItems.erase(it);

	mov	ecx, DWORD PTR _it$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _it$[ebp]
	push	edx
	lea	eax, DWORD PTR $T235798[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?erase@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@V21@@Z ; FFastList<CvTradedItem,21,0>::erase

; 2066 : 			break;

	jmp	SHORT $LN2@RemoveThir@3
$LN1@RemoveThir@3:

; 2067 : 		}
; 2068 : 	}

	jmp	$LN3@RemoveThir@3
$LN2@RemoveThir@3:

; 2069 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RemoveThirdPartyEmbargo@CvDeal@@QAEXW4PlayerTypes@@0@Z$0:
	lea	ecx, DWORD PTR _it$[ebp]
	jmp	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
__ehhandler$?RemoveThirdPartyEmbargo@CvDeal@@QAEXW4PlayerTypes@@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?RemoveThirdPartyEmbargo@CvDeal@@QAEXW4PlayerTypes@@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?RemoveThirdPartyEmbargo@CvDeal@@QAEXW4PlayerTypes@@0@Z ENDP ; CvDeal::RemoveThirdPartyEmbargo
PUBLIC	?RemoveVoteCommitment@CvDeal@@QAEXW4PlayerTypes@@HHH_N@Z ; CvDeal::RemoveVoteCommitment
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
xdata$x	SEGMENT
__unwindtable$?RemoveVoteCommitment@CvDeal@@QAEXW4PlayerTypes@@HHH_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RemoveVoteCommitment@CvDeal@@QAEXW4PlayerTypes@@HHH_N@Z$0
__ehfuncinfo$?RemoveVoteCommitment@CvDeal@@QAEXW4PlayerTypes@@HHH_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?RemoveVoteCommitment@CvDeal@@QAEXW4PlayerTypes@@HHH_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?RemoveVoteCommitment@CvDeal@@QAEXW4PlayerTypes@@HHH_N@Z
_TEXT	SEGMENT
tv163 = -96						; size = 4
_this$ = -92						; size = 4
$T236302 = -88						; size = 4
$T236270 = -84						; size = 4
$T236238 = -80						; size = 4
$T236206 = -76						; size = 4
$T236174 = -72						; size = 4
$T236142 = -68						; size = 4
$T236119 = -64						; size = 4
$T236103 = -60						; size = 4
$T236099 = -56						; size = 4
$T236090 = -52						; size = 4
$T236038 = -48						; size = 8
$T236037 = -40						; size = 8
$T236036 = -29						; size = 1
$T236035 = -28						; size = 8
_it$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_eFrom$ = 8						; size = 4
_iResolutionID$ = 12					; size = 4
_iVoteChoice$ = 16					; size = 4
_iNumVotes$ = 20					; size = 4
_bRepeal$ = 24						; size = 1
?RemoveVoteCommitment@CvDeal@@QAEXW4PlayerTypes@@HHH_N@Z PROC ; CvDeal::RemoveVoteCommitment, COMDAT
; _this$ = ecx

; 2073 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?RemoveVoteCommitment@CvDeal@@QAEXW4PlayerTypes@@HHH_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2074 : 	TradedItemList::iterator it;

	mov	DWORD PTR _it$[ebp], 0
	mov	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2075 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	eax, DWORD PTR $T236035[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv163[ebp], eax
	mov	ecx, DWORD PTR tv163[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _it$[ebp], edx
	mov	DWORD PTR _it$[ebp+4], eax
	jmp	SHORT $LN4@RemoveVote
$LN3@RemoveVote:
	cmp	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	jne	SHORT $LN30@RemoveVote
	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _it$[ebp+4], edx
	jmp	SHORT $LN4@RemoveVote
$LN30@RemoveVote:
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T236090[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T236090[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T236099[ebp], ecx
	mov	eax, DWORD PTR $T236099[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T236103[ebp], ecx
	mov	edx, DWORD PTR $T236103[ebp]
	mov	DWORD PTR _it$[ebp+4], edx
$LN4@RemoveVote:
	lea	eax, DWORD PTR $T236037[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T236119[ebp], eax
	mov	ecx, DWORD PTR $T236119[ebp]
	mov	edx, DWORD PTR _it$[ebp+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setne	al
	mov	BYTE PTR $T236036[ebp], al
	movzx	ecx, BYTE PTR $T236036[ebp]
	test	ecx, ecx
	je	$LN2@RemoveVote

; 2076 : 	{
; 2077 : 		if(it->m_eItemType == TRADE_ITEM_VOTE_COMMITMENT &&
; 2078 : 			it->m_eFromPlayer == eFrom &&
; 2079 : 			it->m_iData1 == iResolutionID &&
; 2080 : 			it->m_iData2 == iVoteChoice &&
; 2081 : 			it->m_iData3 == iNumVotes &&
; 2082 : 			it->m_bFlag1 == bRepeal)

	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T236142[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T236142[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+eax+8], 19		; 00000013H
	jne	$LN1@RemoveVote
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T236174[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T236174[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+ecx+36]
	cmp	ecx, DWORD PTR _eFrom$[ebp]
	jne	$LN1@RemoveVote
	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T236206[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T236206[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+eax+20]
	cmp	eax, DWORD PTR _iResolutionID$[ebp]
	jne	SHORT $LN1@RemoveVote
	mov	ecx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T236238[ebp], ecx
	mov	edx, DWORD PTR _it$[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T236238[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+edx+24]
	cmp	edx, DWORD PTR _iVoteChoice$[ebp]
	jne	SHORT $LN1@RemoveVote
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T236270[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T236270[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+ecx+28]
	cmp	ecx, DWORD PTR _iNumVotes$[ebp]
	jne	SHORT $LN1@RemoveVote
	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T236302[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T236302[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movzx	eax, BYTE PTR [edx+eax+32]
	movzx	ecx, BYTE PTR _bRepeal$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN1@RemoveVote

; 2083 : 		{
; 2084 : 			m_TradedItems.erase(it);

	mov	edx, DWORD PTR _it$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _it$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T236038[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?erase@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@V21@@Z ; FFastList<CvTradedItem,21,0>::erase

; 2085 : 			break;

	jmp	SHORT $LN2@RemoveVote
$LN1@RemoveVote:

; 2086 : 		}
; 2087 : 	}

	jmp	$LN3@RemoveVote
$LN2@RemoveVote:

; 2088 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RemoveVoteCommitment@CvDeal@@QAEXW4PlayerTypes@@HHH_N@Z$0:
	lea	ecx, DWORD PTR _it$[ebp]
	jmp	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
__ehhandler$?RemoveVoteCommitment@CvDeal@@QAEXW4PlayerTypes@@HHH_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-88]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?RemoveVoteCommitment@CvDeal@@QAEXW4PlayerTypes@@HHH_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?RemoveVoteCommitment@CvDeal@@QAEXW4PlayerTypes@@HHH_N@Z ENDP ; CvDeal::RemoveVoteCommitment
PUBLIC	?ChangeThirdPartyWarDuration@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z ; CvDeal::ChangeThirdPartyWarDuration
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
xdata$x	SEGMENT
__unwindtable$?ChangeThirdPartyWarDuration@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ChangeThirdPartyWarDuration@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z$0
__ehfuncinfo$?ChangeThirdPartyWarDuration@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ChangeThirdPartyWarDuration@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?ChangeThirdPartyWarDuration@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z
_TEXT	SEGMENT
tv146 = -80						; size = 4
_this$ = -76						; size = 4
$T236572 = -72						; size = 4
$T236540 = -68						; size = 4
$T236508 = -64						; size = 4
$T236476 = -60						; size = 4
$T236453 = -56						; size = 4
$T236437 = -52						; size = 4
$T236433 = -48						; size = 4
$T236424 = -44						; size = 4
$T236373 = -40						; size = 8
$T236372 = -29						; size = 1
$T236371 = -28						; size = 8
_it$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_eFrom$ = 8						; size = 4
_eThirdPartyTeam$ = 12					; size = 4
_iNewDuration$ = 16					; size = 4
?ChangeThirdPartyWarDuration@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z PROC ; CvDeal::ChangeThirdPartyWarDuration, COMDAT
; _this$ = ecx

; 2091 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ChangeThirdPartyWarDuration@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2092 : 	TradedItemList::iterator it;

	mov	DWORD PTR _it$[ebp], 0
	mov	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2093 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	eax, DWORD PTR $T236371[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv146[ebp], eax
	mov	ecx, DWORD PTR tv146[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _it$[ebp], edx
	mov	DWORD PTR _it$[ebp+4], eax
	jmp	SHORT $LN4@ChangeThir
$LN3@ChangeThir:
	cmp	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	jne	SHORT $LN29@ChangeThir
	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _it$[ebp+4], edx
	jmp	SHORT $LN4@ChangeThir
$LN29@ChangeThir:
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T236424[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T236424[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T236433[ebp], ecx
	mov	eax, DWORD PTR $T236433[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T236437[ebp], ecx
	mov	edx, DWORD PTR $T236437[ebp]
	mov	DWORD PTR _it$[ebp+4], edx
$LN4@ChangeThir:
	lea	eax, DWORD PTR $T236373[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T236453[ebp], eax
	mov	ecx, DWORD PTR $T236453[ebp]
	mov	edx, DWORD PTR _it$[ebp+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setne	al
	mov	BYTE PTR $T236372[ebp], al
	movzx	ecx, BYTE PTR $T236372[ebp]
	test	ecx, ecx
	je	SHORT $LN2@ChangeThir

; 2094 : 	{
; 2095 : 		if(it->m_eItemType == TRADE_ITEM_THIRD_PARTY_WAR &&
; 2096 : #ifdef AUI_WARNING_FIXES
; 2097 : 				(TeamTypes)it->m_iData1 == eThirdPartyTeam &&
; 2098 : #else
; 2099 : 		        (PlayerTypes)it->m_iData1 == eThirdPartyTeam &&
; 2100 : #endif
; 2101 : 		        (PlayerTypes)it->m_eFromPlayer == eFrom)

	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T236476[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T236476[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+eax+8], 15		; 0000000fH
	jne	SHORT $LN1@ChangeThir
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T236508[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T236508[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+ecx+20]
	cmp	ecx, DWORD PTR _eThirdPartyTeam$[ebp]
	jne	SHORT $LN1@ChangeThir
	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T236540[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T236540[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+eax+36]
	cmp	eax, DWORD PTR _eFrom$[ebp]
	jne	SHORT $LN1@ChangeThir

; 2102 : 		{
; 2103 : 			it->m_iDuration = iNewDuration;

	mov	ecx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T236572[ebp], ecx
	mov	edx, DWORD PTR _it$[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T236572[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR _iNewDuration$[ebp]
	mov	DWORD PTR [ecx+edx+12], eax

; 2104 : 			break;

	jmp	SHORT $LN2@ChangeThir
$LN1@ChangeThir:

; 2105 : 		}
; 2106 : 	}

	jmp	$LN3@ChangeThir
$LN2@ChangeThir:

; 2107 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ChangeThirdPartyWarDuration@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z$0:
	lea	ecx, DWORD PTR _it$[ebp]
	jmp	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
__ehhandler$?ChangeThirdPartyWarDuration@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ChangeThirdPartyWarDuration@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ChangeThirdPartyWarDuration@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z ENDP ; CvDeal::ChangeThirdPartyWarDuration
PUBLIC	?ChangeThirdPartyPeaceDuration@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z ; CvDeal::ChangeThirdPartyPeaceDuration
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
xdata$x	SEGMENT
__unwindtable$?ChangeThirdPartyPeaceDuration@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ChangeThirdPartyPeaceDuration@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z$0
__ehfuncinfo$?ChangeThirdPartyPeaceDuration@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ChangeThirdPartyPeaceDuration@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?ChangeThirdPartyPeaceDuration@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z
_TEXT	SEGMENT
tv146 = -80						; size = 4
_this$ = -76						; size = 4
$T236825 = -72						; size = 4
$T236793 = -68						; size = 4
$T236761 = -64						; size = 4
$T236729 = -60						; size = 4
$T236706 = -56						; size = 4
$T236690 = -52						; size = 4
$T236686 = -48						; size = 4
$T236677 = -44						; size = 4
$T236626 = -40						; size = 8
$T236625 = -29						; size = 1
$T236624 = -28						; size = 8
_it$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_eFrom$ = 8						; size = 4
_eThirdPartyTeam$ = 12					; size = 4
_iNewDuration$ = 16					; size = 4
?ChangeThirdPartyPeaceDuration@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z PROC ; CvDeal::ChangeThirdPartyPeaceDuration, COMDAT
; _this$ = ecx

; 2111 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ChangeThirdPartyPeaceDuration@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2112 : 	CvAssertMsg(iNewDuration >= 0, "DEAL: Trying to add a negative duration to a TradeItem.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 2113 : 	CvAssertMsg(iNewDuration < GC.getGame().getEstimateEndTurn() * 2, "DEAL: Trade item has a crazy long duration (probably invalid).  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 2114 : 
; 2115 : 	TradedItemList::iterator it;

	mov	DWORD PTR _it$[ebp], 0
	mov	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2116 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	eax, DWORD PTR $T236624[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv146[ebp], eax
	mov	ecx, DWORD PTR tv146[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _it$[ebp], edx
	mov	DWORD PTR _it$[ebp+4], eax
	jmp	SHORT $LN4@ChangeThir@2
$LN3@ChangeThir@2:
	cmp	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	jne	SHORT $LN29@ChangeThir@2
	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _it$[ebp+4], edx
	jmp	SHORT $LN4@ChangeThir@2
$LN29@ChangeThir@2:
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T236677[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T236677[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T236686[ebp], ecx
	mov	eax, DWORD PTR $T236686[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T236690[ebp], ecx
	mov	edx, DWORD PTR $T236690[ebp]
	mov	DWORD PTR _it$[ebp+4], edx
$LN4@ChangeThir@2:
	lea	eax, DWORD PTR $T236626[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T236706[ebp], eax
	mov	ecx, DWORD PTR $T236706[ebp]
	mov	edx, DWORD PTR _it$[ebp+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setne	al
	mov	BYTE PTR $T236625[ebp], al
	movzx	ecx, BYTE PTR $T236625[ebp]
	test	ecx, ecx
	je	SHORT $LN2@ChangeThir@2

; 2117 : 	{
; 2118 : 		if(it->m_eItemType == TRADE_ITEM_THIRD_PARTY_PEACE &&
; 2119 : 		        (TeamTypes)it->m_iData1 == eThirdPartyTeam &&
; 2120 : 		        (PlayerTypes)it->m_eFromPlayer == eFrom)

	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T236729[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T236729[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+eax+8], 14		; 0000000eH
	jne	SHORT $LN1@ChangeThir@2
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T236761[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T236761[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+ecx+20]
	cmp	ecx, DWORD PTR _eThirdPartyTeam$[ebp]
	jne	SHORT $LN1@ChangeThir@2
	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T236793[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T236793[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+eax+36]
	cmp	eax, DWORD PTR _eFrom$[ebp]
	jne	SHORT $LN1@ChangeThir@2

; 2121 : 		{
; 2122 : 			it->m_iDuration = iNewDuration;

	mov	ecx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T236825[ebp], ecx
	mov	edx, DWORD PTR _it$[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T236825[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR _iNewDuration$[ebp]
	mov	DWORD PTR [ecx+edx+12], eax

; 2123 : 			break;

	jmp	SHORT $LN2@ChangeThir@2
$LN1@ChangeThir@2:

; 2124 : 		}
; 2125 : 	}

	jmp	$LN3@ChangeThir@2
$LN2@ChangeThir@2:

; 2126 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ChangeThirdPartyPeaceDuration@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z$0:
	lea	ecx, DWORD PTR _it$[ebp]
	jmp	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
__ehhandler$?ChangeThirdPartyPeaceDuration@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ChangeThirdPartyPeaceDuration@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ChangeThirdPartyPeaceDuration@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z ENDP ; CvDeal::ChangeThirdPartyPeaceDuration
PUBLIC	?ChangeThirdPartyEmbargoDuration@CvDeal@@QAEXW4PlayerTypes@@0H@Z ; CvDeal::ChangeThirdPartyEmbargoDuration
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
xdata$x	SEGMENT
__unwindtable$?ChangeThirdPartyEmbargoDuration@CvDeal@@QAEXW4PlayerTypes@@0H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ChangeThirdPartyEmbargoDuration@CvDeal@@QAEXW4PlayerTypes@@0H@Z$0
__ehfuncinfo$?ChangeThirdPartyEmbargoDuration@CvDeal@@QAEXW4PlayerTypes@@0H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ChangeThirdPartyEmbargoDuration@CvDeal@@QAEXW4PlayerTypes@@0H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?ChangeThirdPartyEmbargoDuration@CvDeal@@QAEXW4PlayerTypes@@0H@Z
_TEXT	SEGMENT
tv146 = -80						; size = 4
_this$ = -76						; size = 4
$T237078 = -72						; size = 4
$T237046 = -68						; size = 4
$T237014 = -64						; size = 4
$T236982 = -60						; size = 4
$T236959 = -56						; size = 4
$T236943 = -52						; size = 4
$T236939 = -48						; size = 4
$T236930 = -44						; size = 4
$T236879 = -40						; size = 8
$T236878 = -29						; size = 1
$T236877 = -28						; size = 8
_it$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_eFrom$ = 8						; size = 4
_eThirdParty$ = 12					; size = 4
_iNewDuration$ = 16					; size = 4
?ChangeThirdPartyEmbargoDuration@CvDeal@@QAEXW4PlayerTypes@@0H@Z PROC ; CvDeal::ChangeThirdPartyEmbargoDuration, COMDAT
; _this$ = ecx

; 2129 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ChangeThirdPartyEmbargoDuration@CvDeal@@QAEXW4PlayerTypes@@0H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2130 : 	CvAssertMsg(iNewDuration >= 0, "DEAL: Trying to add a negative duration to a TradeItem.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 2131 : 	CvAssertMsg(iNewDuration < GC.getGame().getEstimateEndTurn() * 2, "DEAL: Trade item has a crazy long duration (probably invalid).  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 2132 : 
; 2133 : 	TradedItemList::iterator it;

	mov	DWORD PTR _it$[ebp], 0
	mov	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2134 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	eax, DWORD PTR $T236877[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv146[ebp], eax
	mov	ecx, DWORD PTR tv146[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _it$[ebp], edx
	mov	DWORD PTR _it$[ebp+4], eax
	jmp	SHORT $LN4@ChangeThir@3
$LN3@ChangeThir@3:
	cmp	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	jne	SHORT $LN29@ChangeThir@3
	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _it$[ebp+4], edx
	jmp	SHORT $LN4@ChangeThir@3
$LN29@ChangeThir@3:
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T236930[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T236930[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T236939[ebp], ecx
	mov	eax, DWORD PTR $T236939[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T236943[ebp], ecx
	mov	edx, DWORD PTR $T236943[ebp]
	mov	DWORD PTR _it$[ebp+4], edx
$LN4@ChangeThir@3:
	lea	eax, DWORD PTR $T236879[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T236959[ebp], eax
	mov	ecx, DWORD PTR $T236959[ebp]
	mov	edx, DWORD PTR _it$[ebp+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setne	al
	mov	BYTE PTR $T236878[ebp], al
	movzx	ecx, BYTE PTR $T236878[ebp]
	test	ecx, ecx
	je	SHORT $LN2@ChangeThir@3

; 2135 : 	{
; 2136 : 		if(it->m_eItemType == TRADE_ITEM_THIRD_PARTY_EMBARGO &&
; 2137 : 		        (PlayerTypes)it->m_iData1 == eThirdParty &&
; 2138 : 		        (PlayerTypes)it->m_eFromPlayer == eFrom)

	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T236982[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T236982[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+eax+8], 16		; 00000010H
	jne	SHORT $LN1@ChangeThir@3
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T237014[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T237014[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+ecx+20]
	cmp	ecx, DWORD PTR _eThirdParty$[ebp]
	jne	SHORT $LN1@ChangeThir@3
	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T237046[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T237046[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+eax+36]
	cmp	eax, DWORD PTR _eFrom$[ebp]
	jne	SHORT $LN1@ChangeThir@3

; 2139 : 		{
; 2140 : 			it->m_iDuration = iNewDuration;

	mov	ecx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T237078[ebp], ecx
	mov	edx, DWORD PTR _it$[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T237078[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR _iNewDuration$[ebp]
	mov	DWORD PTR [ecx+edx+12], eax

; 2141 : 			break;

	jmp	SHORT $LN2@ChangeThir@3
$LN1@ChangeThir@3:

; 2142 : 		}
; 2143 : 	}

	jmp	$LN3@ChangeThir@3
$LN2@ChangeThir@3:

; 2144 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ChangeThirdPartyEmbargoDuration@CvDeal@@QAEXW4PlayerTypes@@0H@Z$0:
	lea	ecx, DWORD PTR _it$[ebp]
	jmp	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
__ehhandler$?ChangeThirdPartyEmbargoDuration@CvDeal@@QAEXW4PlayerTypes@@0H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ChangeThirdPartyEmbargoDuration@CvDeal@@QAEXW4PlayerTypes@@0H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ChangeThirdPartyEmbargoDuration@CvDeal@@QAEXW4PlayerTypes@@0H@Z ENDP ; CvDeal::ChangeThirdPartyEmbargoDuration
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
xdata$x	SEGMENT
__unwindtable$?ContainsItemType@CvDeal@@QAE_NW4TradeableItems@@W4PlayerTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ContainsItemType@CvDeal@@QAE_NW4TradeableItems@@W4PlayerTypes@@@Z$0
__ehfuncinfo$?ContainsItemType@CvDeal@@QAE_NW4TradeableItems@@W4PlayerTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ContainsItemType@CvDeal@@QAE_NW4TradeableItems@@W4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?ContainsItemType@CvDeal@@QAE_NW4TradeableItems@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
tv140 = -76						; size = 4
_this$ = -72						; size = 4
$T237269 = -68						; size = 4
$T237237 = -64						; size = 4
$T237214 = -60						; size = 4
$T237198 = -56						; size = 4
$T237194 = -52						; size = 4
$T237185 = -48						; size = 4
$T237134 = -42						; size = 1
$T237133 = -41						; size = 1
$T237132 = -40						; size = 8
$T237131 = -29						; size = 1
$T237130 = -28						; size = 8
_it$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_eItemType$ = 8						; size = 4
_eFrom$ = 12						; size = 4
?ContainsItemType@CvDeal@@QAE_NW4TradeableItems@@W4PlayerTypes@@@Z PROC ; CvDeal::ContainsItemType, COMDAT
; _this$ = ecx

; 2147 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ContainsItemType@CvDeal@@QAE_NW4TradeableItems@@W4PlayerTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2148 : 	TradedItemList::iterator it;

	mov	DWORD PTR _it$[ebp], 0
	mov	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2149 : 	for(it = m_TradedItems.begin(); it != m_TradedItems.end(); ++it)

	lea	eax, DWORD PTR $T237130[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv140[ebp], eax
	mov	ecx, DWORD PTR tv140[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _it$[ebp], edx
	mov	DWORD PTR _it$[ebp+4], eax
	jmp	SHORT $LN5@ContainsIt
$LN4@ContainsIt:
	cmp	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	jne	SHORT $LN30@ContainsIt
	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _it$[ebp+4], edx
	jmp	SHORT $LN5@ContainsIt
$LN30@ContainsIt:
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T237185[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T237185[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T237194[ebp], ecx
	mov	eax, DWORD PTR $T237194[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T237198[ebp], ecx
	mov	edx, DWORD PTR $T237198[ebp]
	mov	DWORD PTR _it$[ebp+4], edx
$LN5@ContainsIt:
	lea	eax, DWORD PTR $T237132[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T237214[ebp], eax
	mov	ecx, DWORD PTR $T237214[ebp]
	mov	edx, DWORD PTR _it$[ebp+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setne	al
	mov	BYTE PTR $T237131[ebp], al
	movzx	ecx, BYTE PTR $T237131[ebp]
	test	ecx, ecx
	je	SHORT $LN3@ContainsIt

; 2150 : 	{
; 2151 : 		if(it->m_eItemType == eItemType && (eFrom == NO_PLAYER || it->m_eFromPlayer == eFrom))

	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T237237[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T237237[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+eax+8]
	cmp	eax, DWORD PTR _eItemType$[ebp]
	jne	SHORT $LN2@ContainsIt
	cmp	DWORD PTR _eFrom$[ebp], -1
	je	SHORT $LN1@ContainsIt
	mov	ecx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T237269[ebp], ecx
	mov	edx, DWORD PTR _it$[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T237269[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+edx+36]
	cmp	edx, DWORD PTR _eFrom$[ebp]
	jne	SHORT $LN2@ContainsIt
$LN1@ContainsIt:

; 2152 : 		{
; 2153 : 			return true;

	mov	BYTE PTR $T237133[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	al, BYTE PTR $T237133[ebp]
	jmp	SHORT $LN6@ContainsIt
$LN2@ContainsIt:

; 2154 : 		}
; 2155 : 	}

	jmp	$LN4@ContainsIt
$LN3@ContainsIt:

; 2156 : 	return false;

	mov	BYTE PTR $T237134[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	al, BYTE PTR $T237134[ebp]
$LN6@ContainsIt:

; 2157 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ContainsItemType@CvDeal@@QAE_NW4TradeableItems@@W4PlayerTypes@@@Z$0:
	lea	ecx, DWORD PTR _it$[ebp]
	jmp	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
__ehhandler$?ContainsItemType@CvDeal@@QAE_NW4TradeableItems@@W4PlayerTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-68]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ContainsItemType@CvDeal@@QAE_NW4TradeableItems@@W4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ContainsItemType@CvDeal@@QAE_NW4TradeableItems@@W4PlayerTypes@@@Z ENDP ; CvDeal::ContainsItemType
PUBLIC	?OldLoad@@YAAAVFDataStream@@AAV1@AAVCvDeal@@@Z	; OldLoad
; Function compile flags: /Odtp
;	COMDAT ?OldLoad@@YAAAVFDataStream@@AAV1@AAVCvDeal@@@Z
_TEXT	SEGMENT
$T237503 = -156						; size = 4
_uiNewIndex$237499 = -104				; size = 4
$T237494 = -100						; size = 44
$T237377 = -56						; size = 4
$T237373 = -52						; size = 4
_v$237358 = -48						; size = 4
_iI$221810 = -44					; size = 4
_iEntriesToRead$ = -40					; size = 4
_tempItem$ = -36					; size = 36
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
?OldLoad@@YAAAVFDataStream@@AAV1@AAVCvDeal@@@Z PROC	; OldLoad, COMDAT

; 2162 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	push	esi
	push	edi

; 2163 : 	int iEntriesToRead;
; 2164 : 	CvTradedItem tempItem;

	lea	ecx, DWORD PTR _tempItem$[ebp]
	call	??0CvTradedItem@@QAE@XZ			; CvTradedItem::CvTradedItem

; 2165 : 
; 2166 : 	loadFrom >> writeTo.m_eFromPlayer;

	mov	eax, DWORD PTR _writeTo$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	push	ecx
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 2167 : 	loadFrom >> writeTo.m_eToPlayer;

	mov	edx, DWORD PTR _writeTo$[ebp]
	add	edx, 8
	push	edx
	mov	eax, DWORD PTR _loadFrom$[ebp]
	push	eax
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 2168 : 	loadFrom >> writeTo.m_iFinalTurn;

	mov	ecx, DWORD PTR _writeTo$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2169 : 	loadFrom >> writeTo.m_iDuration;

	mov	edx, DWORD PTR _writeTo$[ebp]
	add	edx, 20					; 00000014H
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2170 : 	loadFrom >> writeTo.m_iStartTurn;

	mov	eax, DWORD PTR _writeTo$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2171 : 	loadFrom >> writeTo.m_bConsideringForRenewal;

	mov	ecx, DWORD PTR _writeTo$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 2172 : 	loadFrom >> writeTo.m_bDealCancelled;

	mov	edx, DWORD PTR _writeTo$[ebp]
	add	edx, 42					; 0000002aH
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 2173 : 	loadFrom >> writeTo.m_ePeaceTreatyType;

	lea	eax, DWORD PTR _v$237358[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	mov	ecx, DWORD PTR _writeTo$[ebp]
	mov	edx, DWORD PTR _v$237358[ebp]
	mov	DWORD PTR [ecx+24], edx

; 2174 : 	loadFrom >> writeTo.m_eSurrenderingPlayer;

	mov	eax, DWORD PTR _writeTo$[ebp]
	add	eax, 28					; 0000001cH
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	push	ecx
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 2175 : 	loadFrom >> writeTo.m_eDemandingPlayer;

	mov	edx, DWORD PTR _writeTo$[ebp]
	add	edx, 32					; 00000020H
	push	edx
	mov	eax, DWORD PTR _loadFrom$[ebp]
	push	eax
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 2176 : 	loadFrom >> writeTo.m_eRequestingPlayer;

	mov	ecx, DWORD PTR _writeTo$[ebp]
	add	ecx, 36					; 00000024H
	push	ecx
	mov	edx, DWORD PTR _loadFrom$[ebp]
	push	edx
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 2177 : 	loadFrom >> iEntriesToRead;

	lea	eax, DWORD PTR _iEntriesToRead$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2178 : 
; 2179 : 	writeTo.m_TradedItems.clear();

	mov	ecx, DWORD PTR _writeTo$[ebp]
	add	ecx, 44					; 0000002cH
	mov	DWORD PTR $T237373[ebp], ecx
	push	268435455				; 0fffffffH
	mov	edx, DWORD PTR $T237373[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR $T237373[ebp]
	call	?UnLink@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAEXII@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::UnLink

; 2180 : 	for(int iI = 0; iI < iEntriesToRead; iI++)

	mov	DWORD PTR _iI$221810[ebp], 0
	jmp	SHORT $LN3@OldLoad
$LN2@OldLoad:
	mov	ecx, DWORD PTR _iI$221810[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$221810[ebp], ecx
$LN3@OldLoad:
	mov	edx, DWORD PTR _iI$221810[ebp]
	cmp	edx, DWORD PTR _iEntriesToRead$[ebp]
	jge	$LN1@OldLoad

; 2181 : 	{
; 2182 : 		loadFrom = OldLoad(loadFrom, tempItem);

	lea	eax, DWORD PTR _tempItem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	push	ecx
	call	?OldLoad@@YAAAVFDataStream@@AAV1@AAUCvTradedItem@@@Z ; OldLoad
	add	esp, 8
	mov	DWORD PTR $T237377[ebp], eax
	mov	edx, DWORD PTR _loadFrom$[ebp]
	mov	eax, DWORD PTR $T237377[ebp]
	mov	cl, BYTE PTR [eax+4]
	mov	BYTE PTR [edx+4], cl
	mov	edx, DWORD PTR _loadFrom$[ebp]
	mov	eax, DWORD PTR $T237377[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	edx, DWORD PTR _loadFrom$[ebp]
	mov	eax, DWORD PTR $T237377[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], ecx
	mov	edx, DWORD PTR _loadFrom$[ebp]
	mov	eax, DWORD PTR $T237377[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], ecx

; 2183 : 		writeTo.m_TradedItems.push_back(tempItem);

	mov	edx, DWORD PTR _writeTo$[ebp]
	add	edx, 44					; 0000002cH
	mov	DWORD PTR $T237503[ebp], edx
	lea	edi, DWORD PTR $T237494[ebp+8]
	mov	ecx, 9
	lea	esi, DWORD PTR _tempItem$[ebp]
	rep movsd
	lea	eax, DWORD PTR $T237494[ebp]
	push	eax
	mov	ecx, DWORD PTR $T237503[ebp]
	call	?Alloc@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::Alloc
	mov	DWORD PTR _uiNewIndex$237499[ebp], eax
	mov	ecx, DWORD PTR _uiNewIndex$237499[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T237503[ebp]
	call	?push_back_existing@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEXI@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::push_back_existing

; 2184 : 	}

	jmp	$LN2@OldLoad
$LN1@OldLoad:

; 2185 : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 2186 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?OldLoad@@YAAAVFDataStream@@AAV1@AAVCvDeal@@@Z ENDP	; OldLoad
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAVCvDeal@@@Z	; operator>>
; Function compile flags: /Odtp
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAVCvDeal@@@Z
_TEXT	SEGMENT
$T237677 = -160						; size = 4
_uiNewIndex$237668 = -108				; size = 4
$T237674 = -104						; size = 44
$T237551 = -60						; size = 4
$T237547 = -56						; size = 4
_v$237532 = -52						; size = 4
_iI$221826 = -48					; size = 4
_iEntriesToRead$ = -44					; size = 4
_uiVersion$ = -40					; size = 4
_tempItem$ = -36					; size = 36
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAVCvDeal@@@Z PROC		; operator>>, COMDAT

; 2190 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 160				; 000000a0H
	push	esi
	push	edi

; 2191 : 	uint uiVersion;
; 2192 : 	int iEntriesToRead;
; 2193 : 	CvTradedItem tempItem;

	lea	ecx, DWORD PTR _tempItem$[ebp]
	call	??0CvTradedItem@@QAE@XZ			; CvTradedItem::CvTradedItem

; 2194 : 
; 2195 : 	loadFrom >> uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 2196 : 	loadFrom >> writeTo.m_eFromPlayer;

	mov	ecx, DWORD PTR _writeTo$[ebp]
	add	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _loadFrom$[ebp]
	push	edx
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 2197 : 	loadFrom >> writeTo.m_eToPlayer;

	mov	eax, DWORD PTR _writeTo$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	push	ecx
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 2198 : 	loadFrom >> writeTo.m_iFinalTurn;

	mov	edx, DWORD PTR _writeTo$[ebp]
	add	edx, 16					; 00000010H
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2199 : 	loadFrom >> writeTo.m_iDuration;

	mov	eax, DWORD PTR _writeTo$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2200 : 	loadFrom >> writeTo.m_iStartTurn;

	mov	ecx, DWORD PTR _writeTo$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2201 : 	loadFrom >> writeTo.m_bConsideringForRenewal;

	mov	edx, DWORD PTR _writeTo$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 2202 : 	if (uiVersion >= 3)

	cmp	DWORD PTR _uiVersion$[ebp], 3
	jb	SHORT $LN7@operator@4

; 2203 : 	{
; 2204 : 		loadFrom >> writeTo.m_bCheckedForRenewal;

	mov	eax, DWORD PTR _writeTo$[ebp]
	add	eax, 41					; 00000029H
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 2205 : 	}
; 2206 : 	else

	jmp	SHORT $LN6@operator@4
$LN7@operator@4:

; 2207 : 	{
; 2208 : 		writeTo.m_bCheckedForRenewal = false;

	mov	ecx, DWORD PTR _writeTo$[ebp]
	mov	BYTE PTR [ecx+41], 0
$LN6@operator@4:

; 2209 : 	}
; 2210 : 	loadFrom >> writeTo.m_bDealCancelled;

	mov	edx, DWORD PTR _writeTo$[ebp]
	add	edx, 42					; 0000002aH
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 2211 : 	loadFrom >> writeTo.m_ePeaceTreatyType;

	lea	eax, DWORD PTR _v$237532[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	mov	ecx, DWORD PTR _writeTo$[ebp]
	mov	edx, DWORD PTR _v$237532[ebp]
	mov	DWORD PTR [ecx+24], edx

; 2212 : 	loadFrom >> writeTo.m_eSurrenderingPlayer;

	mov	eax, DWORD PTR _writeTo$[ebp]
	add	eax, 28					; 0000001cH
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	push	ecx
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 2213 : 	loadFrom >> writeTo.m_eDemandingPlayer;

	mov	edx, DWORD PTR _writeTo$[ebp]
	add	edx, 32					; 00000020H
	push	edx
	mov	eax, DWORD PTR _loadFrom$[ebp]
	push	eax
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 2214 : 	loadFrom >> writeTo.m_eRequestingPlayer;

	mov	ecx, DWORD PTR _writeTo$[ebp]
	add	ecx, 36					; 00000024H
	push	ecx
	mov	edx, DWORD PTR _loadFrom$[ebp]
	push	edx
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 2215 : 	loadFrom >> iEntriesToRead;

	lea	eax, DWORD PTR _iEntriesToRead$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2216 : 
; 2217 : 	writeTo.m_TradedItems.clear();

	mov	ecx, DWORD PTR _writeTo$[ebp]
	add	ecx, 44					; 0000002cH
	mov	DWORD PTR $T237547[ebp], ecx
	push	268435455				; 0fffffffH
	mov	edx, DWORD PTR $T237547[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR $T237547[ebp]
	call	?UnLink@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAEXII@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::UnLink

; 2218 : 	for(int iI = 0; iI < iEntriesToRead; iI++)

	mov	DWORD PTR _iI$221826[ebp], 0
	jmp	SHORT $LN5@operator@4
$LN4@operator@4:
	mov	ecx, DWORD PTR _iI$221826[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$221826[ebp], ecx
$LN5@operator@4:
	mov	edx, DWORD PTR _iI$221826[ebp]
	cmp	edx, DWORD PTR _iEntriesToRead$[ebp]
	jge	$LN3@operator@4

; 2219 : 	{
; 2220 : 		if(uiVersion >= 2)

	cmp	DWORD PTR _uiVersion$[ebp], 2
	jb	SHORT $LN2@operator@4

; 2221 : 		{
; 2222 : 			loadFrom >> tempItem;

	lea	eax, DWORD PTR _tempItem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	push	ecx
	call	??5@YAAAVFDataStream@@AAV0@AAUCvTradedItem@@@Z ; operator>>
	add	esp, 8

; 2223 : 		}
; 2224 : 		else

	jmp	SHORT $LN1@operator@4
$LN2@operator@4:

; 2225 : 		{
; 2226 : 			loadFrom = OldLoad(loadFrom, tempItem);

	lea	edx, DWORD PTR _tempItem$[ebp]
	push	edx
	mov	eax, DWORD PTR _loadFrom$[ebp]
	push	eax
	call	?OldLoad@@YAAAVFDataStream@@AAV1@AAUCvTradedItem@@@Z ; OldLoad
	add	esp, 8
	mov	DWORD PTR $T237551[ebp], eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	mov	edx, DWORD PTR $T237551[ebp]
	mov	al, BYTE PTR [edx+4]
	mov	BYTE PTR [ecx+4], al
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	mov	edx, DWORD PTR $T237551[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	mov	edx, DWORD PTR $T237551[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	mov	edx, DWORD PTR $T237551[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
$LN1@operator@4:

; 2227 : 		}
; 2228 : 		writeTo.m_TradedItems.push_back(tempItem);

	mov	ecx, DWORD PTR _writeTo$[ebp]
	add	ecx, 44					; 0000002cH
	mov	DWORD PTR $T237677[ebp], ecx
	lea	edi, DWORD PTR $T237674[ebp+8]
	mov	ecx, 9
	lea	esi, DWORD PTR _tempItem$[ebp]
	rep movsd
	lea	edx, DWORD PTR $T237674[ebp]
	push	edx
	mov	ecx, DWORD PTR $T237677[ebp]
	call	?Alloc@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::Alloc
	mov	DWORD PTR _uiNewIndex$237668[ebp], eax
	mov	eax, DWORD PTR _uiNewIndex$237668[ebp]
	push	eax
	mov	ecx, DWORD PTR $T237677[ebp]
	call	?push_back_existing@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEXI@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::push_back_existing

; 2229 : 	}

	jmp	$LN4@operator@4
$LN3@operator@4:

; 2230 : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 2231 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??5@YAAAVFDataStream@@AAV0@AAVCvDeal@@@Z ENDP		; operator>>
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABVCvDeal@@@Z	; operator<<
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
xdata$x	SEGMENT
__unwindtable$??6@YAAAVFDataStream@@AAV0@ABVCvDeal@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??6@YAAAVFDataStream@@AAV0@ABVCvDeal@@@Z$0
__ehfuncinfo$??6@YAAAVFDataStream@@AAV0@ABVCvDeal@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??6@YAAAVFDataStream@@AAV0@ABVCvDeal@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABVCvDeal@@@Z
_TEXT	SEGMENT
tv179 = -84						; size = 4
$T237830 = -80						; size = 4
$T237807 = -76						; size = 4
$T237791 = -72						; size = 4
$T237787 = -68						; size = 4
$T237778 = -64						; size = 4
$T237723 = -60						; size = 4
$T237716 = -56						; size = 4
$T237684 = -52						; size = 4
$T237683 = -48						; size = 8
$T237682 = -37						; size = 1
$T237681 = -36						; size = 8
$T237680 = -28						; size = 4
_uiVersion$ = -24					; size = 4
_it$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABVCvDeal@@@Z PROC		; operator<<, COMDAT

; 2235 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??6@YAAAVFDataStream@@AAV0@ABVCvDeal@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 2236 : 	// Current version number
; 2237 : 	uint uiVersion = 3;

	mov	DWORD PTR _uiVersion$[ebp], 3

; 2238 : 	saveTo << uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 2239 : 	saveTo << readFrom.m_eFromPlayer;

	mov	ecx, DWORD PTR _readFrom$[ebp]
	add	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _saveTo$[ebp]
	push	edx
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 8

; 2240 : 	saveTo << readFrom.m_eToPlayer;

	mov	eax, DWORD PTR _readFrom$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	push	ecx
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 8

; 2241 : 	saveTo << readFrom.m_iFinalTurn;

	mov	edx, DWORD PTR _readFrom$[ebp]
	add	edx, 16					; 00000010H
	push	edx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2242 : 	saveTo << readFrom.m_iDuration;

	mov	eax, DWORD PTR _readFrom$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2243 : 	saveTo << readFrom.m_iStartTurn;

	mov	ecx, DWORD PTR _readFrom$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2244 : 	saveTo << readFrom.m_bConsideringForRenewal;

	mov	edx, DWORD PTR _readFrom$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 2245 : 	saveTo << readFrom.m_bCheckedForRenewal;

	mov	eax, DWORD PTR _readFrom$[ebp]
	add	eax, 41					; 00000029H
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 2246 : 	saveTo << readFrom.m_bDealCancelled;

	mov	ecx, DWORD PTR _readFrom$[ebp]
	add	ecx, 42					; 0000002aH
	push	ecx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 2247 : 	saveTo << readFrom.m_ePeaceTreatyType;

	mov	edx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR $T237716[ebp], eax
	lea	ecx, DWORD PTR $T237716[ebp]
	push	ecx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2248 : 	saveTo << readFrom.m_eSurrenderingPlayer;

	mov	edx, DWORD PTR _readFrom$[ebp]
	add	edx, 28					; 0000001cH
	push	edx
	mov	eax, DWORD PTR _saveTo$[ebp]
	push	eax
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 8

; 2249 : 	saveTo << readFrom.m_eDemandingPlayer;

	mov	ecx, DWORD PTR _readFrom$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	mov	edx, DWORD PTR _saveTo$[ebp]
	push	edx
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 8

; 2250 : 	saveTo << readFrom.m_eRequestingPlayer;

	mov	eax, DWORD PTR _readFrom$[ebp]
	add	eax, 36					; 00000024H
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	push	ecx
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 8

; 2251 : 	saveTo << readFrom.m_TradedItems.size();

	mov	edx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	DWORD PTR $T237723[ebp], eax
	mov	ecx, DWORD PTR $T237723[ebp]
	mov	DWORD PTR $T237680[ebp], ecx
	lea	edx, DWORD PTR $T237680[ebp]
	push	edx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 2252 : 	TradedItemList::const_iterator it;

	mov	DWORD PTR _it$[ebp], 0
	mov	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2253 : 	for(it = readFrom.m_TradedItems.begin(); it != readFrom.m_TradedItems.end(); ++it)

	lea	eax, DWORD PTR $T237681[ebp]
	push	eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QBE?AVconst_iterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv179[ebp], eax
	mov	ecx, DWORD PTR tv179[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _it$[ebp], edx
	mov	DWORD PTR _it$[ebp+4], eax
	jmp	SHORT $LN3@operator@5
$LN2@operator@5:
	cmp	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	jne	SHORT $LN52@operator@5
	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _it$[ebp+4], edx
	jmp	SHORT $LN3@operator@5
$LN52@operator@5:
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T237778[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T237778[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T237787[ebp], ecx
	mov	eax, DWORD PTR $T237787[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T237791[ebp], ecx
	mov	edx, DWORD PTR $T237791[ebp]
	mov	DWORD PTR _it$[ebp+4], edx
$LN3@operator@5:
	lea	eax, DWORD PTR $T237683[ebp]
	push	eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QBE?AVconst_iterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T237807[ebp], eax
	mov	ecx, DWORD PTR $T237807[ebp]
	mov	edx, DWORD PTR _it$[ebp+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setne	al
	mov	BYTE PTR $T237682[ebp], al
	movzx	ecx, BYTE PTR $T237682[ebp]
	test	ecx, ecx
	je	SHORT $LN1@operator@5

; 2254 : 	{
; 2255 : 		saveTo << *it;

	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T237830[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T237830[ebp]
	mov	edx, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [edx+eax+8]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	push	ecx
	call	??6@YAAAVFDataStream@@AAV0@ABUCvTradedItem@@@Z ; operator<<
	add	esp, 8

; 2256 : 	}

	jmp	$LN2@operator@5
$LN1@operator@5:

; 2257 : 
; 2258 : 	return saveTo;

	mov	edx, DWORD PTR _saveTo$[ebp]
	mov	DWORD PTR $T237684[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T237684[ebp]

; 2259 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??6@YAAAVFDataStream@@AAV0@ABVCvDeal@@@Z$0:
	lea	ecx, DWORD PTR _it$[ebp]
	jmp	??1const_iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::const_iterator::~const_iterator
__ehhandler$??6@YAAAVFDataStream@@AAV0@ABVCvDeal@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??6@YAAAVFDataStream@@AAV0@ABVCvDeal@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??6@YAAAVFDataStream@@AAV0@ABVCvDeal@@@Z ENDP		; operator<<
PUBLIC	??1?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::~vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >
PUBLIC	??1?$_Vector_val@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE@XZ ; std::_Vector_val<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::~_Vector_val<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >
PUBLIC	??1?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvDeal,20,0,297,0>::~FStaticVector<CvDeal,20,0,297,0>
PUBLIC	?Init@CvGameDeals@@QAEXXZ			; CvGameDeals::Init
PUBLIC	?_Buy@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAE_NI@Z ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Buy
PUBLIC	??0?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvDeal,20,0,297,0>::FStaticVector<CvDeal,20,0,297,0>
PUBLIC	??_7CvGameDeals@@6B@				; CvGameDeals::`vftable'
PUBLIC	??0CvGameDeals@@QAE@XZ				; CvGameDeals::CvGameDeals
EXTRN	__CxxThrowException@8:PROC
EXTRN	??_ECvGameDeals@@UAEPAXI@Z:PROC			; CvGameDeals::`vector deleting destructor'
;	COMDAT ??_7CvGameDeals@@6B@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
CONST	SEGMENT
??_7CvGameDeals@@6B@ DD FLAT:??_ECvGameDeals@@UAEPAXI@Z	; CvGameDeals::`vftable'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CvGameDeals@@QAE@XZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??0CvGameDeals@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CvGameDeals@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvGameDeals@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvGameDeals@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CvGameDeals@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CvGameDeals@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CvGameDeals@@QAE@XZ$8
	DD	03H
	DD	FLAT:__unwindfunclet$??0CvGameDeals@@QAE@XZ$4
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ??0CvGameDeals@@QAE@XZ
_TEXT	SEGMENT
tv256 = -160						; size = 4
tv281 = -156						; size = 4
_this$ = -152						; size = 4
$T238003 = -148						; size = 4
$T237953 = -54						; size = 1
$T237940 = -53						; size = 1
$T237936 = -52						; size = 4
$T237929 = -44						; size = 4
__$EHRec$ = -12						; size = 12
??0CvGameDeals@@QAE@XZ PROC				; CvGameDeals::CvGameDeals, COMDAT
; _this$ = ecx

; 2268 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvGameDeals@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 148				; 00000094H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvGameDeals@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvDeal,20,0,297,0>::FStaticVector<CvDeal,20,0,297,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1540				; 00000604H
	call	??0?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvDeal,20,0,297,0>::FStaticVector<CvDeal,20,0,297,0>
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3076				; 00000c04H
	call	??0?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvDeal,20,0,297,0>::FStaticVector<CvDeal,20,0,297,0>
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4612				; 00001204H
	call	??0CvDeal@@QAE@XZ			; CvDeal::CvDeal
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4688				; 00001250H
	mov	DWORD PTR $T238003[ebp], ecx
	lea	edx, DWORD PTR $T237953[ebp]
	mov	DWORD PTR $T237929[ebp], edx
	lea	eax, DWORD PTR $T237940[ebp]
	mov	DWORD PTR $T237936[ebp], eax
	mov	ecx, DWORD PTR $T238003[ebp]
	mov	DWORD PTR tv281[ebp], ecx
	mov	edx, DWORD PTR $T238003[ebp]
	mov	DWORD PTR tv256[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	push	0
	mov	ecx, DWORD PTR $T238003[ebp]
	call	?_Buy@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAE_NI@Z ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Buy
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4704], 0

; 2269 : 	Init();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Init@CvGameDeals@@QAEXXZ		; CvGameDeals::Init

; 2270 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvGameDeals@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvDeal,20,0,297,0>::~FStaticVector<CvDeal,20,0,297,0>
__unwindfunclet$??0CvGameDeals@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1540				; 00000604H
	jmp	??1?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvDeal,20,0,297,0>::~FStaticVector<CvDeal,20,0,297,0>
__unwindfunclet$??0CvGameDeals@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3076				; 00000c04H
	jmp	??1?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvDeal,20,0,297,0>::~FStaticVector<CvDeal,20,0,297,0>
__unwindfunclet$??0CvGameDeals@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4612				; 00001204H
	jmp	??1CvDeal@@UAE@XZ			; CvDeal::~CvDeal
__unwindfunclet$??0CvGameDeals@@QAE@XZ$8:
	mov	ecx, DWORD PTR $T238003[ebp]
	jmp	??1?$_Vector_val@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE@XZ
__unwindfunclet$??0CvGameDeals@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4688				; 00001250H
	jmp	??1?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::~vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >
__ehhandler$??0CvGameDeals@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-152]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvGameDeals@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvGameDeals@@QAE@XZ ENDP				; CvGameDeals::CvGameDeals
PUBLIC	??1CvGameDeals@@UAE@XZ				; CvGameDeals::~CvGameDeals
; Function compile flags: /Odtp
;	COMDAT ??_GCvGameDeals@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCvGameDeals@@UAEPAXI@Z PROC				; CvGameDeals::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvGameDeals@@UAE@XZ			; CvGameDeals::~CvGameDeals
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@2
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCvGameDeals@@UAEPAXI@Z ENDP				; CvGameDeals::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$BaseVector@VCvDeal@@$0A@@@QAE@XZ		; BaseVector<CvDeal,0>::~BaseVector<CvDeal,0>
PUBLIC	?Free@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXPAVCvDeal@@I@Z ; FStaticVector<CvDeal,20,0,297,0>::Free
PUBLIC	?_Tidy@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXXZ ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Tidy
PUBLIC	?erase@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@0@Z ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::erase
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__ehfuncinfo$??1CvGameDeals@@UAE@XZ DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$??1CvGameDeals@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvGameDeals@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvGameDeals@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvGameDeals@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvGameDeals@@UAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvGameDeals@@UAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvGameDeals@@UAE@XZ$4
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvGameDeals@@UAE@XZ$5
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvGameDeals@@UAE@XZ$7
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvGameDeals@@UAE@XZ$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvGameDeals@@UAE@XZ$9
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ??1CvGameDeals@@UAE@XZ
_TEXT	SEGMENT
tv136 = -168						; size = 4
_this$ = -164						; size = 4
$T238395 = -160						; size = 4
$T238376 = -152						; size = 4
$T238357 = -144						; size = 4
$T238338 = -136						; size = 4
$T238252 = -100						; size = 4
$T238126 = -64						; size = 4
$T238110 = -60						; size = 4
$T238239 = -56						; size = 4
$T238238 = -52						; size = 4
$T238237 = -48						; size = 4
$T238236 = -44						; size = 4
$T238235 = -40						; size = 4
$T238057 = -36						; size = 4
$T238033 = -32						; size = 4
$T238016 = -28						; size = 4
$T238015 = -24						; size = 4
$T238014 = -20						; size = 4
_it$222028 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??1CvGameDeals@@UAE@XZ PROC				; CvGameDeals::~CvGameDeals, COMDAT
; _this$ = ecx

; 2274 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvGameDeals@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 156				; 0000009cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvGameDeals@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 4

; 2275 : 	for(std::vector<std::pair<uint, CvDeal*> >::iterator it = m_Deals.begin();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4692]
	mov	DWORD PTR $T238033[ebp], edx
	mov	eax, DWORD PTR $T238033[ebp]
	mov	DWORD PTR _it$222028[ebp], eax

; 2276 : 	        it != m_Deals.end(); ++it)

	jmp	SHORT $LN3@CvGameDeal
$LN2@CvGameDeal:
	mov	ecx, DWORD PTR _it$222028[ebp]
	add	ecx, 8
	mov	DWORD PTR _it$222028[ebp], ecx
$LN3@CvGameDeal:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4696]
	mov	DWORD PTR $T238057[ebp], eax
	mov	ecx, DWORD PTR $T238057[ebp]
	mov	DWORD PTR $T238014[ebp], ecx
	mov	edx, DWORD PTR _it$222028[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T238014[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@CvGameDeal

; 2277 : 	{
; 2278 : 		delete(*it).second;

	mov	eax, DWORD PTR _it$222028[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T238016[ebp], ecx
	mov	edx, DWORD PTR $T238016[ebp]
	mov	DWORD PTR $T238015[ebp], edx
	cmp	DWORD PTR $T238015[ebp], 0
	je	SHORT $LN6@CvGameDeal
	push	1
	mov	eax, DWORD PTR $T238015[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T238015[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv136[ebp], eax
	jmp	SHORT $LN37@CvGameDeal
$LN6@CvGameDeal:
	mov	DWORD PTR tv136[ebp], 0

; 2279 : 		it->second = NULL;

$LN37@CvGameDeal:
	mov	ecx, DWORD PTR _it$222028[ebp]
	mov	DWORD PTR [ecx+4], 0

; 2280 : 	}

	jmp	SHORT $LN2@CvGameDeal
$LN1@CvGameDeal:

; 2281 : 
; 2282 : 	m_Deals.clear();

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4688				; 00001250H
	mov	DWORD PTR $T238252[ebp], edx
	mov	eax, DWORD PTR $T238252[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T238110[ebp], ecx
	mov	edx, DWORD PTR $T238110[ebp]
	mov	DWORD PTR $T238236[ebp], edx
	mov	eax, DWORD PTR $T238236[ebp]
	mov	DWORD PTR $T238235[ebp], eax
	mov	ecx, DWORD PTR $T238252[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T238126[ebp], edx
	mov	eax, DWORD PTR $T238126[ebp]
	mov	DWORD PTR $T238238[ebp], eax
	mov	ecx, DWORD PTR $T238238[ebp]
	mov	DWORD PTR $T238237[ebp], ecx
	mov	edx, DWORD PTR $T238235[ebp]
	push	edx
	mov	eax, DWORD PTR $T238237[ebp]
	push	eax
	lea	ecx, DWORD PTR $T238239[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T238252[ebp]
	call	?erase@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@0@Z ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::erase

; 2283 : #ifdef AUI_EXPLICIT_DESTRUCTION
; 2284 : 	Init(); //clears all the deal lists
; 2285 : #endif
; 2286 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4688				; 00001250H
	mov	DWORD PTR $T238338[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR $T238338[ebp]
	call	?_Tidy@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXXZ ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4612				; 00001204H
	call	??1CvDeal@@UAE@XZ			; CvDeal::~CvDeal
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 3076				; 00000c04H
	mov	DWORD PTR $T238357[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR $T238357[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR $T238357[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR $T238357[ebp]
	call	?Free@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXPAVCvDeal@@I@Z ; FStaticVector<CvDeal,20,0,297,0>::Free
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1540				; 00000604H
	mov	DWORD PTR $T238376[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	eax, DWORD PTR $T238376[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR $T238376[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR $T238376[ebp]
	call	?Free@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXPAVCvDeal@@I@Z ; FStaticVector<CvDeal,20,0,297,0>::Free
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	mov	DWORD PTR $T238395[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 8
	mov	edx, DWORD PTR $T238395[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR $T238395[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR $T238395[ebp]
	call	?Free@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXPAVCvDeal@@I@Z ; FStaticVector<CvDeal,20,0,297,0>::Free
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvGameDeals@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvDeal,20,0,297,0>::~FStaticVector<CvDeal,20,0,297,0>
__unwindfunclet$??1CvGameDeals@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1540				; 00000604H
	jmp	??1?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvDeal,20,0,297,0>::~FStaticVector<CvDeal,20,0,297,0>
__unwindfunclet$??1CvGameDeals@@UAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3076				; 00000c04H
	jmp	??1?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvDeal,20,0,297,0>::~FStaticVector<CvDeal,20,0,297,0>
__unwindfunclet$??1CvGameDeals@@UAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4612				; 00001204H
	jmp	??1CvDeal@@UAE@XZ			; CvDeal::~CvDeal
__unwindfunclet$??1CvGameDeals@@UAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4688				; 00001250H
	jmp	??1?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::~vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >
__unwindfunclet$??1CvGameDeals@@UAE@XZ$5:
	mov	ecx, DWORD PTR $T238338[ebp]
	jmp	??1?$_Vector_val@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE@XZ
__unwindfunclet$??1CvGameDeals@@UAE@XZ$7:
	mov	ecx, DWORD PTR $T238357[ebp]
	jmp	??1?$BaseVector@VCvDeal@@$0A@@@QAE@XZ	; BaseVector<CvDeal,0>::~BaseVector<CvDeal,0>
__unwindfunclet$??1CvGameDeals@@UAE@XZ$8:
	mov	ecx, DWORD PTR $T238376[ebp]
	jmp	??1?$BaseVector@VCvDeal@@$0A@@@QAE@XZ	; BaseVector<CvDeal,0>::~BaseVector<CvDeal,0>
__unwindfunclet$??1CvGameDeals@@UAE@XZ$9:
	mov	ecx, DWORD PTR $T238395[ebp]
	jmp	??1?$BaseVector@VCvDeal@@$0A@@@QAE@XZ	; BaseVector<CvDeal,0>::~BaseVector<CvDeal,0>
__ehhandler$??1CvGameDeals@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-160]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvGameDeals@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvGameDeals@@UAE@XZ ENDP				; CvGameDeals::~CvGameDeals
PUBLIC	?clear@?$BaseVector@VCvDeal@@$0A@@@QAEXXZ	; BaseVector<CvDeal,0>::clear
; Function compile flags: /Odtp
;	COMDAT ?Init@CvGameDeals@@QAEXXZ
_TEXT	SEGMENT
_this$ = -40						; size = 4
?Init@CvGameDeals@@QAEXXZ PROC				; CvGameDeals::Init, COMDAT
; _this$ = ecx

; 2290 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 2291 : 	m_ProposedDeals.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?clear@?$BaseVector@VCvDeal@@$0A@@@QAEXXZ ; BaseVector<CvDeal,0>::clear

; 2292 : 	m_CurrentDeals.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1540				; 00000604H
	call	?clear@?$BaseVector@VCvDeal@@$0A@@@QAEXXZ ; BaseVector<CvDeal,0>::clear

; 2293 : 	m_HistoricalDeals.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3076				; 00000c04H
	call	?clear@?$BaseVector@VCvDeal@@$0A@@@QAEXXZ ; BaseVector<CvDeal,0>::clear

; 2294 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 2295 : 	m_CurrentlyEndingDeals.clear();
; 2296 : #endif
; 2297 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Init@CvGameDeals@@QAEXXZ ENDP				; CvGameDeals::Init
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z ; FStaticVector<CvDeal,20,0,297,0>::push_back
PUBLIC	?AddProposedDeal@CvGameDeals@@QAEXVCvDeal@@@Z	; CvGameDeals::AddProposedDeal
EXTRN	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ:PROC ; CvGame::getActivePlayer
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
xdata$x	SEGMENT
__unwindtable$?AddProposedDeal@CvGameDeals@@QAEXVCvDeal@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddProposedDeal@CvGameDeals@@QAEXVCvDeal@@@Z$0
__ehfuncinfo$?AddProposedDeal@CvGameDeals@@QAEXVCvDeal@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddProposedDeal@CvGameDeals@@QAEXVCvDeal@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?AddProposedDeal@CvGameDeals@@QAEXVCvDeal@@@Z
_TEXT	SEGMENT
tv81 = -40						; size = 4
_this$ = -36						; size = 4
$T238456 = -32						; size = 4
$T238452 = -28						; size = 4
_eActivePlayer$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_kDeal$ = 8						; size = 76
?AddProposedDeal@CvGameDeals@@QAEXVCvDeal@@@Z PROC	; CvGameDeals::AddProposedDeal, COMDAT
; _this$ = ecx

; 2305 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddProposedDeal@CvGameDeals@@QAEXVCvDeal@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2306 : 	// Store Deal away
; 2307 : 	m_ProposedDeals.push_back(kDeal);

	lea	eax, DWORD PTR _kDeal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z ; FStaticVector<CvDeal,20,0,297,0>::push_back

; 2308 : 
; 2309 : 	// Update UI if we were involved in the deal
; 2310 : 	PlayerTypes eActivePlayer = GC.getGame().getActivePlayer();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T238452[ebp], ecx
	mov	ecx, DWORD PTR $T238452[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	mov	DWORD PTR _eActivePlayer$[ebp], eax

; 2311 : 	if(kDeal.m_eFromPlayer == eActivePlayer || kDeal.m_eToPlayer == eActivePlayer)

	mov	edx, DWORD PTR _kDeal$[ebp+4]
	cmp	edx, DWORD PTR _eActivePlayer$[ebp]
	je	SHORT $LN1@AddPropose
	mov	eax, DWORD PTR _kDeal$[ebp+8]
	cmp	eax, DWORD PTR _eActivePlayer$[ebp]
	jne	SHORT $LN2@AddPropose
$LN1@AddPropose:

; 2312 : 	{
; 2313 : 		GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	mov	ecx, DWORD PTR $T238456[ebp]
	mov	DWORD PTR tv81[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv81[ebp], edx
	push	1
	push	11					; 0000000bH
	mov	eax, DWORD PTR tv81[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv81[ebp]
	mov	eax, DWORD PTR [edx+260]
	call	eax
$LN2@AddPropose:

; 2314 : 	}
; 2315 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _kDeal$[ebp]
	call	??1CvDeal@@UAE@XZ			; CvDeal::~CvDeal
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	76					; 0000004cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddProposedDeal@CvGameDeals@@QAEXVCvDeal@@@Z$0:
	lea	ecx, DWORD PTR _kDeal$[ebp]
	jmp	??1CvDeal@@UAE@XZ			; CvDeal::~CvDeal
__ehhandler$?AddProposedDeal@CvGameDeals@@QAEXVCvDeal@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AddProposedDeal@CvGameDeals@@QAEXVCvDeal@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddProposedDeal@CvGameDeals@@QAEXVCvDeal@@@Z ENDP	; CvGameDeals::AddProposedDeal
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
PUBLIC	??1?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE@XZ ; CvWeightedVector<enum TeamTypes,63,1>::~CvWeightedVector<enum TeamTypes,63,1>
PUBLIC	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::~FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>
PUBLIC	??_C@_09ODCIJKAA@?$FLNEWLINE?$FN?$AA@		; `string'
PUBLIC	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
PUBLIC	??_C@_0DC@HKECBLMG@TXT_KEY_MISC_MADE_PEACE_WITH_MIN@ ; `string'
PUBLIC	??_C@_0CK@MOEBLOJE@TXT_KEY_MISC_MADE_PEACE_WITH_MIN@ ; `string'
PUBLIC	?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z	; CvGameDeals::LogDealComplete
PUBLIC	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@Z ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::push_back
PUBLIC	?coordRange@@YAHHH_N@Z				; coordRange
PUBLIC	??_C@_0BA@FIPEIDLD@BUILDING_BAZAAR?$AA@		; `string'
PUBLIC	??_C@_0BH@MGBGDCGF@LEADER_HARUN_AL_RASHID?$AA@	; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	?Destroy@?$BaseVector@VCvDeal@@$0A@@@IAEXPAVCvDeal@@I@Z ; BaseVector<CvDeal,0>::Destroy
PUBLIC	??Diterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::operator*
PUBLIC	??0iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::iterator
PUBLIC	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>
PUBLIC	__$ArrayPad$
PUBLIC	?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z ; CvGameDeals::FinalizeDeal
EXTRN	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z:PROC ; CvNotifications::Add
EXTRN	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ:PROC ; CvPlayer::GetNotifications
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:PROC
EXTRN	__imp_??1String@Localization@@UAE@XZ:PROC
EXTRN	__imp_??4String@Localization@@QAEAAV01@ABV01@@Z:PROC
EXTRN	__imp_?toUTF8@String@Localization@@QAEPBDXZ:PROC
EXTRN	?getName@CvTeam@@QBE?AVCvString@@XZ:PROC	; CvTeam::getName
EXTRN	__imp_?Lookup@Localization@@YA?AVString@1@PBD@Z:PROC
EXTRN	?ChangeNumTurnsLockedIntoWar@CvTeam@@QAEXW4TeamTypes@@H@Z:PROC ; CvTeam::ChangeNumTurnsLockedIntoWar
EXTRN	?declareWar@CvTeam@@QAEXW4TeamTypes@@_N@Z:PROC	; CvTeam::declareWar
EXTRN	?setForcePeace@CvTeam@@QAEXW4TeamTypes@@_N@Z:PROC ; CvTeam::setForcePeace
EXTRN	?makePeace@CvTeam@@QAEXW4TeamTypes@@_N1@Z:PROC	; CvTeam::makePeace
EXTRN	?SetHasTradeAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z:PROC ; CvTeam::SetHasTradeAgreement
EXTRN	?DoResearchAgreementNotification@CvGame@@QAEXW4TeamTypes@@0@Z:PROC ; CvGame::DoResearchAgreementNotification
EXTRN	?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z:PROC ; CvTreasury::LogExpenditure
EXTRN	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationShortDescription
EXTRN	?SetHasResearchAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z:PROC ; CvTeam::SetHasResearchAgreement
EXTRN	?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z:PROC ; CvTeam::SetHasDefensivePact
EXTRN	?SetAllowsOpenBordersToTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z:PROC ; CvTeam::SetAllowsOpenBordersToTeam
EXTRN	?AddVoteCommitment@CvLeagueAI@@QAEXW4PlayerTypes@@HHH_N@Z:PROC ; CvLeagueAI::AddVoteCommitment
EXTRN	?SetDoFCounter@CvDiplomacyAI@@QAEXW4PlayerTypes@@H@Z:PROC ; CvDiplomacyAI::SetDoFCounter
EXTRN	?SetDoFAccepted@CvDiplomacyAI@@QAEXW4PlayerTypes@@_N@Z:PROC ; CvDiplomacyAI::SetDoFAccepted
EXTRN	?SetHasEmbassyAtTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z:PROC ; CvTeam::SetHasEmbassyAtTeam
EXTRN	?acquireCity@CvPlayer@@QAEXPAVCvCity@@_N1@Z:PROC ; CvPlayer::acquireCity
EXTRN	?getBuildingClassCount@CvPlayer@@QBEHW4BuildingClassTypes@@@Z:PROC ; CvPlayer::getBuildingClassCount
EXTRN	?GetBuildingClassType@CvBuildingEntry@@QBEHXZ:PROC ; CvBuildingEntry::GetBuildingClassType
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
EXTRN	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z:PROC ; CvGlobals::getBuildingInfo
EXTRN	?getNumBuildingInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumBuildingInfos
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	__imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	?getLeaderTypeKey@CvPlayer@@QBEPBDXZ:PROC	; CvPlayer::getLeaderTypeKey
EXTRN	?isGameMultiPlayer@CvGame@@QBE_NXZ:PROC		; CvGame::isGameMultiPlayer
EXTRN	?changeResourceImport@CvPlayer@@QAEXW4ResourceTypes@@H@Z:PROC ; CvPlayer::changeResourceImport
EXTRN	?changeResourceExport@CvPlayer@@QAEXW4ResourceTypes@@H@Z:PROC ; CvPlayer::changeResourceExport
EXTRN	?ChangeGoldPerTurnFromDiplomacy@CvTreasury@@QAEXH@Z:PROC ; CvTreasury::ChangeGoldPerTurnFromDiplomacy
EXTRN	?ChangeGold@CvTreasury@@QAEXH@Z:PROC		; CvTreasury::ChangeGold
;	COMDAT ??_C@_09ODCIJKAA@?$FLNEWLINE?$FN?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_09ODCIJKAA@?$FLNEWLINE?$FN?$AA@ DB '[NEWLINE]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@HKECBLMG@TXT_KEY_MISC_MADE_PEACE_WITH_MIN@
CONST	SEGMENT
??_C@_0DC@HKECBLMG@TXT_KEY_MISC_MADE_PEACE_WITH_MIN@ DB 'TXT_KEY_MISC_MAD'
	DB	'E_PEACE_WITH_MINOR_ALLIES_SUMMARY', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@MOEBLOJE@TXT_KEY_MISC_MADE_PEACE_WITH_MIN@
CONST	SEGMENT
??_C@_0CK@MOEBLOJE@TXT_KEY_MISC_MADE_PEACE_WITH_MIN@ DB 'TXT_KEY_MISC_MAD'
	DB	'E_PEACE_WITH_MINOR_ALLIES', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FIPEIDLD@BUILDING_BAZAAR?$AA@
CONST	SEGMENT
??_C@_0BA@FIPEIDLD@BUILDING_BAZAAR?$AA@ DB 'BUILDING_BAZAAR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MGBGDCGF@LEADER_HARUN_AL_RASHID?$AA@
CONST	SEGMENT
??_C@_0BH@MGBGDCGF@LEADER_HARUN_AL_RASHID?$AA@ DB 'LEADER_HARUN_AL_RASHID'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z DD 019930522H
	DD	011H
	DD	FLAT:__unwindtable$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$5
	DD	03H
	DD	FLAT:__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$6
	DD	04H
	DD	FLAT:__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$11
	DD	04H
	DD	FLAT:__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$12
	DD	04H
	DD	FLAT:__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$13
	DD	01H
	DD	FLAT:__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$14
	DD	08H
	DD	FLAT:__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$15
	DD	09H
	DD	FLAT:__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$16
	DD	09H
	DD	FLAT:__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$17
	DD	09H
	DD	FLAT:__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$18
	DD	0cH
	DD	FLAT:__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$19
	DD	0dH
	DD	FLAT:__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$20
	DD	0cH
	DD	FLAT:__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$21
	DD	0fH
	DD	FLAT:__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$22
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z
_TEXT	SEGMENT
tv1076 = -3496						; size = 4
tv1697 = -3492						; size = 4
tv1115 = -3488						; size = 4
tv2211 = -3484						; size = 4
tv1113 = -3480						; size = 4
tv2469 = -3476						; size = 4
tv65 = -3472						; size = 4
tv2471 = -3468						; size = 4
tv886 = -3464						; size = 4
tv890 = -3460						; size = 4
tv876 = -3456						; size = 4
tv1102 = -3452						; size = 4
tv2213 = -3448						; size = 4
tv1859 = -3444						; size = 4
tv1868 = -3440						; size = 4
tv610 = -3436						; size = 4
tv1098 = -3432						; size = 4
tv1699 = -3428						; size = 4
tv1096 = -3424						; size = 4
tv1675 = -3420						; size = 4
tv529 = -3416						; size = 4
tv1092 = -3412						; size = 4
tv1088 = -3408						; size = 4
tv1082 = -3404						; size = 4
_this$ = -3400						; size = 4
$T239989 = -3384					; size = 4
$T239985 = -3380					; size = 4
$T239981 = -3376					; size = 4
$T239977 = -3372					; size = 4
$T239973 = -3368					; size = 4
$T239969 = -3364					; size = 4
$T239960 = -3360					; size = 4
$T239948 = -3356					; size = 4
$T239944 = -3349					; size = 1
$T239935 = -3348					; size = 4
$T239931 = -3344					; size = 4
$T239923 = -3340					; size = 4
$T239922 = -3336					; size = 4
$T239918 = -3332					; size = 4
_elem$239901 = -3328					; size = 8
$T239888 = -3320					; size = 4
$T239883 = -3316					; size = 4
$T239870 = -3312					; size = 4
$T239866 = -3308					; size = 4
$T239858 = -3304					; size = 4
$T239854 = -3300					; size = 4
$T239846 = -3296					; size = 4
$T239841 = -3292					; size = 4
$T239837 = -3288					; size = 4
$T239755 = -3276					; size = 4
$T239714 = -3272					; size = 4
$T239682 = -3268					; size = 4
_weightedElem$239676 = -3264				; size = 8
$T239658 = -3256					; size = 4
$T239628 = -3252					; size = 4
$T239596 = -3248					; size = 4
$T239561 = -3244					; size = 4
$T239555 = -3240					; size = 4
$T239551 = -3236					; size = 4
$T239547 = -3232					; size = 4
$T239546 = -3228					; size = 4
$T239537 = -3224					; size = 4
$T239504 = -3220					; size = 4
$T239469 = -3216					; size = 4
$T239434 = -3212					; size = 4
$T239428 = -3208					; size = 4
$T239424 = -3204					; size = 4
$T239397 = -3200					; size = 4
$T239391 = -3196					; size = 4
$T239364 = -3192					; size = 4
$T239358 = -3188					; size = 4
$T239331 = -3184					; size = 4
$T239325 = -3180					; size = 4
$T239298 = -3176					; size = 4
$T239266 = -3172					; size = 4
$T239260 = -3168					; size = 4
$T239256 = -3164					; size = 4
$T239252 = -3160					; size = 4
$T239248 = -3156					; size = 4
$T239218 = -3152					; size = 4
$T239183 = -3148					; size = 4
$T239169 = -3140					; size = 4
$T239168 = -3136					; size = 4
$T239167 = -3132					; size = 4
$T239134 = -3128					; size = 4
$T239121 = -3124					; size = 4
$T239117 = -3120					; size = 4
$T239110 = -3116					; size = 4
$T239106 = -3109					; size = 1
$T239102 = -3108					; size = 4
$T239098 = -3101					; size = 1
_iMapY$239166 = -3100					; size = 4
_iMapX$239165 = -3096					; size = 4
$T239091 = -3092					; size = 4
$T239087 = -3088					; size = 4
$T239060 = -3084					; size = 4
$T239054 = -3080					; size = 4
$T239027 = -3076					; size = 4
$T238995 = -3072					; size = 4
$T238989 = -3068					; size = 4
$T238985 = -3064					; size = 4
$T238969 = -3060					; size = 4
$T238961 = -3056					; size = 4
$T238952 = -3052					; size = 4
$T238948 = -3048					; size = 4
$T238944 = -3044					; size = 4
$T238940 = -3040					; size = 4
$T238924 = -3036					; size = 4
$T238920 = -3032					; size = 4
$T238916 = -3028					; size = 4
$T238909 = -3024					; size = 4
$T238905 = -3020					; size = 4
$T238901 = -3016					; size = 4
$T238894 = -3012					; size = 4
$T238890 = -3008					; size = 4
$T238886 = -3004					; size = 4
$T238874 = -3000					; size = 4
$T238862 = -2996					; size = 4
$T238855 = -2992					; size = 4
$T238834 = -2988					; size = 4
$T238818 = -2984					; size = 4
$T238814 = -2980					; size = 4
$T238805 = -2976					; size = 4
$T238783 = -2972					; size = 4
$T238770 = -2960					; size = 4
$T238760 = -2956					; size = 4
$T238756 = -2952					; size = 4
$T238752 = -2948					; size = 4
$T238748 = -2944					; size = 4
$T238744 = -2940					; size = 4
$T238723 = -2936					; size = 4
$T238707 = -2932					; size = 4
$T238703 = -2928					; size = 4
$T238694 = -2924					; size = 4
$T238653 = -2912					; size = 4
$T238640 = -2900					; size = 4
$T238628 = -2896					; size = 4
$T238624 = -2892					; size = 4
$T238620 = -2888					; size = 4
$T238616 = -2884					; size = 4
$T238612 = -2880					; size = 4
$T238608 = -2876					; size = 4
$T238604 = -2872					; size = 4
$T238600 = -2868					; size = 4
$T238579 = -2864					; size = 4
$T238563 = -2860					; size = 4
$T238559 = -2856					; size = 4
$T238550 = -2852					; size = 4
$T238524 = -2848					; size = 4
$T238488 = -2841					; size = 1
$T238487 = -2840					; size = 28
$T238486 = -2812					; size = 28
$T238485 = -2784					; size = 80
$T238484 = -2704					; size = 28
$T238483 = -2676					; size = 28
$T238482 = -2648					; size = 4
$T238481 = -2644					; size = 28
$T238480 = -2616					; size = 4
$T238479 = -2612					; size = 4
$T238478 = -2608					; size = 28
$T238477 = -2577					; size = 1
$T238476 = -2576					; size = 28
$T238475 = -2545					; size = 1
$T238474 = -2544					; size = 8
$T238473 = -2533					; size = 1
$T238472 = -2532					; size = 8
$T238471 = -2524					; size = 8
$T238470 = -2513					; size = 1
$T238469 = -2512					; size = 8
$T238468 = -2504					; size = 8
$T238467 = -2493					; size = 1
$T238466 = -2492					; size = 8
_eNotifPlayer$222455 = -2484				; size = 4
_iNotifPlayerLoop$222451 = -2480			; size = 4
_iPairIndex$222439 = -2476				; size = 4
_eFromTeam$222419 = -2472				; size = 4
_strMessage$222438 = -2468				; size = 28
_bFromTeamMadePeace$222422 = -2437			; size = 1
_strSummary$222426 = -2436				; size = 80
_eToTeam$222421 = -2352					; size = 4
_strTemp$222423 = -2348					; size = 80
_iFromTeamIndex$222415 = -2268				; size = 4
_iLockedTurns$222408 = -2264				; size = 4
_eTargetTeam$222406 = -2260				; size = 4
_bTargetTeamIsMinor$222402 = -2253			; size = 1
_eTargetTeam$222400 = -2252				; size = 4
_pCity$222380 = -2248					; size = 4
_pkBuildingEntry$222368 = -2244				; size = 4
_iJ$222364 = -2240					; size = 4
_iResourceQuantity$222355 = -2236			; size = 4
_eResource$222353 = -2232				; size = 4
_iGoldPerTurn$222350 = -2228				; size = 4
_iGoldAmount$222347 = -2224				; size = 4
_iLongestDuration$222323 = -2220			; size = 4
_eAcceptedToPlayer$222336 = -2216			; size = 4
_bSentResearchAgreementNotification$222333 = -2209	; size = 1
_iLatestItemLastTurn$222322 = -2208			; size = 4
_eFromTeam$222337 = -2204				; size = 4
_eToTeam$222338 = -2200					; size = 4
_iCost$222334 = -2196					; size = 4
_eAcceptedFromPlayer$222335 = -2192			; size = 4
_it$222324 = -2188					; size = 8
_tempDeals$222312 = -2180				; size = 1536
_iter$222303 = -640					; size = 8
_bFoundIt$ = -630					; size = 1
_bValid$ = -629						; size = 1
_veNowAtPeacePairs$ = -628				; size = 520
__$ArrayPad$ = -108					; size = 4
_dealIt$ = -104						; size = 4
_kDeal$ = -100						; size = 76
_eActivePlayer$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_eFromPlayer$ = 8					; size = 4
_eToPlayer$ = 12					; size = 4
_bAccepted$ = 16					; size = 1
?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z PROC ; CvGameDeals::FinalizeDeal, COMDAT
; _this$ = ecx

; 2320 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 3484				; 00000d9cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2321 : 	DealList::iterator dealIt;
; 2322 : 	CvDeal kDeal;

	lea	ecx, DWORD PTR _kDeal$[ebp]
	call	??0CvDeal@@QAE@XZ			; CvDeal::CvDeal
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2323 : 	bool bFoundIt = false;

	mov	BYTE PTR _bFoundIt$[ebp], 0

; 2324 : 	bool bValid   = true;

	mov	BYTE PTR _bValid$[ebp], 1

; 2325 : 	CvWeightedVector<TeamTypes, MAX_CIV_TEAMS, true> veNowAtPeacePairs; // hacked CvWeighedVector to keep track of third party minors that this deal makes at peace

	lea	ecx, DWORD PTR _veNowAtPeacePairs$[ebp]
	call	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 2326 : 
; 2327 : 	// Find the deal in the list of proposed deals
; 2328 : 	for(dealIt = m_ProposedDeals.begin(); dealIt != m_ProposedDeals.end(); ++dealIt)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _dealIt$[ebp], ecx
	jmp	SHORT $LN86@FinalizeDe
$LN85@FinalizeDe:
	mov	edx, DWORD PTR _dealIt$[ebp]
	add	edx, 76					; 0000004cH
	mov	DWORD PTR _dealIt$[ebp], edx
$LN86@FinalizeDe:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR $T238524[ebp], eax
	mov	ecx, DWORD PTR $T238524[ebp]
	mov	edx, DWORD PTR [ecx+4]
	imul	edx, 76					; 0000004cH
	mov	eax, DWORD PTR $T238524[ebp]
	add	edx, DWORD PTR [eax]
	cmp	DWORD PTR _dealIt$[ebp], edx
	je	SHORT $LN84@FinalizeDe

; 2329 : 	{
; 2330 : 		if(dealIt->m_eFromPlayer == eFromPlayer && dealIt->m_eToPlayer == eToPlayer)

	mov	ecx, DWORD PTR _dealIt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _eFromPlayer$[ebp]
	jne	SHORT $LN83@FinalizeDe
	mov	eax, DWORD PTR _dealIt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR _eToPlayer$[ebp]
	jne	SHORT $LN83@FinalizeDe

; 2331 : 		{
; 2332 : 			kDeal = *dealIt;

	mov	edx, DWORD PTR _dealIt$[ebp]
	push	edx
	lea	ecx, DWORD PTR _kDeal$[ebp]
	call	??4CvDeal@@QAEAAV0@ABV0@@Z		; CvDeal::operator=

; 2333 : 
; 2334 : // EFB: once we can use list containers in AutoVariables, go back to this way of deleting
; 2335 : //			m_ProposedDeals.erase(dealIt);
; 2336 : 			bFoundIt = true;

	mov	BYTE PTR _bFoundIt$[ebp], 1
$LN83@FinalizeDe:

; 2337 : 		}
; 2338 : 	}

	jmp	SHORT $LN85@FinalizeDe
$LN84@FinalizeDe:

; 2339 : 
; 2340 : 	if(bFoundIt)

	movzx	eax, BYTE PTR _bFoundIt$[ebp]
	test	eax, eax
	je	$LN82@FinalizeDe

; 2341 : 	{
; 2342 : 
; 2343 : 		TradedItemList::iterator iter;

	lea	ecx, DWORD PTR _iter$222303[ebp]
	call	??0iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::iterator
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 2344 : 		for(iter = kDeal.m_TradedItems.begin(); iter != kDeal.m_TradedItems.end(); ++iter)

	lea	ecx, DWORD PTR $T238466[ebp]
	push	ecx
	lea	ecx, DWORD PTR _kDeal$[ebp+44]
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv1082[ebp], eax
	mov	edx, DWORD PTR tv1082[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _iter$222303[ebp], eax
	mov	DWORD PTR _iter$222303[ebp+4], ecx
	jmp	SHORT $LN81@FinalizeDe
$LN80@FinalizeDe:
	cmp	DWORD PTR _iter$222303[ebp+4], 268435455 ; 0fffffffH
	jne	SHORT $LN133@FinalizeDe
	mov	edx, DWORD PTR _iter$222303[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _iter$222303[ebp+4], eax
	jmp	SHORT $LN81@FinalizeDe
$LN133@FinalizeDe:
	mov	ecx, DWORD PTR _iter$222303[ebp]
	mov	DWORD PTR $T238550[ebp], ecx
	mov	edx, DWORD PTR _iter$222303[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T238550[ebp]
	add	edx, DWORD PTR [eax+8]
	mov	DWORD PTR $T238559[ebp], edx
	mov	ecx, DWORD PTR $T238559[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T238563[ebp], edx
	mov	eax, DWORD PTR $T238563[ebp]
	mov	DWORD PTR _iter$222303[ebp+4], eax
$LN81@FinalizeDe:
	lea	ecx, DWORD PTR $T238468[ebp]
	push	ecx
	lea	ecx, DWORD PTR _kDeal$[ebp+44]
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T238579[ebp], eax
	mov	edx, DWORD PTR $T238579[ebp]
	mov	eax, DWORD PTR _iter$222303[ebp+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setne	cl
	mov	BYTE PTR $T238467[ebp], cl
	movzx	edx, BYTE PTR $T238467[ebp]
	test	edx, edx
	je	$LN79@FinalizeDe

; 2345 : 		{
; 2346 : 			if(iter->m_bToRenewed)  // slewis - added exception in case of something that was renewed

	lea	ecx, DWORD PTR _iter$222303[ebp]
	call	??Diterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::operator*
	add	eax, 8
	mov	DWORD PTR $T238600[ebp], eax
	mov	eax, DWORD PTR $T238600[ebp]
	movzx	ecx, BYTE PTR [eax+33]
	test	ecx, ecx
	je	SHORT $LN78@FinalizeDe

; 2347 : 			{
; 2348 : 				continue;

	jmp	$LN80@FinalizeDe
$LN78@FinalizeDe:

; 2349 : 			}
; 2350 : 
; 2351 : 			if(!kDeal.IsPossibleToTradeItem(iter->m_eFromPlayer, kDeal.GetOtherPlayer(iter->m_eFromPlayer), iter->m_eItemType, iter->m_iData1, iter->m_iData2, iter->m_iData3, iter->m_bFlag1, false, true))

	lea	ecx, DWORD PTR _iter$222303[ebp]
	call	??Diterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::operator*
	add	eax, 8
	mov	DWORD PTR $T238604[ebp], eax
	lea	ecx, DWORD PTR _iter$222303[ebp]
	call	??Diterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::operator*
	add	eax, 8
	mov	DWORD PTR $T238608[ebp], eax
	lea	ecx, DWORD PTR _iter$222303[ebp]
	call	??Diterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::operator*
	add	eax, 8
	mov	DWORD PTR $T238612[ebp], eax
	lea	ecx, DWORD PTR _iter$222303[ebp]
	call	??Diterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::operator*
	add	eax, 8
	mov	DWORD PTR $T238616[ebp], eax
	lea	ecx, DWORD PTR _iter$222303[ebp]
	call	??Diterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::operator*
	add	eax, 8
	mov	DWORD PTR $T238620[ebp], eax
	lea	ecx, DWORD PTR _iter$222303[ebp]
	call	??Diterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::operator*
	add	eax, 8
	mov	DWORD PTR $T238624[ebp], eax
	lea	ecx, DWORD PTR _iter$222303[ebp]
	call	??Diterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::operator*
	add	eax, 8
	mov	DWORD PTR $T238628[ebp], eax
	push	1
	push	0
	mov	edx, DWORD PTR $T238604[ebp]
	movzx	eax, BYTE PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR $T238608[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR $T238612[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR $T238616[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR $T238620[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR $T238624[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	lea	ecx, DWORD PTR _kDeal$[ebp]
	call	?GetOtherPlayer@CvDeal@@QBE?AW4PlayerTypes@@W42@@Z ; CvDeal::GetOtherPlayer
	push	eax
	mov	edx, DWORD PTR $T238628[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	lea	ecx, DWORD PTR _kDeal$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN77@FinalizeDe

; 2352 : 			{
; 2353 : 				// mark that the deal is no longer valid. We will still delete the deal but not commit its actions
; 2354 : 				bValid = false;

	mov	BYTE PTR _bValid$[ebp], 0

; 2355 : 				break;

	jmp	SHORT $LN79@FinalizeDe
$LN77@FinalizeDe:

; 2356 : 			}
; 2357 : 		}

	jmp	$LN80@FinalizeDe
$LN79@FinalizeDe:

; 2358 : 
; 2359 : 
; 2360 : 		// **** START HACK ****
; 2361 : 		// EFB: temporary delete method; recopy vector without this element
; 2362 : 		//
; 2363 : 		// Copy the deals into a temporary container
; 2364 : 		DealList tempDeals;

	lea	ecx, DWORD PTR _tempDeals$222312[ebp]
	call	??0?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvDeal,20,0,297,0>::FStaticVector<CvDeal,20,0,297,0>
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 2365 : 		for(dealIt = m_ProposedDeals.begin(); dealIt != m_ProposedDeals.end(); ++dealIt)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _dealIt$[ebp], eax
	jmp	SHORT $LN76@FinalizeDe
$LN75@FinalizeDe:
	mov	ecx, DWORD PTR _dealIt$[ebp]
	add	ecx, 76					; 0000004cH
	mov	DWORD PTR _dealIt$[ebp], ecx
$LN76@FinalizeDe:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	mov	DWORD PTR $T238640[ebp], edx
	mov	eax, DWORD PTR $T238640[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 76					; 0000004cH
	mov	edx, DWORD PTR $T238640[ebp]
	add	ecx, DWORD PTR [edx]
	cmp	DWORD PTR _dealIt$[ebp], ecx
	je	SHORT $LN74@FinalizeDe

; 2366 : 		{
; 2367 : 			tempDeals.push_back(*dealIt);

	mov	eax, DWORD PTR _dealIt$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tempDeals$222312[ebp]
	call	?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z ; FStaticVector<CvDeal,20,0,297,0>::push_back

; 2368 : 		}

	jmp	SHORT $LN75@FinalizeDe
$LN74@FinalizeDe:

; 2369 : 
; 2370 : 		// Copy back in minus this element
; 2371 : 		m_ProposedDeals.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	mov	DWORD PTR $T238653[ebp], ecx
	mov	edx, DWORD PTR $T238653[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR $T238653[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR $T238653[ebp]
	call	?Destroy@?$BaseVector@VCvDeal@@$0A@@@IAEXPAVCvDeal@@I@Z ; BaseVector<CvDeal,0>::Destroy
	mov	eax, DWORD PTR $T238653[ebp]
	mov	DWORD PTR [eax+4], 0

; 2372 : 		for(dealIt = tempDeals.begin(); dealIt != tempDeals.end(); ++dealIt)

	mov	ecx, DWORD PTR _tempDeals$222312[ebp]
	mov	DWORD PTR _dealIt$[ebp], ecx
	jmp	SHORT $LN191@FinalizeDe
$LN72@FinalizeDe:
	mov	edx, DWORD PTR _dealIt$[ebp]
	add	edx, 76					; 0000004cH
	mov	DWORD PTR _dealIt$[ebp], edx
$LN191@FinalizeDe:
	mov	eax, DWORD PTR _tempDeals$222312[ebp+4]
	imul	eax, 76					; 0000004cH
	add	eax, DWORD PTR _tempDeals$222312[ebp]
	cmp	DWORD PTR _dealIt$[ebp], eax
	je	SHORT $LN71@FinalizeDe

; 2373 : 		{
; 2374 : 			if(dealIt->m_eFromPlayer != eFromPlayer || dealIt->m_eToPlayer != eToPlayer)

	mov	ecx, DWORD PTR _dealIt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _eFromPlayer$[ebp]
	jne	SHORT $LN69@FinalizeDe
	mov	eax, DWORD PTR _dealIt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR _eToPlayer$[ebp]
	je	SHORT $LN70@FinalizeDe
$LN69@FinalizeDe:

; 2375 : 			{
; 2376 : 				m_ProposedDeals.push_back(*dealIt);

	mov	edx, DWORD PTR _dealIt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z ; FStaticVector<CvDeal,20,0,297,0>::push_back
$LN70@FinalizeDe:

; 2377 : 			}
; 2378 : 		}

	jmp	SHORT $LN72@FinalizeDe
$LN71@FinalizeDe:

; 2379 : 		// **** END HACK ****
; 2380 : 
; 2381 : 
; 2382 : 		if(bValid && bAccepted)

	movzx	eax, BYTE PTR _bValid$[ebp]
	test	eax, eax
	je	$LN68@FinalizeDe
	movzx	ecx, BYTE PTR _bAccepted$[ebp]
	test	ecx, ecx
	je	$LN68@FinalizeDe

; 2383 : 		{
; 2384 : 			// Determine total duration of the Deal
; 2385 : 			int iLatestItemLastTurn = 0;

	mov	DWORD PTR _iLatestItemLastTurn$222322[ebp], 0

; 2386 : 			int iLongestDuration = 0;

	mov	DWORD PTR _iLongestDuration$222323[ebp], 0

; 2387 : 			//int iTemp;
; 2388 : 
; 2389 : 			TradedItemList::iterator it;

	lea	ecx, DWORD PTR _it$222324[ebp]
	call	??0iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::iterator
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 2390 : 			for(it = kDeal.m_TradedItems.begin(); it != kDeal.m_TradedItems.end(); ++it)

	lea	edx, DWORD PTR $T238469[ebp]
	push	edx
	lea	ecx, DWORD PTR _kDeal$[ebp+44]
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv1088[ebp], eax
	mov	eax, DWORD PTR tv1088[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _it$222324[ebp], ecx
	mov	DWORD PTR _it$222324[ebp+4], edx
	jmp	SHORT $LN67@FinalizeDe
$LN66@FinalizeDe:
	cmp	DWORD PTR _it$222324[ebp+4], 268435455	; 0fffffffH
	jne	SHORT $LN213@FinalizeDe
	mov	eax, DWORD PTR _it$222324[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _it$222324[ebp+4], ecx
	jmp	SHORT $LN67@FinalizeDe
$LN213@FinalizeDe:
	mov	edx, DWORD PTR _it$222324[ebp]
	mov	DWORD PTR $T238694[ebp], edx
	mov	eax, DWORD PTR _it$222324[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T238694[ebp]
	add	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR $T238703[ebp], eax
	mov	edx, DWORD PTR $T238703[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T238707[ebp], eax
	mov	ecx, DWORD PTR $T238707[ebp]
	mov	DWORD PTR _it$222324[ebp+4], ecx
$LN67@FinalizeDe:
	lea	edx, DWORD PTR $T238471[ebp]
	push	edx
	lea	ecx, DWORD PTR _kDeal$[ebp+44]
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T238723[ebp], eax
	mov	eax, DWORD PTR $T238723[ebp]
	mov	ecx, DWORD PTR _it$222324[ebp+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setne	dl
	mov	BYTE PTR $T238470[ebp], dl
	movzx	eax, BYTE PTR $T238470[ebp]
	test	eax, eax
	je	$LN65@FinalizeDe

; 2391 : 			{
; 2392 : 				CvAssertMsg(it->m_eFromPlayer == kDeal.m_eFromPlayer || it->m_eFromPlayer == kDeal.m_eToPlayer, "DEAL: Adding deal that has an item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 2393 : 
; 2394 : 				// Calculate duration
; 2395 : 				if(it->m_iDuration > 0)

	lea	ecx, DWORD PTR _it$222324[ebp]
	call	??Diterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::operator*
	add	eax, 8
	mov	DWORD PTR $T238744[ebp], eax
	mov	ecx, DWORD PTR $T238744[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jle	$LN64@FinalizeDe

; 2396 : 				{
; 2397 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 2398 : 					it->m_iTurnsRemaining = it->m_iDuration;
; 2399 : #else
; 2400 : 					it->m_iFinalTurn = it->m_iDuration + GC.getGame().getGameTurn();

	lea	ecx, DWORD PTR _it$222324[ebp]
	call	??Diterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::operator*
	add	eax, 8
	mov	DWORD PTR $T238748[ebp], eax
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T238752[ebp], edx
	lea	ecx, DWORD PTR _it$222324[ebp]
	call	??Diterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::operator*
	add	eax, 8
	mov	DWORD PTR $T238756[ebp], eax
	mov	ecx, DWORD PTR $T238752[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, DWORD PTR $T238748[ebp]
	add	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR $T238756[ebp]
	mov	DWORD PTR [edx+8], eax

; 2401 : #endif
; 2402 : 					if(it->m_iDuration > iLongestDuration)

	lea	ecx, DWORD PTR _it$222324[ebp]
	call	??Diterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::operator*
	add	eax, 8
	mov	DWORD PTR $T238760[ebp], eax
	mov	eax, DWORD PTR $T238760[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _iLongestDuration$222323[ebp]
	jle	SHORT $LN64@FinalizeDe

; 2403 : 					{
; 2404 : 						iLongestDuration = it->m_iDuration;

	lea	ecx, DWORD PTR _it$222324[ebp]
	call	??Diterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::operator*
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _iLongestDuration$222323[ebp], edx

; 2405 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 2406 : 						iLatestItemLastTurn = it->m_iDuration + GC.getGame().getGameTurn();
; 2407 : #else
; 2408 : 						iLatestItemLastTurn = it->m_iFinalTurn;

	lea	ecx, DWORD PTR _it$222324[ebp]
	call	??Diterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::operator*
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR _iLatestItemLastTurn$222322[ebp], eax
$LN64@FinalizeDe:

; 2409 : #endif
; 2410 : 					}
; 2411 : 				}
; 2412 : 			}

	jmp	$LN66@FinalizeDe
$LN65@FinalizeDe:

; 2413 : 
; 2414 : 			kDeal.m_iDuration = iLongestDuration;

	mov	ecx, DWORD PTR _iLongestDuration$222323[ebp]
	mov	DWORD PTR _kDeal$[ebp+20], ecx

; 2415 : 			kDeal.m_iFinalTurn = iLatestItemLastTurn;

	mov	edx, DWORD PTR _iLatestItemLastTurn$222322[ebp]
	mov	DWORD PTR _kDeal$[ebp+16], edx

; 2416 : 			kDeal.m_iStartTurn = GC.getGame().getGameTurn();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T238770[ebp], eax
	mov	ecx, DWORD PTR $T238770[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	DWORD PTR _kDeal$[ebp+12], eax

; 2417 : 
; 2418 : 			// Add to current deals
; 2419 : 			CvAssertMsg(kDeal.m_TradedItems.size() > 0, "New deal has no tradeable items!");
; 2420 : 			m_CurrentDeals.push_back(kDeal);

	lea	ecx, DWORD PTR _kDeal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1540				; 00000604H
	call	?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z ; FStaticVector<CvDeal,20,0,297,0>::push_back

; 2421 : 			kDeal.m_iStartTurn = GC.getGame().getGameTurn();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T238783[ebp], edx
	mov	ecx, DWORD PTR $T238783[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	DWORD PTR _kDeal$[ebp+12], eax

; 2422 : 
; 2423 : 			bool bSentResearchAgreementNotification = false;

	mov	BYTE PTR _bSentResearchAgreementNotification$222333[ebp], 0

; 2424 : 
; 2425 : 			int iCost;
; 2426 : 
; 2427 : 			// What effects does this Deal have right now?
; 2428 : 			PlayerTypes eAcceptedFromPlayer;
; 2429 : 			PlayerTypes eAcceptedToPlayer;
; 2430 : 			TeamTypes eFromTeam;
; 2431 : 			TeamTypes eToTeam;
; 2432 : 
; 2433 : 			for(it = kDeal.m_TradedItems.begin(); it != kDeal.m_TradedItems.end(); ++it)

	lea	eax, DWORD PTR $T238472[ebp]
	push	eax
	lea	ecx, DWORD PTR _kDeal$[ebp+44]
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv1092[ebp], eax
	mov	ecx, DWORD PTR tv1092[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _it$222324[ebp], edx
	mov	DWORD PTR _it$222324[ebp+4], eax
	jmp	SHORT $LN62@FinalizeDe
$LN61@FinalizeDe:
	cmp	DWORD PTR _it$222324[ebp+4], 268435455	; 0fffffffH
	jne	SHORT $LN269@FinalizeDe
	mov	ecx, DWORD PTR _it$222324[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _it$222324[ebp+4], edx
	jmp	SHORT $LN62@FinalizeDe
$LN269@FinalizeDe:
	mov	eax, DWORD PTR _it$222324[ebp]
	mov	DWORD PTR $T238805[ebp], eax
	mov	ecx, DWORD PTR _it$222324[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T238805[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T238814[ebp], ecx
	mov	eax, DWORD PTR $T238814[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T238818[ebp], ecx
	mov	edx, DWORD PTR $T238818[ebp]
	mov	DWORD PTR _it$222324[ebp+4], edx
$LN62@FinalizeDe:
	lea	eax, DWORD PTR $T238474[ebp]
	push	eax
	lea	ecx, DWORD PTR _kDeal$[ebp+44]
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T238834[ebp], eax
	mov	ecx, DWORD PTR $T238834[ebp]
	mov	edx, DWORD PTR _it$222324[ebp+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setne	al
	mov	BYTE PTR $T238473[ebp], al
	movzx	ecx, BYTE PTR $T238473[ebp]
	test	ecx, ecx
	je	$LN60@FinalizeDe

; 2434 : 			{
; 2435 : 				// if the deal is renewed do not start it up
; 2436 : 				if(it->m_bToRenewed)

	lea	ecx, DWORD PTR _it$222324[ebp]
	call	??Diterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::operator*
	add	eax, 8
	mov	DWORD PTR $T238855[ebp], eax
	mov	edx, DWORD PTR $T238855[ebp]
	movzx	eax, BYTE PTR [edx+33]
	test	eax, eax
	je	SHORT $LN292@FinalizeDe

; 2437 : 				{
; 2438 : 					continue;

	jmp	$LN61@FinalizeDe

; 2439 : 				}
; 2440 : 
; 2441 : 				eAcceptedFromPlayer = it->m_eFromPlayer;

$LN292@FinalizeDe:
	lea	ecx, DWORD PTR _it$222324[ebp]
	call	??Diterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::operator*
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR _eAcceptedFromPlayer$222335[ebp], ecx

; 2442 : 				eAcceptedToPlayer = kDeal.GetOtherPlayer(eAcceptedFromPlayer);

	mov	edx, DWORD PTR _eAcceptedFromPlayer$222335[ebp]
	push	edx
	lea	ecx, DWORD PTR _kDeal$[ebp]
	call	?GetOtherPlayer@CvDeal@@QBE?AW4PlayerTypes@@W42@@Z ; CvDeal::GetOtherPlayer
	mov	DWORD PTR _eAcceptedToPlayer$222336[ebp], eax

; 2443 : 				eFromTeam = GET_PLAYER(eAcceptedFromPlayer).getTeam();

	mov	eax, DWORD PTR _eAcceptedFromPlayer$222335[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T238862[ebp], eax
	mov	ecx, DWORD PTR $T238862[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eFromTeam$222337[ebp], eax

; 2444 : 				eToTeam = GET_PLAYER(eAcceptedToPlayer).getTeam();

	mov	eax, DWORD PTR _eAcceptedToPlayer$222336[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T238874[ebp], eax
	mov	ecx, DWORD PTR $T238874[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eToTeam$222338[ebp], eax

; 2445 : 
; 2446 : 				CvAssertMsg(eAcceptedFromPlayer == kDeal.m_eFromPlayer || eAcceptedFromPlayer == kDeal.m_eToPlayer, "DEAL: Adding deal that has an item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 2447 : 
; 2448 : 				// Deduct Gold cost (if applicable)
; 2449 : 				iCost = GetTradeItemGoldCost(it->m_eItemType, eAcceptedFromPlayer, eAcceptedToPlayer);

	lea	ecx, DWORD PTR _it$222324[ebp]
	call	??Diterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::operator*
	add	eax, 8
	mov	DWORD PTR $T238886[ebp], eax
	mov	eax, DWORD PTR _eAcceptedToPlayer$222336[ebp]
	push	eax
	mov	ecx, DWORD PTR _eAcceptedFromPlayer$222335[ebp]
	push	ecx
	mov	edx, DWORD PTR $T238886[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTradeItemGoldCost@CvGameDeals@@QBEHW4TradeableItems@@W4PlayerTypes@@1@Z ; CvGameDeals::GetTradeItemGoldCost
	mov	DWORD PTR _iCost$222334[ebp], eax

; 2450 : 				GET_PLAYER(eAcceptedFromPlayer).GetTreasury()->ChangeGold(-iCost);

	mov	ecx, DWORD PTR _eAcceptedFromPlayer$222335[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T238890[ebp], ecx
	mov	edx, DWORD PTR _iCost$222334[ebp]
	neg	edx
	push	edx
	mov	ecx, DWORD PTR $T238890[ebp]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeGold@CvTreasury@@QAEXH@Z		; CvTreasury::ChangeGold

; 2451 : 
; 2452 : 				// Gold
; 2453 : 				if(it->m_eItemType == TRADE_ITEM_GOLD)

	lea	ecx, DWORD PTR _it$222324[ebp]
	call	??Diterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::operator*
	add	eax, 8
	mov	DWORD PTR $T238894[ebp], eax
	mov	eax, DWORD PTR $T238894[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN58@FinalizeDe

; 2454 : 				{
; 2455 : 					int iGoldAmount = it->m_iData1;

	lea	ecx, DWORD PTR _it$222324[ebp]
	call	??Diterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::operator*
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _iGoldAmount$222347[ebp], ecx

; 2456 : 					GET_PLAYER(eAcceptedFromPlayer).GetTreasury()->ChangeGold(-iGoldAmount);

	mov	edx, DWORD PTR _eAcceptedFromPlayer$222335[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T238901[ebp], edx
	mov	eax, DWORD PTR _iGoldAmount$222347[ebp]
	neg	eax
	push	eax
	mov	ecx, DWORD PTR $T238901[ebp]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeGold@CvTreasury@@QAEXH@Z		; CvTreasury::ChangeGold

; 2457 : 					GET_PLAYER(eAcceptedToPlayer).GetTreasury()->ChangeGold(iGoldAmount);

	mov	ecx, DWORD PTR _eAcceptedToPlayer$222336[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T238905[ebp], ecx
	mov	edx, DWORD PTR _iGoldAmount$222347[ebp]
	push	edx
	mov	ecx, DWORD PTR $T238905[ebp]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeGold@CvTreasury@@QAEXH@Z		; CvTreasury::ChangeGold
	jmp	$LN57@FinalizeDe
$LN58@FinalizeDe:

; 2458 : 				}
; 2459 : 				// Gold Per Turn
; 2460 : 				else if(it->m_eItemType == TRADE_ITEM_GOLD_PER_TURN)

	lea	ecx, DWORD PTR _it$222324[ebp]
	call	??Diterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::operator*
	add	eax, 8
	mov	DWORD PTR $T238909[ebp], eax
	mov	eax, DWORD PTR $T238909[ebp]
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN56@FinalizeDe

; 2461 : 				{
; 2462 : 					int iGoldPerTurn = it->m_iData1;

	lea	ecx, DWORD PTR _it$222324[ebp]
	call	??Diterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::operator*
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _iGoldPerTurn$222350[ebp], ecx

; 2463 : 					GET_PLAYER(eAcceptedFromPlayer).GetTreasury()->ChangeGoldPerTurnFromDiplomacy(-iGoldPerTurn);

	mov	edx, DWORD PTR _eAcceptedFromPlayer$222335[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T238916[ebp], edx
	mov	eax, DWORD PTR _iGoldPerTurn$222350[ebp]
	neg	eax
	push	eax
	mov	ecx, DWORD PTR $T238916[ebp]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeGoldPerTurnFromDiplomacy@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeGoldPerTurnFromDiplomacy

; 2464 : 					GET_PLAYER(eAcceptedToPlayer).GetTreasury()->ChangeGoldPerTurnFromDiplomacy(iGoldPerTurn);

	mov	ecx, DWORD PTR _eAcceptedToPlayer$222336[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T238920[ebp], ecx
	mov	edx, DWORD PTR _iGoldPerTurn$222350[ebp]
	push	edx
	mov	ecx, DWORD PTR $T238920[ebp]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeGoldPerTurnFromDiplomacy@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeGoldPerTurnFromDiplomacy
	jmp	$LN57@FinalizeDe
$LN56@FinalizeDe:

; 2465 : 				}
; 2466 : 				// Resource
; 2467 : 				else if(it->m_eItemType == TRADE_ITEM_RESOURCES)

	lea	ecx, DWORD PTR _it$222324[ebp]
	call	??Diterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::operator*
	add	eax, 8
	mov	DWORD PTR $T238924[ebp], eax
	mov	eax, DWORD PTR $T238924[ebp]
	cmp	DWORD PTR [eax], 3
	jne	$LN54@FinalizeDe

; 2468 : 				{
; 2469 : 					ResourceTypes eResource = (ResourceTypes) it->m_iData1;

	lea	ecx, DWORD PTR _it$222324[ebp]
	call	??Diterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::operator*
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _eResource$222353[ebp], ecx

; 2470 : 					int iResourceQuantity = it->m_iData2;

	lea	ecx, DWORD PTR _it$222324[ebp]
	call	??Diterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::operator*
	mov	edx, DWORD PTR [eax+24]
	mov	DWORD PTR _iResourceQuantity$222355[ebp], edx

; 2471 : 					GET_PLAYER(eAcceptedFromPlayer).changeResourceExport(eResource, iResourceQuantity);

	mov	eax, DWORD PTR _iResourceQuantity$222355[ebp]
	push	eax
	mov	ecx, DWORD PTR _eResource$222353[ebp]
	push	ecx
	mov	ecx, DWORD PTR _eAcceptedFromPlayer$222335[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?changeResourceExport@CvPlayer@@QAEXW4ResourceTypes@@H@Z ; CvPlayer::changeResourceExport

; 2472 : 					GET_PLAYER(eAcceptedToPlayer).changeResourceImport(eResource, iResourceQuantity);

	mov	edx, DWORD PTR _iResourceQuantity$222355[ebp]
	push	edx
	mov	eax, DWORD PTR _eResource$222353[ebp]
	push	eax
	mov	ecx, DWORD PTR _eAcceptedToPlayer$222336[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?changeResourceImport@CvPlayer@@QAEXW4ResourceTypes@@H@Z ; CvPlayer::changeResourceImport

; 2473 : 
; 2474 : 					//Resource Trading Achievements
; 2475 : 					if(!GC.getGame().isGameMultiPlayer())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T238940[ebp], ecx
	mov	ecx, DWORD PTR $T238940[ebp]
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	movzx	edx, al
	test	edx, edx
	jne	$LN53@FinalizeDe

; 2476 : 					{
; 2477 : 						if(GET_PLAYER(eAcceptedFromPlayer).isHuman())

	mov	eax, DWORD PTR _eAcceptedFromPlayer$222335[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T238944[ebp], eax
	mov	ecx, DWORD PTR $T238944[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	ecx, al
	test	ecx, ecx
	je	$LN53@FinalizeDe

; 2478 : 						{
; 2479 : 							gDLL->IncrementSteamStatAndUnlock(ESTEAMSTAT_RESOURCESTRADED, 100, ACHIEVEMENT_100RESOURCES);

	mov	edx, DWORD PTR $T238948[ebp]
	mov	DWORD PTR tv529[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv529[ebp], eax
	push	93					; 0000005dH
	push	100					; 00000064H
	push	119					; 00000077H
	mov	ecx, DWORD PTR tv529[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv529[ebp]
	mov	eax, DWORD PTR [edx+848]
	call	eax

; 2480 : 
; 2481 : 							if(GC.getResourceInfo(eResource)->getResourceUsage() == RESOURCEUSAGE_LUXURY)

	mov	ecx, DWORD PTR _eResource$222353[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	cmp	eax, 2
	jne	$LN53@FinalizeDe

; 2482 : 							{
; 2483 : 								//OutputDebugString("\nStep0");
; 2484 : 								if(((CvString)GET_PLAYER(eAcceptedFromPlayer).getLeaderTypeKey() == "LEADER_HARUN_AL_RASHID"))

	mov	edx, DWORD PTR _eAcceptedFromPlayer$222335[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T238952[ebp], edx
	mov	ecx, DWORD PTR $T238952[ebp]
	call	?getLeaderTypeKey@CvPlayer@@QBEPBDXZ	; CvPlayer::getLeaderTypeKey
	mov	DWORD PTR $T238961[ebp], eax
	cmp	DWORD PTR $T238961[ebp], 0
	je	SHORT $LN346@FinalizeDe
	mov	eax, DWORD PTR $T238961[ebp]
	mov	DWORD PTR tv1675[ebp], eax
	jmp	SHORT $LN347@FinalizeDe
$LN346@FinalizeDe:
	mov	DWORD PTR tv1675[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN347@FinalizeDe:
	mov	ecx, DWORD PTR tv1675[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T238476[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	edx, DWORD PTR $T238476[ebp]
	mov	DWORD PTR tv1096[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	push	OFFSET ??_C@_0BH@MGBGDCGF@LEADER_HARUN_AL_RASHID?$AA@
	mov	eax, DWORD PTR tv1096[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	mov	BYTE PTR $T238475[ebp], al
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T238476[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	movzx	ecx, BYTE PTR $T238475[ebp]
	test	ecx, ecx
	je	$LN53@FinalizeDe

; 2485 : 								{
; 2486 : 									//OutputDebugString("\nStep1");
; 2487 : #ifdef AUI_WARNING_FIXES
; 2488 : 									for (uint iJ = 0; iJ < GC.getNumBuildingInfos(); iJ++)
; 2489 : #else
; 2490 : 									int iJ;
; 2491 : 									for(iJ = 0; iJ < GC.getNumBuildingInfos(); iJ++)

	mov	DWORD PTR _iJ$222364[ebp], 0
	jmp	SHORT $LN49@FinalizeDe
$LN48@FinalizeDe:
	mov	edx, DWORD PTR _iJ$222364[ebp]
	add	edx, 1
	mov	DWORD PTR _iJ$222364[ebp], edx
$LN49@FinalizeDe:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	cmp	DWORD PTR _iJ$222364[ebp], eax
	jge	$LN53@FinalizeDe

; 2492 : #endif
; 2493 : 									{
; 2494 : 										CvBuildingEntry* pkBuildingEntry = GC.getBuildingInfo((BuildingTypes)iJ);

	mov	eax, DWORD PTR _iJ$222364[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	DWORD PTR _pkBuildingEntry$222368[ebp], eax

; 2495 : 										if(pkBuildingEntry)

	cmp	DWORD PTR _pkBuildingEntry$222368[ebp], 0
	je	$LN46@FinalizeDe

; 2496 : 										{
; 2497 : 											if((CvString)pkBuildingEntry->GetType() == "BUILDING_BAZAAR")

	mov	ecx, DWORD PTR _pkBuildingEntry$222368[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T238969[ebp], eax
	cmp	DWORD PTR $T238969[ebp], 0
	je	SHORT $LN356@FinalizeDe
	mov	ecx, DWORD PTR $T238969[ebp]
	mov	DWORD PTR tv1699[ebp], ecx
	jmp	SHORT $LN357@FinalizeDe
$LN356@FinalizeDe:
	mov	DWORD PTR tv1699[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN357@FinalizeDe:
	mov	edx, DWORD PTR tv1699[ebp]
	push	edx
	lea	ecx, DWORD PTR $T238478[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR $T238478[ebp]
	mov	DWORD PTR tv1098[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	push	OFFSET ??_C@_0BA@FIPEIDLD@BUILDING_BAZAAR?$AA@
	mov	ecx, DWORD PTR tv1098[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	mov	BYTE PTR $T238477[ebp], al
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T238478[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	movzx	edx, BYTE PTR $T238477[ebp]
	test	edx, edx
	je	SHORT $LN46@FinalizeDe

; 2498 : 											{
; 2499 : 												//OutputDebugString("\nStep2");
; 2500 : 												if(GET_PLAYER(eAcceptedFromPlayer).getBuildingClassCount((BuildingClassTypes)pkBuildingEntry->GetBuildingClassType()) >= 1)

	mov	eax, DWORD PTR _eAcceptedFromPlayer$222335[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T238985[ebp], eax
	mov	ecx, DWORD PTR _pkBuildingEntry$222368[ebp]
	call	?GetBuildingClassType@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetBuildingClassType
	push	eax
	mov	ecx, DWORD PTR $T238985[ebp]
	call	?getBuildingClassCount@CvPlayer@@QBEHW4BuildingClassTypes@@@Z ; CvPlayer::getBuildingClassCount
	cmp	eax, 1
	jl	SHORT $LN46@FinalizeDe

; 2501 : 												{
; 2502 : 													gDLL->UnlockAchievement(ACHIEVEMENT_SPECIAL_TRADER);

	mov	ecx, DWORD PTR $T238989[ebp]
	mov	DWORD PTR tv610[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv610[ebp], edx
	push	99					; 00000063H
	mov	eax, DWORD PTR tv610[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv610[ebp]
	mov	eax, DWORD PTR [edx+828]
	call	eax
$LN46@FinalizeDe:

; 2503 : 												}
; 2504 : 
; 2505 : 											}
; 2506 : 										}
; 2507 : 									}

	jmp	$LN48@FinalizeDe
$LN53@FinalizeDe:

; 2508 : 								}
; 2509 : 							}
; 2510 : 						}
; 2511 : 					}
; 2512 : 				}

	jmp	$LN57@FinalizeDe
$LN54@FinalizeDe:

; 2513 : 				// City
; 2514 : 				else if(it->m_eItemType == TRADE_ITEM_CITIES)

	mov	ecx, DWORD PTR _it$222324[ebp]
	mov	DWORD PTR $T238995[ebp], ecx
	mov	edx, DWORD PTR _it$222324[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T238995[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	DWORD PTR [ecx+edx+8], 4
	jne	$LN42@FinalizeDe

; 2515 : 				{
; 2516 : 					CvCity* pCity = GC.getMap().plot(it->m_iData1, it->m_iData2)->getPlotCity();

	mov	edx, DWORD PTR _it$222324[ebp]
	mov	DWORD PTR $T239027[ebp], edx
	mov	eax, DWORD PTR _it$222324[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T239027[ebp]
	mov	edx, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [edx+eax+8]
	mov	DWORD PTR $T239054[ebp], eax
	mov	ecx, DWORD PTR _it$222324[ebp]
	mov	DWORD PTR $T239060[ebp], ecx
	mov	edx, DWORD PTR _it$222324[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T239060[ebp]
	mov	ecx, DWORD PTR [eax+8]
	lea	edx, DWORD PTR [ecx+edx+8]
	mov	DWORD PTR $T239087[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T239091[ebp], eax
	mov	ecx, DWORD PTR $T239054[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR $T239168[ebp], edx
	mov	eax, DWORD PTR $T239087[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR $T239167[ebp], ecx
	cmp	DWORD PTR $T239167[ebp], -2147483647	; 80000001H
	je	SHORT $LN398@FinalizeDe
	cmp	DWORD PTR $T239168[ebp], -2147483647	; 80000001H
	jne	SHORT $LN399@FinalizeDe
$LN398@FinalizeDe:
	mov	DWORD PTR $T239169[ebp], 0
	jmp	$LN400@FinalizeDe
$LN399@FinalizeDe:
	mov	edx, DWORD PTR $T239091[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T239098[ebp], al
	mov	ecx, DWORD PTR $T239091[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T239102[ebp], edx
	movzx	eax, BYTE PTR $T239098[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239102[ebp]
	push	ecx
	mov	edx, DWORD PTR $T239167[ebp]
	push	edx
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapX$239165[ebp], eax
	mov	eax, DWORD PTR $T239091[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T239106[ebp], cl
	mov	edx, DWORD PTR $T239091[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T239110[ebp], eax
	movzx	ecx, BYTE PTR $T239106[ebp]
	push	ecx
	mov	edx, DWORD PTR $T239110[ebp]
	push	edx
	mov	eax, DWORD PTR $T239168[ebp]
	push	eax
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapY$239166[ebp], eax
	cmp	DWORD PTR _iMapX$239165[ebp], 0
	jl	SHORT $LN414@FinalizeDe
	mov	ecx, DWORD PTR $T239091[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T239117[ebp], edx
	mov	eax, DWORD PTR _iMapX$239165[ebp]
	cmp	eax, DWORD PTR $T239117[ebp]
	jge	SHORT $LN414@FinalizeDe
	cmp	DWORD PTR _iMapY$239166[ebp], 0
	jl	SHORT $LN414@FinalizeDe
	mov	ecx, DWORD PTR $T239091[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T239121[ebp], edx
	mov	eax, DWORD PTR _iMapY$239166[ebp]
	cmp	eax, DWORD PTR $T239121[ebp]
	jge	SHORT $LN414@FinalizeDe
	mov	DWORD PTR tv1868[ebp], 1
	jmp	SHORT $LN412@FinalizeDe
$LN414@FinalizeDe:
	mov	DWORD PTR tv1868[ebp], 0
$LN412@FinalizeDe:
	cmp	DWORD PTR tv1868[ebp], 0
	je	SHORT $LN402@FinalizeDe
	mov	ecx, DWORD PTR $T239091[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T239134[ebp], edx
	mov	eax, DWORD PTR _iMapY$239166[ebp]
	imul	eax, DWORD PTR $T239134[ebp]
	add	eax, DWORD PTR _iMapX$239165[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T239091[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv1859[ebp], eax
	jmp	SHORT $LN403@FinalizeDe
$LN402@FinalizeDe:
	mov	DWORD PTR tv1859[ebp], 0
$LN403@FinalizeDe:
	mov	edx, DWORD PTR tv1859[ebp]
	mov	DWORD PTR $T239169[ebp], edx
$LN400@FinalizeDe:
	mov	ecx, DWORD PTR $T239169[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pCity$222380[ebp], eax

; 2517 : 					if(pCity != NULL)

	cmp	DWORD PTR _pCity$222380[ebp], 0
	je	SHORT $LN41@FinalizeDe

; 2518 : 						GET_PLAYER(eAcceptedToPlayer).acquireCity(pCity, false, true);

	push	1
	push	0
	mov	eax, DWORD PTR _pCity$222380[ebp]
	push	eax
	mov	ecx, DWORD PTR _eAcceptedToPlayer$222336[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?acquireCity@CvPlayer@@QAEXPAVCvCity@@_N1@Z ; CvPlayer::acquireCity
$LN41@FinalizeDe:

; 2519 : 				}

	jmp	$LN57@FinalizeDe
$LN42@FinalizeDe:

; 2520 : 				else if(it->m_eItemType == TRADE_ITEM_ALLOW_EMBASSY)

	mov	ecx, DWORD PTR _it$222324[ebp]
	mov	DWORD PTR $T239183[ebp], ecx
	mov	edx, DWORD PTR _it$222324[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T239183[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	DWORD PTR [ecx+edx+8], 17		; 00000011H
	jne	SHORT $LN39@FinalizeDe

; 2521 : 				{
; 2522 : 					GET_TEAM(eToTeam).SetHasEmbassyAtTeam(eFromTeam, true);

	push	1
	mov	edx, DWORD PTR _eFromTeam$222337[ebp]
	push	edx
	mov	ecx, DWORD PTR _eToTeam$222338[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?SetHasEmbassyAtTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasEmbassyAtTeam
	jmp	$LN57@FinalizeDe
$LN39@FinalizeDe:

; 2523 : 				}
; 2524 : 				else if(it->m_eItemType == TRADE_ITEM_DECLARATION_OF_FRIENDSHIP)

	mov	eax, DWORD PTR _it$222324[ebp]
	mov	DWORD PTR $T239218[ebp], eax
	mov	ecx, DWORD PTR _it$222324[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T239218[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	DWORD PTR [eax+ecx+8], 18		; 00000012H
	jne	$LN37@FinalizeDe

; 2525 : 				{
; 2526 : 					// Declaration of friendship always goes both ways.  We will most likely have two entries in the deal for this
; 2527 : 					// but just in case, set both anyway.
; 2528 : 					GET_PLAYER(eAcceptedFromPlayer).GetDiplomacyAI()->SetDoFAccepted(eAcceptedToPlayer, true);

	mov	ecx, DWORD PTR _eAcceptedFromPlayer$222335[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239248[ebp], ecx
	push	1
	mov	edx, DWORD PTR _eAcceptedToPlayer$222336[ebp]
	push	edx
	mov	ecx, DWORD PTR $T239248[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?SetDoFAccepted@CvDiplomacyAI@@QAEXW4PlayerTypes@@_N@Z ; CvDiplomacyAI::SetDoFAccepted

; 2529 : 					GET_PLAYER(eAcceptedFromPlayer).GetDiplomacyAI()->SetDoFCounter(eAcceptedToPlayer, 0);

	mov	eax, DWORD PTR _eAcceptedFromPlayer$222335[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239252[ebp], eax
	push	0
	mov	ecx, DWORD PTR _eAcceptedToPlayer$222336[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T239252[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?SetDoFCounter@CvDiplomacyAI@@QAEXW4PlayerTypes@@H@Z ; CvDiplomacyAI::SetDoFCounter

; 2530 : 					GET_PLAYER(eAcceptedToPlayer).GetDiplomacyAI()->SetDoFAccepted(eAcceptedFromPlayer, true);

	mov	edx, DWORD PTR _eAcceptedToPlayer$222336[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239256[ebp], edx
	push	1
	mov	eax, DWORD PTR _eAcceptedFromPlayer$222335[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239256[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?SetDoFAccepted@CvDiplomacyAI@@QAEXW4PlayerTypes@@_N@Z ; CvDiplomacyAI::SetDoFAccepted

; 2531 : 					GET_PLAYER(eAcceptedToPlayer).GetDiplomacyAI()->SetDoFCounter(eAcceptedFromPlayer, 0);

	mov	ecx, DWORD PTR _eAcceptedToPlayer$222336[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239260[ebp], ecx
	push	0
	mov	edx, DWORD PTR _eAcceptedFromPlayer$222335[ebp]
	push	edx
	mov	ecx, DWORD PTR $T239260[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?SetDoFCounter@CvDiplomacyAI@@QAEXW4PlayerTypes@@H@Z ; CvDiplomacyAI::SetDoFCounter
	jmp	$LN57@FinalizeDe
$LN37@FinalizeDe:

; 2532 : 				}
; 2533 : 				// Vote Commitment
; 2534 : 				else if(it->m_eItemType == TRADE_ITEM_VOTE_COMMITMENT)

	mov	eax, DWORD PTR _it$222324[ebp]
	mov	DWORD PTR $T239266[ebp], eax
	mov	ecx, DWORD PTR _it$222324[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T239266[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	DWORD PTR [eax+ecx+8], 19		; 00000013H
	jne	$LN35@FinalizeDe

; 2535 : 				{
; 2536 : 					GET_PLAYER(eAcceptedFromPlayer).GetLeagueAI()->AddVoteCommitment(eAcceptedToPlayer, it->m_iData1, it->m_iData2, it->m_iData3, it->m_bFlag1);

	mov	ecx, DWORD PTR _it$222324[ebp]
	mov	DWORD PTR $T239298[ebp], ecx
	mov	edx, DWORD PTR _it$222324[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T239298[ebp]
	mov	ecx, DWORD PTR [eax+8]
	lea	edx, DWORD PTR [ecx+edx+8]
	mov	DWORD PTR $T239325[ebp], edx
	mov	eax, DWORD PTR _it$222324[ebp]
	mov	DWORD PTR $T239331[ebp], eax
	mov	ecx, DWORD PTR _it$222324[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T239331[ebp]
	mov	eax, DWORD PTR [edx+8]
	lea	ecx, DWORD PTR [eax+ecx+8]
	mov	DWORD PTR $T239358[ebp], ecx
	mov	edx, DWORD PTR _it$222324[ebp]
	mov	DWORD PTR $T239364[ebp], edx
	mov	eax, DWORD PTR _it$222324[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T239364[ebp]
	mov	edx, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [edx+eax+8]
	mov	DWORD PTR $T239391[ebp], eax
	mov	ecx, DWORD PTR _it$222324[ebp]
	mov	DWORD PTR $T239397[ebp], ecx
	mov	edx, DWORD PTR _it$222324[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T239397[ebp]
	mov	ecx, DWORD PTR [eax+8]
	lea	edx, DWORD PTR [ecx+edx+8]
	mov	DWORD PTR $T239424[ebp], edx
	mov	eax, DWORD PTR _eAcceptedFromPlayer$222335[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239428[ebp], eax
	mov	ecx, DWORD PTR $T239325[ebp]
	movzx	edx, BYTE PTR [ecx+24]
	push	edx
	mov	eax, DWORD PTR $T239358[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR $T239391[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR $T239424[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _eAcceptedToPlayer$222336[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239428[ebp]
	call	?GetLeagueAI@CvPlayer@@QBEPAVCvLeagueAI@@XZ ; CvPlayer::GetLeagueAI
	mov	ecx, eax
	call	?AddVoteCommitment@CvLeagueAI@@QAEXW4PlayerTypes@@HHH_N@Z ; CvLeagueAI::AddVoteCommitment
	jmp	$LN57@FinalizeDe
$LN35@FinalizeDe:

; 2537 : 				}
; 2538 : 				// Open Borders
; 2539 : 				else if(it->m_eItemType == TRADE_ITEM_OPEN_BORDERS)

	mov	ecx, DWORD PTR _it$222324[ebp]
	mov	DWORD PTR $T239434[ebp], ecx
	mov	edx, DWORD PTR _it$222324[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T239434[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	DWORD PTR [ecx+edx+8], 6
	jne	SHORT $LN33@FinalizeDe

; 2540 : 				{
; 2541 : 					GET_TEAM(eFromTeam).SetAllowsOpenBordersToTeam(eToTeam, true);

	push	1
	mov	edx, DWORD PTR _eToTeam$222338[ebp]
	push	edx
	mov	ecx, DWORD PTR _eFromTeam$222337[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?SetAllowsOpenBordersToTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetAllowsOpenBordersToTeam
	jmp	$LN57@FinalizeDe
$LN33@FinalizeDe:

; 2542 : 				}
; 2543 : 				// Defensive Pact
; 2544 : 				else if(it->m_eItemType == TRADE_ITEM_DEFENSIVE_PACT)

	mov	eax, DWORD PTR _it$222324[ebp]
	mov	DWORD PTR $T239469[ebp], eax
	mov	ecx, DWORD PTR _it$222324[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T239469[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	DWORD PTR [eax+ecx+8], 7
	jne	SHORT $LN31@FinalizeDe

; 2545 : 				{
; 2546 : 					GET_TEAM(eFromTeam).SetHasDefensivePact(eToTeam, true);

	push	1
	mov	ecx, DWORD PTR _eToTeam$222338[ebp]
	push	ecx
	mov	ecx, DWORD PTR _eFromTeam$222337[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasDefensivePact
	jmp	$LN57@FinalizeDe
$LN31@FinalizeDe:

; 2547 : 				}
; 2548 : 				// Research Agreement
; 2549 : 				else if(it->m_eItemType == TRADE_ITEM_RESEARCH_AGREEMENT)

	mov	edx, DWORD PTR _it$222324[ebp]
	mov	DWORD PTR $T239504[ebp], edx
	mov	eax, DWORD PTR _it$222324[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T239504[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+eax+8], 8
	jne	$LN29@FinalizeDe

; 2550 : 				{
; 2551 : 					GET_TEAM(eFromTeam).SetHasResearchAgreement(eToTeam, true);

	push	1
	mov	eax, DWORD PTR _eToTeam$222338[ebp]
	push	eax
	mov	ecx, DWORD PTR _eFromTeam$222337[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?SetHasResearchAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasResearchAgreement

; 2552 : 					GET_PLAYER(eAcceptedFromPlayer).GetTreasury()->LogExpenditure(GET_PLAYER(eAcceptedToPlayer).getCivilizationShortDescription(), iCost, 9);

	push	9
	mov	ecx, DWORD PTR _iCost$222334[ebp]
	push	ecx
	mov	edx, DWORD PTR _eAcceptedToPlayer$222336[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239537[ebp], edx
	mov	ecx, DWORD PTR $T239537[ebp]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T239547[ebp], eax
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T238479[ebp], esp
	mov	DWORD PTR $T239546[ebp], eax
	cmp	DWORD PTR $T239547[ebp], 0
	je	SHORT $LN553@FinalizeDe
	mov	ecx, DWORD PTR $T239547[ebp]
	mov	DWORD PTR tv2213[ebp], ecx
	jmp	SHORT $LN554@FinalizeDe
$LN553@FinalizeDe:
	mov	DWORD PTR tv2213[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN554@FinalizeDe:
	mov	edx, DWORD PTR tv2213[ebp]
	push	edx
	mov	ecx, DWORD PTR $T239546[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR $T239546[ebp]
	mov	DWORD PTR tv1102[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	ecx, DWORD PTR _eAcceptedFromPlayer$222335[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239551[ebp], ecx
	mov	ecx, DWORD PTR $T239551[ebp]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, eax
	call	?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z ; CvTreasury::LogExpenditure

; 2553 : 
; 2554 : 					if(!bSentResearchAgreementNotification)

	movzx	edx, BYTE PTR _bSentResearchAgreementNotification$222333[ebp]
	test	edx, edx
	jne	SHORT $LN28@FinalizeDe

; 2555 : 					{
; 2556 : 						bSentResearchAgreementNotification = true;

	mov	BYTE PTR _bSentResearchAgreementNotification$222333[ebp], 1

; 2557 : 						GC.getGame().DoResearchAgreementNotification(eFromTeam, eToTeam);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T239555[ebp], eax
	mov	ecx, DWORD PTR _eToTeam$222338[ebp]
	push	ecx
	mov	edx, DWORD PTR _eFromTeam$222337[ebp]
	push	edx
	mov	ecx, DWORD PTR $T239555[ebp]
	call	?DoResearchAgreementNotification@CvGame@@QAEXW4TeamTypes@@0@Z ; CvGame::DoResearchAgreementNotification
$LN28@FinalizeDe:

; 2558 : 					}
; 2559 : 				}

	jmp	$LN57@FinalizeDe
$LN29@FinalizeDe:

; 2560 : 				// Trade Agreement
; 2561 : 				else if(it->m_eItemType == TRADE_ITEM_TRADE_AGREEMENT)

	mov	eax, DWORD PTR _it$222324[ebp]
	mov	DWORD PTR $T239561[ebp], eax
	mov	ecx, DWORD PTR _it$222324[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T239561[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	DWORD PTR [eax+ecx+8], 9
	jne	SHORT $LN26@FinalizeDe

; 2562 : 				{
; 2563 : 					GET_TEAM(eFromTeam).SetHasTradeAgreement(eToTeam, true);

	push	1
	mov	ecx, DWORD PTR _eToTeam$222338[ebp]
	push	ecx
	mov	ecx, DWORD PTR _eFromTeam$222337[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?SetHasTradeAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasTradeAgreement
	jmp	$LN57@FinalizeDe
$LN26@FinalizeDe:

; 2564 : 				}
; 2565 : 				// Third Party Peace
; 2566 : 				else if(it->m_eItemType == TRADE_ITEM_THIRD_PARTY_PEACE)

	mov	edx, DWORD PTR _it$222324[ebp]
	mov	DWORD PTR $T239596[ebp], edx
	mov	eax, DWORD PTR _it$222324[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T239596[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+eax+8], 14		; 0000000eH
	jne	$LN24@FinalizeDe

; 2567 : 				{
; 2568 : 					TeamTypes eTargetTeam = (TeamTypes) it->m_iData1;

	mov	eax, DWORD PTR _it$222324[ebp]
	mov	DWORD PTR $T239628[ebp], eax
	mov	ecx, DWORD PTR _it$222324[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T239628[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+ecx+20]
	mov	DWORD PTR _eTargetTeam$222400[ebp], ecx

; 2569 : 					bool bTargetTeamIsMinor = GET_TEAM(eTargetTeam).isMinorCiv();

	mov	edx, DWORD PTR _eTargetTeam$222400[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T239658[ebp], edx
	mov	ecx, DWORD PTR $T239658[ebp]
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	mov	BYTE PTR _bTargetTeamIsMinor$222402[ebp], al

; 2570 : 					GET_TEAM(eFromTeam).makePeace(eTargetTeam, /*bBumpUnits*/ true, /*bSuppressNotification*/ bTargetTeamIsMinor);

	movzx	eax, BYTE PTR _bTargetTeamIsMinor$222402[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _eTargetTeam$222400[ebp]
	push	ecx
	mov	ecx, DWORD PTR _eFromTeam$222337[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?makePeace@CvTeam@@QAEXW4TeamTypes@@_N1@Z ; CvTeam::makePeace

; 2571 : 					GET_TEAM(eFromTeam).setForcePeace(eTargetTeam, true);

	push	1
	mov	edx, DWORD PTR _eTargetTeam$222400[ebp]
	push	edx
	mov	ecx, DWORD PTR _eFromTeam$222337[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?setForcePeace@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::setForcePeace

; 2572 : 					GET_TEAM(eTargetTeam).setForcePeace(eFromTeam, true);

	push	1
	mov	eax, DWORD PTR _eFromTeam$222337[ebp]
	push	eax
	mov	ecx, DWORD PTR _eTargetTeam$222400[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?setForcePeace@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::setForcePeace

; 2573 : 
; 2574 : 					if(bTargetTeamIsMinor)

	movzx	ecx, BYTE PTR _bTargetTeamIsMinor$222402[ebp]
	test	ecx, ecx
	je	SHORT $LN23@FinalizeDe

; 2575 : 						veNowAtPeacePairs.push_back(eTargetTeam, eFromTeam); //eFromTeam is second so we can take advantage of CvWeightedVector's sort by weights

	mov	DWORD PTR _weightedElem$239676[ebp], 0
	mov	DWORD PTR _weightedElem$239676[ebp+4], 0
	mov	edx, DWORD PTR _eTargetTeam$222400[ebp]
	mov	DWORD PTR _weightedElem$239676[ebp], edx
	mov	eax, DWORD PTR _eFromTeam$222337[ebp]
	mov	DWORD PTR _weightedElem$239676[ebp+4], eax
	lea	ecx, DWORD PTR _weightedElem$239676[ebp]
	push	ecx
	lea	ecx, DWORD PTR _veNowAtPeacePairs$[ebp]
	call	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@Z ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::push_back
$LN23@FinalizeDe:

; 2576 : 				}

	jmp	$LN57@FinalizeDe
$LN24@FinalizeDe:

; 2577 : 				// Third Party War
; 2578 : 				else if(it->m_eItemType == TRADE_ITEM_THIRD_PARTY_WAR)

	mov	edx, DWORD PTR _it$222324[ebp]
	mov	DWORD PTR $T239682[ebp], edx
	mov	eax, DWORD PTR _it$222324[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T239682[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+eax+8], 15		; 0000000fH
	jne	SHORT $LN21@FinalizeDe

; 2579 : 				{
; 2580 : 					TeamTypes eTargetTeam = (TeamTypes) it->m_iData1;

	mov	eax, DWORD PTR _it$222324[ebp]
	mov	DWORD PTR $T239714[ebp], eax
	mov	ecx, DWORD PTR _it$222324[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T239714[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+ecx+20]
	mov	DWORD PTR _eTargetTeam$222406[ebp], ecx

; 2581 : 					GET_TEAM(eFromTeam).declareWar(eTargetTeam);

	push	0
	mov	edx, DWORD PTR _eTargetTeam$222406[ebp]
	push	edx
	mov	ecx, DWORD PTR _eFromTeam$222337[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?declareWar@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::declareWar

; 2582 : 
; 2583 : 					int iLockedTurns = /*15*/ GC.getCOOP_WAR_LOCKED_LENGTH();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6692
	mov	DWORD PTR _iLockedTurns$222408[ebp], eax

; 2584 : 					GET_TEAM(eFromTeam).ChangeNumTurnsLockedIntoWar(eTargetTeam, iLockedTurns);

	mov	ecx, DWORD PTR _iLockedTurns$222408[ebp]
	push	ecx
	mov	edx, DWORD PTR _eTargetTeam$222406[ebp]
	push	edx
	mov	ecx, DWORD PTR _eFromTeam$222337[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?ChangeNumTurnsLockedIntoWar@CvTeam@@QAEXW4TeamTypes@@H@Z ; CvTeam::ChangeNumTurnsLockedIntoWar
	jmp	SHORT $LN57@FinalizeDe
$LN21@FinalizeDe:

; 2585 : 				}
; 2586 : 				// **** Peace Treaty **** this should always be the last item processed!!!
; 2587 : 				else if(it->m_eItemType == TRADE_ITEM_PEACE_TREATY)

	mov	eax, DWORD PTR _it$222324[ebp]
	mov	DWORD PTR $T239755[ebp], eax
	mov	ecx, DWORD PTR _it$222324[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T239755[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	DWORD PTR [eax+ecx+8], 13		; 0000000dH
	jne	SHORT $LN57@FinalizeDe

; 2588 : 				{
; 2589 : 					GET_TEAM(eFromTeam).makePeace(eToTeam);

	push	0
	push	1
	mov	ecx, DWORD PTR _eToTeam$222338[ebp]
	push	ecx
	mov	ecx, DWORD PTR _eFromTeam$222337[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?makePeace@CvTeam@@QAEXW4TeamTypes@@_N1@Z ; CvTeam::makePeace

; 2590 : 					GET_TEAM(eFromTeam).setForcePeace(eToTeam, true);

	push	1
	mov	edx, DWORD PTR _eToTeam$222338[ebp]
	push	edx
	mov	ecx, DWORD PTR _eFromTeam$222337[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?setForcePeace@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::setForcePeace
$LN57@FinalizeDe:

; 2591 : 				}
; 2592 : 				//////////////////////////////////////////////////////////////////////
; 2593 : 				// **** DO NOT PUT ANYTHING AFTER THIS LINE ****
; 2594 : 				//////////////////////////////////////////////////////////////////////
; 2595 : 			}

	jmp	$LN61@FinalizeDe
$LN60@FinalizeDe:

; 2596 : 
; 2597 : 			LogDealComplete(&kDeal);

	lea	eax, DWORD PTR _kDeal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z ; CvGameDeals::LogDealComplete

; 2598 : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 3
$LN68@FinalizeDe:

; 2599 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _tempDeals$222312[ebp]
	call	??1?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvDeal,20,0,297,0>::~FStaticVector<CvDeal,20,0,297,0>
	mov	BYTE PTR __$EHRec$[ebp+8], 1
$LN82@FinalizeDe:

; 2600 : 
; 2601 : 	// Update UI if we were involved in the deal
; 2602 : 	PlayerTypes eActivePlayer = GC.getGame().getActivePlayer();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T239837[ebp], ecx
	mov	ecx, DWORD PTR $T239837[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	mov	DWORD PTR _eActivePlayer$[ebp], eax

; 2603 : 	if(eFromPlayer == eActivePlayer || eToPlayer == eActivePlayer)

	mov	edx, DWORD PTR _eFromPlayer$[ebp]
	cmp	edx, DWORD PTR _eActivePlayer$[ebp]
	je	SHORT $LN17@FinalizeDe
	mov	eax, DWORD PTR _eToPlayer$[ebp]
	cmp	eax, DWORD PTR _eActivePlayer$[ebp]
	jne	SHORT $LN18@FinalizeDe
$LN17@FinalizeDe:

; 2604 : 	{
; 2605 : 		GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	mov	ecx, DWORD PTR $T239841[ebp]
	mov	DWORD PTR tv876[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv876[ebp], edx
	push	1
	push	11					; 0000000bH
	mov	eax, DWORD PTR tv876[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv876[ebp]
	mov	eax, DWORD PTR [edx+260]
	call	eax
$LN18@FinalizeDe:

; 2606 : 	}
; 2607 : 
; 2608 : 	// Send out a condensed notification if peace was made with third party minor civs in this deal
; 2609 : 	if(veNowAtPeacePairs.size() > 0)

	mov	ecx, DWORD PTR _veNowAtPeacePairs$[ebp+4]
	mov	DWORD PTR $T239846[ebp], ecx
	cmp	DWORD PTR $T239846[ebp], 0
	jle	$LN16@FinalizeDe

; 2610 : 	{
; 2611 : 		// Loop through all teams
; 2612 : 		for(int iFromTeamIndex = 0; iFromTeamIndex < MAX_CIV_TEAMS; iFromTeamIndex++)

	mov	DWORD PTR _iFromTeamIndex$222415[ebp], 0
	jmp	SHORT $LN15@FinalizeDe
$LN14@FinalizeDe:
	mov	edx, DWORD PTR _iFromTeamIndex$222415[ebp]
	add	edx, 1
	mov	DWORD PTR _iFromTeamIndex$222415[ebp], edx
$LN15@FinalizeDe:
	cmp	DWORD PTR _iFromTeamIndex$222415[ebp], 63 ; 0000003fH
	jge	$LN16@FinalizeDe

; 2613 : 		{
; 2614 : 			TeamTypes eFromTeam = (TeamTypes) iFromTeamIndex;

	mov	eax, DWORD PTR _iFromTeamIndex$222415[ebp]
	mov	DWORD PTR _eFromTeam$222419[ebp], eax

; 2615 : 			TeamTypes eToTeam = NO_TEAM;

	mov	DWORD PTR _eToTeam$222421[ebp], -1

; 2616 : 			bool bFromTeamMadePeace = false;

	mov	BYTE PTR _bFromTeamMadePeace$222422[ebp], 0

; 2617 : 
; 2618 : 			Localization::String strTemp = Localization::Lookup("TXT_KEY_MISC_MADE_PEACE_WITH_MINOR_ALLIES");

	push	OFFSET ??_C@_0CK@MOEBLOJE@TXT_KEY_MISC_MADE_PEACE_WITH_MIN@
	lea	ecx, DWORD PTR _strTemp$222423[ebp]
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[ebp+8], 8

; 2619 : 			Localization::String strSummary = Localization::Lookup("TXT_KEY_MISC_MADE_PEACE_WITH_MINOR_ALLIES_SUMMARY");

	push	OFFSET ??_C@_0DC@HKECBLMG@TXT_KEY_MISC_MADE_PEACE_WITH_MIN@
	lea	edx, DWORD PTR _strSummary$222426[ebp]
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[ebp+8], 9

; 2620 : 			strTemp << GET_TEAM(eFromTeam).getName().GetCString();

	mov	eax, DWORD PTR _eFromTeam$222419[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T239854[ebp], eax
	lea	ecx, DWORD PTR $T238481[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T239854[ebp]
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	DWORD PTR tv890[ebp], eax
	mov	edx, DWORD PTR tv890[ebp]
	mov	DWORD PTR $T239858[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	ecx, DWORD PTR $T239858[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T238480[ebp], eax
	lea	eax, DWORD PTR $T238480[ebp]
	push	eax
	lea	ecx, DWORD PTR _strTemp$222423[ebp]
	push	ecx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	lea	ecx, DWORD PTR $T238481[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2621 : 			strSummary << GET_TEAM(eFromTeam).getName().GetCString();

	mov	edx, DWORD PTR _eFromTeam$222419[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T239866[ebp], edx
	lea	eax, DWORD PTR $T238483[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239866[ebp]
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	DWORD PTR tv886[ebp], eax
	mov	ecx, DWORD PTR tv886[ebp]
	mov	DWORD PTR $T239870[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	mov	ecx, DWORD PTR $T239870[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T238482[ebp], eax
	lea	edx, DWORD PTR $T238482[ebp]
	push	edx
	lea	eax, DWORD PTR _strSummary$222426[ebp]
	push	eax
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	lea	ecx, DWORD PTR $T238483[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2622 : 			CvString strMessage = strTemp.toUTF8();

	lea	ecx, DWORD PTR _strTemp$222423[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	mov	DWORD PTR $T239883[ebp], eax
	cmp	DWORD PTR $T239883[ebp], 0
	je	SHORT $LN693@FinalizeDe
	mov	ecx, DWORD PTR $T239883[ebp]
	mov	DWORD PTR tv2471[ebp], ecx
	jmp	SHORT $LN694@FinalizeDe
$LN693@FinalizeDe:
	mov	DWORD PTR tv2471[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN694@FinalizeDe:
	mov	edx, DWORD PTR tv2471[ebp]
	push	edx
	lea	ecx, DWORD PTR _strMessage$222438[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH

; 2623 : 
; 2624 : 			// Did this team make peace with someone in this deal?
; 2625 : 			for(int iPairIndex = 0; iPairIndex < veNowAtPeacePairs.size(); iPairIndex++)

	mov	DWORD PTR _iPairIndex$222439[ebp], 0
	jmp	SHORT $LN12@FinalizeDe
$LN11@FinalizeDe:
	mov	eax, DWORD PTR _iPairIndex$222439[ebp]
	add	eax, 1
	mov	DWORD PTR _iPairIndex$222439[ebp], eax
$LN12@FinalizeDe:
	mov	ecx, DWORD PTR _veNowAtPeacePairs$[ebp+4]
	mov	DWORD PTR $T239888[ebp], ecx
	mov	edx, DWORD PTR _iPairIndex$222439[ebp]
	cmp	edx, DWORD PTR $T239888[ebp]
	jge	$LN10@FinalizeDe

; 2626 : 			{
; 2627 : 				if(veNowAtPeacePairs.GetWeight(iPairIndex) == (int) eFromTeam)

	mov	DWORD PTR _elem$239901[ebp], 0
	mov	DWORD PTR _elem$239901[ebp+4], 0
	mov	eax, DWORD PTR _iPairIndex$222439[ebp]
	mov	ecx, DWORD PTR _veNowAtPeacePairs$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR [ecx+eax*8+4]
	mov	DWORD PTR _elem$239901[ebp], edx
	mov	DWORD PTR _elem$239901[ebp+4], eax
	mov	ecx, DWORD PTR _elem$239901[ebp+4]
	cmp	ecx, DWORD PTR _eFromTeam$222419[ebp]
	jne	$LN9@FinalizeDe

; 2628 : 				{
; 2629 : 					eToTeam = veNowAtPeacePairs.GetElement(iPairIndex);

	mov	edx, DWORD PTR _iPairIndex$222439[ebp]
	mov	eax, DWORD PTR _veNowAtPeacePairs$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR _eToTeam$222421[ebp], ecx

; 2630 : 					strTemp = Localization::Lookup(GET_TEAM(eToTeam).getName().GetCString());

	mov	edx, DWORD PTR _eToTeam$222421[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T239918[ebp], edx
	lea	eax, DWORD PTR $T238484[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239918[ebp]
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	DWORD PTR tv65[ebp], eax
	mov	ecx, DWORD PTR tv65[ebp]
	mov	DWORD PTR $T239922[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH
	mov	ecx, DWORD PTR $T239922[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T239923[ebp], eax
	mov	edx, DWORD PTR $T239923[ebp]
	push	edx
	lea	eax, DWORD PTR $T238485[ebp]
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR tv2469[ebp], eax
	mov	ecx, DWORD PTR tv2469[ebp]
	mov	DWORD PTR tv1113[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH
	mov	edx, DWORD PTR tv1113[ebp]
	push	edx
	lea	ecx, DWORD PTR _strTemp$222423[ebp]
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH
	lea	ecx, DWORD PTR $T238485[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	lea	ecx, DWORD PTR $T238484[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2631 : 					strMessage = strMessage + "[NEWLINE]" + strTemp.toUTF8();

	push	OFFSET ??_C@_09ODCIJKAA@?$FLNEWLINE?$FN?$AA@
	lea	eax, DWORD PTR _strMessage$222438[ebp]
	push	eax
	lea	ecx, DWORD PTR $T238486[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv2211[ebp], eax
	mov	edx, DWORD PTR tv2211[ebp]
	mov	DWORD PTR tv1115[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 15		; 0000000fH
	lea	ecx, DWORD PTR _strTemp$222423[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	mov	eax, DWORD PTR tv1115[ebp]
	push	eax
	lea	ecx, DWORD PTR $T238487[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv1697[ebp], eax
	mov	edx, DWORD PTR tv1697[ebp]
	mov	DWORD PTR $T239931[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 16		; 00000010H
	mov	ecx, DWORD PTR $T239931[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strMessage$222438[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 15		; 0000000fH
	lea	ecx, DWORD PTR $T238487[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	lea	ecx, DWORD PTR $T238486[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2632 : 					bFromTeamMadePeace = true;

	mov	BYTE PTR _bFromTeamMadePeace$222422[ebp], 1
$LN9@FinalizeDe:

; 2633 : 				}
; 2634 : 			}

	jmp	$LN11@FinalizeDe
$LN10@FinalizeDe:

; 2635 : 
; 2636 : 			// Send out notifications if there was a change
; 2637 : 			if(bFromTeamMadePeace)

	movzx	eax, BYTE PTR _bFromTeamMadePeace$222422[ebp]
	test	eax, eax
	je	$LN8@FinalizeDe

; 2638 : 			{
; 2639 : 				// Send out the notifications to other players
; 2640 : 				for(int iNotifPlayerLoop = 0; iNotifPlayerLoop < MAX_MAJOR_CIVS; iNotifPlayerLoop++)

	mov	DWORD PTR _iNotifPlayerLoop$222451[ebp], 0
	jmp	SHORT $LN7@FinalizeDe
$LN6@FinalizeDe:
	mov	ecx, DWORD PTR _iNotifPlayerLoop$222451[ebp]
	add	ecx, 1
	mov	DWORD PTR _iNotifPlayerLoop$222451[ebp], ecx
$LN7@FinalizeDe:
	cmp	DWORD PTR _iNotifPlayerLoop$222451[ebp], 22 ; 00000016H
	jge	$LN8@FinalizeDe

; 2641 : 				{
; 2642 : 					PlayerTypes eNotifPlayer = (PlayerTypes) iNotifPlayerLoop;

	mov	edx, DWORD PTR _iNotifPlayerLoop$222451[ebp]
	mov	DWORD PTR _eNotifPlayer$222455[ebp], edx

; 2643 : 
; 2644 : 					if(!GET_PLAYER(eNotifPlayer).isAlive())

	mov	eax, DWORD PTR _eNotifPlayer$222455[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239935[ebp], eax
	mov	ecx, DWORD PTR $T239935[ebp]
	mov	dl, BYTE PTR [ecx+2256]
	mov	BYTE PTR $T239944[ebp], dl
	movzx	eax, BYTE PTR $T239944[ebp]
	test	eax, eax
	jne	SHORT $LN4@FinalizeDe

; 2645 : 						continue;

	jmp	SHORT $LN6@FinalizeDe
$LN4@FinalizeDe:

; 2646 : 
; 2647 : 					if(GET_PLAYER(eNotifPlayer).getTeam() == eFromTeam)

	mov	ecx, DWORD PTR _eNotifPlayer$222455[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239948[ebp], ecx
	mov	edx, DWORD PTR $T239948[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	eax, DWORD PTR _eFromTeam$222419[ebp]
	jne	SHORT $LN3@FinalizeDe

; 2648 : 						continue;

	jmp	$LN6@FinalizeDe
$LN3@FinalizeDe:

; 2649 : 
; 2650 : 					if(GET_TEAM(GET_PLAYER(eNotifPlayer).getTeam()).isHasMet(eFromTeam))  //antonjs: consider: what if eNotifPlayer hasn't met one or more of the minors that eFromTeam made peace with?

	mov	ecx, DWORD PTR _eNotifPlayer$222455[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239960[ebp], ecx
	mov	edx, DWORD PTR $T239960[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T239969[ebp], eax
	mov	ecx, DWORD PTR $T239969[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T239973[ebp], ecx
	mov	edx, DWORD PTR _eFromTeam$222419[ebp]
	push	edx
	mov	ecx, DWORD PTR $T239973[ebp]
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	movzx	eax, al
	test	eax, eax
	je	$LN2@FinalizeDe

; 2651 : 					{
; 2652 : 						if(GET_PLAYER(eNotifPlayer).GetNotifications())

	mov	ecx, DWORD PTR _eNotifPlayer$222455[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239977[ebp], ecx
	mov	ecx, DWORD PTR $T239977[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	test	eax, eax
	je	$LN2@FinalizeDe

; 2653 : 						{
; 2654 : 							GET_PLAYER(eNotifPlayer).GetNotifications()->Add(NOTIFICATION_PEACE, strMessage, strSummary.toUTF8(), -1, -1, GET_TEAM(eFromTeam).getLeaderID(), eToTeam);

	mov	edx, DWORD PTR _eFromTeam$222419[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T239981[ebp], edx
	lea	ecx, DWORD PTR _strMessage$222438[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T239985[ebp], eax
	mov	eax, DWORD PTR _eNotifPlayer$222455[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239989[ebp], eax
	mov	ecx, DWORD PTR _eToTeam$222421[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T239981[ebp]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	push	eax
	push	-1
	push	-1
	lea	ecx, DWORD PTR _strSummary$222426[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	mov	edx, DWORD PTR $T239985[ebp]
	push	edx
	push	818263651				; 30c5b663H
	mov	ecx, DWORD PTR $T239989[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ecx, eax
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN2@FinalizeDe:

; 2655 : 						}
; 2656 : 					}
; 2657 : 				}

	jmp	$LN6@FinalizeDe
$LN8@FinalizeDe:

; 2658 : 			}
; 2659 : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 9
	lea	ecx, DWORD PTR _strMessage$222438[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	ecx, DWORD PTR _strSummary$222426[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strTemp$222423[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	jmp	$LN14@FinalizeDe
$LN16@FinalizeDe:

; 2660 : 	}
; 2661 : 
; 2662 : 	return bFoundIt && bValid;

	movzx	eax, BYTE PTR _bFoundIt$[ebp]
	test	eax, eax
	je	SHORT $LN89@FinalizeDe
	movzx	ecx, BYTE PTR _bValid$[ebp]
	test	ecx, ecx
	je	SHORT $LN89@FinalizeDe
	mov	DWORD PTR tv1076[ebp], 1
	jmp	SHORT $LN90@FinalizeDe
$LN89@FinalizeDe:
	mov	DWORD PTR tv1076[ebp], 0
$LN90@FinalizeDe:
	mov	dl, BYTE PTR tv1076[ebp]
	mov	BYTE PTR $T238488[ebp], dl
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _veNowAtPeacePairs$[ebp]
	call	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::~FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _kDeal$[ebp]
	call	??1CvDeal@@UAE@XZ			; CvDeal::~CvDeal
	mov	al, BYTE PTR $T238488[ebp]

; 2663 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$0:
	lea	ecx, DWORD PTR _kDeal$[ebp]
	jmp	??1CvDeal@@UAE@XZ			; CvDeal::~CvDeal
__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$1:
	lea	ecx, DWORD PTR _veNowAtPeacePairs$[ebp]
	jmp	??1?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE@XZ ; CvWeightedVector<enum TeamTypes,63,1>::~CvWeightedVector<enum TeamTypes,63,1>
__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$2:
	lea	ecx, DWORD PTR _iter$222303[ebp]
	jmp	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$5:
	lea	ecx, DWORD PTR _tempDeals$222312[ebp]
	jmp	??1?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvDeal,20,0,297,0>::~FStaticVector<CvDeal,20,0,297,0>
__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$6:
	lea	ecx, DWORD PTR _it$222324[ebp]
	jmp	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$11:
	lea	ecx, DWORD PTR $T238476[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$12:
	lea	ecx, DWORD PTR $T238478[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$13:
	mov	ecx, DWORD PTR $T238479[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$14:
	lea	ecx, DWORD PTR _strTemp$222423[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$15:
	lea	ecx, DWORD PTR _strSummary$222426[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$16:
	lea	ecx, DWORD PTR $T238481[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$17:
	lea	ecx, DWORD PTR $T238483[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$18:
	lea	ecx, DWORD PTR _strMessage$222438[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$19:
	lea	ecx, DWORD PTR $T238484[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$20:
	lea	ecx, DWORD PTR $T238485[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$21:
	lea	ecx, DWORD PTR $T238486[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z$22:
	lea	ecx, DWORD PTR $T238487[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-3488]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z ENDP ; CvGameDeals::FinalizeDeal
PUBLIC	?GetTempDeal@CvGameDeals@@QAEPAVCvDeal@@XZ	; CvGameDeals::GetTempDeal
; Function compile flags: /Odtp
;	COMDAT ?GetTempDeal@CvGameDeals@@QAEPAVCvDeal@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTempDeal@CvGameDeals@@QAEPAVCvDeal@@XZ PROC		; CvGameDeals::GetTempDeal, COMDAT
; _this$ = ecx

; 2666 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2667 : 	return &m_TempDeal;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4612				; 00001204H

; 2668 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTempDeal@CvGameDeals@@QAEPAVCvDeal@@XZ ENDP		; CvGameDeals::GetTempDeal
_TEXT	ENDS
PUBLIC	?SetTempDeal@CvGameDeals@@QAEXPAVCvDeal@@@Z	; CvGameDeals::SetTempDeal
; Function compile flags: /Odtp
;	COMDAT ?SetTempDeal@CvGameDeals@@QAEXPAVCvDeal@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pDeal$ = 8						; size = 4
?SetTempDeal@CvGameDeals@@QAEXPAVCvDeal@@@Z PROC	; CvGameDeals::SetTempDeal, COMDAT
; _this$ = ecx

; 2671 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2672 : 	m_TempDeal = *pDeal;

	mov	eax, DWORD PTR _pDeal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4612				; 00001204H
	call	??4CvDeal@@QAEAAV0@ABV0@@Z		; CvDeal::operator=

; 2673 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetTempDeal@CvGameDeals@@QAEXPAVCvDeal@@@Z ENDP	; CvGameDeals::SetTempDeal
_TEXT	ENDS
PUBLIC	?DoUpdateCurrentDealsList@CvGameDeals@@QAEXXZ	; CvGameDeals::DoUpdateCurrentDealsList
PUBLIC	?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z ; CvGameDeals::DoEndTradedItem
PUBLIC	?DoTurn@CvGameDeals@@QAEXXZ			; CvGameDeals::DoTurn
EXTRN	?getNumResourceTotal@CvPlayer@@QBEHW4ResourceTypes@@_N@Z:PROC ; CvPlayer::getNumResourceTotal
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
xdata$x	SEGMENT
__unwindtable$?DoTurn@CvGameDeals@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoTurn@CvGameDeals@@QAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DoTurn@CvGameDeals@@QAEXXZ$3
__ehfuncinfo$?DoTurn@CvGameDeals@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?DoTurn@CvGameDeals@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?DoTurn@CvGameDeals@@QAEXXZ
_TEXT	SEGMENT
tv333 = -280						; size = 4
tv350 = -276						; size = 4
tv346 = -272						; size = 4
tv341 = -268						; size = 4
_this$ = -264						; size = 4
$T240737 = -260						; size = 4
$T240733 = -256						; size = 4
$T240686 = -252						; size = 4
$T240654 = -248						; size = 4
$T240648 = -244						; size = 4
$T240621 = -240						; size = 4
$T240615 = -236						; size = 4
$T240594 = -232						; size = 4
$T240578 = -228						; size = 4
$T240574 = -224						; size = 4
$T240565 = -220						; size = 4
$T240517 = -216						; size = 4
$T240485 = -212						; size = 4
$T240479 = -208						; size = 4
$T240449 = -204						; size = 4
$T240417 = -200						; size = 4
$T240385 = -196						; size = 4
$T240353 = -192						; size = 4
$T240330 = -188						; size = 4
$T240314 = -184						; size = 4
$T240310 = -180						; size = 4
$T240301 = -176						; size = 4
$T240253 = -172						; size = 4
$T240203 = -168						; size = 4
$T240171 = -164						; size = 4
$T240145 = -160						; size = 4
$T240129 = -156						; size = 4
$T240125 = -152						; size = 4
$T240116 = -148						; size = 4
$T240068 = -144						; size = 4
$T240061 = -140						; size = 4
$T240057 = -136						; size = 4
$T240045 = -132						; size = 8
$T240044 = -121						; size = 1
$T240043 = -120						; size = 8
$T240042 = -112						; size = 8
$T240041 = -101						; size = 1
$T240040 = -100						; size = 8
$T240039 = -92						; size = 8
$T240038 = -81						; size = 1
$T240037 = -80						; size = 8
_eActivePlayer$222523 = -72				; size = 4
_eResource$222507 = -68					; size = 4
_bHaveEnoughGold$222504 = -62				; size = 1
_bHaveEnoughResource$222505 = -61			; size = 1
_iFinalTurn$222502 = -60				; size = 4
_bInvalidDeal$222494 = -54				; size = 1
_bUnbreakable$222495 = -53				; size = 1
_itemIter$222493 = -52					; size = 8
_iFinalTurn$222488 = -44				; size = 4
_itemIter$222481 = -40					; size = 8
_eFromPlayer$222474 = -32				; size = 4
_iGameTurn$222477 = -28					; size = 4
_eToPlayer$222475 = -24					; size = 4
_bSomethingChanged$222476 = -17				; size = 1
_it$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?DoTurn@CvGameDeals@@QAEXXZ PROC			; CvGameDeals::DoTurn, COMDAT
; _this$ = ecx

; 2822 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DoTurn@CvGameDeals@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 268				; 0000010cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2823 : 	DealList::iterator it;
; 2824 : 
; 2825 : 	if(m_CurrentDeals.size() > 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1544]
	mov	DWORD PTR $T240057[ebp], ecx
	cmp	DWORD PTR $T240057[ebp], 0
	jbe	$LN30@DoTurn

; 2826 : 	{
; 2827 : 		PlayerTypes eFromPlayer = NO_PLAYER;

	mov	DWORD PTR _eFromPlayer$222474[ebp], -1

; 2828 : 		PlayerTypes eToPlayer = NO_PLAYER;

	mov	DWORD PTR _eToPlayer$222475[ebp], -1

; 2829 : 
; 2830 : 		bool bSomethingChanged = false;

	mov	BYTE PTR _bSomethingChanged$222476[ebp], 0

; 2831 : 		//int iTemp;
; 2832 : 		//TradeableItems eTempItem;
; 2833 : 
; 2834 : 		int iGameTurn = GC.getGame().getGameTurn();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T240061[ebp], edx
	mov	ecx, DWORD PTR $T240061[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	DWORD PTR _iGameTurn$222477[ebp], eax

; 2835 : 
; 2836 : 		// Check to see if any of our TradeItems in any of our Deals expire this turn
; 2837 : 		for(it = m_CurrentDeals.begin(); it != m_CurrentDeals.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1540]
	mov	DWORD PTR _it$[ebp], ecx
	jmp	SHORT $LN28@DoTurn
$LN27@DoTurn:
	mov	edx, DWORD PTR _it$[ebp]
	add	edx, 76					; 0000004cH
	mov	DWORD PTR _it$[ebp], edx
$LN28@DoTurn:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1540				; 00000604H
	mov	DWORD PTR $T240068[ebp], eax
	mov	ecx, DWORD PTR $T240068[ebp]
	mov	edx, DWORD PTR [ecx+4]
	imul	edx, 76					; 0000004cH
	mov	eax, DWORD PTR $T240068[ebp]
	add	edx, DWORD PTR [eax]
	cmp	DWORD PTR _it$[ebp], edx
	je	$LN26@DoTurn

; 2838 : 		{
; 2839 : 			TradedItemList::iterator itemIter;

	mov	DWORD PTR _itemIter$222481[ebp], 0
	mov	DWORD PTR _itemIter$222481[ebp+4], 268435455 ; 0fffffffH
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2840 : 			for(itemIter = it->m_TradedItems.begin(); itemIter != it->m_TradedItems.end(); ++itemIter)

	lea	ecx, DWORD PTR $T240037[ebp]
	push	ecx
	mov	ecx, DWORD PTR _it$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv341[ebp], eax
	mov	edx, DWORD PTR tv341[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _itemIter$222481[ebp], eax
	mov	DWORD PTR _itemIter$222481[ebp+4], ecx
	jmp	SHORT $LN25@DoTurn
$LN24@DoTurn:
	cmp	DWORD PTR _itemIter$222481[ebp+4], 268435455 ; 0fffffffH
	jne	SHORT $LN67@DoTurn
	mov	edx, DWORD PTR _itemIter$222481[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _itemIter$222481[ebp+4], eax
	jmp	SHORT $LN25@DoTurn
$LN67@DoTurn:
	mov	ecx, DWORD PTR _itemIter$222481[ebp]
	mov	DWORD PTR $T240116[ebp], ecx
	mov	edx, DWORD PTR _itemIter$222481[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T240116[ebp]
	add	edx, DWORD PTR [eax+8]
	mov	DWORD PTR $T240125[ebp], edx
	mov	ecx, DWORD PTR $T240125[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T240129[ebp], edx
	mov	eax, DWORD PTR $T240129[ebp]
	mov	DWORD PTR _itemIter$222481[ebp+4], eax
$LN25@DoTurn:
	lea	ecx, DWORD PTR $T240039[ebp]
	push	ecx
	mov	ecx, DWORD PTR _it$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T240145[ebp], eax
	mov	edx, DWORD PTR $T240145[ebp]
	mov	eax, DWORD PTR _itemIter$222481[ebp+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setne	cl
	mov	BYTE PTR $T240038[ebp], cl
	movzx	edx, BYTE PTR $T240038[ebp]
	test	edx, edx
	je	$LN23@DoTurn

; 2841 : 			{
; 2842 : 				int iFinalTurn = itemIter->m_iFinalTurn;

	lea	ecx, DWORD PTR _itemIter$222481[ebp]
	call	??Diterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::operator*
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR _iFinalTurn$222488[ebp], eax

; 2843 : 				CvAssertMsg(iFinalTurn >= -1, "DEAL: Trade item has a negative final turn.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 2844 : 				CvAssertMsg(iFinalTurn < GC.getGame().getEstimateEndTurn() * 2, "DEAL: Trade item has a final turn way beyond the end of the game.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 2845 : 				CvAssertMsg(itemIter->m_iDuration < GC.getGame().getEstimateEndTurn() * 2, "DEAL: Trade item has a crazy long duration (probably invalid).  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 2846 : 				CvAssertMsg(itemIter->m_eFromPlayer == it->m_eFromPlayer || itemIter->m_eFromPlayer == it->m_eToPlayer, "DEAL: Processing turn for a deal that has an item for a player that's not actually in this deal!  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 2847 : 
; 2848 : 				if(iFinalTurn > -1 && iFinalTurn == iGameTurn)

	cmp	DWORD PTR _iFinalTurn$222488[ebp], -1
	jle	SHORT $LN22@DoTurn
	mov	ecx, DWORD PTR _iFinalTurn$222488[ebp]
	cmp	ecx, DWORD PTR _iGameTurn$222477[ebp]
	jne	SHORT $LN22@DoTurn

; 2849 : 				{
; 2850 : 					//eTempItem = itemIter->m_eItemType;
; 2851 : 					//iTemp = iFinalTurn;
; 2852 : 
; 2853 : 					bSomethingChanged = true;

	mov	BYTE PTR _bSomethingChanged$222476[ebp], 1

; 2854 : 
; 2855 : 					eFromPlayer = itemIter->m_eFromPlayer;

	mov	edx, DWORD PTR _itemIter$222481[ebp]
	mov	DWORD PTR $T240171[ebp], edx
	mov	eax, DWORD PTR _itemIter$222481[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T240171[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+eax+36]
	mov	DWORD PTR _eFromPlayer$222474[ebp], eax

; 2856 : 					eToPlayer = it->GetOtherPlayer(eFromPlayer);

	mov	ecx, DWORD PTR _eFromPlayer$222474[ebp]
	push	ecx
	mov	ecx, DWORD PTR _it$[ebp]
	call	?GetOtherPlayer@CvDeal@@QBE?AW4PlayerTypes@@W42@@Z ; CvDeal::GetOtherPlayer
	mov	DWORD PTR _eToPlayer$222475[ebp], eax

; 2857 : 
; 2858 : 					DoEndTradedItem(&*itemIter, eToPlayer, false);

	mov	edx, DWORD PTR _itemIter$222481[ebp]
	mov	DWORD PTR $T240203[ebp], edx
	push	0
	mov	eax, DWORD PTR _eToPlayer$222475[ebp]
	push	eax
	mov	ecx, DWORD PTR _itemIter$222481[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T240203[ebp]
	mov	eax, DWORD PTR [edx+8]
	lea	ecx, DWORD PTR [eax+ecx+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z ; CvGameDeals::DoEndTradedItem
$LN22@DoTurn:

; 2859 : 				}
; 2860 : 			}

	jmp	$LN24@DoTurn
$LN23@DoTurn:

; 2861 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	jmp	$LN27@DoTurn
$LN26@DoTurn:

; 2862 : 
; 2863 : 		// check to see if one of our deals in no longer valid
; 2864 : 		for(it = m_CurrentDeals.begin(); it != m_CurrentDeals.end(); ++it)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1540]
	mov	DWORD PTR _it$[ebp], eax
	jmp	SHORT $LN21@DoTurn
$LN20@DoTurn:
	mov	ecx, DWORD PTR _it$[ebp]
	add	ecx, 76					; 0000004cH
	mov	DWORD PTR _it$[ebp], ecx
$LN21@DoTurn:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1540				; 00000604H
	mov	DWORD PTR $T240253[ebp], edx
	mov	eax, DWORD PTR $T240253[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 76					; 0000004cH
	mov	edx, DWORD PTR $T240253[ebp]
	add	ecx, DWORD PTR [edx]
	cmp	DWORD PTR _it$[ebp], ecx
	je	$LN19@DoTurn

; 2865 : 		{
; 2866 : 			TradedItemList::iterator itemIter;

	mov	DWORD PTR _itemIter$222493[ebp], 0
	mov	DWORD PTR _itemIter$222493[ebp+4], 268435455 ; 0fffffffH
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 2867 : 			bool bInvalidDeal = false;

	mov	BYTE PTR _bInvalidDeal$222494[ebp], 0

; 2868 : 			bool bUnbreakable = false;

	mov	BYTE PTR _bUnbreakable$222495[ebp], 0

; 2869 : 			for(itemIter = it->m_TradedItems.begin(); itemIter != it->m_TradedItems.end(); ++itemIter)

	lea	eax, DWORD PTR $T240040[ebp]
	push	eax
	mov	ecx, DWORD PTR _it$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv346[ebp], eax
	mov	ecx, DWORD PTR tv346[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _itemIter$222493[ebp], edx
	mov	DWORD PTR _itemIter$222493[ebp+4], eax
	jmp	SHORT $LN18@DoTurn
$LN17@DoTurn:
	cmp	DWORD PTR _itemIter$222493[ebp+4], 268435455 ; 0fffffffH
	jne	SHORT $LN141@DoTurn
	mov	ecx, DWORD PTR _itemIter$222493[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _itemIter$222493[ebp+4], edx
	jmp	SHORT $LN18@DoTurn
$LN141@DoTurn:
	mov	eax, DWORD PTR _itemIter$222493[ebp]
	mov	DWORD PTR $T240301[ebp], eax
	mov	ecx, DWORD PTR _itemIter$222493[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T240301[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T240310[ebp], ecx
	mov	eax, DWORD PTR $T240310[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T240314[ebp], ecx
	mov	edx, DWORD PTR $T240314[ebp]
	mov	DWORD PTR _itemIter$222493[ebp+4], edx
$LN18@DoTurn:
	lea	eax, DWORD PTR $T240042[ebp]
	push	eax
	mov	ecx, DWORD PTR _it$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T240330[ebp], eax
	mov	ecx, DWORD PTR $T240330[ebp]
	mov	edx, DWORD PTR _itemIter$222493[ebp+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setne	al
	mov	BYTE PTR $T240041[ebp], al
	movzx	ecx, BYTE PTR $T240041[ebp]
	test	ecx, ecx
	je	$LN16@DoTurn

; 2870 : 			{
; 2871 : 				int iFinalTurn = itemIter->m_iFinalTurn;

	mov	edx, DWORD PTR _itemIter$222493[ebp]
	mov	DWORD PTR $T240353[ebp], edx
	mov	eax, DWORD PTR _itemIter$222493[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T240353[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+eax+16]
	mov	DWORD PTR _iFinalTurn$222502[ebp], eax

; 2872 : 				if(iFinalTurn > -1 && iFinalTurn != iGameTurn)  // if this was the last turn the deal was ending anyways

	cmp	DWORD PTR _iFinalTurn$222502[ebp], -1
	jle	$LN15@DoTurn
	mov	ecx, DWORD PTR _iFinalTurn$222502[ebp]
	cmp	ecx, DWORD PTR _iGameTurn$222477[ebp]
	je	$LN15@DoTurn

; 2873 : 				{
; 2874 : 					eFromPlayer = itemIter->m_eFromPlayer;

	mov	edx, DWORD PTR _itemIter$222493[ebp]
	mov	DWORD PTR $T240385[ebp], edx
	mov	eax, DWORD PTR _itemIter$222493[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T240385[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+eax+36]
	mov	DWORD PTR _eFromPlayer$222474[ebp], eax

; 2875 : 					// check to see if we are negative on resource or gold
; 2876 : 					bool bHaveEnoughGold = true;

	mov	BYTE PTR _bHaveEnoughGold$222504[ebp], 1

; 2877 : 					bool bHaveEnoughResource = true;

	mov	BYTE PTR _bHaveEnoughResource$222505[ebp], 1

; 2878 : 					//if (itemIter->m_eItemType == TRADE_ITEM_GOLD_PER_TURN)
; 2879 : 					//{
; 2880 : 					//	int iGoldPerTurn = itemIter->m_iData1;
; 2881 : 					//	bHaveEnoughGold = GET_PLAYER(eFromPlayer).GetTreasury()->GetGold() > iGoldPerTurn;
; 2882 : 					//}
; 2883 : 					// Resource
; 2884 : 					/*else */
; 2885 : 					if(itemIter->m_eItemType == TRADE_ITEM_RESOURCES)

	mov	ecx, DWORD PTR _itemIter$222493[ebp]
	mov	DWORD PTR $T240417[ebp], ecx
	mov	edx, DWORD PTR _itemIter$222493[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T240417[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	DWORD PTR [ecx+edx+8], 3
	jne	SHORT $LN14@DoTurn

; 2886 : 					{
; 2887 : 						ResourceTypes eResource = (ResourceTypes) itemIter->m_iData1;

	mov	edx, DWORD PTR _itemIter$222493[ebp]
	mov	DWORD PTR $T240449[ebp], edx
	mov	eax, DWORD PTR _itemIter$222493[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T240449[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+eax+20]
	mov	DWORD PTR _eResource$222507[ebp], eax

; 2888 : 						//int iResourceQuantity = itemIter->m_iData2;
; 2889 : 						bHaveEnoughResource = GET_PLAYER(eFromPlayer).getNumResourceTotal(eResource) >= 0;

	mov	ecx, DWORD PTR _eFromPlayer$222474[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T240479[ebp], ecx
	push	1
	mov	edx, DWORD PTR _eResource$222507[ebp]
	push	edx
	mov	ecx, DWORD PTR $T240479[ebp]
	call	?getNumResourceTotal@CvPlayer@@QBEHW4ResourceTypes@@_N@Z ; CvPlayer::getNumResourceTotal
	xor	ecx, ecx
	test	eax, eax
	setge	cl
	mov	BYTE PTR _bHaveEnoughResource$222505[ebp], cl
	jmp	SHORT $LN13@DoTurn
$LN14@DoTurn:

; 2890 : 					}
; 2891 : 					else if(itemIter->m_eItemType == TRADE_ITEM_PEACE_TREATY)

	mov	edx, DWORD PTR _itemIter$222493[ebp]
	mov	DWORD PTR $T240485[ebp], edx
	mov	eax, DWORD PTR _itemIter$222493[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T240485[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+eax+8], 13		; 0000000dH
	jne	SHORT $LN12@DoTurn

; 2892 : 					{
; 2893 : 						bUnbreakable = true;

	mov	BYTE PTR _bUnbreakable$222495[ebp], 1
	jmp	SHORT $LN16@DoTurn

; 2894 : 						break;

	jmp	SHORT $LN13@DoTurn
$LN12@DoTurn:

; 2895 : 					}
; 2896 : #ifdef NEW_DEFENSIVE_PACT //EAP: From Immos: Sets DP to unbreakable 
; 2897 : 					else if(itemIter->m_eItemType == TRADE_ITEM_DEFENSIVE_PACT)

	mov	eax, DWORD PTR _itemIter$222493[ebp]
	mov	DWORD PTR $T240517[ebp], eax
	mov	ecx, DWORD PTR _itemIter$222493[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T240517[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	DWORD PTR [eax+ecx+8], 7
	jne	SHORT $LN13@DoTurn

; 2898 : 					{
; 2899 : 						bUnbreakable = true;

	mov	BYTE PTR _bUnbreakable$222495[ebp], 1

; 2900 : 						break;

	jmp	SHORT $LN16@DoTurn
$LN13@DoTurn:

; 2901 : 					}
; 2902 : #endif
; 2903 : 					if(!bHaveEnoughGold || !bHaveEnoughResource)

	movzx	ecx, BYTE PTR _bHaveEnoughGold$222504[ebp]
	test	ecx, ecx
	je	SHORT $LN8@DoTurn
	movzx	edx, BYTE PTR _bHaveEnoughResource$222505[ebp]
	test	edx, edx
	jne	SHORT $LN15@DoTurn
$LN8@DoTurn:

; 2904 : 					{
; 2905 : 						bInvalidDeal = true;

	mov	BYTE PTR _bInvalidDeal$222494[ebp], 1
$LN15@DoTurn:

; 2906 : 					}
; 2907 : 				}
; 2908 : 			}

	jmp	$LN17@DoTurn
$LN16@DoTurn:

; 2909 : 
; 2910 : 			if(!bUnbreakable && bInvalidDeal)

	movzx	eax, BYTE PTR _bUnbreakable$222495[ebp]
	test	eax, eax
	jne	$LN7@DoTurn
	movzx	ecx, BYTE PTR _bInvalidDeal$222494[ebp]
	test	ecx, ecx
	je	$LN7@DoTurn

; 2911 : 			{
; 2912 : 				bSomethingChanged = true;

	mov	BYTE PTR _bSomethingChanged$222476[ebp], 1

; 2913 : 				it->m_iFinalTurn = iGameTurn;

	mov	edx, DWORD PTR _it$[ebp]
	mov	eax, DWORD PTR _iGameTurn$222477[ebp]
	mov	DWORD PTR [edx+16], eax

; 2914 : 				it->m_bDealCancelled = true;

	mov	ecx, DWORD PTR _it$[ebp]
	mov	BYTE PTR [ecx+42], 1

; 2915 : 
; 2916 : 				for(itemIter = it->m_TradedItems.begin(); itemIter != it->m_TradedItems.end(); ++itemIter)

	lea	edx, DWORD PTR $T240043[ebp]
	push	edx
	mov	ecx, DWORD PTR _it$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv350[ebp], eax
	mov	eax, DWORD PTR tv350[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _itemIter$222493[ebp], ecx
	mov	DWORD PTR _itemIter$222493[ebp+4], edx
	jmp	SHORT $LN6@DoTurn
$LN5@DoTurn:
	cmp	DWORD PTR _itemIter$222493[ebp+4], 268435455 ; 0fffffffH
	jne	SHORT $LN233@DoTurn
	mov	eax, DWORD PTR _itemIter$222493[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _itemIter$222493[ebp+4], ecx
	jmp	SHORT $LN6@DoTurn
$LN233@DoTurn:
	mov	edx, DWORD PTR _itemIter$222493[ebp]
	mov	DWORD PTR $T240565[ebp], edx
	mov	eax, DWORD PTR _itemIter$222493[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T240565[ebp]
	add	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR $T240574[ebp], eax
	mov	edx, DWORD PTR $T240574[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T240578[ebp], eax
	mov	ecx, DWORD PTR $T240578[ebp]
	mov	DWORD PTR _itemIter$222493[ebp+4], ecx
$LN6@DoTurn:
	lea	edx, DWORD PTR $T240045[ebp]
	push	edx
	mov	ecx, DWORD PTR _it$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T240594[ebp], eax
	mov	eax, DWORD PTR $T240594[ebp]
	mov	ecx, DWORD PTR _itemIter$222493[ebp+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setne	dl
	mov	BYTE PTR $T240044[ebp], dl
	movzx	eax, BYTE PTR $T240044[ebp]
	test	eax, eax
	je	$LN7@DoTurn

; 2917 : 				{
; 2918 : 					// Cancel individual items
; 2919 : 					itemIter->m_iFinalTurn = GC.getGame().getGameTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T240615[ebp], ecx
	mov	edx, DWORD PTR _itemIter$222493[ebp]
	mov	DWORD PTR $T240621[ebp], edx
	mov	eax, DWORD PTR _itemIter$222493[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T240621[ebp]
	mov	edx, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [edx+eax+8]
	mov	DWORD PTR $T240648[ebp], eax
	mov	ecx, DWORD PTR $T240615[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, DWORD PTR $T240648[ebp]
	mov	DWORD PTR [ecx+8], eax

; 2920 : 
; 2921 : 					eFromPlayer = itemIter->m_eFromPlayer;

	mov	edx, DWORD PTR _itemIter$222493[ebp]
	mov	DWORD PTR $T240654[ebp], edx
	mov	eax, DWORD PTR _itemIter$222493[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T240654[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+eax+36]
	mov	DWORD PTR _eFromPlayer$222474[ebp], eax

; 2922 : 					eToPlayer = it->GetOtherPlayer(eFromPlayer);

	mov	ecx, DWORD PTR _eFromPlayer$222474[ebp]
	push	ecx
	mov	ecx, DWORD PTR _it$[ebp]
	call	?GetOtherPlayer@CvDeal@@QBE?AW4PlayerTypes@@W42@@Z ; CvDeal::GetOtherPlayer
	mov	DWORD PTR _eToPlayer$222475[ebp], eax

; 2923 : 
; 2924 : 					DoEndTradedItem(&*itemIter, eToPlayer, true);

	mov	edx, DWORD PTR _itemIter$222493[ebp]
	mov	DWORD PTR $T240686[ebp], edx
	push	1
	mov	eax, DWORD PTR _eToPlayer$222475[ebp]
	push	eax
	mov	ecx, DWORD PTR _itemIter$222493[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T240686[ebp]
	mov	eax, DWORD PTR [edx+8]
	lea	ecx, DWORD PTR [eax+ecx+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z ; CvGameDeals::DoEndTradedItem

; 2925 : 				}

	jmp	$LN5@DoTurn
$LN7@DoTurn:

; 2926 : 			}
; 2927 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	jmp	$LN20@DoTurn
$LN19@DoTurn:

; 2928 : 
; 2929 : 		if(bSomethingChanged)

	movzx	edx, BYTE PTR _bSomethingChanged$222476[ebp]
	test	edx, edx
	je	SHORT $LN3@DoTurn

; 2930 : 		{
; 2931 : 			// Update UI if we were involved in the deal
; 2932 : 			PlayerTypes eActivePlayer = GC.getGame().getActivePlayer();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T240733[ebp], eax
	mov	ecx, DWORD PTR $T240733[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	mov	DWORD PTR _eActivePlayer$222523[ebp], eax

; 2933 : 			if(eFromPlayer == eActivePlayer || eToPlayer == eActivePlayer)

	mov	ecx, DWORD PTR _eFromPlayer$222474[ebp]
	cmp	ecx, DWORD PTR _eActivePlayer$222523[ebp]
	je	SHORT $LN1@DoTurn
	mov	edx, DWORD PTR _eToPlayer$222475[ebp]
	cmp	edx, DWORD PTR _eActivePlayer$222523[ebp]
	jne	SHORT $LN3@DoTurn
$LN1@DoTurn:

; 2934 : 			{
; 2935 : 				GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	mov	eax, DWORD PTR $T240737[ebp]
	mov	DWORD PTR tv333[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv333[ebp], ecx
	push	1
	push	11					; 0000000bH
	mov	edx, DWORD PTR tv333[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv333[ebp]
	mov	edx, DWORD PTR [eax+260]
	call	edx
$LN3@DoTurn:

; 2936 : 			}
; 2937 : 		}
; 2938 : 
; 2939 : 		DoUpdateCurrentDealsList();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoUpdateCurrentDealsList@CvGameDeals@@QAEXXZ ; CvGameDeals::DoUpdateCurrentDealsList
$LN30@DoTurn:

; 2940 : 	}
; 2941 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoTurn@CvGameDeals@@QAEXXZ$0:
	lea	ecx, DWORD PTR _itemIter$222481[ebp]
	jmp	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
__unwindfunclet$?DoTurn@CvGameDeals@@QAEXXZ$3:
	lea	ecx, DWORD PTR _itemIter$222493[ebp]
	jmp	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
__ehhandler$?DoTurn@CvGameDeals@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-272]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DoTurn@CvGameDeals@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoTurn@CvGameDeals@@QAEXXZ ENDP			; CvGameDeals::DoTurn
PUBLIC	?HasMadeProposal@CvGameDeals@@QAE?AW4PlayerTypes@@W42@@Z ; CvGameDeals::HasMadeProposal
; Function compile flags: /Odtp
;	COMDAT ?HasMadeProposal@CvGameDeals@@QAE?AW4PlayerTypes@@W42@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T240756 = -12						; size = 4
$T240749 = -8						; size = 4
_iter$222531 = -4					; size = 4
_ePlayer$ = 8						; size = 4
?HasMadeProposal@CvGameDeals@@QAE?AW4PlayerTypes@@W42@@Z PROC ; CvGameDeals::HasMadeProposal, COMDAT
; _this$ = ecx

; 2946 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2947 : 	if(m_ProposedDeals.size() > 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T240749[ebp], ecx
	cmp	DWORD PTR $T240749[ebp], 0
	jbe	SHORT $LN5@HasMadePro

; 2948 : 	{
; 2949 : 		DealList::iterator iter;
; 2950 : 		for(iter = m_ProposedDeals.begin(); iter != m_ProposedDeals.end(); ++iter)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _iter$222531[ebp], eax
	jmp	SHORT $LN4@HasMadePro
$LN3@HasMadePro:
	mov	ecx, DWORD PTR _iter$222531[ebp]
	add	ecx, 76					; 0000004cH
	mov	DWORD PTR _iter$222531[ebp], ecx
$LN4@HasMadePro:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	mov	DWORD PTR $T240756[ebp], edx
	mov	eax, DWORD PTR $T240756[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 76					; 0000004cH
	mov	edx, DWORD PTR $T240756[ebp]
	add	ecx, DWORD PTR [edx]
	cmp	DWORD PTR _iter$222531[ebp], ecx
	je	SHORT $LN5@HasMadePro

; 2951 : 			if(iter->m_eFromPlayer == ePlayer)

	mov	eax, DWORD PTR _iter$222531[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _ePlayer$[ebp]
	jne	SHORT $LN1@HasMadePro

; 2952 : 				return iter->m_eToPlayer;

	mov	edx, DWORD PTR _iter$222531[ebp]
	mov	eax, DWORD PTR [edx+8]
	jmp	SHORT $LN6@HasMadePro
$LN1@HasMadePro:

; 2953 : 	}

	jmp	SHORT $LN3@HasMadePro
$LN5@HasMadePro:

; 2954 : 
; 2955 : 	return NO_PLAYER;

	or	eax, -1
$LN6@HasMadePro:

; 2956 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?HasMadeProposal@CvGameDeals@@QAE?AW4PlayerTypes@@W42@@Z ENDP ; CvGameDeals::HasMadeProposal
_TEXT	ENDS
PUBLIC	?ProposedDealExists@CvGameDeals@@QAE_NW4PlayerTypes@@0@Z ; CvGameDeals::ProposedDealExists
; Function compile flags: /Odtp
;	COMDAT ?ProposedDealExists@CvGameDeals@@QAE_NW4PlayerTypes@@0@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T240769 = -12						; size = 4
$T240762 = -8						; size = 4
_iter$222542 = -4					; size = 4
_eFromPlayer$ = 8					; size = 4
_eToPlayer$ = 12					; size = 4
?ProposedDealExists@CvGameDeals@@QAE_NW4PlayerTypes@@0@Z PROC ; CvGameDeals::ProposedDealExists, COMDAT
; _this$ = ecx

; 2959 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2960 : 	if(m_ProposedDeals.size() > 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T240762[ebp], ecx
	cmp	DWORD PTR $T240762[ebp], 0
	jbe	SHORT $LN5@ProposedDe

; 2961 : 	{
; 2962 : 		DealList::iterator iter;
; 2963 : 		for(iter = m_ProposedDeals.begin(); iter != m_ProposedDeals.end(); ++iter)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _iter$222542[ebp], eax
	jmp	SHORT $LN4@ProposedDe
$LN3@ProposedDe:
	mov	ecx, DWORD PTR _iter$222542[ebp]
	add	ecx, 76					; 0000004cH
	mov	DWORD PTR _iter$222542[ebp], ecx
$LN4@ProposedDe:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	mov	DWORD PTR $T240769[ebp], edx
	mov	eax, DWORD PTR $T240769[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 76					; 0000004cH
	mov	edx, DWORD PTR $T240769[ebp]
	add	ecx, DWORD PTR [edx]
	cmp	DWORD PTR _iter$222542[ebp], ecx
	je	SHORT $LN5@ProposedDe

; 2964 : 		{
; 2965 : 			if(iter->m_eFromPlayer == eFromPlayer && iter->m_eToPlayer == eToPlayer)

	mov	eax, DWORD PTR _iter$222542[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _eFromPlayer$[ebp]
	jne	SHORT $LN1@ProposedDe
	mov	edx, DWORD PTR _iter$222542[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	eax, DWORD PTR _eToPlayer$[ebp]
	jne	SHORT $LN1@ProposedDe

; 2966 : 				return true;

	mov	al, 1
	jmp	SHORT $LN6@ProposedDe
$LN1@ProposedDe:

; 2967 : 		}

	jmp	SHORT $LN3@ProposedDe
$LN5@ProposedDe:

; 2968 : 	}
; 2969 : 
; 2970 : 	return false;

	xor	al, al
$LN6@ProposedDe:

; 2971 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ProposedDealExists@CvGameDeals@@QAE_NW4PlayerTypes@@0@Z ENDP ; CvGameDeals::ProposedDealExists
_TEXT	ENDS
PUBLIC	?GetProposedDeal@CvGameDeals@@QAEPAVCvDeal@@W4PlayerTypes@@0@Z ; CvGameDeals::GetProposedDeal
; Function compile flags: /Odtp
;	COMDAT ?GetProposedDeal@CvGameDeals@@QAEPAVCvDeal@@W4PlayerTypes@@0@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T240782 = -12						; size = 4
$T240775 = -8						; size = 4
_iter$222553 = -4					; size = 4
_eFromPlayer$ = 8					; size = 4
_eToPlayer$ = 12					; size = 4
?GetProposedDeal@CvGameDeals@@QAEPAVCvDeal@@W4PlayerTypes@@0@Z PROC ; CvGameDeals::GetProposedDeal, COMDAT
; _this$ = ecx

; 2974 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2975 : 	if(m_ProposedDeals.size() > 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T240775[ebp], ecx
	cmp	DWORD PTR $T240775[ebp], 0
	jbe	SHORT $LN5@GetPropose

; 2976 : 	{
; 2977 : 		DealList::iterator iter;
; 2978 : 		for(iter = m_ProposedDeals.begin(); iter != m_ProposedDeals.end(); ++iter)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _iter$222553[ebp], eax
	jmp	SHORT $LN4@GetPropose
$LN3@GetPropose:
	mov	ecx, DWORD PTR _iter$222553[ebp]
	add	ecx, 76					; 0000004cH
	mov	DWORD PTR _iter$222553[ebp], ecx
$LN4@GetPropose:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	mov	DWORD PTR $T240782[ebp], edx
	mov	eax, DWORD PTR $T240782[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 76					; 0000004cH
	mov	edx, DWORD PTR $T240782[ebp]
	add	ecx, DWORD PTR [edx]
	cmp	DWORD PTR _iter$222553[ebp], ecx
	je	SHORT $LN5@GetPropose

; 2979 : 			if(iter->m_eFromPlayer == eFromPlayer && iter->m_eToPlayer == eToPlayer)

	mov	eax, DWORD PTR _iter$222553[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _eFromPlayer$[ebp]
	jne	SHORT $LN1@GetPropose
	mov	edx, DWORD PTR _iter$222553[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	eax, DWORD PTR _eToPlayer$[ebp]
	jne	SHORT $LN1@GetPropose

; 2980 : 				return &(*iter);

	mov	eax, DWORD PTR _iter$222553[ebp]
	jmp	SHORT $LN6@GetPropose
$LN1@GetPropose:

; 2981 : 	}

	jmp	SHORT $LN3@GetPropose
$LN5@GetPropose:

; 2982 : 
; 2983 : 	return NULL;

	xor	eax, eax
$LN6@GetPropose:

; 2984 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetProposedDeal@CvGameDeals@@QAEPAVCvDeal@@W4PlayerTypes@@0@Z ENDP ; CvGameDeals::GetProposedDeal
_TEXT	ENDS
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?DoUpdateCurrentDealsList@CvGameDeals@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoUpdateCurrentDealsList@CvGameDeals@@QAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DoUpdateCurrentDealsList@CvGameDeals@@QAEXXZ$5
__ehfuncinfo$?DoUpdateCurrentDealsList@CvGameDeals@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?DoUpdateCurrentDealsList@CvGameDeals@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?DoUpdateCurrentDealsList@CvGameDeals@@QAEXXZ
_TEXT	SEGMENT
_this$ = -1608						; size = 4
$T240828 = -1584					; size = 4
$T240798 = -1560					; size = 4
_tempDeals$ = -1556					; size = 1536
__$ArrayPad$ = -20					; size = 4
_it$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?DoUpdateCurrentDealsList@CvGameDeals@@QAEXXZ PROC	; CvGameDeals::DoUpdateCurrentDealsList, COMDAT
; _this$ = ecx

; 2993 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DoUpdateCurrentDealsList@CvGameDeals@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1596				; 0000063cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2994 : 	DealList::iterator it;
; 2995 : 
; 2996 : 	DealList tempDeals;

	lea	ecx, DWORD PTR _tempDeals$[ebp]
	call	??0?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvDeal,20,0,297,0>::FStaticVector<CvDeal,20,0,297,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2997 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 2998 : 	for (it = m_CurrentlyEndingDeals.begin(); it != m_CurrentlyEndingDeals.end(); ++it)
; 2999 : 	{
; 3000 : 		tempDeals.push_back(*it);
; 3001 : 	}
; 3002 : 	m_CurrentlyEndingDeals.clear();
; 3003 : 	for (it = tempDeals.begin(); it != tempDeals.end(); ++it)
; 3004 : 	{
; 3005 : 		if (it->m_eFromPlayer == eForPlayer || it->m_eToPlayer == eForPlayer)
; 3006 : 		{
; 3007 : 			m_HistoricalDeals.push_back(*it);
; 3008 : 		}
; 3009 : 		else
; 3010 : 		{
; 3011 : 			m_CurrentlyEndingDeals.push_back(*it);
; 3012 : 		}
; 3013 : 	}
; 3014 : 	tempDeals.clear();
; 3015 : #endif
; 3016 : 
; 3017 : 	// Copy the deals into a temporary container
; 3018 : 	for(it = m_CurrentDeals.begin(); it != m_CurrentDeals.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1540]
	mov	DWORD PTR _it$[ebp], ecx
	jmp	SHORT $LN8@DoUpdateCu
$LN7@DoUpdateCu:
	mov	edx, DWORD PTR _it$[ebp]
	add	edx, 76					; 0000004cH
	mov	DWORD PTR _it$[ebp], edx
$LN8@DoUpdateCu:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1540				; 00000604H
	mov	DWORD PTR $T240798[ebp], eax
	mov	ecx, DWORD PTR $T240798[ebp]
	mov	edx, DWORD PTR [ecx+4]
	imul	edx, 76					; 0000004cH
	mov	eax, DWORD PTR $T240798[ebp]
	add	edx, DWORD PTR [eax]
	cmp	DWORD PTR _it$[ebp], edx
	je	SHORT $LN6@DoUpdateCu

; 3019 : 	{
; 3020 : 		tempDeals.push_back(*it);

	mov	ecx, DWORD PTR _it$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _tempDeals$[ebp]
	call	?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z ; FStaticVector<CvDeal,20,0,297,0>::push_back

; 3021 : 	}

	jmp	SHORT $LN7@DoUpdateCu
$LN6@DoUpdateCu:

; 3022 : 
; 3023 : 	// Copy them to either current or historical deals based on whether or not they
; 3024 : 	// are still active
; 3025 : 	m_CurrentDeals.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1540				; 00000604H
	call	?clear@?$BaseVector@VCvDeal@@$0A@@@QAEXXZ ; BaseVector<CvDeal,0>::clear

; 3026 : 	for(it = tempDeals.begin(); it != tempDeals.end(); ++it)

	mov	edx, DWORD PTR _tempDeals$[ebp]
	mov	DWORD PTR _it$[ebp], edx
	jmp	SHORT $LN39@DoUpdateCu
$LN4@DoUpdateCu:
	mov	eax, DWORD PTR _it$[ebp]
	add	eax, 76					; 0000004cH
	mov	DWORD PTR _it$[ebp], eax
$LN39@DoUpdateCu:
	mov	ecx, DWORD PTR _tempDeals$[ebp+4]
	imul	ecx, 76					; 0000004cH
	add	ecx, DWORD PTR _tempDeals$[ebp]
	cmp	DWORD PTR _it$[ebp], ecx
	je	SHORT $LN3@DoUpdateCu

; 3027 : 	{
; 3028 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 3029 : 		if (it->m_iFinalTurn == GC.getGame().getGameTurn() && (it->m_eFromPlayer == eForPlayer || it->m_eToPlayer == eForPlayer))
; 3030 : 		{
; 3031 : 			m_CurrentlyEndingDeals.push_back(*it);
; 3032 : 		}
; 3033 : 		else if (it->m_iFinalTurn < GC.getGame().getGameTurn())
; 3034 : #else
; 3035 : 		if(it->m_iFinalTurn <= GC.getGame().getGameTurn())

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T240828[ebp], edx
	mov	ecx, DWORD PTR $T240828[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, DWORD PTR _it$[ebp]
	cmp	DWORD PTR [ecx+16], eax
	jg	SHORT $LN2@DoUpdateCu

; 3036 : #endif
; 3037 : 		{
; 3038 : 			m_HistoricalDeals.push_back(*it);

	mov	edx, DWORD PTR _it$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3076				; 00000c04H
	call	?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z ; FStaticVector<CvDeal,20,0,297,0>::push_back

; 3039 : 		}
; 3040 : 		else

	jmp	SHORT $LN1@DoUpdateCu
$LN2@DoUpdateCu:

; 3041 : 		{
; 3042 : 			m_CurrentDeals.push_back(*it);

	mov	eax, DWORD PTR _it$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1540				; 00000604H
	call	?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z ; FStaticVector<CvDeal,20,0,297,0>::push_back
$LN1@DoUpdateCu:

; 3043 : 		}
; 3044 : 	}

	jmp	SHORT $LN4@DoUpdateCu
$LN3@DoUpdateCu:

; 3045 : }

	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _tempDeals$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _tempDeals$[ebp]
	push	edx
	lea	ecx, DWORD PTR _tempDeals$[ebp]
	call	?Free@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXPAVCvDeal@@I@Z ; FStaticVector<CvDeal,20,0,297,0>::Free
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoUpdateCurrentDealsList@CvGameDeals@@QAEXXZ$0:
	lea	ecx, DWORD PTR _tempDeals$[ebp]
	jmp	??1?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvDeal,20,0,297,0>::~FStaticVector<CvDeal,20,0,297,0>
__unwindfunclet$?DoUpdateCurrentDealsList@CvGameDeals@@QAEXXZ$5:
	lea	ecx, DWORD PTR _tempDeals$[ebp]
	jmp	??1?$BaseVector@VCvDeal@@$0A@@@QAE@XZ	; BaseVector<CvDeal,0>::~BaseVector<CvDeal,0>
__ehhandler$?DoUpdateCurrentDealsList@CvGameDeals@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1600]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DoUpdateCurrentDealsList@CvGameDeals@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoUpdateCurrentDealsList@CvGameDeals@@QAEXXZ ENDP	; CvGameDeals::DoUpdateCurrentDealsList
PUBLIC	?DoCancelDealsBetweenPlayers@CvGameDeals@@QAEXW4PlayerTypes@@0@Z ; CvGameDeals::DoCancelDealsBetweenPlayers
PUBLIC	?DoCancelDealsBetweenTeams@CvGameDeals@@QAEXW4TeamTypes@@0@Z ; CvGameDeals::DoCancelDealsBetweenTeams
; Function compile flags: /Odtp
;	COMDAT ?DoCancelDealsBetweenTeams@CvGameDeals@@QAEXW4TeamTypes@@0@Z
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T240918 = -44						; size = 4
$T240914 = -37						; size = 1
$T240905 = -36						; size = 4
$T240893 = -32						; size = 4
$T240889 = -25						; size = 1
$T240880 = -24						; size = 4
$T240876 = -20						; size = 4
_iPlayerLoop1$222579 = -16				; size = 4
_eFromPlayer$222577 = -12				; size = 4
_iPlayerLoop2$222580 = -8				; size = 4
_eToPlayer$222578 = -4					; size = 4
_eTeam1$ = 8						; size = 4
_eTeam2$ = 12						; size = 4
?DoCancelDealsBetweenTeams@CvGameDeals@@QAEXW4TeamTypes@@0@Z PROC ; CvGameDeals::DoCancelDealsBetweenTeams, COMDAT
; _this$ = ecx

; 3049 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 3050 : 	if(m_CurrentDeals.size() > 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1544]
	mov	DWORD PTR $T240876[ebp], ecx
	cmp	DWORD PTR $T240876[ebp], 0
	jbe	$LN12@DoCancelDe

; 3051 : 	{
; 3052 : 		PlayerTypes eFromPlayer, eToPlayer;
; 3053 : 		int iPlayerLoop1, iPlayerLoop2;
; 3054 : 
; 3055 : 		// Loop through first set of players
; 3056 : 		for(iPlayerLoop1 = 0; iPlayerLoop1 < MAX_MAJOR_CIVS; iPlayerLoop1++)

	mov	DWORD PTR _iPlayerLoop1$222579[ebp], 0
	jmp	SHORT $LN10@DoCancelDe
$LN9@DoCancelDe:
	mov	edx, DWORD PTR _iPlayerLoop1$222579[ebp]
	add	edx, 1
	mov	DWORD PTR _iPlayerLoop1$222579[ebp], edx
$LN10@DoCancelDe:
	cmp	DWORD PTR _iPlayerLoop1$222579[ebp], 22	; 00000016H
	jge	$LN12@DoCancelDe

; 3057 : 		{
; 3058 : 			eFromPlayer = (PlayerTypes) iPlayerLoop1;

	mov	eax, DWORD PTR _iPlayerLoop1$222579[ebp]
	mov	DWORD PTR _eFromPlayer$222577[ebp], eax

; 3059 : 
; 3060 : 			if(!GET_PLAYER(eFromPlayer).isEverAlive())

	mov	ecx, DWORD PTR _eFromPlayer$222577[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T240880[ebp], ecx
	mov	edx, DWORD PTR $T240880[ebp]
	mov	al, BYTE PTR [edx+2268]
	mov	BYTE PTR $T240889[ebp], al
	movzx	ecx, BYTE PTR $T240889[ebp]
	test	ecx, ecx
	jne	SHORT $LN7@DoCancelDe

; 3061 : 			{
; 3062 : 				continue;

	jmp	SHORT $LN9@DoCancelDe
$LN7@DoCancelDe:

; 3063 : 			}
; 3064 : 			if(GET_PLAYER(eFromPlayer).getTeam() != eTeam1)

	mov	edx, DWORD PTR _eFromPlayer$222577[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T240893[ebp], edx
	mov	eax, DWORD PTR $T240893[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	eax, DWORD PTR _eTeam1$[ebp]
	je	SHORT $LN6@DoCancelDe

; 3065 : 			{
; 3066 : 				continue;

	jmp	SHORT $LN9@DoCancelDe
$LN6@DoCancelDe:

; 3067 : 			}
; 3068 : 
; 3069 : 			// Loop through second set of players
; 3070 : 			for(iPlayerLoop2 = 0; iPlayerLoop2 < MAX_MAJOR_CIVS; iPlayerLoop2++)

	mov	DWORD PTR _iPlayerLoop2$222580[ebp], 0
	jmp	SHORT $LN5@DoCancelDe
$LN4@DoCancelDe:
	mov	edx, DWORD PTR _iPlayerLoop2$222580[ebp]
	add	edx, 1
	mov	DWORD PTR _iPlayerLoop2$222580[ebp], edx
$LN5@DoCancelDe:
	cmp	DWORD PTR _iPlayerLoop2$222580[ebp], 22	; 00000016H
	jge	SHORT $LN3@DoCancelDe

; 3071 : 			{
; 3072 : 				eToPlayer = (PlayerTypes) iPlayerLoop2;

	mov	eax, DWORD PTR _iPlayerLoop2$222580[ebp]
	mov	DWORD PTR _eToPlayer$222578[ebp], eax

; 3073 : 
; 3074 : 				if(!GET_PLAYER(eToPlayer).isEverAlive())

	mov	ecx, DWORD PTR _eToPlayer$222578[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T240905[ebp], ecx
	mov	edx, DWORD PTR $T240905[ebp]
	mov	al, BYTE PTR [edx+2268]
	mov	BYTE PTR $T240914[ebp], al
	movzx	ecx, BYTE PTR $T240914[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@DoCancelDe

; 3075 : 				{
; 3076 : 					continue;

	jmp	SHORT $LN4@DoCancelDe
$LN2@DoCancelDe:

; 3077 : 				}
; 3078 : 				if(GET_PLAYER(eToPlayer).getTeam() != eTeam2)

	mov	edx, DWORD PTR _eToPlayer$222578[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T240918[ebp], edx
	mov	eax, DWORD PTR $T240918[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	eax, DWORD PTR _eTeam2$[ebp]
	je	SHORT $LN1@DoCancelDe

; 3079 : 				{
; 3080 : 					continue;

	jmp	SHORT $LN4@DoCancelDe
$LN1@DoCancelDe:

; 3081 : 				}
; 3082 : 
; 3083 : 				DoCancelDealsBetweenPlayers(eFromPlayer, eToPlayer);

	mov	edx, DWORD PTR _eToPlayer$222578[ebp]
	push	edx
	mov	eax, DWORD PTR _eFromPlayer$222577[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoCancelDealsBetweenPlayers@CvGameDeals@@QAEXW4PlayerTypes@@0@Z ; CvGameDeals::DoCancelDealsBetweenPlayers

; 3084 : 			}

	jmp	SHORT $LN4@DoCancelDe
$LN3@DoCancelDe:

; 3085 : 		}

	jmp	$LN9@DoCancelDe
$LN12@DoCancelDe:

; 3086 : 	}
; 3087 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?DoCancelDealsBetweenTeams@CvGameDeals@@QAEXW4TeamTypes@@0@Z ENDP ; CvGameDeals::DoCancelDealsBetweenTeams
_TEXT	ENDS
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
xdata$x	SEGMENT
__unwindtable$?DoCancelDealsBetweenPlayers@CvGameDeals@@QAEXW4PlayerTypes@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoCancelDealsBetweenPlayers@CvGameDeals@@QAEXW4PlayerTypes@@0@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoCancelDealsBetweenPlayers@CvGameDeals@@QAEXW4PlayerTypes@@0@Z$1
__ehfuncinfo$?DoCancelDealsBetweenPlayers@CvGameDeals@@QAEXW4PlayerTypes@@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?DoCancelDealsBetweenPlayers@CvGameDeals@@QAEXW4PlayerTypes@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?DoCancelDealsBetweenPlayers@CvGameDeals@@QAEXW4PlayerTypes@@0@Z
_TEXT	SEGMENT
tv232 = -1688						; size = 4
tv240 = -1684						; size = 4
_this$ = -1680						; size = 4
$T241191 = -1676					; size = 4
$T241187 = -1672					; size = 4
$T241122 = -1652					; size = 4
$T241090 = -1648					; size = 4
$T241084 = -1644					; size = 4
$T241057 = -1640					; size = 4
$T241051 = -1636					; size = 4
$T241030 = -1632					; size = 4
$T241014 = -1628					; size = 4
$T241010 = -1624					; size = 4
$T241001 = -1620					; size = 4
$T240975 = -1616					; size = 4
$T240965 = -1612					; size = 4
$T240952 = -1600					; size = 4
$T240945 = -1596					; size = 4
$T240932 = -1592					; size = 8
$T240931 = -1581					; size = 1
$T240930 = -1580					; size = 8
_eActivePlayer$222620 = -1572				; size = 4
_itemIter$222611 = -1568				; size = 8
_bSomethingChanged$222601 = -1557			; size = 1
_tempDeals$ = -1556					; size = 1536
__$ArrayPad$ = -20					; size = 4
_it$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_eFromPlayer$ = 8					; size = 4
_eToPlayer$ = 12					; size = 4
?DoCancelDealsBetweenPlayers@CvGameDeals@@QAEXW4PlayerTypes@@0@Z PROC ; CvGameDeals::DoCancelDealsBetweenPlayers, COMDAT
; _this$ = ecx

; 3091 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DoCancelDealsBetweenPlayers@CvGameDeals@@QAEXW4PlayerTypes@@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1676				; 0000068cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3092 : 	DealList::iterator it;
; 3093 : 	DealList tempDeals;

	lea	ecx, DWORD PTR _tempDeals$[ebp]
	call	??0?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvDeal,20,0,297,0>::FStaticVector<CvDeal,20,0,297,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3094 : 
; 3095 : 	if(m_CurrentDeals.size() > 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1544]
	mov	DWORD PTR $T240945[ebp], ecx
	cmp	DWORD PTR $T240945[ebp], 0
	jbe	$LN17@DoCancelDe@2

; 3096 : 	{
; 3097 : 		bool bSomethingChanged = false;

	mov	BYTE PTR _bSomethingChanged$222601[ebp], 0

; 3098 : 
; 3099 : 		// Copy the deals into a temporary container
; 3100 : 		for(it = m_CurrentDeals.begin(); it != m_CurrentDeals.end(); ++it)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1540]
	mov	DWORD PTR _it$[ebp], eax
	jmp	SHORT $LN16@DoCancelDe@2
$LN15@DoCancelDe@2:
	mov	ecx, DWORD PTR _it$[ebp]
	add	ecx, 76					; 0000004cH
	mov	DWORD PTR _it$[ebp], ecx
$LN16@DoCancelDe@2:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1540				; 00000604H
	mov	DWORD PTR $T240952[ebp], edx
	mov	eax, DWORD PTR $T240952[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 76					; 0000004cH
	mov	edx, DWORD PTR $T240952[ebp]
	add	ecx, DWORD PTR [edx]
	cmp	DWORD PTR _it$[ebp], ecx
	je	SHORT $LN14@DoCancelDe@2

; 3101 : 		{
; 3102 : 			tempDeals.push_back(*it);

	mov	eax, DWORD PTR _it$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tempDeals$[ebp]
	call	?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z ; FStaticVector<CvDeal,20,0,297,0>::push_back

; 3103 : 		}

	jmp	SHORT $LN15@DoCancelDe@2
$LN14@DoCancelDe@2:

; 3104 : 
; 3105 : 		m_CurrentDeals.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1540				; 00000604H
	mov	DWORD PTR $T240965[ebp], ecx
	mov	edx, DWORD PTR $T240965[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR $T240965[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR $T240965[ebp]
	call	?Destroy@?$BaseVector@VCvDeal@@$0A@@@IAEXPAVCvDeal@@I@Z ; BaseVector<CvDeal,0>::Destroy
	mov	eax, DWORD PTR $T240965[ebp]
	mov	DWORD PTR [eax+4], 0

; 3106 : 		for(it = tempDeals.begin(); it != tempDeals.end(); ++it)

	mov	ecx, DWORD PTR _tempDeals$[ebp]
	mov	DWORD PTR _it$[ebp], ecx
	jmp	SHORT $LN47@DoCancelDe@2
$LN12@DoCancelDe@2:
	mov	edx, DWORD PTR _it$[ebp]
	add	edx, 76					; 0000004cH
	mov	DWORD PTR _it$[ebp], edx
$LN47@DoCancelDe@2:
	mov	eax, DWORD PTR _tempDeals$[ebp+4]
	imul	eax, 76					; 0000004cH
	add	eax, DWORD PTR _tempDeals$[ebp]
	cmp	DWORD PTR _it$[ebp], eax
	je	$LN11@DoCancelDe@2

; 3107 : 		{
; 3108 : 			// Players on this deal match?
; 3109 : 			if(it->m_eFromPlayer == eFromPlayer && it->m_eToPlayer == eToPlayer ||
; 3110 : 			        it->m_eFromPlayer == eToPlayer && it->m_eToPlayer == eFromPlayer)

	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _eFromPlayer$[ebp]
	jne	SHORT $LN8@DoCancelDe@2
	mov	eax, DWORD PTR _it$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR _eToPlayer$[ebp]
	je	SHORT $LN9@DoCancelDe@2
$LN8@DoCancelDe@2:
	mov	edx, DWORD PTR _it$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _eToPlayer$[ebp]
	jne	$LN10@DoCancelDe@2
	mov	ecx, DWORD PTR _it$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR _eFromPlayer$[ebp]
	jne	$LN10@DoCancelDe@2
$LN9@DoCancelDe@2:

; 3111 : 			{
; 3112 : 				// Change final turn
; 3113 : 				it->m_iFinalTurn = GC.getGame().getGameTurn();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T240975[ebp], eax
	mov	ecx, DWORD PTR $T240975[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, DWORD PTR _it$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 3114 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 3115 : 				it->m_bDealCancelled = true;
; 3116 : #endif
; 3117 : 
; 3118 : 				// Cancel individual items
; 3119 : 				TradedItemList::iterator itemIter;

	lea	ecx, DWORD PTR _itemIter$222611[ebp]
	call	??0iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::iterator
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 3120 : 				for(itemIter = it->m_TradedItems.begin(); itemIter != it->m_TradedItems.end(); ++itemIter)

	lea	edx, DWORD PTR $T240930[ebp]
	push	edx
	mov	ecx, DWORD PTR _it$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv240[ebp], eax
	mov	eax, DWORD PTR tv240[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _itemIter$222611[ebp], ecx
	mov	DWORD PTR _itemIter$222611[ebp+4], edx
	jmp	SHORT $LN7@DoCancelDe@2
$LN6@DoCancelDe@2:
	cmp	DWORD PTR _itemIter$222611[ebp+4], 268435455 ; 0fffffffH
	jne	SHORT $LN63@DoCancelDe@2
	mov	eax, DWORD PTR _itemIter$222611[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _itemIter$222611[ebp+4], ecx
	jmp	SHORT $LN7@DoCancelDe@2
$LN63@DoCancelDe@2:
	mov	edx, DWORD PTR _itemIter$222611[ebp]
	mov	DWORD PTR $T241001[ebp], edx
	mov	eax, DWORD PTR _itemIter$222611[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T241001[ebp]
	add	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR $T241010[ebp], eax
	mov	edx, DWORD PTR $T241010[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T241014[ebp], eax
	mov	ecx, DWORD PTR $T241014[ebp]
	mov	DWORD PTR _itemIter$222611[ebp+4], ecx
$LN7@DoCancelDe@2:
	lea	edx, DWORD PTR $T240932[ebp]
	push	edx
	mov	ecx, DWORD PTR _it$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T241030[ebp], eax
	mov	eax, DWORD PTR $T241030[ebp]
	mov	ecx, DWORD PTR _itemIter$222611[ebp+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setne	dl
	mov	BYTE PTR $T240931[ebp], dl
	movzx	eax, BYTE PTR $T240931[ebp]
	test	eax, eax
	je	$LN5@DoCancelDe@2

; 3121 : 				{
; 3122 : 					bSomethingChanged = true;

	mov	BYTE PTR _bSomethingChanged$222601[ebp], 1

; 3123 : 
; 3124 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 3125 : 					itemIter->m_iTurnsRemaining = 0;
; 3126 : #else
; 3127 : 					itemIter->m_iFinalTurn = GC.getGame().getGameTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T241051[ebp], ecx
	mov	edx, DWORD PTR _itemIter$222611[ebp]
	mov	DWORD PTR $T241057[ebp], edx
	mov	eax, DWORD PTR _itemIter$222611[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T241057[ebp]
	mov	edx, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [edx+eax+8]
	mov	DWORD PTR $T241084[ebp], eax
	mov	ecx, DWORD PTR $T241051[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, DWORD PTR $T241084[ebp]
	mov	DWORD PTR [ecx+8], eax

; 3128 : #endif
; 3129 : 
; 3130 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 3131 : 					PlayerTypes eItemFromPlayer = itemIter->m_eFromPlayer;
; 3132 : 					PlayerTypes eItemToPlayer = it->GetOtherPlayer(eItemFromPlayer);
; 3133 : 
; 3134 : 					if (eItemToPlayer == eToPlayer || eItemToPlayer == eFromPlayer || itemIter->m_eItemType == TRADE_ITEM_RESEARCH_AGREEMENT)
; 3135 : 					{
; 3136 : 						DoEndTradedItem(&*itemIter, eItemToPlayer, true);
; 3137 : 					}
; 3138 : #else
; 3139 : 					eFromPlayer = itemIter->m_eFromPlayer;

	mov	edx, DWORD PTR _itemIter$222611[ebp]
	mov	DWORD PTR $T241090[ebp], edx
	mov	eax, DWORD PTR _itemIter$222611[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T241090[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+eax+36]
	mov	DWORD PTR _eFromPlayer$[ebp], eax

; 3140 : 					eToPlayer = it->GetOtherPlayer(eFromPlayer);

	mov	ecx, DWORD PTR _eFromPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _it$[ebp]
	call	?GetOtherPlayer@CvDeal@@QBE?AW4PlayerTypes@@W42@@Z ; CvDeal::GetOtherPlayer
	mov	DWORD PTR _eToPlayer$[ebp], eax

; 3141 : 
; 3142 : 					DoEndTradedItem(&*itemIter, eToPlayer, true);

	mov	edx, DWORD PTR _itemIter$222611[ebp]
	mov	DWORD PTR $T241122[ebp], edx
	push	1
	mov	eax, DWORD PTR _eToPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _itemIter$222611[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T241122[ebp]
	mov	eax, DWORD PTR [edx+8]
	lea	ecx, DWORD PTR [eax+ecx+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z ; CvGameDeals::DoEndTradedItem

; 3143 : #endif
; 3144 : 				}

	jmp	$LN6@DoCancelDe@2
$LN5@DoCancelDe@2:

; 3145 : 				m_HistoricalDeals.push_back(*it);

	mov	edx, DWORD PTR _it$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3076				; 00000c04H
	call	?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z ; FStaticVector<CvDeal,20,0,297,0>::push_back

; 3146 : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 0

; 3147 : 			else

	jmp	SHORT $LN4@DoCancelDe@2
$LN10@DoCancelDe@2:

; 3148 : 			{
; 3149 : 				m_CurrentDeals.push_back(*it);

	mov	eax, DWORD PTR _it$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1540				; 00000604H
	call	?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z ; FStaticVector<CvDeal,20,0,297,0>::push_back
$LN4@DoCancelDe@2:

; 3150 : 			}
; 3151 : 		}

	jmp	$LN12@DoCancelDe@2
$LN11@DoCancelDe@2:

; 3152 : 
; 3153 : 		if(bSomethingChanged)

	movzx	ecx, BYTE PTR _bSomethingChanged$222601[ebp]
	test	ecx, ecx
	je	SHORT $LN17@DoCancelDe@2

; 3154 : 		{
; 3155 : 			// Update UI if we were involved in the deal
; 3156 : 			PlayerTypes eActivePlayer = GC.getGame().getActivePlayer();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T241187[ebp], edx
	mov	ecx, DWORD PTR $T241187[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	mov	DWORD PTR _eActivePlayer$222620[ebp], eax

; 3157 : 			if(eFromPlayer == eActivePlayer || eToPlayer == eActivePlayer)

	mov	eax, DWORD PTR _eFromPlayer$[ebp]
	cmp	eax, DWORD PTR _eActivePlayer$222620[ebp]
	je	SHORT $LN1@DoCancelDe@2
	mov	ecx, DWORD PTR _eToPlayer$[ebp]
	cmp	ecx, DWORD PTR _eActivePlayer$222620[ebp]
	jne	SHORT $LN17@DoCancelDe@2
$LN1@DoCancelDe@2:

; 3158 : 			{
; 3159 : 				GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	mov	edx, DWORD PTR $T241191[ebp]
	mov	DWORD PTR tv232[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv232[ebp], eax
	push	1
	push	11					; 0000000bH
	mov	ecx, DWORD PTR tv232[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv232[ebp]
	mov	eax, DWORD PTR [edx+260]
	call	eax
$LN17@DoCancelDe@2:

; 3160 : 			}
; 3161 : 		}
; 3162 : 	}
; 3163 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tempDeals$[ebp]
	call	??1?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvDeal,20,0,297,0>::~FStaticVector<CvDeal,20,0,297,0>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoCancelDealsBetweenPlayers@CvGameDeals@@QAEXW4PlayerTypes@@0@Z$0:
	lea	ecx, DWORD PTR _tempDeals$[ebp]
	jmp	??1?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvDeal,20,0,297,0>::~FStaticVector<CvDeal,20,0,297,0>
__unwindfunclet$?DoCancelDealsBetweenPlayers@CvGameDeals@@QAEXW4PlayerTypes@@0@Z$1:
	lea	ecx, DWORD PTR _itemIter$222611[ebp]
	jmp	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
__ehhandler$?DoCancelDealsBetweenPlayers@CvGameDeals@@QAEXW4PlayerTypes@@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1680]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DoCancelDealsBetweenPlayers@CvGameDeals@@QAEXW4PlayerTypes@@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoCancelDealsBetweenPlayers@CvGameDeals@@QAEXW4PlayerTypes@@0@Z ENDP ; CvGameDeals::DoCancelDealsBetweenPlayers
PUBLIC	?DoCancelAllDealsWithPlayer@CvGameDeals@@QAEXW4PlayerTypes@@@Z ; CvGameDeals::DoCancelAllDealsWithPlayer
; Function compile flags: /Odtp
;	COMDAT ?DoCancelAllDealsWithPlayer@CvGameDeals@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T241232 = -36						; size = 4
$T241228 = -29						; size = 1
$T241219 = -28						; size = 4
$T241212 = -24						; size = 4
$T241203 = -20						; size = 4
_iPlayerLoop$222630 = -16				; size = 4
_ePlayer$ = -12						; size = 4
_pCancelTeam$ = -8					; size = 4
_eTeam$ = -4						; size = 4
_eCancelPlayer$ = 8					; size = 4
?DoCancelAllDealsWithPlayer@CvGameDeals@@QAEXW4PlayerTypes@@@Z PROC ; CvGameDeals::DoCancelAllDealsWithPlayer, COMDAT
; _this$ = ecx

; 3167 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 3168 : 	CvTeam* pCancelTeam = &GET_TEAM(GET_PLAYER(eCancelPlayer).getTeam());

	mov	eax, DWORD PTR _eCancelPlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T241203[ebp], eax
	mov	ecx, DWORD PTR $T241203[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T241212[ebp], eax
	mov	eax, DWORD PTR $T241212[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR _pCancelTeam$[ebp], eax

; 3169 : 
; 3170 : 	// Loop through first set of players
; 3171 : 	TeamTypes eTeam;
; 3172 : 	PlayerTypes ePlayer;
; 3173 : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	mov	DWORD PTR _iPlayerLoop$222630[ebp], 0
	jmp	SHORT $LN6@DoCancelAl
$LN5@DoCancelAl:
	mov	ecx, DWORD PTR _iPlayerLoop$222630[ebp]
	add	ecx, 1
	mov	DWORD PTR _iPlayerLoop$222630[ebp], ecx
$LN6@DoCancelAl:
	cmp	DWORD PTR _iPlayerLoop$222630[ebp], 22	; 00000016H
	jge	$LN7@DoCancelAl

; 3174 : 	{
; 3175 : 		ePlayer = (PlayerTypes) iPlayerLoop;

	mov	edx, DWORD PTR _iPlayerLoop$222630[ebp]
	mov	DWORD PTR _ePlayer$[ebp], edx

; 3176 : 
; 3177 : 		if(!GET_PLAYER(ePlayer).isEverAlive())

	mov	eax, DWORD PTR _ePlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T241219[ebp], eax
	mov	ecx, DWORD PTR $T241219[ebp]
	mov	dl, BYTE PTR [ecx+2268]
	mov	BYTE PTR $T241228[ebp], dl
	movzx	eax, BYTE PTR $T241228[ebp]
	test	eax, eax
	jne	SHORT $LN3@DoCancelAl

; 3178 : 		{
; 3179 : 			continue;

	jmp	SHORT $LN5@DoCancelAl
$LN3@DoCancelAl:

; 3180 : 		}
; 3181 : 
; 3182 : 		if(ePlayer == eCancelPlayer)

	mov	ecx, DWORD PTR _ePlayer$[ebp]
	cmp	ecx, DWORD PTR _eCancelPlayer$[ebp]
	jne	SHORT $LN2@DoCancelAl

; 3183 : 		{
; 3184 : 			continue;

	jmp	SHORT $LN5@DoCancelAl
$LN2@DoCancelAl:

; 3185 : 		}
; 3186 : 
; 3187 : 		eTeam = GET_PLAYER(ePlayer).getTeam();

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T241232[ebp], edx
	mov	eax, DWORD PTR $T241232[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$[ebp], eax

; 3188 : 
; 3189 : 		if(pCancelTeam->isHasMet(eTeam))

	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pCancelTeam$[ebp]
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@DoCancelAl

; 3190 : 		{
; 3191 : 			DoCancelDealsBetweenPlayers(eCancelPlayer, ePlayer);

	mov	ecx, DWORD PTR _ePlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eCancelPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoCancelDealsBetweenPlayers@CvGameDeals@@QAEXW4PlayerTypes@@0@Z ; CvGameDeals::DoCancelDealsBetweenPlayers
$LN1@DoCancelAl:

; 3192 : 		}

	jmp	$LN5@DoCancelAl
$LN7@DoCancelAl:

; 3193 : 	}
; 3194 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?DoCancelAllDealsWithPlayer@CvGameDeals@@QAEXW4PlayerTypes@@@Z ENDP ; CvGameDeals::DoCancelAllDealsWithPlayer
_TEXT	ENDS
PUBLIC	?DoCancelAllProposedDealsWithPlayer@CvGameDeals@@QAEXW4PlayerTypes@@@Z ; CvGameDeals::DoCancelAllProposedDealsWithPlayer
; Function compile flags: /Odtp
;	COMDAT ?DoCancelAllProposedDealsWithPlayer@CvGameDeals@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_iPlayerLoop$222643 = -8				; size = 4
_eLoopPlayer$ = -4					; size = 4
_eCancelPlayer$ = 8					; size = 4
?DoCancelAllProposedDealsWithPlayer@CvGameDeals@@QAEXW4PlayerTypes@@@Z PROC ; CvGameDeals::DoCancelAllProposedDealsWithPlayer, COMDAT
; _this$ = ecx

; 3197 : {//Cancel all proposed deals involving eCancelPlayer.

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 3198 : 	PlayerTypes eLoopPlayer;
; 3199 : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	mov	DWORD PTR _iPlayerLoop$222643[ebp], 0
	jmp	SHORT $LN5@DoCancelAl@2
$LN4@DoCancelAl@2:
	mov	eax, DWORD PTR _iPlayerLoop$222643[ebp]
	add	eax, 1
	mov	DWORD PTR _iPlayerLoop$222643[ebp], eax
$LN5@DoCancelAl@2:
	cmp	DWORD PTR _iPlayerLoop$222643[ebp], 22	; 00000016H
	jge	SHORT $LN6@DoCancelAl@2

; 3200 : 	{
; 3201 : 		eLoopPlayer = (PlayerTypes) iPlayerLoop;

	mov	ecx, DWORD PTR _iPlayerLoop$222643[ebp]
	mov	DWORD PTR _eLoopPlayer$[ebp], ecx

; 3202 : 		if(GetProposedDeal(eCancelPlayer, eLoopPlayer))

	mov	edx, DWORD PTR _eLoopPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _eCancelPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetProposedDeal@CvGameDeals@@QAEPAVCvDeal@@W4PlayerTypes@@0@Z ; CvGameDeals::GetProposedDeal
	test	eax, eax
	je	SHORT $LN2@DoCancelAl@2

; 3203 : 		{//deal from eCancelPlayer
; 3204 : 			FinalizeDeal(eCancelPlayer, eLoopPlayer, false);

	push	0
	mov	ecx, DWORD PTR _eLoopPlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eCancelPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z ; CvGameDeals::FinalizeDeal
$LN2@DoCancelAl@2:

; 3205 : 		}
; 3206 : 		if(GetProposedDeal(eLoopPlayer, eCancelPlayer))

	mov	eax, DWORD PTR _eCancelPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eLoopPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetProposedDeal@CvGameDeals@@QAEPAVCvDeal@@W4PlayerTypes@@0@Z ; CvGameDeals::GetProposedDeal
	test	eax, eax
	je	SHORT $LN1@DoCancelAl@2

; 3207 : 		{//deal to eCancelPlayer
; 3208 : 			FinalizeDeal(eLoopPlayer, eCancelPlayer, false);

	push	0
	mov	edx, DWORD PTR _eCancelPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _eLoopPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z ; CvGameDeals::FinalizeDeal
$LN1@DoCancelAl@2:

; 3209 : 		}

	jmp	SHORT $LN4@DoCancelAl@2
$LN6@DoCancelAl@2:

; 3210 : 	}
; 3211 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?DoCancelAllProposedDealsWithPlayer@CvGameDeals@@QAEXW4PlayerTypes@@@Z ENDP ; CvGameDeals::DoCancelAllProposedDealsWithPlayer
_TEXT	ENDS
PUBLIC	??_C@_0DA@MCCNCAHM@TXT_KEY_NOTIFICATION_SUMMARY_DEA@ ; `string'
PUBLIC	??_C@_0CI@IHJMECBC@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@ ; `string'
PUBLIC	??_C@_0EA@CJLLGEG@TXT_KEY_NOTIFICATION_SUMMARY_DEA@ ; `string'
PUBLIC	??_C@_0DI@OEOIFBIA@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@ ; `string'
PUBLIC	??_C@_0EC@FOMHLEFF@TXT_KEY_NOTIFICATION_SUMMARY_DEA@ ; `string'
PUBLIC	??_C@_0DK@PNAJFFDF@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@ ; `string'
PUBLIC	??_C@_0CD@MHNHHCAA@TXT_KEY_NTFN_RA_FREE_TECH_CANCEL@ ; `string'
PUBLIC	??_C@_0CB@CBGADHDG@TXT_KEY_NTFN_RA_FREE_TECH_CANCEL@ ; `string'
PUBLIC	?GetLocalizedText@@YA?AVCvString@@PBD@Z		; GetLocalizedText
PUBLIC	??_C@_0CH@OMALONMP@TXT_KEY_NTFN_RA_FREE_TECH_WAR_CA@ ; `string'
PUBLIC	??_C@_0CF@DJIOHFOE@TXT_KEY_NTFN_RA_FREE_TECH_WAR_CA@ ; `string'
PUBLIC	??_C@_0BM@HJHPJDAF@TXT_KEY_NTFN_RA_FREE_TECH_S?$AA@ ; `string'
PUBLIC	??_C@_0BK@GMHFDBFE@TXT_KEY_NTFN_RA_FREE_TECH?$AA@ ; `string'
PUBLIC	??_C@_0DP@MNFCLGCG@TXT_KEY_NOTIFICATION_SUMMARY_DEA@ ; `string'
PUBLIC	??_C@_0DH@NNOJHBGJ@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@ ; `string'
PUBLIC	??_C@_0EB@DLDKBADL@TXT_KEY_NOTIFICATION_SUMMARY_DEA@ ; `string'
PUBLIC	??_C@_0DJ@EJNLAEFJ@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@ ; `string'
PUBLIC	??_C@_0DN@EJFNHMCN@TXT_KEY_NOTIFICATION_SUMMARY_DEA@ ; `string'
PUBLIC	??_C@_0DF@JPLHDFPD@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@ ; `string'
PUBLIC	??_C@_0DP@KDHPGGFB@TXT_KEY_NOTIFICATION_SUMMARY_DEA@ ; `string'
PUBLIC	??_C@_0DH@LDMEKBBO@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@ ; `string'
PUBLIC	??_C@_0DJ@BKHNKBP@TXT_KEY_NOTIFICATION_SUMMARY_DEA@ ; `string'
PUBLIC	??_C@_0DB@NOFPPICE@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@ ; `string'
PUBLIC	??_C@_0DL@HBLKHMAH@TXT_KEY_NOTIFICATION_SUMMARY_DEA@ ; `string'
PUBLIC	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
PUBLIC	??_C@_0DD@JIGIANCD@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@ ; `string'
PUBLIC	??_C@_0DE@IBECBHHD@TXT_KEY_NOTIFICATION_SUMMARY_DEA@ ; `string'
PUBLIC	??_C@_0CM@OKIAKCOL@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@ ; `string'
PUBLIC	??_C@_0DG@FNCHGGEE@TXT_KEY_NOTIFICATION_SUMMARY_DEA@ ; `string'
PUBLIC	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z	; GetLocalizedText<char const *>
PUBLIC	??_C@_0CO@FPLEEKJH@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?CancelVoteCommitmentsToPlayer@CvLeagueAI@@QAEXW4PlayerTypes@@@Z:PROC ; CvLeagueAI::CancelVoteCommitmentsToPlayer
EXTRN	?ChangeResearchProgress@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z:PROC ; CvTeamTechs::ChangeResearchProgress
EXTRN	?changeOverflowResearch@CvPlayer@@QAEXH@Z:PROC	; CvPlayer::changeOverflowResearch
EXTRN	?GetCurrentResearch@CvPlayerTechs@@QBE?AW4TechTypes@@XZ:PROC ; CvPlayerTechs::GetCurrentResearch
EXTRN	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ:PROC ; CvPlayer::GetPlayerTechs
EXTRN	?GetMedianTechPercentage@CvPlayer@@QBEHXZ:PROC	; CvPlayer::GetMedianTechPercentage
EXTRN	?GetResearchAgreementCounter@CvPlayer@@QBEHW4PlayerTypes@@@Z:PROC ; CvPlayer::GetResearchAgreementCounter
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	?getNameKey@CvPlayer@@QBEPBDXZ:PROC		; CvPlayer::getNameKey
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
;	COMDAT ??_C@_0DA@MCCNCAHM@TXT_KEY_NOTIFICATION_SUMMARY_DEA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0DA@MCCNCAHM@TXT_KEY_NOTIFICATION_SUMMARY_DEA@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_SUMMARY_DEAL_EXPIRED_PEACE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@IHJMECBC@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@
CONST	SEGMENT
??_C@_0CI@IHJMECBC@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_DEAL_EXPIRED_PEACE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@CJLLGEG@TXT_KEY_NOTIFICATION_SUMMARY_DEA@
CONST	SEGMENT
??_C@_0EA@CJLLGEG@TXT_KEY_NOTIFICATION_SUMMARY_DEA@ DB 'TXT_KEY_NOTIFICAT'
	DB	'ION_SUMMARY_DEAL_EXPIRED_TRADE_AGREEMENT_TO_US', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@OEOIFBIA@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@
CONST	SEGMENT
??_C@_0DI@OEOIFBIA@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_DEAL_EXPIRED_TRADE_AGREEMENT_TO_US', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@FOMHLEFF@TXT_KEY_NOTIFICATION_SUMMARY_DEA@
CONST	SEGMENT
??_C@_0EC@FOMHLEFF@TXT_KEY_NOTIFICATION_SUMMARY_DEA@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_SUMMARY_DEAL_EXPIRED_TRADE_AGREEMENT_FROM_US', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@PNAJFFDF@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@
CONST	SEGMENT
??_C@_0DK@PNAJFFDF@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_DEAL_EXPIRED_TRADE_AGREEMENT_FROM_US', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@MHNHHCAA@TXT_KEY_NTFN_RA_FREE_TECH_CANCEL@
CONST	SEGMENT
??_C@_0CD@MHNHHCAA@TXT_KEY_NTFN_RA_FREE_TECH_CANCEL@ DB 'TXT_KEY_NTFN_RA_'
	DB	'FREE_TECH_CANCEL_S', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@CBGADHDG@TXT_KEY_NTFN_RA_FREE_TECH_CANCEL@
CONST	SEGMENT
??_C@_0CB@CBGADHDG@TXT_KEY_NTFN_RA_FREE_TECH_CANCEL@ DB 'TXT_KEY_NTFN_RA_'
	DB	'FREE_TECH_CANCEL', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@OMALONMP@TXT_KEY_NTFN_RA_FREE_TECH_WAR_CA@
CONST	SEGMENT
??_C@_0CH@OMALONMP@TXT_KEY_NTFN_RA_FREE_TECH_WAR_CA@ DB 'TXT_KEY_NTFN_RA_'
	DB	'FREE_TECH_WAR_CANCEL_S', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DJIOHFOE@TXT_KEY_NTFN_RA_FREE_TECH_WAR_CA@
CONST	SEGMENT
??_C@_0CF@DJIOHFOE@TXT_KEY_NTFN_RA_FREE_TECH_WAR_CA@ DB 'TXT_KEY_NTFN_RA_'
	DB	'FREE_TECH_WAR_CANCEL', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@HJHPJDAF@TXT_KEY_NTFN_RA_FREE_TECH_S?$AA@
CONST	SEGMENT
??_C@_0BM@HJHPJDAF@TXT_KEY_NTFN_RA_FREE_TECH_S?$AA@ DB 'TXT_KEY_NTFN_RA_F'
	DB	'REE_TECH_S', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GMHFDBFE@TXT_KEY_NTFN_RA_FREE_TECH?$AA@
CONST	SEGMENT
??_C@_0BK@GMHFDBFE@TXT_KEY_NTFN_RA_FREE_TECH?$AA@ DB 'TXT_KEY_NTFN_RA_FRE'
	DB	'E_TECH', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@MNFCLGCG@TXT_KEY_NOTIFICATION_SUMMARY_DEA@
CONST	SEGMENT
??_C@_0DP@MNFCLGCG@TXT_KEY_NOTIFICATION_SUMMARY_DEA@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_SUMMARY_DEAL_EXPIRED_DEFENSIVE_PACT_TO_US', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@NNOJHBGJ@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@
CONST	SEGMENT
??_C@_0DH@NNOJHBGJ@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_DEAL_EXPIRED_DEFENSIVE_PACT_TO_US', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@DLDKBADL@TXT_KEY_NOTIFICATION_SUMMARY_DEA@
CONST	SEGMENT
??_C@_0EB@DLDKBADL@TXT_KEY_NOTIFICATION_SUMMARY_DEA@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_SUMMARY_DEAL_EXPIRED_DEFENSIVE_PACT_FROM_US', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@EJNLAEFJ@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@
CONST	SEGMENT
??_C@_0DJ@EJNLAEFJ@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_DEAL_EXPIRED_DEFENSIVE_PACT_FROM_US', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@EJFNHMCN@TXT_KEY_NOTIFICATION_SUMMARY_DEA@
CONST	SEGMENT
??_C@_0DN@EJFNHMCN@TXT_KEY_NOTIFICATION_SUMMARY_DEA@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_SUMMARY_DEAL_EXPIRED_OPEN_BORDERS_TO_US', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@JPLHDFPD@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@
CONST	SEGMENT
??_C@_0DF@JPLHDFPD@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_DEAL_EXPIRED_OPEN_BORDERS_TO_US', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@KDHPGGFB@TXT_KEY_NOTIFICATION_SUMMARY_DEA@
CONST	SEGMENT
??_C@_0DP@KDHPGGFB@TXT_KEY_NOTIFICATION_SUMMARY_DEA@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_SUMMARY_DEAL_EXPIRED_OPEN_BORDERS_FROM_US', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@LDMEKBBO@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@
CONST	SEGMENT
??_C@_0DH@LDMEKBBO@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_DEAL_EXPIRED_OPEN_BORDERS_FROM_US', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@BKHNKBP@TXT_KEY_NOTIFICATION_SUMMARY_DEA@
CONST	SEGMENT
??_C@_0DJ@BKHNKBP@TXT_KEY_NOTIFICATION_SUMMARY_DEA@ DB 'TXT_KEY_NOTIFICAT'
	DB	'ION_SUMMARY_DEAL_EXPIRED_RESOURCE_TO_US', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@NOFPPICE@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@
CONST	SEGMENT
??_C@_0DB@NOFPPICE@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_DEAL_EXPIRED_RESOURCE_TO_US', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@HBLKHMAH@TXT_KEY_NOTIFICATION_SUMMARY_DEA@
CONST	SEGMENT
??_C@_0DL@HBLKHMAH@TXT_KEY_NOTIFICATION_SUMMARY_DEA@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_SUMMARY_DEAL_EXPIRED_RESOURCE_FROM_US', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@JIGIANCD@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@
CONST	SEGMENT
??_C@_0DD@JIGIANCD@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_DEAL_EXPIRED_RESOURCE_FROM_US', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@IBECBHHD@TXT_KEY_NOTIFICATION_SUMMARY_DEA@
CONST	SEGMENT
??_C@_0DE@IBECBHHD@TXT_KEY_NOTIFICATION_SUMMARY_DEA@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_SUMMARY_DEAL_EXPIRED_GPT_TO_US', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@OKIAKCOL@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@
CONST	SEGMENT
??_C@_0CM@OKIAKCOL@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_DEAL_EXPIRED_GPT_TO_US', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@FNCHGGEE@TXT_KEY_NOTIFICATION_SUMMARY_DEA@
CONST	SEGMENT
??_C@_0DG@FNCHGGEE@TXT_KEY_NOTIFICATION_SUMMARY_DEA@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_SUMMARY_DEAL_EXPIRED_GPT_FROM_US', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@FPLEEKJH@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@
CONST	SEGMENT
??_C@_0CO@FPLEEKJH@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_DEAL_EXPIRED_GPT_FROM_US', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z DD 019930522H
	DD	022H
	DD	FLAT:__unwindtable$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$4
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$5
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$6
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$7
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$8
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$9
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$10
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$11
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$12
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$13
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$14
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$15
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$16
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$17
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$18
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$19
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$20
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$21
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$22
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$23
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$24
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$25
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$26
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$27
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$28
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$29
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$30
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$31
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$32
	DD	01H
	DD	FLAT:__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$33
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z
_TEXT	SEGMENT
tv1818 = -1420						; size = 4
tv1817 = -1416						; size = 4
tv1816 = -1412						; size = 4
tv1815 = -1408						; size = 4
tv1814 = -1404						; size = 4
tv1813 = -1400						; size = 4
tv1812 = -1396						; size = 4
tv1811 = -1392						; size = 4
tv1810 = -1388						; size = 4
tv1809 = -1384						; size = 4
tv1808 = -1380						; size = 4
tv1807 = -1376						; size = 4
tv1806 = -1372						; size = 4
tv1805 = -1368						; size = 4
tv1804 = -1364						; size = 4
tv1803 = -1360						; size = 4
tv1493 = -1356						; size = 4
tv1802 = -1352						; size = 4
tv1801 = -1348						; size = 4
tv1800 = -1344						; size = 4
tv1799 = -1340						; size = 4
tv1798 = -1336						; size = 4
tv1797 = -1332						; size = 4
tv1796 = -1328						; size = 4
tv1795 = -1324						; size = 4
tv1794 = -1320						; size = 4
tv1793 = -1316						; size = 4
tv1792 = -1312						; size = 4
tv1791 = -1308						; size = 4
tv267 = -1304						; size = 4
tv1790 = -1300						; size = 4
tv66 = -1296						; size = 4
tv1119 = -1292						; size = 4
tv1130 = -1288						; size = 4
_this$ = -1284						; size = 4
$T241791 = -1280					; size = 4
$T241783 = -1276					; size = 4
$T241775 = -1272					; size = 4
$T241768 = -1268					; size = 4
$T241760 = -1264					; size = 4
$T241752 = -1260					; size = 4
$T241748 = -1253					; size = 1
$T241739 = -1252					; size = 4
$T241735 = -1248					; size = 4
$T241722 = -1244					; size = 4
$T241714 = -1240					; size = 4
$T241706 = -1236					; size = 4
$T241696 = -1232					; size = 4
$T241688 = -1228					; size = 4
$T241680 = -1224					; size = 4
$T241673 = -1220					; size = 4
$T241665 = -1216					; size = 4
$T241657 = -1212					; size = 4
$T241647 = -1208					; size = 4
$T241639 = -1204					; size = 4
$T241631 = -1200					; size = 4
$T241623 = -1196					; size = 4
$T241615 = -1192					; size = 4
$T241611 = -1188					; size = 4
$T241604 = -1184					; size = 4
$T241596 = -1180					; size = 4
$T241588 = -1176					; size = 4
$T241584 = -1172					; size = 4
$T241578 = -1168					; size = 4
$T241568 = -1164					; size = 4
$T241559 = -1160					; size = 4
$T241549 = -1156					; size = 4
$T241541 = -1152					; size = 4
$T241533 = -1148					; size = 4
$T241526 = -1144					; size = 4
$T241518 = -1140					; size = 4
$T241510 = -1136					; size = 4
$T241500 = -1132					; size = 4
$T241492 = -1128					; size = 4
$T241484 = -1124					; size = 4
$T241477 = -1120					; size = 4
$T241469 = -1116					; size = 4
$T241461 = -1112					; size = 4
$T241451 = -1108					; size = 4
$T241443 = -1104					; size = 4
$T241435 = -1100					; size = 4
$T241428 = -1096					; size = 4
$T241420 = -1092					; size = 4
$T241412 = -1088					; size = 4
$T241402 = -1084					; size = 4
$T241394 = -1080					; size = 4
$T241386 = -1076					; size = 4
$T241379 = -1072					; size = 4
$T241371 = -1068					; size = 4
$T241363 = -1064					; size = 4
$T241359 = -1060					; size = 4
$T241283 = -1056					; size = 28
$T241282 = -1028					; size = 28
$T241281 = -1000					; size = 28
$T241280 = -972						; size = 28
$T241279 = -944						; size = 28
$T241278 = -916						; size = 28
$T241277 = -888						; size = 28
$T241276 = -860						; size = 28
$T241275 = -832						; size = 28
$T241274 = -804						; size = 28
$T241273 = -776						; size = 28
$T241272 = -748						; size = 28
$T241271 = -720						; size = 28
$T241270 = -692						; size = 28
$T241269 = -664						; size = 28
$T241268 = -636						; size = 28
$T241267 = -608						; size = 28
$T241266 = -580						; size = 28
$T241265 = -552						; size = 28
$T241264 = -524						; size = 28
$T241263 = -496						; size = 28
$T241262 = -468						; size = 28
$T241261 = -440						; size = 28
$T241260 = -412						; size = 28
$T241259 = -384						; size = 28
$T241258 = -356						; size = 4
$T241257 = -352						; size = 28
$T241256 = -324						; size = 4
$T241255 = -320						; size = 28
$T241254 = -292						; size = 4
$T241253 = -288						; size = 28
$T241252 = -260						; size = 4
$T241249 = -256						; size = 28
$T241248 = -228						; size = 28
$T241247 = -200						; size = 28
$T241246 = -172						; size = 28
_eTargetTeam$222787 = -144				; size = 4
_targetPlayer$222789 = -140				; size = 4
_iToPlayerBeakers$222738 = -136				; size = 4
_eCurrentTech$222746 = -132				; size = 4
_kTeam$222737 = -128					; size = 4
_iBeakersBonus$222740 = -124				; size = 4
_iFromPlayerBeakers$222739 = -120			; size = 4
_szResourceDescription$222688 = -116			; size = 4
_iResourceQuantity$222686 = -112			; size = 4
_eResource$222684 = -108				; size = 4
_pkResourceInfo$222687 = -104				; size = 4
_iGoldPerTurn$222666 = -100				; size = 4
_pNotifications$ = -96					; size = 4
_strBuffer$ = -92					; size = 28
_fromPlayer$ = -64					; size = 4
_eFromTeam$ = -60					; size = 4
_strSummary$ = -56					; size = 28
__$ArrayPad$ = -28					; size = 4
_eFromPlayer$ = -24					; size = 4
_eToTeam$ = -20						; size = 4
_toPlayer$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pItem$ = 8						; size = 4
_eToPlayer$ = 12					; size = 4
_bCancelled$ = 16					; size = 1
?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z PROC ; CvGameDeals::DoEndTradedItem, COMDAT
; _this$ = ecx

; 3215 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1408				; 00000580H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3216 : 	CvString strBuffer;

	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3217 : 	CvString strSummary;

	lea	ecx, DWORD PTR _strSummary$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 3218 : 
; 3219 : 	PlayerTypes eFromPlayer = pItem->m_eFromPlayer;

	mov	eax, DWORD PTR _pItem$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _eFromPlayer$[ebp], ecx

; 3220 : 
; 3221 : 	CvPlayerAI& fromPlayer = GET_PLAYER(eFromPlayer);

	mov	edx, DWORD PTR _eFromPlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _fromPlayer$[ebp], edx

; 3222 : 	CvPlayerAI& toPlayer = GET_PLAYER(eToPlayer);

	mov	eax, DWORD PTR _eToPlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _toPlayer$[ebp], eax

; 3223 : 
; 3224 : 	TeamTypes eFromTeam = fromPlayer.getTeam();

	mov	ecx, DWORD PTR _fromPlayer$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eFromTeam$[ebp], eax

; 3225 : 	TeamTypes eToTeam = toPlayer.getTeam();

	mov	eax, DWORD PTR _toPlayer$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eToTeam$[ebp], eax

; 3226 : 
; 3227 : 	CvNotifications* pNotifications = NULL;

	mov	DWORD PTR _pNotifications$[ebp], 0

; 3228 : 
; 3229 : 	pItem->m_bToRenewed = false; // if this item is properly ended, then don't have it marked with "to renew"

	mov	edx, DWORD PTR _pItem$[ebp]
	mov	BYTE PTR [edx+33], 0

; 3230 : 
; 3231 : 	if(pItem->m_bFromRenewed)

	mov	eax, DWORD PTR _pItem$[ebp]
	movzx	ecx, BYTE PTR [eax+32]
	test	ecx, ecx
	je	SHORT $LN40@DoEndTrade

; 3232 : 	{
; 3233 : 		return;

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strSummary$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	$LN41@DoEndTrade
$LN40@DoEndTrade:

; 3234 : 	}
; 3235 : 
; 3236 : 	// Gold Per Turn
; 3237 : 	if(pItem->m_eItemType == TRADE_ITEM_GOLD_PER_TURN)

	mov	edx, DWORD PTR _pItem$[ebp]
	cmp	DWORD PTR [edx], 1
	jne	$LN39@DoEndTrade

; 3238 : 	{
; 3239 : 		int iGoldPerTurn = pItem->m_iData1;

	mov	eax, DWORD PTR _pItem$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _iGoldPerTurn$222666[ebp], ecx

; 3240 : 		fromPlayer.GetTreasury()->ChangeGoldPerTurnFromDiplomacy(iGoldPerTurn);

	mov	edx, DWORD PTR _iGoldPerTurn$222666[ebp]
	push	edx
	mov	ecx, DWORD PTR _fromPlayer$[ebp]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeGoldPerTurnFromDiplomacy@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeGoldPerTurnFromDiplomacy

; 3241 : 		toPlayer.GetTreasury()->ChangeGoldPerTurnFromDiplomacy(-iGoldPerTurn);

	mov	eax, DWORD PTR _iGoldPerTurn$222666[ebp]
	neg	eax
	push	eax
	mov	ecx, DWORD PTR _toPlayer$[ebp]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeGoldPerTurnFromDiplomacy@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeGoldPerTurnFromDiplomacy

; 3242 : 
; 3243 : 		pNotifications = GET_PLAYER(eFromPlayer).GetNotifications();

	mov	ecx, DWORD PTR _eFromPlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T241359[ebp], ecx
	mov	ecx, DWORD PTR $T241359[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotifications$[ebp], eax

; 3244 : 		if(pNotifications)

	cmp	DWORD PTR _pNotifications$[ebp], 0
	je	$LN38@DoEndTrade

; 3245 : 		{
; 3246 : 			strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_DEAL_EXPIRED_GPT_FROM_US", toPlayer.getNameKey());

	mov	ecx, DWORD PTR _toPlayer$[ebp]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	push	OFFSET ??_C@_0CO@FPLEEKJH@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@
	lea	edx, DWORD PTR $T241246[ebp]
	push	edx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv1130[ebp], eax
	mov	eax, DWORD PTR tv1130[ebp]
	mov	DWORD PTR $T241363[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR $T241363[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T241246[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3247 : 			strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_DEAL_EXPIRED_GPT_FROM_US", toPlayer.getNameKey());

	mov	ecx, DWORD PTR _toPlayer$[ebp]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	push	OFFSET ??_C@_0DG@FNCHGGEE@TXT_KEY_NOTIFICATION_SUMMARY_DEA@
	lea	edx, DWORD PTR $T241247[ebp]
	push	edx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv1119[ebp], eax
	mov	eax, DWORD PTR tv1119[ebp]
	mov	DWORD PTR $T241371[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR $T241371[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strSummary$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T241247[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3248 : 			pNotifications->Add(NOTIFICATION_DEAL_EXPIRED_GPT, strBuffer, strSummary, -1, -1, -1);

	lea	ecx, DWORD PTR _strSummary$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T241379[ebp], eax
	push	-1
	push	-1
	push	-1
	push	-1
	mov	edx, DWORD PTR $T241379[ebp]
	push	edx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	-235108627				; f1fc86edH
	mov	ecx, DWORD PTR _pNotifications$[ebp]
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN38@DoEndTrade:

; 3249 : 		}
; 3250 : 
; 3251 : 		pNotifications = toPlayer.GetNotifications();

	mov	ecx, DWORD PTR _toPlayer$[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotifications$[ebp], eax

; 3252 : 		if(pNotifications)

	cmp	DWORD PTR _pNotifications$[ebp], 0
	je	$LN37@DoEndTrade

; 3253 : 		{
; 3254 : 			strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_DEAL_EXPIRED_GPT_TO_US", fromPlayer.getNameKey());

	mov	ecx, DWORD PTR _fromPlayer$[ebp]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	push	OFFSET ??_C@_0CM@OKIAKCOL@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@
	lea	eax, DWORD PTR $T241248[ebp]
	push	eax
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv66[ebp], eax
	mov	ecx, DWORD PTR tv66[ebp]
	mov	DWORD PTR $T241386[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	edx, DWORD PTR $T241386[ebp]
	push	edx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T241248[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3255 : 			strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_DEAL_EXPIRED_GPT_TO_US", fromPlayer.getNameKey());

	mov	ecx, DWORD PTR _fromPlayer$[ebp]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	push	OFFSET ??_C@_0DE@IBECBHHD@TXT_KEY_NOTIFICATION_SUMMARY_DEA@
	lea	eax, DWORD PTR $T241249[ebp]
	push	eax
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv1790[ebp], eax
	mov	ecx, DWORD PTR tv1790[ebp]
	mov	DWORD PTR $T241394[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	edx, DWORD PTR $T241394[ebp]
	push	edx
	lea	ecx, DWORD PTR _strSummary$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T241249[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3256 : 			pNotifications->Add(NOTIFICATION_DEAL_EXPIRED_GPT, strBuffer, strSummary, -1, -1, -1);

	lea	ecx, DWORD PTR _strSummary$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T241402[ebp], eax
	push	-1
	push	-1
	push	-1
	push	-1
	mov	eax, DWORD PTR $T241402[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	-235108627				; f1fc86edH
	mov	ecx, DWORD PTR _pNotifications$[ebp]
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN37@DoEndTrade:

; 3257 : 		}
; 3258 : 	}

	jmp	$LN36@DoEndTrade
$LN39@DoEndTrade:

; 3259 : 	// Resource
; 3260 : 	else if(pItem->m_eItemType == TRADE_ITEM_RESOURCES)

	mov	ecx, DWORD PTR _pItem$[ebp]
	cmp	DWORD PTR [ecx], 3
	jne	$LN35@DoEndTrade

; 3261 : 	{
; 3262 : 		ResourceTypes eResource = (ResourceTypes) pItem->m_iData1;

	mov	edx, DWORD PTR _pItem$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _eResource$222684[ebp], eax

; 3263 : 		int iResourceQuantity = pItem->m_iData2;

	mov	ecx, DWORD PTR _pItem$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _iResourceQuantity$222686[ebp], edx

; 3264 : 
; 3265 : 		fromPlayer.changeResourceExport(eResource, -iResourceQuantity);

	mov	eax, DWORD PTR _iResourceQuantity$222686[ebp]
	neg	eax
	push	eax
	mov	ecx, DWORD PTR _eResource$222684[ebp]
	push	ecx
	mov	ecx, DWORD PTR _fromPlayer$[ebp]
	call	?changeResourceExport@CvPlayer@@QAEXW4ResourceTypes@@H@Z ; CvPlayer::changeResourceExport

; 3266 : 		toPlayer.changeResourceImport(eResource, -iResourceQuantity);

	mov	edx, DWORD PTR _iResourceQuantity$222686[ebp]
	neg	edx
	push	edx
	mov	eax, DWORD PTR _eResource$222684[ebp]
	push	eax
	mov	ecx, DWORD PTR _toPlayer$[ebp]
	call	?changeResourceImport@CvPlayer@@QAEXW4ResourceTypes@@H@Z ; CvPlayer::changeResourceImport

; 3267 : 
; 3268 : 		CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);

	mov	ecx, DWORD PTR _eResource$222684[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	DWORD PTR _pkResourceInfo$222687[ebp], eax

; 3269 : 		const char* szResourceDescription = (pkResourceInfo)? pkResourceInfo->GetDescriptionKey() : "";

	cmp	DWORD PTR _pkResourceInfo$222687[ebp], 0
	je	SHORT $LN43@DoEndTrade
	mov	ecx, DWORD PTR _pkResourceInfo$222687[ebp]
	add	ecx, 64					; 00000040H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR tv267[ebp], eax
	jmp	SHORT $LN44@DoEndTrade
$LN43@DoEndTrade:
	mov	DWORD PTR tv267[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN44@DoEndTrade:
	mov	edx, DWORD PTR tv267[ebp]
	mov	DWORD PTR _szResourceDescription$222688[ebp], edx

; 3270 : 
; 3271 : 		pNotifications = fromPlayer.GetNotifications();

	mov	ecx, DWORD PTR _fromPlayer$[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotifications$[ebp], eax

; 3272 : 		if(pNotifications)

	cmp	DWORD PTR _pNotifications$[ebp], 0
	je	$LN34@DoEndTrade

; 3273 : 		{
; 3274 : 
; 3275 : 			strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_DEAL_EXPIRED_RESOURCE_FROM_US", toPlayer.getNameKey(), szResourceDescription);

	mov	ecx, DWORD PTR _toPlayer$[ebp]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	mov	DWORD PTR $T241252[ebp], eax
	lea	eax, DWORD PTR _szResourceDescription$222688[ebp]
	push	eax
	lea	ecx, DWORD PTR $T241252[ebp]
	push	ecx
	push	OFFSET ??_C@_0DD@JIGIANCD@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@
	lea	edx, DWORD PTR $T241253[ebp]
	push	edx
	call	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv1791[ebp], eax
	mov	eax, DWORD PTR tv1791[ebp]
	mov	DWORD PTR $T241412[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR $T241412[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T241253[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3276 : 			strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_DEAL_EXPIRED_RESOURCE_FROM_US", toPlayer.getNameKey(), szResourceDescription);

	mov	ecx, DWORD PTR _toPlayer$[ebp]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	mov	DWORD PTR $T241254[ebp], eax
	lea	edx, DWORD PTR _szResourceDescription$222688[ebp]
	push	edx
	lea	eax, DWORD PTR $T241254[ebp]
	push	eax
	push	OFFSET ??_C@_0DL@HBLKHMAH@TXT_KEY_NOTIFICATION_SUMMARY_DEA@
	lea	ecx, DWORD PTR $T241255[ebp]
	push	ecx
	call	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv1792[ebp], eax
	mov	edx, DWORD PTR tv1792[ebp]
	mov	DWORD PTR $T241420[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	eax, DWORD PTR $T241420[ebp]
	push	eax
	lea	ecx, DWORD PTR _strSummary$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T241255[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3277 : 			pNotifications->Add(NOTIFICATION_DEAL_EXPIRED_RESOURCE, strBuffer, strSummary, -1, -1, -1);

	lea	ecx, DWORD PTR _strSummary$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T241428[ebp], eax
	push	-1
	push	-1
	push	-1
	push	-1
	mov	ecx, DWORD PTR $T241428[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	555577168				; 211d6f50H
	mov	ecx, DWORD PTR _pNotifications$[ebp]
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN34@DoEndTrade:

; 3278 : 		}
; 3279 : 
; 3280 : 		pNotifications = toPlayer.GetNotifications();

	mov	ecx, DWORD PTR _toPlayer$[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotifications$[ebp], eax

; 3281 : 		if(pNotifications)

	cmp	DWORD PTR _pNotifications$[ebp], 0
	je	$LN33@DoEndTrade

; 3282 : 		{
; 3283 : 			strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_DEAL_EXPIRED_RESOURCE_TO_US", fromPlayer.getNameKey(), szResourceDescription);

	mov	ecx, DWORD PTR _fromPlayer$[ebp]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	mov	DWORD PTR $T241256[ebp], eax
	lea	edx, DWORD PTR _szResourceDescription$222688[ebp]
	push	edx
	lea	eax, DWORD PTR $T241256[ebp]
	push	eax
	push	OFFSET ??_C@_0DB@NOFPPICE@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@
	lea	ecx, DWORD PTR $T241257[ebp]
	push	ecx
	call	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv1793[ebp], eax
	mov	edx, DWORD PTR tv1793[ebp]
	mov	DWORD PTR $T241435[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	eax, DWORD PTR $T241435[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T241257[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3284 : 			strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_DEAL_EXPIRED_RESOURCE_TO_US", fromPlayer.getNameKey(), szResourceDescription);

	mov	ecx, DWORD PTR _fromPlayer$[ebp]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	mov	DWORD PTR $T241258[ebp], eax
	lea	ecx, DWORD PTR _szResourceDescription$222688[ebp]
	push	ecx
	lea	edx, DWORD PTR $T241258[ebp]
	push	edx
	push	OFFSET ??_C@_0DJ@BKHNKBP@TXT_KEY_NOTIFICATION_SUMMARY_DEA@
	lea	eax, DWORD PTR $T241259[ebp]
	push	eax
	call	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv1794[ebp], eax
	mov	ecx, DWORD PTR tv1794[ebp]
	mov	DWORD PTR $T241443[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	mov	edx, DWORD PTR $T241443[ebp]
	push	edx
	lea	ecx, DWORD PTR _strSummary$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T241259[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3285 : 			pNotifications->Add(NOTIFICATION_DEAL_EXPIRED_RESOURCE, strBuffer, strSummary, -1, -1, -1);

	lea	ecx, DWORD PTR _strSummary$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T241451[ebp], eax
	push	-1
	push	-1
	push	-1
	push	-1
	mov	eax, DWORD PTR $T241451[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	555577168				; 211d6f50H
	mov	ecx, DWORD PTR _pNotifications$[ebp]
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN33@DoEndTrade:

; 3286 : 		}
; 3287 : 	}

	jmp	$LN36@DoEndTrade
$LN35@DoEndTrade:

; 3288 : 	// Open Borders
; 3289 : 	else if(pItem->m_eItemType == TRADE_ITEM_OPEN_BORDERS)

	mov	ecx, DWORD PTR _pItem$[ebp]
	cmp	DWORD PTR [ecx], 6
	jne	$LN31@DoEndTrade

; 3290 : 	{
; 3291 : 		GET_TEAM(eFromTeam).SetAllowsOpenBordersToTeam(eToTeam, false);

	push	0
	mov	edx, DWORD PTR _eToTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _eFromTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?SetAllowsOpenBordersToTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetAllowsOpenBordersToTeam

; 3292 : 
; 3293 : 		pNotifications = fromPlayer.GetNotifications();

	mov	ecx, DWORD PTR _fromPlayer$[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotifications$[ebp], eax

; 3294 : 		if(pNotifications)

	cmp	DWORD PTR _pNotifications$[ebp], 0
	je	$LN30@DoEndTrade

; 3295 : 		{
; 3296 : 			strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_DEAL_EXPIRED_OPEN_BORDERS_FROM_US", toPlayer.getNameKey());

	mov	ecx, DWORD PTR _toPlayer$[ebp]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	push	OFFSET ??_C@_0DH@LDMEKBBO@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@
	lea	eax, DWORD PTR $T241260[ebp]
	push	eax
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv1795[ebp], eax
	mov	ecx, DWORD PTR tv1795[ebp]
	mov	DWORD PTR $T241461[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	edx, DWORD PTR $T241461[ebp]
	push	edx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T241260[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3297 : 			strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_DEAL_EXPIRED_OPEN_BORDERS_FROM_US", toPlayer.getNameKey());

	mov	ecx, DWORD PTR _toPlayer$[ebp]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	push	OFFSET ??_C@_0DP@KDHPGGFB@TXT_KEY_NOTIFICATION_SUMMARY_DEA@
	lea	eax, DWORD PTR $T241261[ebp]
	push	eax
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv1796[ebp], eax
	mov	ecx, DWORD PTR tv1796[ebp]
	mov	DWORD PTR $T241469[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	mov	edx, DWORD PTR $T241469[ebp]
	push	edx
	lea	ecx, DWORD PTR _strSummary$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T241261[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3298 : 			pNotifications->Add(NOTIFICATION_DEAL_EXPIRED_OPEN_BORDERS, strBuffer, strSummary, -1, -1, -1);

	lea	ecx, DWORD PTR _strSummary$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T241477[ebp], eax
	push	-1
	push	-1
	push	-1
	push	-1
	mov	eax, DWORD PTR $T241477[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	9054908					; 008a2abcH
	mov	ecx, DWORD PTR _pNotifications$[ebp]
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN30@DoEndTrade:

; 3299 : 		}
; 3300 : 
; 3301 : 		pNotifications = toPlayer.GetNotifications();

	mov	ecx, DWORD PTR _toPlayer$[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotifications$[ebp], eax

; 3302 : 		if(pNotifications)

	cmp	DWORD PTR _pNotifications$[ebp], 0
	je	$LN29@DoEndTrade

; 3303 : 		{
; 3304 : 			strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_DEAL_EXPIRED_OPEN_BORDERS_TO_US", fromPlayer.getNameKey());

	mov	ecx, DWORD PTR _fromPlayer$[ebp]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	push	OFFSET ??_C@_0DF@JPLHDFPD@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@
	lea	ecx, DWORD PTR $T241262[ebp]
	push	ecx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv1797[ebp], eax
	mov	edx, DWORD PTR tv1797[ebp]
	mov	DWORD PTR $T241484[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	mov	eax, DWORD PTR $T241484[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T241262[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3305 : 			strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_DEAL_EXPIRED_OPEN_BORDERS_TO_US", fromPlayer.getNameKey());

	mov	ecx, DWORD PTR _fromPlayer$[ebp]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	push	OFFSET ??_C@_0DN@EJFNHMCN@TXT_KEY_NOTIFICATION_SUMMARY_DEA@
	lea	ecx, DWORD PTR $T241263[ebp]
	push	ecx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv1798[ebp], eax
	mov	edx, DWORD PTR tv1798[ebp]
	mov	DWORD PTR $T241492[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH
	mov	eax, DWORD PTR $T241492[ebp]
	push	eax
	lea	ecx, DWORD PTR _strSummary$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T241263[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3306 : 			pNotifications->Add(NOTIFICATION_DEAL_EXPIRED_OPEN_BORDERS, strBuffer, strSummary, -1, -1, -1);

	lea	ecx, DWORD PTR _strSummary$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T241500[ebp], eax
	push	-1
	push	-1
	push	-1
	push	-1
	mov	ecx, DWORD PTR $T241500[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	9054908					; 008a2abcH
	mov	ecx, DWORD PTR _pNotifications$[ebp]
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN29@DoEndTrade:

; 3307 : 		}
; 3308 : 	}

	jmp	$LN36@DoEndTrade
$LN31@DoEndTrade:

; 3309 : 	// Defensive Pact
; 3310 : 	else if(pItem->m_eItemType == TRADE_ITEM_DEFENSIVE_PACT)

	mov	edx, DWORD PTR _pItem$[ebp]
	cmp	DWORD PTR [edx], 7
	jne	$LN27@DoEndTrade

; 3311 : 	{
; 3312 : 		GET_TEAM(eFromTeam).SetHasDefensivePact(eToTeam, false);

	push	0
	mov	eax, DWORD PTR _eToTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eFromTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasDefensivePact

; 3313 : 
; 3314 : 		pNotifications = fromPlayer.GetNotifications();

	mov	ecx, DWORD PTR _fromPlayer$[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotifications$[ebp], eax

; 3315 : 		if(pNotifications)

	cmp	DWORD PTR _pNotifications$[ebp], 0
	je	$LN26@DoEndTrade

; 3316 : 		{
; 3317 : 			strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_DEAL_EXPIRED_DEFENSIVE_PACT_FROM_US", toPlayer.getNameKey());

	mov	ecx, DWORD PTR _toPlayer$[ebp]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	push	OFFSET ??_C@_0DJ@EJNLAEFJ@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@
	lea	ecx, DWORD PTR $T241264[ebp]
	push	ecx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv1799[ebp], eax
	mov	edx, DWORD PTR tv1799[ebp]
	mov	DWORD PTR $T241510[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH
	mov	eax, DWORD PTR $T241510[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T241264[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3318 : 			strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_DEAL_EXPIRED_DEFENSIVE_PACT_FROM_US", toPlayer.getNameKey());

	mov	ecx, DWORD PTR _toPlayer$[ebp]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	push	OFFSET ??_C@_0EB@DLDKBADL@TXT_KEY_NOTIFICATION_SUMMARY_DEA@
	lea	ecx, DWORD PTR $T241265[ebp]
	push	ecx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv1800[ebp], eax
	mov	edx, DWORD PTR tv1800[ebp]
	mov	DWORD PTR $T241518[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 15		; 0000000fH
	mov	eax, DWORD PTR $T241518[ebp]
	push	eax
	lea	ecx, DWORD PTR _strSummary$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T241265[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3319 : 			pNotifications->Add(NOTIFICATION_DEAL_EXPIRED_DEFENSIVE_PACT, strBuffer, strSummary, -1, -1, -1);

	lea	ecx, DWORD PTR _strSummary$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T241526[ebp], eax
	push	-1
	push	-1
	push	-1
	push	-1
	mov	ecx, DWORD PTR $T241526[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	-2090424272				; 8366a830H
	mov	ecx, DWORD PTR _pNotifications$[ebp]
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN26@DoEndTrade:

; 3320 : 		}
; 3321 : 
; 3322 : 		pNotifications = toPlayer.GetNotifications();

	mov	ecx, DWORD PTR _toPlayer$[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotifications$[ebp], eax

; 3323 : 		if(pNotifications)

	cmp	DWORD PTR _pNotifications$[ebp], 0
	je	$LN25@DoEndTrade

; 3324 : 		{
; 3325 : 			strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_DEAL_EXPIRED_DEFENSIVE_PACT_TO_US", fromPlayer.getNameKey());

	mov	ecx, DWORD PTR _fromPlayer$[ebp]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	push	OFFSET ??_C@_0DH@NNOJHBGJ@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@
	lea	edx, DWORD PTR $T241266[ebp]
	push	edx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv1801[ebp], eax
	mov	eax, DWORD PTR tv1801[ebp]
	mov	DWORD PTR $T241533[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 16		; 00000010H
	mov	ecx, DWORD PTR $T241533[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T241266[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3326 : 			strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_DEAL_EXPIRED_DEFENSIVE_PACT_TO_US", fromPlayer.getNameKey());

	mov	ecx, DWORD PTR _fromPlayer$[ebp]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	push	OFFSET ??_C@_0DP@MNFCLGCG@TXT_KEY_NOTIFICATION_SUMMARY_DEA@
	lea	edx, DWORD PTR $T241267[ebp]
	push	edx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv1802[ebp], eax
	mov	eax, DWORD PTR tv1802[ebp]
	mov	DWORD PTR $T241541[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 17		; 00000011H
	mov	ecx, DWORD PTR $T241541[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strSummary$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T241267[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3327 : 			pNotifications->Add(NOTIFICATION_DEAL_EXPIRED_DEFENSIVE_PACT, strBuffer, strSummary, -1, -1, -1);

	lea	ecx, DWORD PTR _strSummary$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T241549[ebp], eax
	push	-1
	push	-1
	push	-1
	push	-1
	mov	edx, DWORD PTR $T241549[ebp]
	push	edx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	-2090424272				; 8366a830H
	mov	ecx, DWORD PTR _pNotifications$[ebp]
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN25@DoEndTrade:

; 3328 : 		}
; 3329 : 	}

	jmp	$LN36@DoEndTrade
$LN27@DoEndTrade:

; 3330 : 	// Research Agreement
; 3331 : 	else if(pItem->m_eItemType == TRADE_ITEM_RESEARCH_AGREEMENT)

	mov	eax, DWORD PTR _pItem$[ebp]
	cmp	DWORD PTR [eax], 8
	jne	$LN23@DoEndTrade

; 3332 : 	{
; 3333 : 		GET_TEAM(eFromTeam).SetHasResearchAgreement(eToTeam, false);

	push	0
	mov	ecx, DWORD PTR _eToTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _eFromTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?SetHasResearchAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasResearchAgreement

; 3334 : 
; 3335 : 		if(!GET_TEAM(eFromTeam).isAtWar(eToTeam) && !bCancelled)

	mov	edx, DWORD PTR _eFromTeam$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T241559[ebp], edx
	mov	eax, DWORD PTR _eToTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T241559[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN22@DoEndTrade
	movzx	edx, BYTE PTR _bCancelled$[ebp]
	test	edx, edx
	jne	$LN22@DoEndTrade

; 3336 : 		{
; 3337 : 			// Beaker boost = ((sum of both players' beakers over term of RA) / 2) / 3) * (median tech percentage rate)
; 3338 : #ifndef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 3339 : 			CvTeam& kTeam = GET_TEAM(toPlayer.getTeam());

	mov	eax, DWORD PTR _toPlayer$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T241568[ebp], eax
	mov	edx, DWORD PTR $T241568[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR _kTeam$222737[ebp], edx

; 3340 : #endif
; 3341 : 			int iToPlayerBeakers = toPlayer.GetResearchAgreementCounter(eFromPlayer);

	mov	eax, DWORD PTR _eFromPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _toPlayer$[ebp]
	call	?GetResearchAgreementCounter@CvPlayer@@QBEHW4PlayerTypes@@@Z ; CvPlayer::GetResearchAgreementCounter
	mov	DWORD PTR _iToPlayerBeakers$222738[ebp], eax

; 3342 : 			int iFromPlayerBeakers = fromPlayer.GetResearchAgreementCounter(eToPlayer);

	mov	ecx, DWORD PTR _eToPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _fromPlayer$[ebp]
	call	?GetResearchAgreementCounter@CvPlayer@@QBEHW4PlayerTypes@@@Z ; CvPlayer::GetResearchAgreementCounter
	mov	DWORD PTR _iFromPlayerBeakers$222739[ebp], eax

; 3343 : #ifdef AUI_DEAL_FIX_ACCURATE_EARLYGAME_RESEARCH_AGREEMENT_YIELDS
; 3344 : 			int iBeakersBonus = MIN(iToPlayerBeakers, iFromPlayerBeakers) * toPlayer.GetMedianTechPercentage();
; 3345 : 			iBeakersBonus /= 100 * GC.getRESEARCH_AGREEMENT_BOOST_DIVISOR();
; 3346 : #else
; 3347 : 			int iBeakersBonus = min(iToPlayerBeakers, iFromPlayerBeakers) / GC.getRESEARCH_AGREEMENT_BOOST_DIVISOR(); //one (third) of minimum contribution

	mov	edx, DWORD PTR _iFromPlayerBeakers$222739[ebp]
	cmp	edx, DWORD PTR _iToPlayerBeakers$222738[ebp]
	jge	SHORT $LN235@DoEndTrade
	lea	eax, DWORD PTR _iFromPlayerBeakers$222739[ebp]
	mov	DWORD PTR tv1493[ebp], eax
	jmp	SHORT $LN236@DoEndTrade
$LN235@DoEndTrade:
	lea	ecx, DWORD PTR _iToPlayerBeakers$222738[ebp]
	mov	DWORD PTR tv1493[ebp], ecx
$LN236@DoEndTrade:
	mov	edx, DWORD PTR tv1493[ebp]
	mov	DWORD PTR $T241578[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6824
	mov	DWORD PTR $T241584[ebp], eax
	mov	ecx, DWORD PTR $T241578[ebp]
	mov	eax, DWORD PTR [ecx]
	cdq
	idiv	DWORD PTR $T241584[ebp]
	mov	DWORD PTR _iBeakersBonus$222740[ebp], eax

; 3348 : 			iBeakersBonus = (iBeakersBonus * toPlayer.GetMedianTechPercentage()) / 100;

	mov	ecx, DWORD PTR _toPlayer$[ebp]
	call	?GetMedianTechPercentage@CvPlayer@@QBEHXZ ; CvPlayer::GetMedianTechPercentage
	imul	eax, DWORD PTR _iBeakersBonus$222740[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iBeakersBonus$222740[ebp], eax

; 3349 : #endif
; 3350 : 
; 3351 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 3352 : 			toPlayer.changeOverflowResearch(iBeakersBonus);
; 3353 : #else
; 3354 : 			TechTypes eCurrentTech = toPlayer.GetPlayerTechs()->GetCurrentResearch();

	mov	ecx, DWORD PTR _toPlayer$[ebp]
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?GetCurrentResearch@CvPlayerTechs@@QBE?AW4TechTypes@@XZ ; CvPlayerTechs::GetCurrentResearch
	mov	DWORD PTR _eCurrentTech$222746[ebp], eax

; 3355 : 			if(eCurrentTech == NO_TECH)

	cmp	DWORD PTR _eCurrentTech$222746[ebp], -1
	jne	SHORT $LN21@DoEndTrade

; 3356 : 			{
; 3357 : 				toPlayer.changeOverflowResearch(iBeakersBonus);

	mov	edx, DWORD PTR _iBeakersBonus$222740[ebp]
	push	edx
	mov	ecx, DWORD PTR _toPlayer$[ebp]
	call	?changeOverflowResearch@CvPlayer@@QAEXH@Z ; CvPlayer::changeOverflowResearch

; 3358 : 			}
; 3359 : 			else

	jmp	SHORT $LN20@DoEndTrade
$LN21@DoEndTrade:

; 3360 : 			{
; 3361 : 				kTeam.GetTeamTechs()->ChangeResearchProgress(eCurrentTech, iBeakersBonus, eToPlayer);

	mov	eax, DWORD PTR _eToPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iBeakersBonus$222740[ebp]
	push	ecx
	mov	edx, DWORD PTR _eCurrentTech$222746[ebp]
	push	edx
	mov	ecx, DWORD PTR _kTeam$222737[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?ChangeResearchProgress@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z ; CvTeamTechs::ChangeResearchProgress
$LN20@DoEndTrade:

; 3362 : 			}
; 3363 : #endif
; 3364 : 
; 3365 : 			pNotifications = toPlayer.GetNotifications();

	mov	ecx, DWORD PTR _toPlayer$[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotifications$[ebp], eax

; 3366 : 			if(pNotifications)

	cmp	DWORD PTR _pNotifications$[ebp], 0
	je	$LN19@DoEndTrade

; 3367 : 			{
; 3368 : 				strBuffer = GetLocalizedText("TXT_KEY_NTFN_RA_FREE_TECH", fromPlayer.getNameKey());

	mov	ecx, DWORD PTR _fromPlayer$[ebp]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	push	OFFSET ??_C@_0BK@GMHFDBFE@TXT_KEY_NTFN_RA_FREE_TECH?$AA@
	lea	eax, DWORD PTR $T241268[ebp]
	push	eax
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv1803[ebp], eax
	mov	ecx, DWORD PTR tv1803[ebp]
	mov	DWORD PTR $T241588[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 18		; 00000012H
	mov	edx, DWORD PTR $T241588[ebp]
	push	edx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T241268[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3369 : 				strSummary = GetLocalizedText("TXT_KEY_NTFN_RA_FREE_TECH_S", fromPlayer.getNameKey());

	mov	ecx, DWORD PTR _fromPlayer$[ebp]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	push	OFFSET ??_C@_0BM@HJHPJDAF@TXT_KEY_NTFN_RA_FREE_TECH_S?$AA@
	lea	eax, DWORD PTR $T241269[ebp]
	push	eax
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv1804[ebp], eax
	mov	ecx, DWORD PTR tv1804[ebp]
	mov	DWORD PTR $T241596[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 19		; 00000013H
	mov	edx, DWORD PTR $T241596[ebp]
	push	edx
	lea	ecx, DWORD PTR _strSummary$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T241269[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3370 : 				pNotifications->Add(NOTIFICATION_DEAL_EXPIRED_RESEARCH_AGREEMENT, strBuffer, strSummary, -1, -1, -1);

	lea	ecx, DWORD PTR _strSummary$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T241604[ebp], eax
	push	-1
	push	-1
	push	-1
	push	-1
	mov	eax, DWORD PTR $T241604[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	-1550921687				; a38ed029H
	mov	ecx, DWORD PTR _pNotifications$[ebp]
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN19@DoEndTrade:

; 3371 : 			}
; 3372 : 		}
; 3373 : 		else

	jmp	$LN18@DoEndTrade
$LN22@DoEndTrade:

; 3374 : 		{
; 3375 : 			pNotifications = toPlayer.GetNotifications();

	mov	ecx, DWORD PTR _toPlayer$[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotifications$[ebp], eax

; 3376 : 			if(pNotifications)

	cmp	DWORD PTR _pNotifications$[ebp], 0
	je	$LN18@DoEndTrade

; 3377 : 			{
; 3378 : 				if(GET_TEAM(eFromTeam).isAtWar(eToTeam))

	mov	ecx, DWORD PTR _eFromTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T241611[ebp], ecx
	mov	edx, DWORD PTR _eToTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T241611[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	eax, al
	test	eax, eax
	je	$LN16@DoEndTrade

; 3379 : 				{
; 3380 : 					strBuffer = GetLocalizedText("TXT_KEY_NTFN_RA_FREE_TECH_WAR_CANCEL", fromPlayer.getNameKey());

	mov	ecx, DWORD PTR _fromPlayer$[ebp]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	push	OFFSET ??_C@_0CF@DJIOHFOE@TXT_KEY_NTFN_RA_FREE_TECH_WAR_CA@
	lea	ecx, DWORD PTR $T241270[ebp]
	push	ecx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv1805[ebp], eax
	mov	edx, DWORD PTR tv1805[ebp]
	mov	DWORD PTR $T241615[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 20		; 00000014H
	mov	eax, DWORD PTR $T241615[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T241270[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3381 : 					strSummary = GetLocalizedText("TXT_KEY_NTFN_RA_FREE_TECH_WAR_CANCEL_S");

	push	OFFSET ??_C@_0CH@OMALONMP@TXT_KEY_NTFN_RA_FREE_TECH_WAR_CA@
	lea	ecx, DWORD PTR $T241271[ebp]
	push	ecx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	mov	DWORD PTR tv1806[ebp], eax
	mov	edx, DWORD PTR tv1806[ebp]
	mov	DWORD PTR $T241623[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 21		; 00000015H
	mov	eax, DWORD PTR $T241623[ebp]
	push	eax
	lea	ecx, DWORD PTR _strSummary$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T241271[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3382 : 				}
; 3383 : 				else

	jmp	$LN15@DoEndTrade
$LN16@DoEndTrade:

; 3384 : 				{
; 3385 : 					strBuffer = GetLocalizedText("TXT_KEY_NTFN_RA_FREE_TECH_CANCEL", fromPlayer.getNameKey());

	mov	ecx, DWORD PTR _fromPlayer$[ebp]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	push	OFFSET ??_C@_0CB@CBGADHDG@TXT_KEY_NTFN_RA_FREE_TECH_CANCEL@
	lea	ecx, DWORD PTR $T241272[ebp]
	push	ecx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv1807[ebp], eax
	mov	edx, DWORD PTR tv1807[ebp]
	mov	DWORD PTR $T241631[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 22		; 00000016H
	mov	eax, DWORD PTR $T241631[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T241272[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3386 : 					strSummary = GetLocalizedText("TXT_KEY_NTFN_RA_FREE_TECH_CANCEL_S");

	push	OFFSET ??_C@_0CD@MHNHHCAA@TXT_KEY_NTFN_RA_FREE_TECH_CANCEL@
	lea	ecx, DWORD PTR $T241273[ebp]
	push	ecx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	mov	DWORD PTR tv1808[ebp], eax
	mov	edx, DWORD PTR tv1808[ebp]
	mov	DWORD PTR $T241639[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 23		; 00000017H
	mov	eax, DWORD PTR $T241639[ebp]
	push	eax
	lea	ecx, DWORD PTR _strSummary$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T241273[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN15@DoEndTrade:

; 3387 : 				}
; 3388 : 
; 3389 : 				pNotifications->Add(NOTIFICATION_DEAL_EXPIRED_RESEARCH_AGREEMENT, strBuffer, strSummary, -1, -1, -1);

	lea	ecx, DWORD PTR _strSummary$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T241647[ebp], eax
	push	-1
	push	-1
	push	-1
	push	-1
	mov	ecx, DWORD PTR $T241647[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	-1550921687				; a38ed029H
	mov	ecx, DWORD PTR _pNotifications$[ebp]
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN18@DoEndTrade:

; 3390 : 			}
; 3391 : 		}

	jmp	$LN36@DoEndTrade
$LN23@DoEndTrade:

; 3392 : 	}
; 3393 : 	// Trade Agreement
; 3394 : 	else if(pItem->m_eItemType == TRADE_ITEM_TRADE_AGREEMENT)

	mov	edx, DWORD PTR _pItem$[ebp]
	cmp	DWORD PTR [edx], 9
	jne	$LN13@DoEndTrade

; 3395 : 	{
; 3396 : 		GET_TEAM(eFromTeam).SetHasTradeAgreement(eToTeam, false);

	push	0
	mov	eax, DWORD PTR _eToTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eFromTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?SetHasTradeAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasTradeAgreement

; 3397 : 
; 3398 : 		pNotifications = fromPlayer.GetNotifications();

	mov	ecx, DWORD PTR _fromPlayer$[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotifications$[ebp], eax

; 3399 : 		if(pNotifications)

	cmp	DWORD PTR _pNotifications$[ebp], 0
	je	$LN12@DoEndTrade

; 3400 : 		{
; 3401 : 			strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_DEAL_EXPIRED_TRADE_AGREEMENT_FROM_US", toPlayer.getNameKey());

	mov	ecx, DWORD PTR _toPlayer$[ebp]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	push	OFFSET ??_C@_0DK@PNAJFFDF@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@
	lea	ecx, DWORD PTR $T241274[ebp]
	push	ecx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv1809[ebp], eax
	mov	edx, DWORD PTR tv1809[ebp]
	mov	DWORD PTR $T241657[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 24		; 00000018H
	mov	eax, DWORD PTR $T241657[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T241274[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3402 : 			strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_DEAL_EXPIRED_TRADE_AGREEMENT_FROM_US", toPlayer.getNameKey());

	mov	ecx, DWORD PTR _toPlayer$[ebp]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	push	OFFSET ??_C@_0EC@FOMHLEFF@TXT_KEY_NOTIFICATION_SUMMARY_DEA@
	lea	ecx, DWORD PTR $T241275[ebp]
	push	ecx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv1810[ebp], eax
	mov	edx, DWORD PTR tv1810[ebp]
	mov	DWORD PTR $T241665[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 25		; 00000019H
	mov	eax, DWORD PTR $T241665[ebp]
	push	eax
	lea	ecx, DWORD PTR _strSummary$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T241275[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3403 : 			pNotifications->Add(NOTIFICATION_DEAL_EXPIRED_TRADE_AGREEMENT, strBuffer, strSummary, -1, -1, -1);

	lea	ecx, DWORD PTR _strSummary$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T241673[ebp], eax
	push	-1
	push	-1
	push	-1
	push	-1
	mov	ecx, DWORD PTR $T241673[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	-1895704892				; 8f01d6c4H
	mov	ecx, DWORD PTR _pNotifications$[ebp]
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN12@DoEndTrade:

; 3404 : 		}
; 3405 : 
; 3406 : 		pNotifications = toPlayer.GetNotifications();

	mov	ecx, DWORD PTR _toPlayer$[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotifications$[ebp], eax

; 3407 : 		if(pNotifications)

	cmp	DWORD PTR _pNotifications$[ebp], 0
	je	$LN11@DoEndTrade

; 3408 : 		{
; 3409 : 			strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_DEAL_EXPIRED_TRADE_AGREEMENT_TO_US", fromPlayer.getNameKey());

	mov	ecx, DWORD PTR _fromPlayer$[ebp]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	push	OFFSET ??_C@_0DI@OEOIFBIA@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@
	lea	edx, DWORD PTR $T241276[ebp]
	push	edx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv1811[ebp], eax
	mov	eax, DWORD PTR tv1811[ebp]
	mov	DWORD PTR $T241680[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 26		; 0000001aH
	mov	ecx, DWORD PTR $T241680[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T241276[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3410 : 			strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_DEAL_EXPIRED_TRADE_AGREEMENT_TO_US", fromPlayer.getNameKey());

	mov	ecx, DWORD PTR _fromPlayer$[ebp]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	push	OFFSET ??_C@_0EA@CJLLGEG@TXT_KEY_NOTIFICATION_SUMMARY_DEA@
	lea	edx, DWORD PTR $T241277[ebp]
	push	edx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv1812[ebp], eax
	mov	eax, DWORD PTR tv1812[ebp]
	mov	DWORD PTR $T241688[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 27		; 0000001bH
	mov	ecx, DWORD PTR $T241688[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strSummary$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T241277[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3411 : 			pNotifications->Add(NOTIFICATION_DEAL_EXPIRED_TRADE_AGREEMENT, strBuffer, strSummary, -1, -1, -1);

	lea	ecx, DWORD PTR _strSummary$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T241696[ebp], eax
	push	-1
	push	-1
	push	-1
	push	-1
	mov	edx, DWORD PTR $T241696[ebp]
	push	edx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	-1895704892				; 8f01d6c4H
	mov	ecx, DWORD PTR _pNotifications$[ebp]
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN11@DoEndTrade:

; 3412 : 		}
; 3413 : 	}

	jmp	$LN36@DoEndTrade
$LN13@DoEndTrade:

; 3414 : 	// Peace Treaty
; 3415 : 	else if(pItem->m_eItemType == TRADE_ITEM_PEACE_TREATY)

	mov	eax, DWORD PTR _pItem$[ebp]
	cmp	DWORD PTR [eax], 13			; 0000000dH
	jne	$LN9@DoEndTrade

; 3416 : 	{
; 3417 : 		GET_TEAM(eFromTeam).setForcePeace(eToTeam, false);

	push	0
	mov	ecx, DWORD PTR _eToTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _eFromTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?setForcePeace@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::setForcePeace

; 3418 : 
; 3419 : 		pNotifications = toPlayer.GetNotifications();

	mov	ecx, DWORD PTR _toPlayer$[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotifications$[ebp], eax

; 3420 : 		if(pNotifications)

	cmp	DWORD PTR _pNotifications$[ebp], 0
	je	$LN8@DoEndTrade

; 3421 : 		{
; 3422 : 			strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_DEAL_EXPIRED_PEACE", fromPlayer.getNameKey());

	mov	ecx, DWORD PTR _fromPlayer$[ebp]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	push	OFFSET ??_C@_0CI@IHJMECBC@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@
	lea	edx, DWORD PTR $T241278[ebp]
	push	edx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv1813[ebp], eax
	mov	eax, DWORD PTR tv1813[ebp]
	mov	DWORD PTR $T241706[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 28		; 0000001cH
	mov	ecx, DWORD PTR $T241706[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T241278[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3423 : 			strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_DEAL_EXPIRED_PEACE");

	push	OFFSET ??_C@_0DA@MCCNCAHM@TXT_KEY_NOTIFICATION_SUMMARY_DEA@
	lea	edx, DWORD PTR $T241279[ebp]
	push	edx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	mov	DWORD PTR tv1814[ebp], eax
	mov	eax, DWORD PTR tv1814[ebp]
	mov	DWORD PTR $T241714[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 29		; 0000001dH
	mov	ecx, DWORD PTR $T241714[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strSummary$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T241279[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3424 : 			pNotifications->Add(NOTIFICATION_DEAL_EXPIRED_TRADE_AGREEMENT, strBuffer, strSummary, -1, -1, -1);

	lea	ecx, DWORD PTR _strSummary$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T241722[ebp], eax
	push	-1
	push	-1
	push	-1
	push	-1
	mov	edx, DWORD PTR $T241722[ebp]
	push	edx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	-1895704892				; 8f01d6c4H
	mov	ecx, DWORD PTR _pNotifications$[ebp]
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN8@DoEndTrade:

; 3425 : 		}
; 3426 : 	}

	jmp	$LN36@DoEndTrade
$LN9@DoEndTrade:

; 3427 : 	// Third Party Peace Treaty
; 3428 : 	else if(pItem->m_eItemType == TRADE_ITEM_THIRD_PARTY_PEACE)

	mov	eax, DWORD PTR _pItem$[ebp]
	cmp	DWORD PTR [eax], 14			; 0000000eH
	jne	$LN6@DoEndTrade

; 3429 : 	{
; 3430 : 		TeamTypes eTargetTeam = (TeamTypes) pItem->m_iData1;

	mov	ecx, DWORD PTR _pItem$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _eTargetTeam$222787[ebp], edx

; 3431 : 		GET_TEAM(eFromTeam).setForcePeace(eTargetTeam, false);

	push	0
	mov	eax, DWORD PTR _eTargetTeam$222787[ebp]
	push	eax
	mov	ecx, DWORD PTR _eFromTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?setForcePeace@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::setForcePeace

; 3432 : 		GET_TEAM(eTargetTeam).setForcePeace(eFromTeam, false);

	push	0
	mov	ecx, DWORD PTR _eFromTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _eTargetTeam$222787[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?setForcePeace@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::setForcePeace

; 3433 : 
; 3434 : 		CvPlayer* targetPlayer = &GET_PLAYER(GET_TEAM(eTargetTeam).getLeaderID());

	mov	edx, DWORD PTR _eTargetTeam$222787[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T241735[ebp], edx
	mov	ecx, DWORD PTR $T241735[ebp]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	mov	DWORD PTR $T241739[ebp], eax
	mov	eax, DWORD PTR $T241739[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _targetPlayer$222789[ebp], eax

; 3435 : 
; 3436 : 		if (targetPlayer->isAlive())

	mov	ecx, DWORD PTR _targetPlayer$222789[ebp]
	mov	dl, BYTE PTR [ecx+2256]
	mov	BYTE PTR $T241748[ebp], dl
	movzx	eax, BYTE PTR $T241748[ebp]
	test	eax, eax
	je	$LN5@DoEndTrade

; 3437 : 		{
; 3438 : 			// Notification for FROM player
; 3439 : 			pNotifications = fromPlayer.GetNotifications();

	mov	ecx, DWORD PTR _fromPlayer$[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotifications$[ebp], eax

; 3440 : 			if(pNotifications)

	cmp	DWORD PTR _pNotifications$[ebp], 0
	je	$LN4@DoEndTrade

; 3441 : 			{
; 3442 : 				strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_DEAL_EXPIRED_PEACE", targetPlayer->getNameKey());

	mov	ecx, DWORD PTR _targetPlayer$222789[ebp]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	push	OFFSET ??_C@_0CI@IHJMECBC@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@
	lea	ecx, DWORD PTR $T241280[ebp]
	push	ecx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv1815[ebp], eax
	mov	edx, DWORD PTR tv1815[ebp]
	mov	DWORD PTR $T241752[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 30		; 0000001eH
	mov	eax, DWORD PTR $T241752[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T241280[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3443 : 				strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_DEAL_EXPIRED_PEACE");

	push	OFFSET ??_C@_0DA@MCCNCAHM@TXT_KEY_NOTIFICATION_SUMMARY_DEA@
	lea	ecx, DWORD PTR $T241281[ebp]
	push	ecx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	mov	DWORD PTR tv1816[ebp], eax
	mov	edx, DWORD PTR tv1816[ebp]
	mov	DWORD PTR $T241760[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 31		; 0000001fH
	mov	eax, DWORD PTR $T241760[ebp]
	push	eax
	lea	ecx, DWORD PTR _strSummary$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T241281[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3444 : 				pNotifications->Add(NOTIFICATION_DEAL_EXPIRED_TRADE_AGREEMENT, strBuffer, strSummary, -1, -1, -1);

	lea	ecx, DWORD PTR _strSummary$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T241768[ebp], eax
	push	-1
	push	-1
	push	-1
	push	-1
	mov	ecx, DWORD PTR $T241768[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	-1895704892				; 8f01d6c4H
	mov	ecx, DWORD PTR _pNotifications$[ebp]
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN4@DoEndTrade:

; 3445 : 			}
; 3446 : 
; 3447 : 			// Notification for TARGET player
; 3448 : 			pNotifications = targetPlayer->GetNotifications();

	mov	ecx, DWORD PTR _targetPlayer$222789[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotifications$[ebp], eax

; 3449 : 			if(pNotifications)

	cmp	DWORD PTR _pNotifications$[ebp], 0
	je	$LN5@DoEndTrade

; 3450 : 			{
; 3451 : 				strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_DEAL_EXPIRED_PEACE", fromPlayer.getNameKey());

	mov	ecx, DWORD PTR _fromPlayer$[ebp]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	push	OFFSET ??_C@_0CI@IHJMECBC@TXT_KEY_NOTIFICATION_DEAL_EXPIRE@
	lea	edx, DWORD PTR $T241282[ebp]
	push	edx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv1817[ebp], eax
	mov	eax, DWORD PTR tv1817[ebp]
	mov	DWORD PTR $T241775[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 32		; 00000020H
	mov	ecx, DWORD PTR $T241775[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T241282[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3452 : 				strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_DEAL_EXPIRED_PEACE");

	push	OFFSET ??_C@_0DA@MCCNCAHM@TXT_KEY_NOTIFICATION_SUMMARY_DEA@
	lea	edx, DWORD PTR $T241283[ebp]
	push	edx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	mov	DWORD PTR tv1818[ebp], eax
	mov	eax, DWORD PTR tv1818[ebp]
	mov	DWORD PTR $T241783[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 33		; 00000021H
	mov	ecx, DWORD PTR $T241783[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strSummary$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T241283[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3453 : 				pNotifications->Add(NOTIFICATION_DEAL_EXPIRED_TRADE_AGREEMENT, strBuffer, strSummary, -1, -1, -1);

	lea	ecx, DWORD PTR _strSummary$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T241791[ebp], eax
	push	-1
	push	-1
	push	-1
	push	-1
	mov	edx, DWORD PTR $T241791[ebp]
	push	edx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	-1895704892				; 8f01d6c4H
	mov	ecx, DWORD PTR _pNotifications$[ebp]
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN5@DoEndTrade:

; 3454 : 			}
; 3455 : 		}
; 3456 : 	}

	jmp	SHORT $LN36@DoEndTrade
$LN6@DoEndTrade:

; 3457 : 	// Vote Commitment
; 3458 : 	else if(pItem->m_eItemType == TRADE_ITEM_VOTE_COMMITMENT)

	mov	eax, DWORD PTR _pItem$[ebp]
	cmp	DWORD PTR [eax], 19			; 00000013H
	jne	SHORT $LN36@DoEndTrade

; 3459 : 	{
; 3460 : 		fromPlayer.GetLeagueAI()->CancelVoteCommitmentsToPlayer(eToPlayer);

	mov	ecx, DWORD PTR _eToPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _fromPlayer$[ebp]
	call	?GetLeagueAI@CvPlayer@@QBEPAVCvLeagueAI@@XZ ; CvPlayer::GetLeagueAI
	mov	ecx, eax
	call	?CancelVoteCommitmentsToPlayer@CvLeagueAI@@QAEXW4PlayerTypes@@@Z ; CvLeagueAI::CancelVoteCommitmentsToPlayer

; 3461 : #ifndef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 3462 : 		toPlayer.GetLeagueAI()->CancelVoteCommitmentsToPlayer(eFromPlayer);

	mov	edx, DWORD PTR _eFromPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _toPlayer$[ebp]
	call	?GetLeagueAI@CvPlayer@@QBEPAVCvLeagueAI@@XZ ; CvPlayer::GetLeagueAI
	mov	ecx, eax
	call	?CancelVoteCommitmentsToPlayer@CvLeagueAI@@QAEXW4PlayerTypes@@@Z ; CvLeagueAI::CancelVoteCommitmentsToPlayer
$LN36@DoEndTrade:

; 3463 : #endif
; 3464 : 	}
; 3465 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strSummary$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN41@DoEndTrade:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$0:
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$1:
	lea	ecx, DWORD PTR _strSummary$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$2:
	lea	ecx, DWORD PTR $T241246[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$3:
	lea	ecx, DWORD PTR $T241247[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$4:
	lea	ecx, DWORD PTR $T241248[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$5:
	lea	ecx, DWORD PTR $T241249[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$6:
	lea	ecx, DWORD PTR $T241253[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$7:
	lea	ecx, DWORD PTR $T241255[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$8:
	lea	ecx, DWORD PTR $T241257[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$9:
	lea	ecx, DWORD PTR $T241259[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$10:
	lea	ecx, DWORD PTR $T241260[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$11:
	lea	ecx, DWORD PTR $T241261[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$12:
	lea	ecx, DWORD PTR $T241262[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$13:
	lea	ecx, DWORD PTR $T241263[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$14:
	lea	ecx, DWORD PTR $T241264[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$15:
	lea	ecx, DWORD PTR $T241265[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$16:
	lea	ecx, DWORD PTR $T241266[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$17:
	lea	ecx, DWORD PTR $T241267[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$18:
	lea	ecx, DWORD PTR $T241268[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$19:
	lea	ecx, DWORD PTR $T241269[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$20:
	lea	ecx, DWORD PTR $T241270[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$21:
	lea	ecx, DWORD PTR $T241271[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$22:
	lea	ecx, DWORD PTR $T241272[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$23:
	lea	ecx, DWORD PTR $T241273[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$24:
	lea	ecx, DWORD PTR $T241274[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$25:
	lea	ecx, DWORD PTR $T241275[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$26:
	lea	ecx, DWORD PTR $T241276[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$27:
	lea	ecx, DWORD PTR $T241277[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$28:
	lea	ecx, DWORD PTR $T241278[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$29:
	lea	ecx, DWORD PTR $T241279[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$30:
	lea	ecx, DWORD PTR $T241280[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$31:
	lea	ecx, DWORD PTR $T241281[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$32:
	lea	ecx, DWORD PTR $T241282[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z$33:
	lea	ecx, DWORD PTR $T241283[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1412]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoEndTradedItem@CvGameDeals@@QAEXPAUCvTradedItem@@W4PlayerTypes@@_N@Z ENDP ; CvGameDeals::DoEndTradedItem
PUBLIC	__$ArrayPad$
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z:PROC
EXTRN	__imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z:PROC
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?GetLocalizedText@@YA?AVCvString@@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$1
__ehfuncinfo$?GetLocalizedText@@YA?AVCvString@@PBD@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ?GetLocalizedText@@YA?AVCvString@@PBD@Z
_TEXT	SEGMENT
$T241815 = -140						; size = 4
_str$ = -136						; size = 28
__$ArrayPad$ = -108					; size = 4
_bytes$ = -104						; size = 4
_text$ = -100						; size = 80
_szComposedString$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
?GetLocalizedText@@YA?AVCvString@@PBD@Z PROC		; GetLocalizedText, COMDAT

; 489  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 128				; 00000080H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T241815[ebp], 0

; 490  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[ebp]
	push	eax
	lea	ecx, DWORD PTR _text$[ebp]
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 491  : 
; 492  : 	size_t bytes = 0;

	mov	DWORD PTR _bytes$[ebp], 0

; 493  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	edx, DWORD PTR _bytes$[ebp]
	push	edx
	lea	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z
	mov	DWORD PTR _szComposedString$[ebp], eax

; 494  : 	CvString str;

	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 495  : 	str.assign(szComposedString, bytes);

	mov	eax, DWORD PTR _bytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szComposedString$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z

; 496  : 	return str;

	lea	edx, DWORD PTR _str$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T241815[ebp]
	or	eax, 1
	mov	DWORD PTR $T241815[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 497  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$1:
	lea	ecx, DWORD PTR _str$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$2:
	mov	eax, DWORD PTR $T241815[ebp]
	and	eax, 1
	je	$LN6@GetLocaliz
	and	DWORD PTR $T241815[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN6@GetLocaliz:
	ret	0
__ehhandler$?GetLocalizedText@@YA?AVCvString@@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-132]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetLocalizedText@@YA?AVCvString@@PBD@Z ENDP		; GetLocalizedText
EXTRN	?GetResearchAgreementCost@CvGame@@QAEHW4PlayerTypes@@0@Z:PROC ; CvGame::GetResearchAgreementCost
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
;	COMDAT ?GetTradeItemGoldCost@CvGameDeals@@QBEHW4TradeableItems@@W4PlayerTypes@@1@Z
_TEXT	SEGMENT
tv64 = -16						; size = 4
_this$ = -12						; size = 4
$T241840 = -8						; size = 4
_iGoldCost$ = -4					; size = 4
_eItem$ = 8						; size = 4
_ePlayer1$ = 12						; size = 4
_ePlayer2$ = 16						; size = 4
?GetTradeItemGoldCost@CvGameDeals@@QBEHW4TradeableItems@@W4PlayerTypes@@1@Z PROC ; CvGameDeals::GetTradeItemGoldCost, COMDAT
; _this$ = ecx

; 3469 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 3470 : 	int iGoldCost = 0;

	mov	DWORD PTR _iGoldCost$[ebp], 0

; 3471 : 
; 3472 : 	switch(eItem)

	mov	eax, DWORD PTR _eItem$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 8
	je	SHORT $LN2@GetTradeIt
	cmp	DWORD PTR tv64[ebp], 9
	je	SHORT $LN1@GetTradeIt
	jmp	SHORT $LN3@GetTradeIt
$LN2@GetTradeIt:

; 3473 : 	{
; 3474 : 	case TRADE_ITEM_RESEARCH_AGREEMENT:
; 3475 : 	{
; 3476 : 		iGoldCost = GC.getGame().GetResearchAgreementCost(ePlayer1, ePlayer2);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T241840[ebp], ecx
	mov	edx, DWORD PTR _ePlayer2$[ebp]
	push	edx
	mov	eax, DWORD PTR _ePlayer1$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T241840[ebp]
	call	?GetResearchAgreementCost@CvGame@@QAEHW4PlayerTypes@@0@Z ; CvGame::GetResearchAgreementCost
	mov	DWORD PTR _iGoldCost$[ebp], eax

; 3477 : 		break;

	jmp	SHORT $LN3@GetTradeIt
$LN1@GetTradeIt:

; 3478 : 	}
; 3479 : 	case TRADE_ITEM_TRADE_AGREEMENT:
; 3480 : 		iGoldCost = 250;

	mov	DWORD PTR _iGoldCost$[ebp], 250		; 000000faH
$LN3@GetTradeIt:

; 3481 : 		break;
; 3482 : 	}
; 3483 : 
; 3484 : 	return iGoldCost;

	mov	eax, DWORD PTR _iGoldCost$[ebp]

; 3485 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetTradeItemGoldCost@CvGameDeals@@QBEHW4TradeableItems@@W4PlayerTypes@@1@Z ENDP ; CvGameDeals::GetTradeItemGoldCost
_TEXT	ENDS
PUBLIC	?PrepareRenewDeal@CvGameDeals@@SAXPAVCvDeal@@PBV2@@Z ; CvGameDeals::PrepareRenewDeal
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
xdata$x	SEGMENT
__unwindtable$?PrepareRenewDeal@CvGameDeals@@SAXPAVCvDeal@@PBV2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PrepareRenewDeal@CvGameDeals@@SAXPAVCvDeal@@PBV2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?PrepareRenewDeal@CvGameDeals@@SAXPAVCvDeal@@PBV2@@Z$3
__ehfuncinfo$?PrepareRenewDeal@CvGameDeals@@SAXPAVCvDeal@@PBV2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?PrepareRenewDeal@CvGameDeals@@SAXPAVCvDeal@@PBV2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?PrepareRenewDeal@CvGameDeals@@SAXPAVCvDeal@@PBV2@@Z
_TEXT	SEGMENT
tv315 = -248						; size = 4
tv310 = -244						; size = 4
$T242621 = -240						; size = 4
$T242589 = -236						; size = 4
$T242557 = -232						; size = 4
$T242525 = -228						; size = 4
$T242493 = -224						; size = 4
$T242461 = -220						; size = 4
$T242429 = -216						; size = 4
$T242397 = -212						; size = 4
$T242391 = -208						; size = 4
$T242364 = -204						; size = 4
$T242332 = -200						; size = 4
$T242326 = -196						; size = 4
$T242299 = -192						; size = 4
$T242267 = -188						; size = 4
$T242235 = -184						; size = 4
$T242229 = -180						; size = 4
$T242202 = -176						; size = 4
$T242170 = -172						; size = 4
$T242138 = -168						; size = 4
$T242132 = -164						; size = 4
$T242105 = -160						; size = 4
$T242073 = -156						; size = 4
$T242067 = -152						; size = 4
$T242040 = -148						; size = 4
$T242034 = -144						; size = 4
$T242013 = -140						; size = 4
$T241997 = -136						; size = 4
$T241993 = -132						; size = 4
$T241984 = -128						; size = 4
$T241936 = -124						; size = 4
$T241915 = -120						; size = 4
$T241899 = -116						; size = 4
$T241895 = -112						; size = 4
$T241886 = -108						; size = 4
$T241848 = -104						; size = 8
$T241847 = -93						; size = 1
$T241846 = -92						; size = 8
$T241845 = -84						; size = 8
$T241844 = -73						; size = 1
$T241843 = -72						; size = 8
_iGoldPerTurnDelta$222851 = -64				; size = 4
_iNewGPTAmount$222849 = -60				; size = 4
_iOldGPTAmount$222848 = -56				; size = 4
_iResourceDelta$222844 = -52				; size = 4
_eResource$222841 = -48					; size = 4
_eItemType$222838 = -44					; size = 4
_newDealItemIter$222828 = -40				; size = 8
_fromPlayer$ = -32					; size = 4
_pNonConstNewDeal$ = -28				; size = 4
_toPlayer$ = -24					; size = 4
_oldDealItemIter$ = -20					; size = 8
__$EHRec$ = -12						; size = 12
_pOldDeal$ = 8						; size = 4
_pNewDeal$ = 12						; size = 4
?PrepareRenewDeal@CvGameDeals@@SAXPAVCvDeal@@PBV2@@Z PROC ; CvGameDeals::PrepareRenewDeal, COMDAT

; 3489 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PrepareRenewDeal@CvGameDeals@@SAXPAVCvDeal@@PBV2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 236				; 000000ecH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 3490 : 	// Cancel individual items
; 3491 : 	// HACK HACK HACK
; 3492 : 	// bad slewis! bad! bad!!
; 3493 : 	CvDeal* pNonConstNewDeal = (CvDeal*)pNewDeal;

	mov	eax, DWORD PTR _pNewDeal$[ebp]
	mov	DWORD PTR _pNonConstNewDeal$[ebp], eax

; 3494 : 	// end HACK HACK HACK
; 3495 : 
; 3496 : 	CvAssertMsg(pOldDeal->m_eFromPlayer == pNewDeal->m_eFromPlayer, "Deal is not to the same from players");
; 3497 : 	CvAssertMsg(pOldDeal->m_eToPlayer == pNewDeal->m_eToPlayer, "Deal is not to the same to players");
; 3498 : 
; 3499 : 	CvPlayerAI& fromPlayer = GET_PLAYER(pOldDeal->m_eFromPlayer);

	mov	ecx, DWORD PTR _pOldDeal$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _fromPlayer$[ebp], edx

; 3500 : 	CvPlayerAI& toPlayer = GET_PLAYER(pOldDeal->m_eToPlayer);

	mov	eax, DWORD PTR _pOldDeal$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _toPlayer$[ebp], ecx

; 3501 : 
; 3502 : 	TradedItemList::iterator oldDealItemIter;

	lea	ecx, DWORD PTR _oldDealItemIter$[ebp]
	call	??0iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::iterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3503 : 	for(oldDealItemIter = pOldDeal->m_TradedItems.begin(); oldDealItemIter != pOldDeal->m_TradedItems.end(); ++oldDealItemIter)

	lea	edx, DWORD PTR $T241843[ebp]
	push	edx
	mov	ecx, DWORD PTR _pOldDeal$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv310[ebp], eax
	mov	eax, DWORD PTR tv310[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _oldDealItemIter$[ebp], ecx
	mov	DWORD PTR _oldDealItemIter$[ebp+4], edx
	jmp	SHORT $LN19@PrepareRen
$LN18@PrepareRen:
	cmp	DWORD PTR _oldDealItemIter$[ebp+4], 268435455 ; 0fffffffH
	jne	SHORT $LN44@PrepareRen
	mov	eax, DWORD PTR _oldDealItemIter$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _oldDealItemIter$[ebp+4], ecx
	jmp	SHORT $LN19@PrepareRen
$LN44@PrepareRen:
	mov	edx, DWORD PTR _oldDealItemIter$[ebp]
	mov	DWORD PTR $T241886[ebp], edx
	mov	eax, DWORD PTR _oldDealItemIter$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T241886[ebp]
	add	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR $T241895[ebp], eax
	mov	edx, DWORD PTR $T241895[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T241899[ebp], eax
	mov	ecx, DWORD PTR $T241899[ebp]
	mov	DWORD PTR _oldDealItemIter$[ebp+4], ecx
$LN19@PrepareRen:
	lea	edx, DWORD PTR $T241845[ebp]
	push	edx
	mov	ecx, DWORD PTR _pOldDeal$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T241915[ebp], eax
	mov	eax, DWORD PTR $T241915[ebp]
	mov	ecx, DWORD PTR _oldDealItemIter$[ebp+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setne	dl
	mov	BYTE PTR $T241844[ebp], dl
	movzx	eax, BYTE PTR $T241844[ebp]
	test	eax, eax
	je	$LN17@PrepareRen

; 3504 : 	{
; 3505 : 		// if this is not a renewable item, ignore
; 3506 : 		if(CvDeal::GetItemTradeableState(oldDealItemIter->m_eItemType) != CvDeal::DEAL_RENEWABLE)

	lea	ecx, DWORD PTR _oldDealItemIter$[ebp]
	call	??Diterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::operator*
	add	eax, 8
	mov	DWORD PTR $T241936[ebp], eax
	mov	ecx, DWORD PTR $T241936[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?GetItemTradeableState@CvDeal@@SA?AW4DealRenewStatus@1@W4TradeableItems@@@Z ; CvDeal::GetItemTradeableState
	add	esp, 4
	test	eax, eax
	je	SHORT $LN16@PrepareRen

; 3507 : 		{
; 3508 : 			continue;

	jmp	$LN18@PrepareRen
$LN16@PrepareRen:

; 3509 : 		}
; 3510 : 
; 3511 : 		TradedItemList::iterator newDealItemIter;

	mov	DWORD PTR _newDealItemIter$222828[ebp], 0
	mov	DWORD PTR _newDealItemIter$222828[ebp+4], 268435455 ; 0fffffffH
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 3512 : 		for(newDealItemIter = pNonConstNewDeal->m_TradedItems.begin(); newDealItemIter != pNonConstNewDeal->m_TradedItems.end(); ++newDealItemIter)

	lea	eax, DWORD PTR $T241846[ebp]
	push	eax
	mov	ecx, DWORD PTR _pNonConstNewDeal$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv315[ebp], eax
	mov	ecx, DWORD PTR tv315[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _newDealItemIter$222828[ebp], edx
	mov	DWORD PTR _newDealItemIter$222828[ebp+4], eax
	jmp	SHORT $LN15@PrepareRen
$LN14@PrepareRen:
	cmp	DWORD PTR _newDealItemIter$222828[ebp+4], 268435455 ; 0fffffffH
	jne	SHORT $LN86@PrepareRen
	mov	ecx, DWORD PTR _newDealItemIter$222828[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _newDealItemIter$222828[ebp+4], edx
	jmp	SHORT $LN15@PrepareRen
$LN86@PrepareRen:
	mov	eax, DWORD PTR _newDealItemIter$222828[ebp]
	mov	DWORD PTR $T241984[ebp], eax
	mov	ecx, DWORD PTR _newDealItemIter$222828[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T241984[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T241993[ebp], ecx
	mov	eax, DWORD PTR $T241993[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T241997[ebp], ecx
	mov	edx, DWORD PTR $T241997[ebp]
	mov	DWORD PTR _newDealItemIter$222828[ebp+4], edx
$LN15@PrepareRen:
	lea	eax, DWORD PTR $T241848[ebp]
	push	eax
	mov	ecx, DWORD PTR _pNonConstNewDeal$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T242013[ebp], eax
	mov	ecx, DWORD PTR $T242013[ebp]
	mov	edx, DWORD PTR _newDealItemIter$222828[ebp+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setne	al
	mov	BYTE PTR $T241847[ebp], al
	movzx	ecx, BYTE PTR $T241847[ebp]
	test	ecx, ecx
	je	$LN13@PrepareRen

; 3513 : 		{
; 3514 : 			// if this is not a renewable item, ignore
; 3515 : 			if(CvDeal::GetItemTradeableState(newDealItemIter->m_eItemType) != CvDeal::DEAL_RENEWABLE)

	lea	ecx, DWORD PTR _newDealItemIter$222828[ebp]
	call	??Diterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::operator*
	add	eax, 8
	mov	DWORD PTR $T242034[ebp], eax
	mov	edx, DWORD PTR $T242034[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	?GetItemTradeableState@CvDeal@@SA?AW4DealRenewStatus@1@W4TradeableItems@@@Z ; CvDeal::GetItemTradeableState
	add	esp, 4
	test	eax, eax
	je	SHORT $LN12@PrepareRen

; 3516 : 			{
; 3517 : 				continue;

	jmp	$LN14@PrepareRen
$LN12@PrepareRen:

; 3518 : 			}
; 3519 : 
; 3520 : 			// if the from player doesn't match, ignore
; 3521 : 			if(oldDealItemIter->m_eFromPlayer != newDealItemIter->m_eFromPlayer)

	mov	ecx, DWORD PTR _oldDealItemIter$[ebp]
	mov	DWORD PTR $T242040[ebp], ecx
	mov	edx, DWORD PTR _oldDealItemIter$[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T242040[ebp]
	mov	ecx, DWORD PTR [eax+8]
	lea	edx, DWORD PTR [ecx+edx+8]
	mov	DWORD PTR $T242067[ebp], edx
	mov	eax, DWORD PTR _newDealItemIter$222828[ebp]
	mov	DWORD PTR $T242073[ebp], eax
	mov	ecx, DWORD PTR _newDealItemIter$222828[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T242073[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR $T242067[ebp]
	mov	edx, DWORD PTR [edx+28]
	cmp	edx, DWORD PTR [eax+ecx+36]
	je	SHORT $LN11@PrepareRen

; 3522 : 			{
; 3523 : 				continue;

	jmp	$LN14@PrepareRen
$LN11@PrepareRen:

; 3524 : 			}
; 3525 : 
; 3526 : 			// if the item types don't match, ignore
; 3527 : 			if(oldDealItemIter->m_eItemType != newDealItemIter->m_eItemType)

	mov	eax, DWORD PTR _oldDealItemIter$[ebp]
	mov	DWORD PTR $T242105[ebp], eax
	mov	ecx, DWORD PTR _oldDealItemIter$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T242105[ebp]
	mov	eax, DWORD PTR [edx+8]
	lea	ecx, DWORD PTR [eax+ecx+8]
	mov	DWORD PTR $T242132[ebp], ecx
	mov	edx, DWORD PTR _newDealItemIter$222828[ebp]
	mov	DWORD PTR $T242138[ebp], edx
	mov	eax, DWORD PTR _newDealItemIter$222828[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T242138[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR $T242132[ebp]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [edx+eax+8]
	je	SHORT $LN10@PrepareRen

; 3528 : 			{
; 3529 : 				continue;

	jmp	$LN14@PrepareRen
$LN10@PrepareRen:

; 3530 : 			}
; 3531 : 
; 3532 : 			TradeableItems eItemType = oldDealItemIter->m_eItemType;

	mov	edx, DWORD PTR _oldDealItemIter$[ebp]
	mov	DWORD PTR $T242170[ebp], edx
	mov	eax, DWORD PTR _oldDealItemIter$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T242170[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+eax+8]
	mov	DWORD PTR _eItemType$222838[ebp], eax

; 3533 : 
; 3534 : 			if(eItemType == TRADE_ITEM_RESOURCES)

	cmp	DWORD PTR _eItemType$222838[ebp], 3
	jne	$LN9@PrepareRen

; 3535 : 			{
; 3536 : 				// resource type
; 3537 : 				if(oldDealItemIter->m_iData1 != newDealItemIter->m_iData1)

	mov	ecx, DWORD PTR _oldDealItemIter$[ebp]
	mov	DWORD PTR $T242202[ebp], ecx
	mov	edx, DWORD PTR _oldDealItemIter$[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T242202[ebp]
	mov	ecx, DWORD PTR [eax+8]
	lea	edx, DWORD PTR [ecx+edx+8]
	mov	DWORD PTR $T242229[ebp], edx
	mov	eax, DWORD PTR _newDealItemIter$222828[ebp]
	mov	DWORD PTR $T242235[ebp], eax
	mov	ecx, DWORD PTR _newDealItemIter$222828[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T242235[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR $T242229[ebp]
	mov	edx, DWORD PTR [edx+12]
	cmp	edx, DWORD PTR [eax+ecx+20]
	je	SHORT $LN8@PrepareRen

; 3538 : 				{
; 3539 : 					continue;

	jmp	$LN14@PrepareRen
$LN8@PrepareRen:

; 3540 : 				}
; 3541 : 
; 3542 : 				ResourceTypes eResource = (ResourceTypes)oldDealItemIter->m_iData1;

	mov	eax, DWORD PTR _oldDealItemIter$[ebp]
	mov	DWORD PTR $T242267[ebp], eax
	mov	ecx, DWORD PTR _oldDealItemIter$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T242267[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+ecx+20]
	mov	DWORD PTR _eResource$222841[ebp], ecx

; 3543 : 
; 3544 : 				// quantity
; 3545 : 				if(oldDealItemIter->m_iData2 != newDealItemIter->m_iData2)

	mov	edx, DWORD PTR _oldDealItemIter$[ebp]
	mov	DWORD PTR $T242299[ebp], edx
	mov	eax, DWORD PTR _oldDealItemIter$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T242299[ebp]
	mov	edx, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [edx+eax+8]
	mov	DWORD PTR $T242326[ebp], eax
	mov	ecx, DWORD PTR _newDealItemIter$222828[ebp]
	mov	DWORD PTR $T242332[ebp], ecx
	mov	edx, DWORD PTR _newDealItemIter$222828[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T242332[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR $T242326[ebp]
	mov	eax, DWORD PTR [eax+16]
	cmp	eax, DWORD PTR [ecx+edx+24]
	je	$LN9@PrepareRen

; 3546 : 				{
; 3547 : 					int iResourceDelta = newDealItemIter->m_iData2 - oldDealItemIter->m_iData2;

	mov	ecx, DWORD PTR _newDealItemIter$222828[ebp]
	mov	DWORD PTR $T242364[ebp], ecx
	mov	edx, DWORD PTR _newDealItemIter$222828[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T242364[ebp]
	mov	ecx, DWORD PTR [eax+8]
	lea	edx, DWORD PTR [ecx+edx+8]
	mov	DWORD PTR $T242391[ebp], edx
	mov	eax, DWORD PTR _oldDealItemIter$[ebp]
	mov	DWORD PTR $T242397[ebp], eax
	mov	ecx, DWORD PTR _oldDealItemIter$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T242397[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR $T242391[ebp]
	mov	edx, DWORD PTR [edx+16]
	sub	edx, DWORD PTR [eax+ecx+24]
	mov	DWORD PTR _iResourceDelta$222844[ebp], edx

; 3548 : 					if(oldDealItemIter->m_eFromPlayer == pOldDeal->m_eFromPlayer)

	mov	eax, DWORD PTR _oldDealItemIter$[ebp]
	mov	DWORD PTR $T242429[ebp], eax
	mov	ecx, DWORD PTR _oldDealItemIter$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T242429[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _pOldDeal$[ebp]
	mov	eax, DWORD PTR [eax+ecx+36]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN6@PrepareRen

; 3549 : 					{
; 3550 : 						fromPlayer.changeResourceExport(eResource, iResourceDelta);

	mov	ecx, DWORD PTR _iResourceDelta$222844[ebp]
	push	ecx
	mov	edx, DWORD PTR _eResource$222841[ebp]
	push	edx
	mov	ecx, DWORD PTR _fromPlayer$[ebp]
	call	?changeResourceExport@CvPlayer@@QAEXW4ResourceTypes@@H@Z ; CvPlayer::changeResourceExport

; 3551 : 						toPlayer.changeResourceImport(eResource, iResourceDelta);

	mov	eax, DWORD PTR _iResourceDelta$222844[ebp]
	push	eax
	mov	ecx, DWORD PTR _eResource$222841[ebp]
	push	ecx
	mov	ecx, DWORD PTR _toPlayer$[ebp]
	call	?changeResourceImport@CvPlayer@@QAEXW4ResourceTypes@@H@Z ; CvPlayer::changeResourceImport

; 3552 : 					}
; 3553 : 					else

	jmp	SHORT $LN9@PrepareRen
$LN6@PrepareRen:

; 3554 : 					{
; 3555 : 						toPlayer.changeResourceExport(eResource, iResourceDelta);

	mov	edx, DWORD PTR _iResourceDelta$222844[ebp]
	push	edx
	mov	eax, DWORD PTR _eResource$222841[ebp]
	push	eax
	mov	ecx, DWORD PTR _toPlayer$[ebp]
	call	?changeResourceExport@CvPlayer@@QAEXW4ResourceTypes@@H@Z ; CvPlayer::changeResourceExport

; 3556 : 						fromPlayer.changeResourceImport(eResource, iResourceDelta);

	mov	ecx, DWORD PTR _iResourceDelta$222844[ebp]
	push	ecx
	mov	edx, DWORD PTR _eResource$222841[ebp]
	push	edx
	mov	ecx, DWORD PTR _fromPlayer$[ebp]
	call	?changeResourceImport@CvPlayer@@QAEXW4ResourceTypes@@H@Z ; CvPlayer::changeResourceImport
$LN9@PrepareRen:

; 3557 : 					}
; 3558 : 				}
; 3559 : 			}
; 3560 : 
; 3561 : 			if(oldDealItemIter->m_eItemType == TRADE_ITEM_GOLD_PER_TURN)

	mov	eax, DWORD PTR _oldDealItemIter$[ebp]
	mov	DWORD PTR $T242461[ebp], eax
	mov	ecx, DWORD PTR _oldDealItemIter$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T242461[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	DWORD PTR [eax+ecx+8], 1
	jne	$LN4@PrepareRen

; 3562 : 			{
; 3563 : 				int iOldGPTAmount = oldDealItemIter->m_iData1;

	mov	ecx, DWORD PTR _oldDealItemIter$[ebp]
	mov	DWORD PTR $T242493[ebp], ecx
	mov	edx, DWORD PTR _oldDealItemIter$[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T242493[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+edx+20]
	mov	DWORD PTR _iOldGPTAmount$222848[ebp], edx

; 3564 : 				int iNewGPTAmount = newDealItemIter->m_iData1;

	mov	eax, DWORD PTR _newDealItemIter$222828[ebp]
	mov	DWORD PTR $T242525[ebp], eax
	mov	ecx, DWORD PTR _newDealItemIter$222828[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T242525[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+ecx+20]
	mov	DWORD PTR _iNewGPTAmount$222849[ebp], ecx

; 3565 : 
; 3566 : 				// has the amount of gold amount changed?
; 3567 : 				if(iOldGPTAmount != iNewGPTAmount)

	mov	edx, DWORD PTR _iOldGPTAmount$222848[ebp]
	cmp	edx, DWORD PTR _iNewGPTAmount$222849[ebp]
	je	SHORT $LN4@PrepareRen

; 3568 : 				{
; 3569 : 					int iGoldPerTurnDelta = iNewGPTAmount - iOldGPTAmount;

	mov	eax, DWORD PTR _iNewGPTAmount$222849[ebp]
	sub	eax, DWORD PTR _iOldGPTAmount$222848[ebp]
	mov	DWORD PTR _iGoldPerTurnDelta$222851[ebp], eax

; 3570 : 					if(oldDealItemIter->m_eFromPlayer == pOldDeal->m_eFromPlayer)

	mov	ecx, DWORD PTR _oldDealItemIter$[ebp]
	mov	DWORD PTR $T242557[ebp], ecx
	mov	edx, DWORD PTR _oldDealItemIter$[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T242557[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR _pOldDeal$[ebp]
	mov	ecx, DWORD PTR [ecx+edx+36]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN2@PrepareRen

; 3571 : 					{
; 3572 : 						fromPlayer.GetTreasury()->ChangeGoldPerTurnFromDiplomacy(-iGoldPerTurnDelta);

	mov	edx, DWORD PTR _iGoldPerTurnDelta$222851[ebp]
	neg	edx
	push	edx
	mov	ecx, DWORD PTR _fromPlayer$[ebp]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeGoldPerTurnFromDiplomacy@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeGoldPerTurnFromDiplomacy

; 3573 : 						toPlayer.GetTreasury()->ChangeGoldPerTurnFromDiplomacy(iGoldPerTurnDelta);

	mov	eax, DWORD PTR _iGoldPerTurnDelta$222851[ebp]
	push	eax
	mov	ecx, DWORD PTR _toPlayer$[ebp]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeGoldPerTurnFromDiplomacy@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeGoldPerTurnFromDiplomacy

; 3574 : 					}
; 3575 : 					else

	jmp	SHORT $LN4@PrepareRen
$LN2@PrepareRen:

; 3576 : 					{
; 3577 : 						toPlayer.GetTreasury()->ChangeGoldPerTurnFromDiplomacy(-iGoldPerTurnDelta);

	mov	ecx, DWORD PTR _iGoldPerTurnDelta$222851[ebp]
	neg	ecx
	push	ecx
	mov	ecx, DWORD PTR _toPlayer$[ebp]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeGoldPerTurnFromDiplomacy@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeGoldPerTurnFromDiplomacy

; 3578 : 						fromPlayer.GetTreasury()->ChangeGoldPerTurnFromDiplomacy(iGoldPerTurnDelta);

	mov	edx, DWORD PTR _iGoldPerTurnDelta$222851[ebp]
	push	edx
	mov	ecx, DWORD PTR _fromPlayer$[ebp]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeGoldPerTurnFromDiplomacy@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeGoldPerTurnFromDiplomacy
$LN4@PrepareRen:

; 3579 : 					}
; 3580 : 				}
; 3581 : 			}
; 3582 : 
; 3583 : 			// mark the deals as appropriately renewed
; 3584 : 			newDealItemIter->m_bToRenewed = true;

	mov	eax, DWORD PTR _newDealItemIter$222828[ebp]
	mov	DWORD PTR $T242589[ebp], eax
	mov	ecx, DWORD PTR _newDealItemIter$222828[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T242589[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	BYTE PTR [eax+ecx+41], 1

; 3585 : 			oldDealItemIter->m_bFromRenewed = true;

	mov	ecx, DWORD PTR _oldDealItemIter$[ebp]
	mov	DWORD PTR $T242621[ebp], ecx
	mov	edx, DWORD PTR _oldDealItemIter$[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T242621[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	BYTE PTR [ecx+edx+40], 1

; 3586 : 
; 3587 : 			// break because we found the match and can continue on
; 3588 : 			break;

	jmp	SHORT $LN13@PrepareRen

; 3589 : 		}

	jmp	$LN14@PrepareRen
$LN13@PrepareRen:

; 3590 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	jmp	$LN18@PrepareRen
$LN17@PrepareRen:

; 3591 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PrepareRenewDeal@CvGameDeals@@SAXPAVCvDeal@@PBV2@@Z$0:
	lea	ecx, DWORD PTR _oldDealItemIter$[ebp]
	jmp	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
__unwindfunclet$?PrepareRenewDeal@CvGameDeals@@SAXPAVCvDeal@@PBV2@@Z$3:
	lea	ecx, DWORD PTR _newDealItemIter$222828[ebp]
	jmp	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
__ehhandler$?PrepareRenewDeal@CvGameDeals@@SAXPAVCvDeal@@PBV2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-240]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?PrepareRenewDeal@CvGameDeals@@SAXPAVCvDeal@@PBV2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?PrepareRenewDeal@CvGameDeals@@SAXPAVCvDeal@@PBV2@@Z ENDP ; CvGameDeals::PrepareRenewDeal
PUBLIC	??_C@_0BN@MFPCJCIM@?$CK?$CK?$CK?$CK?$CK?5UNKNOWN?5TRADE?$CB?$CB?$CB?5?$CK?$CK?$CK?$CK?$CK?$AA@ ; `string'
PUBLIC	??_C@_0CO@MGPLHFAL@?$CK?$CK?$CK?$CK?$CK?5Vote?5Commitment?3?5ID?5?$CFd?0?5Ch@ ; `string'
PUBLIC	??_C@_0CC@NPAIHELI@?$CK?$CK?$CK?$CK?$CK?5Third?5Party?5War?5Trade?5?$CK?$CK?$CK?$CK@ ; `string'
PUBLIC	??_C@_0CE@OMBEOCFK@?$CK?$CK?$CK?$CK?$CK?5Third?5Party?5Peace?5Trade?5?$CK?$CK@ ; `string'
PUBLIC	??_C@_0BP@GJNHHCDL@?$CK?$CK?$CK?$CK?$CK?5Peace?5Treaty?5Trade?5?$CK?$CK?$CK?$CK?$CK?$AA@ ; `string'
PUBLIC	??_C@_0BJ@CNPHKDPC@Research?5Agreement?5Trade?$AA@ ; `string'
PUBLIC	??_C@_0CB@HJDILAIL@?$CK?$CK?$CK?$CK?$CK?5Defensive?5Pact?5Trade?5?$CK?$CK?$CK?$CK?$CK@ ; `string'
PUBLIC	??_C@_0BD@JBFHPOFG@Open?5Borders?5Trade?$AA@	; `string'
PUBLIC	??_C@_0CB@EIPFEACI@?$CK?$CK?$CK?$CK?$CK?5City?5Trade?3?5ID?5?$CFd?5?$CFd?5?$CK?$CK?$CK?$CK?$CK@ ; `string'
PUBLIC	??_C@_0CC@NCDFBFMH@?$CK?$CK?$CK?$CK?$CK?5Resource?5Trade?3?5ID?5?$CFd?5?$CK?$CK?$CK?$CK@ ; `string'
PUBLIC	??_C@_0BK@IJBKIFCE@?$CK?$CK?$CK?$CK?$CK?5GPT?5Trade?3?5?$CFd?5?$CK?$CK?$CK?$CK?$CK?$AA@ ; `string'
PUBLIC	??_C@_0BL@CDOPOBBO@?$CK?$CK?$CK?$CK?$CK?5Gold?5Trade?3?5?$CFd?5?$CK?$CK?$CK?$CK?$CK?$AA@ ; `string'
PUBLIC	??_C@_0BF@BALNBIM@?5has?5made?5a?5request?$CB?$AA@ ; `string'
PUBLIC	??_C@_0BE@MOMNMKPE@?5has?5made?5a?5demand?$CB?$AA@ ; `string'
PUBLIC	??_C@_0P@HNMIHOOB@?0?5White?5Peace?$CB?$AA@	; `string'
PUBLIC	??_C@_0P@OFLNONA@?5is?5giving?5up?$CB?$AA@	; `string'
PUBLIC	??_C@_0BN@GIPAALKO@XXX?5NO?5VALID?5PEACE?5TREATY?$CB?$CB?$CB?$AA@ ; `string'
PUBLIC	??_C@_0CE@JOPDMDJI@?$CK?$CK?$CK?$CK?$CK?5UNCONDITIONAL?5SURRENDER?5?$CK?$CK@ ; `string'
PUBLIC	??_C@_0BJ@JKMJDBGK@?$CK?$CK?$CK?$CK?$CK?5CAPITULATION?5?$CK?$CK?$CK?$CK?$CK?$AA@ ; `string'
PUBLIC	??_C@_0BE@MBMCANPB@?$CK?$CK?$CK?$CK?$CK?5CESSION?5?$CK?$CK?$CK?$CK?$CK?$AA@ ; `string'
PUBLIC	??_C@_0BG@NFOMOILH@?$CK?$CK?$CK?$CK?$CK?5SURRENDER?5?$CK?$CK?$CK?$CK?$CK?$AA@ ; `string'
PUBLIC	??_C@_0BH@OHJNDNPE@?$CK?$CK?$CK?$CK?$CK?5SUBMISSION?5?$CK?$CK?$CK?$CK?$CK?$AA@ ; `string'
PUBLIC	??_C@_0BF@BBLCPBGO@?$CK?$CK?$CK?$CK?$CK?5BACKDOWN?5?$CK?$CK?$CK?$CK?$CK?$AA@ ; `string'
PUBLIC	??_C@_0BH@ENHAEGBH@?$CK?$CK?$CK?$CK?$CK?5SETTLEMENT?5?$CK?$CK?$CK?$CK?$CK?$AA@ ; `string'
PUBLIC	??_C@_0BG@BDGEHDOI@?$CK?$CK?$CK?$CK?$CK?5ARMISTICE?5?$CK?$CK?$CK?$CK?$CK?$AA@ ; `string'
PUBLIC	??_C@_0BI@DAGCMOMB@?$CK?$CK?$CK?$CK?$CK?5WHITE?5PEACE?5?$CK?$CK?$CK?$CK?$CK?$AA@ ; `string'
PUBLIC	??_C@_04DJANPOPP@?0?5?0?5?$AA@			; `string'
PUBLIC	??_C@_02KEGNLNML@?0?5?$AA@			; `string'
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
PUBLIC	??_C@_06NHKAIDD@?$CF03d?0?5?$AA@		; `string'
PUBLIC	??_C@_0BN@NEDAAMNI@DiplomacyAI_Messages_Log?4csv?$AA@ ; `string'
PUBLIC	??_C@_04EBGNMJBD@?4csv?$AA@			; `string'
PUBLIC	??_C@_0BK@GIOCJFHA@DiplomacyAI_Messages_Log_?$AA@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	?getElapsedGameTurns@CvGame@@QBEHXZ:PROC	; CvGame::getElapsedGameTurns
EXTRN	?GetInstance@FILogFileMgr@@SAAAV1@XZ:PROC	; FILogFileMgr::GetInstance
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z:PROC
EXTRN	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ:PROC ; CvGlobals::getPlayerAndCityAILogSplit
EXTRN	?getAILogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getAILogging
EXTRN	?getLogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getLogging
;	COMDAT ??_C@_0BN@MFPCJCIM@?$CK?$CK?$CK?$CK?$CK?5UNKNOWN?5TRADE?$CB?$CB?$CB?5?$CK?$CK?$CK?$CK?$CK?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BN@MFPCJCIM@?$CK?$CK?$CK?$CK?$CK?5UNKNOWN?5TRADE?$CB?$CB?$CB?5?$CK?$CK?$CK?$CK?$CK?$AA@ DB '*'
	DB	'**** UNKNOWN TRADE!!! *****', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@MGPLHFAL@?$CK?$CK?$CK?$CK?$CK?5Vote?5Commitment?3?5ID?5?$CFd?0?5Ch@
CONST	SEGMENT
??_C@_0CO@MGPLHFAL@?$CK?$CK?$CK?$CK?$CK?5Vote?5Commitment?3?5ID?5?$CFd?0?5Ch@ DB '*'
	DB	'**** Vote Commitment: ID %d, Choice %d *****', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@NPAIHELI@?$CK?$CK?$CK?$CK?$CK?5Third?5Party?5War?5Trade?5?$CK?$CK?$CK?$CK@
CONST	SEGMENT
??_C@_0CC@NPAIHELI@?$CK?$CK?$CK?$CK?$CK?5Third?5Party?5War?5Trade?5?$CK?$CK?$CK?$CK@ DB '*'
	DB	'**** Third Party War Trade *****', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@OMBEOCFK@?$CK?$CK?$CK?$CK?$CK?5Third?5Party?5Peace?5Trade?5?$CK?$CK@
CONST	SEGMENT
??_C@_0CE@OMBEOCFK@?$CK?$CK?$CK?$CK?$CK?5Third?5Party?5Peace?5Trade?5?$CK?$CK@ DB '*'
	DB	'**** Third Party Peace Trade *****', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@GJNHHCDL@?$CK?$CK?$CK?$CK?$CK?5Peace?5Treaty?5Trade?5?$CK?$CK?$CK?$CK?$CK?$AA@
CONST	SEGMENT
??_C@_0BP@GJNHHCDL@?$CK?$CK?$CK?$CK?$CK?5Peace?5Treaty?5Trade?5?$CK?$CK?$CK?$CK?$CK?$AA@ DB '*'
	DB	'**** Peace Treaty Trade *****', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CNPHKDPC@Research?5Agreement?5Trade?$AA@
CONST	SEGMENT
??_C@_0BJ@CNPHKDPC@Research?5Agreement?5Trade?$AA@ DB 'Research Agreement'
	DB	' Trade', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@HJDILAIL@?$CK?$CK?$CK?$CK?$CK?5Defensive?5Pact?5Trade?5?$CK?$CK?$CK?$CK?$CK@
CONST	SEGMENT
??_C@_0CB@HJDILAIL@?$CK?$CK?$CK?$CK?$CK?5Defensive?5Pact?5Trade?5?$CK?$CK?$CK?$CK?$CK@ DB '*'
	DB	'**** Defensive Pact Trade *****', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JBFHPOFG@Open?5Borders?5Trade?$AA@
CONST	SEGMENT
??_C@_0BD@JBFHPOFG@Open?5Borders?5Trade?$AA@ DB 'Open Borders Trade', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@EIPFEACI@?$CK?$CK?$CK?$CK?$CK?5City?5Trade?3?5ID?5?$CFd?5?$CFd?5?$CK?$CK?$CK?$CK?$CK@
CONST	SEGMENT
??_C@_0CB@EIPFEACI@?$CK?$CK?$CK?$CK?$CK?5City?5Trade?3?5ID?5?$CFd?5?$CFd?5?$CK?$CK?$CK?$CK?$CK@ DB '*'
	DB	'**** City Trade: ID %d %d *****', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@NCDFBFMH@?$CK?$CK?$CK?$CK?$CK?5Resource?5Trade?3?5ID?5?$CFd?5?$CK?$CK?$CK?$CK@
CONST	SEGMENT
??_C@_0CC@NCDFBFMH@?$CK?$CK?$CK?$CK?$CK?5Resource?5Trade?3?5ID?5?$CFd?5?$CK?$CK?$CK?$CK@ DB '*'
	DB	'**** Resource Trade: ID %d *****', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@IJBKIFCE@?$CK?$CK?$CK?$CK?$CK?5GPT?5Trade?3?5?$CFd?5?$CK?$CK?$CK?$CK?$CK?$AA@
CONST	SEGMENT
??_C@_0BK@IJBKIFCE@?$CK?$CK?$CK?$CK?$CK?5GPT?5Trade?3?5?$CFd?5?$CK?$CK?$CK?$CK?$CK?$AA@ DB '*'
	DB	'**** GPT Trade: %d *****', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@CDOPOBBO@?$CK?$CK?$CK?$CK?$CK?5Gold?5Trade?3?5?$CFd?5?$CK?$CK?$CK?$CK?$CK?$AA@
CONST	SEGMENT
??_C@_0BL@CDOPOBBO@?$CK?$CK?$CK?$CK?$CK?5Gold?5Trade?3?5?$CFd?5?$CK?$CK?$CK?$CK?$CK?$AA@ DB '*'
	DB	'**** Gold Trade: %d *****', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BALNBIM@?5has?5made?5a?5request?$CB?$AA@
CONST	SEGMENT
??_C@_0BF@BALNBIM@?5has?5made?5a?5request?$CB?$AA@ DB ' has made a reques'
	DB	't!', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MOMNMKPE@?5has?5made?5a?5demand?$CB?$AA@
CONST	SEGMENT
??_C@_0BE@MOMNMKPE@?5has?5made?5a?5demand?$CB?$AA@ DB ' has made a demand'
	DB	'!', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HNMIHOOB@?0?5White?5Peace?$CB?$AA@
CONST	SEGMENT
??_C@_0P@HNMIHOOB@?0?5White?5Peace?$CB?$AA@ DB ', White Peace!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OFLNONA@?5is?5giving?5up?$CB?$AA@
CONST	SEGMENT
??_C@_0P@OFLNONA@?5is?5giving?5up?$CB?$AA@ DB ' is giving up!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@GIPAALKO@XXX?5NO?5VALID?5PEACE?5TREATY?$CB?$CB?$CB?$AA@
CONST	SEGMENT
??_C@_0BN@GIPAALKO@XXX?5NO?5VALID?5PEACE?5TREATY?$CB?$CB?$CB?$AA@ DB 'XXX'
	DB	' NO VALID PEACE TREATY!!!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@JOPDMDJI@?$CK?$CK?$CK?$CK?$CK?5UNCONDITIONAL?5SURRENDER?5?$CK?$CK@
CONST	SEGMENT
??_C@_0CE@JOPDMDJI@?$CK?$CK?$CK?$CK?$CK?5UNCONDITIONAL?5SURRENDER?5?$CK?$CK@ DB '*'
	DB	'**** UNCONDITIONAL SURRENDER *****', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@JKMJDBGK@?$CK?$CK?$CK?$CK?$CK?5CAPITULATION?5?$CK?$CK?$CK?$CK?$CK?$AA@
CONST	SEGMENT
??_C@_0BJ@JKMJDBGK@?$CK?$CK?$CK?$CK?$CK?5CAPITULATION?5?$CK?$CK?$CK?$CK?$CK?$AA@ DB '*'
	DB	'**** CAPITULATION *****', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MBMCANPB@?$CK?$CK?$CK?$CK?$CK?5CESSION?5?$CK?$CK?$CK?$CK?$CK?$AA@
CONST	SEGMENT
??_C@_0BE@MBMCANPB@?$CK?$CK?$CK?$CK?$CK?5CESSION?5?$CK?$CK?$CK?$CK?$CK?$AA@ DB '*'
	DB	'**** CESSION *****', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NFOMOILH@?$CK?$CK?$CK?$CK?$CK?5SURRENDER?5?$CK?$CK?$CK?$CK?$CK?$AA@
CONST	SEGMENT
??_C@_0BG@NFOMOILH@?$CK?$CK?$CK?$CK?$CK?5SURRENDER?5?$CK?$CK?$CK?$CK?$CK?$AA@ DB '*'
	DB	'**** SURRENDER *****', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@OHJNDNPE@?$CK?$CK?$CK?$CK?$CK?5SUBMISSION?5?$CK?$CK?$CK?$CK?$CK?$AA@
CONST	SEGMENT
??_C@_0BH@OHJNDNPE@?$CK?$CK?$CK?$CK?$CK?5SUBMISSION?5?$CK?$CK?$CK?$CK?$CK?$AA@ DB '*'
	DB	'**** SUBMISSION *****', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BBLCPBGO@?$CK?$CK?$CK?$CK?$CK?5BACKDOWN?5?$CK?$CK?$CK?$CK?$CK?$AA@
CONST	SEGMENT
??_C@_0BF@BBLCPBGO@?$CK?$CK?$CK?$CK?$CK?5BACKDOWN?5?$CK?$CK?$CK?$CK?$CK?$AA@ DB '*'
	DB	'**** BACKDOWN *****', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@ENHAEGBH@?$CK?$CK?$CK?$CK?$CK?5SETTLEMENT?5?$CK?$CK?$CK?$CK?$CK?$AA@
CONST	SEGMENT
??_C@_0BH@ENHAEGBH@?$CK?$CK?$CK?$CK?$CK?5SETTLEMENT?5?$CK?$CK?$CK?$CK?$CK?$AA@ DB '*'
	DB	'**** SETTLEMENT *****', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BDGEHDOI@?$CK?$CK?$CK?$CK?$CK?5ARMISTICE?5?$CK?$CK?$CK?$CK?$CK?$AA@
CONST	SEGMENT
??_C@_0BG@BDGEHDOI@?$CK?$CK?$CK?$CK?$CK?5ARMISTICE?5?$CK?$CK?$CK?$CK?$CK?$AA@ DB '*'
	DB	'**** ARMISTICE *****', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DAGCMOMB@?$CK?$CK?$CK?$CK?$CK?5WHITE?5PEACE?5?$CK?$CK?$CK?$CK?$CK?$AA@
CONST	SEGMENT
??_C@_0BI@DAGCMOMB@?$CK?$CK?$CK?$CK?$CK?5WHITE?5PEACE?5?$CK?$CK?$CK?$CK?$CK?$AA@ DB '*'
	DB	'**** WHITE PEACE *****', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DJANPOPP@?0?5?0?5?$AA@
CONST	SEGMENT
??_C@_04DJANPOPP@?0?5?0?5?$AA@ DB ', , ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02KEGNLNML@?0?5?$AA@
CONST	SEGMENT
??_C@_02KEGNLNML@?0?5?$AA@ DB ', ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
CONST	SEGMENT
??_C@_06NHKAIDD@?$CF03d?0?5?$AA@ DB '%03d, ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@NEDAAMNI@DiplomacyAI_Messages_Log?4csv?$AA@
CONST	SEGMENT
??_C@_0BN@NEDAAMNI@DiplomacyAI_Messages_Log?4csv?$AA@ DB 'DiplomacyAI_Mes'
	DB	'sages_Log.csv', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04EBGNMJBD@?4csv?$AA@
CONST	SEGMENT
??_C@_04EBGNMJBD@?4csv?$AA@ DB '.csv', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GIOCJFHA@DiplomacyAI_Messages_Log_?$AA@
CONST	SEGMENT
??_C@_0BK@GIOCJFHA@DiplomacyAI_Messages_Log_?$AA@ DB 'DiplomacyAI_Message'
	DB	's_Log_', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z DD 019930522H
	DD	013H
	DD	FLAT:__unwindtable$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$7
	DD	05H
	DD	FLAT:__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$11
	DD	08H
	DD	FLAT:__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$12
	DD	08H
	DD	FLAT:__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$13
	DD	08H
	DD	FLAT:__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$14
	DD	0cH
	DD	FLAT:__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$15
	DD	08H
	DD	FLAT:__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$16
	DD	0eH
	DD	FLAT:__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$17
	DD	08H
	DD	FLAT:__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$18
	DD	010H
	DD	FLAT:__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$19
	DD	08H
	DD	FLAT:__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$20
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z
_TEXT	SEGMENT
tv571 = -800						; size = 4
tv1104 = -796						; size = 4
tv429 = -792						; size = 4
tv569 = -788						; size = 4
tv1103 = -784						; size = 4
tv567 = -780						; size = 4
tv1102 = -776						; size = 4
tv565 = -772						; size = 4
tv1101 = -768						; size = 4
tv563 = -764						; size = 4
tv74 = -760						; size = 4
tv561 = -756						; size = 4
tv577 = -752						; size = 4
tv559 = -748						; size = 4
tv588 = -744						; size = 4
tv557 = -740						; size = 4
tv599 = -736						; size = 4
tv269 = -732						; size = 4
tv610 = -728						; size = 4
tv553 = -724						; size = 4
tv621 = -720						; size = 4
tv205 = -716						; size = 4
tv549 = -712						; size = 4
tv148 = -708						; size = 4
tv632 = -704						; size = 4
tv544 = -700						; size = 4
tv664 = -696						; size = 4
_this$ = -692						; size = 4
$T243163 = -688						; size = 4
$T243133 = -684						; size = 4
$T243127 = -680						; size = 4
$T243100 = -676						; size = 4
$T243068 = -672						; size = 4
$T243062 = -668						; size = 4
$T243035 = -664						; size = 4
$T243003 = -660						; size = 4
$T242971 = -656						; size = 4
$T242939 = -652						; size = 4
$T242907 = -648						; size = 4
$T242901 = -644						; size = 4
$T242895 = -640						; size = 4
$T242894 = -636						; size = 4
$T242890 = -632						; size = 4
$T242884 = -628						; size = 4
$T242883 = -624						; size = 4
$T242879 = -620						; size = 4
$T242873 = -616						; size = 4
$T242872 = -612						; size = 4
$T242868 = -608						; size = 4
$T242864 = -604						; size = 4
$T242858 = -600						; size = 4
$T242854 = -596						; size = 4
$T242848 = -592						; size = 4
$T242841 = -588						; size = 4
$T242820 = -584						; size = 4
$T242804 = -580						; size = 4
$T242800 = -576						; size = 4
$T242791 = -572						; size = 4
$T242765 = -568						; size = 4
$T242756 = -564						; size = 4
$T242707 = -560						; size = 28
$T242706 = -532						; size = 28
$T242705 = -504						; size = 28
$T242704 = -476						; size = 28
$T242703 = -448						; size = 28
$T242702 = -420						; size = 28
$T242701 = -392						; size = 28
$T242700 = -364						; size = 28
$T242699 = -336						; size = 28
$T242698 = -308						; size = 28
$T242695 = -280						; size = 8
$T242694 = -269						; size = 1
$T242693 = -268						; size = 8
$T242692 = -260						; size = 28
$T242691 = -232						; size = 28
_strOutBuf$222860 = -204				; size = 28
_playerName$222862 = -176				; size = 28
_eFromPlayer$222873 = -148				; size = 4
_itemIter$222875 = -144					; size = 8
_strLogName$222859 = -136				; size = 28
_pLog$222872 = -108					; size = 4
_otherPlayerName$222863 = -104				; size = 28
_eToPlayer$222874 = -76					; size = 4
_strTemp$222864 = -72					; size = 28
_strBaseString$222861 = -44				; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pDeal$ = 8						; size = 4
?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z PROC	; CvGameDeals::LogDealComplete, COMDAT
; _this$ = ecx

; 3595 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 788				; 00000314H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3596 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN39@LogDealCom
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN39@LogDealCom

; 3597 : 	{
; 3598 : 		CvString strLogName;

	lea	ecx, DWORD PTR _strLogName$222859[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3599 : 
; 3600 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$222860[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 3601 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$222861[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 3602 : 
; 3603 : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$222862[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 3604 : 		CvString otherPlayerName;

	lea	ecx, DWORD PTR _otherPlayerName$222863[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 3605 : 
; 3606 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$222864[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5

; 3607 : 
; 3608 : 		// Open the log file
; 3609 : 		if(GC.getPlayerAndCityAILogSplit())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ ; CvGlobals::getPlayerAndCityAILogSplit
	movzx	edx, al
	test	edx, edx
	je	$LN37@LogDealCom

; 3610 : 		{
; 3611 : 			strLogName = "DiplomacyAI_Messages_Log_" + playerName + ".csv";

	lea	eax, DWORD PTR _playerName$222862[ebp]
	push	eax
	push	OFFSET ??_C@_0BK@GIOCJFHA@DiplomacyAI_Messages_Log_?$AA@
	lea	ecx, DWORD PTR $T242691[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv664[ebp], eax
	mov	edx, DWORD PTR tv664[ebp]
	mov	DWORD PTR tv544[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	push	OFFSET ??_C@_04EBGNMJBD@?4csv?$AA@
	mov	eax, DWORD PTR tv544[ebp]
	push	eax
	lea	ecx, DWORD PTR $T242692[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv632[ebp], eax
	mov	edx, DWORD PTR tv632[ebp]
	mov	DWORD PTR $T242756[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	ecx, DWORD PTR $T242756[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogName$222859[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR $T242692[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T242691[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3612 : 		}
; 3613 : 		else

	jmp	SHORT $LN36@LogDealCom
$LN37@LogDealCom:

; 3614 : 		{
; 3615 : 			strLogName = "DiplomacyAI_Messages_Log.csv";

	mov	eax, OFFSET ??_C@_0BN@NEDAAMNI@DiplomacyAI_Messages_Log?4csv?$AA@
	test	eax, eax
	je	SHORT $LN85@LogDealCom
	push	OFFSET ??_C@_0BN@NEDAAMNI@DiplomacyAI_Messages_Log?4csv?$AA@
	lea	ecx, DWORD PTR _strLogName$222859[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN36@LogDealCom
$LN85@LogDealCom:
	lea	ecx, DWORD PTR _strLogName$222859[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN36@LogDealCom:

; 3616 : 		}
; 3617 : 
; 3618 : 		FILogFile* pLog;
; 3619 : 		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv148[ebp], eax
	lea	ecx, DWORD PTR _strLogName$222859[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T242765[ebp], eax
	push	0
	push	1
	mov	ecx, DWORD PTR $T242765[ebp]
	push	ecx
	mov	edx, DWORD PTR tv148[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv148[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	DWORD PTR _pLog$222872[ebp], eax

; 3620 : 
; 3621 : 		PlayerTypes eFromPlayer;
; 3622 : 		PlayerTypes eToPlayer;
; 3623 : 
; 3624 : 		TradedItemList::iterator itemIter;

	lea	ecx, DWORD PTR _itemIter$222875[ebp]
	call	??0iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::iterator
	mov	BYTE PTR __$EHRec$[ebp+8], 8

; 3625 : 		for(itemIter = pDeal->m_TradedItems.begin(); itemIter != pDeal->m_TradedItems.end(); ++itemIter)

	lea	eax, DWORD PTR $T242693[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv549[ebp], eax
	mov	ecx, DWORD PTR tv549[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _itemIter$222875[ebp], edx
	mov	DWORD PTR _itemIter$222875[ebp+4], eax
	jmp	SHORT $LN35@LogDealCom
$LN34@LogDealCom:
	cmp	DWORD PTR _itemIter$222875[ebp+4], 268435455 ; 0fffffffH
	jne	SHORT $LN102@LogDealCom
	mov	ecx, DWORD PTR _itemIter$222875[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _itemIter$222875[ebp+4], edx
	jmp	SHORT $LN35@LogDealCom
$LN102@LogDealCom:
	mov	eax, DWORD PTR _itemIter$222875[ebp]
	mov	DWORD PTR $T242791[ebp], eax
	mov	ecx, DWORD PTR _itemIter$222875[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T242791[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T242800[ebp], ecx
	mov	eax, DWORD PTR $T242800[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T242804[ebp], ecx
	mov	edx, DWORD PTR $T242804[ebp]
	mov	DWORD PTR _itemIter$222875[ebp+4], edx
$LN35@LogDealCom:
	lea	eax, DWORD PTR $T242695[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T242820[ebp], eax
	mov	ecx, DWORD PTR $T242820[ebp]
	mov	edx, DWORD PTR _itemIter$222875[ebp+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setne	al
	mov	BYTE PTR $T242694[ebp], al
	movzx	ecx, BYTE PTR $T242694[ebp]
	test	ecx, ecx
	je	$LN33@LogDealCom

; 3626 : 		{
; 3627 : 			// Turn number
; 3628 : 			strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T242841[ebp], edx
	mov	ecx, DWORD PTR $T242841[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	push	OFFSET ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
	lea	eax, DWORD PTR _strBaseString$222861[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 3629 : 
; 3630 : 			eFromPlayer = itemIter->m_eFromPlayer;

	lea	ecx, DWORD PTR _itemIter$222875[ebp]
	call	??Diterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::operator*
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR _eFromPlayer$222873[ebp], ecx

; 3631 : 			eToPlayer = eFromPlayer == pDeal->m_eFromPlayer ? pDeal->m_eToPlayer : pDeal->m_eFromPlayer;

	mov	edx, DWORD PTR _pDeal$[ebp]
	mov	eax, DWORD PTR _eFromPlayer$222873[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN41@LogDealCom
	mov	ecx, DWORD PTR _pDeal$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv205[ebp], edx
	jmp	SHORT $LN42@LogDealCom
$LN41@LogDealCom:
	mov	eax, DWORD PTR _pDeal$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv205[ebp], ecx
$LN42@LogDealCom:
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR _eToPlayer$222874[ebp], edx

; 3632 : 
; 3633 : 			playerName = GET_PLAYER(eFromPlayer).getCivilizationShortDescription();

	mov	eax, DWORD PTR _eFromPlayer$222873[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T242848[ebp], eax
	mov	ecx, DWORD PTR $T242848[ebp]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T242854[ebp], eax
	cmp	DWORD PTR $T242854[ebp], 0
	je	SHORT $LN130@LogDealCom
	mov	ecx, DWORD PTR $T242854[ebp]
	push	ecx
	lea	ecx, DWORD PTR _playerName$222862[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN131@LogDealCom
$LN130@LogDealCom:
	lea	ecx, DWORD PTR _playerName$222862[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN131@LogDealCom:

; 3634 : 
; 3635 : 			// Our Name
; 3636 : 			strBaseString += playerName;

	lea	edx, DWORD PTR _playerName$222862[ebp]
	push	edx
	lea	ecx, DWORD PTR _strBaseString$222861[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 3637 : 
; 3638 : 			// Their Name
; 3639 : 			otherPlayerName = GET_PLAYER(eToPlayer).getCivilizationShortDescription();

	mov	eax, DWORD PTR _eToPlayer$222874[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T242858[ebp], eax
	mov	ecx, DWORD PTR $T242858[ebp]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T242864[ebp], eax
	cmp	DWORD PTR $T242864[ebp], 0
	je	SHORT $LN136@LogDealCom
	mov	ecx, DWORD PTR $T242864[ebp]
	push	ecx
	lea	ecx, DWORD PTR _otherPlayerName$222863[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN137@LogDealCom
$LN136@LogDealCom:
	lea	ecx, DWORD PTR _otherPlayerName$222863[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN137@LogDealCom:

; 3640 : 			strBaseString += ", " + otherPlayerName;

	lea	edx, DWORD PTR _otherPlayerName$222863[ebp]
	push	edx
	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	eax, DWORD PTR $T242698[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv621[ebp], eax
	mov	ecx, DWORD PTR tv621[ebp]
	mov	DWORD PTR tv553[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	mov	edx, DWORD PTR tv553[ebp]
	push	edx
	lea	ecx, DWORD PTR _strBaseString$222861[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	ecx, DWORD PTR $T242698[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3641 : 
; 3642 : 			strOutBuf = strBaseString + ", , ";

	push	OFFSET ??_C@_04DJANPOPP@?0?5?0?5?$AA@
	lea	eax, DWORD PTR _strBaseString$222861[ebp]
	push	eax
	lea	ecx, DWORD PTR $T242699[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv610[ebp], eax
	mov	edx, DWORD PTR tv610[ebp]
	mov	DWORD PTR $T242868[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	ecx, DWORD PTR $T242868[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$222860[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	ecx, DWORD PTR $T242699[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3643 : 
; 3644 : 			// Peace Treaty deal?
; 3645 : 			if(pDeal->GetPeaceTreatyType() != NO_PEACE_TREATY_TYPE)

	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?GetPeaceTreatyType@CvDeal@@QBE?AW4PeaceTreatyTypes@@XZ ; CvDeal::GetPeaceTreatyType
	cmp	eax, -1
	je	$LN32@LogDealCom

; 3646 : 			{
; 3647 : 				switch(pDeal->GetPeaceTreatyType())

	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?GetPeaceTreatyType@CvDeal@@QBE?AW4PeaceTreatyTypes@@XZ ; CvDeal::GetPeaceTreatyType
	mov	DWORD PTR tv269[ebp], eax
	cmp	DWORD PTR tv269[ebp], 8
	ja	$LN20@LogDealCom
	mov	eax, DWORD PTR tv269[ebp]
	jmp	DWORD PTR $LN269@LogDealCom[eax*4]
$LN29@LogDealCom:

; 3648 : 				{
; 3649 : 				case PEACE_TREATY_WHITE_PEACE:
; 3650 : 					strTemp.Format("***** WHITE PEACE *****");

	push	OFFSET ??_C@_0BI@DAGCMOMB@?$CK?$CK?$CK?$CK?$CK?5WHITE?5PEACE?5?$CK?$CK?$CK?$CK?$CK?$AA@
	lea	ecx, DWORD PTR _strTemp$222864[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 3651 : 					break;

	jmp	$LN30@LogDealCom
$LN28@LogDealCom:

; 3652 : 				case PEACE_TREATY_ARMISTICE:
; 3653 : 					strTemp.Format("***** ARMISTICE *****");

	push	OFFSET ??_C@_0BG@BDGEHDOI@?$CK?$CK?$CK?$CK?$CK?5ARMISTICE?5?$CK?$CK?$CK?$CK?$CK?$AA@
	lea	edx, DWORD PTR _strTemp$222864[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 3654 : 					break;

	jmp	$LN30@LogDealCom
$LN27@LogDealCom:

; 3655 : 				case PEACE_TREATY_SETTLEMENT:
; 3656 : 					strTemp.Format("***** SETTLEMENT *****");

	push	OFFSET ??_C@_0BH@ENHAEGBH@?$CK?$CK?$CK?$CK?$CK?5SETTLEMENT?5?$CK?$CK?$CK?$CK?$CK?$AA@
	lea	eax, DWORD PTR _strTemp$222864[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 3657 : 					break;

	jmp	$LN30@LogDealCom
$LN26@LogDealCom:

; 3658 : 				case PEACE_TREATY_BACKDOWN:
; 3659 : 					strTemp.Format("***** BACKDOWN *****");

	push	OFFSET ??_C@_0BF@BBLCPBGO@?$CK?$CK?$CK?$CK?$CK?5BACKDOWN?5?$CK?$CK?$CK?$CK?$CK?$AA@
	lea	ecx, DWORD PTR _strTemp$222864[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 3660 : 					break;

	jmp	SHORT $LN30@LogDealCom
$LN25@LogDealCom:

; 3661 : 				case PEACE_TREATY_SUBMISSION:
; 3662 : 					strTemp.Format("***** SUBMISSION *****");

	push	OFFSET ??_C@_0BH@OHJNDNPE@?$CK?$CK?$CK?$CK?$CK?5SUBMISSION?5?$CK?$CK?$CK?$CK?$CK?$AA@
	lea	edx, DWORD PTR _strTemp$222864[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 3663 : 					break;

	jmp	SHORT $LN30@LogDealCom
$LN24@LogDealCom:

; 3664 : 				case PEACE_TREATY_SURRENDER:
; 3665 : 					strTemp.Format("***** SURRENDER *****");

	push	OFFSET ??_C@_0BG@NFOMOILH@?$CK?$CK?$CK?$CK?$CK?5SURRENDER?5?$CK?$CK?$CK?$CK?$CK?$AA@
	lea	eax, DWORD PTR _strTemp$222864[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 3666 : 					break;

	jmp	SHORT $LN30@LogDealCom
$LN23@LogDealCom:

; 3667 : 				case PEACE_TREATY_CESSION:
; 3668 : 					strTemp.Format("***** CESSION *****");

	push	OFFSET ??_C@_0BE@MBMCANPB@?$CK?$CK?$CK?$CK?$CK?5CESSION?5?$CK?$CK?$CK?$CK?$CK?$AA@
	lea	ecx, DWORD PTR _strTemp$222864[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 3669 : 					break;

	jmp	SHORT $LN30@LogDealCom
$LN22@LogDealCom:

; 3670 : 				case PEACE_TREATY_CAPITULATION:
; 3671 : 					strTemp.Format("***** CAPITULATION *****");

	push	OFFSET ??_C@_0BJ@JKMJDBGK@?$CK?$CK?$CK?$CK?$CK?5CAPITULATION?5?$CK?$CK?$CK?$CK?$CK?$AA@
	lea	edx, DWORD PTR _strTemp$222864[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 3672 : 					break;

	jmp	SHORT $LN30@LogDealCom
$LN21@LogDealCom:

; 3673 : 				case PEACE_TREATY_UNCONDITIONAL_SURRENDER:
; 3674 : 					strTemp.Format("***** UNCONDITIONAL SURRENDER *****");

	push	OFFSET ??_C@_0CE@JOPDMDJI@?$CK?$CK?$CK?$CK?$CK?5UNCONDITIONAL?5SURRENDER?5?$CK?$CK@
	lea	eax, DWORD PTR _strTemp$222864[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 3675 : 					break;

	jmp	SHORT $LN30@LogDealCom
$LN20@LogDealCom:

; 3676 : 				default:
; 3677 : 					strTemp.Format("XXX NO VALID PEACE TREATY!!!");

	push	OFFSET ??_C@_0BN@GIPAALKO@XXX?5NO?5VALID?5PEACE?5TREATY?$CB?$CB?$CB?$AA@
	lea	ecx, DWORD PTR _strTemp$222864[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8
$LN30@LogDealCom:

; 3678 : 					break;
; 3679 : 				}
; 3680 : 				strOutBuf += ", " + strTemp;

	lea	edx, DWORD PTR _strTemp$222864[ebp]
	push	edx
	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	eax, DWORD PTR $T242700[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv599[ebp], eax
	mov	ecx, DWORD PTR tv599[ebp]
	mov	DWORD PTR tv557[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	mov	edx, DWORD PTR tv557[ebp]
	push	edx
	lea	ecx, DWORD PTR _strOutBuf$222860[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	ecx, DWORD PTR $T242700[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN32@LogDealCom:

; 3681 : 			}
; 3682 : 
; 3683 : 			// Is someone surrendering?
; 3684 : 			if(pDeal->GetSurrenderingPlayer() != NO_PLAYER)

	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?GetSurrenderingPlayer@CvDeal@@QBE?AW4PlayerTypes@@XZ ; CvDeal::GetSurrenderingPlayer
	cmp	eax, -1
	je	$LN19@LogDealCom

; 3685 : 			{
; 3686 : 				playerName = GET_PLAYER(pDeal->GetSurrenderingPlayer()).getCivilizationShortDescription();

	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?GetSurrenderingPlayer@CvDeal@@QBE?AW4PlayerTypes@@XZ ; CvDeal::GetSurrenderingPlayer
	mov	DWORD PTR $T242872[ebp], eax
	mov	eax, DWORD PTR $T242872[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T242873[ebp], eax
	mov	ecx, DWORD PTR $T242873[ebp]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T242879[ebp], eax
	cmp	DWORD PTR $T242879[ebp], 0
	je	SHORT $LN144@LogDealCom
	mov	ecx, DWORD PTR $T242879[ebp]
	push	ecx
	lea	ecx, DWORD PTR _playerName$222862[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN145@LogDealCom
$LN144@LogDealCom:
	lea	ecx, DWORD PTR _playerName$222862[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN145@LogDealCom:

; 3687 : 				strOutBuf += ", " + playerName + " is giving up!";

	lea	edx, DWORD PTR _playerName$222862[ebp]
	push	edx
	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	eax, DWORD PTR $T242701[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv588[ebp], eax
	mov	ecx, DWORD PTR tv588[ebp]
	mov	DWORD PTR tv559[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	push	OFFSET ??_C@_0P@OFLNONA@?5is?5giving?5up?$CB?$AA@
	mov	edx, DWORD PTR tv559[ebp]
	push	edx
	lea	eax, DWORD PTR $T242702[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv577[ebp], eax
	mov	ecx, DWORD PTR tv577[ebp]
	mov	DWORD PTR tv561[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH
	mov	edx, DWORD PTR tv561[ebp]
	push	edx
	lea	ecx, DWORD PTR _strOutBuf$222860[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	lea	ecx, DWORD PTR $T242702[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	ecx, DWORD PTR $T242701[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	SHORT $LN18@LogDealCom
$LN19@LogDealCom:

; 3688 : 			}
; 3689 : 			// White Peace
; 3690 : 			else if(pDeal->GetPeaceTreatyType() == PEACE_TREATY_WHITE_PEACE)

	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?GetPeaceTreatyType@CvDeal@@QBE?AW4PeaceTreatyTypes@@XZ ; CvDeal::GetPeaceTreatyType
	test	eax, eax
	jne	SHORT $LN18@LogDealCom

; 3691 : 			{
; 3692 : 				strOutBuf += ", White Peace!";

	push	OFFSET ??_C@_0P@HNMIHOOB@?0?5White?5Peace?$CB?$AA@
	lea	ecx, DWORD PTR _strOutBuf$222860[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN18@LogDealCom:

; 3693 : 			}
; 3694 : 
; 3695 : 			// Is this a demand?
; 3696 : 			if(pDeal->GetDemandingPlayer() != NO_PLAYER)

	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?GetDemandingPlayer@CvDeal@@QBE?AW4PlayerTypes@@XZ ; CvDeal::GetDemandingPlayer
	cmp	eax, -1
	je	$LN16@LogDealCom

; 3697 : 			{
; 3698 : 				playerName = GET_PLAYER(pDeal->GetDemandingPlayer()).getCivilizationShortDescription();

	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?GetDemandingPlayer@CvDeal@@QBE?AW4PlayerTypes@@XZ ; CvDeal::GetDemandingPlayer
	mov	DWORD PTR $T242883[ebp], eax
	mov	eax, DWORD PTR $T242883[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T242884[ebp], eax
	mov	ecx, DWORD PTR $T242884[ebp]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T242890[ebp], eax
	cmp	DWORD PTR $T242890[ebp], 0
	je	SHORT $LN150@LogDealCom
	mov	ecx, DWORD PTR $T242890[ebp]
	push	ecx
	lea	ecx, DWORD PTR _playerName$222862[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN151@LogDealCom
$LN150@LogDealCom:
	lea	ecx, DWORD PTR _playerName$222862[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN151@LogDealCom:

; 3699 : 				strOutBuf += ", " + playerName + " has made a demand!";

	lea	edx, DWORD PTR _playerName$222862[ebp]
	push	edx
	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	eax, DWORD PTR $T242703[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv74[ebp], eax
	mov	ecx, DWORD PTR tv74[ebp]
	mov	DWORD PTR tv563[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH
	push	OFFSET ??_C@_0BE@MOMNMKPE@?5has?5made?5a?5demand?$CB?$AA@
	mov	edx, DWORD PTR tv563[ebp]
	push	edx
	lea	eax, DWORD PTR $T242704[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv1101[ebp], eax
	mov	ecx, DWORD PTR tv1101[ebp]
	mov	DWORD PTR tv565[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 15		; 0000000fH
	mov	edx, DWORD PTR tv565[ebp]
	push	edx
	lea	ecx, DWORD PTR _strOutBuf$222860[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH
	lea	ecx, DWORD PTR $T242704[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	ecx, DWORD PTR $T242703[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN16@LogDealCom:

; 3700 : 			}
; 3701 : 
; 3702 : 			// Is this a request?
; 3703 : 			if(pDeal->GetRequestingPlayer() != NO_PLAYER)

	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?GetRequestingPlayer@CvDeal@@QBE?AW4PlayerTypes@@XZ ; CvDeal::GetRequestingPlayer
	cmp	eax, -1
	je	$LN15@LogDealCom

; 3704 : 			{
; 3705 : 				playerName = GET_PLAYER(pDeal->GetRequestingPlayer()).getCivilizationShortDescription();

	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?GetRequestingPlayer@CvDeal@@QBE?AW4PlayerTypes@@XZ ; CvDeal::GetRequestingPlayer
	mov	DWORD PTR $T242894[ebp], eax
	mov	eax, DWORD PTR $T242894[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T242895[ebp], eax
	mov	ecx, DWORD PTR $T242895[ebp]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T242901[ebp], eax
	cmp	DWORD PTR $T242901[ebp], 0
	je	SHORT $LN156@LogDealCom
	mov	ecx, DWORD PTR $T242901[ebp]
	push	ecx
	lea	ecx, DWORD PTR _playerName$222862[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN157@LogDealCom
$LN156@LogDealCom:
	lea	ecx, DWORD PTR _playerName$222862[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN157@LogDealCom:

; 3706 : 				strOutBuf += ", " + playerName + " has made a request!";

	lea	edx, DWORD PTR _playerName$222862[ebp]
	push	edx
	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	eax, DWORD PTR $T242705[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv1102[ebp], eax
	mov	ecx, DWORD PTR tv1102[ebp]
	mov	DWORD PTR tv567[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 16		; 00000010H
	push	OFFSET ??_C@_0BF@BALNBIM@?5has?5made?5a?5request?$CB?$AA@
	mov	edx, DWORD PTR tv567[ebp]
	push	edx
	lea	eax, DWORD PTR $T242706[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv1103[ebp], eax
	mov	ecx, DWORD PTR tv1103[ebp]
	mov	DWORD PTR tv569[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 17		; 00000011H
	mov	edx, DWORD PTR tv569[ebp]
	push	edx
	lea	ecx, DWORD PTR _strOutBuf$222860[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 16		; 00000010H
	lea	ecx, DWORD PTR $T242706[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	ecx, DWORD PTR $T242705[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN15@LogDealCom:

; 3707 : 			}
; 3708 : 
; 3709 : 			// What is this particular Trade item?
; 3710 : 			switch(itemIter->m_eItemType)

	mov	eax, DWORD PTR _itemIter$222875[ebp]
	mov	DWORD PTR $T242907[ebp], eax
	mov	ecx, DWORD PTR _itemIter$222875[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T242907[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+ecx+8]
	mov	DWORD PTR tv429[ebp], ecx
	cmp	DWORD PTR tv429[ebp], 19		; 00000013H
	ja	$LN1@LogDealCom
	mov	edx, DWORD PTR tv429[ebp]
	movzx	eax, BYTE PTR $LN267@LogDealCom[edx]
	jmp	DWORD PTR $LN270@LogDealCom[eax*4]
$LN12@LogDealCom:

; 3711 : 			{
; 3712 : 			case TRADE_ITEM_GOLD:
; 3713 : 				strTemp.Format("***** Gold Trade: %d *****", itemIter->m_iData1);

	mov	ecx, DWORD PTR _itemIter$222875[ebp]
	mov	DWORD PTR $T242939[ebp], ecx
	mov	edx, DWORD PTR _itemIter$222875[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T242939[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+edx+20]
	push	edx
	push	OFFSET ??_C@_0BL@CDOPOBBO@?$CK?$CK?$CK?$CK?$CK?5Gold?5Trade?3?5?$CFd?5?$CK?$CK?$CK?$CK?$CK?$AA@
	lea	eax, DWORD PTR _strTemp$222864[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 3714 : 				break;

	jmp	$LN13@LogDealCom
$LN11@LogDealCom:

; 3715 : 			case TRADE_ITEM_GOLD_PER_TURN:
; 3716 : 				strTemp.Format("***** GPT Trade: %d *****", itemIter->m_iData1);

	mov	ecx, DWORD PTR _itemIter$222875[ebp]
	mov	DWORD PTR $T242971[ebp], ecx
	mov	edx, DWORD PTR _itemIter$222875[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T242971[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+edx+20]
	push	edx
	push	OFFSET ??_C@_0BK@IJBKIFCE@?$CK?$CK?$CK?$CK?$CK?5GPT?5Trade?3?5?$CFd?5?$CK?$CK?$CK?$CK?$CK?$AA@
	lea	eax, DWORD PTR _strTemp$222864[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 3717 : 				break;

	jmp	$LN13@LogDealCom
$LN10@LogDealCom:

; 3718 : 			case TRADE_ITEM_RESOURCES:
; 3719 : 				strTemp.Format("***** Resource Trade: ID %d *****", itemIter->m_iData1);

	mov	ecx, DWORD PTR _itemIter$222875[ebp]
	mov	DWORD PTR $T243003[ebp], ecx
	mov	edx, DWORD PTR _itemIter$222875[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T243003[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+edx+20]
	push	edx
	push	OFFSET ??_C@_0CC@NCDFBFMH@?$CK?$CK?$CK?$CK?$CK?5Resource?5Trade?3?5ID?5?$CFd?5?$CK?$CK?$CK?$CK@
	lea	eax, DWORD PTR _strTemp$222864[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 3720 : 				break;

	jmp	$LN13@LogDealCom
$LN9@LogDealCom:

; 3721 : 			case TRADE_ITEM_CITIES:
; 3722 : 				strTemp.Format("***** City Trade: ID %d %d *****", itemIter->m_iData1, itemIter->m_iData2);

	mov	ecx, DWORD PTR _itemIter$222875[ebp]
	mov	DWORD PTR $T243035[ebp], ecx
	mov	edx, DWORD PTR _itemIter$222875[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T243035[ebp]
	mov	ecx, DWORD PTR [eax+8]
	lea	edx, DWORD PTR [ecx+edx+8]
	mov	DWORD PTR $T243062[ebp], edx
	mov	eax, DWORD PTR _itemIter$222875[ebp]
	mov	DWORD PTR $T243068[ebp], eax
	mov	ecx, DWORD PTR $T243062[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _itemIter$222875[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T243068[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+eax+20]
	push	eax
	push	OFFSET ??_C@_0CB@EIPFEACI@?$CK?$CK?$CK?$CK?$CK?5City?5Trade?3?5ID?5?$CFd?5?$CFd?5?$CK?$CK?$CK?$CK?$CK@
	lea	ecx, DWORD PTR _strTemp$222864[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3723 : 				break;

	jmp	$LN13@LogDealCom
$LN8@LogDealCom:

; 3724 : 			case TRADE_ITEM_OPEN_BORDERS:
; 3725 : 				strTemp.Format("Open Borders Trade");

	push	OFFSET ??_C@_0BD@JBFHPOFG@Open?5Borders?5Trade?$AA@
	lea	edx, DWORD PTR _strTemp$222864[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 3726 : 				break;

	jmp	$LN13@LogDealCom
$LN7@LogDealCom:

; 3727 : 			case TRADE_ITEM_DEFENSIVE_PACT:
; 3728 : 				strTemp.Format("***** Defensive Pact Trade *****");

	push	OFFSET ??_C@_0CB@HJDILAIL@?$CK?$CK?$CK?$CK?$CK?5Defensive?5Pact?5Trade?5?$CK?$CK?$CK?$CK?$CK@
	lea	eax, DWORD PTR _strTemp$222864[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 3729 : 				break;

	jmp	$LN13@LogDealCom
$LN6@LogDealCom:

; 3730 : 			case TRADE_ITEM_RESEARCH_AGREEMENT:
; 3731 : 				strTemp.Format("Research Agreement Trade");

	push	OFFSET ??_C@_0BJ@CNPHKDPC@Research?5Agreement?5Trade?$AA@
	lea	ecx, DWORD PTR _strTemp$222864[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 3732 : 				break;

	jmp	$LN13@LogDealCom
$LN5@LogDealCom:

; 3733 : 			case TRADE_ITEM_PEACE_TREATY:
; 3734 : 				strTemp.Format("***** Peace Treaty Trade *****");

	push	OFFSET ??_C@_0BP@GJNHHCDL@?$CK?$CK?$CK?$CK?$CK?5Peace?5Treaty?5Trade?5?$CK?$CK?$CK?$CK?$CK?$AA@
	lea	edx, DWORD PTR _strTemp$222864[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 3735 : 				break;

	jmp	$LN13@LogDealCom
$LN4@LogDealCom:

; 3736 : 			case TRADE_ITEM_THIRD_PARTY_PEACE:
; 3737 : 				strTemp.Format("***** Third Party Peace Trade *****");

	push	OFFSET ??_C@_0CE@OMBEOCFK@?$CK?$CK?$CK?$CK?$CK?5Third?5Party?5Peace?5Trade?5?$CK?$CK@
	lea	eax, DWORD PTR _strTemp$222864[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 3738 : 				break;

	jmp	$LN13@LogDealCom
$LN3@LogDealCom:

; 3739 : 			case TRADE_ITEM_THIRD_PARTY_WAR:
; 3740 : 				strTemp.Format("***** Third Party War Trade *****");

	push	OFFSET ??_C@_0CC@NPAIHELI@?$CK?$CK?$CK?$CK?$CK?5Third?5Party?5War?5Trade?5?$CK?$CK?$CK?$CK@
	lea	ecx, DWORD PTR _strTemp$222864[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 3741 : 				break;

	jmp	SHORT $LN13@LogDealCom
$LN2@LogDealCom:

; 3742 : 			case TRADE_ITEM_VOTE_COMMITMENT:
; 3743 : 				strTemp.Format("***** Vote Commitment: ID %d, Choice %d *****", itemIter->m_iData1, itemIter->m_iData2);

	mov	edx, DWORD PTR _itemIter$222875[ebp]
	mov	DWORD PTR $T243100[ebp], edx
	mov	eax, DWORD PTR _itemIter$222875[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T243100[ebp]
	mov	edx, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [edx+eax+8]
	mov	DWORD PTR $T243127[ebp], eax
	mov	ecx, DWORD PTR _itemIter$222875[ebp]
	mov	DWORD PTR $T243133[ebp], ecx
	mov	edx, DWORD PTR $T243127[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _itemIter$222875[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T243133[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+ecx+20]
	push	ecx
	push	OFFSET ??_C@_0CO@MGPLHFAL@?$CK?$CK?$CK?$CK?$CK?5Vote?5Commitment?3?5ID?5?$CFd?0?5Ch@
	lea	edx, DWORD PTR _strTemp$222864[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3744 : 				break;

	jmp	SHORT $LN13@LogDealCom
$LN1@LogDealCom:

; 3745 : 			default:
; 3746 : 				strTemp.Format("***** UNKNOWN TRADE!!! *****");

	push	OFFSET ??_C@_0BN@MFPCJCIM@?$CK?$CK?$CK?$CK?$CK?5UNKNOWN?5TRADE?$CB?$CB?$CB?5?$CK?$CK?$CK?$CK?$CK?$AA@
	lea	eax, DWORD PTR _strTemp$222864[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8
$LN13@LogDealCom:

; 3747 : 				break;
; 3748 : 			}
; 3749 : 			strOutBuf += ", " + strTemp;

	lea	ecx, DWORD PTR _strTemp$222864[ebp]
	push	ecx
	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	edx, DWORD PTR $T242707[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv1104[ebp], eax
	mov	eax, DWORD PTR tv1104[ebp]
	mov	DWORD PTR tv571[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 18		; 00000012H
	mov	ecx, DWORD PTR tv571[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strOutBuf$222860[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	ecx, DWORD PTR $T242707[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3750 : 
; 3751 : 			pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$222860[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T243163[ebp], eax
	mov	edx, DWORD PTR $T243163[ebp]
	push	edx
	mov	eax, DWORD PTR _pLog$222872[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pLog$222872[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	eax
	add	esp, 8

; 3752 : 
; 3753 : 			OutputDebugString("\n");
; 3754 : 			OutputDebugString(strOutBuf);
; 3755 : 			OutputDebugString("\n");
; 3756 : 		}

	jmp	$LN34@LogDealCom
$LN33@LogDealCom:

; 3757 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR _strTemp$222864[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _otherPlayerName$222863[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _playerName$222862[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strBaseString$222861[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strOutBuf$222860[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strLogName$222859[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN39@LogDealCom:

; 3758 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN269@LogDealCom:
	DD	$LN29@LogDealCom
	DD	$LN28@LogDealCom
	DD	$LN27@LogDealCom
	DD	$LN26@LogDealCom
	DD	$LN25@LogDealCom
	DD	$LN24@LogDealCom
	DD	$LN23@LogDealCom
	DD	$LN22@LogDealCom
	DD	$LN21@LogDealCom
$LN270@LogDealCom:
	DD	$LN12@LogDealCom
	DD	$LN11@LogDealCom
	DD	$LN10@LogDealCom
	DD	$LN9@LogDealCom
	DD	$LN8@LogDealCom
	DD	$LN7@LogDealCom
	DD	$LN6@LogDealCom
	DD	$LN5@LogDealCom
	DD	$LN4@LogDealCom
	DD	$LN3@LogDealCom
	DD	$LN2@LogDealCom
	DD	$LN1@LogDealCom
$LN267@LogDealCom:
	DB	0
	DB	1
	DB	11					; 0000000bH
	DB	2
	DB	3
	DB	11					; 0000000bH
	DB	4
	DB	5
	DB	6
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	7
	DB	8
	DB	9
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	10					; 0000000aH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$0:
	lea	ecx, DWORD PTR _strLogName$222859[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$1:
	lea	ecx, DWORD PTR _strOutBuf$222860[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$2:
	lea	ecx, DWORD PTR _strBaseString$222861[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$3:
	lea	ecx, DWORD PTR _playerName$222862[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$4:
	lea	ecx, DWORD PTR _otherPlayerName$222863[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$5:
	lea	ecx, DWORD PTR _strTemp$222864[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$6:
	lea	ecx, DWORD PTR $T242691[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$7:
	lea	ecx, DWORD PTR $T242692[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$8:
	lea	ecx, DWORD PTR _itemIter$222875[ebp]
	jmp	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$11:
	lea	ecx, DWORD PTR $T242698[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$12:
	lea	ecx, DWORD PTR $T242699[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$13:
	lea	ecx, DWORD PTR $T242700[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$14:
	lea	ecx, DWORD PTR $T242701[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$15:
	lea	ecx, DWORD PTR $T242702[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$16:
	lea	ecx, DWORD PTR $T242703[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$17:
	lea	ecx, DWORD PTR $T242704[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$18:
	lea	ecx, DWORD PTR $T242705[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$19:
	lea	ecx, DWORD PTR $T242706[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z$20:
	lea	ecx, DWORD PTR $T242707[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-792]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogDealComplete@CvGameDeals@@IAEXPAVCvDeal@@@Z ENDP	; CvGameDeals::LogDealComplete
PUBLIC	?GetCurrentDeal@CvGameDeals@@QAEPAVCvDeal@@W4PlayerTypes@@I@Z ; CvGameDeals::GetCurrentDeal
; Function compile flags: /Odtp
;	COMDAT ?GetCurrentDeal@CvGameDeals@@QAEPAVCvDeal@@W4PlayerTypes@@I@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T243219 = -16						; size = 4
_iCount$ = -12						; size = 4
_end$ = -8						; size = 4
_iter$ = -4						; size = 4
_ePlayer$ = 8						; size = 4
_index$ = 12						; size = 4
?GetCurrentDeal@CvGameDeals@@QAEPAVCvDeal@@W4PlayerTypes@@I@Z PROC ; CvGameDeals::GetCurrentDeal, COMDAT
; _this$ = ecx

; 3764 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 3765 : 	DealList::iterator iter;
; 3766 : 	DealList::iterator end = m_CurrentDeals.end();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1540				; 00000604H
	mov	DWORD PTR $T243219[ebp], eax
	mov	ecx, DWORD PTR $T243219[ebp]
	mov	edx, DWORD PTR [ecx+4]
	imul	edx, 76					; 0000004cH
	mov	eax, DWORD PTR $T243219[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR _end$[ebp], edx

; 3767 : 
; 3768 : 	uint iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0

; 3769 : 	for(iter = m_CurrentDeals.begin(); iter != end; ++iter)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1540]
	mov	DWORD PTR _iter$[ebp], edx
	jmp	SHORT $LN5@GetCurrent
$LN4@GetCurrent:
	mov	eax, DWORD PTR _iter$[ebp]
	add	eax, 76					; 0000004cH
	mov	DWORD PTR _iter$[ebp], eax
$LN5@GetCurrent:
	mov	ecx, DWORD PTR _iter$[ebp]
	cmp	ecx, DWORD PTR _end$[ebp]
	je	SHORT $LN3@GetCurrent

; 3770 : 	{
; 3771 : 		if((iter->m_eToPlayer == ePlayer ||
; 3772 : 		        iter->m_eFromPlayer == ePlayer) &&
; 3773 : 		        (iCount++ == index))

	mov	edx, DWORD PTR _iter$[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	eax, DWORD PTR _ePlayer$[ebp]
	je	SHORT $LN1@GetCurrent
	mov	ecx, DWORD PTR _iter$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _ePlayer$[ebp]
	jne	SHORT $LN2@GetCurrent
$LN1@GetCurrent:
	mov	eax, DWORD PTR _iCount$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	mov	edx, DWORD PTR _iCount$[ebp]
	add	edx, 1
	mov	DWORD PTR _iCount$[ebp], edx
	cmp	eax, ecx
	jne	SHORT $LN2@GetCurrent

; 3774 : 		{
; 3775 : 			return &(*iter);

	mov	eax, DWORD PTR _iter$[ebp]
	jmp	SHORT $LN6@GetCurrent
$LN2@GetCurrent:

; 3776 : 		}
; 3777 : 	}

	jmp	SHORT $LN4@GetCurrent
$LN3@GetCurrent:

; 3778 : 
; 3779 : 	return NULL;

	xor	eax, eax
$LN6@GetCurrent:

; 3780 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetCurrentDeal@CvGameDeals@@QAEPAVCvDeal@@W4PlayerTypes@@I@Z ENDP ; CvGameDeals::GetCurrentDeal
_TEXT	ENDS
PUBLIC	?GetHistoricDeal@CvGameDeals@@QAEPAVCvDeal@@W4PlayerTypes@@I@Z ; CvGameDeals::GetHistoricDeal
; Function compile flags: /Odtp
;	COMDAT ?GetHistoricDeal@CvGameDeals@@QAEPAVCvDeal@@W4PlayerTypes@@I@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T243228 = -16						; size = 4
_iCount$ = -12						; size = 4
_end$ = -8						; size = 4
_iter$ = -4						; size = 4
_ePlayer$ = 8						; size = 4
_index$ = 12						; size = 4
?GetHistoricDeal@CvGameDeals@@QAEPAVCvDeal@@W4PlayerTypes@@I@Z PROC ; CvGameDeals::GetHistoricDeal, COMDAT
; _this$ = ecx

; 3786 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 3787 : 	DealList::iterator iter;
; 3788 : 	DealList::iterator end = m_HistoricalDeals.end();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 3076				; 00000c04H
	mov	DWORD PTR $T243228[ebp], eax
	mov	ecx, DWORD PTR $T243228[ebp]
	mov	edx, DWORD PTR [ecx+4]
	imul	edx, 76					; 0000004cH
	mov	eax, DWORD PTR $T243228[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR _end$[ebp], edx

; 3789 : 
; 3790 : 	uint iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0

; 3791 : 	for(iter = m_HistoricalDeals.begin(); iter != end; ++iter)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+3076]
	mov	DWORD PTR _iter$[ebp], edx
	jmp	SHORT $LN5@GetHistori
$LN4@GetHistori:
	mov	eax, DWORD PTR _iter$[ebp]
	add	eax, 76					; 0000004cH
	mov	DWORD PTR _iter$[ebp], eax
$LN5@GetHistori:
	mov	ecx, DWORD PTR _iter$[ebp]
	cmp	ecx, DWORD PTR _end$[ebp]
	je	SHORT $LN3@GetHistori

; 3792 : 	{
; 3793 : 		if((iter->m_eToPlayer == ePlayer ||
; 3794 : 		        iter->m_eFromPlayer == ePlayer) &&
; 3795 : 		        (iCount++ == index))

	mov	edx, DWORD PTR _iter$[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	eax, DWORD PTR _ePlayer$[ebp]
	je	SHORT $LN1@GetHistori
	mov	ecx, DWORD PTR _iter$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _ePlayer$[ebp]
	jne	SHORT $LN2@GetHistori
$LN1@GetHistori:
	mov	eax, DWORD PTR _iCount$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	mov	edx, DWORD PTR _iCount$[ebp]
	add	edx, 1
	mov	DWORD PTR _iCount$[ebp], edx
	cmp	eax, ecx
	jne	SHORT $LN2@GetHistori

; 3796 : 		{
; 3797 : 			return &(*iter);

	mov	eax, DWORD PTR _iter$[ebp]
	jmp	SHORT $LN6@GetHistori
$LN2@GetHistori:

; 3798 : 		}
; 3799 : 	}

	jmp	SHORT $LN4@GetHistori
$LN3@GetHistori:

; 3800 : 
; 3801 : 	return NULL;

	xor	eax, eax
$LN6@GetHistori:

; 3802 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetHistoricDeal@CvGameDeals@@QAEPAVCvDeal@@W4PlayerTypes@@I@Z ENDP ; CvGameDeals::GetHistoricDeal
_TEXT	ENDS
PUBLIC	?GetNumCurrentDeals@CvGameDeals@@QAEIW4PlayerTypes@@@Z ; CvGameDeals::GetNumCurrentDeals
; Function compile flags: /Odtp
;	COMDAT ?GetNumCurrentDeals@CvGameDeals@@QAEIW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T243237 = -16						; size = 4
_iCount$ = -12						; size = 4
_end$ = -8						; size = 4
_iter$ = -4						; size = 4
_ePlayer$ = 8						; size = 4
?GetNumCurrentDeals@CvGameDeals@@QAEIW4PlayerTypes@@@Z PROC ; CvGameDeals::GetNumCurrentDeals, COMDAT
; _this$ = ecx

; 3808 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 3809 : 	DealList::iterator iter;
; 3810 : 	DealList::iterator end = m_CurrentDeals.end();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1540				; 00000604H
	mov	DWORD PTR $T243237[ebp], eax
	mov	ecx, DWORD PTR $T243237[ebp]
	mov	edx, DWORD PTR [ecx+4]
	imul	edx, 76					; 0000004cH
	mov	eax, DWORD PTR $T243237[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR _end$[ebp], edx

; 3811 : 
; 3812 : 	uint iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0

; 3813 : 	for(iter = m_CurrentDeals.begin(); iter != end; ++iter)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1540]
	mov	DWORD PTR _iter$[ebp], edx
	jmp	SHORT $LN5@GetNumCurr
$LN4@GetNumCurr:
	mov	eax, DWORD PTR _iter$[ebp]
	add	eax, 76					; 0000004cH
	mov	DWORD PTR _iter$[ebp], eax
$LN5@GetNumCurr:
	mov	ecx, DWORD PTR _iter$[ebp]
	cmp	ecx, DWORD PTR _end$[ebp]
	je	SHORT $LN3@GetNumCurr

; 3814 : 	{
; 3815 : 		if(iter->m_eToPlayer == ePlayer ||
; 3816 : 		        iter->m_eFromPlayer == ePlayer)

	mov	edx, DWORD PTR _iter$[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	eax, DWORD PTR _ePlayer$[ebp]
	je	SHORT $LN1@GetNumCurr
	mov	ecx, DWORD PTR _iter$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _ePlayer$[ebp]
	jne	SHORT $LN2@GetNumCurr
$LN1@GetNumCurr:

; 3817 : 		{
; 3818 : 			++iCount;

	mov	eax, DWORD PTR _iCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCount$[ebp], eax
$LN2@GetNumCurr:

; 3819 : 		}
; 3820 : 	}

	jmp	SHORT $LN4@GetNumCurr
$LN3@GetNumCurr:

; 3821 : 
; 3822 : 	return iCount;

	mov	eax, DWORD PTR _iCount$[ebp]

; 3823 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetNumCurrentDeals@CvGameDeals@@QAEIW4PlayerTypes@@@Z ENDP ; CvGameDeals::GetNumCurrentDeals
_TEXT	ENDS
PUBLIC	?GetNumHistoricDeals@CvGameDeals@@QAEIW4PlayerTypes@@@Z ; CvGameDeals::GetNumHistoricDeals
; Function compile flags: /Odtp
;	COMDAT ?GetNumHistoricDeals@CvGameDeals@@QAEIW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T243246 = -16						; size = 4
_iCount$ = -12						; size = 4
_end$ = -8						; size = 4
_iter$ = -4						; size = 4
_ePlayer$ = 8						; size = 4
?GetNumHistoricDeals@CvGameDeals@@QAEIW4PlayerTypes@@@Z PROC ; CvGameDeals::GetNumHistoricDeals, COMDAT
; _this$ = ecx

; 3830 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 3831 : 	DealList::iterator iter;
; 3832 : 	DealList::iterator end = m_HistoricalDeals.end();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 3076				; 00000c04H
	mov	DWORD PTR $T243246[ebp], eax
	mov	ecx, DWORD PTR $T243246[ebp]
	mov	edx, DWORD PTR [ecx+4]
	imul	edx, 76					; 0000004cH
	mov	eax, DWORD PTR $T243246[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR _end$[ebp], edx

; 3833 : 
; 3834 : 	uint iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0

; 3835 : 	for(iter = m_HistoricalDeals.begin(); iter != end; ++iter)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+3076]
	mov	DWORD PTR _iter$[ebp], edx
	jmp	SHORT $LN5@GetNumHist
$LN4@GetNumHist:
	mov	eax, DWORD PTR _iter$[ebp]
	add	eax, 76					; 0000004cH
	mov	DWORD PTR _iter$[ebp], eax
$LN5@GetNumHist:
	mov	ecx, DWORD PTR _iter$[ebp]
	cmp	ecx, DWORD PTR _end$[ebp]
	je	SHORT $LN3@GetNumHist

; 3836 : 	{
; 3837 : 		if(iter->m_eToPlayer == ePlayer ||
; 3838 : 		        iter->m_eFromPlayer == ePlayer)

	mov	edx, DWORD PTR _iter$[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	eax, DWORD PTR _ePlayer$[ebp]
	je	SHORT $LN1@GetNumHist
	mov	ecx, DWORD PTR _iter$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _ePlayer$[ebp]
	jne	SHORT $LN2@GetNumHist
$LN1@GetNumHist:

; 3839 : 		{
; 3840 : 			++iCount;

	mov	eax, DWORD PTR _iCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCount$[ebp], eax
$LN2@GetNumHist:

; 3841 : 		}
; 3842 : 	}

	jmp	SHORT $LN4@GetNumHist
$LN3@GetNumHist:

; 3843 : 
; 3844 : 	return iCount;

	mov	eax, DWORD PTR _iCount$[ebp]

; 3845 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetNumHistoricDeals@CvGameDeals@@QAEIW4PlayerTypes@@@Z ENDP ; CvGameDeals::GetNumHistoricDeals
_TEXT	ENDS
PUBLIC	?push_back@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAEXABU?$pair@IPAVCvDeal@@@2@@Z ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::push_back
PUBLIC	?CreateDeal@CvGameDeals@@QAEIXZ			; CvGameDeals::CreateDeal
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$?CreateDeal@CvGameDeals@@QAEIXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateDeal@CvGameDeals@@QAEIXZ$0
__ehfuncinfo$?CreateDeal@CvGameDeals@@QAEIXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CreateDeal@CvGameDeals@@QAEIXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?CreateDeal@CvGameDeals@@QAEIXZ
_TEXT	SEGMENT
tv77 = -100						; size = 4
_this$ = -96						; size = 4
$T243254 = -36						; size = 4
$T243253 = -32						; size = 4
$T243252 = -28						; size = 4
_entry$ = -24						; size = 8
_index$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?CreateDeal@CvGameDeals@@QAEIXZ PROC			; CvGameDeals::CreateDeal, COMDAT
; _this$ = ecx

; 3881 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CreateDeal@CvGameDeals@@QAEIXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3882 : 	uint index = m_uiDealCounter++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4704]
	mov	DWORD PTR _index$[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4704]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4704], eax

; 3883 : 	std::pair<uint, CvDeal*> entry(index, FNEW(CvDeal, c_eCiv5GameplayDLL, 0));

	push	76					; 0000004cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T243254[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T243254[ebp], 0
	je	SHORT $LN3@CreateDeal
	mov	ecx, DWORD PTR $T243254[ebp]
	call	??0CvDeal@@QAE@XZ			; CvDeal::CvDeal
	mov	DWORD PTR tv77[ebp], eax
	jmp	SHORT $LN4@CreateDeal
$LN3@CreateDeal:
	mov	DWORD PTR tv77[ebp], 0
$LN4@CreateDeal:
	mov	edx, DWORD PTR tv77[ebp]
	mov	DWORD PTR $T243253[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T243253[ebp]
	mov	DWORD PTR $T243252[ebp], eax
	mov	ecx, DWORD PTR _index$[ebp]
	mov	DWORD PTR _entry$[ebp], ecx
	mov	edx, DWORD PTR $T243252[ebp]
	mov	DWORD PTR _entry$[ebp+4], edx

; 3884 : 
; 3885 : 	m_Deals.push_back(entry);

	lea	eax, DWORD PTR _entry$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4688				; 00001250H
	call	?push_back@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAEXABU?$pair@IPAVCvDeal@@@2@@Z ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::push_back

; 3886 : 	return index;

	mov	eax, DWORD PTR _index$[ebp]

; 3887 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CreateDeal@CvGameDeals@@QAEIXZ$0:
	mov	eax, DWORD PTR $T243254[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?CreateDeal@CvGameDeals@@QAEIXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-92]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?CreateDeal@CvGameDeals@@QAEIXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?CreateDeal@CvGameDeals@@QAEIXZ ENDP			; CvGameDeals::CreateDeal
PUBLIC	?GetDeal@CvGameDeals@@QAEPAVCvDeal@@I@Z		; CvGameDeals::GetDeal
; Function compile flags: /Odtp
;	COMDAT ?GetDeal@CvGameDeals@@QAEPAVCvDeal@@I@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T243419 = -16						; size = 4
$T243395 = -12						; size = 4
$T243385 = -8						; size = 4
_it$223029 = -4						; size = 4
_index$ = 8						; size = 4
?GetDeal@CvGameDeals@@QAEPAVCvDeal@@I@Z PROC		; CvGameDeals::GetDeal, COMDAT
; _this$ = ecx

; 3890 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 3891 : 	for(std::vector<std::pair<uint, CvDeal*> >::iterator it = m_Deals.begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4692]
	mov	DWORD PTR $T243395[ebp], ecx
	mov	edx, DWORD PTR $T243395[ebp]
	mov	DWORD PTR _it$223029[ebp], edx

; 3892 : 	        it != m_Deals.end(); ++it)

	jmp	SHORT $LN4@GetDeal
$LN3@GetDeal:
	mov	eax, DWORD PTR _it$223029[ebp]
	add	eax, 8
	mov	DWORD PTR _it$223029[ebp], eax
$LN4@GetDeal:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4696]
	mov	DWORD PTR $T243419[ebp], edx
	mov	eax, DWORD PTR $T243419[ebp]
	mov	DWORD PTR $T243385[ebp], eax
	mov	ecx, DWORD PTR _it$223029[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T243385[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@GetDeal

; 3893 : 	{
; 3894 : 		if((*it).first == index)

	mov	edx, DWORD PTR _it$223029[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _index$[ebp]
	jne	SHORT $LN1@GetDeal

; 3895 : 			return (*it).second;

	mov	ecx, DWORD PTR _it$223029[ebp]
	mov	eax, DWORD PTR [ecx+4]
	jmp	SHORT $LN5@GetDeal
$LN1@GetDeal:

; 3896 : 	}

	jmp	SHORT $LN3@GetDeal
$LN2@GetDeal:

; 3897 : 
; 3898 : 	return NULL;

	xor	eax, eax
$LN5@GetDeal:

; 3899 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetDeal@CvGameDeals@@QAEPAVCvDeal@@I@Z ENDP		; CvGameDeals::GetDeal
_TEXT	ENDS
PUBLIC	?erase@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@@Z ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::erase
PUBLIC	?DestroyDeal@CvGameDeals@@QAEXI@Z		; CvGameDeals::DestroyDeal
; Function compile flags: /Odtp
;	COMDAT ?DestroyDeal@CvGameDeals@@QAEXI@Z
_TEXT	SEGMENT
tv151 = -112						; size = 4
_this$ = -108						; size = 4
$T243542 = -48						; size = 4
$T243510 = -44						; size = 4
$T243486 = -40						; size = 4
$T243470 = -36						; size = 4
$T243460 = -32						; size = 4
$T243459 = -28						; size = 4
$T243456 = -24						; size = 4
$T243455 = -20						; size = 4
$T243454 = -16						; size = 4
$T243453 = -12						; size = 4
$T243452 = -8						; size = 4
_it$ = -4						; size = 4
_index$ = 8						; size = 4
?DestroyDeal@CvGameDeals@@QAEXI@Z PROC			; CvGameDeals::DestroyDeal, COMDAT
; _this$ = ecx

; 3902 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	DWORD PTR _this$[ebp], ecx

; 3903 : 	std::vector<std::pair<uint, CvDeal*> >::iterator it = m_Deals.end();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4696]
	mov	DWORD PTR $T243470[ebp], ecx
	mov	edx, DWORD PTR $T243470[ebp]
	mov	DWORD PTR _it$[ebp], edx

; 3904 : 	for(it = m_Deals.begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4692]
	mov	DWORD PTR $T243486[ebp], ecx
	mov	edx, DWORD PTR $T243486[ebp]
	mov	DWORD PTR $T243452[ebp], edx
	mov	eax, DWORD PTR $T243452[ebp]
	mov	DWORD PTR _it$[ebp], eax
	jmp	SHORT $LN5@DestroyDea
$LN4@DestroyDea:

; 3905 : 	        it != m_Deals.end(); ++it)

	mov	ecx, DWORD PTR _it$[ebp]
	add	ecx, 8
	mov	DWORD PTR _it$[ebp], ecx
$LN5@DestroyDea:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4696]
	mov	DWORD PTR $T243510[ebp], eax
	mov	ecx, DWORD PTR $T243510[ebp]
	mov	DWORD PTR $T243453[ebp], ecx
	mov	edx, DWORD PTR _it$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T243453[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN3@DestroyDea

; 3906 : 	{
; 3907 : 		if((*it).first == index)

	mov	eax, DWORD PTR _it$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _index$[ebp]
	jne	SHORT $LN2@DestroyDea

; 3908 : 			break;

	jmp	SHORT $LN3@DestroyDea
$LN2@DestroyDea:

; 3909 : 	}

	jmp	SHORT $LN4@DestroyDea
$LN3@DestroyDea:

; 3910 : 
; 3911 : 	if(it != m_Deals.end())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4696]
	mov	DWORD PTR $T243542[ebp], eax
	mov	ecx, DWORD PTR $T243542[ebp]
	mov	DWORD PTR $T243454[ebp], ecx
	mov	edx, DWORD PTR _it$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T243454[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN6@DestroyDea

; 3912 : 	{
; 3913 : 		delete(*it).second;

	mov	eax, DWORD PTR _it$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T243456[ebp], ecx
	mov	edx, DWORD PTR $T243456[ebp]
	mov	DWORD PTR $T243455[ebp], edx
	cmp	DWORD PTR $T243455[ebp], 0
	je	SHORT $LN8@DestroyDea
	push	1
	mov	eax, DWORD PTR $T243455[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T243455[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv151[ebp], eax
	jmp	SHORT $LN9@DestroyDea
$LN8@DestroyDea:
	mov	DWORD PTR tv151[ebp], 0
$LN9@DestroyDea:

; 3914 : 		m_Deals.erase(it);

	mov	ecx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T243459[ebp], ecx
	mov	edx, DWORD PTR $T243459[ebp]
	push	edx
	lea	eax, DWORD PTR $T243460[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4688				; 00001250H
	call	?erase@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@@Z ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::erase
$LN6@DestroyDea:

; 3915 : 	}
; 3916 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?DestroyDeal@CvGameDeals@@QAEXI@Z ENDP			; CvGameDeals::DestroyDeal
_TEXT	ENDS
PUBLIC	?OldLoad@@YAAAVFDataStream@@AAV1@AAVCvGameDeals@@@Z ; OldLoad
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__unwindtable$?OldLoad@@YAAAVFDataStream@@AAV1@AAVCvGameDeals@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OldLoad@@YAAAVFDataStream@@AAV1@AAVCvGameDeals@@@Z$0
__ehfuncinfo$?OldLoad@@YAAAVFDataStream@@AAV1@AAVCvGameDeals@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?OldLoad@@YAAAVFDataStream@@AAV1@AAVCvGameDeals@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ?OldLoad@@YAAAVFDataStream@@AAV1@AAVCvGameDeals@@@Z
_TEXT	SEGMENT
$T243759 = -176						; size = 4
$T243732 = -152						; size = 4
$T243705 = -128						; size = 4
$T243686 = -112						; size = 4
_iI$223074 = -108					; size = 4
_iI$223070 = -104					; size = 4
_iI$223066 = -100					; size = 4
_iEntriesToRead$ = -96					; size = 4
_tempItem$ = -92					; size = 76
__$EHRec$ = -12						; size = 12
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
?OldLoad@@YAAAVFDataStream@@AAV1@AAVCvGameDeals@@@Z PROC ; OldLoad, COMDAT

; 3919 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?OldLoad@@YAAAVFDataStream@@AAV1@AAVCvGameDeals@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 172				; 000000acH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 3920 : 	int iEntriesToRead;
; 3921 : 	CvDeal tempItem;

	lea	ecx, DWORD PTR _tempItem$[ebp]
	call	??0CvDeal@@QAE@XZ			; CvDeal::CvDeal
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3922 : 
; 3923 : 	writeTo.m_ProposedDeals.clear();

	mov	ecx, DWORD PTR _writeTo$[ebp]
	add	ecx, 4
	call	?clear@?$BaseVector@VCvDeal@@$0A@@@QAEXXZ ; BaseVector<CvDeal,0>::clear

; 3924 : 	loadFrom >> iEntriesToRead;

	lea	eax, DWORD PTR _iEntriesToRead$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3925 : 	for(int iI = 0; iI < iEntriesToRead; iI++)

	mov	DWORD PTR _iI$223066[ebp], 0
	jmp	SHORT $LN9@OldLoad@2
$LN8@OldLoad@2:
	mov	ecx, DWORD PTR _iI$223066[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$223066[ebp], ecx
$LN9@OldLoad@2:
	mov	edx, DWORD PTR _iI$223066[ebp]
	cmp	edx, DWORD PTR _iEntriesToRead$[ebp]
	jge	SHORT $LN7@OldLoad@2

; 3926 : 	{
; 3927 : 		loadFrom = OldLoad(loadFrom, tempItem);

	lea	eax, DWORD PTR _tempItem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	push	ecx
	call	?OldLoad@@YAAAVFDataStream@@AAV1@AAVCvDeal@@@Z ; OldLoad
	add	esp, 8
	mov	DWORD PTR $T243705[ebp], eax
	mov	edx, DWORD PTR _loadFrom$[ebp]
	mov	eax, DWORD PTR $T243705[ebp]
	mov	cl, BYTE PTR [eax+4]
	mov	BYTE PTR [edx+4], cl
	mov	edx, DWORD PTR _loadFrom$[ebp]
	mov	eax, DWORD PTR $T243705[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	edx, DWORD PTR _loadFrom$[ebp]
	mov	eax, DWORD PTR $T243705[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], ecx
	mov	edx, DWORD PTR _loadFrom$[ebp]
	mov	eax, DWORD PTR $T243705[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], ecx

; 3928 : 		writeTo.m_ProposedDeals.push_back(tempItem);

	lea	edx, DWORD PTR _tempItem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _writeTo$[ebp]
	add	ecx, 4
	call	?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z ; FStaticVector<CvDeal,20,0,297,0>::push_back

; 3929 : 	}

	jmp	SHORT $LN8@OldLoad@2
$LN7@OldLoad@2:

; 3930 : 
; 3931 : 	writeTo.m_CurrentDeals.clear();

	mov	ecx, DWORD PTR _writeTo$[ebp]
	add	ecx, 1540				; 00000604H
	call	?clear@?$BaseVector@VCvDeal@@$0A@@@QAEXXZ ; BaseVector<CvDeal,0>::clear

; 3932 : 	loadFrom >> iEntriesToRead;

	lea	eax, DWORD PTR _iEntriesToRead$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3933 : 	for(int iI = 0; iI < iEntriesToRead; iI++)

	mov	DWORD PTR _iI$223070[ebp], 0
	jmp	SHORT $LN6@OldLoad@2
$LN5@OldLoad@2:
	mov	ecx, DWORD PTR _iI$223070[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$223070[ebp], ecx
$LN6@OldLoad@2:
	mov	edx, DWORD PTR _iI$223070[ebp]
	cmp	edx, DWORD PTR _iEntriesToRead$[ebp]
	jge	SHORT $LN4@OldLoad@2

; 3934 : 	{
; 3935 : 		loadFrom = OldLoad(loadFrom, tempItem);

	lea	eax, DWORD PTR _tempItem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	push	ecx
	call	?OldLoad@@YAAAVFDataStream@@AAV1@AAVCvDeal@@@Z ; OldLoad
	add	esp, 8
	mov	DWORD PTR $T243732[ebp], eax
	mov	edx, DWORD PTR _loadFrom$[ebp]
	mov	eax, DWORD PTR $T243732[ebp]
	mov	cl, BYTE PTR [eax+4]
	mov	BYTE PTR [edx+4], cl
	mov	edx, DWORD PTR _loadFrom$[ebp]
	mov	eax, DWORD PTR $T243732[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	edx, DWORD PTR _loadFrom$[ebp]
	mov	eax, DWORD PTR $T243732[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], ecx
	mov	edx, DWORD PTR _loadFrom$[ebp]
	mov	eax, DWORD PTR $T243732[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], ecx

; 3936 : 		writeTo.m_CurrentDeals.push_back(tempItem);

	lea	edx, DWORD PTR _tempItem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _writeTo$[ebp]
	add	ecx, 1540				; 00000604H
	call	?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z ; FStaticVector<CvDeal,20,0,297,0>::push_back

; 3937 : 	}

	jmp	SHORT $LN5@OldLoad@2
$LN4@OldLoad@2:

; 3938 : 
; 3939 : 	writeTo.m_HistoricalDeals.clear();

	mov	ecx, DWORD PTR _writeTo$[ebp]
	add	ecx, 3076				; 00000c04H
	call	?clear@?$BaseVector@VCvDeal@@$0A@@@QAEXXZ ; BaseVector<CvDeal,0>::clear

; 3940 : 	loadFrom >> iEntriesToRead;

	lea	eax, DWORD PTR _iEntriesToRead$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3941 : 	for(int iI = 0; iI < iEntriesToRead; iI++)

	mov	DWORD PTR _iI$223074[ebp], 0
	jmp	SHORT $LN3@OldLoad@2
$LN2@OldLoad@2:
	mov	ecx, DWORD PTR _iI$223074[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$223074[ebp], ecx
$LN3@OldLoad@2:
	mov	edx, DWORD PTR _iI$223074[ebp]
	cmp	edx, DWORD PTR _iEntriesToRead$[ebp]
	jge	SHORT $LN1@OldLoad@2

; 3942 : 	{
; 3943 : 		loadFrom = OldLoad(loadFrom, tempItem);

	lea	eax, DWORD PTR _tempItem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	push	ecx
	call	?OldLoad@@YAAAVFDataStream@@AAV1@AAVCvDeal@@@Z ; OldLoad
	add	esp, 8
	mov	DWORD PTR $T243759[ebp], eax
	mov	edx, DWORD PTR _loadFrom$[ebp]
	mov	eax, DWORD PTR $T243759[ebp]
	mov	cl, BYTE PTR [eax+4]
	mov	BYTE PTR [edx+4], cl
	mov	edx, DWORD PTR _loadFrom$[ebp]
	mov	eax, DWORD PTR $T243759[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	edx, DWORD PTR _loadFrom$[ebp]
	mov	eax, DWORD PTR $T243759[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], ecx
	mov	edx, DWORD PTR _loadFrom$[ebp]
	mov	eax, DWORD PTR $T243759[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], ecx

; 3944 : 		writeTo.m_HistoricalDeals.push_back(tempItem);

	lea	edx, DWORD PTR _tempItem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _writeTo$[ebp]
	add	ecx, 3076				; 00000c04H
	call	?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z ; FStaticVector<CvDeal,20,0,297,0>::push_back

; 3945 : 	}

	jmp	SHORT $LN2@OldLoad@2
$LN1@OldLoad@2:

; 3946 : 
; 3947 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 3948 : 	writeTo.m_CurrentlyEndingDeals.clear();
; 3949 : 	loadFrom >> iEntriesToRead;
; 3950 : 	for (int iI = 0; iI < iEntriesToRead; iI++)
; 3951 : 	{
; 3952 : 		loadFrom = OldLoad(loadFrom, tempItem);
; 3953 : 		writeTo.m_CurrentlyEndingDeals.push_back(tempItem);
; 3954 : 	}
; 3955 : #endif
; 3956 : 
; 3957 : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]
	mov	DWORD PTR $T243686[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tempItem$[ebp]
	call	??1CvDeal@@UAE@XZ			; CvDeal::~CvDeal
	mov	eax, DWORD PTR $T243686[ebp]

; 3958 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?OldLoad@@YAAAVFDataStream@@AAV1@AAVCvGameDeals@@@Z$0:
	lea	ecx, DWORD PTR _tempItem$[ebp]
	jmp	??1CvDeal@@UAE@XZ			; CvDeal::~CvDeal
__ehhandler$?OldLoad@@YAAAVFDataStream@@AAV1@AAVCvGameDeals@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-176]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?OldLoad@@YAAAVFDataStream@@AAV1@AAVCvGameDeals@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?OldLoad@@YAAAVFDataStream@@AAV1@AAVCvGameDeals@@@Z ENDP ; OldLoad
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAVCvGameDeals@@@Z	; operator>>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__unwindtable$??5@YAAAVFDataStream@@AAV0@AAVCvGameDeals@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??5@YAAAVFDataStream@@AAV0@AAVCvGameDeals@@@Z$0
__ehfuncinfo$??5@YAAAVFDataStream@@AAV0@AAVCvGameDeals@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??5@YAAAVFDataStream@@AAV0@AAVCvGameDeals@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealclasses.cpp
xdata$x	ENDS
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAVCvGameDeals@@@Z
_TEXT	SEGMENT
$T243777 = -116						; size = 4
_iI$223097 = -112					; size = 4
_iI$223093 = -108					; size = 4
_iI$223086 = -104					; size = 4
_iEntriesToRead$ = -100					; size = 4
_uiVersion$ = -96					; size = 4
_tempItem$ = -92					; size = 76
__$EHRec$ = -12						; size = 12
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAVCvGameDeals@@@Z PROC	; operator>>, COMDAT

; 3962 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??5@YAAAVFDataStream@@AAV0@AAVCvGameDeals@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 184				; 000000b8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 3963 : 	uint uiVersion;
; 3964 : 	int iEntriesToRead;
; 3965 : 	CvDeal tempItem;

	lea	ecx, DWORD PTR _tempItem$[ebp]
	call	??0CvDeal@@QAE@XZ			; CvDeal::CvDeal
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3966 : 
; 3967 : 	loadFrom >> uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 3968 : 
; 3969 : 	writeTo.m_ProposedDeals.clear();

	mov	ecx, DWORD PTR _writeTo$[ebp]
	add	ecx, 4
	call	?clear@?$BaseVector@VCvDeal@@$0A@@@QAEXXZ ; BaseVector<CvDeal,0>::clear

; 3970 : 	loadFrom >> iEntriesToRead;

	lea	ecx, DWORD PTR _iEntriesToRead$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3971 : 	for(int iI = 0; iI < iEntriesToRead; iI++)

	mov	DWORD PTR _iI$223086[ebp], 0
	jmp	SHORT $LN9@operator@6
$LN8@operator@6:
	mov	edx, DWORD PTR _iI$223086[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$223086[ebp], edx
$LN9@operator@6:
	mov	eax, DWORD PTR _iI$223086[ebp]
	cmp	eax, DWORD PTR _iEntriesToRead$[ebp]
	jge	SHORT $LN7@operator@6

; 3972 : 	{
; 3973 : 		loadFrom >> tempItem;

	lea	ecx, DWORD PTR _tempItem$[ebp]
	push	ecx
	mov	edx, DWORD PTR _loadFrom$[ebp]
	push	edx
	call	??5@YAAAVFDataStream@@AAV0@AAVCvDeal@@@Z ; operator>>
	add	esp, 8

; 3974 : 		writeTo.m_ProposedDeals.push_back(tempItem);

	lea	eax, DWORD PTR _tempItem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _writeTo$[ebp]
	add	ecx, 4
	call	?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z ; FStaticVector<CvDeal,20,0,297,0>::push_back

; 3975 : 	}

	jmp	SHORT $LN8@operator@6
$LN7@operator@6:

; 3976 : 
; 3977 : 	writeTo.m_CurrentDeals.clear();

	mov	ecx, DWORD PTR _writeTo$[ebp]
	add	ecx, 1540				; 00000604H
	call	?clear@?$BaseVector@VCvDeal@@$0A@@@QAEXXZ ; BaseVector<CvDeal,0>::clear

; 3978 : 	loadFrom >> iEntriesToRead;

	lea	ecx, DWORD PTR _iEntriesToRead$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3979 : 	for(int iI = 0; iI < iEntriesToRead; iI++)

	mov	DWORD PTR _iI$223093[ebp], 0
	jmp	SHORT $LN6@operator@6
$LN5@operator@6:
	mov	edx, DWORD PTR _iI$223093[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$223093[ebp], edx
$LN6@operator@6:
	mov	eax, DWORD PTR _iI$223093[ebp]
	cmp	eax, DWORD PTR _iEntriesToRead$[ebp]
	jge	SHORT $LN4@operator@6

; 3980 : 	{
; 3981 : 		loadFrom >> tempItem;

	lea	ecx, DWORD PTR _tempItem$[ebp]
	push	ecx
	mov	edx, DWORD PTR _loadFrom$[ebp]
	push	edx
	call	??5@YAAAVFDataStream@@AAV0@AAVCvDeal@@@Z ; operator>>
	add	esp, 8

; 3982 : 		writeTo.m_CurrentDeals.push_back(tempItem);

	lea	eax, DWORD PTR _tempItem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _writeTo$[ebp]
	add	ecx, 1540				; 00000604H
	call	?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z ; FStaticVector<CvDeal,20,0,297,0>::push_back

; 3983 : 	}

	jmp	SHORT $LN5@operator@6
$LN4@operator@6:

; 3984 : 
; 3985 : 	writeTo.m_HistoricalDeals.clear();

	mov	ecx, DWORD PTR _writeTo$[ebp]
	add	ecx, 3076				; 00000c04H
	call	?clear@?$BaseVector@VCvDeal@@$0A@@@QAEXXZ ; BaseVector<CvDeal,0>::clear

; 3986 : 	loadFrom >> iEntriesToRead;

	lea	ecx, DWORD PTR _iEntriesToRead$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3987 : 	for(int iI = 0; iI < iEntriesToRead; iI++)

	mov	DWORD PTR _iI$223097[ebp], 0
	jmp	SHORT $LN3@operator@6
$LN2@operator@6:
	mov	edx, DWORD PTR _iI$223097[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$223097[ebp], edx
$LN3@operator@6:
	mov	eax, DWORD PTR _iI$223097[ebp]
	cmp	eax, DWORD PTR _iEntriesToRead$[ebp]
	jge	SHORT $LN1@operator@6

; 3988 : 	{
; 3989 : 		loadFrom >> tempItem;

	lea	ecx, DWORD PTR _tempItem$[ebp]
	push	ecx
	mov	edx, DWORD PTR _loadFrom$[ebp]
	push	edx
	call	??5@YAAAVFDataStream@@AAV0@AAVCvDeal@@@Z ; operator>>
	add	esp, 8

; 3990 : 		writeTo.m_HistoricalDeals.push_back(tempItem);

	lea	eax, DWORD PTR _tempItem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _writeTo$[ebp]
	add	ecx, 3076				; 00000c04H
	call	?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z ; FStaticVector<CvDeal,20,0,297,0>::push_back

; 3991 : 	}

	jmp	SHORT $LN2@operator@6
$LN1@operator@6:

; 3992 : 
; 3993 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 3994 : 	writeTo.m_CurrentlyEndingDeals.clear();
; 3995 : 	loadFrom >> iEntriesToRead;
; 3996 : 	for (int iI = 0; iI < iEntriesToRead; iI++)
; 3997 : 	{
; 3998 : 		loadFrom >> tempItem;
; 3999 : 		writeTo.m_CurrentlyEndingDeals.push_back(tempItem);
; 4000 : 	}
; 4001 : #endif
; 4002 : 
; 4003 : 	return loadFrom;

	mov	ecx, DWORD PTR _loadFrom$[ebp]
	mov	DWORD PTR $T243777[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tempItem$[ebp]
	call	??1CvDeal@@UAE@XZ			; CvDeal::~CvDeal
	mov	eax, DWORD PTR $T243777[ebp]

; 4004 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??5@YAAAVFDataStream@@AAV0@AAVCvGameDeals@@@Z$0:
	lea	ecx, DWORD PTR _tempItem$[ebp]
	jmp	??1CvDeal@@UAE@XZ			; CvDeal::~CvDeal
__ehhandler$??5@YAAAVFDataStream@@AAV0@AAVCvGameDeals@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-188]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??5@YAAAVFDataStream@@AAV0@AAVCvGameDeals@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??5@YAAAVFDataStream@@AAV0@AAVCvGameDeals@@@Z ENDP	; operator>>
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABVCvGameDeals@@@Z	; operator<<
; Function compile flags: /Odtp
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABVCvGameDeals@@@Z
_TEXT	SEGMENT
$T243915 = -44						; size = 4
$T243905 = -40						; size = 4
$T243901 = -36						; size = 4
$T243891 = -32						; size = 4
$T243887 = -28						; size = 4
$T243877 = -24						; size = 4
$T243870 = -20						; size = 4
$T243869 = -16						; size = 4
$T243868 = -12						; size = 4
_uiVersion$ = -8					; size = 4
_it$ = -4						; size = 4
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABVCvGameDeals@@@Z PROC	; operator<<, COMDAT

; 4008 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 4009 : 	uint uiVersion = 1;

	mov	DWORD PTR _uiVersion$[ebp], 1

; 4010 : 	DealList::const_iterator it;
; 4011 : 	saveTo << uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 4012 : 
; 4013 : 	saveTo << readFrom.m_ProposedDeals.size();

	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T243877[ebp], edx
	mov	eax, DWORD PTR $T243877[ebp]
	mov	DWORD PTR $T243868[ebp], eax
	lea	ecx, DWORD PTR $T243868[ebp]
	push	ecx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 4014 : 	for(it = readFrom.m_ProposedDeals.begin(); it != readFrom.m_ProposedDeals.end(); ++it)

	mov	edx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _it$[ebp], eax
	jmp	SHORT $LN9@operator@7
$LN8@operator@7:
	mov	ecx, DWORD PTR _it$[ebp]
	add	ecx, 76					; 0000004cH
	mov	DWORD PTR _it$[ebp], ecx
$LN9@operator@7:
	mov	edx, DWORD PTR _readFrom$[ebp]
	add	edx, 4
	mov	DWORD PTR $T243887[ebp], edx
	mov	eax, DWORD PTR $T243887[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 76					; 0000004cH
	mov	edx, DWORD PTR $T243887[ebp]
	add	ecx, DWORD PTR [edx]
	cmp	DWORD PTR _it$[ebp], ecx
	je	SHORT $LN7@operator@7

; 4015 : 	{
; 4016 : 		saveTo << *it;

	mov	eax, DWORD PTR _it$[ebp]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	push	ecx
	call	??6@YAAAVFDataStream@@AAV0@ABVCvDeal@@@Z ; operator<<
	add	esp, 8

; 4017 : 	}

	jmp	SHORT $LN8@operator@7
$LN7@operator@7:

; 4018 : 	saveTo << readFrom.m_CurrentDeals.size();

	mov	edx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR [edx+1544]
	mov	DWORD PTR $T243891[ebp], eax
	mov	ecx, DWORD PTR $T243891[ebp]
	mov	DWORD PTR $T243869[ebp], ecx
	lea	edx, DWORD PTR $T243869[ebp]
	push	edx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 4019 : 	for(it = readFrom.m_CurrentDeals.begin(); it != readFrom.m_CurrentDeals.end(); ++it)

	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [eax+1540]
	mov	DWORD PTR _it$[ebp], ecx
	jmp	SHORT $LN6@operator@7
$LN5@operator@7:
	mov	edx, DWORD PTR _it$[ebp]
	add	edx, 76					; 0000004cH
	mov	DWORD PTR _it$[ebp], edx
$LN6@operator@7:
	mov	eax, DWORD PTR _readFrom$[ebp]
	add	eax, 1540				; 00000604H
	mov	DWORD PTR $T243901[ebp], eax
	mov	ecx, DWORD PTR $T243901[ebp]
	mov	edx, DWORD PTR [ecx+4]
	imul	edx, 76					; 0000004cH
	mov	eax, DWORD PTR $T243901[ebp]
	add	edx, DWORD PTR [eax]
	cmp	DWORD PTR _it$[ebp], edx
	je	SHORT $LN4@operator@7

; 4020 : 	{
; 4021 : 		saveTo << *it;

	mov	ecx, DWORD PTR _it$[ebp]
	push	ecx
	mov	edx, DWORD PTR _saveTo$[ebp]
	push	edx
	call	??6@YAAAVFDataStream@@AAV0@ABVCvDeal@@@Z ; operator<<
	add	esp, 8

; 4022 : 	}

	jmp	SHORT $LN5@operator@7
$LN4@operator@7:

; 4023 : 	saveTo << readFrom.m_HistoricalDeals.size();

	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [eax+3080]
	mov	DWORD PTR $T243905[ebp], ecx
	mov	edx, DWORD PTR $T243905[ebp]
	mov	DWORD PTR $T243870[ebp], edx
	lea	eax, DWORD PTR $T243870[ebp]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 4024 : 	for(it = readFrom.m_HistoricalDeals.begin(); it != readFrom.m_HistoricalDeals.end(); ++it)

	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+3076]
	mov	DWORD PTR _it$[ebp], edx
	jmp	SHORT $LN3@operator@7
$LN2@operator@7:
	mov	eax, DWORD PTR _it$[ebp]
	add	eax, 76					; 0000004cH
	mov	DWORD PTR _it$[ebp], eax
$LN3@operator@7:
	mov	ecx, DWORD PTR _readFrom$[ebp]
	add	ecx, 3076				; 00000c04H
	mov	DWORD PTR $T243915[ebp], ecx
	mov	edx, DWORD PTR $T243915[ebp]
	mov	eax, DWORD PTR [edx+4]
	imul	eax, 76					; 0000004cH
	mov	ecx, DWORD PTR $T243915[ebp]
	add	eax, DWORD PTR [ecx]
	cmp	DWORD PTR _it$[ebp], eax
	je	SHORT $LN1@operator@7

; 4025 : 	{
; 4026 : 		saveTo << *it;

	mov	edx, DWORD PTR _it$[ebp]
	push	edx
	mov	eax, DWORD PTR _saveTo$[ebp]
	push	eax
	call	??6@YAAAVFDataStream@@AAV0@ABVCvDeal@@@Z ; operator<<
	add	esp, 8

; 4027 : 	}

	jmp	SHORT $LN2@operator@7
$LN1@operator@7:

; 4028 : 
; 4029 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 4030 : 	saveTo << readFrom.m_CurrentlyEndingDeals.size();
; 4031 : 	for (it = readFrom.m_CurrentlyEndingDeals.begin(); it != readFrom.m_CurrentlyEndingDeals.end(); ++it)
; 4032 : 	{
; 4033 : 		saveTo << *it;
; 4034 : 	}
; 4035 : #endif
; 4036 : 
; 4037 : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 4038 : }

	mov	esp, ebp
	pop	ebp
	ret	0
??6@YAAAVFDataStream@@AAV0@ABVCvGameDeals@@@Z ENDP	; operator<<
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
_TEXT	ENDS
;	COMDAT ?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T243947 = -8						; size = 4
$T243919 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ PROC ; FFastList<CvTradedItem,21,0>::begin, COMDAT
; _this$ = ecx

; 199  : 	iterator begin(){ return iterator( m_uiFirst, this ); };

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T243919[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR $T243947[ebp], ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR $T243947[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR $T243919[ebp]
	or	eax, 1
	mov	DWORD PTR $T243919[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ENDP ; FFastList<CvTradedItem,21,0>::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T243951 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ PROC ; FFastList<CvTradedItem,21,0>::end, COMDAT
; _this$ = ecx

; 200  : 	iterator end(){ return iterator( ANCHOR_NODE_INDEX, this ); };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T243951[ebp], 0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx+4], 268435455		; 0fffffffH
	mov	eax, DWORD PTR $T243951[ebp]
	or	eax, 1
	mov	DWORD PTR $T243951[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ENDP ; FFastList<CvTradedItem,21,0>::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QBE?AVconst_iterator@1@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T244010 = -8						; size = 4
$T243982 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QBE?AVconst_iterator@1@XZ PROC ; FFastList<CvTradedItem,21,0>::begin, COMDAT
; _this$ = ecx

; 201  : 	const_iterator begin() const{ return const_iterator( m_uiFirst, this ); };

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T243982[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR $T244010[ebp], ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR $T244010[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR $T243982[ebp]
	or	eax, 1
	mov	DWORD PTR $T243982[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QBE?AVconst_iterator@1@XZ ENDP ; FFastList<CvTradedItem,21,0>::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QBE?AVconst_iterator@1@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T244014 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QBE?AVconst_iterator@1@XZ PROC ; FFastList<CvTradedItem,21,0>::end, COMDAT
; _this$ = ecx

; 202  : 	const_iterator end() const{ return const_iterator( ANCHOR_NODE_INDEX, this ); };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T244014[ebp], 0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx+4], 268435455		; 0fffffffH
	mov	eax, DWORD PTR $T244014[ebp]
	or	eax, 1
	mov	DWORD PTR $T244014[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QBE?AVconst_iterator@1@XZ ENDP ; FFastList<CvTradedItem,21,0>::end
_TEXT	ENDS
PUBLIC	??1iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::~iterator
PUBLIC	?erase@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE?AViterator@1@V21@@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::erase
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?erase@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@V21@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@V21@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?erase@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@V21@@Z$1
__ehfuncinfo$?erase@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@V21@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?erase@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@V21@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?erase@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@V21@@Z
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T244057 = -48						; size = 4
$T244056 = -44						; size = 4
$T244051 = -40						; size = 4
$T244048 = -36						; size = 8
$T244045 = -28						; size = 8
$T244044 = -20						; size = 8
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_it$ = 12						; size = 8
?erase@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@V21@@Z PROC ; FFastList<CvTradedItem,21,0>::erase, COMDAT
; _this$ = ecx

; 226  : 	iterator erase( iterator it ){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?erase@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@V21@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T244051[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 227  : 		return iterator( BASE_TYPE::erase( it ).get_index(), this );

	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T244044[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	mov	DWORD PTR $T244044[ebp+4], ecx
	mov	edx, DWORD PTR $T244044[ebp]
	mov	DWORD PTR $T244048[ebp], edx
	mov	eax, DWORD PTR $T244044[ebp+4]
	mov	DWORD PTR $T244048[ebp+4], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR $T244048[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T244048[ebp]
	push	edx
	lea	eax, DWORD PTR $T244045[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE?AViterator@1@V21@@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::erase
	mov	DWORD PTR $T244056[ebp], eax
	mov	ecx, DWORD PTR $T244056[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T244057[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR $T244057[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR $T244051[ebp]
	or	ecx, 1
	mov	DWORD PTR $T244051[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 228  : 	};

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@V21@@Z$0:
	lea	ecx, DWORD PTR _it$[ebp]
	jmp	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
__unwindfunclet$?erase@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@V21@@Z$1:
	lea	ecx, DWORD PTR $T244044[ebp]
	jmp	??1iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::~iterator
__ehhandler$?erase@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@V21@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?erase@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@V21@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@V21@@Z ENDP ; FFastList<CvTradedItem,21,0>::erase
PUBLIC	??1?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE@XZ ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::~FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>
; Function compile flags: /Odtp
;	COMDAT ??1?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@IAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T244147 = -8						; size = 4
_i$244155 = -4						; size = 4
??1?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@IAE@XZ PROC ; FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> >::~FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> >, COMDAT
; _this$ = ecx

; 700  : 	~FCustomList_Tail_Member(){ m_kAllocator.clear(); };

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 268435455		; 0fffffffH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	mov	DWORD PTR $T244147[ebp], ecx
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN12@FCustomLis
	mov	DWORD PTR _i$244155[ebp], 0
	jmp	SHORT $LN10@FCustomLis
$LN9@FCustomLis:
	mov	eax, DWORD PTR _i$244155[ebp]
	add	eax, 1
	mov	DWORD PTR _i$244155[ebp], eax
$LN10@FCustomLis:
	mov	ecx, DWORD PTR $T244147[ebp]
	mov	edx, DWORD PTR _i$244155[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jae	SHORT $LN12@FCustomLis
	jmp	SHORT $LN9@FCustomLis
$LN12@FCustomLis:
	mov	eax, DWORD PTR $T244147[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE@XZ ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::~FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@IAE@XZ ENDP ; FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> >::~FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> >
_TEXT	ENDS
PUBLIC	??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ ; `string'
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ DB 'd:\sources\'
	DB	'lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\FF'
	DB	'astVector.h', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T244221 = -20						; size = 4
_pRet$244217 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvDeal,20,0,297,0>::FStaticVector<CvDeal,20,0,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 20			; 00000014H

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T244221[ebp], edx
	cmp	DWORD PTR $T244221[ebp], 20		; 00000014H
	jbe	SHORT $LN7@FStaticVec
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T244221[ebp]
	imul	eax, 76					; 0000004cH
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$244217[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T244221[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec
$LN7@FStaticVec:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$244217[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 20			; 00000014H
$LN8@FStaticVec:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$244217[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@VCvDeal@@$0A@@@QAE@XZ	; BaseVector<CvDeal,0>::~BaseVector<CvDeal,0>
__ehhandler$??0?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvDeal,20,0,297,0>::FStaticVector<CvDeal,20,0,297,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvDeal,20,0,297,0>::~FStaticVector<CvDeal,20,0,297,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Free@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXPAVCvDeal@@I@Z ; FStaticVector<CvDeal,20,0,297,0>::Free

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@VCvDeal@@$0A@@@QAE@XZ	; BaseVector<CvDeal,0>::~BaseVector<CvDeal,0>
__ehhandler$??1?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvDeal,20,0,297,0>::~FStaticVector<CvDeal,20,0,297,0>
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?GrowSize@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvDeal,20,0,297,0>::GrowSize
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__unwindtable$?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z$0
__ehfuncinfo$?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	ENDS
;	COMDAT ?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z
_TEXT	SEGMENT
tv157 = -64						; size = 4
tv149 = -60						; size = 4
_this$ = -56						; size = 4
$T244252 = -20						; size = 4
$T244251 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_element$ = 8						; size = 4
?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z PROC ; FStaticVector<CvDeal,20,0,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1532], 0

; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN37@push_back

; 679  : 			GrowSize(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvDeal,20,0,297,0>::GrowSize

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN37@push_back:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 76					; 0000004cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T244252[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T244252[ebp], 0
	je	SHORT $LN4@push_back
	mov	eax, DWORD PTR _element$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T244252[ebp]
	call	??0CvDeal@@QAE@ABV0@@Z			; CvDeal::CvDeal
	mov	DWORD PTR tv149[ebp], eax
	jmp	SHORT $LN5@push_back
$LN4@push_back:
	mov	DWORD PTR tv149[ebp], 0
$LN5@push_back:
	mov	ecx, DWORD PTR tv149[ebp]
	mov	DWORD PTR $T244251[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 681  : 		return m_uiCurrSize++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR tv157[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR tv157[ebp]

; 682  : 	};

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z$0:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 76					; 0000004cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR $T244252[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?push_back@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@QAEIABVCvDeal@@@Z ENDP ; FStaticVector<CvDeal,20,0,297,0>::push_back
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 63   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 64   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
_TEXT	ENDS
;	COMDAT ?clear@?$BaseVector@VCvDeal@@$0A@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T244303 = -12						; size = 4
$T244302 = -8						; size = 4
_i$244297 = -4						; size = 4
?clear@?$BaseVector@VCvDeal@@$0A@@@QAEXXZ PROC		; BaseVector<CvDeal,0>::clear, COMDAT
; _this$ = ecx

; 120  : 	void clear(){

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T244303[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T244302[ebp], eax
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN7@clear
	mov	DWORD PTR _i$244297[ebp], 0
	jmp	SHORT $LN5@clear
$LN4@clear:
	mov	edx, DWORD PTR _i$244297[ebp]
	add	edx, 1
	mov	DWORD PTR _i$244297[ebp], edx
$LN5@clear:
	mov	eax, DWORD PTR _i$244297[ebp]
	cmp	eax, DWORD PTR $T244303[ebp]
	jae	SHORT $LN7@clear
	push	0
	mov	ecx, DWORD PTR _i$244297[ebp]
	imul	ecx, 76					; 0000004cH
	mov	edx, DWORD PTR _i$244297[ebp]
	imul	edx, 76					; 0000004cH
	add	edx, DWORD PTR $T244302[ebp]
	mov	eax, DWORD PTR $T244302[ebp]
	mov	eax, DWORD PTR [eax+ecx]
	mov	ecx, edx
	mov	edx, DWORD PTR [eax]
	call	edx
	jmp	SHORT $LN4@clear
$LN7@clear:

; 122  : 		m_uiCurrSize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 123  : 	};

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$BaseVector@VCvDeal@@$0A@@@QAEXXZ ENDP		; BaseVector<CvDeal,0>::clear
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::~vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXXZ ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE@XZ
__ehhandler$??1?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::~vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >
PUBLIC	?insert@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@ABU?$pair@IPAVCvDeal@@@2@@Z ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::insert
PUBLIC	??$_Uninit_fill_n@PAU?$pair@IPAVCvDeal@@@std@@IU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@IABU10@AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::pair<unsigned int,CvDeal *> *,unsigned int,std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAEXABU?$pair@IPAVCvDeal@@@2@@Z
_TEXT	SEGMENT
tv129 = -64						; size = 4
_this$ = -60						; size = 4
$T244441 = -32						; size = 4
$T244431 = -28						; size = 4
$T244421 = -24						; size = 4
__Cat$244430 = -19					; size = 1
$T244427 = -18						; size = 1
$T244426 = -17						; size = 1
$T244398 = -16						; size = 4
$T244394 = -12						; size = 4
$T244393 = -8						; size = 4
$T244392 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAEXABU?$pair@IPAVCvDeal@@@2@@Z PROC ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 3
	mov	DWORD PTR $T244398[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN9@push_back@2
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN7@push_back@2
$LN9@push_back@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 3
	mov	DWORD PTR tv129[ebp], eax
$LN7@push_back@2:
	mov	ecx, DWORD PTR $T244398[ebp]
	cmp	ecx, DWORD PTR tv129[ebp]
	jae	SHORT $LN2@push_back@2

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T244431[ebp], eax
	mov	ecx, DWORD PTR $T244431[ebp]
	mov	DWORD PTR $T244421[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T244426[ebp], dl
	mov	al, BYTE PTR __Cat$244430[ebp]
	mov	BYTE PTR $T244427[ebp], al
	movzx	ecx, BYTE PTR $T244426[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T244427[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR $T244421[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAU?$pair@IPAVCvDeal@@@std@@IU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@IABU10@AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::pair<unsigned int,CvDeal *> *,unsigned int,std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >
	add	esp, 24					; 00000018H
	mov	eax, 1
	shl	eax, 3
	add	eax, DWORD PTR $T244431[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back@2
$LN2@push_back@2:

; 823  : 			insert(end(), _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T244441[ebp], eax
	mov	ecx, DWORD PTR $T244441[ebp]
	mov	DWORD PTR $T244393[ebp], ecx
	mov	edx, DWORD PTR $T244393[ebp]
	mov	DWORD PTR $T244392[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T244392[ebp]
	push	ecx
	lea	edx, DWORD PTR $T244394[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@ABU?$pair@IPAVCvDeal@@@2@@Z ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::insert
$LN3@push_back@2:

; 824  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAEXABU?$pair@IPAVCvDeal@@@2@@Z ENDP ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::push_back
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?erase@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@@Z
_TEXT	SEGMENT
_this$ = -60						; size = 4
$T244611 = -56						; size = 4
$T244610 = -52						; size = 4
$T244592 = -48						; size = 4
$T244591 = -44						; size = 4
$T244575 = -40						; size = 4
__Cat$244599 = -34					; size = 1
$T244597 = -33						; size = 1
$T244549 = -32						; size = 4
$T244548 = -28						; size = 4
$T244547 = -24						; size = 4
$T244530 = -18						; size = 1
$T244529 = -17						; size = 1
$T244528 = -16						; size = 4
$T244527 = -12						; size = 4
__Cat$244538 = -4					; size = 1
$T244535 = -3						; size = 1
$T244534 = -2						; size = 1
$T244533 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@@Z PROC ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::erase, COMDAT
; _this$ = ecx

; 1017 : 		{	// erase element at where

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	DWORD PTR _this$[ebp], ecx

; 1018 : 		_STDEXT unchecked_copy(_VEC_ITER_BASE(_Where) + 1, _Mylast,
; 1019 : 			_VEC_ITER_BASE(_Where));

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T244549[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T244548[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	add	eax, 8
	mov	DWORD PTR $T244547[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T244533[ebp], cl
	mov	dl, BYTE PTR __Cat$244538[ebp]
	mov	BYTE PTR $T244534[ebp], dl
	mov	al, BYTE PTR $T244533[ebp]
	mov	BYTE PTR $T244530[ebp], al
	mov	cl, BYTE PTR $T244535[ebp]
	mov	BYTE PTR $T244529[ebp], cl
	mov	edx, DWORD PTR $T244549[ebp]
	mov	DWORD PTR $T244528[ebp], edx
	mov	eax, DWORD PTR $T244547[ebp]
	mov	DWORD PTR $T244527[ebp], eax
	jmp	SHORT $LN11@erase
$LN10@erase:
	mov	ecx, DWORD PTR $T244528[ebp]
	add	ecx, 8
	mov	DWORD PTR $T244528[ebp], ecx
	mov	edx, DWORD PTR $T244527[ebp]
	add	edx, 8
	mov	DWORD PTR $T244527[ebp], edx
$LN11@erase:
	mov	eax, DWORD PTR $T244527[ebp]
	cmp	eax, DWORD PTR $T244548[ebp]
	je	SHORT $LN3@erase
	mov	ecx, DWORD PTR $T244527[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T244528[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN10@erase
$LN3@erase:

; 1020 : 		_Destroy(_Mylast - 1, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T244611[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, 8
	mov	DWORD PTR $T244610[ebp], edx
	mov	eax, DWORD PTR $T244611[ebp]
	mov	DWORD PTR $T244592[ebp], eax
	mov	ecx, DWORD PTR $T244610[ebp]
	mov	DWORD PTR $T244591[ebp], ecx
	mov	dl, BYTE PTR __Cat$244599[ebp]
	mov	BYTE PTR $T244597[ebp], dl
	mov	eax, DWORD PTR $T244591[ebp]
	mov	DWORD PTR $T244575[ebp], eax
	jmp	SHORT $LN22@erase
$LN21@erase:
	mov	ecx, DWORD PTR $T244575[ebp]
	add	ecx, 8
	mov	DWORD PTR $T244575[ebp], ecx
$LN22@erase:
	mov	edx, DWORD PTR $T244575[ebp]
	cmp	edx, DWORD PTR $T244592[ebp]
	je	SHORT $LN14@erase
	jmp	SHORT $LN21@erase
$LN14@erase:

; 1021 : 		--_Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1022 : 		return (_Make_iter(_Where));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1023 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@@Z ENDP ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::erase
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
_TEXT	ENDS
;	COMDAT ??1const_iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1const_iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ PROC ; FFastList<CvTradedItem,21,0>::const_iterator::~const_iterator, COMDAT
; _this$ = ecx

; 148  : 		~const_iterator(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1const_iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ENDP ; FFastList<CvTradedItem,21,0>::const_iterator::~const_iterator
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ PROC ; FFastList<CvTradedItem,21,0>::iterator::~iterator, COMDAT
; _this$ = ecx

; 136  : 		~iterator(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ENDP ; FFastList<CvTradedItem,21,0>::iterator::~iterator
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
_TEXT	ENDS
;	COMDAT ??1?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
??1?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE@XZ PROC ; CvWeightedVector<enum TeamTypes,63,1>::~CvWeightedVector<enum TeamTypes,63,1>, COMDAT
; _this$ = ecx

; 58   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 59   : 	};

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::~FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE@XZ ENDP ; CvWeightedVector<enum TeamTypes,63,1>::~CvWeightedVector<enum TeamTypes,63,1>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE@XZ PROC ; std::_Vector_val<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::~_Vector_val<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE@XZ ENDP ; std::_Vector_val<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::~_Vector_val<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
xdata$x	SEGMENT
__unwindtable$?erase@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE?AViterator@1@V21@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE?AViterator@1@V21@@Z$0
__ehfuncinfo$?erase@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE?AViterator@1@V21@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?erase@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE?AViterator@1@V21@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?erase@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE?AViterator@1@V21@@Z
_TEXT	SEGMENT
_this$ = -80						; size = 4
$T244715 = -32						; size = 4
$T244708 = -28						; size = 4
$T244696 = -24						; size = 4
$T244691 = -20						; size = 4
_uiNext$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_it$ = 12						; size = 8
?erase@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE?AViterator@1@V21@@Z PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::erase, COMDAT
; _this$ = ecx

; 564  : 	iterator erase( iterator  it ){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?erase@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE?AViterator@1@V21@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T244691[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 565  : 		const unsigned int uiNext = get_allocator()[it.get_index()].LIST_GetNext();

	mov	eax, DWORD PTR _it$[ebp+4]
	mov	DWORD PTR $T244696[ebp], eax
	mov	ecx, DWORD PTR $T244696[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T244708[ebp], ecx
	mov	eax, DWORD PTR $T244708[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _uiNext$[ebp], ecx

; 566  : 		UnLink( it.get_index(), uiNext );

	mov	edx, DWORD PTR _it$[ebp+4]
	mov	DWORD PTR $T244715[ebp], edx
	mov	eax, DWORD PTR _uiNext$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T244715[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnLink@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAEXII@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::UnLink

; 567  : 		return iterator( uiNext, this );

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR _uiNext$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR $T244691[ebp]
	or	eax, 1
	mov	DWORD PTR $T244691[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 568  : 	};

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE?AViterator@1@V21@@Z$0:
	lea	ecx, DWORD PTR _it$[ebp]
	jmp	??1iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::~iterator
__ehhandler$?erase@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE?AViterator@1@V21@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?erase@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE?AViterator@1@V21@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE?AViterator@1@V21@@Z ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::erase
PUBLIC	??1?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@QAE@XZ ; BaseVector<MultiListNodePolicy<CvTradedItem>,0>::~BaseVector<MultiListNodePolicy<CvTradedItem>,0>
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??1?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE@XZ$1
__ehfuncinfo$??1?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastallocator.h
xdata$x	ENDS
;	COMDAT ??1?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T244910 = -28						; size = 4
$T244890 = -24						; size = 4
$T244889 = -20						; size = 4
_i$244899 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE@XZ PROC ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::~FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 76   : 	~FFastAllocator(){ assert( m_uiSize == 0); };

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	mov	DWORD PTR $T244910[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR $T244910[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T244890[ebp], edx
	mov	eax, DWORD PTR $T244910[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T244889[ebp], ecx
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN7@FFastAlloc
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN7@FFastAlloc
	mov	DWORD PTR _i$244899[ebp], 0
	jmp	SHORT $LN12@FFastAlloc
$LN11@FFastAlloc:
	mov	ecx, DWORD PTR _i$244899[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$244899[ebp], ecx
$LN12@FFastAlloc:
	mov	edx, DWORD PTR _i$244899[ebp]
	cmp	edx, DWORD PTR $T244890[ebp]
	jae	SHORT $LN7@FFastAlloc
	jmp	SHORT $LN11@FFastAlloc
$LN7@FFastAlloc:
	mov	eax, DWORD PTR $T244889[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE@XZ$1:
	mov	ecx, DWORD PTR $T244910[ebp]
	jmp	??1?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@QAE@XZ ; BaseVector<MultiListNodePolicy<CvTradedItem>,0>::~BaseVector<MultiListNodePolicy<CvTradedItem>,0>
__ehhandler$??1?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE@XZ ENDP ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::~FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>
EXTRN	_memcpy:PROC
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?GrowSize@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GrowSize@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXI@Z$0
__ehfuncinfo$?GrowSize@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GrowSize@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?GrowSize@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv186 = -52						; size = 4
_this$ = -48						; size = 4
$T244930 = -40						; size = 4
_pRet$244926 = -36					; size = 4
$T244920 = -32						; size = 4
$T244919 = -28						; size = 4
_i$223344 = -24						; size = 4
_uiNewSize$223336 = -20					; size = 4
_pTemp$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<CvDeal,20,0,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GrowSize@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@GrowSize
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jb	SHORT $LN7@GrowSize

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	DWORD PTR _uiNewSize$223336[ebp], edx

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$223336[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN6@GrowSize

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 754  : 				break;

	jmp	SHORT $LN7@GrowSize
$LN6@GrowSize:

; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$223336[ebp]
	mov	DWORD PTR [ecx+8], edx

; 759  : 		}

	jmp	SHORT $LN8@GrowSize
$LN7@GrowSize:

; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T244930[ebp], ecx
	cmp	DWORD PTR $T244930[ebp], 20		; 00000014H
	jbe	SHORT $LN16@GrowSize
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T244930[ebp]
	imul	edx, 76					; 0000004cH
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$244926[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T244930[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN17@GrowSize
$LN16@GrowSize:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$244926[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 20			; 00000014H
$LN17@GrowSize:
	mov	ecx, DWORD PTR _pRet$244926[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 762  : 		if( bPODType ){

	xor	edx, edx
	je	SHORT $LN5@GrowSize

; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 76					; 0000004cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 764  : 		}else{

	jmp	SHORT $LN4@GrowSize
$LN5@GrowSize:

; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$223344[ebp], 0
	jmp	SHORT $LN3@GrowSize
$LN2@GrowSize:
	mov	edx, DWORD PTR _i$223344[ebp]
	add	edx, 1
	mov	DWORD PTR _i$223344[ebp], edx
$LN3@GrowSize:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$223344[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN4@GrowSize

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$223344[ebp]
	imul	edx, 76					; 0000004cH
	add	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR $T244920[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T244920[ebp], 0
	je	SHORT $LN12@GrowSize
	mov	eax, DWORD PTR _i$223344[ebp]
	imul	eax, 76					; 0000004cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	push	eax
	mov	ecx, DWORD PTR $T244920[ebp]
	call	??0CvDeal@@QAE@ABV0@@Z			; CvDeal::CvDeal
	mov	DWORD PTR tv186[ebp], eax
	jmp	SHORT $LN13@GrowSize
$LN12@GrowSize:
	mov	DWORD PTR tv186[ebp], 0
$LN13@GrowSize:
	mov	edx, DWORD PTR tv186[ebp]
	mov	DWORD PTR $T244919[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	jmp	SHORT $LN2@GrowSize
$LN4@GrowSize:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Free@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXPAVCvDeal@@I@Z ; FStaticVector<CvDeal,20,0,297,0>::Free

; 769  : 		m_pData = pTemp;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx], edx

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1532], 1

; 772  : 	};

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GrowSize@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXI@Z$0:
	mov	eax, DWORD PTR _i$223344[ebp]
	imul	eax, 76					; 0000004cH
	add	eax, DWORD PTR _pTemp$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T244920[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?GrowSize@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GrowSize@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GrowSize@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvDeal,20,0,297,0>::GrowSize
; Function compile flags: /Odtp
;	COMDAT ?Free@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXPAVCvDeal@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$244955 = -4						; size = 4
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXPAVCvDeal@@I@Z PROC ; FStaticVector<CvDeal,20,0,297,0>::Free, COMDAT
; _this$ = ecx

; 809  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN2@Free
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN2@Free
	mov	DWORD PTR _i$244955[ebp], 0
	jmp	SHORT $LN7@Free
$LN6@Free:
	mov	edx, DWORD PTR _i$244955[ebp]
	add	edx, 1
	mov	DWORD PTR _i$244955[ebp], edx
$LN7@Free:
	mov	eax, DWORD PTR _i$244955[ebp]
	cmp	eax, DWORD PTR _uiNumElements$[ebp]
	jae	SHORT $LN2@Free
	push	0
	mov	ecx, DWORD PTR _i$244955[ebp]
	imul	ecx, 76					; 0000004cH
	mov	edx, DWORD PTR _i$244955[ebp]
	imul	edx, 76					; 0000004cH
	add	edx, DWORD PTR _pVal$[ebp]
	mov	eax, DWORD PTR _pVal$[ebp]
	mov	eax, DWORD PTR [eax+ecx]
	mov	ecx, edx
	mov	edx, DWORD PTR [eax]
	call	edx
	jmp	SHORT $LN6@Free
$LN2@Free:

; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	cmp	DWORD PTR _pVal$[ebp], eax
	je	SHORT $LN3@Free

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	mov	ecx, DWORD PTR _pVal$[ebp]
	push	ecx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN3@Free:

; 813  : 	};

	mov	esp, ebp
	pop	ebp
	ret	8
?Free@?$FStaticVector@VCvDeal@@$0BE@$0A@$0BCJ@$0A@@@IAEXPAVCvDeal@@I@Z ENDP ; FStaticVector<CvDeal,20,0,297,0>::Free
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@VCvDeal@@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@VCvDeal@@$0A@@@QAE@XZ PROC		; BaseVector<CvDeal,0>::~BaseVector<CvDeal,0>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@VCvDeal@@$0A@@@QAE@XZ ENDP		; BaseVector<CvDeal,0>::~BaseVector<CvDeal,0>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Destroy@?$BaseVector@VCvDeal@@$0A@@@IAEXPAVCvDeal@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$223376 = -4						; size = 4
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@VCvDeal@@$0A@@@IAEXPAVCvDeal@@I@Z PROC ; BaseVector<CvDeal,0>::Destroy, COMDAT
; _this$ = ecx

; 220  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 221  : 		if( !bPODType){

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN5@Destroy

; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){

	mov	DWORD PTR _i$223376[ebp], 0
	jmp	SHORT $LN3@Destroy
$LN2@Destroy:
	mov	ecx, DWORD PTR _i$223376[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$223376[ebp], ecx
$LN3@Destroy:
	mov	edx, DWORD PTR _i$223376[ebp]
	cmp	edx, DWORD PTR _uiNumElements$[ebp]
	jae	SHORT $LN5@Destroy

; 223  : 				pVal[i].~T();

	push	0
	mov	eax, DWORD PTR _i$223376[ebp]
	imul	eax, 76					; 0000004cH
	mov	ecx, DWORD PTR _i$223376[ebp]
	imul	ecx, 76					; 0000004cH
	add	ecx, DWORD PTR _pVal$[ebp]
	mov	edx, DWORD PTR _pVal$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	edx, DWORD PTR [eax]
	call	edx

; 224  : 			}

	jmp	SHORT $LN2@Destroy
$LN5@Destroy:

; 225  : 		}
; 226  : 	};

	mov	esp, ebp
	pop	ebp
	ret	8
?Destroy@?$BaseVector@VCvDeal@@$0A@@@IAEXPAVCvDeal@@I@Z ENDP ; BaseVector<CvDeal,0>::Destroy
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Insert_n
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?insert@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@ABU?$pair@IPAVCvDeal@@@2@@Z
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
__Tmp$245023 = -24					; size = 4
$T245001 = -20						; size = 4
$T244982 = -16						; size = 4
$T244969 = -12						; size = 4
$T244966 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@ABU?$pair@IPAVCvDeal@@@2@@Z PROC ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 3
	test	edx, edx
	jne	SHORT $LN3@insert
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert
$LN3@insert:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T244982[ebp], ecx
	mov	edx, DWORD PTR $T244982[ebp]
	mov	DWORD PTR $T244966[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	sub	eax, DWORD PTR $T244966[ebp]
	sar	eax, 3
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T245001[ebp], edx
	mov	eax, DWORD PTR $T245001[ebp]
	mov	DWORD PTR $T244969[ebp], eax
	mov	ecx, DWORD PTR $T244969[ebp]
	mov	DWORD PTR __Tmp$245023[ebp], ecx
	mov	edx, DWORD PTR __Off$[ebp]
	mov	eax, DWORD PTR __Tmp$245023[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR __Tmp$245023[ebp], ecx
	mov	edx, DWORD PTR __Tmp$245023[ebp]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@ABU?$pair@IPAVCvDeal@@@2@@Z ENDP ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::insert
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?erase@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@0@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
$T245165 = -64						; size = 4
$T245147 = -60						; size = 4
$T245146 = -56						; size = 4
$T245130 = -52						; size = 4
__Cat$245154 = -46					; size = 1
$T245151 = -45						; size = 1
$T245104 = -44						; size = 4
$T245103 = -40						; size = 4
$T245102 = -36						; size = 4
$T245085 = -30						; size = 1
$T245084 = -29						; size = 1
$T245083 = -28						; size = 4
$T245082 = -24						; size = 4
__Cat$245092 = -16					; size = 1
$T245089 = -15						; size = 1
$T245088 = -14						; size = 1
$T245087 = -13						; size = 1
__Ptr$223404 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@0@Z PROC ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	$LN1@erase@2

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T245104[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T245103[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T245102[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T245087[ebp], cl
	mov	dl, BYTE PTR __Cat$245092[ebp]
	mov	BYTE PTR $T245088[ebp], dl
	mov	al, BYTE PTR $T245087[ebp]
	mov	BYTE PTR $T245085[ebp], al
	mov	cl, BYTE PTR $T245089[ebp]
	mov	BYTE PTR $T245084[ebp], cl
	mov	edx, DWORD PTR $T245104[ebp]
	mov	DWORD PTR $T245083[ebp], edx
	mov	eax, DWORD PTR $T245102[ebp]
	mov	DWORD PTR $T245082[ebp], eax
	jmp	SHORT $LN28@erase@2
$LN27@erase@2:
	mov	ecx, DWORD PTR $T245083[ebp]
	add	ecx, 8
	mov	DWORD PTR $T245083[ebp], ecx
	mov	edx, DWORD PTR $T245082[ebp]
	add	edx, 8
	mov	DWORD PTR $T245082[ebp], edx
$LN28@erase@2:
	mov	eax, DWORD PTR $T245082[ebp]
	cmp	eax, DWORD PTR $T245103[ebp]
	je	SHORT $LN20@erase@2
	mov	ecx, DWORD PTR $T245082[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T245083[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN27@erase@2
$LN20@erase@2:
	mov	edx, DWORD PTR $T245083[ebp]
	mov	DWORD PTR __Ptr$223404[ebp], edx

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T245165[ebp], ecx
	mov	edx, DWORD PTR $T245165[ebp]
	mov	DWORD PTR $T245147[ebp], edx
	mov	eax, DWORD PTR __Ptr$223404[ebp]
	mov	DWORD PTR $T245146[ebp], eax
	mov	cl, BYTE PTR __Cat$245154[ebp]
	mov	BYTE PTR $T245151[ebp], cl
	mov	edx, DWORD PTR $T245146[ebp]
	mov	DWORD PTR $T245130[ebp], edx
	jmp	SHORT $LN39@erase@2
$LN38@erase@2:
	mov	eax, DWORD PTR $T245130[ebp]
	add	eax, 8
	mov	DWORD PTR $T245130[ebp], eax
$LN39@erase@2:
	mov	ecx, DWORD PTR $T245130[ebp]
	cmp	ecx, DWORD PTR $T245147[ebp]
	je	SHORT $LN31@erase@2
	jmp	SHORT $LN38@erase@2
$LN31@erase@2:

; 1049 : 			_Mylast = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$223404[ebp]
	mov	DWORD PTR [edx+8], eax
$LN1@erase@2:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@0@Z ENDP ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::erase
_TEXT	ENDS
PUBLIC	??$_Allocate@U?$pair@IPAVCvDeal@@@std@@@std@@YAPAU?$pair@IPAVCvDeal@@@0@IPAU10@@Z ; std::_Allocate<std::pair<unsigned int,CvDeal *> >
PUBLIC	?_Xlen@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@KAXXZ ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$245183 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAE_NI@Z PROC ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy
	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$245183[ebp], 536870911 ; 1fffffffH
	cmp	DWORD PTR __Count$245183[ebp], 0
	jbe	SHORT $LN11@Buy
	mov	eax, DWORD PTR __Count$245183[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy
$LN11@Buy:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@KAXXZ ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@U?$pair@IPAVCvDeal@@@std@@@std@@YAPAU?$pair@IPAVCvDeal@@@0@IPAU10@@Z ; std::_Allocate<std::pair<unsigned int,CvDeal *> >
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAE_NI@Z ENDP ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T245276 = -32						; size = 4
$T245275 = -28						; size = 4
$T245271 = -24						; size = 4
$T245270 = -20						; size = 4
$T245252 = -16						; size = 4
$T245251 = -12						; size = 4
$T245235 = -8						; size = 4
__Cat$245259 = -2					; size = 1
$T245256 = -1						; size = 1
?_Tidy@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXXZ PROC ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T245271[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T245270[ebp], ecx
	mov	edx, DWORD PTR $T245271[ebp]
	mov	DWORD PTR $T245252[ebp], edx
	mov	eax, DWORD PTR $T245270[ebp]
	mov	DWORD PTR $T245251[ebp], eax
	mov	cl, BYTE PTR __Cat$245259[ebp]
	mov	BYTE PTR $T245256[ebp], cl
	mov	edx, DWORD PTR $T245251[ebp]
	mov	DWORD PTR $T245235[ebp], edx
	jmp	SHORT $LN12@Tidy
$LN11@Tidy:
	mov	eax, DWORD PTR $T245235[ebp]
	add	eax, 8
	mov	DWORD PTR $T245235[ebp], eax
$LN12@Tidy:
	mov	ecx, DWORD PTR $T245235[ebp]
	cmp	ecx, DWORD PTR $T245252[ebp]
	je	SHORT $LN4@Tidy
	jmp	SHORT $LN11@Tidy
$LN4@Tidy:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 3
	mov	DWORD PTR $T245276[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T245275[ebp], eax
	mov	ecx, DWORD PTR $T245275[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXXZ ENDP ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Tidy
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
_TEXT	ENDS
;	COMDAT ??0iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::iterator, COMDAT
; _this$ = ecx

; 378  : 		explicit iterator(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 268435455		; 0fffffffH
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::iterator
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::~iterator, COMDAT
; _this$ = ecx

; 381  : 		~iterator(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1iterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAE@XZ ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::~iterator
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Diterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T245299 = -4						; size = 4
??Diterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@XZ PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::operator*, COMDAT
; _this$ = ecx

; 383  : 		T& operator*(){

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 384  : 			return m_pFastList->get_allocator()[ m_uiCurrPos ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T245299[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T245299[ebp]
	add	eax, DWORD PTR [ecx+8]

; 385  : 		};

	mov	esp, ebp
	pop	ebp
	ret	0
??Diterator@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEAAU?$MultiListNodePolicy@UCvTradedItem@@@@XZ ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::iterator::operator*
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T245320 = -20						; size = 4
_pRet$245316 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 63			; 0000003fH

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T245320[ebp], edx
	cmp	DWORD PTR $T245320[ebp], 63		; 0000003fH
	jbe	SHORT $LN7@FStaticVec@2
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T245320[ebp]
	shl	eax, 3
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$245316[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T245320[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec@2
$LN7@FStaticVec@2:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$245316[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 63			; 0000003fH
$LN8@FStaticVec@2:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$245316[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>
__ehhandler$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T245351 = -24						; size = 4
$T245350 = -20						; size = 4
_i$245345 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::~FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T245351[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T245350[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN5@FStaticVec@3
	xor	edx, edx
	je	SHORT $LN5@FStaticVec@3
	mov	DWORD PTR _i$245345[ebp], 0
	jmp	SHORT $LN10@FStaticVec@3
$LN9@FStaticVec@3:
	mov	eax, DWORD PTR _i$245345[ebp]
	add	eax, 1
	mov	DWORD PTR _i$245345[ebp], eax
$LN10@FStaticVec@3:
	mov	ecx, DWORD PTR _i$245345[ebp]
	cmp	ecx, DWORD PTR $T245351[ebp]
	jae	SHORT $LN5@FStaticVec@3
	jmp	SHORT $LN9@FStaticVec@3
$LN5@FStaticVec@3:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T245350[ebp], edx
	je	SHORT $LN1@FStaticVec@3
	mov	eax, DWORD PTR $T245350[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@FStaticVec@3:

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>
__ehhandler$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::~FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>
PUBLIC	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::GrowSize
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@Z
_TEXT	SEGMENT
tv157 = -64						; size = 4
tv149 = -60						; size = 4
_this$ = -56						; size = 4
$T245364 = -8						; size = 4
$T245363 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@Z PROC ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+516], 0

; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN39@push_back@3

; 679  : 			GrowSize(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::GrowSize

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN39@push_back@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T245364[ebp], ecx
	cmp	DWORD PTR $T245364[ebp], 0
	je	SHORT $LN4@push_back@3
	mov	edx, DWORD PTR $T245364[ebp]
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T245364[ebp]
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR $T245364[ebp]
	mov	DWORD PTR tv149[ebp], edx
	jmp	SHORT $LN5@push_back@3
$LN4@push_back@3:
	mov	DWORD PTR tv149[ebp], 0
$LN5@push_back@3:
	mov	eax, DWORD PTR tv149[ebp]
	mov	DWORD PTR $T245363[ebp], eax

; 681  : 		return m_uiCurrSize++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv157[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR tv157[ebp]

; 682  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@Z ENDP ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::push_back
_TEXT	ENDS
PUBLIC	??0?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE@I@Z ; FFastVector<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::FFastVector<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
;	COMDAT ??0?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
??0?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAE@XZ PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >, COMDAT
; _this$ = ecx

; 416  : 		: TAIL(), m_uiFirst( ANCHOR_NODE_INDEX ), m_uiLast( ANCHOR_NODE_INDEX ), m_uiSize(0) {};

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 268435455		; 0fffffffH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE@I@Z ; FFastVector<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::FFastVector<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 268435455		; 0fffffffH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], 268435455		; 0fffffffH
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAE@XZ ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >
_TEXT	ENDS
PUBLIC	?InsertAfter@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAEXII@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::InsertAfter
; Function compile flags: /Odtp
;	COMDAT ?push_back_existing@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
_uiOldLast$ = -4					; size = 4
_uiNewIndex$ = 8					; size = 4
?push_back_existing@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEXI@Z PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::push_back_existing, COMDAT
; _this$ = ecx

; 494  : 	void push_back_existing( unsigned int uiNewIndex ){

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 495  : 		unsigned int uiOldLast = m_uiLast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _uiOldLast$[ebp], ecx

; 496  : 		m_uiLast = uiNewIndex;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiNewIndex$[ebp]
	mov	DWORD PTR [edx+28], eax

; 497  : 		m_uiSize++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx

; 498  : 		if( m_uiFirst == ANCHOR_NODE_INDEX ) m_uiFirst = m_uiLast;

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], 268435455		; 0fffffffH
	jne	SHORT $LN1@push_back_
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR [edx+24], ecx
$LN1@push_back_:

; 499  : 		InsertAfter(m_uiLast, uiOldLast);

	mov	edx, DWORD PTR _uiOldLast$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertAfter@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAEXII@Z ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::InsertAfter

; 500  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back_existing@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@QAEXI@Z ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::push_back_existing
_TEXT	ENDS
PUBLIC	?FreeIfDeleted@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE_NI@Z ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::FreeIfDeleted
; Function compile flags: /Odtp
;	COMDAT ?UnLink@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAEXII@Z
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T245581 = -28						; size = 4
$T245566 = -24						; size = 4
$T245531 = -20						; size = 4
$T245516 = -16						; size = 4
_uiNext$223515 = -12					; size = 4
_uiPrev$223516 = -8					; size = 4
_kEnd$223514 = -4					; size = 4
_uiStart$ = 8						; size = 4
_uiEnd$ = 12						; size = 4
?UnLink@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAEXII@Z PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::UnLink, COMDAT
; _this$ = ecx

; 656  : 	void UnLink( unsigned int uiStart, unsigned int uiEnd ){

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 657  : 		if( uiStart == ANCHOR_NODE_INDEX ){ return; }

	cmp	DWORD PTR _uiStart$[ebp], 268435455	; 0fffffffH
	jne	SHORT $LN8@UnLink
	jmp	$LN9@UnLink
$LN8@UnLink:

; 658  : 		assert( get_allocator().is_element_valid(uiStart) );
; 659  : 
; 660  : 		if( uiStart == m_uiFirst){ m_uiFirst = uiEnd; }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiStart$[ebp]
	cmp	ecx, DWORD PTR [eax+24]
	jne	SHORT $LN15@UnLink
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiEnd$[ebp]
	mov	DWORD PTR [edx+24], eax

; 661  : 		uiStart = get_allocator()[uiStart].LIST_GetPrev();

$LN15@UnLink:
	mov	ecx, DWORD PTR _uiStart$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T245516[ebp], ecx
	mov	eax, DWORD PTR $T245516[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 2147483647				; 7fffffffH
	mov	DWORD PTR _uiStart$[ebp], ecx

; 662  : 		if( uiEnd == ANCHOR_NODE_INDEX ){

	cmp	DWORD PTR _uiEnd$[ebp], 268435455	; 0fffffffH
	jne	SHORT $LN23@UnLink

; 663  : 			uiEnd = m_uiLast;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR _uiEnd$[ebp], eax

; 664  : 			m_uiLast = uiStart;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiStart$[ebp]
	mov	DWORD PTR [ecx+28], edx

; 665  : 		}else{

	jmp	SHORT $LN4@UnLink

; 666  : 			assert( get_allocator().is_element_valid(uiEnd) );
; 667  : 			uiEnd = get_allocator()[uiEnd].LIST_GetPrev();

$LN23@UnLink:
	mov	eax, DWORD PTR _uiEnd$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR $T245531[ebp], eax
	mov	edx, DWORD PTR $T245531[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, 2147483647				; 7fffffffH
	mov	DWORD PTR _uiEnd$[ebp], eax
$LN4@UnLink:

; 668  : 		}
; 669  : 
; 670  : 		while( uiStart != uiEnd ){

	mov	ecx, DWORD PTR _uiStart$[ebp]
	cmp	ecx, DWORD PTR _uiEnd$[ebp]
	je	$LN9@UnLink

; 671  : 			T& kEnd = get_allocator()[uiEnd];

	mov	edx, DWORD PTR _uiEnd$[ebp]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _kEnd$223514[ebp], edx

; 672  : 			unsigned int uiNext = kEnd.LIST_GetNext();

	mov	ecx, DWORD PTR _kEnd$223514[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _uiNext$223515[ebp], edx

; 673  : 			unsigned int uiPrev = kEnd.LIST_GetPrev();

	mov	eax, DWORD PTR _kEnd$223514[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 2147483647				; 7fffffffH
	mov	DWORD PTR _uiPrev$223516[ebp], ecx

; 674  : 			if( uiNext != ANCHOR_NODE_INDEX ) get_allocator()[uiNext].LIST_SetPrev( uiPrev );

	cmp	DWORD PTR _uiNext$223515[ebp], 268435455 ; 0fffffffH
	je	SHORT $LN2@UnLink
	mov	edx, DWORD PTR _uiNext$223515[ebp]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+8]
	mov	DWORD PTR $T245566[ebp], edx
	mov	ecx, DWORD PTR _uiPrev$223516[ebp]
	and	ecx, 2147483647				; 7fffffffH
	mov	edx, DWORD PTR $T245566[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, -2147483648			; 80000000H
	or	eax, ecx
	mov	ecx, DWORD PTR $T245566[ebp]
	mov	DWORD PTR [ecx+4], eax
$LN2@UnLink:

; 675  : 			if( uiPrev != ANCHOR_NODE_INDEX ) get_allocator()[uiPrev].LIST_SetNext( uiNext );

	cmp	DWORD PTR _uiPrev$223516[ebp], 268435455 ; 0fffffffH
	je	SHORT $LN1@UnLink
	mov	edx, DWORD PTR _uiPrev$223516[ebp]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+8]
	mov	DWORD PTR $T245581[ebp], edx
	mov	ecx, DWORD PTR $T245581[ebp]
	mov	edx, DWORD PTR _uiNext$223515[ebp]
	mov	DWORD PTR [ecx], edx
$LN1@UnLink:

; 676  : 			kEnd.LIST_SetDeleted(true);

	mov	eax, 1
	neg	eax
	sbb	eax, eax
	add	eax, 1
	and	eax, 1
	shl	eax, 31					; 0000001fH
	mov	ecx, DWORD PTR _kEnd$223514[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, 2147483647				; 7fffffffH
	or	edx, eax
	mov	eax, DWORD PTR _kEnd$223514[ebp]
	mov	DWORD PTR [eax+4], edx

; 677  : 			get_allocator().FreeIfDeleted(uiEnd);

	mov	ecx, DWORD PTR _uiEnd$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeIfDeleted@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE_NI@Z ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::FreeIfDeleted

; 678  : 
; 679  : 			m_uiSize--;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 680  : 
; 681  : 			uiEnd = uiPrev;

	mov	edx, DWORD PTR _uiPrev$223516[ebp]
	mov	DWORD PTR _uiEnd$[ebp], edx

; 682  : 		}

	jmp	$LN4@UnLink
$LN9@UnLink:

; 683  : 	};

	mov	esp, ebp
	pop	ebp
	ret	8
?UnLink@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAEXII@Z ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::UnLink
_TEXT	ENDS
PUBLIC	?push_back@?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z ; FFastVector<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::push_back
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastallocator.h
;	COMDAT ?Alloc@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z
_TEXT	SEGMENT
tv141 = -36						; size = 4
_this$ = -32						; size = 4
$T245650 = -28						; size = 4
$T245643 = -24						; size = 4
$T245619 = -16						; size = 4
_pTemp$223525 = -12					; size = 4
_uiIndex$223523 = -8					; size = 4
_uiPos$ = -4						; size = 4
_x$ = 8							; size = 4
?Alloc@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z PROC ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::Alloc, COMDAT
; _this$ = ecx

; 90   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 91   : 		unsigned int uiPos;
; 92   : 
; 93   : 		//If there are no pre-allocated spots, get a new one
; 94   : 		if( m_uiFirstEmpty == ms_uiAnchorNodeIndex )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 268435455		; 0fffffffH
	jne	SHORT $LN2@Alloc

; 95   : 		{
; 96   : 			uiPos = m_vec.size();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _uiPos$[ebp], edx

; 97   : 			unsigned int uiIndex = m_vec.push_back( x );

	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?push_back@?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z ; FFastVector<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::push_back
	mov	DWORD PTR _uiIndex$223523[ebp], eax

; 98   : 			m_vec[uiIndex].ALLOC_SetDeleted(false);

	mov	ecx, DWORD PTR _uiIndex$223523[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T245643[ebp], ecx
	xor	eax, eax
	neg	eax
	sbb	eax, eax
	add	eax, 1
	and	eax, 1
	shl	eax, 31					; 0000001fH
	mov	ecx, DWORD PTR $T245643[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, 2147483647				; 7fffffffH
	or	edx, eax
	mov	eax, DWORD PTR $T245643[ebp]
	mov	DWORD PTR [eax+4], edx

; 99   : 		}
; 100  : 
; 101  : 		//Otherwise reuse an old spot after deleting it's previous contents
; 102  : 		else{

	jmp	SHORT $LN1@Alloc
$LN2@Alloc:

; 103  : 			uiPos = m_uiFirstEmpty;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _uiPos$[ebp], edx

; 104  : 			T* pTemp = &m_vec[uiPos];

	mov	eax, DWORD PTR _uiPos$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR _pTemp$223525[ebp], eax

; 105  : 			m_uiFirstEmpty = pTemp->ALLOC_GetNext();

	mov	edx, DWORD PTR _pTemp$223525[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T245650[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T245650[ebp]
	mov	DWORD PTR [ecx], edx

; 106  : 			pTemp->~T();
; 107  : 			new( (void*)pTemp )T( x );

	mov	eax, DWORD PTR _pTemp$223525[ebp]
	mov	DWORD PTR $T245619[ebp], eax
	cmp	DWORD PTR $T245619[ebp], 0
	je	SHORT $LN5@Alloc
	mov	esi, DWORD PTR _x$[ebp]
	mov	ecx, 11					; 0000000bH
	mov	edi, DWORD PTR $T245619[ebp]
	rep movsd
	mov	ecx, DWORD PTR $T245619[ebp]
	mov	DWORD PTR tv141[ebp], ecx
	jmp	SHORT $LN6@Alloc
$LN5@Alloc:
	mov	DWORD PTR tv141[ebp], 0
$LN6@Alloc:

; 108  : 			pTemp->ALLOC_SetDeleted(false);

	xor	edx, edx
	neg	edx
	sbb	edx, edx
	add	edx, 1
	and	edx, 1
	shl	edx, 31					; 0000001fH
	mov	eax, DWORD PTR _pTemp$223525[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 2147483647				; 7fffffffH
	or	ecx, edx
	mov	edx, DWORD PTR _pTemp$223525[ebp]
	mov	DWORD PTR [edx+4], ecx
$LN1@Alloc:

; 109  : 		}
; 110  : 		m_uiSize++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 111  : 		return uiPos;

	mov	eax, DWORD PTR _uiPos$[ebp]

; 112  : 	};

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?Alloc@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z ENDP ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::Alloc
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *,std::allocator<std::pair<unsigned int,CvDeal *> > >
PUBLIC	??$unchecked_uninitialized_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@stdext@@YAPAU?$pair@IPAVCvDeal@@@std@@PAU12@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@Z ; stdext::unchecked_uninitialized_copy<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *,std::allocator<std::pair<unsigned int,CvDeal *> > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z$2
__catchsym$?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z$0
__unwindtable$?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z$5
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z$6
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z
_TEXT	SEGMENT
tv84 = -432						; size = 4
tv304 = -428						; size = 4
tv290 = -424						; size = 4
tv282 = -420						; size = 4
_this$ = -416						; size = 4
$T246345 = -412						; size = 4
$T246337 = -408						; size = 4
$T246336 = -404						; size = 4
$T246313 = -398						; size = 1
$T246312 = -397						; size = 1
$T246311 = -396						; size = 4
$T246310 = -392						; size = 4
$T246298 = -385						; size = 1
$T246297 = -384						; size = 4
$T246296 = -380						; size = 4
$T246295 = -376						; size = 4
__Cat$246329 = -372					; size = 1
$T246326 = -371						; size = 1
$T246325 = -370						; size = 1
__Cat$246320 = -368					; size = 1
$T246317 = -367						; size = 1
$T246316 = -366						; size = 1
$T246315 = -365						; size = 1
$T246270 = -364						; size = 4
$T246251 = -360						; size = 4
$T246234 = -353						; size = 1
$T246233 = -352						; size = 4
$T246223 = -348						; size = 4
$T246222 = -344						; size = 4
__Cat$246265 = -338					; size = 1
$T246262 = -337						; size = 1
$T246261 = -336						; size = 1
__Cat$246258 = -335					; size = 1
$T246255 = -334						; size = 1
$T246254 = -333						; size = 1
$T246198 = -332						; size = 4
$T246190 = -328						; size = 4
$T246182 = -324						; size = 4
$T246164 = -320						; size = 4
$T246163 = -316						; size = 4
$T246147 = -312						; size = 4
__Cat$246171 = -306					; size = 1
$T246168 = -305						; size = 1
$T246121 = -304						; size = 4
$T246120 = -300						; size = 4
$T246110 = -296						; size = 4
__Cat$246118 = -291					; size = 1
$T246115 = -290						; size = 1
$T246114 = -289						; size = 1
$T246094 = -288						; size = 4
$T246075 = -284						; size = 4
$T246058 = -277						; size = 1
$T246057 = -276						; size = 4
$T246047 = -272						; size = 4
$T246046 = -268						; size = 4
__Cat$246089 = -262					; size = 1
$T246086 = -261						; size = 1
$T246085 = -260						; size = 1
__Cat$246082 = -259					; size = 1
$T246079 = -258						; size = 1
$T246078 = -257						; size = 1
$T246022 = -256						; size = 4
$T246021 = -252						; size = 4
$T246017 = -248						; size = 4
$T246016 = -244						; size = 4
$T245998 = -240						; size = 4
$T245997 = -236						; size = 4
$T245981 = -232						; size = 4
__Cat$246005 = -226					; size = 1
$T246002 = -225						; size = 1
$T245932 = -224						; size = 4
$T245931 = -220						; size = 4
$T245915 = -216						; size = 4
__Cat$245938 = -210					; size = 1
$T245935 = -209						; size = 1
$T245872 = -208						; size = 4
$T245871 = -204						; size = 4
$T245855 = -200						; size = 4
__Cat$245878 = -194					; size = 1
$T245875 = -193						; size = 1
$T245829 = -192						; size = 4
$T245817 = -188						; size = 4
$T245807 = -181						; size = 1
$T245806 = -180						; size = 4
__Cat$245824 = -175					; size = 1
$T245821 = -174						; size = 1
$T245820 = -173						; size = 1
$T245794 = -172						; size = 4
$T245782 = -168						; size = 4
$T245772 = -161						; size = 1
$T245771 = -160						; size = 4
__Cat$245789 = -155					; size = 1
$T245786 = -154						; size = 1
$T245785 = -153						; size = 1
$T245759 = -152						; size = 4
$T245749 = -148						; size = 4
__Cat$245757 = -143					; size = 1
$T245755 = -142						; size = 1
$T245754 = -141						; size = 1
__Count$245719 = -128					; size = 4
__Count$245693 = -56					; size = 4
__Tmp$223575 = -52					; size = 8
__Oldend$223576 = -44					; size = 4
__Tmp$223557 = -40					; size = 8
__Ncopied$223544 = -32					; size = 4
__Newvec$223542 = -28					; size = 4
__Whereoff$223543 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z PROC ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 416				; 000001a0H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN29@Insert_n
	mov	DWORD PTR tv282[ebp], 0
	jmp	SHORT $LN27@Insert_n
$LN29@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 3
	mov	DWORD PTR tv282[ebp], eax
$LN27@Insert_n:
	mov	ecx, DWORD PTR tv282[ebp]
	mov	DWORD PTR __Capacity$[ebp], ecx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n
	jmp	$LN16@Insert_n
$LN14@Insert_n:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$245693[ebp], 536870911 ; 1fffffffH
	cmp	DWORD PTR __Count$245693[ebp], 0
	jbe	SHORT $LN35@Insert_n
	mov	edx, DWORD PTR __Count$245693[ebp]
	mov	DWORD PTR tv290[ebp], edx
	jmp	SHORT $LN37@Insert_n
$LN35@Insert_n:
	mov	DWORD PTR tv290[ebp], 1
$LN37@Insert_n:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 3
	mov	eax, DWORD PTR tv290[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN42@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@KAXXZ ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Xlen
	jmp	$LN16@Insert_n

; 1167 : 		else if (_Capacity < size() + _Count)

$LN42@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 3
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$245719[ebp], 536870911 ; 1fffffffH
	cmp	DWORD PTR __Count$245719[ebp], 0
	jbe	SHORT $LN48@Insert_n
	mov	ecx, DWORD PTR __Count$245719[ebp]
	mov	DWORD PTR tv304[ebp], ecx
	jmp	SHORT $LN44@Insert_n
$LN48@Insert_n:
	mov	DWORD PTR tv304[ebp], 1
$LN44@Insert_n:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	mov	eax, DWORD PTR tv304[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	add	ecx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], ecx
$LN18@Insert_n:
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1171 : 			if (_Capacity < size() + _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 3
	add	edx, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], edx
	jae	SHORT $LN54@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 3
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN54@Insert_n:
	push	0
	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	call	??$_Allocate@U?$pair@IPAVCvDeal@@@std@@@std@@YAPAU?$pair@IPAVCvDeal@@@0@IPAU10@@Z ; std::_Allocate<std::pair<unsigned int,CvDeal *> >
	add	esp, 8
	mov	DWORD PTR __Newvec$223542[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 3
	mov	DWORD PTR __Whereoff$223543[ebp], edx

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$223544[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Whereoff$223543[ebp]
	mov	ecx, DWORD PTR __Newvec$223542[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR $T245759[ebp], edx
	mov	eax, DWORD PTR $T245759[ebp]
	mov	DWORD PTR $T245749[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T245754[ebp], cl
	mov	dl, BYTE PTR __Cat$245757[ebp]
	mov	BYTE PTR $T245755[ebp], dl
	movzx	eax, BYTE PTR $T245754[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T245755[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T245749[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAU?$pair@IPAVCvDeal@@@std@@IU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@IABU10@AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::pair<unsigned int,CvDeal *> *,unsigned int,std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >
	add	esp, 24					; 00000018H

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$223544[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$223544[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T245794[ebp], edx
	mov	eax, DWORD PTR __Newvec$223542[ebp]
	mov	DWORD PTR $T245782[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T245785[ebp], cl
	mov	dl, BYTE PTR __Cat$245789[ebp]
	mov	BYTE PTR $T245786[ebp], dl
	mov	al, BYTE PTR $T245785[ebp]
	mov	BYTE PTR $T245772[ebp], al
	mov	ecx, DWORD PTR $T245782[ebp]
	mov	DWORD PTR $T245771[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T245771[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T245794[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@stdext@@YAPAU?$pair@IPAVCvDeal@@@std@@PAU12@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@Z ; stdext::unchecked_uninitialized_copy<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *,std::allocator<std::pair<unsigned int,CvDeal *> > >
	add	esp, 16					; 00000010H

; 1182 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$223544[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$223544[ebp], eax

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T245829[ebp], edx
	mov	eax, DWORD PTR __Whereoff$223543[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Newvec$223542[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR $T245817[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T245820[ebp], al
	mov	cl, BYTE PTR __Cat$245824[ebp]
	mov	BYTE PTR $T245821[ebp], cl
	mov	dl, BYTE PTR $T245820[ebp]
	mov	BYTE PTR $T245807[ebp], dl
	mov	eax, DWORD PTR $T245817[ebp]
	mov	DWORD PTR $T245806[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T245806[ebp]
	push	edx
	mov	eax, DWORD PTR $T245829[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	call	??$unchecked_uninitialized_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@stdext@@YAPAU?$pair@IPAVCvDeal@@@std@@PAU12@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@Z ; stdext::unchecked_uninitialized_copy<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *,std::allocator<std::pair<unsigned int,CvDeal *> > >
	add	esp, 16					; 00000010H
	jmp	$LN19@Insert_n
__catch$?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$223544[ebp], 1
	jle	SHORT $LN7@Insert_n

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	edx, DWORD PTR __Whereoff$223543[ebp]
	mov	eax, DWORD PTR __Newvec$223542[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T245872[ebp], ecx
	mov	edx, DWORD PTR __Newvec$223542[ebp]
	mov	DWORD PTR $T245871[ebp], edx
	mov	al, BYTE PTR __Cat$245878[ebp]
	mov	BYTE PTR $T245875[ebp], al
	mov	ecx, DWORD PTR $T245871[ebp]
	mov	DWORD PTR $T245855[ebp], ecx
	jmp	SHORT $LN91@Insert_n
$LN90@Insert_n:
	mov	edx, DWORD PTR $T245855[ebp]
	add	edx, 8
	mov	DWORD PTR $T245855[ebp], edx
$LN91@Insert_n:
	mov	eax, DWORD PTR $T245855[ebp]
	cmp	eax, DWORD PTR $T245872[ebp]
	je	SHORT $LN7@Insert_n
	jmp	SHORT $LN90@Insert_n
$LN7@Insert_n:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$223544[ebp], 0
	jle	SHORT $LN6@Insert_n

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Whereoff$223543[ebp]
	mov	edx, DWORD PTR __Newvec$223542[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T245932[ebp], edx
	mov	eax, DWORD PTR __Whereoff$223543[ebp]
	mov	ecx, DWORD PTR __Newvec$223542[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR $T245931[ebp], edx
	mov	al, BYTE PTR __Cat$245938[ebp]
	mov	BYTE PTR $T245935[ebp], al
	mov	ecx, DWORD PTR $T245931[ebp]
	mov	DWORD PTR $T245915[ebp], ecx
	jmp	SHORT $LN106@Insert_n
$LN105@Insert_n:
	mov	edx, DWORD PTR $T245915[ebp]
	add	edx, 8
	mov	DWORD PTR $T245915[ebp], edx
$LN106@Insert_n:
	mov	eax, DWORD PTR $T245915[ebp]
	cmp	eax, DWORD PTR $T245932[ebp]
	je	SHORT $LN6@Insert_n
	jmp	SHORT $LN105@Insert_n
$LN6@Insert_n:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	ecx, DWORD PTR __Newvec$223542[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN115@Insert_n
	ret	0
$LN19@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN115@Insert_n:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 3
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], ecx

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN5@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T246017[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T246016[ebp], eax
	mov	ecx, DWORD PTR $T246017[ebp]
	mov	DWORD PTR $T245998[ebp], ecx
	mov	edx, DWORD PTR $T246016[ebp]
	mov	DWORD PTR $T245997[ebp], edx
	mov	al, BYTE PTR __Cat$246005[ebp]
	mov	BYTE PTR $T246002[ebp], al
	mov	ecx, DWORD PTR $T245997[ebp]
	mov	DWORD PTR $T245981[ebp], ecx
	jmp	SHORT $LN125@Insert_n
$LN124@Insert_n:
	mov	edx, DWORD PTR $T245981[ebp]
	add	edx, 8
	mov	DWORD PTR $T245981[ebp], edx
$LN125@Insert_n:
	mov	eax, DWORD PTR $T245981[ebp]
	cmp	eax, DWORD PTR $T245998[ebp]
	je	SHORT $LN117@Insert_n
	jmp	SHORT $LN124@Insert_n
$LN117@Insert_n:

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 3
	mov	DWORD PTR $T246022[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T246021[ebp], edx
	mov	eax, DWORD PTR $T246021[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	ecx, DWORD PTR __Capacity$[ebp]
	mov	edx, DWORD PTR __Newvec$223542[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Newvec$223542[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newvec$223542[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	$LN16@Insert_n
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	sar	eax, 3
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$223557[ebp], edx
	mov	DWORD PTR __Tmp$223557[ebp+4], eax

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T246094[ebp], edx
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR $T246075[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T246078[ebp], al
	mov	cl, BYTE PTR __Cat$246082[ebp]
	mov	BYTE PTR $T246079[ebp], cl
	mov	dl, BYTE PTR $T246078[ebp]
	mov	BYTE PTR $T246058[ebp], dl
	mov	eax, DWORD PTR $T246075[ebp]
	mov	DWORD PTR $T246057[ebp], eax
	mov	ecx, DWORD PTR $T246057[ebp]
	mov	DWORD PTR $T246047[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T246046[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T246085[ebp], al
	mov	cl, BYTE PTR __Cat$246089[ebp]
	mov	BYTE PTR $T246086[ebp], cl
	movzx	edx, BYTE PTR $T246085[ebp]
	push	edx
	movzx	eax, BYTE PTR $T246086[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T246047[ebp]
	push	edx
	mov	eax, DWORD PTR $T246094[ebp]
	push	eax
	mov	ecx, DWORD PTR $T246046[ebp]
	push	ecx
	call	??$_Uninit_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *,std::allocator<std::pair<unsigned int,CvDeal *> > >
	add	esp, 24					; 00000018H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	sar	eax, 3
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, eax
	mov	DWORD PTR $T246121[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T246120[ebp], eax
	mov	ecx, DWORD PTR $T246120[ebp]
	mov	DWORD PTR $T246110[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T246114[ebp], dl
	mov	al, BYTE PTR __Cat$246118[ebp]
	mov	BYTE PTR $T246115[ebp], al
	movzx	ecx, BYTE PTR $T246114[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T246115[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$223557[ebp]
	push	ecx
	mov	edx, DWORD PTR $T246121[ebp]
	push	edx
	mov	eax, DWORD PTR $T246110[ebp]
	push	eax
	call	??$_Uninit_fill_n@PAU?$pair@IPAVCvDeal@@@std@@IU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@IABU10@AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::pair<unsigned int,CvDeal *> *,unsigned int,std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >
	add	esp, 24					; 00000018H
	jmp	SHORT $LN21@Insert_n
__catch$?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	DWORD PTR $T246182[ebp], ecx
	mov	edx, DWORD PTR $T246182[ebp]
	mov	DWORD PTR $T246164[ebp], edx
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR $T246163[ebp], edx
	mov	al, BYTE PTR __Cat$246171[ebp]
	mov	BYTE PTR $T246168[ebp], al
	mov	ecx, DWORD PTR $T246163[ebp]
	mov	DWORD PTR $T246147[ebp], ecx
	jmp	SHORT $LN160@Insert_n
$LN159@Insert_n:
	mov	edx, DWORD PTR $T246147[ebp]
	add	edx, 8
	mov	DWORD PTR $T246147[ebp], edx
$LN160@Insert_n:
	mov	eax, DWORD PTR $T246147[ebp]
	cmp	eax, DWORD PTR $T246164[ebp]
	je	SHORT $LN152@Insert_n
	jmp	SHORT $LN159@Insert_n
$LN152@Insert_n:

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z$3
	ret	0
$LN21@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, eax
	mov	DWORD PTR $T246198[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T246190[ebp], eax
	jmp	SHORT $LN171@Insert_n
$LN170@Insert_n:
	mov	ecx, DWORD PTR $T246190[ebp]
	add	ecx, 8
	mov	DWORD PTR $T246190[ebp], ecx
$LN171@Insert_n:
	mov	edx, DWORD PTR $T246190[ebp]
	cmp	edx, DWORD PTR $T246198[ebp]
	je	SHORT $LN167@Insert_n
	mov	eax, DWORD PTR __Tmp$223557[ebp]
	mov	ecx, DWORD PTR __Tmp$223557[ebp+4]
	mov	edx, DWORD PTR $T246190[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN170@Insert_n
$LN167@Insert_n:

; 1232 : 			}
; 1233 : 		else

	jmp	$LN16@Insert_n
$LN3@Insert_n:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$223575[ebp], ecx
	mov	DWORD PTR __Tmp$223575[ebp+4], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Oldend$223576[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T246270[ebp], eax
	mov	ecx, DWORD PTR $T246270[ebp]
	mov	DWORD PTR $T246251[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T246254[ebp], dl
	mov	al, BYTE PTR __Cat$246258[ebp]
	mov	BYTE PTR $T246255[ebp], al
	mov	cl, BYTE PTR $T246254[ebp]
	mov	BYTE PTR $T246234[ebp], cl
	mov	edx, DWORD PTR $T246251[ebp]
	mov	DWORD PTR $T246233[ebp], edx
	mov	eax, DWORD PTR $T246233[ebp]
	mov	DWORD PTR $T246223[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 3
	mov	edx, DWORD PTR __Oldend$223576[ebp]
	sub	edx, ecx
	mov	DWORD PTR $T246222[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T246261[ebp], al
	mov	cl, BYTE PTR __Cat$246265[ebp]
	mov	BYTE PTR $T246262[ebp], cl
	movzx	edx, BYTE PTR $T246261[ebp]
	push	edx
	movzx	eax, BYTE PTR $T246262[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T246223[ebp]
	push	edx
	mov	eax, DWORD PTR __Oldend$223576[ebp]
	push	eax
	mov	ecx, DWORD PTR $T246222[ebp]
	push	ecx
	call	??$_Uninit_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *,std::allocator<std::pair<unsigned int,CvDeal *> > >
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, DWORD PTR __Oldend$223576[ebp]
	mov	DWORD PTR $T246337[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T246336[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T246315[ebp], dl
	mov	al, BYTE PTR __Cat$246320[ebp]
	mov	BYTE PTR $T246316[ebp], al
	mov	cl, BYTE PTR $T246315[ebp]
	mov	BYTE PTR $T246313[ebp], cl
	mov	dl, BYTE PTR $T246317[ebp]
	mov	BYTE PTR $T246312[ebp], dl
	mov	eax, DWORD PTR $T246337[ebp]
	mov	DWORD PTR $T246311[ebp], eax
	mov	ecx, DWORD PTR $T246336[ebp]
	mov	DWORD PTR $T246310[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T246325[ebp], dl
	mov	al, BYTE PTR __Cat$246329[ebp]
	mov	BYTE PTR $T246326[ebp], al
	mov	cl, BYTE PTR $T246325[ebp]
	mov	BYTE PTR $T246298[ebp], cl
	mov	edx, DWORD PTR $T246311[ebp]
	mov	DWORD PTR $T246297[ebp], edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR __Oldend$223576[ebp]
	sub	ecx, eax
	mov	DWORD PTR $T246296[ebp], ecx
	mov	edx, DWORD PTR $T246310[ebp]
	mov	DWORD PTR $T246295[ebp], edx
$LN197@Insert_n:
	mov	eax, DWORD PTR $T246295[ebp]
	cmp	eax, DWORD PTR $T246296[ebp]
	je	SHORT $LN186@Insert_n
	mov	ecx, DWORD PTR $T246296[ebp]
	sub	ecx, 8
	mov	DWORD PTR $T246296[ebp], ecx
	mov	edx, DWORD PTR $T246297[ebp]
	sub	edx, 8
	mov	DWORD PTR $T246297[ebp], edx
	mov	eax, DWORD PTR $T246296[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T246297[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN197@Insert_n
$LN186@Insert_n:

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T246345[ebp], ecx
	jmp	SHORT $LN204@Insert_n
$LN203@Insert_n:
	mov	edx, DWORD PTR $T246345[ebp]
	add	edx, 8
	mov	DWORD PTR $T246345[ebp], edx
$LN204@Insert_n:
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	cmp	DWORD PTR $T246345[ebp], edx
	je	SHORT $LN16@Insert_n
	mov	eax, DWORD PTR __Tmp$223575[ebp]
	mov	ecx, DWORD PTR __Tmp$223575[ebp+4]
	mov	edx, DWORD PTR $T246345[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN203@Insert_n
$LN16@Insert_n:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-436]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@2@IABU?$pair@IPAVCvDeal@@@2@@Z ENDP ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Insert_n
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_Elength_error@std@@UAEPAXI@Z ; std::length_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_Elogic_error@std@@UAEPAXI@Z ; std::logic_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@KAXXZ
_TEXT	SEGMENT
$T246367 = -80						; size = 28
$T246366 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@KAXXZ PROC ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T246367[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T246366[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T246366[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T246367[ebp]
	push	eax
	lea	ecx, DWORD PTR $T246366[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T246366[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T246366[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T246367[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T246367[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T246366[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@U?$pair@IPAVCvDeal@@@std@@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@KAXXZ ENDP ; std::vector<std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >::_Xlen
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 34   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 36   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar@3
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@

; 110  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	edx, DWORD PTR ___flags$[ebp]
	and	edx, 1
	je	SHORT $LN1@scalar@4
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
_TEXT	ENDS
;	COMDAT ?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv186 = -52						; size = 4
_this$ = -48						; size = 4
$T246450 = -44						; size = 4
$T246449 = -40						; size = 4
_i$246444 = -36						; size = 4
$T246428 = -32						; size = 4
$T246421 = -28						; size = 4
_pRet$246417 = -24					; size = 4
$T246411 = -20						; size = 4
$T246410 = -16						; size = 4
_i$223636 = -12						; size = 4
_uiNewSize$223628 = -8					; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@IAEXI@Z PROC ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@GrowSize@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@GrowSize@2:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jb	SHORT $LN7@GrowSize@2

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	DWORD PTR _uiNewSize$223628[ebp], edx

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$223628[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN6@GrowSize@2

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 754  : 				break;

	jmp	SHORT $LN7@GrowSize@2
$LN6@GrowSize@2:

; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$223628[ebp]
	mov	DWORD PTR [ecx+8], edx

; 759  : 		}

	jmp	SHORT $LN8@GrowSize@2
$LN7@GrowSize@2:

; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T246421[ebp], ecx
	cmp	DWORD PTR $T246421[ebp], 63		; 0000003fH
	jbe	SHORT $LN16@GrowSize@2
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T246421[ebp]
	shl	edx, 3
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$246417[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T246421[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN17@GrowSize@2
$LN16@GrowSize@2:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$246417[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 63			; 0000003fH
$LN17@GrowSize@2:
	mov	ecx, DWORD PTR _pRet$246417[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 762  : 		if( bPODType ){

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@GrowSize@2

; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 764  : 		}else{

	jmp	SHORT $LN4@GrowSize@2
$LN5@GrowSize@2:

; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$223636[ebp], 0
	jmp	SHORT $LN3@GrowSize@2
$LN2@GrowSize@2:
	mov	edx, DWORD PTR _i$223636[ebp]
	add	edx, 1
	mov	DWORD PTR _i$223636[ebp], edx
$LN3@GrowSize@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$223636[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN4@GrowSize@2

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$223636[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T246411[ebp], ecx
	cmp	DWORD PTR $T246411[ebp], 0
	je	SHORT $LN12@GrowSize@2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _i$223636[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T246428[ebp], edx
	mov	eax, DWORD PTR $T246411[ebp]
	mov	ecx, DWORD PTR $T246428[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR $T246411[ebp]
	mov	ecx, DWORD PTR $T246428[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR $T246411[ebp]
	mov	DWORD PTR tv186[ebp], eax
	jmp	SHORT $LN13@GrowSize@2
$LN12@GrowSize@2:
	mov	DWORD PTR tv186[ebp], 0
$LN13@GrowSize@2:
	mov	ecx, DWORD PTR tv186[ebp]
	mov	DWORD PTR $T246410[ebp], ecx
	jmp	SHORT $LN2@GrowSize@2
$LN4@GrowSize@2:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T246450[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T246449[ebp], edx
	xor	eax, eax
	je	SHORT $LN24@GrowSize@2
	xor	ecx, ecx
	je	SHORT $LN24@GrowSize@2
	mov	DWORD PTR _i$246444[ebp], 0
	jmp	SHORT $LN29@GrowSize@2
$LN28@GrowSize@2:
	mov	edx, DWORD PTR _i$246444[ebp]
	add	edx, 1
	mov	DWORD PTR _i$246444[ebp], edx
$LN29@GrowSize@2:
	mov	eax, DWORD PTR _i$246444[ebp]
	cmp	eax, DWORD PTR $T246450[ebp]
	jae	SHORT $LN24@GrowSize@2
	jmp	SHORT $LN28@GrowSize@2
$LN24@GrowSize@2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	cmp	DWORD PTR $T246449[ebp], ecx
	je	SHORT $LN25@GrowSize@2
	mov	edx, DWORD PTR $T246449[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN25@GrowSize@2:

; 769  : 		m_pData = pTemp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], ecx

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+516], 1

; 772  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::GrowSize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QAE@XZ PROC ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QAE@XZ ENDP ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@QAE@XZ PROC ; BaseVector<MultiListNodePolicy<CvTradedItem>,0>::~BaseVector<MultiListNodePolicy<CvTradedItem>,0>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@QAE@XZ ENDP ; BaseVector<MultiListNodePolicy<CvTradedItem>,0>::~BaseVector<MultiListNodePolicy<CvTradedItem>,0>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
_TEXT	ENDS
;	COMDAT ?InsertAfter@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAEXII@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T246508 = -16						; size = 4
_b$223684 = -12						; size = 4
_uiBNext$223685 = -8					; size = 4
_a$ = -4						; size = 4
_i$ = 8							; size = 4
_j$ = 12						; size = 4
?InsertAfter@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAEXII@Z PROC ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::InsertAfter, COMDAT
; _this$ = ecx

; 633  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 634  : 		assert( get_allocator().is_element_valid(i) );
; 635  : 
; 636  : 		T* a = &get_allocator()[i];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR _a$[ebp], eax

; 637  : 		if( j == ANCHOR_NODE_INDEX ){

	cmp	DWORD PTR _j$[ebp], 268435455		; 0fffffffH
	jne	SHORT $LN18@InsertAfte

; 638  : 			a->LIST_SetNext(ANCHOR_NODE_INDEX);

	mov	edx, DWORD PTR _a$[ebp]
	mov	DWORD PTR [edx], 268435455		; 0fffffffH

; 639  : 			a->LIST_SetPrev(ANCHOR_NODE_INDEX);

	mov	eax, 268435455				; 0fffffffH
	and	eax, 2147483647				; 7fffffffH
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, -2147483648			; 80000000H
	or	edx, eax
	mov	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR [eax+4], edx

; 640  : 		}else{

	jmp	SHORT $LN4@InsertAfte

; 641  : 			T* b = &get_allocator()[j];

$LN18@InsertAfte:
	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR _b$223684[ebp], ecx

; 642  : 
; 643  : 			//Set the links for the new node
; 644  : 			unsigned int uiBNext = b->LIST_GetNext();

	mov	eax, DWORD PTR _b$223684[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _uiBNext$223685[ebp], ecx

; 645  : 			a->LIST_SetPrev(j);

	mov	edx, DWORD PTR _j$[ebp]
	and	edx, 2147483647				; 7fffffffH
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, -2147483648			; 80000000H
	or	ecx, edx
	mov	edx, DWORD PTR _a$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 646  : 			a->LIST_SetNext(uiBNext);

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _uiBNext$223685[ebp]
	mov	DWORD PTR [eax], ecx

; 647  : 
; 648  : 			//Fix the links for the next and previous nodes
; 649  : 			if( uiBNext != ANCHOR_NODE_INDEX )

	cmp	DWORD PTR _uiBNext$223685[ebp], 268435455 ; 0fffffffH
	je	SHORT $LN1@InsertAfte

; 650  : 				get_allocator()[uiBNext].LIST_SetPrev(i);

	mov	edx, DWORD PTR _uiBNext$223685[ebp]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+8]
	mov	DWORD PTR $T246508[ebp], edx
	mov	ecx, DWORD PTR _i$[ebp]
	and	ecx, 2147483647				; 7fffffffH
	mov	edx, DWORD PTR $T246508[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, -2147483648			; 80000000H
	or	eax, ecx
	mov	ecx, DWORD PTR $T246508[ebp]
	mov	DWORD PTR [ecx+4], eax
$LN1@InsertAfte:

; 651  : 			b->LIST_SetNext(i);

	mov	edx, DWORD PTR _b$223684[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR [edx], eax
$LN4@InsertAfte:

; 652  : 		}
; 653  : 	};

	mov	esp, ebp
	pop	ebp
	ret	8
?InsertAfter@?$FCustomList_Core@U?$MultiListNodePolicy@UCvTradedItem@@@@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@V?$FCustomList_Tail_Member@V?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@@@@@IAEXII@Z ENDP ; FCustomList_Core<MultiListNodePolicy<CvTradedItem>,FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>,FCustomList_Tail_Member<FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator> > >::InsertAfter
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastallocator.h
_TEXT	ENDS
;	COMDAT ?FreeIfDeleted@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE_NI@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T246535 = -16						; size = 4
$T246528 = -12						; size = 4
_pRoot$223695 = -8					; size = 4
_element$ = -4						; size = 4
_uiIndex$ = 8						; size = 4
?FreeIfDeleted@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE_NI@Z PROC ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::FreeIfDeleted, COMDAT
; _this$ = ecx

; 238  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 239  : 		T& element = m_vec[uiIndex];

	mov	eax, DWORD PTR _uiIndex$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR _element$[ebp], eax

; 240  : 		if( !element.ALLOC_GetDeleted() ){

	mov	edx, DWORD PTR _element$[ebp]
	mov	eax, DWORD PTR [edx+4]
	shr	eax, 31					; 0000001fH
	and	eax, 1
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@FreeIfDele

; 241  : 			return false;

	xor	al, al
	jmp	SHORT $LN4@FreeIfDele
$LN3@FreeIfDele:

; 242  : 		}
; 243  : 
; 244  : 		if( uiIndex < m_uiFirstEmpty){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiIndex$[ebp]
	cmp	eax, DWORD PTR [edx]
	jae	SHORT $LN14@FreeIfDele

; 245  : 			element.ALLOC_SetNext(m_uiFirstEmpty);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T246528[ebp], edx
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR $T246528[ebp]
	mov	DWORD PTR [eax], ecx

; 246  : 
; 247  : 			m_uiFirstEmpty = uiIndex;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiIndex$[ebp]
	mov	DWORD PTR [edx], eax

; 248  : 		}else{

	jmp	SHORT $LN1@FreeIfDele

; 249  : 			T* pRoot = &m_vec[m_uiFirstEmpty];

$LN14@FreeIfDele:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _pRoot$223695[ebp], edx

; 250  : 			element.ALLOC_SetNext( pRoot->ALLOC_GetNext() );

	mov	ecx, DWORD PTR _pRoot$223695[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T246535[ebp], edx
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR $T246535[ebp]
	mov	DWORD PTR [eax], ecx

; 251  : 			pRoot->ALLOC_SetNext(uiIndex);

	mov	edx, DWORD PTR _pRoot$223695[ebp]
	mov	eax, DWORD PTR _uiIndex$[ebp]
	mov	DWORD PTR [edx], eax
$LN1@FreeIfDele:

; 252  : 		}
; 253  : 		m_uiSize--;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 254  : 
; 255  : 		return true;

	mov	al, 1
$LN4@FreeIfDele:

; 256  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?FreeIfDeleted@?$FFastAllocator@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE_NI@Z ENDP ; FFastAllocator<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::FreeIfDeleted
_TEXT	ENDS
PUBLIC	?GrowSize@?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@IAEXI@Z ; FFastVector<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::GrowSize
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?push_back@?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z
_TEXT	SEGMENT
tv140 = -56						; size = 4
tv131 = -52						; size = 4
_this$ = -48						; size = 4
$T246544 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z PROC ; FFastVector<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::push_back, COMDAT
; _this$ = ecx

; 376  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN39@push_back@4

; 378  : 			GrowSize(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@IAEXI@Z ; FFastVector<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::GrowSize

; 379  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN39@push_back@4:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T246544[ebp], eax
	je	SHORT $LN4@push_back@4
	mov	esi, DWORD PTR _element$[ebp]
	mov	ecx, 11					; 0000000bH
	mov	edi, DWORD PTR $T246544[ebp]
	rep movsd
	mov	edx, DWORD PTR $T246544[ebp]
	mov	DWORD PTR tv131[ebp], edx
	jmp	SHORT $LN5@push_back@4
$LN4@push_back@4:
	mov	DWORD PTR tv131[ebp], 0
$LN5@push_back@4:

; 380  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv140[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR tv140[ebp]

; 381  : 	};

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAEIABU?$MultiListNodePolicy@UCvTradedItem@@@@@Z ENDP ; FFastVector<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::push_back
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GrowSize@?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@IAEXI@Z
_TEXT	SEGMENT
tv185 = -48						; size = 4
_this$ = -44						; size = 4
$T246638 = -40						; size = 4
$T246637 = -36						; size = 4
_i$246630 = -32						; size = 4
$T246609 = -28						; size = 4
_pRet$246605 = -24					; size = 4
$T246596 = -20						; size = 4
_i$223760 = -16						; size = 4
_uiNewSize$223751 = -12					; size = 4
_nOld$ = -8						; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@IAEXI@Z PROC ; FFastVector<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::GrowSize, COMDAT
; _this$ = ecx

; 422  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 423  : 		unsigned int nOld = m_uiCurrMaxSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _nOld$[ebp], ecx

; 424  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jne	SHORT $LN10@GrowSize@3
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 1
$LN10@GrowSize@3:

; 425  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiFit$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jb	SHORT $LN9@GrowSize@3

; 426  : 
; 427  : 			//Try to double size...
; 428  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 1
	mov	DWORD PTR _uiNewSize$223751[ebp], ecx

; 429  : 
; 430  : 			//...on overflow bail and set to exact size
; 431  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiNewSize$223751[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN8@GrowSize@3

; 432  : 				m_uiCurrMaxSize = uiFit;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 433  : 				break;

	jmp	SHORT $LN9@GrowSize@3
$LN8@GrowSize@3:

; 434  : 			}
; 435  : 
; 436  : 			//...otherwise use the doubled size
; 437  : 			m_uiCurrMaxSize = uiNewSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$223751[ebp]
	mov	DWORD PTR [eax+8], ecx

; 438  : 		}

	jmp	SHORT $LN10@GrowSize@3
$LN9@GrowSize@3:

; 439  : 
; 440  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T246609[ebp], eax
	cmp	DWORD PTR $T246609[ebp], 0
	jbe	SHORT $LN16@GrowSize@3
	push	85					; 00000055H
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	ecx, DWORD PTR $T246609[ebp]
	imul	ecx, 44					; 0000002cH
	push	ecx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$246605[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T246609[ebp]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _pRet$246605[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx
	jmp	SHORT $LN17@GrowSize@3
$LN16@GrowSize@3:
	mov	DWORD PTR _pTemp$[ebp], 0
$LN17@GrowSize@3:

; 441  : 		if (pTemp)

	cmp	DWORD PTR _pTemp$[ebp], 0
	je	$LN7@GrowSize@3

; 442  : 		{
; 443  : 			if( bPODType ){

	xor	edx, edx
	je	SHORT $LN6@GrowSize@3

; 444  : 				memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 44					; 0000002cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 445  : 			}else{

	jmp	SHORT $LN5@GrowSize@3
$LN6@GrowSize@3:

; 446  : 				for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$223760[ebp], 0
	jmp	SHORT $LN4@GrowSize@3
$LN3@GrowSize@3:
	mov	edx, DWORD PTR _i$223760[ebp]
	add	edx, 1
	mov	DWORD PTR _i$223760[ebp], edx
$LN4@GrowSize@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$223760[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN5@GrowSize@3

; 447  : 					new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$223760[ebp]
	imul	edx, 44					; 0000002cH
	add	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR $T246596[ebp], edx
	je	SHORT $LN14@GrowSize@3
	mov	eax, DWORD PTR _i$223760[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [ecx]
	add	esi, eax
	mov	ecx, 11					; 0000000bH
	mov	edi, DWORD PTR $T246596[ebp]
	rep movsd
	mov	edx, DWORD PTR $T246596[ebp]
	mov	DWORD PTR tv185[ebp], edx
	jmp	SHORT $LN15@GrowSize@3
$LN14@GrowSize@3:
	mov	DWORD PTR tv185[ebp], 0
$LN15@GrowSize@3:
	jmp	SHORT $LN3@GrowSize@3
$LN5@GrowSize@3:

; 448  : 			}
; 449  : 			Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T246638[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T246637[ebp], eax
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN23@GrowSize@3
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN23@GrowSize@3
	mov	DWORD PTR _i$246630[ebp], 0
	jmp	SHORT $LN28@GrowSize@3
$LN27@GrowSize@3:
	mov	eax, DWORD PTR _i$246630[ebp]
	add	eax, 1
	mov	DWORD PTR _i$246630[ebp], eax
$LN28@GrowSize@3:
	mov	ecx, DWORD PTR _i$246630[ebp]
	cmp	ecx, DWORD PTR $T246638[ebp]
	jae	SHORT $LN23@GrowSize@3
	jmp	SHORT $LN27@GrowSize@3
$LN23@GrowSize@3:
	mov	edx, DWORD PTR $T246637[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4

; 450  : 			m_pData = pTemp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], ecx

; 451  : 		}
; 452  : 		else

	jmp	SHORT $LN12@GrowSize@3
$LN7@GrowSize@3:

; 453  : 		{
; 454  : 			FAssertMsg2(0, "Failed to grow array size from %u to %u", nOld, m_uiCurrMaxSize);
; 455  : 			m_uiCurrMaxSize = nOld;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _nOld$[ebp]
	mov	DWORD PTR [edx+8], eax
$LN12@GrowSize@3:

; 456  : 		}
; 457  : 	};

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@IAEXI@Z ENDP ; FFastVector<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::GrowSize
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE@I@Z$0
__ehfuncinfo$??0?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T246655 = -20						; size = 4
_pRet$246651 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_uiStartingMaxSize$ = 8					; size = 4
??0?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE@I@Z PROC ; FFastVector<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::FFastVector<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 309  : 	FFastVector(unsigned int uiStartingMaxSize = 0)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 310  : 	{
; 311  : #ifdef BREAK_ON_REPEATED_RESIZE
; 312  : 		m_nResizeTimes = 0;
; 313  : #endif
; 314  : 		m_pData = Alloc(uiStartingMaxSize);

	cmp	DWORD PTR _uiStartingMaxSize$[ebp], 0
	jbe	SHORT $LN6@FFastVecto
	push	85					; 00000055H
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR _uiStartingMaxSize$[ebp]
	imul	eax, 44					; 0000002cH
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$246651[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiStartingMaxSize$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _pRet$246651[ebp]
	mov	DWORD PTR $T246655[ebp], eax
	jmp	SHORT $LN7@FFastVecto
$LN6@FFastVecto:
	mov	DWORD PTR $T246655[ebp], 0
$LN7@FFastVecto:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T246655[ebp]
	mov	DWORD PTR [ecx], edx

; 315  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE@I@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@QAE@XZ ; BaseVector<MultiListNodePolicy<CvTradedItem>,0>::~BaseVector<MultiListNodePolicy<CvTradedItem>,0>
__ehhandler$??0?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FFastVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@$0BF@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$MultiListNodePolicy@UCvTradedItem@@@@$0A@@@@@QAE@I@Z ENDP ; FFastVector<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>::FFastVector<MultiListNodePolicy<CvTradedItem>,0,21,0,BaseVector<MultiListNodePolicy<CvTradedItem>,0>::FDefaultFastVectorAllocator>
EXTRN	__imp_?PushArgument@String@Localization@@QAE_NPBD@Z:PROC
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvlocalization\include\cvlocalization.h
;	COMDAT ??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z PROC	; operator<<<char const *>, COMDAT

; 490  : {

	push	ebp
	mov	ebp, esp

; 491  : 	s.PushArgument(val);

	mov	eax, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _s$[ebp]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 492  : 	return s;

	mov	eax, DWORD PTR _s$[ebp]

; 493  : }

	pop	ebp
	ret	0
??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ENDP	; operator<<<char const *>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$1
__ehfuncinfo$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z
_TEXT	SEGMENT
$T246670 = -140						; size = 4
_str$ = -136						; size = 28
__$ArrayPad$ = -108					; size = 4
_bytes$ = -104						; size = 4
_text$ = -100						; size = 80
_szComposedString$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z PROC	; GetLocalizedText<char const *>, COMDAT

; 501  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 128				; 00000080H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T246670[ebp], 0

; 502  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[ebp]
	push	eax
	lea	ecx, DWORD PTR _text$[ebp]
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 503  : 	text << arg1;

	lea	edx, DWORD PTR _arg1$[ebp]
	push	edx
	lea	eax, DWORD PTR _text$[ebp]
	push	eax
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 504  : 
; 505  : 	size_t bytes = 0;

	mov	DWORD PTR _bytes$[ebp], 0

; 506  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	ecx, DWORD PTR _bytes$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z
	mov	DWORD PTR _szComposedString$[ebp], eax

; 507  : 	CvString str;

	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 508  : 	str.assign(szComposedString, bytes);

	mov	edx, DWORD PTR _bytes$[ebp]
	push	edx
	mov	eax, DWORD PTR _szComposedString$[ebp]
	push	eax
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z

; 509  : 	return str;

	lea	ecx, DWORD PTR _str$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	edx, DWORD PTR $T246670[ebp]
	or	edx, 1
	mov	DWORD PTR $T246670[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 510  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$1:
	lea	ecx, DWORD PTR _str$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$2:
	mov	eax, DWORD PTR $T246670[ebp]
	and	eax, 1
	je	$LN6@GetLocaliz@2
	and	DWORD PTR $T246670[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN6@GetLocaliz@2:
	ret	0
__ehhandler$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-132]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ENDP	; GetLocalizedText<char const *>
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z$1
__ehfuncinfo$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z
_TEXT	SEGMENT
$T246696 = -140						; size = 4
_str$ = -136						; size = 28
__$ArrayPad$ = -108					; size = 4
_bytes$ = -104						; size = 4
_text$ = -100						; size = 80
_szComposedString$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
_arg2$ = 20						; size = 4
??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z PROC ; GetLocalizedText<char const *,char const *>, COMDAT

; 514  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 128				; 00000080H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T246696[ebp], 0

; 515  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[ebp]
	push	eax
	lea	ecx, DWORD PTR _text$[ebp]
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 516  : 	text << arg1 << arg2;

	mov	edx, DWORD PTR _arg2$[ebp]
	push	edx
	mov	eax, DWORD PTR _arg1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _text$[ebp]
	push	ecx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8
	push	eax
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 517  : 
; 518  : 	size_t bytes = 0;

	mov	DWORD PTR _bytes$[ebp], 0

; 519  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	edx, DWORD PTR _bytes$[ebp]
	push	edx
	lea	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z
	mov	DWORD PTR _szComposedString$[ebp], eax

; 520  : 	CvString str;

	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 521  : 	str.assign(szComposedString, bytes);

	mov	eax, DWORD PTR _bytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szComposedString$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z

; 522  : 	return str;

	lea	edx, DWORD PTR _str$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T246696[ebp]
	or	eax, 1
	mov	DWORD PTR $T246696[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 523  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z$1:
	lea	ecx, DWORD PTR _str$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z$2:
	mov	eax, DWORD PTR $T246696[ebp]
	and	eax, 1
	je	$LN6@GetLocaliz@3
	and	DWORD PTR $T246696[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN6@GetLocaliz@3:
	ret	0
__ehhandler$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-132]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ENDP ; GetLocalizedText<char const *,char const *>
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R0?AVbad_alloc@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
xdata$x	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_Ebad_alloc@std@@UAEPAXI@Z ; std::bad_alloc::`vftable'
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
CONST	ENDS
;	COMDAT ??$_Allocate@U?$pair@IPAVCvDeal@@@std@@@std@@YAPAU?$pair@IPAVCvDeal@@@0@IPAU10@@Z
_TEXT	SEGMENT
$T246722 = -16						; size = 4
$T246718 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U?$pair@IPAVCvDeal@@@std@@@std@@YAPAU?$pair@IPAVCvDeal@@@0@IPAU10@@Z PROC ; std::_Allocate<std::pair<unsigned int,CvDeal *> >, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 8
	jae	SHORT $LN2@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T246722[ebp], 0
	lea	eax, DWORD PTR $T246722[ebp]
	push	eax
	lea	ecx, DWORD PTR $T246718[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T246718[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T246718[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 3
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@U?$pair@IPAVCvDeal@@@std@@@std@@YAPAU?$pair@IPAVCvDeal@@@0@IPAU10@@Z ENDP ; std::_Allocate<std::pair<unsigned int,CvDeal *> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar@5
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@5:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAU?$pair@IPAVCvDeal@@@std@@IU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@IABU10@AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAU?$pair@IPAVCvDeal@@@std@@IU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@IABU10@AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAU?$pair@IPAVCvDeal@@@std@@IU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@IABU10@AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAU?$pair@IPAVCvDeal@@@std@@IU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@IABU10@AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAU?$pair@IPAVCvDeal@@@std@@IU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@IABU10@AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_fill_n@PAU?$pair@IPAVCvDeal@@@std@@IU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@IABU10@AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAU?$pair@IPAVCvDeal@@@std@@IU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@IABU10@AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAU?$pair@IPAVCvDeal@@@std@@IU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@IABU10@AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAU?$pair@IPAVCvDeal@@@std@@IU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@IABU10@AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv84 = -32						; size = 4
$T246757 = -28						; size = 4
__Vptr$246755 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAU?$pair@IPAVCvDeal@@@std@@IU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@IABU10@AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<std::pair<unsigned int,CvDeal *> *,unsigned int,std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAU?$pair@IPAVCvDeal@@@std@@IU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@IABU10@AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil
$LN5@Uninit_fil:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 8
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Vptr$246755[ebp], eax
	mov	ecx, DWORD PTR __Vptr$246755[ebp]
	mov	DWORD PTR $T246757[ebp], ecx
	cmp	DWORD PTR $T246757[ebp], 0
	je	SHORT $LN18@Uninit_fil
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T246757[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T246757[ebp]
	mov	DWORD PTR tv84[ebp], eax
	jmp	SHORT $LN14@Uninit_fil
$LN18@Uninit_fil:
	mov	DWORD PTR tv84[ebp], 0
$LN14@Uninit_fil:
	jmp	SHORT $LN5@Uninit_fil
$LN4@Uninit_fil:
	jmp	SHORT $LN10@Uninit_fil
__catch$??$_Uninit_fill_n@PAU?$pair@IPAVCvDeal@@@std@@IU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@IABU10@AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil
$LN2@Uninit_fil:
	mov	ecx, DWORD PTR __Next$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Next$[ebp], ecx
$LN3@Uninit_fil:
	mov	edx, DWORD PTR __Next$[ebp]
	cmp	edx, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil

; 407  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_fil
$LN1@Uninit_fil:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil
	ret	0
$LN10@Uninit_fil:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAU?$pair@IPAVCvDeal@@@std@@IU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@IABU10@AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAU?$pair@IPAVCvDeal@@@std@@IU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@IABU10@AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAU?$pair@IPAVCvDeal@@@std@@IU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAXPAU?$pair@IPAVCvDeal@@@0@IABU10@AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<std::pair<unsigned int,CvDeal *> *,unsigned int,std::pair<unsigned int,CvDeal *>,std::allocator<std::pair<unsigned int,CvDeal *> > >
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@stdext@@YAPAU?$pair@IPAVCvDeal@@@std@@PAU12@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@Z
_TEXT	SEGMENT
__Cat$246785 = -3					; size = 1
$T246782 = -2						; size = 1
$T246781 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@stdext@@YAPAU?$pair@IPAVCvDeal@@@std@@PAU12@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@Z PROC ; stdext::unchecked_uninitialized_copy<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *,std::allocator<std::pair<unsigned int,CvDeal *> > >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T246781[ebp], al
	mov	cl, BYTE PTR __Cat$246785[ebp]
	mov	BYTE PTR $T246782[ebp], cl
	movzx	edx, BYTE PTR $T246781[ebp]
	push	edx
	movzx	eax, BYTE PTR $T246782[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninit_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *,std::allocator<std::pair<unsigned int,CvDeal *> > >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@stdext@@YAPAU?$pair@IPAVCvDeal@@@std@@PAU12@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *,std::allocator<std::pair<unsigned int,CvDeal *> > >
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv84 = -32						; size = 4
$T246811 = -28						; size = 4
__Vptr$246817 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *,std::allocator<std::pair<unsigned int,CvDeal *> > >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop
$LN5@Uninit_cop:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 8
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$246817[ebp], ecx
	mov	edx, DWORD PTR __Vptr$246817[ebp]
	mov	DWORD PTR $T246811[ebp], edx
	cmp	DWORD PTR $T246811[ebp], 0
	je	SHORT $LN18@Uninit_cop
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T246811[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR $T246811[ebp]
	mov	DWORD PTR tv84[ebp], ecx
	jmp	SHORT $LN14@Uninit_cop
$LN18@Uninit_cop:
	mov	DWORD PTR tv84[ebp], 0
$LN14@Uninit_cop:
	jmp	SHORT $LN5@Uninit_cop
$LN4@Uninit_cop:
	jmp	SHORT $LN10@Uninit_cop
__catch$??$_Uninit_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop
$LN2@Uninit_cop:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 8
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_cop:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop

; 134  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_cop
$LN1@Uninit_cop:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAU?$pair@IPAVCvDeal@@@std@@PAU12@V?$allocator@U?$pair@IPAVCvDeal@@@std@@@2@@std@@YAPAU?$pair@IPAVCvDeal@@@0@PAU10@00AAV?$allocator@U?$pair@IPAVCvDeal@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::pair<unsigned int,CvDeal *> *,std::pair<unsigned int,CvDeal *> *,std::allocator<std::pair<unsigned int,CvDeal *> > >
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -48						; size = 28
__$ArrayPad$ = -20					; size = 4
_args$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 2124				; 0000084cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);

	lea	eax, DWORD PTR _lpszFormat$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _args$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpszFormat$[ebp]
	push	edx
	lea	eax, DWORD PTR _result$[ebp]
	push	eax
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);

	mov	DWORD PTR _args$[ebp], 0

; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-2128]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	__$ArrayPad$
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__imp___vsnprintf:PROC
; Function compile flags: /Odtp
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
tv74 = -2096						; size = 4
$T246876 = -2092					; size = 4
$T246875 = -2088					; size = 4
$T246874 = -2084					; size = 4
_maxlen$95294 = -2080					; size = 4
_kMaxAttempts$ = -2076					; size = 4
_buf$ = -2072						; size = 2048
__$ArrayPad$ = -20					; size = 4
_len$ = -16						; size = 4
_attempts$ = -12					; size = 4
_success$ = -5						; size = 1
_pbuf$ = -4						; size = 4
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2096				; 00000830H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	lea	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _pbuf$[ebp], eax

; 194  : 	int len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 195  : 	int attempts = 0;

	mov	DWORD PTR _attempts$[ebp], 0

; 196  : 	bool success = false;

	mov	BYTE PTR _success$[ebp], 0

; 197  : 	const int kMaxAttempts = 40;

	mov	DWORD PTR _kMaxAttempts$[ebp], 40	; 00000028H
$LN10@formatv:

; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;

	mov	ecx, DWORD PTR _attempts$[ebp]
	shl	ecx, 11					; 0000000bH
	add	ecx, 2047				; 000007ffH
	mov	DWORD PTR _maxlen$95294[ebp], ecx

; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	edx, DWORD PTR _args$[ebp]
	push	edx
	mov	eax, DWORD PTR _fmt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _maxlen$95294[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbuf$[ebp]
	push	edx
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR _len$[ebp], eax

; 203  : 		attempts++;

	mov	eax, DWORD PTR _attempts$[ebp]
	add	eax, 1
	mov	DWORD PTR _attempts$[ebp], eax

; 204  : 		success = (len>=0 && len<=maxlen);

	cmp	DWORD PTR _len$[ebp], 0
	jl	SHORT $LN13@formatv
	mov	ecx, DWORD PTR _len$[ebp]
	cmp	ecx, DWORD PTR _maxlen$95294[ebp]
	jg	SHORT $LN13@formatv
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN14@formatv
$LN13@formatv:
	mov	DWORD PTR tv74[ebp], 0
$LN14@formatv:
	mov	dl, BYTE PTR tv74[ebp]
	mov	BYTE PTR _success$[ebp], dl

; 205  : 		if (!success)

	movzx	eax, BYTE PTR _success$[ebp]
	test	eax, eax
	jne	SHORT $LN9@formatv

; 206  : 		{
; 207  : 			if (pbuf!=buf)

	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, edx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T246874[ebp], eax
	mov	ecx, DWORD PTR $T246874[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	mov	edx, DWORD PTR _attempts$[ebp]
	shl	edx, 11					; 0000000bH
	add	edx, 2048				; 00000800H
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T246875[ebp], eax
	mov	eax, DWORD PTR $T246875[ebp]
	mov	DWORD PTR _pbuf$[ebp], eax
$LN9@formatv:

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	movzx	ecx, BYTE PTR _success$[ebp]
	test	ecx, ecx
	jne	SHORT $LN4@formatv
	cmp	DWORD PTR _attempts$[ebp], 40		; 00000028H
	jl	$LN10@formatv
$LN4@formatv:

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)

	movzx	edx, BYTE PTR _success$[ebp]
	test	edx, edx
	je	SHORT $LN3@formatv

; 220  : 		out = pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 221  : 	else

	jmp	SHORT $LN2@formatv
$LN3@formatv:

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN2@formatv:

; 223  : 
; 224  : 	if (pbuf!=buf)

	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, edx
	je	SHORT $LN1@formatv

; 225  : 		delete [] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T246876[ebp], eax
	mov	ecx, DWORD PTR $T246876[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN1@formatv:

; 226  : 
; 227  : 	return success;

	mov	al, BYTE PTR _success$[ebp]

; 228  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT

; 298  : {

	push	ebp
	mov	ebp, esp

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	DWORD PTR _p$[ebp], 0
	jl	SHORT $LN1@teamType
	cmp	DWORD PTR _p$[ebp], 64			; 00000040H
	jge	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	eax, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN2@teamType
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1
$LN2@teamType:

; 302  : }

	pop	ebp
	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
_TEXT	ENDS
;	COMDAT ?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T246887 = -4						; size = 4
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ PROC		; CvPlot::getPlotCity, COMDAT
; _this$ = ecx

; 532  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 533  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+104], 0
	jl	SHORT $LN1@getPlotCit
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+104], 64			; 00000040H
	jge	SHORT $LN1@getPlotCit

; 534  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T246887[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	mov	ecx, DWORD PTR $T246887[ebp]
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	jmp	SHORT $LN2@getPlotCit
$LN1@getPlotCit:

; 535  : 
; 536  : 		return NULL;

	xor	eax, eax
$LN2@getPlotCit:

; 537  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ ENDP		; CvPlot::getPlotCity
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
_TEXT	ENDS
;	COMDAT ?coordRange@@YAHHH_N@Z
_TEXT	SEGMENT
_iCoord$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?coordRange@@YAHHH_N@Z PROC				; coordRange, COMDAT

; 87   : {

	push	ebp
	mov	ebp, esp

; 88   : 	if(bWrap)

	movzx	eax, BYTE PTR _bWrap$[ebp]
	test	eax, eax
	je	SHORT $LN4@coordRange

; 89   : 	{
; 90   : 		if(iCoord < 0)

	cmp	DWORD PTR _iCoord$[ebp], 0
	jge	SHORT $LN3@coordRange

; 91   : 		{
; 92   : 			return (iRange + (iCoord % iRange));

	mov	eax, DWORD PTR _iCoord$[ebp]
	cdq
	idiv	DWORD PTR _iRange$[ebp]
	add	edx, DWORD PTR _iRange$[ebp]
	mov	eax, edx
	jmp	SHORT $LN5@coordRange
	jmp	SHORT $LN4@coordRange
$LN3@coordRange:

; 93   : 		}
; 94   : 		else if(iCoord >= iRange)

	mov	ecx, DWORD PTR _iCoord$[ebp]
	cmp	ecx, DWORD PTR _iRange$[ebp]
	jl	SHORT $LN4@coordRange

; 95   : 		{
; 96   : 			return (iCoord % iRange);

	mov	eax, DWORD PTR _iCoord$[ebp]
	cdq
	idiv	DWORD PTR _iRange$[ebp]
	mov	eax, edx
	jmp	SHORT $LN5@coordRange
$LN4@coordRange:

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;

	mov	eax, DWORD PTR _iCoord$[ebp]
$LN5@coordRange:

; 101  : }

	pop	ebp
	ret	0
?coordRange@@YAHHH_N@Z ENDP				; coordRange
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
tv72 = -16						; size = 4
_this$ = -12						; size = 4
$T246901 = -8						; size = 4
$T246897 = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	cmp	DWORD PTR _iX$[ebp], 0
	jl	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T246897[ebp], ecx
	mov	edx, DWORD PTR _iX$[ebp]
	cmp	edx, DWORD PTR $T246897[ebp]
	jge	SHORT $LN3@isPlot
	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T246901[ebp], ecx
	mov	edx, DWORD PTR _iY$[ebp]
	cmp	edx, DWORD PTR $T246901[ebp]
	jge	SHORT $LN3@isPlot
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN4@isPlot
$LN3@isPlot:
	mov	DWORD PTR tv72[ebp], 0
$LN4@isPlot:
	mov	eax, DWORD PTR tv72[ebp]

; 161  : #endif
; 162  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0length_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
; Function compile flags: /Odtp
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
END
