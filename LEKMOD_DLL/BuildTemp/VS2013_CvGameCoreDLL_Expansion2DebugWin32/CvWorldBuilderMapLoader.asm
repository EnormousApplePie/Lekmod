; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvWorldBuilderMapLoader.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
PUBLIC	?FileVersion@CvWorldBuilderMap@@2IB		; CvWorldBuilderMap::FileVersion
PUBLIC	?MaxMapSize@CvWorldBuilderMap@@2IB		; CvWorldBuilderMap::MaxMapSize
PUBLIC	?MaxPlayers@CvWorldBuilderMap@@2IB		; CvWorldBuilderMap::MaxPlayers
PUBLIC	?MaxCityStates@CvWorldBuilderMap@@2IB		; CvWorldBuilderMap::MaxCityStates
PUBLIC	?MaxTeams@CvWorldBuilderMap@@2IB		; CvWorldBuilderMap::MaxTeams
PUBLIC	?BarbarianPlayer@CvWorldBuilderMap@@2IB		; CvWorldBuilderMap::BarbarianPlayer
PUBLIC	?InvalidResource@PlotMapData@CvWorldBuilderMap@@2EB ; CvWorldBuilderMap::PlotMapData::InvalidResource
PUBLIC	?InvalidFeature@PlotMapData@CvWorldBuilderMap@@2EB ; CvWorldBuilderMap::PlotMapData::InvalidFeature
PUBLIC	?InvalidNaturalWonder@PlotMapData@CvWorldBuilderMap@@2EB ; CvWorldBuilderMap::PlotMapData::InvalidNaturalWonder
PUBLIC	?InvalidUnitType@OldUnit@CvWorldBuilderMap@@2EB	; CvWorldBuilderMap::OldUnit::InvalidUnitType
PUBLIC	?MaxLength@UnitName@CvWorldBuilderMap@@2IB	; CvWorldBuilderMap::UnitName::MaxLength
PUBLIC	?InvalidUnitType@UnitV2@CvWorldBuilderMap@@2EB	; CvWorldBuilderMap::UnitV2::InvalidUnitType
PUBLIC	?MaxPromotionTypes@UnitV2@CvWorldBuilderMap@@2IB ; CvWorldBuilderMap::UnitV2::MaxPromotionTypes
PUBLIC	?MaxHealth@UnitV2@CvWorldBuilderMap@@2IB	; CvWorldBuilderMap::UnitV2::MaxHealth
PUBLIC	?InvalidUnitType@Unit@CvWorldBuilderMap@@2IB	; CvWorldBuilderMap::Unit::InvalidUnitType
PUBLIC	?MaxPromotionTypes@Unit@CvWorldBuilderMap@@2IB	; CvWorldBuilderMap::Unit::MaxPromotionTypes
PUBLIC	?MaxHealth@Unit@CvWorldBuilderMap@@2IB		; CvWorldBuilderMap::Unit::MaxHealth
PUBLIC	?MaxBuildingTypes@OldCity@CvWorldBuilderMap@@2IB ; CvWorldBuilderMap::OldCity::MaxBuildingTypes
PUBLIC	?MaxBuildingTypes@CityV2@CvWorldBuilderMap@@2IB	; CvWorldBuilderMap::CityV2::MaxBuildingTypes
PUBLIC	?MaxNameLength@CityV2@CvWorldBuilderMap@@2IB	; CvWorldBuilderMap::CityV2::MaxNameLength
PUBLIC	?MaxHealth@CityV2@CvWorldBuilderMap@@2IB	; CvWorldBuilderMap::CityV2::MaxHealth
PUBLIC	?MaxBuildingTypes@City@CvWorldBuilderMap@@2IB	; CvWorldBuilderMap::City::MaxBuildingTypes
PUBLIC	?MaxNameLength@City@CvWorldBuilderMap@@2IB	; CvWorldBuilderMap::City::MaxNameLength
PUBLIC	?MaxHealth@City@CvWorldBuilderMap@@2IB		; CvWorldBuilderMap::City::MaxHealth
PUBLIC	?InvalidCulture@PlotScenarioData@CvWorldBuilderMap@@2EB ; CvWorldBuilderMap::PlotScenarioData::InvalidCulture
PUBLIC	?InvalidImprovement@PlotScenarioData@CvWorldBuilderMap@@2EB ; CvWorldBuilderMap::PlotScenarioData::InvalidImprovement
PUBLIC	?InvalidRoute@PlotScenarioData@CvWorldBuilderMap@@2EB ; CvWorldBuilderMap::PlotScenarioData::InvalidRoute
PUBLIC	?MaxTechs@Team@CvWorldBuilderMap@@2IB		; CvWorldBuilderMap::Team::MaxTechs
PUBLIC	?MaxPolicies@OldPlayer@CvWorldBuilderMap@@2IB	; CvWorldBuilderMap::OldPlayer::MaxPolicies
PUBLIC	?InvalidTeam@OldPlayer@CvWorldBuilderMap@@2EB	; CvWorldBuilderMap::OldPlayer::InvalidTeam
PUBLIC	?MaxPolicies@Player@CvWorldBuilderMap@@2IB	; CvWorldBuilderMap::Player::MaxPolicies
PUBLIC	?InvalidTeam@Player@CvWorldBuilderMap@@2EB	; CvWorldBuilderMap::Player::InvalidTeam
PUBLIC	?BitCount@?$FRelationshipBitset@$0GA@$00@@0IB	; FRelationshipBitset<96,1>::BitCount
PUBLIC	?ByteCount@?$FRelationshipBitset@$0GA@$00@@0IB	; FRelationshipBitset<96,1>::ByteCount
PUBLIC	?BitCount@?$FRelationshipBitset@$0GA@$0A@@@0IB	; FRelationshipBitset<96,0>::BitCount
PUBLIC	?ByteCount@?$FRelationshipBitset@$0GA@$0A@@@0IB	; FRelationshipBitset<96,0>::ByteCount
PUBLIC	?ByteCount@?$SerializableBitset@$0DAAAAA@@CvWorldBuilderMap@@0IB ; CvWorldBuilderMap::SerializableBitset<3145728>::ByteCount
_BSS	SEGMENT
_sg_wszTempMapName DW 0104H DUP (?)
_BSS	ENDS
;	COMDAT ?ByteCount@?$SerializableBitset@$0DAAAAA@@CvWorldBuilderMap@@0IB
CONST	SEGMENT
?ByteCount@?$SerializableBitset@$0DAAAAA@@CvWorldBuilderMap@@0IB DD 060000H ; CvWorldBuilderMap::SerializableBitset<3145728>::ByteCount
CONST	ENDS
;	COMDAT ?ByteCount@?$FRelationshipBitset@$0GA@$0A@@@0IB
CONST	SEGMENT
?ByteCount@?$FRelationshipBitset@$0GA@$0A@@@0IB DD 023aH ; FRelationshipBitset<96,0>::ByteCount
CONST	ENDS
;	COMDAT ?BitCount@?$FRelationshipBitset@$0GA@$0A@@@0IB
CONST	SEGMENT
?BitCount@?$FRelationshipBitset@$0GA@$0A@@@0IB DD 011d0H ; FRelationshipBitset<96,0>::BitCount
CONST	ENDS
;	COMDAT ?ByteCount@?$FRelationshipBitset@$0GA@$00@@0IB
CONST	SEGMENT
?ByteCount@?$FRelationshipBitset@$0GA@$00@@0IB DD 023aH	; FRelationshipBitset<96,1>::ByteCount
CONST	ENDS
;	COMDAT ?BitCount@?$FRelationshipBitset@$0GA@$00@@0IB
CONST	SEGMENT
?BitCount@?$FRelationshipBitset@$0GA@$00@@0IB DD 011d0H	; FRelationshipBitset<96,1>::BitCount
CONST	ENDS
;	COMDAT ?InvalidTeam@Player@CvWorldBuilderMap@@2EB
CONST	SEGMENT
?InvalidTeam@Player@CvWorldBuilderMap@@2EB DB 0ffH	; CvWorldBuilderMap::Player::InvalidTeam
CONST	ENDS
;	COMDAT ?MaxPolicies@Player@CvWorldBuilderMap@@2IB
CONST	SEGMENT
?MaxPolicies@Player@CvWorldBuilderMap@@2IB DD 0100H	; CvWorldBuilderMap::Player::MaxPolicies
CONST	ENDS
;	COMDAT ?InvalidTeam@OldPlayer@CvWorldBuilderMap@@2EB
CONST	SEGMENT
?InvalidTeam@OldPlayer@CvWorldBuilderMap@@2EB DB 0ffH	; CvWorldBuilderMap::OldPlayer::InvalidTeam
CONST	ENDS
;	COMDAT ?MaxPolicies@OldPlayer@CvWorldBuilderMap@@2IB
CONST	SEGMENT
?MaxPolicies@OldPlayer@CvWorldBuilderMap@@2IB DD 0100H	; CvWorldBuilderMap::OldPlayer::MaxPolicies
CONST	ENDS
;	COMDAT ?MaxTechs@Team@CvWorldBuilderMap@@2IB
CONST	SEGMENT
?MaxTechs@Team@CvWorldBuilderMap@@2IB DD 0100H		; CvWorldBuilderMap::Team::MaxTechs
CONST	ENDS
;	COMDAT ?InvalidRoute@PlotScenarioData@CvWorldBuilderMap@@2EB
CONST	SEGMENT
?InvalidRoute@PlotScenarioData@CvWorldBuilderMap@@2EB DB 0ffH ; CvWorldBuilderMap::PlotScenarioData::InvalidRoute
CONST	ENDS
;	COMDAT ?InvalidImprovement@PlotScenarioData@CvWorldBuilderMap@@2EB
CONST	SEGMENT
?InvalidImprovement@PlotScenarioData@CvWorldBuilderMap@@2EB DB 0ffH ; CvWorldBuilderMap::PlotScenarioData::InvalidImprovement
CONST	ENDS
;	COMDAT ?InvalidCulture@PlotScenarioData@CvWorldBuilderMap@@2EB
CONST	SEGMENT
?InvalidCulture@PlotScenarioData@CvWorldBuilderMap@@2EB DB 0ffH ; CvWorldBuilderMap::PlotScenarioData::InvalidCulture
CONST	ENDS
;	COMDAT ?MaxHealth@City@CvWorldBuilderMap@@2IB
CONST	SEGMENT
?MaxHealth@City@CvWorldBuilderMap@@2IB DD 0186a0H	; CvWorldBuilderMap::City::MaxHealth
CONST	ENDS
;	COMDAT ?MaxNameLength@City@CvWorldBuilderMap@@2IB
CONST	SEGMENT
?MaxNameLength@City@CvWorldBuilderMap@@2IB DD 040H	; CvWorldBuilderMap::City::MaxNameLength
CONST	ENDS
;	COMDAT ?MaxBuildingTypes@City@CvWorldBuilderMap@@2IB
CONST	SEGMENT
?MaxBuildingTypes@City@CvWorldBuilderMap@@2IB DD 0200H	; CvWorldBuilderMap::City::MaxBuildingTypes
CONST	ENDS
;	COMDAT ?MaxHealth@CityV2@CvWorldBuilderMap@@2IB
CONST	SEGMENT
?MaxHealth@CityV2@CvWorldBuilderMap@@2IB DD 0186a0H	; CvWorldBuilderMap::CityV2::MaxHealth
CONST	ENDS
;	COMDAT ?MaxNameLength@CityV2@CvWorldBuilderMap@@2IB
CONST	SEGMENT
?MaxNameLength@CityV2@CvWorldBuilderMap@@2IB DD 040H	; CvWorldBuilderMap::CityV2::MaxNameLength
CONST	ENDS
;	COMDAT ?MaxBuildingTypes@CityV2@CvWorldBuilderMap@@2IB
CONST	SEGMENT
?MaxBuildingTypes@CityV2@CvWorldBuilderMap@@2IB DD 0100H ; CvWorldBuilderMap::CityV2::MaxBuildingTypes
CONST	ENDS
;	COMDAT ?MaxBuildingTypes@OldCity@CvWorldBuilderMap@@2IB
CONST	SEGMENT
?MaxBuildingTypes@OldCity@CvWorldBuilderMap@@2IB DD 0100H ; CvWorldBuilderMap::OldCity::MaxBuildingTypes
CONST	ENDS
;	COMDAT ?MaxHealth@Unit@CvWorldBuilderMap@@2IB
CONST	SEGMENT
?MaxHealth@Unit@CvWorldBuilderMap@@2IB DD 0186a0H	; CvWorldBuilderMap::Unit::MaxHealth
CONST	ENDS
;	COMDAT ?MaxPromotionTypes@Unit@CvWorldBuilderMap@@2IB
CONST	SEGMENT
?MaxPromotionTypes@Unit@CvWorldBuilderMap@@2IB DD 0200H	; CvWorldBuilderMap::Unit::MaxPromotionTypes
CONST	ENDS
;	COMDAT ?InvalidUnitType@Unit@CvWorldBuilderMap@@2IB
CONST	SEGMENT
?InvalidUnitType@Unit@CvWorldBuilderMap@@2IB DD 0ffffffffH ; CvWorldBuilderMap::Unit::InvalidUnitType
CONST	ENDS
;	COMDAT ?MaxHealth@UnitV2@CvWorldBuilderMap@@2IB
CONST	SEGMENT
?MaxHealth@UnitV2@CvWorldBuilderMap@@2IB DD 0186a0H	; CvWorldBuilderMap::UnitV2::MaxHealth
CONST	ENDS
;	COMDAT ?MaxPromotionTypes@UnitV2@CvWorldBuilderMap@@2IB
CONST	SEGMENT
?MaxPromotionTypes@UnitV2@CvWorldBuilderMap@@2IB DD 0100H ; CvWorldBuilderMap::UnitV2::MaxPromotionTypes
CONST	ENDS
;	COMDAT ?InvalidUnitType@UnitV2@CvWorldBuilderMap@@2EB
CONST	SEGMENT
?InvalidUnitType@UnitV2@CvWorldBuilderMap@@2EB DB 0ffH	; CvWorldBuilderMap::UnitV2::InvalidUnitType
CONST	ENDS
;	COMDAT ?MaxLength@UnitName@CvWorldBuilderMap@@2IB
CONST	SEGMENT
?MaxLength@UnitName@CvWorldBuilderMap@@2IB DD 040H	; CvWorldBuilderMap::UnitName::MaxLength
CONST	ENDS
;	COMDAT ?InvalidUnitType@OldUnit@CvWorldBuilderMap@@2EB
CONST	SEGMENT
?InvalidUnitType@OldUnit@CvWorldBuilderMap@@2EB DB 0ffH	; CvWorldBuilderMap::OldUnit::InvalidUnitType
CONST	ENDS
;	COMDAT ?InvalidNaturalWonder@PlotMapData@CvWorldBuilderMap@@2EB
CONST	SEGMENT
?InvalidNaturalWonder@PlotMapData@CvWorldBuilderMap@@2EB DB 0ffH ; CvWorldBuilderMap::PlotMapData::InvalidNaturalWonder
CONST	ENDS
;	COMDAT ?InvalidFeature@PlotMapData@CvWorldBuilderMap@@2EB
CONST	SEGMENT
?InvalidFeature@PlotMapData@CvWorldBuilderMap@@2EB DB 0ffH ; CvWorldBuilderMap::PlotMapData::InvalidFeature
CONST	ENDS
;	COMDAT ?InvalidResource@PlotMapData@CvWorldBuilderMap@@2EB
CONST	SEGMENT
?InvalidResource@PlotMapData@CvWorldBuilderMap@@2EB DB 0ffH ; CvWorldBuilderMap::PlotMapData::InvalidResource
CONST	ENDS
;	COMDAT ?BarbarianPlayer@CvWorldBuilderMap@@2IB
CONST	SEGMENT
?BarbarianPlayer@CvWorldBuilderMap@@2IB DD 060H		; CvWorldBuilderMap::BarbarianPlayer
CONST	ENDS
;	COMDAT ?MaxTeams@CvWorldBuilderMap@@2IB
CONST	SEGMENT
?MaxTeams@CvWorldBuilderMap@@2IB DD 060H		; CvWorldBuilderMap::MaxTeams
CONST	ENDS
;	COMDAT ?MaxCityStates@CvWorldBuilderMap@@2IB
CONST	SEGMENT
?MaxCityStates@CvWorldBuilderMap@@2IB DD 040H		; CvWorldBuilderMap::MaxCityStates
CONST	ENDS
;	COMDAT ?MaxPlayers@CvWorldBuilderMap@@2IB
CONST	SEGMENT
?MaxPlayers@CvWorldBuilderMap@@2IB DD 020H		; CvWorldBuilderMap::MaxPlayers
CONST	ENDS
;	COMDAT ?MaxMapSize@CvWorldBuilderMap@@2IB
CONST	SEGMENT
?MaxMapSize@CvWorldBuilderMap@@2IB DD 08000H		; CvWorldBuilderMap::MaxMapSize
CONST	ENDS
;	COMDAT ?FileVersion@CvWorldBuilderMap@@2IB
CONST	SEGMENT
?FileVersion@CvWorldBuilderMap@@2IB DD 0cH		; CvWorldBuilderMap::FileVersion
CONST	ENDS
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	?erase@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE?AV?$_Vector_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@V?$_Vector_const_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@0@Z ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::erase
PUBLIC	?InitTypeDesc@@YAXXZ				; InitTypeDesc
EXTRN	?getPromotionInfo@CvGlobals@@QAEPAVCvPromotionEntry@@W4PromotionTypes@@@Z:PROC ; CvGlobals::getPromotionInfo
EXTRN	?getNumPromotionInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumPromotionInfos
EXTRN	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z:PROC ; CvGlobals::getBuildingInfo
EXTRN	?getNumBuildingInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumBuildingInfos
EXTRN	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z:PROC ; CvGlobals::getPolicyInfo
EXTRN	?getNumPolicyInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumPolicyInfos
EXTRN	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z:PROC ; CvGlobals::getTechInfo
EXTRN	?getNumTechInfos@CvGlobals@@QAEHXZ:PROC		; CvGlobals::getNumTechInfos
EXTRN	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z:PROC ; CvGlobals::getUnitInfo
EXTRN	?getNumUnitInfos@CvGlobals@@QAEHXZ:PROC		; CvGlobals::getNumUnitInfos
EXTRN	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z:PROC ; CvGlobals::getImprovementInfo
EXTRN	?getNumImprovementInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumImprovementInfos
EXTRN	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z:PROC ; CvGlobals::getResourceInfo
EXTRN	?getNumResourceInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumResourceInfos
EXTRN	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z:PROC ; CvGlobals::getFeatureInfo
EXTRN	?getNumFeatureInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumFeatureInfos
EXTRN	?Add@TypeMap@CvWorldBuilderMapTypeDesc@@QAEIPBD@Z:PROC ; CvWorldBuilderMapTypeDesc::TypeMap::Add
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
EXTRN	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z:PROC ; CvGlobals::getTerrainInfo
EXTRN	?getNumTerrainInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumTerrainInfos
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvworldbuildermaploader.cpp
;	COMDAT ?InitTypeDesc@@YAXXZ
_TEXT	SEGMENT
$T227515 = -476						; size = 4
$T227499 = -472						; size = 4
$T227689 = -468						; size = 4
$T227688 = -464						; size = 4
$T227687 = -460						; size = 4
$T227686 = -456						; size = 4
$T227685 = -452						; size = 4
$T227307 = -396						; size = 4
$T227291 = -392						; size = 4
$T227465 = -388						; size = 4
$T227464 = -384						; size = 4
$T227463 = -380						; size = 4
$T227462 = -376						; size = 4
$T227461 = -372						; size = 4
$T227125 = -336						; size = 4
$T227109 = -332						; size = 4
$T227259 = -328						; size = 4
$T227258 = -324						; size = 4
$T227257 = -320						; size = 4
$T227256 = -316						; size = 4
$T227255 = -312						; size = 4
$T226943 = -276						; size = 4
$T226927 = -272						; size = 4
$T227077 = -268						; size = 4
$T227076 = -264						; size = 4
$T227075 = -260						; size = 4
$T227074 = -256						; size = 4
$T227073 = -252						; size = 4
$T226861 = -248						; size = 4
$T226845 = -244						; size = 4
$T226895 = -240						; size = 4
$T226894 = -236						; size = 4
$T226893 = -232						; size = 4
$T226892 = -228						; size = 4
$T226891 = -224						; size = 4
$T226779 = -220						; size = 4
$T226763 = -216						; size = 4
$T226813 = -212						; size = 4
$T226812 = -208						; size = 4
$T226811 = -204						; size = 4
$T226810 = -200						; size = 4
$T226809 = -196						; size = 4
$T226697 = -192						; size = 4
$T226681 = -188						; size = 4
$T226731 = -184						; size = 4
$T226730 = -180						; size = 4
$T226729 = -176						; size = 4
$T226728 = -172						; size = 4
$T226727 = -168						; size = 4
$T226612 = -164						; size = 4
$T226596 = -160						; size = 4
$T226645 = -156						; size = 4
$T226644 = -152						; size = 4
$T226643 = -148						; size = 4
$T226642 = -144						; size = 4
$T226641 = -140						; size = 4
$T226530 = -136						; size = 4
$T226514 = -132						; size = 4
$T226563 = -128						; size = 4
$T226562 = -124						; size = 4
$T226561 = -120						; size = 4
$T226560 = -116						; size = 4
$T226559 = -112						; size = 4
_pkPromotionInfo$223751 = -108				; size = 4
_i$223747 = -104					; size = 4
_pkBuildingInfo$223742 = -100				; size = 4
_i$223738 = -96						; size = 4
_pkPolicyInfo$223733 = -92				; size = 4
_i$223729 = -88						; size = 4
_pkTechInfo$223724 = -84				; size = 4
_i$223720 = -80						; size = 4
_pkUnitInfo$223715 = -76				; size = 4
_i$223711 = -72						; size = 4
_pkImprovementInfo$223706 = -68				; size = 4
_i$223702 = -64						; size = 4
_pkResourceInfo$223697 = -60				; size = 4
_i$223693 = -56						; size = 4
_pkFeatureInfo$223688 = -52				; size = 4
_i$223684 = -48						; size = 4
_pkTerrainInfo$223679 = -44				; size = 4
_i$223675 = -40						; size = 4
_iPromotionCount$223746 = -36				; size = 4
_iPolicyCount$223728 = -32				; size = 4
_iTerrainTypeCount$223674 = -28				; size = 4
_iImprovementCount$223701 = -24				; size = 4
_iResourceCount$223692 = -20				; size = 4
_iBuildingCount$223737 = -16				; size = 4
_iFeatureCount$223683 = -12				; size = 4
_iTechCount$223719 = -8					; size = 4
_iUnitCount$223710 = -4					; size = 4
?InitTypeDesc@@YAXXZ PROC				; InitTypeDesc, COMDAT

; 30   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 540				; 0000021cH

; 31   : 	//static bool bFirst = true;
; 32   : 	//if( bFirst ) // Do this every time as mod data may have changed.
; 33   : 	{
; 34   : 		sg_kMapTypeDesc.m_kTerrainTypes.Clear();

	mov	eax, DWORD PTR _sg_kMapTypeDesc+8
	mov	DWORD PTR $T226514[ebp], eax
	mov	ecx, DWORD PTR $T226514[ebp]
	mov	DWORD PTR $T226560[ebp], ecx
	mov	edx, DWORD PTR $T226560[ebp]
	mov	DWORD PTR $T226559[ebp], edx
	mov	eax, DWORD PTR _sg_kMapTypeDesc+4
	mov	DWORD PTR $T226530[ebp], eax
	mov	ecx, DWORD PTR $T226530[ebp]
	mov	DWORD PTR $T226562[ebp], ecx
	mov	edx, DWORD PTR $T226562[ebp]
	mov	DWORD PTR $T226561[ebp], edx
	mov	eax, DWORD PTR $T226559[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226561[ebp]
	push	ecx
	lea	edx, DWORD PTR $T226563[ebp]
	push	edx
	mov	ecx, OFFSET _sg_kMapTypeDesc
	call	?erase@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE?AV?$_Vector_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@V?$_Vector_const_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@0@Z ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::erase

; 35   : 		const int iTerrainTypeCount = GC.getNumTerrainInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTerrainInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTerrainInfos
	mov	DWORD PTR _iTerrainTypeCount$223674[ebp], eax

; 36   : 		for(int i = 0; i < iTerrainTypeCount; ++i)

	mov	DWORD PTR _i$223675[ebp], 0
	jmp	SHORT $LN45@InitTypeDe
$LN44@InitTypeDe:
	mov	eax, DWORD PTR _i$223675[ebp]
	add	eax, 1
	mov	DWORD PTR _i$223675[ebp], eax
$LN45@InitTypeDe:
	mov	ecx, DWORD PTR _i$223675[ebp]
	cmp	ecx, DWORD PTR _iTerrainTypeCount$223674[ebp]
	jge	SHORT $LN43@InitTypeDe

; 37   : 		{
; 38   : 			const CvTerrainInfo* pkTerrainInfo = GC.getTerrainInfo((TerrainTypes)i);

	mov	edx, DWORD PTR _i$223675[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo
	mov	DWORD PTR _pkTerrainInfo$223679[ebp], eax

; 39   : 			if(pkTerrainInfo != NULL)

	cmp	DWORD PTR _pkTerrainInfo$223679[ebp], 0
	je	SHORT $LN42@InitTypeDe

; 40   : 			{
; 41   : 				sg_kMapTypeDesc.m_kTerrainTypes.Add( pkTerrainInfo->GetType() );

	mov	ecx, DWORD PTR _pkTerrainInfo$223679[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, OFFSET _sg_kMapTypeDesc
	call	?Add@TypeMap@CvWorldBuilderMapTypeDesc@@QAEIPBD@Z ; CvWorldBuilderMapTypeDesc::TypeMap::Add

; 42   : 			}
; 43   : 			else

	jmp	SHORT $LN41@InitTypeDe
$LN42@InitTypeDe:

; 44   : 			{
; 45   : 				sg_kMapTypeDesc.m_kTerrainTypes.Add( NULL );

	push	0
	mov	ecx, OFFSET _sg_kMapTypeDesc
	call	?Add@TypeMap@CvWorldBuilderMapTypeDesc@@QAEIPBD@Z ; CvWorldBuilderMapTypeDesc::TypeMap::Add
$LN41@InitTypeDe:

; 46   : 			}
; 47   : 		}

	jmp	SHORT $LN44@InitTypeDe
$LN43@InitTypeDe:

; 48   : 
; 49   : 		sg_kMapTypeDesc.m_kFeatures.Clear();

	mov	eax, DWORD PTR _sg_kMapTypeDesc+24
	mov	DWORD PTR $T226596[ebp], eax
	mov	ecx, DWORD PTR $T226596[ebp]
	mov	DWORD PTR $T226642[ebp], ecx
	mov	edx, DWORD PTR $T226642[ebp]
	mov	DWORD PTR $T226641[ebp], edx
	mov	eax, DWORD PTR _sg_kMapTypeDesc+20
	mov	DWORD PTR $T226612[ebp], eax
	mov	ecx, DWORD PTR $T226612[ebp]
	mov	DWORD PTR $T226644[ebp], ecx
	mov	edx, DWORD PTR $T226644[ebp]
	mov	DWORD PTR $T226643[ebp], edx
	mov	eax, DWORD PTR $T226641[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226643[ebp]
	push	ecx
	lea	edx, DWORD PTR $T226645[ebp]
	push	edx
	mov	ecx, OFFSET _sg_kMapTypeDesc+16
	call	?erase@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE?AV?$_Vector_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@V?$_Vector_const_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@0@Z ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::erase

; 50   : 		const int iFeatureCount = GC.getNumFeatureInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumFeatureInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumFeatureInfos
	mov	DWORD PTR _iFeatureCount$223683[ebp], eax

; 51   : 		for(int i = 0; i < iFeatureCount; ++i)

	mov	DWORD PTR _i$223684[ebp], 0
	jmp	SHORT $LN40@InitTypeDe
$LN39@InitTypeDe:
	mov	eax, DWORD PTR _i$223684[ebp]
	add	eax, 1
	mov	DWORD PTR _i$223684[ebp], eax
$LN40@InitTypeDe:
	mov	ecx, DWORD PTR _i$223684[ebp]
	cmp	ecx, DWORD PTR _iFeatureCount$223683[ebp]
	jge	SHORT $LN38@InitTypeDe

; 52   : 		{
; 53   : 			const CvFeatureInfo* pkFeatureInfo = GC.getFeatureInfo((FeatureTypes)i);

	mov	edx, DWORD PTR _i$223684[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	DWORD PTR _pkFeatureInfo$223688[ebp], eax

; 54   : 			if(pkFeatureInfo != NULL)

	cmp	DWORD PTR _pkFeatureInfo$223688[ebp], 0
	je	SHORT $LN37@InitTypeDe

; 55   : 			{
; 56   : 				sg_kMapTypeDesc.m_kFeatures.Add( pkFeatureInfo->GetType() );

	mov	ecx, DWORD PTR _pkFeatureInfo$223688[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, OFFSET _sg_kMapTypeDesc+16
	call	?Add@TypeMap@CvWorldBuilderMapTypeDesc@@QAEIPBD@Z ; CvWorldBuilderMapTypeDesc::TypeMap::Add

; 57   : 				sg_kMapTypeDesc.m_kNaturalWonders.Add( pkFeatureInfo->GetType() );

	mov	ecx, DWORD PTR _pkFeatureInfo$223688[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, OFFSET _sg_kMapTypeDesc+32
	call	?Add@TypeMap@CvWorldBuilderMapTypeDesc@@QAEIPBD@Z ; CvWorldBuilderMapTypeDesc::TypeMap::Add

; 58   : 			}
; 59   : 			else

	jmp	SHORT $LN36@InitTypeDe
$LN37@InitTypeDe:

; 60   : 			{
; 61   : 				sg_kMapTypeDesc.m_kFeatures.Add( NULL );

	push	0
	mov	ecx, OFFSET _sg_kMapTypeDesc+16
	call	?Add@TypeMap@CvWorldBuilderMapTypeDesc@@QAEIPBD@Z ; CvWorldBuilderMapTypeDesc::TypeMap::Add

; 62   : 				sg_kMapTypeDesc.m_kNaturalWonders.Add( NULL );

	push	0
	mov	ecx, OFFSET _sg_kMapTypeDesc+32
	call	?Add@TypeMap@CvWorldBuilderMapTypeDesc@@QAEIPBD@Z ; CvWorldBuilderMapTypeDesc::TypeMap::Add
$LN36@InitTypeDe:

; 63   : 			}
; 64   : 		}

	jmp	SHORT $LN39@InitTypeDe
$LN38@InitTypeDe:

; 65   : 
; 66   : 		sg_kMapTypeDesc.m_kResources.Clear();

	mov	eax, DWORD PTR _sg_kMapTypeDesc+56
	mov	DWORD PTR $T226681[ebp], eax
	mov	ecx, DWORD PTR $T226681[ebp]
	mov	DWORD PTR $T226728[ebp], ecx
	mov	edx, DWORD PTR $T226728[ebp]
	mov	DWORD PTR $T226727[ebp], edx
	mov	eax, DWORD PTR _sg_kMapTypeDesc+52
	mov	DWORD PTR $T226697[ebp], eax
	mov	ecx, DWORD PTR $T226697[ebp]
	mov	DWORD PTR $T226730[ebp], ecx
	mov	edx, DWORD PTR $T226730[ebp]
	mov	DWORD PTR $T226729[ebp], edx
	mov	eax, DWORD PTR $T226727[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226729[ebp]
	push	ecx
	lea	edx, DWORD PTR $T226731[ebp]
	push	edx
	mov	ecx, OFFSET _sg_kMapTypeDesc+48
	call	?erase@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE?AV?$_Vector_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@V?$_Vector_const_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@0@Z ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::erase

; 67   : 		const int iResourceCount = GC.getNumResourceInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	mov	DWORD PTR _iResourceCount$223692[ebp], eax

; 68   : 		for(int i = 0; i < iResourceCount; ++i)

	mov	DWORD PTR _i$223693[ebp], 0
	jmp	SHORT $LN35@InitTypeDe
$LN34@InitTypeDe:
	mov	eax, DWORD PTR _i$223693[ebp]
	add	eax, 1
	mov	DWORD PTR _i$223693[ebp], eax
$LN35@InitTypeDe:
	mov	ecx, DWORD PTR _i$223693[ebp]
	cmp	ecx, DWORD PTR _iResourceCount$223692[ebp]
	jge	SHORT $LN33@InitTypeDe

; 69   : 		{
; 70   : 			const CvResourceInfo* pkResourceInfo = GC.getResourceInfo((ResourceTypes)i);

	mov	edx, DWORD PTR _i$223693[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	DWORD PTR _pkResourceInfo$223697[ebp], eax

; 71   : 			if(pkResourceInfo != NULL)

	cmp	DWORD PTR _pkResourceInfo$223697[ebp], 0
	je	SHORT $LN32@InitTypeDe

; 72   : 			{
; 73   : 				sg_kMapTypeDesc.m_kResources.Add( pkResourceInfo->GetType() );

	mov	ecx, DWORD PTR _pkResourceInfo$223697[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, OFFSET _sg_kMapTypeDesc+48
	call	?Add@TypeMap@CvWorldBuilderMapTypeDesc@@QAEIPBD@Z ; CvWorldBuilderMapTypeDesc::TypeMap::Add

; 74   : 			}
; 75   : 			else

	jmp	SHORT $LN31@InitTypeDe
$LN32@InitTypeDe:

; 76   : 			{
; 77   : 				sg_kMapTypeDesc.m_kResources.Add( NULL );

	push	0
	mov	ecx, OFFSET _sg_kMapTypeDesc+48
	call	?Add@TypeMap@CvWorldBuilderMapTypeDesc@@QAEIPBD@Z ; CvWorldBuilderMapTypeDesc::TypeMap::Add
$LN31@InitTypeDe:

; 78   : 			}
; 79   : 		}

	jmp	SHORT $LN34@InitTypeDe
$LN33@InitTypeDe:

; 80   : 
; 81   : 		sg_kMapTypeDesc.m_kImprovements.Clear();

	mov	eax, DWORD PTR _sg_kMapTypeDesc+72
	mov	DWORD PTR $T226763[ebp], eax
	mov	ecx, DWORD PTR $T226763[ebp]
	mov	DWORD PTR $T226810[ebp], ecx
	mov	edx, DWORD PTR $T226810[ebp]
	mov	DWORD PTR $T226809[ebp], edx
	mov	eax, DWORD PTR _sg_kMapTypeDesc+68
	mov	DWORD PTR $T226779[ebp], eax
	mov	ecx, DWORD PTR $T226779[ebp]
	mov	DWORD PTR $T226812[ebp], ecx
	mov	edx, DWORD PTR $T226812[ebp]
	mov	DWORD PTR $T226811[ebp], edx
	mov	eax, DWORD PTR $T226809[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226811[ebp]
	push	ecx
	lea	edx, DWORD PTR $T226813[ebp]
	push	edx
	mov	ecx, OFFSET _sg_kMapTypeDesc+64
	call	?erase@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE?AV?$_Vector_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@V?$_Vector_const_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@0@Z ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::erase

; 82   : 		const int iImprovementCount = GC.getNumImprovementInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumImprovementInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumImprovementInfos
	mov	DWORD PTR _iImprovementCount$223701[ebp], eax

; 83   : 		for(int i = 0; i < iImprovementCount; ++i)

	mov	DWORD PTR _i$223702[ebp], 0
	jmp	SHORT $LN30@InitTypeDe
$LN29@InitTypeDe:
	mov	eax, DWORD PTR _i$223702[ebp]
	add	eax, 1
	mov	DWORD PTR _i$223702[ebp], eax
$LN30@InitTypeDe:
	mov	ecx, DWORD PTR _i$223702[ebp]
	cmp	ecx, DWORD PTR _iImprovementCount$223701[ebp]
	jge	SHORT $LN28@InitTypeDe

; 84   : 		{
; 85   : 			const CvImprovementEntry* pkImprovementInfo = GC.getImprovementInfo((ImprovementTypes)i);

	mov	edx, DWORD PTR _i$223702[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	DWORD PTR _pkImprovementInfo$223706[ebp], eax

; 86   : 			if(pkImprovementInfo != NULL)

	cmp	DWORD PTR _pkImprovementInfo$223706[ebp], 0
	je	SHORT $LN27@InitTypeDe

; 87   : 			{
; 88   : 				sg_kMapTypeDesc.m_kImprovements.Add( pkImprovementInfo->GetType() );

	mov	ecx, DWORD PTR _pkImprovementInfo$223706[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, OFFSET _sg_kMapTypeDesc+64
	call	?Add@TypeMap@CvWorldBuilderMapTypeDesc@@QAEIPBD@Z ; CvWorldBuilderMapTypeDesc::TypeMap::Add

; 89   : 			}
; 90   : 			else

	jmp	SHORT $LN26@InitTypeDe
$LN27@InitTypeDe:

; 91   : 			{
; 92   : 				sg_kMapTypeDesc.m_kImprovements.Add( NULL );

	push	0
	mov	ecx, OFFSET _sg_kMapTypeDesc+64
	call	?Add@TypeMap@CvWorldBuilderMapTypeDesc@@QAEIPBD@Z ; CvWorldBuilderMapTypeDesc::TypeMap::Add
$LN26@InitTypeDe:

; 93   : 			}
; 94   : 		}

	jmp	SHORT $LN29@InitTypeDe
$LN28@InitTypeDe:

; 95   : 
; 96   : 		sg_kMapTypeDesc.m_kUnits.Clear();

	mov	eax, DWORD PTR _sg_kMapTypeDesc+88
	mov	DWORD PTR $T226845[ebp], eax
	mov	ecx, DWORD PTR $T226845[ebp]
	mov	DWORD PTR $T226892[ebp], ecx
	mov	edx, DWORD PTR $T226892[ebp]
	mov	DWORD PTR $T226891[ebp], edx
	mov	eax, DWORD PTR _sg_kMapTypeDesc+84
	mov	DWORD PTR $T226861[ebp], eax
	mov	ecx, DWORD PTR $T226861[ebp]
	mov	DWORD PTR $T226894[ebp], ecx
	mov	edx, DWORD PTR $T226894[ebp]
	mov	DWORD PTR $T226893[ebp], edx
	mov	eax, DWORD PTR $T226891[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226893[ebp]
	push	ecx
	lea	edx, DWORD PTR $T226895[ebp]
	push	edx
	mov	ecx, OFFSET _sg_kMapTypeDesc+80
	call	?erase@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE?AV?$_Vector_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@V?$_Vector_const_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@0@Z ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::erase

; 97   : 		const int iUnitCount = GC.getNumUnitInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumUnitInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitInfos
	mov	DWORD PTR _iUnitCount$223710[ebp], eax

; 98   : 		for(int i = 0; i < iUnitCount; ++i)

	mov	DWORD PTR _i$223711[ebp], 0
	jmp	SHORT $LN25@InitTypeDe
$LN24@InitTypeDe:
	mov	eax, DWORD PTR _i$223711[ebp]
	add	eax, 1
	mov	DWORD PTR _i$223711[ebp], eax
$LN25@InitTypeDe:
	mov	ecx, DWORD PTR _i$223711[ebp]
	cmp	ecx, DWORD PTR _iUnitCount$223710[ebp]
	jge	SHORT $LN23@InitTypeDe

; 99   : 		{
; 100  : 			const CvUnitEntry* pkUnitInfo = GC.getUnitInfo((UnitTypes)i);

	mov	edx, DWORD PTR _i$223711[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	DWORD PTR _pkUnitInfo$223715[ebp], eax

; 101  : 			if(pkUnitInfo != NULL)

	cmp	DWORD PTR _pkUnitInfo$223715[ebp], 0
	je	SHORT $LN22@InitTypeDe

; 102  : 			{
; 103  : 				sg_kMapTypeDesc.m_kUnits.Add( pkUnitInfo->GetType() );

	mov	ecx, DWORD PTR _pkUnitInfo$223715[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, OFFSET _sg_kMapTypeDesc+80
	call	?Add@TypeMap@CvWorldBuilderMapTypeDesc@@QAEIPBD@Z ; CvWorldBuilderMapTypeDesc::TypeMap::Add

; 104  : 			}
; 105  : 			else

	jmp	SHORT $LN21@InitTypeDe
$LN22@InitTypeDe:

; 106  : 			{
; 107  : 				sg_kMapTypeDesc.m_kUnits.Add( NULL );

	push	0
	mov	ecx, OFFSET _sg_kMapTypeDesc+80
	call	?Add@TypeMap@CvWorldBuilderMapTypeDesc@@QAEIPBD@Z ; CvWorldBuilderMapTypeDesc::TypeMap::Add
$LN21@InitTypeDe:

; 108  : 			}
; 109  : 		}

	jmp	SHORT $LN24@InitTypeDe
$LN23@InitTypeDe:

; 110  : 
; 111  : 		sg_kMapTypeDesc.m_kTechs.Clear();

	mov	eax, DWORD PTR _sg_kMapTypeDesc+120
	mov	DWORD PTR $T226927[ebp], eax
	mov	ecx, DWORD PTR $T226927[ebp]
	mov	DWORD PTR $T227074[ebp], ecx
	mov	edx, DWORD PTR $T227074[ebp]
	mov	DWORD PTR $T227073[ebp], edx
	mov	eax, DWORD PTR _sg_kMapTypeDesc+116
	mov	DWORD PTR $T226943[ebp], eax
	mov	ecx, DWORD PTR $T226943[ebp]
	mov	DWORD PTR $T227076[ebp], ecx
	mov	edx, DWORD PTR $T227076[ebp]
	mov	DWORD PTR $T227075[ebp], edx
	mov	eax, DWORD PTR $T227073[ebp]
	push	eax
	mov	ecx, DWORD PTR $T227075[ebp]
	push	ecx
	lea	edx, DWORD PTR $T227077[ebp]
	push	edx
	mov	ecx, OFFSET _sg_kMapTypeDesc+112
	call	?erase@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE?AV?$_Vector_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@V?$_Vector_const_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@0@Z ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::erase

; 112  : 		const int iTechCount = GC.getNumTechInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	mov	DWORD PTR _iTechCount$223719[ebp], eax

; 113  : 		for(int i = 0; i < iTechCount; ++i)

	mov	DWORD PTR _i$223720[ebp], 0
	jmp	SHORT $LN20@InitTypeDe
$LN19@InitTypeDe:
	mov	eax, DWORD PTR _i$223720[ebp]
	add	eax, 1
	mov	DWORD PTR _i$223720[ebp], eax
$LN20@InitTypeDe:
	mov	ecx, DWORD PTR _i$223720[ebp]
	cmp	ecx, DWORD PTR _iTechCount$223719[ebp]
	jge	SHORT $LN18@InitTypeDe

; 114  : 		{
; 115  : 			const CvTechEntry* pkTechInfo = GC.getTechInfo((TechTypes)i);

	mov	edx, DWORD PTR _i$223720[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo
	mov	DWORD PTR _pkTechInfo$223724[ebp], eax

; 116  : 			if(pkTechInfo != NULL)

	cmp	DWORD PTR _pkTechInfo$223724[ebp], 0
	je	SHORT $LN17@InitTypeDe

; 117  : 			{
; 118  : 				sg_kMapTypeDesc.m_kTechs.Add( pkTechInfo->GetType() );

	mov	ecx, DWORD PTR _pkTechInfo$223724[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, OFFSET _sg_kMapTypeDesc+112
	call	?Add@TypeMap@CvWorldBuilderMapTypeDesc@@QAEIPBD@Z ; CvWorldBuilderMapTypeDesc::TypeMap::Add

; 119  : 			}
; 120  : 			else

	jmp	SHORT $LN16@InitTypeDe
$LN17@InitTypeDe:

; 121  : 			{
; 122  : 				sg_kMapTypeDesc.m_kTechs.Add( NULL );

	push	0
	mov	ecx, OFFSET _sg_kMapTypeDesc+112
	call	?Add@TypeMap@CvWorldBuilderMapTypeDesc@@QAEIPBD@Z ; CvWorldBuilderMapTypeDesc::TypeMap::Add
$LN16@InitTypeDe:

; 123  : 			}
; 124  : 		}

	jmp	SHORT $LN19@InitTypeDe
$LN18@InitTypeDe:

; 125  : 
; 126  : 		sg_kMapTypeDesc.m_kPolicies.Clear();

	mov	eax, DWORD PTR _sg_kMapTypeDesc+136
	mov	DWORD PTR $T227109[ebp], eax
	mov	ecx, DWORD PTR $T227109[ebp]
	mov	DWORD PTR $T227256[ebp], ecx
	mov	edx, DWORD PTR $T227256[ebp]
	mov	DWORD PTR $T227255[ebp], edx
	mov	eax, DWORD PTR _sg_kMapTypeDesc+132
	mov	DWORD PTR $T227125[ebp], eax
	mov	ecx, DWORD PTR $T227125[ebp]
	mov	DWORD PTR $T227258[ebp], ecx
	mov	edx, DWORD PTR $T227258[ebp]
	mov	DWORD PTR $T227257[ebp], edx
	mov	eax, DWORD PTR $T227255[ebp]
	push	eax
	mov	ecx, DWORD PTR $T227257[ebp]
	push	ecx
	lea	edx, DWORD PTR $T227259[ebp]
	push	edx
	mov	ecx, OFFSET _sg_kMapTypeDesc+128
	call	?erase@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE?AV?$_Vector_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@V?$_Vector_const_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@0@Z ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::erase

; 127  : 		const int iPolicyCount = GC.getNumPolicyInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumPolicyInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPolicyInfos
	mov	DWORD PTR _iPolicyCount$223728[ebp], eax

; 128  : 		for(int i = 0; i < iPolicyCount; ++i)

	mov	DWORD PTR _i$223729[ebp], 0
	jmp	SHORT $LN15@InitTypeDe
$LN14@InitTypeDe:
	mov	eax, DWORD PTR _i$223729[ebp]
	add	eax, 1
	mov	DWORD PTR _i$223729[ebp], eax
$LN15@InitTypeDe:
	mov	ecx, DWORD PTR _i$223729[ebp]
	cmp	ecx, DWORD PTR _iPolicyCount$223728[ebp]
	jge	SHORT $LN13@InitTypeDe

; 129  : 		{
; 130  : 			const CvPolicyEntry* pkPolicyInfo = GC.getPolicyInfo((PolicyTypes)i);

	mov	edx, DWORD PTR _i$223729[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z ; CvGlobals::getPolicyInfo
	mov	DWORD PTR _pkPolicyInfo$223733[ebp], eax

; 131  : 			if(pkPolicyInfo != NULL)

	cmp	DWORD PTR _pkPolicyInfo$223733[ebp], 0
	je	SHORT $LN12@InitTypeDe

; 132  : 			{
; 133  : 				sg_kMapTypeDesc.m_kPolicies.Add( pkPolicyInfo->GetType() );

	mov	ecx, DWORD PTR _pkPolicyInfo$223733[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, OFFSET _sg_kMapTypeDesc+128
	call	?Add@TypeMap@CvWorldBuilderMapTypeDesc@@QAEIPBD@Z ; CvWorldBuilderMapTypeDesc::TypeMap::Add

; 134  : 			}
; 135  : 			else

	jmp	SHORT $LN11@InitTypeDe
$LN12@InitTypeDe:

; 136  : 			{
; 137  : 				sg_kMapTypeDesc.m_kPolicies.Add( NULL );

	push	0
	mov	ecx, OFFSET _sg_kMapTypeDesc+128
	call	?Add@TypeMap@CvWorldBuilderMapTypeDesc@@QAEIPBD@Z ; CvWorldBuilderMapTypeDesc::TypeMap::Add
$LN11@InitTypeDe:

; 138  : 			}
; 139  : 		}

	jmp	SHORT $LN14@InitTypeDe
$LN13@InitTypeDe:

; 140  : 
; 141  : 		sg_kMapTypeDesc.m_kBuildingTypes.Clear();

	mov	eax, DWORD PTR _sg_kMapTypeDesc+104
	mov	DWORD PTR $T227291[ebp], eax
	mov	ecx, DWORD PTR $T227291[ebp]
	mov	DWORD PTR $T227462[ebp], ecx
	mov	edx, DWORD PTR $T227462[ebp]
	mov	DWORD PTR $T227461[ebp], edx
	mov	eax, DWORD PTR _sg_kMapTypeDesc+100
	mov	DWORD PTR $T227307[ebp], eax
	mov	ecx, DWORD PTR $T227307[ebp]
	mov	DWORD PTR $T227464[ebp], ecx
	mov	edx, DWORD PTR $T227464[ebp]
	mov	DWORD PTR $T227463[ebp], edx
	mov	eax, DWORD PTR $T227461[ebp]
	push	eax
	mov	ecx, DWORD PTR $T227463[ebp]
	push	ecx
	lea	edx, DWORD PTR $T227465[ebp]
	push	edx
	mov	ecx, OFFSET _sg_kMapTypeDesc+96
	call	?erase@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE?AV?$_Vector_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@V?$_Vector_const_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@0@Z ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::erase

; 142  : 		const int iBuildingCount = GC.getNumBuildingInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	mov	DWORD PTR _iBuildingCount$223737[ebp], eax

; 143  : 		for(int i = 0; i < iBuildingCount; ++i)

	mov	DWORD PTR _i$223738[ebp], 0
	jmp	SHORT $LN10@InitTypeDe
$LN9@InitTypeDe:
	mov	eax, DWORD PTR _i$223738[ebp]
	add	eax, 1
	mov	DWORD PTR _i$223738[ebp], eax
$LN10@InitTypeDe:
	mov	ecx, DWORD PTR _i$223738[ebp]
	cmp	ecx, DWORD PTR _iBuildingCount$223737[ebp]
	jge	SHORT $LN8@InitTypeDe

; 144  : 		{
; 145  : 			const CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo((BuildingTypes)i);

	mov	edx, DWORD PTR _i$223738[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	DWORD PTR _pkBuildingInfo$223742[ebp], eax

; 146  : 			if(pkBuildingInfo != NULL)

	cmp	DWORD PTR _pkBuildingInfo$223742[ebp], 0
	je	SHORT $LN7@InitTypeDe

; 147  : 			{
; 148  : 				sg_kMapTypeDesc.m_kBuildingTypes.Add( pkBuildingInfo->GetType() );

	mov	ecx, DWORD PTR _pkBuildingInfo$223742[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, OFFSET _sg_kMapTypeDesc+96
	call	?Add@TypeMap@CvWorldBuilderMapTypeDesc@@QAEIPBD@Z ; CvWorldBuilderMapTypeDesc::TypeMap::Add

; 149  : 			}
; 150  : 			else

	jmp	SHORT $LN6@InitTypeDe
$LN7@InitTypeDe:

; 151  : 			{
; 152  : 				sg_kMapTypeDesc.m_kBuildingTypes.Add( NULL );

	push	0
	mov	ecx, OFFSET _sg_kMapTypeDesc+96
	call	?Add@TypeMap@CvWorldBuilderMapTypeDesc@@QAEIPBD@Z ; CvWorldBuilderMapTypeDesc::TypeMap::Add
$LN6@InitTypeDe:

; 153  : 			}
; 154  : 		}

	jmp	SHORT $LN9@InitTypeDe
$LN8@InitTypeDe:

; 155  : 
; 156  : 		sg_kMapTypeDesc.m_kUnitPromotions.Clear();

	mov	eax, DWORD PTR _sg_kMapTypeDesc+152
	mov	DWORD PTR $T227499[ebp], eax
	mov	ecx, DWORD PTR $T227499[ebp]
	mov	DWORD PTR $T227686[ebp], ecx
	mov	edx, DWORD PTR $T227686[ebp]
	mov	DWORD PTR $T227685[ebp], edx
	mov	eax, DWORD PTR _sg_kMapTypeDesc+148
	mov	DWORD PTR $T227515[ebp], eax
	mov	ecx, DWORD PTR $T227515[ebp]
	mov	DWORD PTR $T227688[ebp], ecx
	mov	edx, DWORD PTR $T227688[ebp]
	mov	DWORD PTR $T227687[ebp], edx
	mov	eax, DWORD PTR $T227685[ebp]
	push	eax
	mov	ecx, DWORD PTR $T227687[ebp]
	push	ecx
	lea	edx, DWORD PTR $T227689[ebp]
	push	edx
	mov	ecx, OFFSET _sg_kMapTypeDesc+144
	call	?erase@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE?AV?$_Vector_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@V?$_Vector_const_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@0@Z ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::erase

; 157  : 		const int iPromotionCount = GC.getNumPromotionInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumPromotionInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPromotionInfos
	mov	DWORD PTR _iPromotionCount$223746[ebp], eax

; 158  : 		for(int i = 0; i < iPromotionCount; ++i)

	mov	DWORD PTR _i$223747[ebp], 0
	jmp	SHORT $LN5@InitTypeDe
$LN4@InitTypeDe:
	mov	eax, DWORD PTR _i$223747[ebp]
	add	eax, 1
	mov	DWORD PTR _i$223747[ebp], eax
$LN5@InitTypeDe:
	mov	ecx, DWORD PTR _i$223747[ebp]
	cmp	ecx, DWORD PTR _iPromotionCount$223746[ebp]
	jge	SHORT $LN46@InitTypeDe

; 159  : 		{
; 160  : 			const CvPromotionEntry* pkPromotionInfo = GC.getPromotionInfo((PromotionTypes)i);

	mov	edx, DWORD PTR _i$223747[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPromotionInfo@CvGlobals@@QAEPAVCvPromotionEntry@@W4PromotionTypes@@@Z ; CvGlobals::getPromotionInfo
	mov	DWORD PTR _pkPromotionInfo$223751[ebp], eax

; 161  : 			if(pkPromotionInfo != NULL)

	cmp	DWORD PTR _pkPromotionInfo$223751[ebp], 0
	je	SHORT $LN2@InitTypeDe

; 162  : 			{
; 163  : 				sg_kMapTypeDesc.m_kUnitPromotions.Add( pkPromotionInfo->GetType() );

	mov	ecx, DWORD PTR _pkPromotionInfo$223751[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, OFFSET _sg_kMapTypeDesc+144
	call	?Add@TypeMap@CvWorldBuilderMapTypeDesc@@QAEIPBD@Z ; CvWorldBuilderMapTypeDesc::TypeMap::Add

; 164  : 			}
; 165  : 			else

	jmp	SHORT $LN1@InitTypeDe
$LN2@InitTypeDe:

; 166  : 			{
; 167  : 				sg_kMapTypeDesc.m_kUnitPromotions.Add( NULL );

	push	0
	mov	ecx, OFFSET _sg_kMapTypeDesc+144
	call	?Add@TypeMap@CvWorldBuilderMapTypeDesc@@QAEIPBD@Z ; CvWorldBuilderMapTypeDesc::TypeMap::Add
$LN1@InitTypeDe:

; 168  : 			}
; 169  : 		}

	jmp	SHORT $LN4@InitTypeDe
$LN46@InitTypeDe:

; 170  : 
; 171  : 		//bFirst = false;
; 172  : 	}
; 173  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InitTypeDesc@@YAXXZ ENDP				; InitTypeDesc
_TEXT	ENDS
PUBLIC	?GetCurrentMapInfo@CvWorldBuilderMapLoader@@SAABUCvWorldBuilderMapLoaderMapInfo@@XZ ; CvWorldBuilderMapLoader::GetCurrentMapInfo
; Function compile flags: /Odtp
;	COMDAT ?GetCurrentMapInfo@CvWorldBuilderMapLoader@@SAABUCvWorldBuilderMapLoaderMapInfo@@XZ
_TEXT	SEGMENT
?GetCurrentMapInfo@CvWorldBuilderMapLoader@@SAABUCvWorldBuilderMapLoaderMapInfo@@XZ PROC ; CvWorldBuilderMapLoader::GetCurrentMapInfo, COMDAT

; 176  : {

	push	ebp
	mov	ebp, esp

; 177  : 	return sg_kMapInfo;

	mov	eax, OFFSET _sg_kMapInfo

; 178  : }

	pop	ebp
	ret	0
?GetCurrentMapInfo@CvWorldBuilderMapLoader@@SAABUCvWorldBuilderMapLoaderMapInfo@@XZ ENDP ; CvWorldBuilderMapLoader::GetCurrentMapInfo
_TEXT	ENDS
PUBLIC	?Preload@CvWorldBuilderMapLoader@@SA_NPB_W_N@Z	; CvWorldBuilderMapLoader::Preload
EXTRN	?SwapPlayers@CvWorldBuilderMap@@QAEXEE@Z:PROC	; CvWorldBuilderMap::SwapPlayers
EXTRN	?sm_kErrorPlotMapData@CvWorldBuilderMap@@0VPlotMapData@1@A:QWORD ; CvWorldBuilderMap::sm_kErrorPlotMapData
EXTRN	?IsGoody@CvImprovementEntry@@QBE_NXZ:PROC	; CvImprovementEntry::IsGoody
EXTRN	?sm_kErrorPlotScenarioData@CvWorldBuilderMap@@0UPlotScenarioData@1@A:QWORD ; CvWorldBuilderMap::sm_kErrorPlotScenarioData
EXTRN	?ClearScenarioData@CvWorldBuilderMap@@QAEX_N@Z:PROC ; CvWorldBuilderMap::ClearScenarioData
EXTRN	?Load@CvWorldBuilderMap@@QAE_NPB_WABVCvWorldBuilderMapTypeDesc@@_N@Z:PROC ; CvWorldBuilderMap::Load
_BSS	SEGMENT
_sg_auiPlayerSlots DD 03fH DUP (?)
; Function compile flags: /Odtp
_BSS	ENDS
;	COMDAT ?Preload@CvWorldBuilderMapLoader@@SA_NPB_W_N@Z
_TEXT	SEGMENT
tv73 = -68						; size = 4
$T227765 = -63						; size = 1
$T227744 = -62						; size = 1
$T227740 = -61						; size = 1
$T227736 = -60						; size = 4
$T227732 = -56						; size = 4
$T227711 = -52						; size = 4
$T227710 = -48						; size = 4
_j$223797 = -44						; size = 4
_uiNew$223794 = -40					; size = 4
_i$223790 = -36						; size = 4
_kPlotData$223784 = -32					; size = 4
_i$223780 = -28						; size = 4
_pkImprovement$223777 = -24				; size = 4
_eType$223775 = -20					; size = 4
_kPlot$223773 = -16					; size = 4
_i$223769 = -12						; size = 4
_uiPlotCount$223767 = -8				; size = 4
_uiPlayerCount$223788 = -4				; size = 4
_wszFilename$ = 8					; size = 4
_bScenario$ = 12					; size = 1
?Preload@CvWorldBuilderMapLoader@@SA_NPB_W_N@Z PROC	; CvWorldBuilderMapLoader::Preload, COMDAT

; 185  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H

; 186  : 	InitTypeDesc();

	call	?InitTypeDesc@@YAXXZ			; InitTypeDesc

; 187  : 
; 188  : 	// Re-initialize map info
; 189  : 	new(&sg_kMapInfo)CvWorldBuilderMapLoaderMapInfo();

	mov	DWORD PTR $T227711[ebp], OFFSET _sg_kMapInfo
	cmp	DWORD PTR $T227711[ebp], 0
	je	SHORT $LN28@Preload
	mov	eax, DWORD PTR $T227711[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T227711[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T227711[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T227711[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T227711[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR $T227711[ebp]
	mov	DWORD PTR [edx+20], 0
	mov	eax, DWORD PTR $T227711[ebp]
	mov	BYTE PTR [eax+24], 0
	mov	ecx, DWORD PTR $T227711[ebp]
	mov	BYTE PTR [ecx+25], 0
	mov	edx, DWORD PTR $T227711[ebp]
	mov	DWORD PTR tv73[ebp], edx
	jmp	SHORT $LN29@Preload
$LN28@Preload:
	mov	DWORD PTR tv73[ebp], 0
$LN29@Preload:
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T227710[ebp], eax

; 190  : 
; 191  : 	if(sg_kSave.Load(wszFilename, sg_kMapTypeDesc))

	push	1
	push	OFFSET _sg_kMapTypeDesc
	mov	ecx, DWORD PTR _wszFilename$[ebp]
	push	ecx
	mov	ecx, OFFSET _sg_kSave
	call	?Load@CvWorldBuilderMap@@QAE_NPB_WABVCvWorldBuilderMapTypeDesc@@_N@Z ; CvWorldBuilderMap::Load
	movzx	edx, al
	test	edx, edx
	je	$LN25@Preload

; 192  : 	{
; 193  : 		const uint uiPlotCount = sg_kSave.GetPlotCount();

	mov	eax, DWORD PTR _sg_kSave+12228
	imul	eax, DWORD PTR _sg_kSave+12232
	mov	DWORD PTR _uiPlotCount$223767[ebp], eax

; 194  : 
; 195  : 		if(!bScenario)

	movzx	ecx, BYTE PTR _bScenario$[ebp]
	test	ecx, ecx
	jne	$LN24@Preload

; 196  : 		{
; 197  : 			// Clear out all of the scenario data (except improvements)
; 198  : 			sg_kSave.ClearScenarioData(true);

	push	1
	mov	ecx, OFFSET _sg_kSave
	call	?ClearScenarioData@CvWorldBuilderMap@@QAEX_N@Z ; CvWorldBuilderMap::ClearScenarioData

; 199  : 
; 200  : 			// Remove all improvements that aren't goodies
; 201  : 			for(uint i = 0; i < uiPlotCount; ++i)

	mov	DWORD PTR _i$223769[ebp], 0
	jmp	SHORT $LN23@Preload
$LN22@Preload:
	mov	edx, DWORD PTR _i$223769[ebp]
	add	edx, 1
	mov	DWORD PTR _i$223769[ebp], edx
$LN23@Preload:
	mov	eax, DWORD PTR _i$223769[ebp]
	cmp	eax, DWORD PTR _uiPlotCount$223767[ebp]
	jae	SHORT $LN24@Preload

; 202  : 			{
; 203  : 				CvWorldBuilderMap::PlotScenarioData& kPlot = sg_kSave.GetPlotScenarioData(i);

	mov	ecx, DWORD PTR _sg_kSave+12228
	imul	ecx, DWORD PTR _sg_kSave+12232
	cmp	DWORD PTR _i$223769[ebp], ecx
	jae	SHORT $LN38@Preload
	cmp	DWORD PTR _i$223769[ebp], 32768		; 00008000H
	jae	SHORT $LN38@Preload
	mov	edx, DWORD PTR _i$223769[ebp]
	lea	eax, DWORD PTR _sg_kSave[edx*8+274464]
	mov	DWORD PTR _kPlot$223773[ebp], eax
	jmp	SHORT $LN39@Preload
	jmp	SHORT $LN39@Preload
$LN38@Preload:
	mov	DWORD PTR _kPlot$223773[ebp], OFFSET ?sm_kErrorPlotScenarioData@CvWorldBuilderMap@@0UPlotScenarioData@1@A ; CvWorldBuilderMap::sm_kErrorPlotScenarioData
$LN39@Preload:

; 204  : 				if(kPlot.m_byImprovement != CvWorldBuilderMap::PlotScenarioData::InvalidImprovement)

	mov	ecx, DWORD PTR _kPlot$223773[ebp]
	movzx	edx, BYTE PTR [ecx+5]
	cmp	edx, 255				; 000000ffH
	je	SHORT $LN20@Preload

; 205  : 				{
; 206  : 					ImprovementTypes eType = (ImprovementTypes)kPlot.m_byImprovement;

	mov	eax, DWORD PTR _kPlot$223773[ebp]
	movzx	ecx, BYTE PTR [eax+5]
	mov	DWORD PTR _eType$223775[ebp], ecx

; 207  : 					const CvImprovementEntry* pkImprovement = GC.getImprovementInfo(eType);

	mov	edx, DWORD PTR _eType$223775[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	DWORD PTR _pkImprovement$223777[ebp], eax

; 208  : 					if(pkImprovement == NULL || !pkImprovement->IsGoody())

	cmp	DWORD PTR _pkImprovement$223777[ebp], 0
	je	SHORT $LN18@Preload
	mov	ecx, DWORD PTR _pkImprovement$223777[ebp]
	call	?IsGoody@CvImprovementEntry@@QBE_NXZ	; CvImprovementEntry::IsGoody
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN20@Preload
$LN18@Preload:

; 209  : 						kPlot.m_byImprovement = CvWorldBuilderMap::PlotScenarioData::InvalidImprovement;

	mov	ecx, DWORD PTR _kPlot$223773[ebp]
	mov	BYTE PTR [ecx+5], 255			; 000000ffH
$LN20@Preload:

; 210  : 				}
; 211  : 			}

	jmp	$LN22@Preload
$LN24@Preload:

; 212  : 		}
; 213  : 
; 214  : 		sg_kMapInfo.uiWidth = sg_kSave.GetWidth();

	mov	edx, DWORD PTR _sg_kSave+12228
	mov	DWORD PTR $T227732[ebp], edx
	mov	eax, DWORD PTR $T227732[ebp]
	mov	DWORD PTR _sg_kMapInfo, eax

; 215  : 		sg_kMapInfo.uiHeight = sg_kSave.GetHeight();

	mov	ecx, DWORD PTR _sg_kSave+12232
	mov	DWORD PTR $T227736[ebp], ecx
	mov	edx, DWORD PTR $T227736[ebp]
	mov	DWORD PTR _sg_kMapInfo+4, edx

; 216  : 
; 217  : 		sg_kMapInfo.uiPlayers = sg_kSave.GetPlayerCount();

	mov	al, BYTE PTR _sg_kSave+12316
	mov	BYTE PTR $T227740[ebp], al
	movzx	ecx, BYTE PTR $T227740[ebp]
	mov	DWORD PTR _sg_kMapInfo+8, ecx

; 218  : 		sg_kMapInfo.uiCityStates = sg_kSave.GetCityStateCount();

	mov	dl, BYTE PTR _sg_kSave+12317
	mov	BYTE PTR $T227744[ebp], dl
	movzx	eax, BYTE PTR $T227744[ebp]
	mov	DWORD PTR _sg_kMapInfo+12, eax

; 219  : 
; 220  : 		sg_kMapInfo.uiMajorCivStartingPositions = 0;

	mov	DWORD PTR _sg_kMapInfo+16, 0

; 221  : 		sg_kMapInfo.uiMinorCivStartingPositions = 0;

	mov	DWORD PTR _sg_kMapInfo+20, 0

; 222  : 
; 223  : 		sg_kMapInfo.bWorldWrap = sg_kSave.GetFlag(CvWorldBuilderMap::FLAG_WORLD_WRAP);

	mov	ecx, DWORD PTR _sg_kSave+12224
	and	ecx, 1
	neg	ecx
	sbb	ecx, ecx
	neg	ecx
	mov	BYTE PTR _sg_kMapInfo+24, cl

; 224  : 		sg_kMapInfo.bRandomResources = sg_kSave.GetFlag(CvWorldBuilderMap::FLAG_RANDOM_RECOURCES);

	mov	edx, DWORD PTR _sg_kSave+12224
	and	edx, 2
	neg	edx
	sbb	edx, edx
	neg	edx
	mov	BYTE PTR _sg_kMapInfo+25, dl

; 225  : 
; 226  : 		for(uint i = 0; i < uiPlotCount; ++i)

	mov	DWORD PTR _i$223780[ebp], 0
	jmp	SHORT $LN17@Preload
$LN16@Preload:
	mov	eax, DWORD PTR _i$223780[ebp]
	add	eax, 1
	mov	DWORD PTR _i$223780[ebp], eax
$LN17@Preload:
	mov	ecx, DWORD PTR _i$223780[ebp]
	cmp	ecx, DWORD PTR _uiPlotCount$223767[ebp]
	jae	$LN15@Preload

; 227  : 		{
; 228  : 			const CvWorldBuilderMap::PlotMapData& kPlotData = sg_kSave.GetPlotData(i);

	mov	edx, DWORD PTR _sg_kSave+12228
	imul	edx, DWORD PTR _sg_kSave+12232
	cmp	DWORD PTR _i$223780[ebp], edx
	jae	SHORT $LN54@Preload
	cmp	DWORD PTR _i$223780[ebp], 32768		; 00008000H
	jae	SHORT $LN54@Preload
	mov	eax, DWORD PTR _i$223780[ebp]
	lea	ecx, DWORD PTR _sg_kSave[eax*8+12320]
	mov	DWORD PTR _kPlotData$223784[ebp], ecx
	jmp	SHORT $LN57@Preload
	jmp	SHORT $LN57@Preload
$LN54@Preload:
	mov	DWORD PTR _kPlotData$223784[ebp], OFFSET ?sm_kErrorPlotMapData@CvWorldBuilderMap@@0VPlotMapData@1@A ; CvWorldBuilderMap::sm_kErrorPlotMapData

; 229  : 			if(kPlotData.GetFlag(CvWorldBuilderMap::PlotMapData::START_POS_MAJOR))

$LN57@Preload:
	mov	edx, DWORD PTR _kPlotData$223784[ebp]
	movzx	eax, BYTE PTR [edx+3]
	and	eax, 64					; 00000040H
	neg	eax
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN59@Preload

; 230  : 				sg_kMapInfo.uiMajorCivStartingPositions++;

	mov	edx, DWORD PTR _sg_kMapInfo+16
	add	edx, 1
	mov	DWORD PTR _sg_kMapInfo+16, edx
	jmp	SHORT $LN13@Preload

; 231  : 			else if(kPlotData.GetFlag(CvWorldBuilderMap::PlotMapData::START_POS_MINOR))

$LN59@Preload:
	mov	eax, DWORD PTR _kPlotData$223784[ebp]
	movzx	ecx, BYTE PTR [eax+3]
	and	ecx, 128				; 00000080H
	neg	ecx
	sbb	ecx, ecx
	neg	ecx
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN13@Preload

; 232  : 				sg_kMapInfo.uiMinorCivStartingPositions++;

	mov	eax, DWORD PTR _sg_kMapInfo+20
	add	eax, 1
	mov	DWORD PTR _sg_kMapInfo+20, eax
$LN13@Preload:

; 233  : 		}

	jmp	$LN16@Preload
$LN15@Preload:

; 234  : 
; 235  : 		const uint uiPlayerCount = sg_kSave.GetPlayerCount();

	mov	cl, BYTE PTR _sg_kSave+12316
	mov	BYTE PTR $T227765[ebp], cl
	movzx	edx, BYTE PTR $T227765[ebp]
	mov	DWORD PTR _uiPlayerCount$223788[ebp], edx

; 236  : 		if(uiPlayerCount > 0)

	cmp	DWORD PTR _uiPlayerCount$223788[ebp], 0
	jbe	$LN11@Preload

; 237  : 		{
; 238  : 			for(uint i = 0; i < uiPlayerCount; ++i)

	mov	DWORD PTR _i$223790[ebp], 0
	jmp	SHORT $LN10@Preload
$LN9@Preload:
	mov	eax, DWORD PTR _i$223790[ebp]
	add	eax, 1
	mov	DWORD PTR _i$223790[ebp], eax
$LN10@Preload:
	mov	ecx, DWORD PTR _i$223790[ebp]
	cmp	ecx, DWORD PTR _uiPlayerCount$223788[ebp]
	jae	SHORT $LN11@Preload

; 239  : 			{
; 240  : 				const uint uiNew = sg_auiPlayerSlots[i];

	mov	edx, DWORD PTR _i$223790[ebp]
	mov	eax, DWORD PTR _sg_auiPlayerSlots[edx*4]
	mov	DWORD PTR _uiNew$223794[ebp], eax

; 241  : 				if(uiNew != i)

	mov	ecx, DWORD PTR _uiNew$223794[ebp]
	cmp	ecx, DWORD PTR _i$223790[ebp]
	je	SHORT $LN7@Preload

; 242  : 				{
; 243  : 					if(uiNew < uiPlayerCount)

	mov	edx, DWORD PTR _uiNew$223794[ebp]
	cmp	edx, DWORD PTR _uiPlayerCount$223788[ebp]
	jae	SHORT $LN7@Preload

; 244  : 					{
; 245  : #ifdef AUI_WARNING_FIXES
; 246  : 						sg_kSave.SwapPlayers(byte(uiNew), byte(i));
; 247  : #else
; 248  : 						sg_kSave.SwapPlayers(uiNew, i);

	movzx	eax, BYTE PTR _i$223790[ebp]
	push	eax
	movzx	ecx, BYTE PTR _uiNew$223794[ebp]
	push	ecx
	mov	ecx, OFFSET _sg_kSave
	call	?SwapPlayers@CvWorldBuilderMap@@QAEXEE@Z ; CvWorldBuilderMap::SwapPlayers

; 249  : #endif
; 250  : 
; 251  : 						for(uint j = i + 1; j < uiPlayerCount; ++j)

	mov	edx, DWORD PTR _i$223790[ebp]
	add	edx, 1
	mov	DWORD PTR _j$223797[ebp], edx
	jmp	SHORT $LN5@Preload
$LN4@Preload:
	mov	eax, DWORD PTR _j$223797[ebp]
	add	eax, 1
	mov	DWORD PTR _j$223797[ebp], eax
$LN5@Preload:
	mov	ecx, DWORD PTR _j$223797[ebp]
	cmp	ecx, DWORD PTR _uiPlayerCount$223788[ebp]
	jae	SHORT $LN7@Preload

; 252  : 						{
; 253  : 							if(sg_auiPlayerSlots[j] == i)

	mov	edx, DWORD PTR _j$223797[ebp]
	mov	eax, DWORD PTR _sg_auiPlayerSlots[edx*4]
	cmp	eax, DWORD PTR _i$223790[ebp]
	jne	SHORT $LN2@Preload

; 254  : 							{
; 255  : 								sg_auiPlayerSlots[j] = uiNew;

	mov	ecx, DWORD PTR _j$223797[ebp]
	mov	edx, DWORD PTR _uiNew$223794[ebp]
	mov	DWORD PTR _sg_auiPlayerSlots[ecx*4], edx

; 256  : 								break;

	jmp	SHORT $LN7@Preload
$LN2@Preload:

; 257  : 							}
; 258  : 						}

	jmp	SHORT $LN4@Preload
$LN7@Preload:

; 259  : 					}
; 260  : 				}
; 261  : 			}

	jmp	SHORT $LN9@Preload
$LN11@Preload:

; 262  : 		}
; 263  : 
; 264  : 		//ResetPlayerSlots();
; 265  : 
; 266  : 		return true;

	mov	al, 1
	jmp	SHORT $LN26@Preload

; 267  : 	}
; 268  : 	else

	jmp	SHORT $LN26@Preload
$LN25@Preload:

; 269  : 	{
; 270  : 		return false;

	xor	al, al
$LN26@Preload:

; 271  : 	}
; 272  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Preload@CvWorldBuilderMapLoader@@SA_NPB_W_N@Z ENDP	; CvWorldBuilderMapLoader::Preload
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	?SetupGameOptions@CvWorldBuilderMapLoader@@SAXXZ ; CvWorldBuilderMapLoader::SetupGameOptions
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	?setGameSpeed@CvPreGame@@YAXABVCvString@@@Z:PROC ; CvPreGame::setGameSpeed
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	?setStartYear@CvGame@@QAEXH@Z:PROC		; CvGame::setStartYear
EXTRN	?setMaxTurns@CvPreGame@@YAXH@Z:PROC		; CvPreGame::setMaxTurns
EXTRN	?setVictoryValid@CvGame@@QAEXW4VictoryTypes@@_N@Z:PROC ; CvGame::setVictoryValid
EXTRN	?getVictoryInfo@CvGlobals@@QAEPAVCvVictoryInfo@@W4VictoryTypes@@@Z:PROC ; CvGlobals::getVictoryInfo
EXTRN	?getNumVictoryInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumVictoryInfos
EXTRN	?setOption@CvGame@@QAEXPBD_N@Z:PROC		; CvGame::setOption
EXTRN	?Contains@CvWorldBuilderMapTypeGroup@@QBE_NPBD@Z:PROC ; CvWorldBuilderMapTypeGroup::Contains
EXTRN	?getGameOptionInfo@CvGlobals@@QAEPAVCvGameOptionInfo@@W4GameOptionTypes@@@Z:PROC ; CvGlobals::getGameOptionInfo
EXTRN	?getNumGameOptionInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumGameOptionInfos
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SetupGameOptions@CvWorldBuilderMapLoader@@SAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetupGameOptions@CvWorldBuilderMapLoader@@SAXXZ$0
__ehfuncinfo$?SetupGameOptions@CvWorldBuilderMapLoader@@SAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SetupGameOptions@CvWorldBuilderMapLoader@@SAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvworldbuildermaploader.cpp
xdata$x	ENDS
;	COMDAT ?SetupGameOptions@CvWorldBuilderMapLoader@@SAXXZ
_TEXT	SEGMENT
tv179 = -116						; size = 4
$T227807 = -112						; size = 4
$T227795 = -108						; size = 4
$T227791 = -104						; size = 4
$T227787 = -100						; size = 4
$T227783 = -96						; size = 4
$T227776 = -92						; size = 4
$T227768 = -88						; size = 28
_bValid$223826 = -57					; size = 1
_szVictoryType$223825 = -56				; size = 4
_eVictoryType$223821 = -52				; size = 4
_pkVictoryType$223823 = -48				; size = 4
_i$223817 = -44						; size = 4
_szOption$223814 = -40					; size = 4
_bEnabled$223815 = -33					; size = 1
_pkOption$223812 = -32					; size = 4
_eOption$223810 = -28					; size = 4
_i$223806 = -24						; size = 4
_iGameOptionCount$ = -20				; size = 4
_iVictoryTypeCount$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
?SetupGameOptions@CvWorldBuilderMapLoader@@SAXXZ PROC	; CvWorldBuilderMapLoader::SetupGameOptions, COMDAT

; 275  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetupGameOptions@CvWorldBuilderMapLoader@@SAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 276  : 	const int iGameOptionCount = GC.getNumGameOptionInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumGameOptionInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumGameOptionInfos
	mov	DWORD PTR _iGameOptionCount$[ebp], eax

; 277  : 	for(int i = 0; i < iGameOptionCount; ++i)

	mov	DWORD PTR _i$223806[ebp], 0
	jmp	SHORT $LN8@SetupGameO
$LN7@SetupGameO:
	mov	eax, DWORD PTR _i$223806[ebp]
	add	eax, 1
	mov	DWORD PTR _i$223806[ebp], eax
$LN8@SetupGameO:
	mov	ecx, DWORD PTR _i$223806[ebp]
	cmp	ecx, DWORD PTR _iGameOptionCount$[ebp]
	jge	SHORT $LN6@SetupGameO

; 278  : 	{
; 279  : 		const GameOptionTypes eOption = (GameOptionTypes)i;

	mov	edx, DWORD PTR _i$223806[ebp]
	mov	DWORD PTR _eOption$223810[ebp], edx

; 280  : 		const CvGameOptionInfo* pkOption = GC.getGameOptionInfo(eOption);

	mov	eax, DWORD PTR _eOption$223810[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getGameOptionInfo@CvGlobals@@QAEPAVCvGameOptionInfo@@W4GameOptionTypes@@@Z ; CvGlobals::getGameOptionInfo
	mov	DWORD PTR _pkOption$223812[ebp], eax

; 281  : 		if(pkOption != NULL)

	cmp	DWORD PTR _pkOption$223812[ebp], 0
	je	SHORT $LN5@SetupGameO

; 282  : 		{
; 283  : 			const char* szOption = pkOption->GetType();

	mov	ecx, DWORD PTR _pkOption$223812[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR _szOption$223814[ebp], eax

; 284  : 			const bool bEnabled = sg_kSave.m_kGameOptions.Contains(szOption);

	mov	ecx, DWORD PTR _szOption$223814[ebp]
	push	ecx
	mov	ecx, OFFSET _sg_kSave+4024
	call	?Contains@CvWorldBuilderMapTypeGroup@@QBE_NPBD@Z ; CvWorldBuilderMapTypeGroup::Contains
	mov	BYTE PTR _bEnabled$223815[ebp], al

; 285  : 			GC.getGame().setOption(szOption, bEnabled);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T227776[ebp], edx
	movzx	eax, BYTE PTR _bEnabled$223815[ebp]
	push	eax
	mov	ecx, DWORD PTR _szOption$223814[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T227776[ebp]
	call	?setOption@CvGame@@QAEXPBD_N@Z		; CvGame::setOption
$LN5@SetupGameO:

; 286  : 		}
; 287  : 	}

	jmp	SHORT $LN7@SetupGameO
$LN6@SetupGameO:

; 288  : 
; 289  : 	const int iVictoryTypeCount = GC.getNumVictoryInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumVictoryInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumVictoryInfos
	mov	DWORD PTR _iVictoryTypeCount$[ebp], eax

; 290  : 	for(int i = 0; i < iVictoryTypeCount; ++i)

	mov	DWORD PTR _i$223817[ebp], 0
	jmp	SHORT $LN4@SetupGameO
$LN3@SetupGameO:
	mov	edx, DWORD PTR _i$223817[ebp]
	add	edx, 1
	mov	DWORD PTR _i$223817[ebp], edx
$LN4@SetupGameO:
	mov	eax, DWORD PTR _i$223817[ebp]
	cmp	eax, DWORD PTR _iVictoryTypeCount$[ebp]
	jge	SHORT $LN2@SetupGameO

; 291  : 	{
; 292  : 		const VictoryTypes eVictoryType = (VictoryTypes)i;

	mov	ecx, DWORD PTR _i$223817[ebp]
	mov	DWORD PTR _eVictoryType$223821[ebp], ecx

; 293  : 		const CvVictoryInfo* pkVictoryType = GC.getVictoryInfo(eVictoryType);

	mov	edx, DWORD PTR _eVictoryType$223821[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getVictoryInfo@CvGlobals@@QAEPAVCvVictoryInfo@@W4VictoryTypes@@@Z ; CvGlobals::getVictoryInfo
	mov	DWORD PTR _pkVictoryType$223823[ebp], eax

; 294  : 		if(pkVictoryType != NULL)

	cmp	DWORD PTR _pkVictoryType$223823[ebp], 0
	je	SHORT $LN1@SetupGameO

; 295  : 		{
; 296  : 			const char* szVictoryType = pkVictoryType->GetType();

	mov	ecx, DWORD PTR _pkVictoryType$223823[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR _szVictoryType$223825[ebp], eax

; 297  : 			const bool bValid = sg_kSave.m_kVictoryTypes.Contains(szVictoryType);

	mov	eax, DWORD PTR _szVictoryType$223825[ebp]
	push	eax
	mov	ecx, OFFSET _sg_kSave+4016
	call	?Contains@CvWorldBuilderMapTypeGroup@@QBE_NPBD@Z ; CvWorldBuilderMapTypeGroup::Contains
	mov	BYTE PTR _bValid$223826[ebp], al

; 298  : 			GC.getGame().setVictoryValid(eVictoryType, bValid);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T227783[ebp], ecx
	movzx	edx, BYTE PTR _bValid$223826[ebp]
	push	edx
	mov	eax, DWORD PTR _eVictoryType$223821[ebp]
	push	eax
	mov	ecx, DWORD PTR $T227783[ebp]
	call	?setVictoryValid@CvGame@@QAEXW4VictoryTypes@@_N@Z ; CvGame::setVictoryValid
$LN1@SetupGameO:

; 299  : 		}
; 300  : 	}

	jmp	SHORT $LN3@SetupGameO
$LN2@SetupGameO:

; 301  : 
; 302  : 	CvPreGame::setMaxTurns(sg_kSave.GetMaxTurns());

	mov	ecx, DWORD PTR _sg_kSave+12304
	mov	DWORD PTR $T227787[ebp], ecx
	mov	edx, DWORD PTR $T227787[ebp]
	push	edx
	call	?setMaxTurns@CvPreGame@@YAXH@Z		; CvPreGame::setMaxTurns
	add	esp, 4

; 303  : 
; 304  : 	GC.getGame().setStartYear(sg_kSave.GetStartYear());

	mov	eax, DWORD PTR _sg_kSave+12312
	mov	DWORD PTR $T227791[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T227795[ebp], ecx
	mov	edx, DWORD PTR $T227791[ebp]
	push	edx
	mov	ecx, DWORD PTR $T227795[ebp]
	call	?setStartYear@CvGame@@QAEXH@Z		; CvGame::setStartYear

; 305  : 	CvPreGame::setGameSpeed(sg_kSave.GetDefaultGameSpeed());

	mov	DWORD PTR $T227807[ebp], OFFSET _sg_kSave+12236
	cmp	DWORD PTR $T227807[ebp], 0
	je	SHORT $LN30@SetupGameO
	mov	eax, DWORD PTR $T227807[ebp]
	mov	DWORD PTR tv179[ebp], eax
	jmp	SHORT $LN31@SetupGameO
$LN30@SetupGameO:
	mov	DWORD PTR tv179[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN31@SetupGameO:
	mov	ecx, DWORD PTR tv179[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T227768[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	edx, DWORD PTR $T227768[ebp]
	push	edx
	call	?setGameSpeed@CvPreGame@@YAXABVCvString@@@Z ; CvPreGame::setGameSpeed
	add	esp, 4
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T227768[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 306  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetupGameOptions@CvWorldBuilderMapLoader@@SAXXZ$0:
	lea	ecx, DWORD PTR $T227768[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?SetupGameOptions@CvWorldBuilderMapLoader@@SAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-108]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetupGameOptions@CvWorldBuilderMapLoader@@SAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetupGameOptions@CvWorldBuilderMapLoader@@SAXXZ ENDP	; CvWorldBuilderMapLoader::SetupGameOptions
PUBLIC	?SetupPlayers@CvWorldBuilderMapLoader@@SAXXZ	; CvWorldBuilderMapLoader::SetupPlayers
EXTRN	?setMinorCivType@CvPreGame@@YAXW4PlayerTypes@@W4MinorCivTypes@@@Z:PROC ; CvPreGame::setMinorCivType
EXTRN	?getMinorCivInfo@CvGlobals@@QAEPAVCvMinorCivInfo@@W4MinorCivTypes@@@Z:PROC ; CvGlobals::getMinorCivInfo
EXTRN	?getNumMinorCivInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumMinorCivInfos
EXTRN	?mapNoPlayers@CvPreGame@@YA_NXZ:PROC		; CvPreGame::mapNoPlayers
EXTRN	?setNumMinorCivs@CvPreGame@@YAXH@Z:PROC		; CvPreGame::setNumMinorCivs
EXTRN	?resetPlayer@CvPreGame@@YAXW4PlayerTypes@@@Z:PROC ; CvPreGame::resetPlayer
EXTRN	?setCivilizationDescription@CvPreGame@@YAXW4PlayerTypes@@ABVCvString@@@Z:PROC ; CvPreGame::setCivilizationDescription
EXTRN	?setCivilizationShortDescription@CvPreGame@@YAXW4PlayerTypes@@ABVCvString@@@Z:PROC ; CvPreGame::setCivilizationShortDescription
EXTRN	?setLeaderName@CvPreGame@@YAXW4PlayerTypes@@ABVCvString@@@Z:PROC ; CvPreGame::setLeaderName
EXTRN	?setMinorCiv@CvPreGame@@YAXW4PlayerTypes@@_N@Z:PROC ; CvPreGame::setMinorCiv
EXTRN	?setTeamType@CvPreGame@@YAXW4PlayerTypes@@W4TeamTypes@@@Z:PROC ; CvPreGame::setTeamType
EXTRN	?setHandicap@CvPreGame@@YAXW4PlayerTypes@@W4HandicapTypes@@@Z:PROC ; CvPreGame::setHandicap
EXTRN	?getHandicapInfo@CvGlobals@@QAEPAVCvHandicapInfo@@W4HandicapTypes@@@Z:PROC ; CvGlobals::getHandicapInfo
EXTRN	?getNumHandicapInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumHandicapInfos
EXTRN	?overrideScenarioHandicap@CvPreGame@@YA_NXZ:PROC ; CvPreGame::overrideScenarioHandicap
EXTRN	?setPlayerColor@CvPreGame@@YAXW4PlayerTypes@@W4PlayerColorTypes@@@Z:PROC ; CvPreGame::setPlayerColor
EXTRN	?GetPlayerColorInfo@CvGlobals@@QAEPAVCvPlayerColorInfo@@W4PlayerColorTypes@@@Z:PROC ; CvGlobals::GetPlayerColorInfo
EXTRN	?GetNumPlayerColorInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::GetNumPlayerColorInfos
EXTRN	?setCivilization@CvPreGame@@YAXW4PlayerTypes@@W4CivilizationTypes@@@Z:PROC ; CvPreGame::setCivilization
EXTRN	?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z:PROC ; CvGlobals::getCivilizationInfo
EXTRN	?getNumCivilizationInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumCivilizationInfos
EXTRN	?sm_kErrorPlayer@CvWorldBuilderMap@@0UPlayer@1@A:BYTE ; CvWorldBuilderMap::sm_kErrorPlayer
EXTRN	?setSlotStatus@CvPreGame@@YAXW4PlayerTypes@@W4SlotStatus@@@Z:PROC ; CvPreGame::setSlotStatus
EXTRN	?slotStatus@CvPreGame@@YA?AW4SlotStatus@@W4PlayerTypes@@@Z:PROC ; CvPreGame::slotStatus
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
xdata$x	SEGMENT
__unwindtable$?SetupPlayers@CvWorldBuilderMapLoader@@SAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetupPlayers@CvWorldBuilderMapLoader@@SAXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SetupPlayers@CvWorldBuilderMapLoader@@SAXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SetupPlayers@CvWorldBuilderMapLoader@@SAXXZ$2
__ehfuncinfo$?SetupPlayers@CvWorldBuilderMapLoader@@SAXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?SetupPlayers@CvWorldBuilderMapLoader@@SAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvworldbuildermaploader.cpp
xdata$x	ENDS
;	COMDAT ?SetupPlayers@CvWorldBuilderMapLoader@@SAXXZ
_TEXT	SEGMENT
tv342 = -424						; size = 4
tv718 = -420						; size = 4
tv713 = -414						; size = 1
tv706 = -413						; size = 1
tv702 = -412						; size = 4
tv703 = -408						; size = 4
tv320 = -404						; size = 4
tv687 = -400						; size = 4
tv682 = -394						; size = 1
tv675 = -393						; size = 1
tv671 = -392						; size = 4
tv672 = -388						; size = 4
tv298 = -384						; size = 4
tv656 = -380						; size = 4
tv651 = -374						; size = 1
tv644 = -373						; size = 1
tv640 = -372						; size = 4
tv641 = -368						; size = 4
tv444 = -364						; size = 4
tv429 = -360						; size = 4
tv411 = -356						; size = 4
tv204 = -352						; size = 4
tv600 = -345						; size = 1
tv597 = -344						; size = 4
tv594 = -340						; size = 4
tv393 = -336						; size = 4
tv192 = -332						; size = 4
tv583 = -325						; size = 1
tv580 = -324						; size = 4
tv577 = -320						; size = 4
tv179 = -316						; size = 4
tv564 = -312						; size = 4
tv559 = -306						; size = 1
tv552 = -305						; size = 1
tv548 = -304						; size = 4
tv549 = -300						; size = 4
tv153 = -296						; size = 4
tv532 = -292						; size = 4
tv527 = -286						; size = 1
tv520 = -285						; size = 1
tv516 = -284						; size = 4
tv517 = -280						; size = 4
tv131 = -276						; size = 4
tv501 = -272						; size = 4
tv496 = -266						; size = 1
tv489 = -265						; size = 1
tv485 = -264						; size = 4
tv486 = -260						; size = 4
tv361 = -256						; size = 4
$T227911 = -252						; size = 4
$T227904 = -245						; size = 1
$T227896 = -244						; size = 4
$T227883 = -240						; size = 4
$T227870 = -236						; size = 4
$T227845 = -232						; size = 4
$T227838 = -227						; size = 1
$T227831 = -226						; size = 1
$T227830 = -225						; size = 1
$T227829 = -224						; size = 28
$T227828 = -196						; size = 28
$T227827 = -168						; size = 28
$T227826 = -138						; size = 1
$T227825 = -137						; size = 1
_pkHandicap$223932 = -136				; size = 4
_iHandicap$223928 = -132				; size = 4
_pkColor$223923 = -128					; size = 4
_iColor$223919 = -124					; size = 4
_pkCivilization$223914 = -120				; size = 4
_iCiv$223910 = -116					; size = 4
_ePlayer$223906 = -112					; size = 4
_eColorType$223918 = -108				; size = 4
_eCivType$223909 = -104					; size = 4
_eHandicap$223927 = -100				; size = 4
_kPlayer$223908 = -96					; size = 4
_i$223902 = -92						; size = 4
_ePlayer$223889 = -88					; size = 4
_eStatus$223891 = -84					; size = 4
_i$223885 = -80						; size = 4
_pkHandicap$223873 = -76				; size = 4
_iHandicap$223869 = -72					; size = 4
_eHandicap$223868 = -68					; size = 4
_pkColor$223862 = -64					; size = 4
_iColor$223858 = -60					; size = 4
_pkCivilization$223853 = -56				; size = 4
_iCiv$223849 = -52					; size = 4
_ePlayer$223843 = -48					; size = 4
_eColorType$223857 = -44				; size = 4
_eStatus$223845 = -40					; size = 4
_eCivType$223848 = -36					; size = 4
_kPlayer$223847 = -32					; size = 4
_i$223839 = -28						; size = 4
_uiCityStateCount$ = -24				; size = 4
_uiPlayerCount$ = -20					; size = 4
_uiPlayerSlotCount$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
?SetupPlayers@CvWorldBuilderMapLoader@@SAXXZ PROC	; CvWorldBuilderMapLoader::SetupPlayers, COMDAT

; 309  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetupPlayers@CvWorldBuilderMapLoader@@SAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 412				; 0000019cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 310  : #ifdef AUI_WARNING_FIXES
; 311  : 	const byte uiPlayerCount = MIN(sg_kSave.GetPlayerCount(), (byte)MAX_CIV_PLAYERS);
; 312  : 	for (byte i = 0; i < uiPlayerCount; ++i)
; 313  : #else
; 314  : 	const uint uiPlayerCount = std::min(sg_kSave.GetPlayerCount(), (byte)MAX_CIV_PLAYERS);

	mov	BYTE PTR $T227825[ebp], 63		; 0000003fH
	mov	al, BYTE PTR _sg_kSave+12316
	mov	BYTE PTR $T227838[ebp], al
	mov	cl, BYTE PTR $T227838[ebp]
	mov	BYTE PTR $T227826[ebp], cl
	movzx	edx, BYTE PTR $T227825[ebp]
	movzx	eax, BYTE PTR $T227826[ebp]
	cmp	edx, eax
	jge	SHORT $LN55@SetupPlaye
	lea	ecx, DWORD PTR $T227825[ebp]
	mov	DWORD PTR tv361[ebp], ecx
	jmp	SHORT $LN56@SetupPlaye
$LN55@SetupPlaye:
	lea	edx, DWORD PTR $T227826[ebp]
	mov	DWORD PTR tv361[ebp], edx
$LN56@SetupPlaye:
	mov	eax, DWORD PTR tv361[ebp]
	mov	DWORD PTR $T227845[ebp], eax
	mov	ecx, DWORD PTR $T227845[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _uiPlayerCount$[ebp], edx

; 315  : 	for(uint i = 0; i < uiPlayerCount; ++i)

	mov	DWORD PTR _i$223839[ebp], 0
	jmp	SHORT $LN45@SetupPlaye
$LN44@SetupPlaye:
	mov	eax, DWORD PTR _i$223839[ebp]
	add	eax, 1
	mov	DWORD PTR _i$223839[ebp], eax
$LN45@SetupPlaye:
	mov	ecx, DWORD PTR _i$223839[ebp]
	cmp	ecx, DWORD PTR _uiPlayerCount$[ebp]
	jae	$LN43@SetupPlaye

; 316  : #endif
; 317  : 	{
; 318  : 		const PlayerTypes ePlayer = (PlayerTypes)i;

	mov	edx, DWORD PTR _i$223839[ebp]
	mov	DWORD PTR _ePlayer$223843[ebp], edx

; 319  : 		const SlotStatus eStatus = CvPreGame::slotStatus(ePlayer);

	mov	eax, DWORD PTR _ePlayer$223843[ebp]
	push	eax
	call	?slotStatus@CvPreGame@@YA?AW4SlotStatus@@W4PlayerTypes@@@Z ; CvPreGame::slotStatus
	add	esp, 4
	mov	DWORD PTR _eStatus$223845[ebp], eax

; 320  : 		if(eStatus != SS_TAKEN && eStatus != SS_COMPUTER)

	cmp	DWORD PTR _eStatus$223845[ebp], 3
	je	SHORT $LN42@SetupPlaye
	cmp	DWORD PTR _eStatus$223845[ebp], 1
	je	SHORT $LN42@SetupPlaye

; 321  : 			CvPreGame::setSlotStatus(ePlayer, SS_COMPUTER);

	push	1
	mov	ecx, DWORD PTR _ePlayer$223843[ebp]
	push	ecx
	call	?setSlotStatus@CvPreGame@@YAXW4PlayerTypes@@W4SlotStatus@@@Z ; CvPreGame::setSlotStatus
	add	esp, 8
$LN42@SetupPlaye:

; 322  : 
; 323  : 		const CvWorldBuilderMap::Player& kPlayer = sg_kSave.GetPlayer(i);

	movzx	edx, BYTE PTR _i$223839[ebp]
	movzx	eax, BYTE PTR _sg_kSave+12316
	cmp	edx, eax
	jge	SHORT $LN58@SetupPlaye
	movzx	ecx, BYTE PTR _i$223839[ebp]
	cmp	ecx, 32					; 00000020H
	jae	SHORT $LN58@SetupPlaye
	movzx	edx, BYTE PTR _i$223839[ebp]
	imul	edx, 436				; 000001b4H
	add	edx, OFFSET _sg_kSave+536608
	mov	DWORD PTR _kPlayer$223847[ebp], edx
	jmp	SHORT $LN59@SetupPlaye
	jmp	SHORT $LN59@SetupPlaye
$LN58@SetupPlaye:
	mov	DWORD PTR _kPlayer$223847[ebp], OFFSET ?sm_kErrorPlayer@CvWorldBuilderMap@@0UPlayer@1@A ; CvWorldBuilderMap::sm_kErrorPlayer
$LN59@SetupPlaye:

; 324  : 
; 325  : 		CivilizationTypes eCivType = NO_CIVILIZATION;

	mov	DWORD PTR _eCivType$223848[ebp], -1

; 326  : #ifdef AUI_WARNING_FIXES
; 327  : 		for (uint iCiv = 0; iCiv < GC.getNumCivilizationInfos(); ++iCiv)
; 328  : #else
; 329  : 		for(int iCiv = 0; iCiv < GC.getNumCivilizationInfos(); ++iCiv)

	mov	DWORD PTR _iCiv$223849[ebp], 0
	jmp	SHORT $LN41@SetupPlaye
$LN40@SetupPlaye:
	mov	eax, DWORD PTR _iCiv$223849[ebp]
	add	eax, 1
	mov	DWORD PTR _iCiv$223849[ebp], eax
$LN41@SetupPlaye:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumCivilizationInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumCivilizationInfos
	cmp	DWORD PTR _iCiv$223849[ebp], eax
	jge	$LN39@SetupPlaye

; 330  : #endif
; 331  : 		{
; 332  : 			CvCivilizationInfo* pkCivilization = GC.getCivilizationInfo((CivilizationTypes)iCiv);

	mov	ecx, DWORD PTR _iCiv$223849[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z ; CvGlobals::getCivilizationInfo
	mov	DWORD PTR _pkCivilization$223853[ebp], eax

; 333  : 			if(pkCivilization != NULL && strcmp(kPlayer.m_szCivType, pkCivilization->GetType()) == 0)

	cmp	DWORD PTR _pkCivilization$223853[ebp], 0
	je	$LN38@SetupPlaye
	mov	ecx, DWORD PTR _pkCivilization$223853[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR tv486[ebp], eax
	mov	edx, DWORD PTR _kPlayer$223847[ebp]
	add	edx, 160				; 000000a0H
	mov	DWORD PTR tv485[ebp], edx
$LL107@SetupPlaye:
	mov	eax, DWORD PTR tv485[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv489[ebp], cl
	mov	edx, DWORD PTR tv486[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN108@SetupPlaye
	cmp	BYTE PTR tv489[ebp], 0
	je	SHORT $LN109@SetupPlaye
	mov	eax, DWORD PTR tv485[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv496[ebp], cl
	mov	edx, DWORD PTR tv486[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN108@SetupPlaye
	add	DWORD PTR tv485[ebp], 2
	add	DWORD PTR tv486[ebp], 2
	cmp	BYTE PTR tv496[ebp], 0
	jne	SHORT $LL107@SetupPlaye
$LN109@SetupPlaye:
	mov	DWORD PTR tv501[ebp], 0
	jmp	SHORT $LN110@SetupPlaye
$LN108@SetupPlaye:
	sbb	eax, eax
	sbb	eax, -1
	mov	DWORD PTR tv501[ebp], eax
$LN110@SetupPlaye:
	mov	ecx, DWORD PTR tv501[ebp]
	mov	DWORD PTR tv131[ebp], ecx
	cmp	DWORD PTR tv131[ebp], 0
	jne	SHORT $LN38@SetupPlaye

; 334  : 			{
; 335  : 				eCivType = (CivilizationTypes)iCiv;

	mov	edx, DWORD PTR _iCiv$223849[ebp]
	mov	DWORD PTR _eCivType$223848[ebp], edx

; 336  : 				break;

	jmp	SHORT $LN39@SetupPlaye
$LN38@SetupPlaye:

; 337  : 			}
; 338  : 		}

	jmp	$LN40@SetupPlaye
$LN39@SetupPlaye:

; 339  : 
; 340  : 		CvPreGame::setCivilization(ePlayer, eCivType);

	mov	eax, DWORD PTR _eCivType$223848[ebp]
	push	eax
	mov	ecx, DWORD PTR _ePlayer$223843[ebp]
	push	ecx
	call	?setCivilization@CvPreGame@@YAXW4PlayerTypes@@W4CivilizationTypes@@@Z ; CvPreGame::setCivilization
	add	esp, 8

; 341  : 
; 342  : 		PlayerColorTypes eColorType = NO_PLAYERCOLOR;

	mov	DWORD PTR _eColorType$223857[ebp], -1

; 343  : #ifdef AUI_WARNING_FIXES
; 344  : 		for (uint iColor = 0; iColor < GC.GetNumPlayerColorInfos(); ++iColor)
; 345  : #else
; 346  : 		for(int iColor = 0; iColor < GC.GetNumPlayerColorInfos(); ++iColor)

	mov	DWORD PTR _iColor$223858[ebp], 0
	jmp	SHORT $LN37@SetupPlaye
$LN36@SetupPlaye:
	mov	edx, DWORD PTR _iColor$223858[ebp]
	add	edx, 1
	mov	DWORD PTR _iColor$223858[ebp], edx
$LN37@SetupPlaye:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetNumPlayerColorInfos@CvGlobals@@QAEHXZ ; CvGlobals::GetNumPlayerColorInfos
	cmp	DWORD PTR _iColor$223858[ebp], eax
	jge	$LN35@SetupPlaye

; 347  : #endif
; 348  : 		{
; 349  : 			CvPlayerColorInfo* pkColor = GC.GetPlayerColorInfo((PlayerColorTypes)iColor);

	mov	eax, DWORD PTR _iColor$223858[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetPlayerColorInfo@CvGlobals@@QAEPAVCvPlayerColorInfo@@W4PlayerColorTypes@@@Z ; CvGlobals::GetPlayerColorInfo
	mov	DWORD PTR _pkColor$223862[ebp], eax

; 350  : 			if(pkColor != NULL && strcmp(kPlayer.m_szTeamColor, pkColor->GetType()) == 0)

	cmp	DWORD PTR _pkColor$223862[ebp], 0
	je	$LN34@SetupPlaye
	mov	ecx, DWORD PTR _pkColor$223862[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR tv517[ebp], eax
	mov	ecx, DWORD PTR _kPlayer$223847[ebp]
	add	ecx, 224				; 000000e0H
	mov	DWORD PTR tv516[ebp], ecx
$LL111@SetupPlaye:
	mov	edx, DWORD PTR tv516[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv520[ebp], al
	mov	ecx, DWORD PTR tv517[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN112@SetupPlaye
	cmp	BYTE PTR tv520[ebp], 0
	je	SHORT $LN113@SetupPlaye
	mov	edx, DWORD PTR tv516[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv527[ebp], al
	mov	ecx, DWORD PTR tv517[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN112@SetupPlaye
	add	DWORD PTR tv516[ebp], 2
	add	DWORD PTR tv517[ebp], 2
	cmp	BYTE PTR tv527[ebp], 0
	jne	SHORT $LL111@SetupPlaye
$LN113@SetupPlaye:
	mov	DWORD PTR tv532[ebp], 0
	jmp	SHORT $LN114@SetupPlaye
$LN112@SetupPlaye:
	sbb	edx, edx
	sbb	edx, -1
	mov	DWORD PTR tv532[ebp], edx
$LN114@SetupPlaye:
	mov	eax, DWORD PTR tv532[ebp]
	mov	DWORD PTR tv153[ebp], eax
	cmp	DWORD PTR tv153[ebp], 0
	jne	SHORT $LN34@SetupPlaye

; 351  : 			{
; 352  : 				eColorType = (PlayerColorTypes)iColor;

	mov	ecx, DWORD PTR _iColor$223858[ebp]
	mov	DWORD PTR _eColorType$223857[ebp], ecx

; 353  : 				break;

	jmp	SHORT $LN35@SetupPlaye
$LN34@SetupPlaye:

; 354  : 			}
; 355  : 		}

	jmp	$LN36@SetupPlaye
$LN35@SetupPlaye:

; 356  : 
; 357  : 		CvPreGame::setPlayerColor(ePlayer, eColorType);

	mov	edx, DWORD PTR _eColorType$223857[ebp]
	push	edx
	mov	eax, DWORD PTR _ePlayer$223843[ebp]
	push	eax
	call	?setPlayerColor@CvPreGame@@YAXW4PlayerTypes@@W4PlayerColorTypes@@@Z ; CvPreGame::setPlayerColor
	add	esp, 8

; 358  : 
; 359  : 		if(!(eStatus == SS_TAKEN && CvPreGame::overrideScenarioHandicap()))

	cmp	DWORD PTR _eStatus$223845[ebp], 3
	jne	SHORT $LN32@SetupPlaye
	call	?overrideScenarioHandicap@CvPreGame@@YA_NXZ ; CvPreGame::overrideScenarioHandicap
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN33@SetupPlaye
$LN32@SetupPlaye:

; 360  : 		{
; 361  : 			HandicapTypes eHandicap = NO_HANDICAP;

	mov	DWORD PTR _eHandicap$223868[ebp], -1

; 362  : #ifdef AUI_WARNING_FIXES
; 363  : 			for (uint iHandicap = 0; iHandicap < GC.getNumHandicapInfos(); ++iHandicap)
; 364  : #else
; 365  : 			for(int iHandicap = 0; iHandicap < GC.getNumHandicapInfos(); ++iHandicap)

	mov	DWORD PTR _iHandicap$223869[ebp], 0
	jmp	SHORT $LN31@SetupPlaye
$LN30@SetupPlaye:
	mov	edx, DWORD PTR _iHandicap$223869[ebp]
	add	edx, 1
	mov	DWORD PTR _iHandicap$223869[ebp], edx
$LN31@SetupPlaye:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumHandicapInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumHandicapInfos
	cmp	DWORD PTR _iHandicap$223869[ebp], eax
	jge	$LN29@SetupPlaye

; 366  : #endif
; 367  : 			{
; 368  : 				CvHandicapInfo* pkHandicap = GC.getHandicapInfo((HandicapTypes)iHandicap);

	mov	eax, DWORD PTR _iHandicap$223869[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getHandicapInfo@CvGlobals@@QAEPAVCvHandicapInfo@@W4HandicapTypes@@@Z ; CvGlobals::getHandicapInfo
	mov	DWORD PTR _pkHandicap$223873[ebp], eax

; 369  : 				if(pkHandicap != NULL && strcmp(kPlayer.m_szHandicap, pkHandicap->GetType()) == 0)

	cmp	DWORD PTR _pkHandicap$223873[ebp], 0
	je	$LN28@SetupPlaye
	mov	ecx, DWORD PTR _pkHandicap$223873[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR tv549[ebp], eax
	mov	ecx, DWORD PTR _kPlayer$223847[ebp]
	add	ecx, 352				; 00000160H
	mov	DWORD PTR tv548[ebp], ecx
$LL115@SetupPlaye:
	mov	edx, DWORD PTR tv548[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv552[ebp], al
	mov	ecx, DWORD PTR tv549[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN116@SetupPlaye
	cmp	BYTE PTR tv552[ebp], 0
	je	SHORT $LN117@SetupPlaye
	mov	edx, DWORD PTR tv548[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv559[ebp], al
	mov	ecx, DWORD PTR tv549[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN116@SetupPlaye
	add	DWORD PTR tv548[ebp], 2
	add	DWORD PTR tv549[ebp], 2
	cmp	BYTE PTR tv559[ebp], 0
	jne	SHORT $LL115@SetupPlaye
$LN117@SetupPlaye:
	mov	DWORD PTR tv564[ebp], 0
	jmp	SHORT $LN118@SetupPlaye
$LN116@SetupPlaye:
	sbb	edx, edx
	sbb	edx, -1
	mov	DWORD PTR tv564[ebp], edx
$LN118@SetupPlaye:
	mov	eax, DWORD PTR tv564[ebp]
	mov	DWORD PTR tv179[ebp], eax
	cmp	DWORD PTR tv179[ebp], 0
	jne	SHORT $LN28@SetupPlaye

; 370  : 				{
; 371  : 					eHandicap = (HandicapTypes)iHandicap;

	mov	ecx, DWORD PTR _iHandicap$223869[ebp]
	mov	DWORD PTR _eHandicap$223868[ebp], ecx

; 372  : 					break;

	jmp	SHORT $LN29@SetupPlaye
$LN28@SetupPlaye:

; 373  : 				}
; 374  : 			}

	jmp	$LN30@SetupPlaye
$LN29@SetupPlaye:

; 375  : 
; 376  : 			CvPreGame::setHandicap(ePlayer, eHandicap);

	mov	edx, DWORD PTR _eHandicap$223868[ebp]
	push	edx
	mov	eax, DWORD PTR _ePlayer$223843[ebp]
	push	eax
	call	?setHandicap@CvPreGame@@YAXW4PlayerTypes@@W4HandicapTypes@@@Z ; CvPreGame::setHandicap
	add	esp, 8
$LN33@SetupPlaye:

; 377  : 		}
; 378  : 
; 379  : 		CvPreGame::setTeamType(ePlayer, (TeamTypes)kPlayer.m_byTeam);

	mov	ecx, DWORD PTR _kPlayer$223847[ebp]
	movzx	edx, BYTE PTR [ecx+432]
	push	edx
	mov	eax, DWORD PTR _ePlayer$223843[ebp]
	push	eax
	call	?setTeamType@CvPreGame@@YAXW4PlayerTypes@@W4TeamTypes@@@Z ; CvPreGame::setTeamType
	add	esp, 8

; 380  : 		CvPreGame::setMinorCiv(ePlayer, false);

	push	0
	mov	ecx, DWORD PTR _ePlayer$223843[ebp]
	push	ecx
	call	?setMinorCiv@CvPreGame@@YAXW4PlayerTypes@@_N@Z ; CvPreGame::setMinorCiv
	add	esp, 8

; 381  : 
; 382  : #ifdef AUI_WARNING_FIXES
; 383  : 		if (kPlayer.m_szLeaderName[0] != '\0')
; 384  : #else
; 385  : 		if(strlen(kPlayer.m_szLeaderName) > 0)

	mov	edx, DWORD PTR _kPlayer$223847[ebp]
	add	edx, 32					; 00000020H
	mov	DWORD PTR tv577[ebp], edx
	mov	eax, DWORD PTR tv577[ebp]
	add	eax, 1
	mov	DWORD PTR tv580[ebp], eax
$LL119@SetupPlaye:
	mov	ecx, DWORD PTR tv577[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv583[ebp], dl
	add	DWORD PTR tv577[ebp], 1
	cmp	BYTE PTR tv583[ebp], 0
	jne	SHORT $LL119@SetupPlaye
	mov	eax, DWORD PTR tv577[ebp]
	sub	eax, DWORD PTR tv580[ebp]
	mov	DWORD PTR tv192[ebp], eax
	je	SHORT $LN27@SetupPlaye

; 386  : #endif
; 387  : 			CvPreGame::setLeaderName(ePlayer, kPlayer.m_szLeaderName);

	mov	ecx, DWORD PTR _kPlayer$223847[ebp]
	add	ecx, 32					; 00000020H
	mov	DWORD PTR $T227870[ebp], ecx
	je	SHORT $LN69@SetupPlaye
	mov	edx, DWORD PTR $T227870[ebp]
	mov	DWORD PTR tv393[ebp], edx
	jmp	SHORT $LN70@SetupPlaye
$LN69@SetupPlaye:
	mov	DWORD PTR tv393[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN70@SetupPlaye:
	mov	eax, DWORD PTR tv393[ebp]
	push	eax
	lea	ecx, DWORD PTR $T227827[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T227827[ebp]
	push	ecx
	mov	edx, DWORD PTR _ePlayer$223843[ebp]
	push	edx
	call	?setLeaderName@CvPreGame@@YAXW4PlayerTypes@@ABVCvString@@@Z ; CvPreGame::setLeaderName
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T227827[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN27@SetupPlaye:

; 388  : 
; 389  : #ifdef AUI_WARNING_FIXES
; 390  : 		if (kPlayer.m_szCivName[0] != '\0')
; 391  : #else
; 392  : 		if(strlen(kPlayer.m_szCivName) > 0)

	mov	eax, DWORD PTR _kPlayer$223847[ebp]
	add	eax, 96					; 00000060H
	mov	DWORD PTR tv594[ebp], eax
	mov	ecx, DWORD PTR tv594[ebp]
	add	ecx, 1
	mov	DWORD PTR tv597[ebp], ecx
$LL120@SetupPlaye:
	mov	edx, DWORD PTR tv594[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv600[ebp], al
	add	DWORD PTR tv594[ebp], 1
	cmp	BYTE PTR tv600[ebp], 0
	jne	SHORT $LL120@SetupPlaye
	mov	ecx, DWORD PTR tv594[ebp]
	sub	ecx, DWORD PTR tv597[ebp]
	mov	DWORD PTR tv204[ebp], ecx
	je	$LN26@SetupPlaye

; 393  : #endif
; 394  : 		{
; 395  : 			CvPreGame::setCivilizationShortDescription(ePlayer, kPlayer.m_szCivName);

	mov	edx, DWORD PTR _kPlayer$223847[ebp]
	add	edx, 96					; 00000060H
	mov	DWORD PTR $T227883[ebp], edx
	je	SHORT $LN77@SetupPlaye
	mov	eax, DWORD PTR $T227883[ebp]
	mov	DWORD PTR tv411[ebp], eax
	jmp	SHORT $LN78@SetupPlaye
$LN77@SetupPlaye:
	mov	DWORD PTR tv411[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN78@SetupPlaye:
	mov	ecx, DWORD PTR tv411[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T227828[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	lea	edx, DWORD PTR $T227828[ebp]
	push	edx
	mov	eax, DWORD PTR _ePlayer$223843[ebp]
	push	eax
	call	?setCivilizationShortDescription@CvPreGame@@YAXW4PlayerTypes@@ABVCvString@@@Z ; CvPreGame::setCivilizationShortDescription
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T227828[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 396  : 			CvPreGame::setCivilizationDescription(ePlayer, kPlayer.m_szCivName);

	mov	ecx, DWORD PTR _kPlayer$223847[ebp]
	add	ecx, 96					; 00000060H
	mov	DWORD PTR $T227896[ebp], ecx
	je	SHORT $LN85@SetupPlaye
	mov	edx, DWORD PTR $T227896[ebp]
	mov	DWORD PTR tv429[ebp], edx
	jmp	SHORT $LN86@SetupPlaye
$LN85@SetupPlaye:
	mov	DWORD PTR tv429[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN86@SetupPlaye:
	mov	eax, DWORD PTR tv429[ebp]
	push	eax
	lea	ecx, DWORD PTR $T227829[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T227829[ebp]
	push	ecx
	mov	edx, DWORD PTR _ePlayer$223843[ebp]
	push	edx
	call	?setCivilizationDescription@CvPreGame@@YAXW4PlayerTypes@@ABVCvString@@@Z ; CvPreGame::setCivilizationDescription
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T227829[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN26@SetupPlaye:

; 397  : 		}
; 398  : 	}

	jmp	$LN44@SetupPlaye
$LN43@SetupPlaye:

; 399  : 
; 400  : 	// If this is a map with defined player slots then close any slots out of this defined range
; 401  : 	// that are being filled by computer players.  Hopefully there aren't any human players there.
; 402  : 	const uint uiPlayerSlotCount = sg_kMapInfo.uiMajorCivStartingPositions + sg_kMapInfo.uiPlayers;

	mov	eax, DWORD PTR _sg_kMapInfo+16
	add	eax, DWORD PTR _sg_kMapInfo+8
	mov	DWORD PTR _uiPlayerSlotCount$[ebp], eax

; 403  : 	if(uiPlayerSlotCount > 0)

	je	SHORT $LN25@SetupPlaye

; 404  : 	{
; 405  : 		for(uint i = uiPlayerSlotCount; i < MAX_MAJOR_CIVS; ++i)

	mov	ecx, DWORD PTR _uiPlayerSlotCount$[ebp]
	mov	DWORD PTR _i$223885[ebp], ecx
	jmp	SHORT $LN24@SetupPlaye
$LN23@SetupPlaye:
	mov	edx, DWORD PTR _i$223885[ebp]
	add	edx, 1
	mov	DWORD PTR _i$223885[ebp], edx
$LN24@SetupPlaye:
	cmp	DWORD PTR _i$223885[ebp], 22		; 00000016H
	jae	SHORT $LN25@SetupPlaye

; 406  : 		{
; 407  : 			const PlayerTypes ePlayer = (PlayerTypes)i;

	mov	eax, DWORD PTR _i$223885[ebp]
	mov	DWORD PTR _ePlayer$223889[ebp], eax

; 408  : 			const SlotStatus eStatus = CvPreGame::slotStatus(ePlayer);

	mov	ecx, DWORD PTR _ePlayer$223889[ebp]
	push	ecx
	call	?slotStatus@CvPreGame@@YA?AW4SlotStatus@@W4PlayerTypes@@@Z ; CvPreGame::slotStatus
	add	esp, 4
	mov	DWORD PTR _eStatus$223891[ebp], eax

; 409  : 			if(eStatus == SS_COMPUTER)

	cmp	DWORD PTR _eStatus$223891[ebp], 1
	jne	SHORT $LN21@SetupPlaye

; 410  : 				CvPreGame::resetPlayer(ePlayer);	// Do a full reset, which will also close the slot.  A reset is better so that the player data does not get initialized later.

	mov	edx, DWORD PTR _ePlayer$223889[ebp]
	push	edx
	call	?resetPlayer@CvPreGame@@YAXW4PlayerTypes@@@Z ; CvPreGame::resetPlayer
	add	esp, 4
$LN21@SetupPlaye:

; 411  : 		}

	jmp	SHORT $LN23@SetupPlaye
$LN25@SetupPlaye:

; 412  : 	}
; 413  : 
; 414  : #ifdef AUI_WARNING_FIXES
; 415  : 	const byte uiCityStateCount = MIN(sg_kSave.GetCityStateCount(), (byte)MAX_MINOR_CIVS);
; 416  : #else
; 417  : 	const uint uiCityStateCount = std::min(sg_kSave.GetCityStateCount(), (byte)MAX_MINOR_CIVS);

	mov	BYTE PTR $T227830[ebp], 41		; 00000029H
	mov	al, BYTE PTR _sg_kSave+12317
	mov	BYTE PTR $T227904[ebp], al
	mov	cl, BYTE PTR $T227904[ebp]
	mov	BYTE PTR $T227831[ebp], cl
	movzx	edx, BYTE PTR $T227830[ebp]
	movzx	eax, BYTE PTR $T227831[ebp]
	cmp	edx, eax
	jge	SHORT $LN95@SetupPlaye
	lea	ecx, DWORD PTR $T227830[ebp]
	mov	DWORD PTR tv444[ebp], ecx
	jmp	SHORT $LN96@SetupPlaye
$LN95@SetupPlaye:
	lea	edx, DWORD PTR $T227831[ebp]
	mov	DWORD PTR tv444[ebp], edx
$LN96@SetupPlaye:
	mov	eax, DWORD PTR tv444[ebp]
	mov	DWORD PTR $T227911[ebp], eax
	mov	ecx, DWORD PTR $T227911[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _uiCityStateCount$[ebp], edx

; 418  : #endif
; 419  : 
; 420  : 	if(uiCityStateCount > 0)

	cmp	DWORD PTR _uiCityStateCount$[ebp], 0
	jbe	SHORT $LN20@SetupPlaye

; 421  : 		CvPreGame::setNumMinorCivs(uiCityStateCount);

	mov	eax, DWORD PTR _uiCityStateCount$[ebp]
	push	eax
	call	?setNumMinorCivs@CvPreGame@@YAXH@Z	; CvPreGame::setNumMinorCivs
	add	esp, 4
	jmp	SHORT $LN19@SetupPlaye
$LN20@SetupPlaye:

; 422  : 	else if(sg_kMapInfo.uiMinorCivStartingPositions > 0)

	cmp	DWORD PTR _sg_kMapInfo+20, 0
	jbe	SHORT $LN18@SetupPlaye

; 423  : 		CvPreGame::setNumMinorCivs(sg_kMapInfo.uiMinorCivStartingPositions);

	mov	ecx, DWORD PTR _sg_kMapInfo+20
	push	ecx
	call	?setNumMinorCivs@CvPreGame@@YAXH@Z	; CvPreGame::setNumMinorCivs
	add	esp, 4
	jmp	SHORT $LN19@SetupPlaye
$LN18@SetupPlaye:

; 424  : 	else if(!CvPreGame::mapNoPlayers())

	call	?mapNoPlayers@CvPreGame@@YA_NXZ		; CvPreGame::mapNoPlayers
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN19@SetupPlaye

; 425  : 		CvPreGame::setNumMinorCivs(0);

	push	0
	call	?setNumMinorCivs@CvPreGame@@YAXH@Z	; CvPreGame::setNumMinorCivs
	add	esp, 4
$LN19@SetupPlaye:

; 426  : 
; 427  : #ifdef AUI_WARNING_FIXES
; 428  : 	for (byte i = 0; i < uiCityStateCount; ++i)
; 429  : #else
; 430  : 	for(uint i = 0; i < uiCityStateCount; ++i)

	mov	DWORD PTR _i$223902[ebp], 0
	jmp	SHORT $LN15@SetupPlaye
$LN14@SetupPlaye:
	mov	eax, DWORD PTR _i$223902[ebp]
	add	eax, 1
	mov	DWORD PTR _i$223902[ebp], eax
$LN15@SetupPlaye:
	mov	ecx, DWORD PTR _i$223902[ebp]
	cmp	ecx, DWORD PTR _uiCityStateCount$[ebp]
	jae	$LN46@SetupPlaye

; 431  : #endif
; 432  : 	{
; 433  : 		const PlayerTypes ePlayer = (PlayerTypes)(i + MAX_MAJOR_CIVS);

	mov	edx, DWORD PTR _i$223902[ebp]
	add	edx, 22					; 00000016H
	mov	DWORD PTR _ePlayer$223906[ebp], edx

; 434  : 		const CvWorldBuilderMap::Player& kPlayer = sg_kSave.GetCityState(i);

	movzx	eax, BYTE PTR _i$223902[ebp]
	movzx	ecx, BYTE PTR _sg_kSave+12317
	cmp	eax, ecx
	jge	SHORT $LN98@SetupPlaye
	movzx	edx, BYTE PTR _i$223902[ebp]
	cmp	edx, 64					; 00000040H
	jae	SHORT $LN98@SetupPlaye
	movzx	eax, BYTE PTR _i$223902[ebp]
	imul	eax, 436				; 000001b4H
	add	eax, OFFSET _sg_kSave+550560
	mov	DWORD PTR _kPlayer$223908[ebp], eax
	jmp	SHORT $LN99@SetupPlaye
	jmp	SHORT $LN99@SetupPlaye
$LN98@SetupPlaye:
	mov	DWORD PTR _kPlayer$223908[ebp], OFFSET ?sm_kErrorPlayer@CvWorldBuilderMap@@0UPlayer@1@A ; CvWorldBuilderMap::sm_kErrorPlayer
$LN99@SetupPlaye:

; 435  : 
; 436  : 		MinorCivTypes eCivType = NO_MINORCIV;

	mov	DWORD PTR _eCivType$223909[ebp], -1

; 437  : #ifdef AUI_WARNING_FIXES
; 438  : 		for (uint iCiv = 0; iCiv < GC.getNumMinorCivInfos(); ++iCiv)
; 439  : #else
; 440  : 		for(int iCiv = 0; iCiv < GC.getNumMinorCivInfos(); ++iCiv)

	mov	DWORD PTR _iCiv$223910[ebp], 0
	jmp	SHORT $LN12@SetupPlaye
$LN11@SetupPlaye:
	mov	ecx, DWORD PTR _iCiv$223910[ebp]
	add	ecx, 1
	mov	DWORD PTR _iCiv$223910[ebp], ecx
$LN12@SetupPlaye:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumMinorCivInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumMinorCivInfos
	cmp	DWORD PTR _iCiv$223910[ebp], eax
	jge	$LN10@SetupPlaye

; 441  : #endif
; 442  : 		{
; 443  : 			CvMinorCivInfo* pkCivilization = GC.getMinorCivInfo((MinorCivTypes)iCiv);

	mov	edx, DWORD PTR _iCiv$223910[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMinorCivInfo@CvGlobals@@QAEPAVCvMinorCivInfo@@W4MinorCivTypes@@@Z ; CvGlobals::getMinorCivInfo
	mov	DWORD PTR _pkCivilization$223914[ebp], eax

; 444  : 			if(pkCivilization != NULL && strcmp(kPlayer.m_szCivType, pkCivilization->GetType()) == 0)

	cmp	DWORD PTR _pkCivilization$223914[ebp], 0
	je	$LN9@SetupPlaye
	mov	ecx, DWORD PTR _pkCivilization$223914[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR tv641[ebp], eax
	mov	eax, DWORD PTR _kPlayer$223908[ebp]
	add	eax, 160				; 000000a0H
	mov	DWORD PTR tv640[ebp], eax
$LL121@SetupPlaye:
	mov	ecx, DWORD PTR tv640[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv644[ebp], dl
	mov	eax, DWORD PTR tv641[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN122@SetupPlaye
	cmp	BYTE PTR tv644[ebp], 0
	je	SHORT $LN123@SetupPlaye
	mov	ecx, DWORD PTR tv640[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv651[ebp], dl
	mov	eax, DWORD PTR tv641[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN122@SetupPlaye
	add	DWORD PTR tv640[ebp], 2
	add	DWORD PTR tv641[ebp], 2
	cmp	BYTE PTR tv651[ebp], 0
	jne	SHORT $LL121@SetupPlaye
$LN123@SetupPlaye:
	mov	DWORD PTR tv656[ebp], 0
	jmp	SHORT $LN124@SetupPlaye
$LN122@SetupPlaye:
	sbb	ecx, ecx
	sbb	ecx, -1
	mov	DWORD PTR tv656[ebp], ecx
$LN124@SetupPlaye:
	mov	edx, DWORD PTR tv656[ebp]
	mov	DWORD PTR tv298[ebp], edx
	cmp	DWORD PTR tv298[ebp], 0
	jne	SHORT $LN9@SetupPlaye

; 445  : 			{
; 446  : 				eCivType = (MinorCivTypes)iCiv;

	mov	eax, DWORD PTR _iCiv$223910[ebp]
	mov	DWORD PTR _eCivType$223909[ebp], eax

; 447  : 				break;

	jmp	SHORT $LN10@SetupPlaye
$LN9@SetupPlaye:

; 448  : 			}
; 449  : 		}

	jmp	$LN11@SetupPlaye
$LN10@SetupPlaye:

; 450  : 
; 451  : 		CvPreGame::setMinorCivType(ePlayer, eCivType);

	mov	ecx, DWORD PTR _eCivType$223909[ebp]
	push	ecx
	mov	edx, DWORD PTR _ePlayer$223906[ebp]
	push	edx
	call	?setMinorCivType@CvPreGame@@YAXW4PlayerTypes@@W4MinorCivTypes@@@Z ; CvPreGame::setMinorCivType
	add	esp, 8

; 452  : 
; 453  : 		PlayerColorTypes eColorType = NO_PLAYERCOLOR;

	mov	DWORD PTR _eColorType$223918[ebp], -1

; 454  : #ifdef AUI_WARNING_FIXES
; 455  : 		for (uint iColor = 0; iColor < GC.GetNumPlayerColorInfos(); ++iColor)
; 456  : #else
; 457  : 		for(int iColor = 0; iColor < GC.GetNumPlayerColorInfos(); ++iColor)

	mov	DWORD PTR _iColor$223919[ebp], 0
	jmp	SHORT $LN8@SetupPlaye
$LN7@SetupPlaye:
	mov	eax, DWORD PTR _iColor$223919[ebp]
	add	eax, 1
	mov	DWORD PTR _iColor$223919[ebp], eax
$LN8@SetupPlaye:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetNumPlayerColorInfos@CvGlobals@@QAEHXZ ; CvGlobals::GetNumPlayerColorInfos
	cmp	DWORD PTR _iColor$223919[ebp], eax
	jge	$LN6@SetupPlaye

; 458  : #endif
; 459  : 		{
; 460  : 			CvPlayerColorInfo* pkColor = GC.GetPlayerColorInfo((PlayerColorTypes)iColor);

	mov	ecx, DWORD PTR _iColor$223919[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetPlayerColorInfo@CvGlobals@@QAEPAVCvPlayerColorInfo@@W4PlayerColorTypes@@@Z ; CvGlobals::GetPlayerColorInfo
	mov	DWORD PTR _pkColor$223923[ebp], eax

; 461  : 			if(pkColor != NULL && strcmp(kPlayer.m_szTeamColor, pkColor->GetType()) == 0)

	cmp	DWORD PTR _pkColor$223923[ebp], 0
	je	$LN5@SetupPlaye
	mov	ecx, DWORD PTR _pkColor$223923[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR tv672[ebp], eax
	mov	edx, DWORD PTR _kPlayer$223908[ebp]
	add	edx, 224				; 000000e0H
	mov	DWORD PTR tv671[ebp], edx
$LL125@SetupPlaye:
	mov	eax, DWORD PTR tv671[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv675[ebp], cl
	mov	edx, DWORD PTR tv672[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN126@SetupPlaye
	cmp	BYTE PTR tv675[ebp], 0
	je	SHORT $LN127@SetupPlaye
	mov	eax, DWORD PTR tv671[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv682[ebp], cl
	mov	edx, DWORD PTR tv672[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN126@SetupPlaye
	add	DWORD PTR tv671[ebp], 2
	add	DWORD PTR tv672[ebp], 2
	cmp	BYTE PTR tv682[ebp], 0
	jne	SHORT $LL125@SetupPlaye
$LN127@SetupPlaye:
	mov	DWORD PTR tv687[ebp], 0
	jmp	SHORT $LN128@SetupPlaye
$LN126@SetupPlaye:
	sbb	eax, eax
	sbb	eax, -1
	mov	DWORD PTR tv687[ebp], eax
$LN128@SetupPlaye:
	mov	ecx, DWORD PTR tv687[ebp]
	mov	DWORD PTR tv320[ebp], ecx
	cmp	DWORD PTR tv320[ebp], 0
	jne	SHORT $LN5@SetupPlaye

; 462  : 			{
; 463  : 				eColorType = (PlayerColorTypes)iColor;

	mov	edx, DWORD PTR _iColor$223919[ebp]
	mov	DWORD PTR _eColorType$223918[ebp], edx

; 464  : 				break;

	jmp	SHORT $LN6@SetupPlaye
$LN5@SetupPlaye:

; 465  : 			}
; 466  : 		}

	jmp	$LN7@SetupPlaye
$LN6@SetupPlaye:

; 467  : 
; 468  : 		CvPreGame::setPlayerColor(ePlayer, eColorType);

	mov	eax, DWORD PTR _eColorType$223918[ebp]
	push	eax
	mov	ecx, DWORD PTR _ePlayer$223906[ebp]
	push	ecx
	call	?setPlayerColor@CvPreGame@@YAXW4PlayerTypes@@W4PlayerColorTypes@@@Z ; CvPreGame::setPlayerColor
	add	esp, 8

; 469  : 
; 470  : 		HandicapTypes eHandicap = NO_HANDICAP;

	mov	DWORD PTR _eHandicap$223927[ebp], -1

; 471  : #ifdef AUI_WARNING_FIXES
; 472  : 		for (uint iHandicap = 0; iHandicap < GC.getNumHandicapInfos(); ++iHandicap)
; 473  : #else
; 474  : 		for(int iHandicap = 0; iHandicap < GC.getNumHandicapInfos(); ++iHandicap)

	mov	DWORD PTR _iHandicap$223928[ebp], 0
	jmp	SHORT $LN4@SetupPlaye
$LN3@SetupPlaye:
	mov	edx, DWORD PTR _iHandicap$223928[ebp]
	add	edx, 1
	mov	DWORD PTR _iHandicap$223928[ebp], edx
$LN4@SetupPlaye:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumHandicapInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumHandicapInfos
	cmp	DWORD PTR _iHandicap$223928[ebp], eax
	jge	$LN2@SetupPlaye

; 475  : #endif
; 476  : 		{
; 477  : 			CvHandicapInfo* pkHandicap = GC.getHandicapInfo((HandicapTypes)iHandicap);

	mov	eax, DWORD PTR _iHandicap$223928[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getHandicapInfo@CvGlobals@@QAEPAVCvHandicapInfo@@W4HandicapTypes@@@Z ; CvGlobals::getHandicapInfo
	mov	DWORD PTR _pkHandicap$223932[ebp], eax

; 478  : 			if(pkHandicap != NULL && strcmp(kPlayer.m_szHandicap, pkHandicap->GetType()) == 0)

	cmp	DWORD PTR _pkHandicap$223932[ebp], 0
	je	$LN1@SetupPlaye
	mov	ecx, DWORD PTR _pkHandicap$223932[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR tv703[ebp], eax
	mov	ecx, DWORD PTR _kPlayer$223908[ebp]
	add	ecx, 352				; 00000160H
	mov	DWORD PTR tv702[ebp], ecx
$LL129@SetupPlaye:
	mov	edx, DWORD PTR tv702[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv706[ebp], al
	mov	ecx, DWORD PTR tv703[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN130@SetupPlaye
	cmp	BYTE PTR tv706[ebp], 0
	je	SHORT $LN131@SetupPlaye
	mov	edx, DWORD PTR tv702[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv713[ebp], al
	mov	ecx, DWORD PTR tv703[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN130@SetupPlaye
	add	DWORD PTR tv702[ebp], 2
	add	DWORD PTR tv703[ebp], 2
	cmp	BYTE PTR tv713[ebp], 0
	jne	SHORT $LL129@SetupPlaye
$LN131@SetupPlaye:
	mov	DWORD PTR tv718[ebp], 0
	jmp	SHORT $LN132@SetupPlaye
$LN130@SetupPlaye:
	sbb	edx, edx
	sbb	edx, -1
	mov	DWORD PTR tv718[ebp], edx
$LN132@SetupPlaye:
	mov	eax, DWORD PTR tv718[ebp]
	mov	DWORD PTR tv342[ebp], eax
	cmp	DWORD PTR tv342[ebp], 0
	jne	SHORT $LN1@SetupPlaye

; 479  : 			{
; 480  : 				eHandicap = (HandicapTypes)iHandicap;

	mov	ecx, DWORD PTR _iHandicap$223928[ebp]
	mov	DWORD PTR _eHandicap$223927[ebp], ecx

; 481  : 				break;

	jmp	SHORT $LN2@SetupPlaye
$LN1@SetupPlaye:

; 482  : 			}
; 483  : 		}

	jmp	$LN3@SetupPlaye
$LN2@SetupPlaye:

; 484  : 
; 485  : 		CvPreGame::setHandicap(ePlayer, eHandicap);

	mov	edx, DWORD PTR _eHandicap$223927[ebp]
	push	edx
	mov	eax, DWORD PTR _ePlayer$223906[ebp]
	push	eax
	call	?setHandicap@CvPreGame@@YAXW4PlayerTypes@@W4HandicapTypes@@@Z ; CvPreGame::setHandicap
	add	esp, 8

; 486  : 
; 487  : 		CvPreGame::setSlotStatus(ePlayer, SS_COMPUTER);

	push	1
	mov	ecx, DWORD PTR _ePlayer$223906[ebp]
	push	ecx
	call	?setSlotStatus@CvPreGame@@YAXW4PlayerTypes@@W4SlotStatus@@@Z ; CvPreGame::setSlotStatus
	add	esp, 8

; 488  : 		CvPreGame::setTeamType(ePlayer, (TeamTypes)kPlayer.m_byTeam);

	mov	edx, DWORD PTR _kPlayer$223908[ebp]
	movzx	eax, BYTE PTR [edx+432]
	push	eax
	mov	ecx, DWORD PTR _ePlayer$223906[ebp]
	push	ecx
	call	?setTeamType@CvPreGame@@YAXW4PlayerTypes@@W4TeamTypes@@@Z ; CvPreGame::setTeamType
	add	esp, 8

; 489  : 		CvPreGame::setMinorCiv(ePlayer, true);

	push	1
	mov	edx, DWORD PTR _ePlayer$223906[ebp]
	push	edx
	call	?setMinorCiv@CvPreGame@@YAXW4PlayerTypes@@_N@Z ; CvPreGame::setMinorCiv
	add	esp, 8
	jmp	$LN14@SetupPlaye
$LN46@SetupPlaye:

; 490  : 	}
; 491  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetupPlayers@CvWorldBuilderMapLoader@@SAXXZ$0:
	lea	ecx, DWORD PTR $T227827[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?SetupPlayers@CvWorldBuilderMapLoader@@SAXXZ$1:
	lea	ecx, DWORD PTR $T227828[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?SetupPlayers@CvWorldBuilderMapLoader@@SAXXZ$2:
	lea	ecx, DWORD PTR $T227829[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?SetupPlayers@CvWorldBuilderMapLoader@@SAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-416]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetupPlayers@CvWorldBuilderMapLoader@@SAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetupPlayers@CvWorldBuilderMapLoader@@SAXXZ ENDP	; CvWorldBuilderMapLoader::SetupPlayers
PUBLIC	?_Xran@?$bitset@$0BAA@@std@@ABEXXZ		; std::bitset<256>::_Xran
PUBLIC	?SetPlayerInitialItems@@YAXAAVCvPlayer@@ABUPlayer@CvWorldBuilderMap@@@Z ; SetPlayerInitialItems
EXTRN	?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z:PROC ; CvTeam::setHasTech
EXTRN	?GetEra@CvTechEntry@@QBEHXZ:PROC		; CvTechEntry::GetEra
EXTRN	?getEraInfo@CvGlobals@@QAEPAVCvEraInfo@@W4EraTypes@@@Z:PROC ; CvGlobals::getEraInfo
EXTRN	?getNumEraInfos@CvGlobals@@QAEHXZ:PROC		; CvGlobals::getNumEraInfos
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
EXTRN	?setHasPolicy@CvPlayer@@QAEXW4PolicyTypes@@_N@Z:PROC ; CvPlayer::setHasPolicy
EXTRN	?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z:PROC ; CvPlayerPolicies::SetPolicyBranchUnlocked
EXTRN	?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z:PROC ; CvPlayerPolicies::IsPolicyBranchUnlocked
EXTRN	?GetFreePolicy@CvPolicyBranchEntry@@QBEHXZ:PROC	; CvPolicyBranchEntry::GetFreePolicy
EXTRN	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z:PROC ; CvGlobals::getPolicyBranchInfo
EXTRN	?getNumPolicyBranchInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumPolicyBranchInfos
EXTRN	?GetPolicyBranchType@CvPolicyEntry@@QBEHXZ:PROC	; CvPolicyEntry::GetPolicyBranchType
EXTRN	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ:PROC ; CvPlayer::GetPlayerPolicies
EXTRN	?setJONSCulture@CvPlayer@@QAEXH@Z:PROC		; CvPlayer::setJONSCulture
EXTRN	?SetGold@CvTreasury@@QAEXH@Z:PROC		; CvTreasury::SetGold
EXTRN	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ:PROC ; CvPlayer::GetTreasury
EXTRN	__CxxThrowException@8:PROC
; Function compile flags: /Odtp
;	COMDAT ?SetPlayerInitialItems@@YAXAAVCvPlayer@@ABUPlayer@CvWorldBuilderMap@@@Z
_TEXT	SEGMENT
tv181 = -188						; size = 4
tv343 = -184						; size = 4
tv338 = -178						; size = 1
tv331 = -177						; size = 1
tv327 = -176						; size = 4
tv328 = -172						; size = 4
$T228003 = -168						; size = 4
_pkTech$223993 = -96					; size = 4
_eTech$223991 = -92					; size = 4
_iTech$223987 = -88					; size = 4
_iTechCount$223986 = -84				; size = 4
_eEra$223981 = -80					; size = 4
_pkEra$223983 = -76					; size = 4
_iEra$223977 = -72					; size = 4
_iStartingEra$223975 = -68				; size = 4
_iEraCount$223976 = -64					; size = 4
_kTeam$223974 = -60					; size = 4
_eFreePolicy$223969 = -56				; size = 4
_pkBranch$223967 = -52					; size = 4
_eCurrentBranch$223962 = -48				; size = 4
_pkBranch$223964 = -44					; size = 4
_iPolicyBranch$223958 = -40				; size = 4
_iPolicyBranchCount$223957 = -36			; size = 4
_ePolicyBranch$223954 = -32				; size = 4
_pkPlayerPolicies$223951 = -28				; size = 4
_pkPolicy$223952 = -24					; size = 4
_ePolicy$223948 = -20					; size = 4
_iPolicy$223944 = -16					; size = 4
_iPolicyCount$ = -12					; size = 4
_pkTreasury$ = -8					; size = 4
_eTeam$ = -4						; size = 4
_kGameplayPlayer$ = 8					; size = 4
_kSavedPlayer$ = 12					; size = 4
?SetPlayerInitialItems@@YAXAAVCvPlayer@@ABUPlayer@CvWorldBuilderMap@@@Z PROC ; SetPlayerInitialItems, COMDAT

; 494  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 188				; 000000bcH
	push	esi

; 495  : 	CvTreasury* pkTreasury = kGameplayPlayer.GetTreasury();

	mov	ecx, DWORD PTR _kGameplayPlayer$[ebp]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	DWORD PTR _pkTreasury$[ebp], eax

; 496  : 	FAssertMsg(pkTreasury, "Unable to set gold amount.  Treasury Missing!");
; 497  : 	if(pkTreasury != NULL)

	cmp	DWORD PTR _pkTreasury$[ebp], 0
	je	SHORT $LN24@SetPlayerI

; 498  : 		pkTreasury->SetGold(kSavedPlayer.m_uiGold);

	mov	eax, DWORD PTR _kSavedPlayer$[ebp]
	mov	ecx, DWORD PTR [eax+420]
	push	ecx
	mov	ecx, DWORD PTR _pkTreasury$[ebp]
	call	?SetGold@CvTreasury@@QAEXH@Z		; CvTreasury::SetGold
$LN24@SetPlayerI:

; 499  : 
; 500  : 	kGameplayPlayer.setJONSCulture(kSavedPlayer.m_uiCulture);

	mov	edx, DWORD PTR _kSavedPlayer$[ebp]
	mov	eax, DWORD PTR [edx+416]
	push	eax
	mov	ecx, DWORD PTR _kGameplayPlayer$[ebp]
	call	?setJONSCulture@CvPlayer@@QAEXH@Z	; CvPlayer::setJONSCulture

; 501  : 
; 502  : #ifdef AUI_WARNING_FIXES
; 503  : 	for (uint iPolicy = 0; iPolicy < GC.getNumPolicyInfos(); ++iPolicy)
; 504  : #else
; 505  : 	const int iPolicyCount = GC.getNumPolicyInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumPolicyInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPolicyInfos
	mov	DWORD PTR _iPolicyCount$[ebp], eax

; 506  : 	for(int iPolicy = 0; iPolicy < iPolicyCount; ++iPolicy)

	mov	DWORD PTR _iPolicy$223944[ebp], 0
	jmp	SHORT $LN23@SetPlayerI
$LN22@SetPlayerI:
	mov	ecx, DWORD PTR _iPolicy$223944[ebp]
	add	ecx, 1
	mov	DWORD PTR _iPolicy$223944[ebp], ecx
$LN23@SetPlayerI:
	mov	edx, DWORD PTR _iPolicy$223944[ebp]
	cmp	edx, DWORD PTR _iPolicyCount$[ebp]
	jge	$LN38@SetPlayerI

; 507  : #endif
; 508  : 	{
; 509  : 		const PolicyTypes ePolicy = (PolicyTypes)iPolicy;

	mov	eax, DWORD PTR _iPolicy$223944[ebp]
	mov	DWORD PTR _ePolicy$223948[ebp], eax

; 510  : 		if(kSavedPlayer.m_kPolicies[iPolicy])

	cmp	DWORD PTR _iPolicy$223944[ebp], 256	; 00000100H
	jb	SHORT $LN27@SetPlayerI
	mov	ecx, DWORD PTR _kSavedPlayer$[ebp]
	call	?_Xran@?$bitset@$0BAA@@std@@ABEXXZ	; std::bitset<256>::_Xran
$LN27@SetPlayerI:
	mov	esi, DWORD PTR _iPolicy$223944[ebp]
	shr	esi, 5
	mov	eax, DWORD PTR _iPolicy$223944[ebp]
	xor	edx, edx
	mov	ecx, 32					; 00000020H
	div	ecx
	mov	eax, 1
	mov	ecx, edx
	shl	eax, cl
	mov	ecx, DWORD PTR _kSavedPlayer$[ebp]
	and	eax, DWORD PTR [ecx+esi*4]
	neg	eax
	sbb	eax, eax
	neg	eax
	movzx	edx, al
	test	edx, edx
	je	$LN20@SetPlayerI

; 511  : 		{
; 512  : 			// Check the policy branch
; 513  : 			CvPlayerPolicies* pkPlayerPolicies = kGameplayPlayer.GetPlayerPolicies();

	mov	ecx, DWORD PTR _kGameplayPlayer$[ebp]
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	DWORD PTR _pkPlayerPolicies$223951[ebp], eax

; 514  : 			const CvPolicyEntry* pkPolicy = GC.getPolicyInfo(ePolicy);

	mov	eax, DWORD PTR _ePolicy$223948[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z ; CvGlobals::getPolicyInfo
	mov	DWORD PTR _pkPolicy$223952[ebp], eax

; 515  : 			if(pkPolicy != NULL && pkPlayerPolicies != NULL)

	cmp	DWORD PTR _pkPolicy$223952[ebp], 0
	je	$LN19@SetPlayerI
	cmp	DWORD PTR _pkPlayerPolicies$223951[ebp], 0
	je	$LN19@SetPlayerI

; 516  : 			{
; 517  : 				PolicyBranchTypes ePolicyBranch = (PolicyBranchTypes)pkPolicy->GetPolicyBranchType();

	mov	ecx, DWORD PTR _pkPolicy$223952[ebp]
	call	?GetPolicyBranchType@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetPolicyBranchType
	mov	DWORD PTR _ePolicyBranch$223954[ebp], eax

; 518  : 
; 519  : 				// NO_POLICY_BRANCH_TYPE means that this is probably a free policy.
; 520  : 				// We'll have to look through the policy branches to find a matching one.
; 521  : 				if(ePolicyBranch == NO_POLICY_BRANCH_TYPE)

	cmp	DWORD PTR _ePolicyBranch$223954[ebp], -1
	jne	SHORT $LN18@SetPlayerI

; 522  : 				{
; 523  : 					const int iPolicyBranchCount = GC.getNumPolicyBranchInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumPolicyBranchInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumPolicyBranchInfos
	mov	DWORD PTR _iPolicyBranchCount$223957[ebp], eax

; 524  : 					for(int iPolicyBranch = 0; iPolicyBranch < iPolicyBranchCount; ++iPolicyBranch)

	mov	DWORD PTR _iPolicyBranch$223958[ebp], 0
	jmp	SHORT $LN17@SetPlayerI
$LN16@SetPlayerI:
	mov	ecx, DWORD PTR _iPolicyBranch$223958[ebp]
	add	ecx, 1
	mov	DWORD PTR _iPolicyBranch$223958[ebp], ecx
$LN17@SetPlayerI:
	mov	edx, DWORD PTR _iPolicyBranch$223958[ebp]
	cmp	edx, DWORD PTR _iPolicyBranchCount$223957[ebp]
	jge	SHORT $LN18@SetPlayerI

; 525  : 					{
; 526  : 						const PolicyBranchTypes eCurrentBranch = (PolicyBranchTypes)iPolicyBranch;

	mov	eax, DWORD PTR _iPolicyBranch$223958[ebp]
	mov	DWORD PTR _eCurrentBranch$223962[ebp], eax

; 527  : 						const CvPolicyBranchEntry* pkBranch = GC.getPolicyBranchInfo(eCurrentBranch);

	mov	ecx, DWORD PTR _eCurrentBranch$223962[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z ; CvGlobals::getPolicyBranchInfo
	mov	DWORD PTR _pkBranch$223964[ebp], eax

; 528  : 						if(pkBranch != NULL && pkBranch->GetFreePolicy() == ePolicy)

	cmp	DWORD PTR _pkBranch$223964[ebp], 0
	je	SHORT $LN14@SetPlayerI
	mov	ecx, DWORD PTR _pkBranch$223964[ebp]
	call	?GetFreePolicy@CvPolicyBranchEntry@@QBEHXZ ; CvPolicyBranchEntry::GetFreePolicy
	cmp	eax, DWORD PTR _ePolicy$223948[ebp]
	jne	SHORT $LN14@SetPlayerI

; 529  : 						{
; 530  : 							ePolicyBranch = eCurrentBranch;

	mov	edx, DWORD PTR _eCurrentBranch$223962[ebp]
	mov	DWORD PTR _ePolicyBranch$223954[ebp], edx

; 531  : 							break;

	jmp	SHORT $LN18@SetPlayerI
$LN14@SetPlayerI:

; 532  : 						}
; 533  : 					}

	jmp	SHORT $LN16@SetPlayerI
$LN18@SetPlayerI:

; 534  : 				}
; 535  : 
; 536  : 				// Unlock the policy branch if it hasn't been unlocked yet
; 537  : 				if(ePolicyBranch != NO_POLICY_BRANCH_TYPE &&
; 538  : 				        !pkPlayerPolicies->IsPolicyBranchUnlocked(ePolicyBranch))

	cmp	DWORD PTR _ePolicyBranch$223954[ebp], -1
	je	SHORT $LN19@SetPlayerI
	mov	eax, DWORD PTR _ePolicyBranch$223954[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkPlayerPolicies$223951[ebp]
	call	?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::IsPolicyBranchUnlocked
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN19@SetPlayerI

; 539  : 				{
; 540  : 					pkPlayerPolicies->SetPolicyBranchUnlocked(ePolicyBranch, true, false);

	push	0
	push	1
	mov	edx, DWORD PTR _ePolicyBranch$223954[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkPlayerPolicies$223951[ebp]
	call	?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z ; CvPlayerPolicies::SetPolicyBranchUnlocked

; 541  : 
; 542  : 					// Also, unlock the free policy for the branch
; 543  : 					const CvPolicyBranchEntry* pkBranch = GC.getPolicyBranchInfo(ePolicyBranch);

	mov	eax, DWORD PTR _ePolicyBranch$223954[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z ; CvGlobals::getPolicyBranchInfo
	mov	DWORD PTR _pkBranch$223967[ebp], eax

; 544  : 					if(pkBranch != NULL)

	cmp	DWORD PTR _pkBranch$223967[ebp], 0
	je	SHORT $LN19@SetPlayerI

; 545  : 					{
; 546  : 						PolicyTypes eFreePolicy = (PolicyTypes)pkBranch->GetFreePolicy();

	mov	ecx, DWORD PTR _pkBranch$223967[ebp]
	call	?GetFreePolicy@CvPolicyBranchEntry@@QBEHXZ ; CvPolicyBranchEntry::GetFreePolicy
	mov	DWORD PTR _eFreePolicy$223969[ebp], eax

; 547  : 						if(eFreePolicy != NO_POLICY)

	cmp	DWORD PTR _eFreePolicy$223969[ebp], -1
	je	SHORT $LN19@SetPlayerI

; 548  : 							kGameplayPlayer.setHasPolicy(eFreePolicy, true);

	push	1
	mov	ecx, DWORD PTR _eFreePolicy$223969[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kGameplayPlayer$[ebp]
	call	?setHasPolicy@CvPlayer@@QAEXW4PolicyTypes@@_N@Z ; CvPlayer::setHasPolicy
$LN19@SetPlayerI:

; 549  : 					}
; 550  : 				}
; 551  : 			}
; 552  : 
; 553  : 			// Finally, unlock the policy
; 554  : 			kGameplayPlayer.setHasPolicy(ePolicy, true);

	push	1
	mov	edx, DWORD PTR _ePolicy$223948[ebp]
	push	edx
	mov	ecx, DWORD PTR _kGameplayPlayer$[ebp]
	call	?setHasPolicy@CvPlayer@@QAEXW4PolicyTypes@@_N@Z ; CvPlayer::setHasPolicy
$LN20@SetPlayerI:

; 555  : 		}
; 556  : 	}

	jmp	$LN22@SetPlayerI

; 557  : 
; 558  : 	const TeamTypes eTeam = kGameplayPlayer.getTeam();

$LN38@SetPlayerI:
	mov	eax, DWORD PTR _kGameplayPlayer$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$[ebp], eax

; 559  : 	if(eTeam != NO_TEAM)

	cmp	DWORD PTR _eTeam$[ebp], -1
	je	$LN25@SetPlayerI

; 560  : 	{
; 561  : 		CvTeam& kTeam = GET_TEAM(eTeam);

	mov	edx, DWORD PTR _eTeam$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR _kTeam$223974[ebp], edx

; 562  : 
; 563  : 		int iStartingEra = 0;

	mov	DWORD PTR _iStartingEra$223975[ebp], 0

; 564  : #ifdef AUI_WARNING_FIXES
; 565  : 		for (uint iEra = 0; iEra < GC.getNumEraInfos(); ++iEra)
; 566  : #else
; 567  : 		const int iEraCount = GC.getNumEraInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumEraInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumEraInfos
	mov	DWORD PTR _iEraCount$223976[ebp], eax

; 568  : 		for(int iEra = 0; iEra < iEraCount; ++iEra)

	mov	DWORD PTR _iEra$223977[ebp], 0
	jmp	SHORT $LN9@SetPlayerI
$LN8@SetPlayerI:
	mov	eax, DWORD PTR _iEra$223977[ebp]
	add	eax, 1
	mov	DWORD PTR _iEra$223977[ebp], eax
$LN9@SetPlayerI:
	mov	ecx, DWORD PTR _iEra$223977[ebp]
	cmp	ecx, DWORD PTR _iEraCount$223976[ebp]
	jge	$LN7@SetPlayerI

; 569  : #endif
; 570  : 		{
; 571  : 			const EraTypes eEra = (EraTypes)iEra;

	mov	edx, DWORD PTR _iEra$223977[ebp]
	mov	DWORD PTR _eEra$223981[ebp], edx

; 572  : 			const CvEraInfo* pkEra = GC.getEraInfo(eEra);

	mov	eax, DWORD PTR _eEra$223981[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getEraInfo@CvGlobals@@QAEPAVCvEraInfo@@W4EraTypes@@@Z ; CvGlobals::getEraInfo
	mov	DWORD PTR _pkEra$223983[ebp], eax

; 573  : 			if(pkEra != NULL && strcmp(pkEra->GetType(), kSavedPlayer.m_szEra) == 0)

	cmp	DWORD PTR _pkEra$223983[ebp], 0
	je	$LN6@SetPlayerI
	mov	ecx, DWORD PTR _kSavedPlayer$[ebp]
	add	ecx, 288				; 00000120H
	mov	DWORD PTR tv328[ebp], ecx
	mov	ecx, DWORD PTR _pkEra$223983[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR tv327[ebp], eax
$LL50@SetPlayerI:
	mov	edx, DWORD PTR tv327[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv331[ebp], al
	mov	ecx, DWORD PTR tv328[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN51@SetPlayerI
	cmp	BYTE PTR tv331[ebp], 0
	je	SHORT $LN52@SetPlayerI
	mov	edx, DWORD PTR tv327[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv338[ebp], al
	mov	ecx, DWORD PTR tv328[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN51@SetPlayerI
	add	DWORD PTR tv327[ebp], 2
	add	DWORD PTR tv328[ebp], 2
	cmp	BYTE PTR tv338[ebp], 0
	jne	SHORT $LL50@SetPlayerI
$LN52@SetPlayerI:
	mov	DWORD PTR tv343[ebp], 0
	jmp	SHORT $LN53@SetPlayerI
$LN51@SetPlayerI:
	sbb	edx, edx
	sbb	edx, -1
	mov	DWORD PTR tv343[ebp], edx
$LN53@SetPlayerI:
	mov	eax, DWORD PTR tv343[ebp]
	mov	DWORD PTR tv181[ebp], eax
	cmp	DWORD PTR tv181[ebp], 0
	jne	SHORT $LN6@SetPlayerI

; 574  : 			{
; 575  : 				iStartingEra = iEra;

	mov	ecx, DWORD PTR _iEra$223977[ebp]
	mov	DWORD PTR _iStartingEra$223975[ebp], ecx

; 576  : 				break;

	jmp	SHORT $LN7@SetPlayerI
$LN6@SetPlayerI:

; 577  : 			}
; 578  : 		}

	jmp	$LN8@SetPlayerI
$LN7@SetPlayerI:

; 579  : 
; 580  : 		if(iStartingEra > 0)

	cmp	DWORD PTR _iStartingEra$223975[ebp], 0
	jle	SHORT $LN25@SetPlayerI

; 581  : 		{
; 582  : #ifdef AUI_WARNING_FIXES
; 583  : 			for (uint iTech = 0; iTech < GC.getNumTechInfos(); ++iTech)
; 584  : #else
; 585  : 			const int iTechCount = GC.getNumTechInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	mov	DWORD PTR _iTechCount$223986[ebp], eax

; 586  : 			for(int iTech = 0; iTech < iTechCount; ++iTech)

	mov	DWORD PTR _iTech$223987[ebp], 0
	jmp	SHORT $LN4@SetPlayerI
$LN3@SetPlayerI:
	mov	edx, DWORD PTR _iTech$223987[ebp]
	add	edx, 1
	mov	DWORD PTR _iTech$223987[ebp], edx
$LN4@SetPlayerI:
	mov	eax, DWORD PTR _iTech$223987[ebp]
	cmp	eax, DWORD PTR _iTechCount$223986[ebp]
	jge	SHORT $LN25@SetPlayerI

; 587  : #endif
; 588  : 			{
; 589  : 				const TechTypes eTech = (TechTypes)iTech;

	mov	ecx, DWORD PTR _iTech$223987[ebp]
	mov	DWORD PTR _eTech$223991[ebp], ecx

; 590  : 				const CvTechEntry* pkTech = GC.getTechInfo(eTech);

	mov	edx, DWORD PTR _eTech$223991[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo
	mov	DWORD PTR _pkTech$223993[ebp], eax

; 591  : 				if(pkTech != NULL && pkTech->GetEra() < iStartingEra)

	cmp	DWORD PTR _pkTech$223993[ebp], 0
	je	SHORT $LN1@SetPlayerI
	mov	ecx, DWORD PTR _pkTech$223993[ebp]
	call	?GetEra@CvTechEntry@@QBEHXZ		; CvTechEntry::GetEra
	cmp	eax, DWORD PTR _iStartingEra$223975[ebp]
	jge	SHORT $LN1@SetPlayerI

; 592  : 					kTeam.setHasTech(eTech, true, kGameplayPlayer.GetID(), false, false);

	mov	eax, DWORD PTR _kGameplayPlayer$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T228003[ebp], ecx
	push	0
	push	0
	mov	edx, DWORD PTR $T228003[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _eTech$223991[ebp]
	push	eax
	mov	ecx, DWORD PTR _kTeam$223974[ebp]
	call	?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z ; CvTeam::setHasTech
$LN1@SetPlayerI:

; 593  : 			}

	jmp	SHORT $LN3@SetPlayerI
$LN25@SetPlayerI:

; 594  : 		}
; 595  : 	}
; 596  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?SetPlayerInitialItems@@YAXAAVCvPlayer@@ABUPlayer@CvWorldBuilderMap@@@Z ENDP ; SetPlayerInitialItems
_TEXT	ENDS
PUBLIC	?SetTeamInitialItems@@YAXAAVCvTeam@@ABUTeam@CvWorldBuilderMap@@@Z ; SetTeamInitialItems
; Function compile flags: /Odtp
;	COMDAT ?SetTeamInitialItems@@YAXAAVCvTeam@@ABUTeam@CvWorldBuilderMap@@@Z
_TEXT	SEGMENT
$T228035 = -84						; size = 4
_eTech$224004 = -12					; size = 4
_iTech$224000 = -8					; size = 4
_iTechCount$ = -4					; size = 4
_kGameplayTeam$ = 8					; size = 4
_kSavedTeam$ = 12					; size = 4
?SetTeamInitialItems@@YAXAAVCvTeam@@ABUTeam@CvWorldBuilderMap@@@Z PROC ; SetTeamInitialItems, COMDAT

; 599  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	esi

; 600  : #ifdef AUI_WARNING_FIXES
; 601  : 	for (uint iTech = 0; iTech < GC.getNumTechInfos(); ++iTech)
; 602  : #else
; 603  : 	const int iTechCount = GC.getNumTechInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	mov	DWORD PTR _iTechCount$[ebp], eax

; 604  : 	for(int iTech = 0; iTech < iTechCount; ++iTech)

	mov	DWORD PTR _iTech$224000[ebp], 0
	jmp	SHORT $LN4@SetTeamIni
$LN3@SetTeamIni:
	mov	eax, DWORD PTR _iTech$224000[ebp]
	add	eax, 1
	mov	DWORD PTR _iTech$224000[ebp], eax
$LN4@SetTeamIni:
	mov	ecx, DWORD PTR _iTech$224000[ebp]
	cmp	ecx, DWORD PTR _iTechCount$[ebp]
	jge	SHORT $LN5@SetTeamIni

; 605  : #endif
; 606  : 	{
; 607  : 		const TechTypes eTech = (TechTypes)iTech;

	mov	edx, DWORD PTR _iTech$224000[ebp]
	mov	DWORD PTR _eTech$224004[ebp], edx

; 608  : 		if(kSavedTeam.m_kTechs[iTech])

	mov	eax, DWORD PTR _kSavedTeam$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR $T228035[ebp], eax
	cmp	DWORD PTR _iTech$224000[ebp], 256	; 00000100H
	jb	SHORT $LN7@SetTeamIni
	mov	ecx, DWORD PTR $T228035[ebp]
	call	?_Xran@?$bitset@$0BAA@@std@@ABEXXZ	; std::bitset<256>::_Xran
$LN7@SetTeamIni:
	mov	esi, DWORD PTR _iTech$224000[ebp]
	shr	esi, 5
	mov	eax, DWORD PTR _iTech$224000[ebp]
	xor	edx, edx
	mov	ecx, 32					; 00000020H
	div	ecx
	mov	eax, 1
	mov	ecx, edx
	shl	eax, cl
	mov	ecx, DWORD PTR $T228035[ebp]
	and	eax, DWORD PTR [ecx+esi*4]
	neg	eax
	sbb	eax, eax
	neg	eax
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@SetTeamIni

; 609  : 			kGameplayTeam.setHasTech(eTech, true, NO_PLAYER, false, false);

	push	0
	push	0
	push	-1
	push	1
	mov	eax, DWORD PTR _eTech$224004[ebp]
	push	eax
	mov	ecx, DWORD PTR _kGameplayTeam$[ebp]
	call	?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z ; CvTeam::setHasTech
$LN1@SetTeamIni:

; 610  : 	}

	jmp	SHORT $LN3@SetTeamIni
$LN5@SetTeamIni:

; 611  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?SetTeamInitialItems@@YAXAAVCvTeam@@ABUTeam@CvWorldBuilderMap@@@Z ENDP ; SetTeamInitialItems
_TEXT	ENDS
PUBLIC	?SetInitialItems@CvWorldBuilderMapLoader@@SAX_N@Z ; CvWorldBuilderMapLoader::SetInitialItems
EXTRN	?DoUpdateHappiness@CvPlayer@@QAEXXZ:PROC	; CvPlayer::DoUpdateHappiness
EXTRN	?DoGold@CvTreasury@@QAEXXZ:PROC			; CvTreasury::DoGold
EXTRN	?DoUpdateCityConnectionGold@CvTreasury@@QAEXXZ:PROC ; CvTreasury::DoUpdateCityConnectionGold
EXTRN	?Update@CvCityConnections@@QAEXXZ:PROC		; CvCityConnections::Update
EXTRN	?GetCityConnections@CvPlayer@@QBEPAVCvCityConnections@@XZ:PROC ; CvPlayer::GetCityConnections
EXTRN	?DoTurn@CvCityCitizens@@QAEXXZ:PROC		; CvCityCitizens::DoTurn
EXTRN	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ:PROC ; CvCity::GetCityCitizens
EXTRN	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::nextCity
EXTRN	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::firstCity
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
EXTRN	?sm_kErrorTeam@CvWorldBuilderMap@@0UTeam@1@A:BYTE ; CvWorldBuilderMap::sm_kErrorTeam
; Function compile flags: /Odtp
;	COMDAT ?SetInitialItems@CvWorldBuilderMapLoader@@SAX_N@Z
_TEXT	SEGMENT
tv204 = -100						; size = 4
tv191 = -96						; size = 4
tv178 = -92						; size = 4
$T228106 = -88						; size = 4
$T228098 = -84						; size = 4
$T228091 = -77						; size = 1
$T228087 = -76						; size = 4
$T228076 = -72						; size = 4
$T228069 = -65						; size = 1
$T228062 = -64						; size = 4
$T228054 = -60						; size = 4
$T228047 = -55						; size = 1
$T228043 = -54						; size = 1
$T228042 = -53						; size = 1
$T228041 = -52						; size = 1
$T228040 = -51						; size = 1
$T228039 = -50						; size = 1
$T228038 = -49						; size = 1
_ePlayer$224045 = -48					; size = 4
_i$224041 = -44						; size = 4
_pLoopCity$224032 = -40					; size = 4
_iLoop$224033 = -36					; size = 4
_ePlayer$224028 = -32					; size = 4
_kPlayer$224030 = -28					; size = 4
_i$224024 = -24						; size = 4
_eTeam$224018 = -20					; size = 4
_i$224014 = -16						; size = 4
_uiCityStateCount$ = -12				; size = 4
_uiTeamCount$ = -8					; size = 4
_uiPlayerCount$ = -4					; size = 4
_bFirstCall$ = 8					; size = 1
?SetInitialItems@CvWorldBuilderMapLoader@@SAX_N@Z PROC	; CvWorldBuilderMapLoader::SetInitialItems, COMDAT

; 614  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H

; 615  : #ifdef AUI_WARNING_FIXES
; 616  : 	const byte uiTeamCount = MIN(sg_kSave.GetTeamCount(), (byte)MAX_TEAMS);
; 617  : 	for (byte i = 0; i < uiTeamCount; ++i)
; 618  : #else
; 619  : 	const uint uiTeamCount = std::min(sg_kSave.GetTeamCount(), (byte)MAX_TEAMS);

	mov	BYTE PTR $T228038[ebp], 64		; 00000040H
	mov	al, BYTE PTR _sg_kSave+12318
	mov	BYTE PTR $T228047[ebp], al
	mov	cl, BYTE PTR $T228047[ebp]
	mov	BYTE PTR $T228039[ebp], cl
	movzx	edx, BYTE PTR $T228038[ebp]
	movzx	eax, BYTE PTR $T228039[ebp]
	cmp	edx, eax
	jge	SHORT $LN20@SetInitial
	lea	ecx, DWORD PTR $T228038[ebp]
	mov	DWORD PTR tv178[ebp], ecx
	jmp	SHORT $LN21@SetInitial
$LN20@SetInitial:
	lea	edx, DWORD PTR $T228039[ebp]
	mov	DWORD PTR tv178[ebp], edx
$LN21@SetInitial:
	mov	eax, DWORD PTR tv178[ebp]
	mov	DWORD PTR $T228054[ebp], eax
	mov	ecx, DWORD PTR $T228054[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _uiTeamCount$[ebp], edx

; 620  : 	for(uint i = 0; i < uiTeamCount; ++i)

	mov	DWORD PTR _i$224014[ebp], 0
	jmp	SHORT $LN13@SetInitial
$LN12@SetInitial:
	mov	eax, DWORD PTR _i$224014[ebp]
	add	eax, 1
	mov	DWORD PTR _i$224014[ebp], eax
$LN13@SetInitial:
	mov	ecx, DWORD PTR _i$224014[ebp]
	cmp	ecx, DWORD PTR _uiTeamCount$[ebp]
	jae	SHORT $LN11@SetInitial

; 621  : #endif
; 622  : 	{
; 623  : 		const TeamTypes eTeam = (TeamTypes)i;

	mov	edx, DWORD PTR _i$224014[ebp]
	mov	DWORD PTR _eTeam$224018[ebp], edx

; 624  : 		SetTeamInitialItems(GET_TEAM(eTeam), sg_kSave.GetTeam(i));

	movzx	eax, BYTE PTR _i$224014[ebp]
	movzx	ecx, BYTE PTR _sg_kSave+12318
	cmp	eax, ecx
	jge	SHORT $LN23@SetInitial
	movzx	edx, BYTE PTR _i$224014[ebp]
	cmp	edx, 96					; 00000060H
	jae	SHORT $LN23@SetInitial
	movzx	eax, BYTE PTR _i$224014[ebp]
	shl	eax, 6
	add	eax, OFFSET _sg_kSave+578464
	mov	DWORD PTR $T228062[ebp], eax
	jmp	SHORT $LN26@SetInitial
	jmp	SHORT $LN26@SetInitial
$LN23@SetInitial:
	mov	DWORD PTR $T228062[ebp], OFFSET ?sm_kErrorTeam@CvWorldBuilderMap@@0UTeam@1@A ; CvWorldBuilderMap::sm_kErrorTeam
$LN26@SetInitial:
	mov	ecx, DWORD PTR $T228062[ebp]
	push	ecx
	mov	edx, DWORD PTR _eTeam$224018[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	edx
	call	?SetTeamInitialItems@@YAXAAVCvTeam@@ABUTeam@CvWorldBuilderMap@@@Z ; SetTeamInitialItems
	add	esp, 8

; 625  : 	}

	jmp	SHORT $LN12@SetInitial
$LN11@SetInitial:

; 626  : 
; 627  : #ifdef AUI_WARNING_FIXES
; 628  : 	const byte uiPlayerCount = MIN(sg_kSave.GetPlayerCount(), (byte)MAX_CIV_PLAYERS);
; 629  : 	for (byte i = 0; i < uiPlayerCount; ++i)
; 630  : #else
; 631  : 	const uint uiPlayerCount = std::min(sg_kSave.GetPlayerCount(), (byte)MAX_CIV_PLAYERS);

	mov	BYTE PTR $T228040[ebp], 63		; 0000003fH
	mov	al, BYTE PTR _sg_kSave+12316
	mov	BYTE PTR $T228069[ebp], al
	mov	cl, BYTE PTR $T228069[ebp]
	mov	BYTE PTR $T228041[ebp], cl
	movzx	edx, BYTE PTR $T228040[ebp]
	movzx	eax, BYTE PTR $T228041[ebp]
	cmp	edx, eax
	jge	SHORT $LN32@SetInitial
	lea	ecx, DWORD PTR $T228040[ebp]
	mov	DWORD PTR tv191[ebp], ecx
	jmp	SHORT $LN33@SetInitial
$LN32@SetInitial:
	lea	edx, DWORD PTR $T228041[ebp]
	mov	DWORD PTR tv191[ebp], edx
$LN33@SetInitial:
	mov	eax, DWORD PTR tv191[ebp]
	mov	DWORD PTR $T228076[ebp], eax
	mov	ecx, DWORD PTR $T228076[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _uiPlayerCount$[ebp], edx

; 632  : 	for(uint i = 0; i < uiPlayerCount; ++i)

	mov	DWORD PTR _i$224024[ebp], 0
	jmp	SHORT $LN10@SetInitial
$LN9@SetInitial:
	mov	eax, DWORD PTR _i$224024[ebp]
	add	eax, 1
	mov	DWORD PTR _i$224024[ebp], eax
$LN10@SetInitial:
	mov	ecx, DWORD PTR _i$224024[ebp]
	cmp	ecx, DWORD PTR _uiPlayerCount$[ebp]
	jae	$LN8@SetInitial

; 633  : #endif
; 634  : 	{
; 635  : 		const PlayerTypes ePlayer = (PlayerTypes)i;

	mov	edx, DWORD PTR _i$224024[ebp]
	mov	DWORD PTR _ePlayer$224028[ebp], edx

; 636  : 		CvPlayer& kPlayer = GET_PLAYER(ePlayer);

	mov	eax, DWORD PTR _ePlayer$224028[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$224030[ebp], eax

; 637  : 		SetPlayerInitialItems(kPlayer, sg_kSave.GetPlayer(i));

	movzx	ecx, BYTE PTR _i$224024[ebp]
	movzx	edx, BYTE PTR _sg_kSave+12316
	cmp	ecx, edx
	jge	SHORT $LN37@SetInitial
	movzx	eax, BYTE PTR _i$224024[ebp]
	cmp	eax, 32					; 00000020H
	jae	SHORT $LN37@SetInitial
	movzx	ecx, BYTE PTR _i$224024[ebp]
	imul	ecx, 436				; 000001b4H
	add	ecx, OFFSET _sg_kSave+536608
	mov	DWORD PTR $T228087[ebp], ecx
	jmp	SHORT $LN38@SetInitial
	jmp	SHORT $LN38@SetInitial
$LN37@SetInitial:
	mov	DWORD PTR $T228087[ebp], OFFSET ?sm_kErrorPlayer@CvWorldBuilderMap@@0UPlayer@1@A ; CvWorldBuilderMap::sm_kErrorPlayer
$LN38@SetInitial:
	mov	edx, DWORD PTR $T228087[ebp]
	push	edx
	mov	eax, DWORD PTR _kPlayer$224030[ebp]
	push	eax
	call	?SetPlayerInitialItems@@YAXAAVCvPlayer@@ABUPlayer@CvWorldBuilderMap@@@Z ; SetPlayerInitialItems
	add	esp, 8

; 638  : 
; 639  : 		if(!bFirstCall)

	movzx	ecx, BYTE PTR _bFirstCall$[ebp]
	test	ecx, ecx
	jne	SHORT $LN7@SetInitial

; 640  : 		{
; 641  : 			// Assign all citizens
; 642  : 			CvCity* pLoopCity;
; 643  : 			int iLoop;
; 644  : 			for(pLoopCity = kPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kPlayer.nextCity(&iLoop))

	push	0
	lea	edx, DWORD PTR _iLoop$224033[ebp]
	push	edx
	mov	ecx, DWORD PTR _kPlayer$224030[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$224032[ebp], eax
	jmp	SHORT $LN6@SetInitial
$LN5@SetInitial:
	push	0
	lea	eax, DWORD PTR _iLoop$224033[ebp]
	push	eax
	mov	ecx, DWORD PTR _kPlayer$224030[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$224032[ebp], eax
$LN6@SetInitial:
	cmp	DWORD PTR _pLoopCity$224032[ebp], 0
	je	SHORT $LN4@SetInitial

; 645  : 			{
; 646  : 				pLoopCity->GetCityCitizens()->DoTurn();

	mov	ecx, DWORD PTR _pLoopCity$224032[ebp]
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?DoTurn@CvCityCitizens@@QAEXXZ		; CvCityCitizens::DoTurn

; 647  : 			}

	jmp	SHORT $LN5@SetInitial
$LN4@SetInitial:

; 648  : 
; 649  : 			// Update player data
; 650  : 			kPlayer.GetCityConnections()->Update();

	mov	ecx, DWORD PTR _kPlayer$224030[ebp]
	call	?GetCityConnections@CvPlayer@@QBEPAVCvCityConnections@@XZ ; CvPlayer::GetCityConnections
	mov	ecx, eax
	call	?Update@CvCityConnections@@QAEXXZ	; CvCityConnections::Update

; 651  : 			kPlayer.GetTreasury()->DoUpdateCityConnectionGold();

	mov	ecx, DWORD PTR _kPlayer$224030[ebp]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?DoUpdateCityConnectionGold@CvTreasury@@QAEXXZ ; CvTreasury::DoUpdateCityConnectionGold

; 652  : 			kPlayer.GetTreasury()->DoGold();

	mov	ecx, DWORD PTR _kPlayer$224030[ebp]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?DoGold@CvTreasury@@QAEXXZ		; CvTreasury::DoGold

; 653  : 			kPlayer.DoUpdateHappiness();

	mov	ecx, DWORD PTR _kPlayer$224030[ebp]
	call	?DoUpdateHappiness@CvPlayer@@QAEXXZ	; CvPlayer::DoUpdateHappiness
$LN7@SetInitial:

; 654  : #ifdef AUI_CITIZENS_MID_TURN_ASSIGN_RUNS_SELF_CONSISTENCY
; 655  : 			kPlayer.doSelfConsistencyCheckAllCities();
; 656  : #endif
; 657  : 		}
; 658  : 	}

	jmp	$LN9@SetInitial
$LN8@SetInitial:

; 659  : 
; 660  : #ifdef AUI_WARNING_FIXES
; 661  : 	const byte uiCityStateCount = MIN(sg_kSave.GetCityStateCount(), (byte)MAX_MINOR_CIVS);
; 662  : 	for (byte i = 0; i < uiCityStateCount; ++i)
; 663  : #else
; 664  : 	const uint uiCityStateCount = std::min(sg_kSave.GetCityStateCount(), (byte)MAX_MINOR_CIVS);

	mov	BYTE PTR $T228042[ebp], 41		; 00000029H
	mov	cl, BYTE PTR _sg_kSave+12317
	mov	BYTE PTR $T228091[ebp], cl
	mov	dl, BYTE PTR $T228091[ebp]
	mov	BYTE PTR $T228043[ebp], dl
	movzx	eax, BYTE PTR $T228042[ebp]
	movzx	ecx, BYTE PTR $T228043[ebp]
	cmp	eax, ecx
	jge	SHORT $LN44@SetInitial
	lea	edx, DWORD PTR $T228042[ebp]
	mov	DWORD PTR tv204[ebp], edx
	jmp	SHORT $LN45@SetInitial
$LN44@SetInitial:
	lea	eax, DWORD PTR $T228043[ebp]
	mov	DWORD PTR tv204[ebp], eax
$LN45@SetInitial:
	mov	ecx, DWORD PTR tv204[ebp]
	mov	DWORD PTR $T228098[ebp], ecx
	mov	edx, DWORD PTR $T228098[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR _uiCityStateCount$[ebp], eax

; 665  : 	for(uint i = 0; i < uiCityStateCount; ++i)

	mov	DWORD PTR _i$224041[ebp], 0
	jmp	SHORT $LN3@SetInitial
$LN2@SetInitial:
	mov	ecx, DWORD PTR _i$224041[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$224041[ebp], ecx
$LN3@SetInitial:
	mov	edx, DWORD PTR _i$224041[ebp]
	cmp	edx, DWORD PTR _uiCityStateCount$[ebp]
	jae	SHORT $LN14@SetInitial

; 666  : #endif
; 667  : 	{
; 668  : 		const PlayerTypes ePlayer = (PlayerTypes)(i + MAX_MAJOR_CIVS);

	mov	eax, DWORD PTR _i$224041[ebp]
	add	eax, 22					; 00000016H
	mov	DWORD PTR _ePlayer$224045[ebp], eax

; 669  : 		SetPlayerInitialItems(GET_PLAYER(ePlayer), sg_kSave.GetCityState(i));

	movzx	ecx, BYTE PTR _i$224041[ebp]
	movzx	edx, BYTE PTR _sg_kSave+12317
	cmp	ecx, edx
	jge	SHORT $LN47@SetInitial
	movzx	eax, BYTE PTR _i$224041[ebp]
	cmp	eax, 64					; 00000040H
	jae	SHORT $LN47@SetInitial
	movzx	ecx, BYTE PTR _i$224041[ebp]
	imul	ecx, 436				; 000001b4H
	add	ecx, OFFSET _sg_kSave+550560
	mov	DWORD PTR $T228106[ebp], ecx
	jmp	SHORT $LN50@SetInitial
	jmp	SHORT $LN50@SetInitial
$LN47@SetInitial:
	mov	DWORD PTR $T228106[ebp], OFFSET ?sm_kErrorPlayer@CvWorldBuilderMap@@0UPlayer@1@A ; CvWorldBuilderMap::sm_kErrorPlayer
$LN50@SetInitial:
	mov	edx, DWORD PTR $T228106[ebp]
	push	edx
	mov	eax, DWORD PTR _ePlayer$224045[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	call	?SetPlayerInitialItems@@YAXAAVCvPlayer@@ABUPlayer@CvWorldBuilderMap@@@Z ; SetPlayerInitialItems
	add	esp, 8
	jmp	SHORT $LN2@SetInitial
$LN14@SetInitial:

; 670  : 	}
; 671  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetInitialItems@CvWorldBuilderMapLoader@@SAX_N@Z ENDP	; CvWorldBuilderMapLoader::SetInitialItems
_TEXT	ENDS
PUBLIC	?GetPlayerType@@YA?AW4PlayerTypes@@E@Z		; GetPlayerType
; Function compile flags: /Odtp
;	COMDAT ?GetPlayerType@@YA?AW4PlayerTypes@@E@Z
_TEXT	SEGMENT
_uiCityState$224056 = -4				; size = 4
_byCulture$ = 8						; size = 1
?GetPlayerType@@YA?AW4PlayerTypes@@E@Z PROC		; GetPlayerType, COMDAT

; 674  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 675  : 	if(byCulture < CvWorldBuilderMap::MaxPlayers)

	movzx	eax, BYTE PTR _byCulture$[ebp]
	cmp	eax, 32					; 00000020H
	jae	SHORT $LN10@GetPlayerT

; 676  : 	{
; 677  : 		if(byCulture < MAX_MAJOR_CIVS)

	movzx	ecx, BYTE PTR _byCulture$[ebp]
	cmp	ecx, 22					; 00000016H
	jge	SHORT $LN9@GetPlayerT

; 678  : 			return (PlayerTypes)byCulture;

	movzx	eax, BYTE PTR _byCulture$[ebp]
	jmp	SHORT $LN11@GetPlayerT

; 679  : 		else

	jmp	SHORT $LN8@GetPlayerT
$LN9@GetPlayerT:

; 680  : 			return NO_PLAYER; // Player out of range

	or	eax, -1
	jmp	SHORT $LN11@GetPlayerT
$LN8@GetPlayerT:
	jmp	SHORT $LN11@GetPlayerT
$LN10@GetPlayerT:

; 681  : 	}
; 682  : 	else if(byCulture < CvWorldBuilderMap::MaxPlayers + CvWorldBuilderMap::MaxCityStates)

	movzx	edx, BYTE PTR _byCulture$[ebp]
	cmp	edx, 96					; 00000060H
	jae	SHORT $LN6@GetPlayerT

; 683  : 	{
; 684  : 		const uint uiCityState = byCulture - CvWorldBuilderMap::MaxPlayers;

	movzx	eax, BYTE PTR _byCulture$[ebp]
	sub	eax, 32					; 00000020H
	mov	DWORD PTR _uiCityState$224056[ebp], eax

; 685  : 		if(uiCityState < MAX_MINOR_CIVS)

	cmp	DWORD PTR _uiCityState$224056[ebp], 41	; 00000029H
	jae	SHORT $LN5@GetPlayerT

; 686  : 			return (PlayerTypes)(uiCityState + MAX_MAJOR_CIVS);

	mov	eax, DWORD PTR _uiCityState$224056[ebp]
	add	eax, 22					; 00000016H
	jmp	SHORT $LN11@GetPlayerT

; 687  : 		else

	jmp	SHORT $LN4@GetPlayerT
$LN5@GetPlayerT:

; 688  : 			return NO_PLAYER; // City State out of range

	or	eax, -1
	jmp	SHORT $LN11@GetPlayerT
$LN4@GetPlayerT:
	jmp	SHORT $LN11@GetPlayerT
$LN6@GetPlayerT:

; 689  : 	}
; 690  : 	else if(byCulture == CvWorldBuilderMap::MaxPlayers + CvWorldBuilderMap::MaxCityStates)

	movzx	ecx, BYTE PTR _byCulture$[ebp]
	cmp	ecx, 96					; 00000060H
	jne	SHORT $LN2@GetPlayerT

; 691  : 	{
; 692  : 		return BARBARIAN_PLAYER;

	mov	eax, 63					; 0000003fH
	jmp	SHORT $LN11@GetPlayerT

; 693  : 	}
; 694  : 	else

	jmp	SHORT $LN11@GetPlayerT
$LN2@GetPlayerT:

; 695  : 	{
; 696  : 		return NO_PLAYER; // Completely invalid culture type

	or	eax, -1
$LN11@GetPlayerT:

; 697  : 	}
; 698  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPlayerType@@YA?AW4PlayerTypes@@E@Z ENDP		; GetPlayerType
_TEXT	ENDS
PUBLIC	?_Xran@?$bitset@$0CAA@@std@@ABEXXZ		; std::bitset<512>::_Xran
PUBLIC	__real@47c35000
PUBLIC	?SetupCity@@YAXABUCity@CvWorldBuilderMap@@HH@Z	; SetupCity
EXTRN	?DoUpdateNextPolicyCost@CvPlayer@@QAEXXZ:PROC	; CvPlayer::DoUpdateNextPolicyCost
EXTRN	?SetNumRealBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z:PROC ; CvCityBuildings::SetNumRealBuilding
EXTRN	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ:PROC ; CvCity::GetCityBuildings
EXTRN	?setDamage@CvCity@@QAEXH_N@Z:PROC		; CvCity::setDamage
EXTRN	?GetMaxHitPoints@CvCity@@QBEHXZ:PROC		; CvCity::GetMaxHitPoints
EXTRN	?SetPuppet@CvCity@@QAEX_N@Z:PROC		; CvCity::SetPuppet
EXTRN	?SetOccupied@CvCity@@QAEX_N@Z:PROC		; CvCity::SetOccupied
EXTRN	?setPopulation@CvCity@@QAEXH_N@Z:PROC		; CvCity::setPopulation
EXTRN	?setName@CvCity@@QAEXPBD_N@Z:PROC		; CvCity::setName
EXTRN	?initCity@CvPlayer@@QAEPAVCvCity@@HH_N0@Z:PROC	; CvPlayer::initCity
EXTRN	__fltused:DWORD
;	COMDAT __real@47c35000
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
CONST	SEGMENT
__real@47c35000 DD 047c35000r			; 100000
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvworldbuildermaploader.cpp
CONST	ENDS
;	COMDAT ?SetupCity@@YAXABUCity@CvWorldBuilderMap@@HH@Z
_TEXT	SEGMENT
tv247 = -120						; size = 8
$T228151 = -112						; size = 4
_eBuildingType$224091 = -40				; size = 4
_iBuilding$224087 = -36					; size = 4
_iBuildingTypeCount$224086 = -32			; size = 4
_fHitPoints$224079 = -28				; size = 4
_iHitPoints$224081 = -24				; size = 4
_iMaxHitPoints$224078 = -20				; size = 4
_pkCityBuildings$224084 = -16				; size = 4
_pkGameplayCity$224072 = -12				; size = 4
_kPlayer$224071 = -8					; size = 4
_ePlayer$ = -4						; size = 4
_kSavedCity$ = 8					; size = 4
_iPlotX$ = 12						; size = 4
_iPlotY$ = 16						; size = 4
?SetupCity@@YAXABUCity@CvWorldBuilderMap@@HH@Z PROC	; SetupCity, COMDAT

; 701  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	push	esi

; 702  : 	const PlayerTypes ePlayer = GetPlayerType(kSavedCity.m_byOwner);

	mov	eax, DWORD PTR _kSavedCity$[ebp]
	movzx	ecx, BYTE PTR [eax+64]
	push	ecx
	call	?GetPlayerType@@YA?AW4PlayerTypes@@E@Z	; GetPlayerType
	add	esp, 4
	mov	DWORD PTR _ePlayer$[ebp], eax

; 703  : 	if(ePlayer != NO_PLAYER)

	cmp	DWORD PTR _ePlayer$[ebp], -1
	je	$LN11@SetupCity

; 704  : 	{
; 705  : 		CvPlayer& kPlayer = GET_PLAYER(ePlayer);

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$224071[ebp], edx

; 706  : 		CvCity* pkGameplayCity = kPlayer.initCity(iPlotX, iPlotY);

	push	1
	push	1
	mov	eax, DWORD PTR _iPlotY$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iPlotX$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kPlayer$224071[ebp]
	call	?initCity@CvPlayer@@QAEPAVCvCity@@HH_N0@Z ; CvPlayer::initCity
	mov	DWORD PTR _pkGameplayCity$224072[ebp], eax

; 707  : 		if(pkGameplayCity != NULL)

	cmp	DWORD PTR _pkGameplayCity$224072[ebp], 0
	je	$LN11@SetupCity

; 708  : 		{
; 709  : 			pkGameplayCity->setName(kSavedCity.m_szName);

	push	0
	mov	edx, DWORD PTR _kSavedCity$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkGameplayCity$224072[ebp]
	call	?setName@CvCity@@QAEXPBD_N@Z		; CvCity::setName

; 710  : 			pkGameplayCity->setPopulation(kSavedCity.m_wPopulation);

	push	1
	mov	eax, DWORD PTR _kSavedCity$[ebp]
	movzx	ecx, WORD PTR [eax+66]
	push	ecx
	mov	ecx, DWORD PTR _pkGameplayCity$224072[ebp]
	call	?setPopulation@CvCity@@QAEXH_N@Z	; CvCity::setPopulation

; 711  : 
; 712  : 			if(kSavedCity.GetFlag(CvWorldBuilderMap::City::CITY_PUPPET_STATE))

	mov	edx, DWORD PTR _kSavedCity$[ebp]
	movzx	eax, BYTE PTR [edx+65]
	and	eax, 2
	neg	eax
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN10@SetupCity

; 713  : 			{
; 714  : 				pkGameplayCity->SetOccupied(true);

	push	1
	mov	ecx, DWORD PTR _pkGameplayCity$224072[ebp]
	call	?SetOccupied@CvCity@@QAEX_N@Z		; CvCity::SetOccupied

; 715  : 				pkGameplayCity->SetPuppet(true);

	push	1
	mov	ecx, DWORD PTR _pkGameplayCity$224072[ebp]
	call	?SetPuppet@CvCity@@QAEX_N@Z		; CvCity::SetPuppet
	jmp	SHORT $LN8@SetupCity
$LN10@SetupCity:

; 716  : 			}
; 717  : 			else if(kSavedCity.GetFlag(CvWorldBuilderMap::City::CITY_OCCUPIED))

	mov	edx, DWORD PTR _kSavedCity$[ebp]
	movzx	eax, BYTE PTR [edx+65]
	and	eax, 4
	neg	eax
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN8@SetupCity

; 718  : 			{
; 719  : 				pkGameplayCity->SetOccupied(true);

	push	1
	mov	ecx, DWORD PTR _pkGameplayCity$224072[ebp]
	call	?SetOccupied@CvCity@@QAEX_N@Z		; CvCity::SetOccupied
$LN8@SetupCity:

; 720  : 			}
; 721  : 
; 722  : 			if(kSavedCity.m_uiHealth != kSavedCity.MaxHealth)

	mov	edx, DWORD PTR _kSavedCity$[ebp]
	cmp	DWORD PTR [edx+68], 100000		; 000186a0H
	je	SHORT $LN7@SetupCity

; 723  : 			{
; 724  : 				const int iMaxHitPoints = pkGameplayCity->GetMaxHitPoints();

	mov	ecx, DWORD PTR _pkGameplayCity$224072[ebp]
	call	?GetMaxHitPoints@CvCity@@QBEHXZ		; CvCity::GetMaxHitPoints
	mov	DWORD PTR _iMaxHitPoints$224078[ebp], eax

; 725  : 
; 726  : 				// TODO: Oh no!  It's floating point math!  This may be an issue for multi-player.
; 727  : 				const float fHitPoints = kSavedCity.GetHealthAsFloat() * (float)iMaxHitPoints;

	fild	DWORD PTR _iMaxHitPoints$224078[ebp]
	mov	eax, DWORD PTR _kSavedCity$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	DWORD PTR tv247[ebp], ecx
	mov	DWORD PTR tv247[ebp+4], 0
	fild	QWORD PTR tv247[ebp]
	fdiv	DWORD PTR __real@47c35000
	fmulp	ST(1), ST(0)
	fstp	DWORD PTR _fHitPoints$224079[ebp]

; 728  : 
; 729  : 				// Don't allow the city to be killed by a precision error
; 730  : 				int iHitPoints = (int)fHitPoints;

	cvttss2si edx, DWORD PTR _fHitPoints$224079[ebp]
	mov	DWORD PTR _iHitPoints$224081[ebp], edx

; 731  : 				if(iHitPoints == 0 && kSavedCity.m_uiHealth != 0)

	cmp	DWORD PTR _iHitPoints$224081[ebp], 0
	jne	SHORT $LN6@SetupCity
	mov	eax, DWORD PTR _kSavedCity$[ebp]
	cmp	DWORD PTR [eax+68], 0
	je	SHORT $LN6@SetupCity

; 732  : 					iHitPoints = 1;

	mov	DWORD PTR _iHitPoints$224081[ebp], 1
$LN6@SetupCity:

; 733  : 
; 734  : 				pkGameplayCity->setDamage(iMaxHitPoints - iHitPoints);

	push	0
	mov	ecx, DWORD PTR _iMaxHitPoints$224078[ebp]
	sub	ecx, DWORD PTR _iHitPoints$224081[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkGameplayCity$224072[ebp]
	call	?setDamage@CvCity@@QAEXH_N@Z		; CvCity::setDamage
$LN7@SetupCity:

; 735  : 			}
; 736  : 
; 737  : 			CvCityBuildings* pkCityBuildings = pkGameplayCity->GetCityBuildings();

	mov	ecx, DWORD PTR _pkGameplayCity$224072[ebp]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	DWORD PTR _pkCityBuildings$224084[ebp], eax

; 738  : 			if(pkCityBuildings != NULL)

	cmp	DWORD PTR _pkCityBuildings$224084[ebp], 0
	je	$LN2@SetupCity

; 739  : 			{
; 740  : 				const int iBuildingTypeCount = GC.getNumBuildingInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	mov	DWORD PTR _iBuildingTypeCount$224086[ebp], eax

; 741  : 				for(int iBuilding = 0; iBuilding < iBuildingTypeCount; ++iBuilding)

	mov	DWORD PTR _iBuilding$224087[ebp], 0
	jmp	SHORT $LN4@SetupCity
$LN3@SetupCity:
	mov	edx, DWORD PTR _iBuilding$224087[ebp]
	add	edx, 1
	mov	DWORD PTR _iBuilding$224087[ebp], edx
$LN4@SetupCity:
	mov	eax, DWORD PTR _iBuilding$224087[ebp]
	cmp	eax, DWORD PTR _iBuildingTypeCount$224086[ebp]
	jge	SHORT $LN2@SetupCity

; 742  : 				{
; 743  : 					const BuildingTypes eBuildingType = (BuildingTypes)iBuilding;

	mov	ecx, DWORD PTR _iBuilding$224087[ebp]
	mov	DWORD PTR _eBuildingType$224091[ebp], ecx

; 744  : 					if(kSavedCity.m_kBuildings[iBuilding])

	mov	edx, DWORD PTR _kSavedCity$[ebp]
	add	edx, 72					; 00000048H
	mov	DWORD PTR $T228151[ebp], edx
	cmp	DWORD PTR _iBuilding$224087[ebp], 512	; 00000200H
	jb	SHORT $LN25@SetupCity
	mov	ecx, DWORD PTR $T228151[ebp]
	call	?_Xran@?$bitset@$0CAA@@std@@ABEXXZ	; std::bitset<512>::_Xran
$LN25@SetupCity:
	mov	esi, DWORD PTR _iBuilding$224087[ebp]
	shr	esi, 5
	mov	eax, DWORD PTR _iBuilding$224087[ebp]
	xor	edx, edx
	mov	ecx, 32					; 00000020H
	div	ecx
	mov	eax, 1
	mov	ecx, edx
	shl	eax, cl
	mov	ecx, DWORD PTR $T228151[ebp]
	and	eax, DWORD PTR [ecx+esi*4]
	neg	eax
	sbb	eax, eax
	neg	eax
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@SetupCity

; 745  : 						pkCityBuildings->SetNumRealBuilding(eBuildingType, 1);

	push	1
	mov	eax, DWORD PTR _eBuildingType$224091[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkCityBuildings$224084[ebp]
	call	?SetNumRealBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::SetNumRealBuilding
$LN1@SetupCity:

; 746  : 				}

	jmp	SHORT $LN3@SetupCity
$LN2@SetupCity:

; 747  : 			}
; 748  : 			kPlayer.DoUpdateNextPolicyCost();

	mov	ecx, DWORD PTR _kPlayer$224071[ebp]
	call	?DoUpdateNextPolicyCost@CvPlayer@@QAEXXZ ; CvPlayer::DoUpdateNextPolicyCost
$LN11@SetupCity:

; 749  : 		}
; 750  : 	}
; 751  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?SetupCity@@YAXABUCity@CvWorldBuilderMap@@HH@Z ENDP	; SetupCity
_TEXT	ENDS
PUBLIC	__real@00000000
PUBLIC	??_C@_0BO@OLOFEPN@Picking?5Random?5Unit?5Direction?$AA@ ; `string'
PUBLIC	?SetupUnit@@YAXABUUnit@CvWorldBuilderMap@@HH@Z	; SetupUnit
EXTRN	?setName@CvUnit@@QAEXVCvString@@@Z:PROC		; CvUnit::setName
EXTRN	?setExperience@CvUnit@@QAEXHH@Z:PROC		; CvUnit::setExperience
EXTRN	?setDamage@CvUnit@@QAEHHW4PlayerTypes@@MPBVCvString@@@Z:PROC ; CvUnit::setDamage
EXTRN	?GetMaxHitPoints@CvUnit@@QBEHXZ:PROC		; CvUnit::GetMaxHitPoints
EXTRN	?setMoves@CvUnit@@QAEXH@Z:PROC			; CvUnit::setMoves
EXTRN	?maxMoves@CvUnit@@QBEHXZ:PROC			; CvUnit::maxMoves
EXTRN	?setEmbarked@CvUnit@@QAEX_N@Z:PROC		; CvUnit::setEmbarked
EXTRN	?setHasPromotion@CvUnit@@QAEXW4PromotionTypes@@_N@Z:PROC ; CvUnit::setHasPromotion
EXTRN	?GetEmbarkationPromotion@CvPlayer@@QBE?AW4PromotionTypes@@XZ:PROC ; CvPlayer::GetEmbarkationPromotion
EXTRN	?getMISSION_SLEEP@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_SLEEP
EXTRN	?getMISSION_FORTIFY@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_FORTIFY
EXTRN	?isFortifyable@CvUnit@@QBE_N_N@Z:PROC		; CvUnit::isFortifyable
EXTRN	?initUnit@CvPlayer@@QAEPAVCvUnit@@W4UnitTypes@@HHW4UnitAITypes@@W4DirectionTypes@@_N3HH@Z:PROC ; CvPlayer::initUnit
EXTRN	?getJonRandNum@CvGame@@QAEHHPBD@Z:PROC		; CvGame::getJonRandNum
EXTRN	?GetDefaultUnitAIType@CvUnitEntry@@QBEHXZ:PROC	; CvUnitEntry::GetDefaultUnitAIType
;	COMDAT __real@00000000
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0BO@OLOFEPN@Picking?5Random?5Unit?5Direction?$AA@
CONST	SEGMENT
??_C@_0BO@OLOFEPN@Picking?5Random?5Unit?5Direction?$AA@ DB 'Picking Rando'
	DB	'm Unit Direction', 00H			; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvworldbuildermaploader.cpp
CONST	ENDS
;	COMDAT ?SetupUnit@@YAXABUUnit@CvWorldBuilderMap@@HH@Z
_TEXT	SEGMENT
tv262 = -192						; size = 4
tv294 = -188						; size = 4
tv405 = -184						; size = 8
tv173 = -176						; size = 4
tv154 = -172						; size = 4
tv77 = -168						; size = 4
$T228237 = -164						; size = 4
$T228228 = -158						; size = 2
$T228219 = -156						; size = 4
$T228194 = -84						; size = 4
$T228185 = -80						; size = 4
$T228181 = -76						; size = 4
$T228172 = -72						; size = 4
$T228162 = -68						; size = 4
$T228157 = -64						; size = 4
_pkUnitName$224148 = -60				; size = 4
_ePromotionType$224144 = -56				; size = 4
_iPromotion$224140 = -52				; size = 4
_fHitPoints$224133 = -48				; size = 4
_iHitPoints$224135 = -44				; size = 4
_iMaxHitPoints$224132 = -40				; size = 4
_ePromotionEmbarkation$224130 = -36			; size = 4
_iPromotionTypeCount$224139 = -32			; size = 4
_pkGameplayUnit$224124 = -28				; size = 4
_kPlayer$224123 = -24					; size = 4
_ePlayer$ = -20						; size = 4
_eFacing$ = -16						; size = 4
_pkUnitType$ = -12					; size = 4
_eUnitType$ = -8					; size = 4
_eAIType$ = -4						; size = 4
_kSavedUnit$ = 8					; size = 4
_iPlotX$ = 12						; size = 4
_iPlotY$ = 16						; size = 4
?SetupUnit@@YAXABUUnit@CvWorldBuilderMap@@HH@Z PROC	; SetupUnit, COMDAT

; 754  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	esi

; 755  : 	const PlayerTypes ePlayer = GetPlayerType(kSavedUnit.m_byOwner);

	mov	eax, DWORD PTR _kSavedUnit$[ebp]
	movzx	ecx, BYTE PTR [eax+16]
	push	ecx
	call	?GetPlayerType@@YA?AW4PlayerTypes@@E@Z	; GetPlayerType
	add	esp, 4
	mov	DWORD PTR _ePlayer$[ebp], eax

; 756  : 	UnitTypes eUnitType = (UnitTypes)kSavedUnit.m_byUnitType;

	mov	edx, DWORD PTR _kSavedUnit$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _eUnitType$[ebp], eax

; 757  : 	// Test to see if m_byUnitType is still a byte, if so, if it is 255, then it is really -1 and we must reflect this in the eUnitType
; 758  : 	// The World Builder map format should be changed so the serialization of the unit type is an int.  We are already close to
; 759  : 	// maxing out the byte range as it stands now.
; 760  : 	if (sizeof(kSavedUnit.m_byUnitType) == 1 && kSavedUnit.m_byUnitType == 255)

	xor	ecx, ecx
	je	SHORT $LN26@SetupUnit

; 761  : 	{
; 762  : 		eUnitType = NO_UNIT;

	mov	DWORD PTR _eUnitType$[ebp], -1
$LN26@SetupUnit:

; 763  : 	}
; 764  : 
; 765  : 	UnitAITypes eAIType = NO_UNITAI;

	mov	DWORD PTR _eAIType$[ebp], -1

; 766  : 	const CvUnitEntry* pkUnitType = GC.getUnitInfo(eUnitType);

	mov	edx, DWORD PTR _eUnitType$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	DWORD PTR _pkUnitType$[ebp], eax

; 767  : 	FAssert(pkUnitType); // We should probably be concerned if this unit type isn't valid
; 768  : 	if(pkUnitType != NULL)

	cmp	DWORD PTR _pkUnitType$[ebp], 0
	je	SHORT $LN25@SetupUnit

; 769  : 		eAIType = (UnitAITypes)pkUnitType->GetDefaultUnitAIType();

	mov	ecx, DWORD PTR _pkUnitType$[ebp]
	call	?GetDefaultUnitAIType@CvUnitEntry@@QBEHXZ ; CvUnitEntry::GetDefaultUnitAIType
	mov	DWORD PTR _eAIType$[ebp], eax

; 770  : 	else

	jmp	SHORT $LN24@SetupUnit
$LN25@SetupUnit:

; 771  : 		return;	// The unit type is invalid, we really can't go any further.

	jmp	$LN27@SetupUnit
$LN24@SetupUnit:

; 772  : 
; 773  : 	DirectionTypes eFacing = NO_DIRECTION;

	mov	DWORD PTR _eFacing$[ebp], -1

; 774  : 	switch(kSavedUnit.m_byDirection)

	mov	eax, DWORD PTR _kSavedUnit$[ebp]
	movzx	ecx, BYTE PTR [eax+17]
	mov	DWORD PTR tv77[ebp], ecx
	mov	edx, DWORD PTR tv77[ebp]
	sub	edx, 1
	mov	DWORD PTR tv77[ebp], edx
	cmp	DWORD PTR tv77[ebp], 5
	ja	SHORT $LN15@SetupUnit
	mov	eax, DWORD PTR tv77[ebp]
	jmp	DWORD PTR $LN74@SetupUnit[eax*4]
$LN21@SetupUnit:

; 775  : 	{
; 776  : 	case CvWorldBuilderMap::Unit::DIRECTION_EAST:
; 777  : 		eFacing = DIRECTION_EAST;

	mov	DWORD PTR _eFacing$[ebp], 1

; 778  : 		break;

	jmp	SHORT $LN22@SetupUnit
$LN20@SetupUnit:

; 779  : 
; 780  : 	case CvWorldBuilderMap::Unit::DIRECTION_NORTHEAST:
; 781  : 		eFacing = DIRECTION_NORTHEAST;

	mov	DWORD PTR _eFacing$[ebp], 0

; 782  : 		break;

	jmp	SHORT $LN22@SetupUnit
$LN19@SetupUnit:

; 783  : 
; 784  : 	case CvWorldBuilderMap::Unit::DIRECTION_NORTHWEST:
; 785  : 		eFacing = DIRECTION_NORTHWEST;

	mov	DWORD PTR _eFacing$[ebp], 5

; 786  : 		break;

	jmp	SHORT $LN22@SetupUnit
$LN18@SetupUnit:

; 787  : 
; 788  : 	case CvWorldBuilderMap::Unit::DIRECTION_SOUTHEAST:
; 789  : 		eFacing = DIRECTION_SOUTHEAST;

	mov	DWORD PTR _eFacing$[ebp], 2

; 790  : 		break;

	jmp	SHORT $LN22@SetupUnit
$LN17@SetupUnit:

; 791  : 
; 792  : 	case CvWorldBuilderMap::Unit::DIRECTION_SOUTHWEST:
; 793  : 		eFacing = DIRECTION_SOUTHWEST;

	mov	DWORD PTR _eFacing$[ebp], 3

; 794  : 		break;

	jmp	SHORT $LN22@SetupUnit
$LN16@SetupUnit:

; 795  : 
; 796  : 	case CvWorldBuilderMap::Unit::DIRECTION_WEST:
; 797  : 		eFacing = DIRECTION_WEST;

	mov	DWORD PTR _eFacing$[ebp], 4

; 798  : 		break;

	jmp	SHORT $LN22@SetupUnit
$LN15@SetupUnit:

; 799  : 
; 800  : 	default:
; 801  : 		eFacing = (DirectionTypes)GC.getGame().getJonRandNum(NUM_DIRECTION_TYPES, "Picking Random Unit Direction");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T228162[ebp], ecx
	push	OFFSET ??_C@_0BO@OLOFEPN@Picking?5Random?5Unit?5Direction?$AA@
	push	6
	mov	ecx, DWORD PTR $T228162[ebp]
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	mov	DWORD PTR _eFacing$[ebp], eax
$LN22@SetupUnit:

; 802  : 	}
; 803  : 
; 804  : 	if(ePlayer != NO_PLAYER)

	cmp	DWORD PTR _ePlayer$[ebp], -1
	je	$LN1@SetupUnit

; 805  : 	{
; 806  : 		CvPlayer& kPlayer = GET_PLAYER(ePlayer);

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$224123[ebp], edx

; 807  : 		CvUnit* pkGameplayUnit = kPlayer.initUnit(eUnitType, iPlotX, iPlotY, eAIType, eFacing, false);

	push	0
	push	0
	push	1
	push	0
	mov	eax, DWORD PTR _eFacing$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eAIType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iPlotY$[ebp]
	push	edx
	mov	eax, DWORD PTR _iPlotX$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eUnitType$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kPlayer$224123[ebp]
	call	?initUnit@CvPlayer@@QAEPAVCvUnit@@W4UnitTypes@@HHW4UnitAITypes@@W4DirectionTypes@@_N3HH@Z ; CvPlayer::initUnit
	mov	DWORD PTR _pkGameplayUnit$224124[ebp], eax

; 808  : 		if(pkGameplayUnit != NULL)

	cmp	DWORD PTR _pkGameplayUnit$224124[ebp], 0
	je	$LN1@SetupUnit

; 809  : 		{
; 810  : 			if(kSavedUnit.GetFlag(CvWorldBuilderMap::Unit::UNIT_FORTIFIED))

	mov	edx, DWORD PTR _kSavedUnit$[ebp]
	movzx	eax, BYTE PTR [edx+18]
	and	eax, 1
	neg	eax
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	je	$LN10@SetupUnit

; 811  : 			{
; 812  : 				if(pkGameplayUnit->isFortifyable(true))

	push	1
	mov	ecx, DWORD PTR _pkGameplayUnit$224124[ebp]
	call	?isFortifyable@CvUnit@@QBE_N_N@Z	; CvUnit::isFortifyable
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN11@SetupUnit

; 813  : 					gDLL->sendPushMission(pkGameplayUnit->GetID(), CvTypes::getMISSION_FORTIFY(), 0, 0, 0, false);

	mov	eax, DWORD PTR $T228172[ebp]
	mov	DWORD PTR tv154[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv154[ebp], ecx
	mov	edx, DWORD PTR _pkGameplayUnit$224124[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T228181[ebp], eax
	push	0
	push	0
	push	0
	push	0
	call	?getMISSION_FORTIFY@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_FORTIFY
	push	eax
	mov	ecx, DWORD PTR $T228181[ebp]
	push	ecx
	mov	edx, DWORD PTR tv154[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv154[ebp]
	mov	edx, DWORD PTR [eax+152]
	call	edx

; 814  : 				else

	jmp	SHORT $LN10@SetupUnit
$LN11@SetupUnit:

; 815  : 					gDLL->sendPushMission(pkGameplayUnit->GetID(), CvTypes::getMISSION_SLEEP(), 0, 0, 0, false);

	mov	eax, DWORD PTR $T228185[ebp]
	mov	DWORD PTR tv173[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv173[ebp], ecx
	mov	edx, DWORD PTR _pkGameplayUnit$224124[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T228194[ebp], eax
	push	0
	push	0
	push	0
	push	0
	call	?getMISSION_SLEEP@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SLEEP
	push	eax
	mov	ecx, DWORD PTR $T228194[ebp]
	push	ecx
	mov	edx, DWORD PTR tv173[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv173[ebp]
	mov	edx, DWORD PTR [eax+152]
	call	edx
$LN10@SetupUnit:

; 816  : 			}
; 817  : 
; 818  : 			if(kSavedUnit.GetFlag(CvWorldBuilderMap::Unit::UNIT_EMBARKED))

	mov	eax, DWORD PTR _kSavedUnit$[ebp]
	movzx	ecx, BYTE PTR [eax+18]
	and	ecx, 2
	neg	ecx
	sbb	ecx, ecx
	neg	ecx
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN9@SetupUnit

; 819  : 			{
; 820  : 				const PromotionTypes ePromotionEmbarkation = kPlayer.GetEmbarkationPromotion();

	mov	ecx, DWORD PTR _kPlayer$224123[ebp]
	call	?GetEmbarkationPromotion@CvPlayer@@QBE?AW4PromotionTypes@@XZ ; CvPlayer::GetEmbarkationPromotion
	mov	DWORD PTR _ePromotionEmbarkation$224130[ebp], eax

; 821  : 				pkGameplayUnit->setHasPromotion(ePromotionEmbarkation, true);

	push	1
	mov	eax, DWORD PTR _ePromotionEmbarkation$224130[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkGameplayUnit$224124[ebp]
	call	?setHasPromotion@CvUnit@@QAEXW4PromotionTypes@@_N@Z ; CvUnit::setHasPromotion

; 822  : 				pkGameplayUnit->setEmbarked(true);

	push	1
	mov	ecx, DWORD PTR _pkGameplayUnit$224124[ebp]
	call	?setEmbarked@CvUnit@@QAEX_N@Z		; CvUnit::setEmbarked

; 823  : 				pkGameplayUnit->setMoves(pkGameplayUnit->maxMoves());

	mov	ecx, DWORD PTR _pkGameplayUnit$224124[ebp]
	call	?maxMoves@CvUnit@@QBEHXZ		; CvUnit::maxMoves
	push	eax
	mov	ecx, DWORD PTR _pkGameplayUnit$224124[ebp]
	call	?setMoves@CvUnit@@QAEXH@Z		; CvUnit::setMoves
$LN9@SetupUnit:

; 824  : 			}
; 825  : 
; 826  : 			if(kSavedUnit.m_uiHealth != kSavedUnit.MaxHealth)

	mov	ecx, DWORD PTR _kSavedUnit$[ebp]
	cmp	DWORD PTR [ecx+8], 100000		; 000186a0H
	je	SHORT $LN8@SetupUnit

; 827  : 			{
; 828  : 				const int iMaxHitPoints = pkGameplayUnit->GetMaxHitPoints();

	mov	ecx, DWORD PTR _pkGameplayUnit$224124[ebp]
	call	?GetMaxHitPoints@CvUnit@@QBEHXZ		; CvUnit::GetMaxHitPoints
	mov	DWORD PTR _iMaxHitPoints$224132[ebp], eax

; 829  : 
; 830  : 				// TODO: Oh no!  It's floating point math!  This may be an issue for multi-player.
; 831  : 				const float fHitPoints = kSavedUnit.GetHealthAsFloat() * (float)iMaxHitPoints;

	fild	DWORD PTR _iMaxHitPoints$224132[ebp]
	mov	edx, DWORD PTR _kSavedUnit$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR tv405[ebp], eax
	mov	DWORD PTR tv405[ebp+4], 0
	fild	QWORD PTR tv405[ebp]
	fdiv	DWORD PTR __real@47c35000
	fmulp	ST(1), ST(0)
	fstp	DWORD PTR _fHitPoints$224133[ebp]

; 832  : 
; 833  : 				// Don't allow the unit to be killed by a precision error
; 834  : 				int iHitPoints = (int)fHitPoints;

	cvttss2si ecx, DWORD PTR _fHitPoints$224133[ebp]
	mov	DWORD PTR _iHitPoints$224135[ebp], ecx

; 835  : 				if(iHitPoints == 0 && kSavedUnit.m_uiHealth != 0)

	cmp	DWORD PTR _iHitPoints$224135[ebp], 0
	jne	SHORT $LN7@SetupUnit
	mov	edx, DWORD PTR _kSavedUnit$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN7@SetupUnit

; 836  : 					iHitPoints = 1;

	mov	DWORD PTR _iHitPoints$224135[ebp], 1
$LN7@SetupUnit:

; 837  : 
; 838  : 				pkGameplayUnit->setDamage(iMaxHitPoints - iHitPoints);

	push	0
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	-1
	mov	eax, DWORD PTR _iMaxHitPoints$224132[ebp]
	sub	eax, DWORD PTR _iHitPoints$224135[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkGameplayUnit$224124[ebp]
	call	?setDamage@CvUnit@@QAEHHW4PlayerTypes@@MPBVCvString@@@Z ; CvUnit::setDamage
$LN8@SetupUnit:

; 839  : 			}
; 840  : 
; 841  : 			pkGameplayUnit->setExperience((int)kSavedUnit.m_uiExperience);

	push	-1
	mov	ecx, DWORD PTR _kSavedUnit$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _pkGameplayUnit$224124[ebp]
	call	?setExperience@CvUnit@@QAEXHH@Z		; CvUnit::setExperience

; 842  : 
; 843  : 			const int iPromotionTypeCount = GC.getNumPromotionInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumPromotionInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPromotionInfos
	mov	DWORD PTR _iPromotionTypeCount$224139[ebp], eax

; 844  : 			for(int iPromotion = 0; iPromotion < iPromotionTypeCount; ++iPromotion)

	mov	DWORD PTR _iPromotion$224140[ebp], 0
	jmp	SHORT $LN6@SetupUnit
$LN5@SetupUnit:
	mov	eax, DWORD PTR _iPromotion$224140[ebp]
	add	eax, 1
	mov	DWORD PTR _iPromotion$224140[ebp], eax
$LN6@SetupUnit:
	mov	ecx, DWORD PTR _iPromotion$224140[ebp]
	cmp	ecx, DWORD PTR _iPromotionTypeCount$224139[ebp]
	jge	SHORT $LN4@SetupUnit

; 845  : 			{
; 846  : 				const PromotionTypes ePromotionType = (PromotionTypes)iPromotion;

	mov	edx, DWORD PTR _iPromotion$224140[ebp]
	mov	DWORD PTR _ePromotionType$224144[ebp], edx

; 847  : 				if(kSavedUnit.m_kPromotions[iPromotion])

	mov	eax, DWORD PTR _kSavedUnit$[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR $T228219[ebp], eax
	cmp	DWORD PTR _iPromotion$224140[ebp], 512	; 00000200H
	jb	SHORT $LN54@SetupUnit
	mov	ecx, DWORD PTR $T228219[ebp]
	call	?_Xran@?$bitset@$0CAA@@std@@ABEXXZ	; std::bitset<512>::_Xran
$LN54@SetupUnit:
	mov	esi, DWORD PTR _iPromotion$224140[ebp]
	shr	esi, 5
	mov	eax, DWORD PTR _iPromotion$224140[ebp]
	xor	edx, edx
	mov	ecx, 32					; 00000020H
	div	ecx
	mov	eax, 1
	mov	ecx, edx
	shl	eax, cl
	mov	ecx, DWORD PTR $T228219[ebp]
	and	eax, DWORD PTR [ecx+esi*4]
	neg	eax
	sbb	eax, eax
	neg	eax
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@SetupUnit

; 848  : 					pkGameplayUnit->setHasPromotion(ePromotionType, true);

	push	1
	mov	eax, DWORD PTR _ePromotionType$224144[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkGameplayUnit$224124[ebp]
	call	?setHasPromotion@CvUnit@@QAEXW4PromotionTypes@@_N@Z ; CvUnit::setHasPromotion
$LN3@SetupUnit:

; 849  : 			}

	jmp	SHORT $LN5@SetupUnit
$LN4@SetupUnit:

; 850  : 
; 851  : 			if(kSavedUnit.m_hCustomName.Valid())

	mov	ecx, DWORD PTR _kSavedUnit$[ebp]
	movzx	edx, WORD PTR [ecx+2]
	cmp	edx, 65535				; 0000ffffH
	setne	al
	movzx	ecx, al
	test	ecx, ecx
	je	$LN1@SetupUnit

; 852  : 			{
; 853  : 				CvWorldBuilderMap::UnitName* pkUnitName = sg_kSave.m_kUnitNames[kSavedUnit.m_hCustomName];

	mov	edx, DWORD PTR _kSavedUnit$[ebp]
	mov	ax, WORD PTR [edx+2]
	mov	WORD PTR $T228228[ebp], ax
	movzx	ecx, WORD PTR $T228228[ebp]
	cmp	ecx, DWORD PTR _sg_kSave+2872
	jae	SHORT $LN66@SetupUnit
	movzx	edx, WORD PTR $T228228[ebp]
	shl	edx, 6
	add	edx, DWORD PTR _sg_kSave+2864
	mov	DWORD PTR _pkUnitName$224148[ebp], edx
	jmp	SHORT $LN65@SetupUnit
	jmp	SHORT $LN65@SetupUnit
$LN66@SetupUnit:
	mov	DWORD PTR _pkUnitName$224148[ebp], 0
$LN65@SetupUnit:

; 854  : 				if(pkUnitName != NULL)

	cmp	DWORD PTR _pkUnitName$224148[ebp], 0
	je	SHORT $LN1@SetupUnit

; 855  : 				{
; 856  : 					pkGameplayUnit->setName(pkUnitName->m_szText);

	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T228157[ebp], esp
	mov	DWORD PTR $T228237[ebp], eax
	cmp	DWORD PTR _pkUnitName$224148[ebp], 0
	je	SHORT $LN71@SetupUnit
	mov	ecx, DWORD PTR _pkUnitName$224148[ebp]
	mov	DWORD PTR tv294[ebp], ecx
	jmp	SHORT $LN72@SetupUnit
$LN71@SetupUnit:
	mov	DWORD PTR tv294[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN72@SetupUnit:
	mov	edx, DWORD PTR tv294[ebp]
	push	edx
	mov	ecx, DWORD PTR $T228237[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR $T228237[ebp]
	mov	DWORD PTR tv262[ebp], eax
	mov	ecx, DWORD PTR _pkGameplayUnit$224124[ebp]
	call	?setName@CvUnit@@QAEXVCvString@@@Z	; CvUnit::setName
$LN1@SetupUnit:
$LN27@SetupUnit:

; 857  : 				}
; 858  : 			}
; 859  : 		}
; 860  : 	}
; 861  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN74@SetupUnit:
	DD	$LN20@SetupUnit
	DD	$LN21@SetupUnit
	DD	$LN18@SetupUnit
	DD	$LN17@SetupUnit
	DD	$LN16@SetupUnit
	DD	$LN19@SetupUnit
?SetupUnit@@YAXABUUnit@CvWorldBuilderMap@@HH@Z ENDP	; SetupUnit
_TEXT	ENDS
PUBLIC	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ		; CvPlot::getPlotCity
PUBLIC	?GetCity@@YAPBVCvCity@@W4PlayerTypes@@PBVCvPlot@@@Z ; GetCity
; Function compile flags: /Odtp
;	COMDAT ?GetCity@@YAPBVCvCity@@W4PlayerTypes@@PBVCvPlot@@@Z
_TEXT	SEGMENT
$T228256 = -12						; size = 4
_pkCity$224156 = -4					; size = 4
_ePlayer$ = 8						; size = 4
_pkPlot$ = 12						; size = 4
?GetCity@@YAPBVCvCity@@W4PlayerTypes@@PBVCvPlot@@@Z PROC ; GetCity, COMDAT

; 864  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 865  : 	if(pkPlot != NULL)

	cmp	DWORD PTR _pkPlot$[ebp], 0
	je	SHORT $LN2@GetCity

; 866  : 	{
; 867  : 		const CvCity* pkCity = pkPlot->getPlotCity();

	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pkCity$224156[ebp], eax

; 868  : 		if(pkCity != NULL && pkCity->getOwner() == ePlayer)

	cmp	DWORD PTR _pkCity$224156[ebp], 0
	je	SHORT $LN2@GetCity
	mov	eax, DWORD PTR _pkCity$224156[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T228256[ebp], ecx
	mov	edx, DWORD PTR $T228256[ebp]
	cmp	edx, DWORD PTR _ePlayer$[ebp]
	jne	SHORT $LN2@GetCity

; 869  : 			return pkCity;

	mov	eax, DWORD PTR _pkCity$224156[ebp]
	jmp	SHORT $LN3@GetCity
$LN2@GetCity:

; 870  : 	}
; 871  : 
; 872  : 	return NULL;

	xor	eax, eax
$LN3@GetCity:

; 873  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCity@@YAPBVCvCity@@W4PlayerTypes@@PBVCvPlot@@@Z ENDP ; GetCity
_TEXT	ENDS
PUBLIC	?FindClosestCity@@YAPBVCvCity@@W4PlayerTypes@@ABVCvPlot@@@Z ; FindClosestCity
; Function compile flags: /Odtp
;	COMDAT ?FindClosestCity@@YAPBVCvCity@@W4PlayerTypes@@ABVCvPlot@@@Z
_TEXT	SEGMENT
tv794 = -624						; size = 4
tv809 = -620						; size = 4
tv722 = -616						; size = 4
tv769 = -612						; size = 4
tv682 = -608						; size = 4
tv697 = -604						; size = 4
tv642 = -600						; size = 4
tv657 = -596						; size = 4
tv570 = -592						; size = 4
tv617 = -588						; size = 4
tv530 = -584						; size = 4
tv545 = -580						; size = 4
tv490 = -576						; size = 4
tv505 = -572						; size = 4
tv450 = -568						; size = 4
tv465 = -564						; size = 4
tv378 = -560						; size = 4
tv393 = -556						; size = 4
tv338 = -552						; size = 4
tv353 = -548						; size = 4
$T229294 = -544						; size = 4
$T229249 = -540						; size = 4
$T229236 = -536						; size = 4
$T229232 = -532						; size = 4
$T229218 = -528						; size = 4
$T229214 = -521						; size = 1
$T229203 = -520						; size = 4
$T229199 = -513						; size = 1
_iMapY$229258 = -512					; size = 4
_iMapX$229257 = -508					; size = 4
$T229192 = -504						; size = 4
$T229147 = -500						; size = 4
$T229134 = -496						; size = 4
$T229130 = -492						; size = 4
$T229116 = -488						; size = 4
$T229112 = -481						; size = 1
$T229101 = -480						; size = 4
$T229097 = -473						; size = 1
_iMapY$229160 = -472					; size = 4
_iMapX$229158 = -468					; size = 4
$T229090 = -464						; size = 4
$T229045 = -460						; size = 4
$T229032 = -456						; size = 4
$T229028 = -452						; size = 4
$T229014 = -448						; size = 4
$T229010 = -441						; size = 1
$T228999 = -440						; size = 4
$T228995 = -433						; size = 1
_iMapY$229089 = -432					; size = 4
_iMapX$229088 = -428					; size = 4
$T228988 = -424						; size = 4
$T228943 = -420						; size = 4
$T228930 = -416						; size = 4
$T228926 = -412						; size = 4
$T228912 = -408						; size = 4
$T228908 = -401						; size = 1
$T228897 = -400						; size = 4
$T228893 = -393						; size = 1
_iMapY$228987 = -392					; size = 4
_iMapX$228986 = -388					; size = 4
$T228886 = -384						; size = 4
$T228841 = -380						; size = 4
$T228828 = -376						; size = 4
$T228824 = -372						; size = 4
$T228810 = -368						; size = 4
$T228806 = -361						; size = 1
$T228795 = -360						; size = 4
$T228791 = -353						; size = 1
_iMapY$228885 = -352					; size = 4
_iMapX$228884 = -348					; size = 4
$T228784 = -344						; size = 4
$T228739 = -340						; size = 4
$T228726 = -336						; size = 4
$T228722 = -332						; size = 4
$T228708 = -328						; size = 4
$T228704 = -321						; size = 1
$T228693 = -320						; size = 4
$T228689 = -313						; size = 1
_iMapY$228783 = -312					; size = 4
_iMapX$228782 = -308					; size = 4
$T228638 = -304						; size = 4
$T228625 = -300						; size = 4
$T228621 = -296						; size = 4
$T228607 = -292						; size = 4
$T228603 = -285						; size = 1
$T228592 = -284						; size = 4
$T228588 = -277						; size = 1
_iMapY$228682 = -276					; size = 4
_iMapX$228681 = -272					; size = 4
$T228581 = -268						; size = 4
$T228536 = -264						; size = 4
$T228523 = -260						; size = 4
$T228519 = -256						; size = 4
$T228505 = -252						; size = 4
$T228501 = -245						; size = 1
$T228490 = -244						; size = 4
$T228486 = -237						; size = 1
_iMapY$228580 = -236					; size = 4
_iMapX$228579 = -232					; size = 4
$T228435 = -228						; size = 4
$T228422 = -224						; size = 4
$T228418 = -220						; size = 4
$T228404 = -216						; size = 4
$T228400 = -209						; size = 1
$T228389 = -208						; size = 4
$T228385 = -201						; size = 1
_iMapY$228479 = -200					; size = 4
_iMapX$228478 = -196					; size = 4
$T228378 = -192						; size = 4
$T228333 = -188						; size = 4
$T228320 = -184						; size = 4
$T228316 = -180						; size = 4
$T228302 = -176						; size = 4
$T228298 = -169						; size = 1
$T228287 = -168						; size = 4
$T228283 = -161						; size = 1
_iMapY$228342 = -160					; size = 4
_iMapX$228341 = -156					; size = 4
_pkCity$224263 = -152					; size = 4
_pkTestPlot$224262 = -148				; size = 4
_pkCity$224259 = -144					; size = 4
_pkTestPlot$224258 = -140				; size = 4
_iX$224244 = -136					; size = 4
_iPlot$224240 = -132					; size = 4
_iRowWidth$224239 = -128				; size = 4
_pkCity$224237 = -124					; size = 4
_pkTestPlot$224236 = -120				; size = 4
_pkCity$224233 = -116					; size = 4
_pkTestPlot$224232 = -112				; size = 4
_iX$224223 = -108					; size = 4
_pkCity$224221 = -104					; size = 4
_pkTestPlot$224220 = -100				; size = 4
_pkCity$224217 = -96					; size = 4
_pkTestPlot$224216 = -92				; size = 4
_iX$224207 = -88					; size = 4
_iRowWidth$224206 = -84					; size = 4
_iRow$224202 = -80					; size = 4
_iX$224194 = -76					; size = 4
_pkCity$224199 = -72					; size = 4
_pkTestPlot$224198 = -68				; size = 4
_pkCity$224190 = -64					; size = 4
_pkTestPlot$224189 = -60				; size = 4
_iX$224181 = -56					; size = 4
_pkCity$224186 = -52					; size = 4
_pkTestPlot$224185 = -48				; size = 4
_pkCity$224177 = -44					; size = 4
_pkTestPlot$224176 = -40				; size = 4
_iRowOffset$224201 = -36				; size = 4
_iDist$224170 = -32					; size = 4
_pkPlotCity$224162 = -28				; size = 4
_kMap$ = -24						; size = 4
_iMapWidth$ = -20					; size = 4
_iPlotY$ = -16						; size = 4
_iMapHeight$ = -12					; size = 4
_iPlotX$ = -8						; size = 4
_bWorldWrap$ = -1					; size = 1
_ePlayer$ = 8						; size = 4
_kPlot$ = 12						; size = 4
?FindClosestCity@@YAPBVCvCity@@W4PlayerTypes@@ABVCvPlot@@@Z PROC ; FindClosestCity, COMDAT

; 876  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 624				; 00000270H

; 877  : 	{
; 878  : 		const CvCity* pkPlotCity = GetCity(ePlayer, &kPlot);

	mov	eax, DWORD PTR _kPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ePlayer$[ebp]
	push	ecx
	call	?GetCity@@YAPBVCvCity@@W4PlayerTypes@@PBVCvPlot@@@Z ; GetCity
	add	esp, 8
	mov	DWORD PTR _pkPlotCity$224162[ebp], eax

; 879  : 		if(pkPlotCity != NULL)

	cmp	DWORD PTR _pkPlotCity$224162[ebp], 0
	je	SHORT $LN63@FindCloses

; 880  : 			return pkPlotCity;

	mov	eax, DWORD PTR _pkPlotCity$224162[ebp]
	jmp	$LN64@FindCloses
$LN63@FindCloses:

; 881  : 	}
; 882  : 
; 883  : 	const CvMap& kMap = GC.getMap();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], edx

; 884  : 
; 885  : 	const int iPlotX = kPlot.getX();

	mov	eax, DWORD PTR _kPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR _iPlotX$[ebp], ecx

; 886  : 	const int iPlotY = kPlot.getY();

	mov	edx, DWORD PTR _kPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR _iPlotY$[ebp], eax

; 887  : 
; 888  : 	const int iMapHeight = kMap.getGridHeight();

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR _iMapHeight$[ebp], edx

; 889  : 	const int iMapWidth  = kMap.getGridWidth();

	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR _iMapWidth$[ebp], ecx

; 890  : 
; 891  : 	const bool bWorldWrap = kMap.isWrapX();

	mov	edx, DWORD PTR _kMap$[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR _bWorldWrap$[ebp], al

; 892  : 
; 893  : 	// Do a search radiating from the search plot
; 894  : 	for(int iDist = 1; iDist < iMapHeight || iDist < iMapWidth; ++iDist)

	mov	DWORD PTR _iDist$224170[ebp], 1
	jmp	SHORT $LN62@FindCloses
$LN61@FindCloses:
	mov	ecx, DWORD PTR _iDist$224170[ebp]
	add	ecx, 1
	mov	DWORD PTR _iDist$224170[ebp], ecx
$LN62@FindCloses:
	mov	edx, DWORD PTR _iDist$224170[ebp]
	cmp	edx, DWORD PTR _iMapHeight$[ebp]
	jl	SHORT $LN59@FindCloses
	mov	eax, DWORD PTR _iDist$224170[ebp]
	cmp	eax, DWORD PTR _iMapWidth$[ebp]
	jge	$LN60@FindCloses
$LN59@FindCloses:

; 895  : 	{
; 896  : 		// Center Row
; 897  : 		if(iPlotX - iDist >= 0)

	mov	ecx, DWORD PTR _iPlotX$[ebp]
	sub	ecx, DWORD PTR _iDist$224170[ebp]
	js	$LN58@FindCloses

; 898  : 		{
; 899  : 			const CvPlot* pkTestPlot = kMap.plot(iPlotX - iDist, iPlotY);

	mov	edx, DWORD PTR _iPlotX$[ebp]
	sub	edx, DWORD PTR _iDist$224170[ebp]
	mov	DWORD PTR $T228378[ebp], edx
	cmp	DWORD PTR $T228378[ebp], -2147483647	; 80000001H
	je	SHORT $LN78@FindCloses
	cmp	DWORD PTR _iPlotY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN79@FindCloses
$LN78@FindCloses:
	mov	DWORD PTR _pkTestPlot$224176[ebp], 0
	jmp	$LN80@FindCloses
$LN79@FindCloses:
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	cl, BYTE PTR [eax+4056]
	mov	BYTE PTR $T228283[ebp], cl
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T228287[ebp], eax
	movzx	ecx, BYTE PTR $T228283[ebp]
	test	ecx, ecx
	je	SHORT $LN91@FindCloses
	cmp	DWORD PTR $T228378[ebp], 0
	jge	SHORT $LN90@FindCloses
	mov	eax, DWORD PTR $T228378[ebp]
	cdq
	idiv	DWORD PTR $T228287[ebp]
	add	edx, DWORD PTR $T228287[ebp]
	mov	DWORD PTR _iMapX$228341[ebp], edx
	jmp	SHORT $LN92@FindCloses
	jmp	SHORT $LN91@FindCloses
$LN90@FindCloses:
	mov	edx, DWORD PTR $T228378[ebp]
	cmp	edx, DWORD PTR $T228287[ebp]
	jl	SHORT $LN91@FindCloses
	mov	eax, DWORD PTR $T228378[ebp]
	cdq
	idiv	DWORD PTR $T228287[ebp]
	mov	DWORD PTR _iMapX$228341[ebp], edx
	jmp	SHORT $LN92@FindCloses
$LN91@FindCloses:
	mov	eax, DWORD PTR $T228378[ebp]
	mov	DWORD PTR _iMapX$228341[ebp], eax
$LN92@FindCloses:
	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T228298[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T228302[ebp], ecx
	movzx	edx, BYTE PTR $T228298[ebp]
	test	edx, edx
	je	SHORT $LN101@FindCloses
	cmp	DWORD PTR _iPlotY$[ebp], 0
	jge	SHORT $LN100@FindCloses
	mov	eax, DWORD PTR _iPlotY$[ebp]
	cdq
	idiv	DWORD PTR $T228302[ebp]
	add	edx, DWORD PTR $T228302[ebp]
	mov	DWORD PTR _iMapY$228342[ebp], edx
	jmp	SHORT $LN102@FindCloses
	jmp	SHORT $LN101@FindCloses
$LN100@FindCloses:
	mov	eax, DWORD PTR _iPlotY$[ebp]
	cmp	eax, DWORD PTR $T228302[ebp]
	jl	SHORT $LN101@FindCloses
	mov	eax, DWORD PTR _iPlotY$[ebp]
	cdq
	idiv	DWORD PTR $T228302[ebp]
	mov	DWORD PTR _iMapY$228342[ebp], edx
	jmp	SHORT $LN102@FindCloses
$LN101@FindCloses:
	mov	ecx, DWORD PTR _iPlotY$[ebp]
	mov	DWORD PTR _iMapY$228342[ebp], ecx
$LN102@FindCloses:
	cmp	DWORD PTR _iMapX$228341[ebp], 0
	jl	SHORT $LN106@FindCloses
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T228316[ebp], eax
	mov	ecx, DWORD PTR _iMapX$228341[ebp]
	cmp	ecx, DWORD PTR $T228316[ebp]
	jge	SHORT $LN106@FindCloses
	cmp	DWORD PTR _iMapY$228342[ebp], 0
	jl	SHORT $LN106@FindCloses
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T228320[ebp], eax
	mov	ecx, DWORD PTR _iMapY$228342[ebp]
	cmp	ecx, DWORD PTR $T228320[ebp]
	jge	SHORT $LN106@FindCloses
	mov	DWORD PTR tv353[ebp], 1
	jmp	SHORT $LN104@FindCloses
$LN106@FindCloses:
	mov	DWORD PTR tv353[ebp], 0
$LN104@FindCloses:
	cmp	DWORD PTR tv353[ebp], 0
	je	SHORT $LN82@FindCloses
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T228333[ebp], eax
	mov	ecx, DWORD PTR _iMapY$228342[ebp]
	imul	ecx, DWORD PTR $T228333[ebp]
	add	ecx, DWORD PTR _iMapX$228341[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _kMap$[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv338[ebp], ecx
	jmp	SHORT $LN83@FindCloses
$LN82@FindCloses:
	mov	DWORD PTR tv338[ebp], 0
$LN83@FindCloses:
	mov	eax, DWORD PTR tv338[ebp]
	mov	DWORD PTR _pkTestPlot$224176[ebp], eax
$LN80@FindCloses:

; 900  : 			const CvCity* pkCity = GetCity(ePlayer, pkTestPlot);

	mov	ecx, DWORD PTR _pkTestPlot$224176[ebp]
	push	ecx
	mov	edx, DWORD PTR _ePlayer$[ebp]
	push	edx
	call	?GetCity@@YAPBVCvCity@@W4PlayerTypes@@PBVCvPlot@@@Z ; GetCity
	add	esp, 8
	mov	DWORD PTR _pkCity$224177[ebp], eax

; 901  : 			if(pkCity) return pkCity;

	cmp	DWORD PTR _pkCity$224177[ebp], 0
	je	SHORT $LN57@FindCloses
	mov	eax, DWORD PTR _pkCity$224177[ebp]
	jmp	$LN64@FindCloses
$LN57@FindCloses:

; 902  : 		}

	jmp	$LN56@FindCloses
$LN58@FindCloses:

; 903  : 		else if(bWorldWrap)

	movzx	eax, BYTE PTR _bWorldWrap$[ebp]
	test	eax, eax
	je	$LN56@FindCloses

; 904  : 		{
; 905  : 			int iX = iPlotX - iDist;

	mov	ecx, DWORD PTR _iPlotX$[ebp]
	sub	ecx, DWORD PTR _iDist$224170[ebp]
	mov	DWORD PTR _iX$224181[ebp], ecx
$LN54@FindCloses:

; 906  : 			while(iX < 0) iX += iMapWidth;

	cmp	DWORD PTR _iX$224181[ebp], 0
	jge	SHORT $LN53@FindCloses
	mov	edx, DWORD PTR _iX$224181[ebp]
	add	edx, DWORD PTR _iMapWidth$[ebp]
	mov	DWORD PTR _iX$224181[ebp], edx
	jmp	SHORT $LN54@FindCloses
$LN53@FindCloses:

; 907  : 
; 908  : 			const CvPlot* pkTestPlot = kMap.plot(iX, iPlotY);

	cmp	DWORD PTR _iX$224181[ebp], -2147483647	; 80000001H
	je	SHORT $LN116@FindCloses
	cmp	DWORD PTR _iPlotY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN117@FindCloses
$LN116@FindCloses:
	mov	DWORD PTR _pkTestPlot$224185[ebp], 0
	jmp	$LN118@FindCloses
$LN117@FindCloses:
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	cl, BYTE PTR [eax+4056]
	mov	BYTE PTR $T228385[ebp], cl
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T228389[ebp], eax
	movzx	ecx, BYTE PTR $T228385[ebp]
	test	ecx, ecx
	je	SHORT $LN129@FindCloses
	cmp	DWORD PTR _iX$224181[ebp], 0
	jge	SHORT $LN128@FindCloses
	mov	eax, DWORD PTR _iX$224181[ebp]
	cdq
	idiv	DWORD PTR $T228389[ebp]
	add	edx, DWORD PTR $T228389[ebp]
	mov	DWORD PTR _iMapX$228478[ebp], edx
	jmp	SHORT $LN130@FindCloses
	jmp	SHORT $LN129@FindCloses
$LN128@FindCloses:
	mov	edx, DWORD PTR _iX$224181[ebp]
	cmp	edx, DWORD PTR $T228389[ebp]
	jl	SHORT $LN129@FindCloses
	mov	eax, DWORD PTR _iX$224181[ebp]
	cdq
	idiv	DWORD PTR $T228389[ebp]
	mov	DWORD PTR _iMapX$228478[ebp], edx
	jmp	SHORT $LN130@FindCloses
$LN129@FindCloses:
	mov	eax, DWORD PTR _iX$224181[ebp]
	mov	DWORD PTR _iMapX$228478[ebp], eax
$LN130@FindCloses:
	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T228400[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T228404[ebp], ecx
	movzx	edx, BYTE PTR $T228400[ebp]
	test	edx, edx
	je	SHORT $LN139@FindCloses
	cmp	DWORD PTR _iPlotY$[ebp], 0
	jge	SHORT $LN138@FindCloses
	mov	eax, DWORD PTR _iPlotY$[ebp]
	cdq
	idiv	DWORD PTR $T228404[ebp]
	add	edx, DWORD PTR $T228404[ebp]
	mov	DWORD PTR _iMapY$228479[ebp], edx
	jmp	SHORT $LN140@FindCloses
	jmp	SHORT $LN139@FindCloses
$LN138@FindCloses:
	mov	eax, DWORD PTR _iPlotY$[ebp]
	cmp	eax, DWORD PTR $T228404[ebp]
	jl	SHORT $LN139@FindCloses
	mov	eax, DWORD PTR _iPlotY$[ebp]
	cdq
	idiv	DWORD PTR $T228404[ebp]
	mov	DWORD PTR _iMapY$228479[ebp], edx
	jmp	SHORT $LN140@FindCloses
$LN139@FindCloses:
	mov	ecx, DWORD PTR _iPlotY$[ebp]
	mov	DWORD PTR _iMapY$228479[ebp], ecx
$LN140@FindCloses:
	cmp	DWORD PTR _iMapX$228478[ebp], 0
	jl	SHORT $LN144@FindCloses
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T228418[ebp], eax
	mov	ecx, DWORD PTR _iMapX$228478[ebp]
	cmp	ecx, DWORD PTR $T228418[ebp]
	jge	SHORT $LN144@FindCloses
	cmp	DWORD PTR _iMapY$228479[ebp], 0
	jl	SHORT $LN144@FindCloses
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T228422[ebp], eax
	mov	ecx, DWORD PTR _iMapY$228479[ebp]
	cmp	ecx, DWORD PTR $T228422[ebp]
	jge	SHORT $LN144@FindCloses
	mov	DWORD PTR tv393[ebp], 1
	jmp	SHORT $LN142@FindCloses
$LN144@FindCloses:
	mov	DWORD PTR tv393[ebp], 0
$LN142@FindCloses:
	cmp	DWORD PTR tv393[ebp], 0
	je	SHORT $LN120@FindCloses
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T228435[ebp], eax
	mov	ecx, DWORD PTR _iMapY$228479[ebp]
	imul	ecx, DWORD PTR $T228435[ebp]
	add	ecx, DWORD PTR _iMapX$228478[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _kMap$[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv378[ebp], ecx
	jmp	SHORT $LN121@FindCloses
$LN120@FindCloses:
	mov	DWORD PTR tv378[ebp], 0
$LN121@FindCloses:
	mov	eax, DWORD PTR tv378[ebp]
	mov	DWORD PTR _pkTestPlot$224185[ebp], eax
$LN118@FindCloses:

; 909  : 			const CvCity* pkCity = GetCity(ePlayer, pkTestPlot);

	mov	ecx, DWORD PTR _pkTestPlot$224185[ebp]
	push	ecx
	mov	edx, DWORD PTR _ePlayer$[ebp]
	push	edx
	call	?GetCity@@YAPBVCvCity@@W4PlayerTypes@@PBVCvPlot@@@Z ; GetCity
	add	esp, 8
	mov	DWORD PTR _pkCity$224186[ebp], eax

; 910  : 			if(pkCity) return pkCity;

	cmp	DWORD PTR _pkCity$224186[ebp], 0
	je	SHORT $LN56@FindCloses
	mov	eax, DWORD PTR _pkCity$224186[ebp]
	jmp	$LN64@FindCloses
$LN56@FindCloses:

; 911  : 		}
; 912  : 
; 913  : 		if(iPlotX + iDist < iMapWidth)

	mov	eax, DWORD PTR _iPlotX$[ebp]
	add	eax, DWORD PTR _iDist$224170[ebp]
	cmp	eax, DWORD PTR _iMapWidth$[ebp]
	jge	$LN51@FindCloses

; 914  : 		{
; 915  : 			const CvPlot* pkTestPlot = kMap.plot(iPlotX + iDist, iPlotY);

	mov	ecx, DWORD PTR _iPlotX$[ebp]
	add	ecx, DWORD PTR _iDist$224170[ebp]
	mov	DWORD PTR $T228581[ebp], ecx
	cmp	DWORD PTR $T228581[ebp], -2147483647	; 80000001H
	je	SHORT $LN154@FindCloses
	cmp	DWORD PTR _iPlotY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN155@FindCloses
$LN154@FindCloses:
	mov	DWORD PTR _pkTestPlot$224189[ebp], 0
	jmp	$LN156@FindCloses
$LN155@FindCloses:
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T228486[ebp], al
	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T228490[ebp], edx
	movzx	eax, BYTE PTR $T228486[ebp]
	test	eax, eax
	je	SHORT $LN167@FindCloses
	cmp	DWORD PTR $T228581[ebp], 0
	jge	SHORT $LN166@FindCloses
	mov	eax, DWORD PTR $T228581[ebp]
	cdq
	idiv	DWORD PTR $T228490[ebp]
	add	edx, DWORD PTR $T228490[ebp]
	mov	DWORD PTR _iMapX$228579[ebp], edx
	jmp	SHORT $LN168@FindCloses
	jmp	SHORT $LN167@FindCloses
$LN166@FindCloses:
	mov	ecx, DWORD PTR $T228581[ebp]
	cmp	ecx, DWORD PTR $T228490[ebp]
	jl	SHORT $LN167@FindCloses
	mov	eax, DWORD PTR $T228581[ebp]
	cdq
	idiv	DWORD PTR $T228490[ebp]
	mov	DWORD PTR _iMapX$228579[ebp], edx
	jmp	SHORT $LN168@FindCloses
$LN167@FindCloses:
	mov	edx, DWORD PTR $T228581[ebp]
	mov	DWORD PTR _iMapX$228579[ebp], edx
$LN168@FindCloses:
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T228501[ebp], cl
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T228505[ebp], eax
	movzx	ecx, BYTE PTR $T228501[ebp]
	test	ecx, ecx
	je	SHORT $LN177@FindCloses
	cmp	DWORD PTR _iPlotY$[ebp], 0
	jge	SHORT $LN176@FindCloses
	mov	eax, DWORD PTR _iPlotY$[ebp]
	cdq
	idiv	DWORD PTR $T228505[ebp]
	add	edx, DWORD PTR $T228505[ebp]
	mov	DWORD PTR _iMapY$228580[ebp], edx
	jmp	SHORT $LN178@FindCloses
	jmp	SHORT $LN177@FindCloses
$LN176@FindCloses:
	mov	edx, DWORD PTR _iPlotY$[ebp]
	cmp	edx, DWORD PTR $T228505[ebp]
	jl	SHORT $LN177@FindCloses
	mov	eax, DWORD PTR _iPlotY$[ebp]
	cdq
	idiv	DWORD PTR $T228505[ebp]
	mov	DWORD PTR _iMapY$228580[ebp], edx
	jmp	SHORT $LN178@FindCloses
$LN177@FindCloses:
	mov	eax, DWORD PTR _iPlotY$[ebp]
	mov	DWORD PTR _iMapY$228580[ebp], eax
$LN178@FindCloses:
	cmp	DWORD PTR _iMapX$228579[ebp], 0
	jl	SHORT $LN182@FindCloses
	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T228519[ebp], edx
	mov	eax, DWORD PTR _iMapX$228579[ebp]
	cmp	eax, DWORD PTR $T228519[ebp]
	jge	SHORT $LN182@FindCloses
	cmp	DWORD PTR _iMapY$228580[ebp], 0
	jl	SHORT $LN182@FindCloses
	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T228523[ebp], edx
	mov	eax, DWORD PTR _iMapY$228580[ebp]
	cmp	eax, DWORD PTR $T228523[ebp]
	jge	SHORT $LN182@FindCloses
	mov	DWORD PTR tv465[ebp], 1
	jmp	SHORT $LN180@FindCloses
$LN182@FindCloses:
	mov	DWORD PTR tv465[ebp], 0
$LN180@FindCloses:
	cmp	DWORD PTR tv465[ebp], 0
	je	SHORT $LN158@FindCloses
	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T228536[ebp], edx
	mov	eax, DWORD PTR _iMapY$228580[ebp]
	imul	eax, DWORD PTR $T228536[ebp]
	add	eax, DWORD PTR _iMapX$228579[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR _kMap$[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv450[ebp], eax
	jmp	SHORT $LN159@FindCloses
$LN158@FindCloses:
	mov	DWORD PTR tv450[ebp], 0
$LN159@FindCloses:
	mov	edx, DWORD PTR tv450[ebp]
	mov	DWORD PTR _pkTestPlot$224189[ebp], edx
$LN156@FindCloses:

; 916  : 			const CvCity* pkCity = GetCity(ePlayer, pkTestPlot);

	mov	eax, DWORD PTR _pkTestPlot$224189[ebp]
	push	eax
	mov	ecx, DWORD PTR _ePlayer$[ebp]
	push	ecx
	call	?GetCity@@YAPBVCvCity@@W4PlayerTypes@@PBVCvPlot@@@Z ; GetCity
	add	esp, 8
	mov	DWORD PTR _pkCity$224190[ebp], eax

; 917  : 			if(pkCity) return pkCity;

	cmp	DWORD PTR _pkCity$224190[ebp], 0
	je	SHORT $LN50@FindCloses
	mov	eax, DWORD PTR _pkCity$224190[ebp]
	jmp	$LN64@FindCloses
$LN50@FindCloses:

; 918  : 		}

	jmp	$LN49@FindCloses
$LN51@FindCloses:

; 919  : 		else if(bWorldWrap)

	movzx	edx, BYTE PTR _bWorldWrap$[ebp]
	test	edx, edx
	je	$LN49@FindCloses

; 920  : 		{
; 921  : 			int iX = iPlotX + iDist;

	mov	eax, DWORD PTR _iPlotX$[ebp]
	add	eax, DWORD PTR _iDist$224170[ebp]
	mov	DWORD PTR _iX$224194[ebp], eax
$LN47@FindCloses:

; 922  : 			while(iX >= iMapWidth) iX -= iMapWidth;

	mov	ecx, DWORD PTR _iX$224194[ebp]
	cmp	ecx, DWORD PTR _iMapWidth$[ebp]
	jl	SHORT $LN46@FindCloses
	mov	edx, DWORD PTR _iX$224194[ebp]
	sub	edx, DWORD PTR _iMapWidth$[ebp]
	mov	DWORD PTR _iX$224194[ebp], edx
	jmp	SHORT $LN47@FindCloses
$LN46@FindCloses:

; 923  : 
; 924  : 			const CvPlot* pkTestPlot = kMap.plot(iX, iPlotY);

	cmp	DWORD PTR _iX$224194[ebp], -2147483647	; 80000001H
	je	SHORT $LN192@FindCloses
	cmp	DWORD PTR _iPlotY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN193@FindCloses
$LN192@FindCloses:
	mov	DWORD PTR _pkTestPlot$224198[ebp], 0
	jmp	$LN194@FindCloses
$LN193@FindCloses:
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	cl, BYTE PTR [eax+4056]
	mov	BYTE PTR $T228588[ebp], cl
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T228592[ebp], eax
	movzx	ecx, BYTE PTR $T228588[ebp]
	test	ecx, ecx
	je	SHORT $LN205@FindCloses
	cmp	DWORD PTR _iX$224194[ebp], 0
	jge	SHORT $LN204@FindCloses
	mov	eax, DWORD PTR _iX$224194[ebp]
	cdq
	idiv	DWORD PTR $T228592[ebp]
	add	edx, DWORD PTR $T228592[ebp]
	mov	DWORD PTR _iMapX$228681[ebp], edx
	jmp	SHORT $LN206@FindCloses
	jmp	SHORT $LN205@FindCloses
$LN204@FindCloses:
	mov	edx, DWORD PTR _iX$224194[ebp]
	cmp	edx, DWORD PTR $T228592[ebp]
	jl	SHORT $LN205@FindCloses
	mov	eax, DWORD PTR _iX$224194[ebp]
	cdq
	idiv	DWORD PTR $T228592[ebp]
	mov	DWORD PTR _iMapX$228681[ebp], edx
	jmp	SHORT $LN206@FindCloses
$LN205@FindCloses:
	mov	eax, DWORD PTR _iX$224194[ebp]
	mov	DWORD PTR _iMapX$228681[ebp], eax
$LN206@FindCloses:
	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T228603[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T228607[ebp], ecx
	movzx	edx, BYTE PTR $T228603[ebp]
	test	edx, edx
	je	SHORT $LN215@FindCloses
	cmp	DWORD PTR _iPlotY$[ebp], 0
	jge	SHORT $LN214@FindCloses
	mov	eax, DWORD PTR _iPlotY$[ebp]
	cdq
	idiv	DWORD PTR $T228607[ebp]
	add	edx, DWORD PTR $T228607[ebp]
	mov	DWORD PTR _iMapY$228682[ebp], edx
	jmp	SHORT $LN216@FindCloses
	jmp	SHORT $LN215@FindCloses
$LN214@FindCloses:
	mov	eax, DWORD PTR _iPlotY$[ebp]
	cmp	eax, DWORD PTR $T228607[ebp]
	jl	SHORT $LN215@FindCloses
	mov	eax, DWORD PTR _iPlotY$[ebp]
	cdq
	idiv	DWORD PTR $T228607[ebp]
	mov	DWORD PTR _iMapY$228682[ebp], edx
	jmp	SHORT $LN216@FindCloses
$LN215@FindCloses:
	mov	ecx, DWORD PTR _iPlotY$[ebp]
	mov	DWORD PTR _iMapY$228682[ebp], ecx
$LN216@FindCloses:
	cmp	DWORD PTR _iMapX$228681[ebp], 0
	jl	SHORT $LN220@FindCloses
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T228621[ebp], eax
	mov	ecx, DWORD PTR _iMapX$228681[ebp]
	cmp	ecx, DWORD PTR $T228621[ebp]
	jge	SHORT $LN220@FindCloses
	cmp	DWORD PTR _iMapY$228682[ebp], 0
	jl	SHORT $LN220@FindCloses
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T228625[ebp], eax
	mov	ecx, DWORD PTR _iMapY$228682[ebp]
	cmp	ecx, DWORD PTR $T228625[ebp]
	jge	SHORT $LN220@FindCloses
	mov	DWORD PTR tv505[ebp], 1
	jmp	SHORT $LN218@FindCloses
$LN220@FindCloses:
	mov	DWORD PTR tv505[ebp], 0
$LN218@FindCloses:
	cmp	DWORD PTR tv505[ebp], 0
	je	SHORT $LN196@FindCloses
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T228638[ebp], eax
	mov	ecx, DWORD PTR _iMapY$228682[ebp]
	imul	ecx, DWORD PTR $T228638[ebp]
	add	ecx, DWORD PTR _iMapX$228681[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _kMap$[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv490[ebp], ecx
	jmp	SHORT $LN197@FindCloses
$LN196@FindCloses:
	mov	DWORD PTR tv490[ebp], 0
$LN197@FindCloses:
	mov	eax, DWORD PTR tv490[ebp]
	mov	DWORD PTR _pkTestPlot$224198[ebp], eax
$LN194@FindCloses:

; 925  : 			const CvCity* pkCity = GetCity(ePlayer, pkTestPlot);

	mov	ecx, DWORD PTR _pkTestPlot$224198[ebp]
	push	ecx
	mov	edx, DWORD PTR _ePlayer$[ebp]
	push	edx
	call	?GetCity@@YAPBVCvCity@@W4PlayerTypes@@PBVCvPlot@@@Z ; GetCity
	add	esp, 8
	mov	DWORD PTR _pkCity$224199[ebp], eax

; 926  : 			if(pkCity) return pkCity;

	cmp	DWORD PTR _pkCity$224199[ebp], 0
	je	SHORT $LN49@FindCloses
	mov	eax, DWORD PTR _pkCity$224199[ebp]
	jmp	$LN64@FindCloses
$LN49@FindCloses:

; 927  : 		}
; 928  : 
; 929  : 		// Top and Bottom Rows
; 930  : 		const int iRowOffset = (iPlotY % 2 == 0)? 0 : 1;

	mov	eax, DWORD PTR _iPlotY$[ebp]
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN458@FindCloses
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN458@FindCloses:
	neg	eax
	sbb	eax, eax
	neg	eax
	mov	DWORD PTR _iRowOffset$224201[ebp], eax

; 931  : 		for(int iRow = 1; iRow < iDist; ++iRow)

	mov	DWORD PTR _iRow$224202[ebp], 1
	jmp	SHORT $LN44@FindCloses
$LN43@FindCloses:
	mov	ecx, DWORD PTR _iRow$224202[ebp]
	add	ecx, 1
	mov	DWORD PTR _iRow$224202[ebp], ecx
$LN44@FindCloses:
	mov	edx, DWORD PTR _iRow$224202[ebp]
	cmp	edx, DWORD PTR _iDist$224170[ebp]
	jge	$LN42@FindCloses

; 932  : 		{
; 933  : 			const int iRowWidth = (iDist * 2) - (iRow - 1);

	mov	eax, DWORD PTR _iDist$224170[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _iRow$224202[ebp]
	sub	ecx, 1
	sub	eax, ecx
	mov	DWORD PTR _iRowWidth$224206[ebp], eax

; 934  : 
; 935  : 			{
; 936  : 				// Left-most plot in the current row
; 937  : 				int iX = iPlotX - (iRowWidth / 2);

	mov	eax, DWORD PTR _iRowWidth$224206[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edx, DWORD PTR _iPlotX$[ebp]
	sub	edx, eax
	mov	DWORD PTR _iX$224207[ebp], edx

; 938  : 				if(iRow % 2 == 1) iX += iRowOffset;

	mov	eax, DWORD PTR _iRow$224202[ebp]
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN459@FindCloses
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN459@FindCloses:
	cmp	eax, 1
	jne	SHORT $LN41@FindCloses
	mov	ecx, DWORD PTR _iX$224207[ebp]
	add	ecx, DWORD PTR _iRowOffset$224201[ebp]
	mov	DWORD PTR _iX$224207[ebp], ecx
$LN41@FindCloses:

; 939  : 
; 940  : 				if(iX < 0)

	cmp	DWORD PTR _iX$224207[ebp], 0
	jge	SHORT $LN40@FindCloses

; 941  : 				{
; 942  : 					if(bWorldWrap)

	movzx	edx, BYTE PTR _bWorldWrap$[ebp]
	test	edx, edx
	je	SHORT $LN40@FindCloses
$LN38@FindCloses:

; 943  : 						do
; 944  : 						{
; 945  : 							iX += iMapWidth;

	mov	eax, DWORD PTR _iX$224207[ebp]
	add	eax, DWORD PTR _iMapWidth$[ebp]
	mov	DWORD PTR _iX$224207[ebp], eax

; 946  : 						}
; 947  : 						while(iX < 0);

	js	SHORT $LN38@FindCloses
$LN40@FindCloses:

; 948  : 				}
; 949  : 
; 950  : 				if(iX >= 0)

	cmp	DWORD PTR _iX$224207[ebp], 0
	jl	$LN35@FindCloses

; 951  : 				{
; 952  : 					if(iPlotY - iRow >= 0)

	mov	ecx, DWORD PTR _iPlotY$[ebp]
	sub	ecx, DWORD PTR _iRow$224202[ebp]
	js	$LN34@FindCloses

; 953  : 					{
; 954  : 						const CvPlot* pkTestPlot = kMap.plot(iX, iPlotY - iRow);

	mov	edx, DWORD PTR _iPlotY$[ebp]
	sub	edx, DWORD PTR _iRow$224202[ebp]
	mov	DWORD PTR $T228784[ebp], edx
	cmp	DWORD PTR _iX$224207[ebp], -2147483647	; 80000001H
	je	SHORT $LN230@FindCloses
	cmp	DWORD PTR $T228784[ebp], -2147483647	; 80000001H
	jne	SHORT $LN231@FindCloses
$LN230@FindCloses:
	mov	DWORD PTR _pkTestPlot$224216[ebp], 0
	jmp	$LN232@FindCloses
$LN231@FindCloses:
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	cl, BYTE PTR [eax+4056]
	mov	BYTE PTR $T228689[ebp], cl
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T228693[ebp], eax
	movzx	ecx, BYTE PTR $T228689[ebp]
	test	ecx, ecx
	je	SHORT $LN243@FindCloses
	cmp	DWORD PTR _iX$224207[ebp], 0
	jge	SHORT $LN242@FindCloses
	mov	eax, DWORD PTR _iX$224207[ebp]
	cdq
	idiv	DWORD PTR $T228693[ebp]
	add	edx, DWORD PTR $T228693[ebp]
	mov	DWORD PTR _iMapX$228782[ebp], edx
	jmp	SHORT $LN244@FindCloses
	jmp	SHORT $LN243@FindCloses
$LN242@FindCloses:
	mov	edx, DWORD PTR _iX$224207[ebp]
	cmp	edx, DWORD PTR $T228693[ebp]
	jl	SHORT $LN243@FindCloses
	mov	eax, DWORD PTR _iX$224207[ebp]
	cdq
	idiv	DWORD PTR $T228693[ebp]
	mov	DWORD PTR _iMapX$228782[ebp], edx
	jmp	SHORT $LN244@FindCloses
$LN243@FindCloses:
	mov	eax, DWORD PTR _iX$224207[ebp]
	mov	DWORD PTR _iMapX$228782[ebp], eax
$LN244@FindCloses:
	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T228704[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T228708[ebp], ecx
	movzx	edx, BYTE PTR $T228704[ebp]
	test	edx, edx
	je	SHORT $LN253@FindCloses
	cmp	DWORD PTR $T228784[ebp], 0
	jge	SHORT $LN252@FindCloses
	mov	eax, DWORD PTR $T228784[ebp]
	cdq
	idiv	DWORD PTR $T228708[ebp]
	add	edx, DWORD PTR $T228708[ebp]
	mov	DWORD PTR _iMapY$228783[ebp], edx
	jmp	SHORT $LN254@FindCloses
	jmp	SHORT $LN253@FindCloses
$LN252@FindCloses:
	mov	eax, DWORD PTR $T228784[ebp]
	cmp	eax, DWORD PTR $T228708[ebp]
	jl	SHORT $LN253@FindCloses
	mov	eax, DWORD PTR $T228784[ebp]
	cdq
	idiv	DWORD PTR $T228708[ebp]
	mov	DWORD PTR _iMapY$228783[ebp], edx
	jmp	SHORT $LN254@FindCloses
$LN253@FindCloses:
	mov	ecx, DWORD PTR $T228784[ebp]
	mov	DWORD PTR _iMapY$228783[ebp], ecx
$LN254@FindCloses:
	cmp	DWORD PTR _iMapX$228782[ebp], 0
	jl	SHORT $LN258@FindCloses
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T228722[ebp], eax
	mov	ecx, DWORD PTR _iMapX$228782[ebp]
	cmp	ecx, DWORD PTR $T228722[ebp]
	jge	SHORT $LN258@FindCloses
	cmp	DWORD PTR _iMapY$228783[ebp], 0
	jl	SHORT $LN258@FindCloses
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T228726[ebp], eax
	mov	ecx, DWORD PTR _iMapY$228783[ebp]
	cmp	ecx, DWORD PTR $T228726[ebp]
	jge	SHORT $LN258@FindCloses
	mov	DWORD PTR tv545[ebp], 1
	jmp	SHORT $LN256@FindCloses
$LN258@FindCloses:
	mov	DWORD PTR tv545[ebp], 0
$LN256@FindCloses:
	cmp	DWORD PTR tv545[ebp], 0
	je	SHORT $LN234@FindCloses
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T228739[ebp], eax
	mov	ecx, DWORD PTR _iMapY$228783[ebp]
	imul	ecx, DWORD PTR $T228739[ebp]
	add	ecx, DWORD PTR _iMapX$228782[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _kMap$[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv530[ebp], ecx
	jmp	SHORT $LN235@FindCloses
$LN234@FindCloses:
	mov	DWORD PTR tv530[ebp], 0
$LN235@FindCloses:
	mov	eax, DWORD PTR tv530[ebp]
	mov	DWORD PTR _pkTestPlot$224216[ebp], eax
$LN232@FindCloses:

; 955  : 						const CvCity* pkCity = GetCity(ePlayer, pkTestPlot);

	mov	ecx, DWORD PTR _pkTestPlot$224216[ebp]
	push	ecx
	mov	edx, DWORD PTR _ePlayer$[ebp]
	push	edx
	call	?GetCity@@YAPBVCvCity@@W4PlayerTypes@@PBVCvPlot@@@Z ; GetCity
	add	esp, 8
	mov	DWORD PTR _pkCity$224217[ebp], eax

; 956  : 						if(pkCity) return pkCity;

	cmp	DWORD PTR _pkCity$224217[ebp], 0
	je	SHORT $LN34@FindCloses
	mov	eax, DWORD PTR _pkCity$224217[ebp]
	jmp	$LN64@FindCloses
$LN34@FindCloses:

; 957  : 					}
; 958  : 
; 959  : 					if(iPlotY + iRow < iMapHeight)

	mov	eax, DWORD PTR _iPlotY$[ebp]
	add	eax, DWORD PTR _iRow$224202[ebp]
	cmp	eax, DWORD PTR _iMapHeight$[ebp]
	jge	$LN35@FindCloses

; 960  : 					{
; 961  : 						const CvPlot* pkTestPlot = kMap.plot(iX, iPlotY + iRow);

	mov	ecx, DWORD PTR _iPlotY$[ebp]
	add	ecx, DWORD PTR _iRow$224202[ebp]
	mov	DWORD PTR $T228886[ebp], ecx
	cmp	DWORD PTR _iX$224207[ebp], -2147483647	; 80000001H
	je	SHORT $LN268@FindCloses
	cmp	DWORD PTR $T228886[ebp], -2147483647	; 80000001H
	jne	SHORT $LN269@FindCloses
$LN268@FindCloses:
	mov	DWORD PTR _pkTestPlot$224220[ebp], 0
	jmp	$LN270@FindCloses
$LN269@FindCloses:
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T228791[ebp], al
	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T228795[ebp], edx
	movzx	eax, BYTE PTR $T228791[ebp]
	test	eax, eax
	je	SHORT $LN281@FindCloses
	cmp	DWORD PTR _iX$224207[ebp], 0
	jge	SHORT $LN280@FindCloses
	mov	eax, DWORD PTR _iX$224207[ebp]
	cdq
	idiv	DWORD PTR $T228795[ebp]
	add	edx, DWORD PTR $T228795[ebp]
	mov	DWORD PTR _iMapX$228884[ebp], edx
	jmp	SHORT $LN282@FindCloses
	jmp	SHORT $LN281@FindCloses
$LN280@FindCloses:
	mov	ecx, DWORD PTR _iX$224207[ebp]
	cmp	ecx, DWORD PTR $T228795[ebp]
	jl	SHORT $LN281@FindCloses
	mov	eax, DWORD PTR _iX$224207[ebp]
	cdq
	idiv	DWORD PTR $T228795[ebp]
	mov	DWORD PTR _iMapX$228884[ebp], edx
	jmp	SHORT $LN282@FindCloses
$LN281@FindCloses:
	mov	edx, DWORD PTR _iX$224207[ebp]
	mov	DWORD PTR _iMapX$228884[ebp], edx
$LN282@FindCloses:
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T228806[ebp], cl
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T228810[ebp], eax
	movzx	ecx, BYTE PTR $T228806[ebp]
	test	ecx, ecx
	je	SHORT $LN291@FindCloses
	cmp	DWORD PTR $T228886[ebp], 0
	jge	SHORT $LN290@FindCloses
	mov	eax, DWORD PTR $T228886[ebp]
	cdq
	idiv	DWORD PTR $T228810[ebp]
	add	edx, DWORD PTR $T228810[ebp]
	mov	DWORD PTR _iMapY$228885[ebp], edx
	jmp	SHORT $LN292@FindCloses
	jmp	SHORT $LN291@FindCloses
$LN290@FindCloses:
	mov	edx, DWORD PTR $T228886[ebp]
	cmp	edx, DWORD PTR $T228810[ebp]
	jl	SHORT $LN291@FindCloses
	mov	eax, DWORD PTR $T228886[ebp]
	cdq
	idiv	DWORD PTR $T228810[ebp]
	mov	DWORD PTR _iMapY$228885[ebp], edx
	jmp	SHORT $LN292@FindCloses
$LN291@FindCloses:
	mov	eax, DWORD PTR $T228886[ebp]
	mov	DWORD PTR _iMapY$228885[ebp], eax
$LN292@FindCloses:
	cmp	DWORD PTR _iMapX$228884[ebp], 0
	jl	SHORT $LN296@FindCloses
	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T228824[ebp], edx
	mov	eax, DWORD PTR _iMapX$228884[ebp]
	cmp	eax, DWORD PTR $T228824[ebp]
	jge	SHORT $LN296@FindCloses
	cmp	DWORD PTR _iMapY$228885[ebp], 0
	jl	SHORT $LN296@FindCloses
	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T228828[ebp], edx
	mov	eax, DWORD PTR _iMapY$228885[ebp]
	cmp	eax, DWORD PTR $T228828[ebp]
	jge	SHORT $LN296@FindCloses
	mov	DWORD PTR tv617[ebp], 1
	jmp	SHORT $LN294@FindCloses
$LN296@FindCloses:
	mov	DWORD PTR tv617[ebp], 0
$LN294@FindCloses:
	cmp	DWORD PTR tv617[ebp], 0
	je	SHORT $LN272@FindCloses
	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T228841[ebp], edx
	mov	eax, DWORD PTR _iMapY$228885[ebp]
	imul	eax, DWORD PTR $T228841[ebp]
	add	eax, DWORD PTR _iMapX$228884[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR _kMap$[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv570[ebp], eax
	jmp	SHORT $LN273@FindCloses
$LN272@FindCloses:
	mov	DWORD PTR tv570[ebp], 0
$LN273@FindCloses:
	mov	edx, DWORD PTR tv570[ebp]
	mov	DWORD PTR _pkTestPlot$224220[ebp], edx
$LN270@FindCloses:

; 962  : 						const CvCity* pkCity = GetCity(ePlayer, pkTestPlot);

	mov	eax, DWORD PTR _pkTestPlot$224220[ebp]
	push	eax
	mov	ecx, DWORD PTR _ePlayer$[ebp]
	push	ecx
	call	?GetCity@@YAPBVCvCity@@W4PlayerTypes@@PBVCvPlot@@@Z ; GetCity
	add	esp, 8
	mov	DWORD PTR _pkCity$224221[ebp], eax

; 963  : 						if(pkCity) return pkCity;

	cmp	DWORD PTR _pkCity$224221[ebp], 0
	je	SHORT $LN35@FindCloses
	mov	eax, DWORD PTR _pkCity$224221[ebp]
	jmp	$LN64@FindCloses
$LN35@FindCloses:

; 964  : 					}
; 965  : 				}
; 966  : 			}
; 967  : 
; 968  : 			{
; 969  : 				// Right-most plot in the current row
; 970  : 				int iX = iPlotX + (iRowWidth / 2) - 1;

	mov	eax, DWORD PTR _iRowWidth$224206[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edx, DWORD PTR _iPlotX$[ebp]
	lea	eax, DWORD PTR [edx+eax-1]
	mov	DWORD PTR _iX$224223[ebp], eax

; 971  : 				if(iRow % 2 == 1) iX += iRowOffset;

	mov	ecx, DWORD PTR _iRow$224202[ebp]
	and	ecx, -2147483647			; 80000001H
	jns	SHORT $LN460@FindCloses
	dec	ecx
	or	ecx, -2					; fffffffeH
	inc	ecx
$LN460@FindCloses:
	cmp	ecx, 1
	jne	SHORT $LN30@FindCloses
	mov	edx, DWORD PTR _iX$224223[ebp]
	add	edx, DWORD PTR _iRowOffset$224201[ebp]
	mov	DWORD PTR _iX$224223[ebp], edx
$LN30@FindCloses:

; 972  : 
; 973  : 				if(iX >= iMapWidth)

	mov	eax, DWORD PTR _iX$224223[ebp]
	cmp	eax, DWORD PTR _iMapWidth$[ebp]
	jl	SHORT $LN29@FindCloses

; 974  : 				{
; 975  : 					if(bWorldWrap)

	movzx	ecx, BYTE PTR _bWorldWrap$[ebp]
	test	ecx, ecx
	je	SHORT $LN29@FindCloses
$LN27@FindCloses:

; 976  : 						do
; 977  : 						{
; 978  : 							iX -= iMapWidth;

	mov	edx, DWORD PTR _iX$224223[ebp]
	sub	edx, DWORD PTR _iMapWidth$[ebp]
	mov	DWORD PTR _iX$224223[ebp], edx

; 979  : 						}
; 980  : 						while(iX >= iMapWidth);

	mov	eax, DWORD PTR _iX$224223[ebp]
	cmp	eax, DWORD PTR _iMapWidth$[ebp]
	jge	SHORT $LN27@FindCloses
$LN29@FindCloses:

; 981  : 				}
; 982  : 
; 983  : 				if(iX < iMapWidth)

	mov	ecx, DWORD PTR _iX$224223[ebp]
	cmp	ecx, DWORD PTR _iMapWidth$[ebp]
	jge	$LN24@FindCloses

; 984  : 				{
; 985  : 					if(iPlotY - iRow >= 0)

	mov	edx, DWORD PTR _iPlotY$[ebp]
	sub	edx, DWORD PTR _iRow$224202[ebp]
	js	$LN23@FindCloses

; 986  : 					{
; 987  : 						const CvPlot* pkTestPlot = kMap.plot(iX, iPlotY - iRow);

	mov	eax, DWORD PTR _iPlotY$[ebp]
	sub	eax, DWORD PTR _iRow$224202[ebp]
	mov	DWORD PTR $T228988[ebp], eax
	cmp	DWORD PTR _iX$224223[ebp], -2147483647	; 80000001H
	je	SHORT $LN306@FindCloses
	cmp	DWORD PTR $T228988[ebp], -2147483647	; 80000001H
	jne	SHORT $LN307@FindCloses
$LN306@FindCloses:
	mov	DWORD PTR _pkTestPlot$224232[ebp], 0
	jmp	$LN308@FindCloses
$LN307@FindCloses:
	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T228893[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T228897[ebp], ecx
	movzx	edx, BYTE PTR $T228893[ebp]
	test	edx, edx
	je	SHORT $LN319@FindCloses
	cmp	DWORD PTR _iX$224223[ebp], 0
	jge	SHORT $LN318@FindCloses
	mov	eax, DWORD PTR _iX$224223[ebp]
	cdq
	idiv	DWORD PTR $T228897[ebp]
	add	edx, DWORD PTR $T228897[ebp]
	mov	DWORD PTR _iMapX$228986[ebp], edx
	jmp	SHORT $LN320@FindCloses
	jmp	SHORT $LN319@FindCloses
$LN318@FindCloses:
	mov	eax, DWORD PTR _iX$224223[ebp]
	cmp	eax, DWORD PTR $T228897[ebp]
	jl	SHORT $LN319@FindCloses
	mov	eax, DWORD PTR _iX$224223[ebp]
	cdq
	idiv	DWORD PTR $T228897[ebp]
	mov	DWORD PTR _iMapX$228986[ebp], edx
	jmp	SHORT $LN320@FindCloses
$LN319@FindCloses:
	mov	ecx, DWORD PTR _iX$224223[ebp]
	mov	DWORD PTR _iMapX$228986[ebp], ecx
$LN320@FindCloses:
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T228908[ebp], al
	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T228912[ebp], edx
	movzx	eax, BYTE PTR $T228908[ebp]
	test	eax, eax
	je	SHORT $LN329@FindCloses
	cmp	DWORD PTR $T228988[ebp], 0
	jge	SHORT $LN328@FindCloses
	mov	eax, DWORD PTR $T228988[ebp]
	cdq
	idiv	DWORD PTR $T228912[ebp]
	add	edx, DWORD PTR $T228912[ebp]
	mov	DWORD PTR _iMapY$228987[ebp], edx
	jmp	SHORT $LN330@FindCloses
	jmp	SHORT $LN329@FindCloses
$LN328@FindCloses:
	mov	ecx, DWORD PTR $T228988[ebp]
	cmp	ecx, DWORD PTR $T228912[ebp]
	jl	SHORT $LN329@FindCloses
	mov	eax, DWORD PTR $T228988[ebp]
	cdq
	idiv	DWORD PTR $T228912[ebp]
	mov	DWORD PTR _iMapY$228987[ebp], edx
	jmp	SHORT $LN330@FindCloses
$LN329@FindCloses:
	mov	edx, DWORD PTR $T228988[ebp]
	mov	DWORD PTR _iMapY$228987[ebp], edx
$LN330@FindCloses:
	cmp	DWORD PTR _iMapX$228986[ebp], 0
	jl	SHORT $LN334@FindCloses
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T228926[ebp], ecx
	mov	edx, DWORD PTR _iMapX$228986[ebp]
	cmp	edx, DWORD PTR $T228926[ebp]
	jge	SHORT $LN334@FindCloses
	cmp	DWORD PTR _iMapY$228987[ebp], 0
	jl	SHORT $LN334@FindCloses
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T228930[ebp], ecx
	mov	edx, DWORD PTR _iMapY$228987[ebp]
	cmp	edx, DWORD PTR $T228930[ebp]
	jge	SHORT $LN334@FindCloses
	mov	DWORD PTR tv657[ebp], 1
	jmp	SHORT $LN332@FindCloses
$LN334@FindCloses:
	mov	DWORD PTR tv657[ebp], 0
$LN332@FindCloses:
	cmp	DWORD PTR tv657[ebp], 0
	je	SHORT $LN310@FindCloses
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T228943[ebp], ecx
	mov	edx, DWORD PTR _iMapY$228987[ebp]
	imul	edx, DWORD PTR $T228943[ebp]
	add	edx, DWORD PTR _iMapX$228986[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR _kMap$[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv642[ebp], edx
	jmp	SHORT $LN311@FindCloses
$LN310@FindCloses:
	mov	DWORD PTR tv642[ebp], 0
$LN311@FindCloses:
	mov	ecx, DWORD PTR tv642[ebp]
	mov	DWORD PTR _pkTestPlot$224232[ebp], ecx
$LN308@FindCloses:

; 988  : 						const CvCity* pkCity = GetCity(ePlayer, pkTestPlot);

	mov	edx, DWORD PTR _pkTestPlot$224232[ebp]
	push	edx
	mov	eax, DWORD PTR _ePlayer$[ebp]
	push	eax
	call	?GetCity@@YAPBVCvCity@@W4PlayerTypes@@PBVCvPlot@@@Z ; GetCity
	add	esp, 8
	mov	DWORD PTR _pkCity$224233[ebp], eax

; 989  : 						if(pkCity) return pkCity;

	cmp	DWORD PTR _pkCity$224233[ebp], 0
	je	SHORT $LN23@FindCloses
	mov	eax, DWORD PTR _pkCity$224233[ebp]
	jmp	$LN64@FindCloses
$LN23@FindCloses:

; 990  : 					}
; 991  : 
; 992  : 					if(iPlotY + iRow < iMapHeight)

	mov	ecx, DWORD PTR _iPlotY$[ebp]
	add	ecx, DWORD PTR _iRow$224202[ebp]
	cmp	ecx, DWORD PTR _iMapHeight$[ebp]
	jge	$LN24@FindCloses

; 993  : 					{
; 994  : 						const CvPlot* pkTestPlot = kMap.plot(iX, iPlotY + iRow);

	mov	edx, DWORD PTR _iPlotY$[ebp]
	add	edx, DWORD PTR _iRow$224202[ebp]
	mov	DWORD PTR $T229090[ebp], edx
	cmp	DWORD PTR _iX$224223[ebp], -2147483647	; 80000001H
	je	SHORT $LN344@FindCloses
	cmp	DWORD PTR $T229090[ebp], -2147483647	; 80000001H
	jne	SHORT $LN345@FindCloses
$LN344@FindCloses:
	mov	DWORD PTR _pkTestPlot$224236[ebp], 0
	jmp	$LN346@FindCloses
$LN345@FindCloses:
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	cl, BYTE PTR [eax+4056]
	mov	BYTE PTR $T228995[ebp], cl
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T228999[ebp], eax
	movzx	ecx, BYTE PTR $T228995[ebp]
	test	ecx, ecx
	je	SHORT $LN357@FindCloses
	cmp	DWORD PTR _iX$224223[ebp], 0
	jge	SHORT $LN356@FindCloses
	mov	eax, DWORD PTR _iX$224223[ebp]
	cdq
	idiv	DWORD PTR $T228999[ebp]
	add	edx, DWORD PTR $T228999[ebp]
	mov	DWORD PTR _iMapX$229088[ebp], edx
	jmp	SHORT $LN358@FindCloses
	jmp	SHORT $LN357@FindCloses
$LN356@FindCloses:
	mov	edx, DWORD PTR _iX$224223[ebp]
	cmp	edx, DWORD PTR $T228999[ebp]
	jl	SHORT $LN357@FindCloses
	mov	eax, DWORD PTR _iX$224223[ebp]
	cdq
	idiv	DWORD PTR $T228999[ebp]
	mov	DWORD PTR _iMapX$229088[ebp], edx
	jmp	SHORT $LN358@FindCloses
$LN357@FindCloses:
	mov	eax, DWORD PTR _iX$224223[ebp]
	mov	DWORD PTR _iMapX$229088[ebp], eax
$LN358@FindCloses:
	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T229010[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T229014[ebp], ecx
	movzx	edx, BYTE PTR $T229010[ebp]
	test	edx, edx
	je	SHORT $LN367@FindCloses
	cmp	DWORD PTR $T229090[ebp], 0
	jge	SHORT $LN366@FindCloses
	mov	eax, DWORD PTR $T229090[ebp]
	cdq
	idiv	DWORD PTR $T229014[ebp]
	add	edx, DWORD PTR $T229014[ebp]
	mov	DWORD PTR _iMapY$229089[ebp], edx
	jmp	SHORT $LN368@FindCloses
	jmp	SHORT $LN367@FindCloses
$LN366@FindCloses:
	mov	eax, DWORD PTR $T229090[ebp]
	cmp	eax, DWORD PTR $T229014[ebp]
	jl	SHORT $LN367@FindCloses
	mov	eax, DWORD PTR $T229090[ebp]
	cdq
	idiv	DWORD PTR $T229014[ebp]
	mov	DWORD PTR _iMapY$229089[ebp], edx
	jmp	SHORT $LN368@FindCloses
$LN367@FindCloses:
	mov	ecx, DWORD PTR $T229090[ebp]
	mov	DWORD PTR _iMapY$229089[ebp], ecx
$LN368@FindCloses:
	cmp	DWORD PTR _iMapX$229088[ebp], 0
	jl	SHORT $LN372@FindCloses
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T229028[ebp], eax
	mov	ecx, DWORD PTR _iMapX$229088[ebp]
	cmp	ecx, DWORD PTR $T229028[ebp]
	jge	SHORT $LN372@FindCloses
	cmp	DWORD PTR _iMapY$229089[ebp], 0
	jl	SHORT $LN372@FindCloses
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T229032[ebp], eax
	mov	ecx, DWORD PTR _iMapY$229089[ebp]
	cmp	ecx, DWORD PTR $T229032[ebp]
	jge	SHORT $LN372@FindCloses
	mov	DWORD PTR tv697[ebp], 1
	jmp	SHORT $LN370@FindCloses
$LN372@FindCloses:
	mov	DWORD PTR tv697[ebp], 0
$LN370@FindCloses:
	cmp	DWORD PTR tv697[ebp], 0
	je	SHORT $LN348@FindCloses
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T229045[ebp], eax
	mov	ecx, DWORD PTR _iMapY$229089[ebp]
	imul	ecx, DWORD PTR $T229045[ebp]
	add	ecx, DWORD PTR _iMapX$229088[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _kMap$[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv682[ebp], ecx
	jmp	SHORT $LN349@FindCloses
$LN348@FindCloses:
	mov	DWORD PTR tv682[ebp], 0
$LN349@FindCloses:
	mov	eax, DWORD PTR tv682[ebp]
	mov	DWORD PTR _pkTestPlot$224236[ebp], eax
$LN346@FindCloses:

; 995  : 						const CvCity* pkCity = GetCity(ePlayer, pkTestPlot);

	mov	ecx, DWORD PTR _pkTestPlot$224236[ebp]
	push	ecx
	mov	edx, DWORD PTR _ePlayer$[ebp]
	push	edx
	call	?GetCity@@YAPBVCvCity@@W4PlayerTypes@@PBVCvPlot@@@Z ; GetCity
	add	esp, 8
	mov	DWORD PTR _pkCity$224237[ebp], eax

; 996  : 						if(pkCity) return pkCity;

	cmp	DWORD PTR _pkCity$224237[ebp], 0
	je	SHORT $LN24@FindCloses
	mov	eax, DWORD PTR _pkCity$224237[ebp]
	jmp	$LN64@FindCloses
$LN24@FindCloses:

; 997  : 					}
; 998  : 				}
; 999  : 			}
; 1000 : 		}

	jmp	$LN43@FindCloses
$LN42@FindCloses:

; 1001 : 
; 1002 : 		// Top-most and Bottom-most rows
; 1003 : 		{
; 1004 : 			const int iRowWidth = iDist + 1;

	mov	eax, DWORD PTR _iDist$224170[ebp]
	add	eax, 1
	mov	DWORD PTR _iRowWidth$224239[ebp], eax

; 1005 : 			for(int iPlot = 0; iPlot < iRowWidth; ++iPlot)

	mov	DWORD PTR _iPlot$224240[ebp], 0
	jmp	SHORT $LN19@FindCloses
$LN18@FindCloses:
	mov	ecx, DWORD PTR _iPlot$224240[ebp]
	add	ecx, 1
	mov	DWORD PTR _iPlot$224240[ebp], ecx
$LN19@FindCloses:
	mov	edx, DWORD PTR _iPlot$224240[ebp]
	cmp	edx, DWORD PTR _iRowWidth$224239[ebp]
	jge	$LN17@FindCloses

; 1006 : 			{
; 1007 : 				int iX = iPlotX + iPlot - (iRowWidth / 2);

	mov	ecx, DWORD PTR _iPlotX$[ebp]
	add	ecx, DWORD PTR _iPlot$224240[ebp]
	mov	eax, DWORD PTR _iRowWidth$224239[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	ecx, eax
	mov	DWORD PTR _iX$224244[ebp], ecx

; 1008 : 				if(iDist % 2 == 1) iX += iRowOffset;

	mov	edx, DWORD PTR _iDist$224170[ebp]
	and	edx, -2147483647			; 80000001H
	jns	SHORT $LN461@FindCloses
	dec	edx
	or	edx, -2					; fffffffeH
	inc	edx
$LN461@FindCloses:
	cmp	edx, 1
	jne	SHORT $LN16@FindCloses
	mov	eax, DWORD PTR _iX$224244[ebp]
	add	eax, DWORD PTR _iRowOffset$224201[ebp]
	mov	DWORD PTR _iX$224244[ebp], eax
$LN16@FindCloses:

; 1009 : 
; 1010 : 				if(iX < 0)

	cmp	DWORD PTR _iX$224244[ebp], 0
	jge	SHORT $LN15@FindCloses

; 1011 : 				{
; 1012 : 					if(!bWorldWrap)

	movzx	ecx, BYTE PTR _bWorldWrap$[ebp]
	test	ecx, ecx
	jne	SHORT $LN13@FindCloses

; 1013 : 						continue;

	jmp	SHORT $LN18@FindCloses
$LN13@FindCloses:

; 1014 : 
; 1015 : 					do
; 1016 : 					{
; 1017 : 						iX += iMapWidth;

	mov	edx, DWORD PTR _iX$224244[ebp]
	add	edx, DWORD PTR _iMapWidth$[ebp]
	mov	DWORD PTR _iX$224244[ebp], edx

; 1018 : 					}
; 1019 : 					while(iX < 0);

	js	SHORT $LN13@FindCloses

; 1020 : 				}
; 1021 : 				else if(iX >= iMapWidth)

	jmp	SHORT $LN10@FindCloses
$LN15@FindCloses:
	mov	eax, DWORD PTR _iX$224244[ebp]
	cmp	eax, DWORD PTR _iMapWidth$[ebp]
	jl	SHORT $LN10@FindCloses

; 1022 : 				{
; 1023 : 					if(!bWorldWrap)

	movzx	ecx, BYTE PTR _bWorldWrap$[ebp]
	test	ecx, ecx
	jne	SHORT $LN7@FindCloses

; 1024 : 						continue;

	jmp	$LN18@FindCloses
$LN7@FindCloses:

; 1025 : 
; 1026 : 					do
; 1027 : 					{
; 1028 : 						iX -= iMapWidth;

	mov	edx, DWORD PTR _iX$224244[ebp]
	sub	edx, DWORD PTR _iMapWidth$[ebp]
	mov	DWORD PTR _iX$224244[ebp], edx

; 1029 : 					}
; 1030 : 					while(iX >= iMapWidth);

	mov	eax, DWORD PTR _iX$224244[ebp]
	cmp	eax, DWORD PTR _iMapWidth$[ebp]
	jge	SHORT $LN7@FindCloses
$LN10@FindCloses:

; 1031 : 				}
; 1032 : 
; 1033 : 				if(iPlotY - iDist >= 0)

	mov	ecx, DWORD PTR _iPlotY$[ebp]
	sub	ecx, DWORD PTR _iDist$224170[ebp]
	js	$LN4@FindCloses

; 1034 : 				{
; 1035 : 					const CvPlot* pkTestPlot = kMap.plot(iX, iPlotY - iDist);

	mov	edx, DWORD PTR _iPlotY$[ebp]
	sub	edx, DWORD PTR _iDist$224170[ebp]
	mov	DWORD PTR $T229192[ebp], edx
	cmp	DWORD PTR _iX$224244[ebp], -2147483647	; 80000001H
	je	SHORT $LN382@FindCloses
	cmp	DWORD PTR $T229192[ebp], -2147483647	; 80000001H
	jne	SHORT $LN383@FindCloses
$LN382@FindCloses:
	mov	DWORD PTR _pkTestPlot$224258[ebp], 0
	jmp	$LN384@FindCloses
$LN383@FindCloses:
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	cl, BYTE PTR [eax+4056]
	mov	BYTE PTR $T229097[ebp], cl
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T229101[ebp], eax
	movzx	ecx, BYTE PTR $T229097[ebp]
	test	ecx, ecx
	je	SHORT $LN395@FindCloses
	cmp	DWORD PTR _iX$224244[ebp], 0
	jge	SHORT $LN394@FindCloses
	mov	eax, DWORD PTR _iX$224244[ebp]
	cdq
	idiv	DWORD PTR $T229101[ebp]
	add	edx, DWORD PTR $T229101[ebp]
	mov	DWORD PTR _iMapX$229158[ebp], edx
	jmp	SHORT $LN396@FindCloses
	jmp	SHORT $LN395@FindCloses
$LN394@FindCloses:
	mov	edx, DWORD PTR _iX$224244[ebp]
	cmp	edx, DWORD PTR $T229101[ebp]
	jl	SHORT $LN395@FindCloses
	mov	eax, DWORD PTR _iX$224244[ebp]
	cdq
	idiv	DWORD PTR $T229101[ebp]
	mov	DWORD PTR _iMapX$229158[ebp], edx
	jmp	SHORT $LN396@FindCloses
$LN395@FindCloses:
	mov	eax, DWORD PTR _iX$224244[ebp]
	mov	DWORD PTR _iMapX$229158[ebp], eax
$LN396@FindCloses:
	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T229112[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T229116[ebp], ecx
	movzx	edx, BYTE PTR $T229112[ebp]
	test	edx, edx
	je	SHORT $LN405@FindCloses
	cmp	DWORD PTR $T229192[ebp], 0
	jge	SHORT $LN404@FindCloses
	mov	eax, DWORD PTR $T229192[ebp]
	cdq
	idiv	DWORD PTR $T229116[ebp]
	add	edx, DWORD PTR $T229116[ebp]
	mov	DWORD PTR _iMapY$229160[ebp], edx
	jmp	SHORT $LN406@FindCloses
	jmp	SHORT $LN405@FindCloses
$LN404@FindCloses:
	mov	eax, DWORD PTR $T229192[ebp]
	cmp	eax, DWORD PTR $T229116[ebp]
	jl	SHORT $LN405@FindCloses
	mov	eax, DWORD PTR $T229192[ebp]
	cdq
	idiv	DWORD PTR $T229116[ebp]
	mov	DWORD PTR _iMapY$229160[ebp], edx
	jmp	SHORT $LN406@FindCloses
$LN405@FindCloses:
	mov	ecx, DWORD PTR $T229192[ebp]
	mov	DWORD PTR _iMapY$229160[ebp], ecx
$LN406@FindCloses:
	cmp	DWORD PTR _iMapX$229158[ebp], 0
	jl	SHORT $LN410@FindCloses
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T229130[ebp], eax
	mov	ecx, DWORD PTR _iMapX$229158[ebp]
	cmp	ecx, DWORD PTR $T229130[ebp]
	jge	SHORT $LN410@FindCloses
	cmp	DWORD PTR _iMapY$229160[ebp], 0
	jl	SHORT $LN410@FindCloses
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T229134[ebp], eax
	mov	ecx, DWORD PTR _iMapY$229160[ebp]
	cmp	ecx, DWORD PTR $T229134[ebp]
	jge	SHORT $LN410@FindCloses
	mov	DWORD PTR tv769[ebp], 1
	jmp	SHORT $LN408@FindCloses
$LN410@FindCloses:
	mov	DWORD PTR tv769[ebp], 0
$LN408@FindCloses:
	cmp	DWORD PTR tv769[ebp], 0
	je	SHORT $LN386@FindCloses
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T229147[ebp], eax
	mov	ecx, DWORD PTR _iMapY$229160[ebp]
	imul	ecx, DWORD PTR $T229147[ebp]
	add	ecx, DWORD PTR _iMapX$229158[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _kMap$[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv722[ebp], ecx
	jmp	SHORT $LN387@FindCloses
$LN386@FindCloses:
	mov	DWORD PTR tv722[ebp], 0
$LN387@FindCloses:
	mov	eax, DWORD PTR tv722[ebp]
	mov	DWORD PTR _pkTestPlot$224258[ebp], eax
$LN384@FindCloses:

; 1036 : 					const CvCity* pkCity = GetCity(ePlayer, pkTestPlot);

	mov	ecx, DWORD PTR _pkTestPlot$224258[ebp]
	push	ecx
	mov	edx, DWORD PTR _ePlayer$[ebp]
	push	edx
	call	?GetCity@@YAPBVCvCity@@W4PlayerTypes@@PBVCvPlot@@@Z ; GetCity
	add	esp, 8
	mov	DWORD PTR _pkCity$224259[ebp], eax

; 1037 : 					if(pkCity) return pkCity;

	cmp	DWORD PTR _pkCity$224259[ebp], 0
	je	SHORT $LN4@FindCloses
	mov	eax, DWORD PTR _pkCity$224259[ebp]
	jmp	$LN64@FindCloses
$LN4@FindCloses:

; 1038 : 				}
; 1039 : 
; 1040 : 				if(iPlotY + iDist < iMapHeight)

	mov	eax, DWORD PTR _iPlotY$[ebp]
	add	eax, DWORD PTR _iDist$224170[ebp]
	cmp	eax, DWORD PTR _iMapHeight$[ebp]
	jge	$LN2@FindCloses

; 1041 : 				{
; 1042 : 					const CvPlot* pkTestPlot = kMap.plot(iX, iPlotY + iDist);

	mov	ecx, DWORD PTR _iPlotY$[ebp]
	add	ecx, DWORD PTR _iDist$224170[ebp]
	mov	DWORD PTR $T229294[ebp], ecx
	cmp	DWORD PTR _iX$224244[ebp], -2147483647	; 80000001H
	je	SHORT $LN420@FindCloses
	cmp	DWORD PTR $T229294[ebp], -2147483647	; 80000001H
	jne	SHORT $LN421@FindCloses
$LN420@FindCloses:
	mov	DWORD PTR _pkTestPlot$224262[ebp], 0
	jmp	$LN422@FindCloses
$LN421@FindCloses:
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T229199[ebp], al
	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T229203[ebp], edx
	movzx	eax, BYTE PTR $T229199[ebp]
	test	eax, eax
	je	SHORT $LN433@FindCloses
	cmp	DWORD PTR _iX$224244[ebp], 0
	jge	SHORT $LN432@FindCloses
	mov	eax, DWORD PTR _iX$224244[ebp]
	cdq
	idiv	DWORD PTR $T229203[ebp]
	add	edx, DWORD PTR $T229203[ebp]
	mov	DWORD PTR _iMapX$229257[ebp], edx
	jmp	SHORT $LN434@FindCloses
	jmp	SHORT $LN433@FindCloses
$LN432@FindCloses:
	mov	ecx, DWORD PTR _iX$224244[ebp]
	cmp	ecx, DWORD PTR $T229203[ebp]
	jl	SHORT $LN433@FindCloses
	mov	eax, DWORD PTR _iX$224244[ebp]
	cdq
	idiv	DWORD PTR $T229203[ebp]
	mov	DWORD PTR _iMapX$229257[ebp], edx
	jmp	SHORT $LN434@FindCloses
$LN433@FindCloses:
	mov	edx, DWORD PTR _iX$224244[ebp]
	mov	DWORD PTR _iMapX$229257[ebp], edx
$LN434@FindCloses:
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T229214[ebp], cl
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T229218[ebp], eax
	movzx	ecx, BYTE PTR $T229214[ebp]
	test	ecx, ecx
	je	SHORT $LN443@FindCloses
	cmp	DWORD PTR $T229294[ebp], 0
	jge	SHORT $LN442@FindCloses
	mov	eax, DWORD PTR $T229294[ebp]
	cdq
	idiv	DWORD PTR $T229218[ebp]
	add	edx, DWORD PTR $T229218[ebp]
	mov	DWORD PTR _iMapY$229258[ebp], edx
	jmp	SHORT $LN444@FindCloses
	jmp	SHORT $LN443@FindCloses
$LN442@FindCloses:
	mov	edx, DWORD PTR $T229294[ebp]
	cmp	edx, DWORD PTR $T229218[ebp]
	jl	SHORT $LN443@FindCloses
	mov	eax, DWORD PTR $T229294[ebp]
	cdq
	idiv	DWORD PTR $T229218[ebp]
	mov	DWORD PTR _iMapY$229258[ebp], edx
	jmp	SHORT $LN444@FindCloses
$LN443@FindCloses:
	mov	eax, DWORD PTR $T229294[ebp]
	mov	DWORD PTR _iMapY$229258[ebp], eax
$LN444@FindCloses:
	cmp	DWORD PTR _iMapX$229257[ebp], 0
	jl	SHORT $LN448@FindCloses
	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T229232[ebp], edx
	mov	eax, DWORD PTR _iMapX$229257[ebp]
	cmp	eax, DWORD PTR $T229232[ebp]
	jge	SHORT $LN448@FindCloses
	cmp	DWORD PTR _iMapY$229258[ebp], 0
	jl	SHORT $LN448@FindCloses
	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T229236[ebp], edx
	mov	eax, DWORD PTR _iMapY$229258[ebp]
	cmp	eax, DWORD PTR $T229236[ebp]
	jge	SHORT $LN448@FindCloses
	mov	DWORD PTR tv809[ebp], 1
	jmp	SHORT $LN446@FindCloses
$LN448@FindCloses:
	mov	DWORD PTR tv809[ebp], 0
$LN446@FindCloses:
	cmp	DWORD PTR tv809[ebp], 0
	je	SHORT $LN424@FindCloses
	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T229249[ebp], edx
	mov	eax, DWORD PTR _iMapY$229258[ebp]
	imul	eax, DWORD PTR $T229249[ebp]
	add	eax, DWORD PTR _iMapX$229257[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR _kMap$[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv794[ebp], eax
	jmp	SHORT $LN425@FindCloses
$LN424@FindCloses:
	mov	DWORD PTR tv794[ebp], 0
$LN425@FindCloses:
	mov	edx, DWORD PTR tv794[ebp]
	mov	DWORD PTR _pkTestPlot$224262[ebp], edx
$LN422@FindCloses:

; 1043 : 					const CvCity* pkCity = GetCity(ePlayer, pkTestPlot);

	mov	eax, DWORD PTR _pkTestPlot$224262[ebp]
	push	eax
	mov	ecx, DWORD PTR _ePlayer$[ebp]
	push	ecx
	call	?GetCity@@YAPBVCvCity@@W4PlayerTypes@@PBVCvPlot@@@Z ; GetCity
	add	esp, 8
	mov	DWORD PTR _pkCity$224263[ebp], eax

; 1044 : 					if(pkCity) return pkCity;

	cmp	DWORD PTR _pkCity$224263[ebp], 0
	je	SHORT $LN2@FindCloses
	mov	eax, DWORD PTR _pkCity$224263[ebp]
	jmp	SHORT $LN64@FindCloses
$LN2@FindCloses:

; 1045 : 				}
; 1046 : 			}

	jmp	$LN18@FindCloses
$LN17@FindCloses:

; 1047 : 		}
; 1048 : 	}

	jmp	$LN61@FindCloses
$LN60@FindCloses:

; 1049 : 
; 1050 : 	return NULL;

	xor	eax, eax
$LN64@FindCloses:

; 1051 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FindClosestCity@@YAPBVCvCity@@W4PlayerTypes@@ABVCvPlot@@@Z ENDP ; FindClosestCity
_TEXT	ENDS
PUBLIC	??1?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAE@XZ ; FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>::~FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>
PUBLIC	??_C@_0BD@FPKADGCN@Map?5Load?5Success?$CB?6?$AA@ ; `string'
PUBLIC	??_C@_0BN@JLCKEMAB@Adding?5Scenario?5Elements?4?4?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BG@NBCEOEJG@Calculating?5Areas?4?4?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@LPGKJLCN@Setting?5up?5map?4?4?4?6?$AA@ ; `string'
PUBLIC	?push_back@?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAEIABQAVCvPlayer@@@Z ; FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>::push_back
PUBLIC	??0?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAE@I@Z ; FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>::FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
PUBLIC	?coordRange@@YAHHH_N@Z				; coordRange
PUBLIC	??_C@_0BH@KKCBKBMH@Setting?5up?5players?4?4?4?6?$AA@ ; `string'
PUBLIC	?InitMap@CvWorldBuilderMapLoader@@SA_NXZ	; CvWorldBuilderMapLoader::InitMap
EXTRN	?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z:PROC ; CvPlot::setOwner
EXTRN	?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z:PROC ; CvPlot::setRevealed
EXTRN	?SetPlayerResponsibleForRoute@CvPlot@@QAEXW4PlayerTypes@@@Z:PROC ; CvPlot::SetPlayerResponsibleForRoute
EXTRN	?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z:PROC ; CvTreasury::ChangeBaseImprovementGoldMaintenance
EXTRN	?GetGoldMaintenance@CvRouteInfo@@QBEHXZ:PROC	; CvRouteInfo::GetGoldMaintenance
EXTRN	?MustPayMaintenanceHere@CvPlot@@QBE_NW4PlayerTypes@@@Z:PROC ; CvPlot::MustPayMaintenanceHere
EXTRN	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z:PROC ; CvGlobals::getRouteInfo
EXTRN	?isOwned@CvPlot@@QBE_NXZ:PROC			; CvPlot::isOwned
EXTRN	?setRouteType@CvPlot@@QAEXW4RouteTypes@@@Z:PROC	; CvPlot::setRouteType
EXTRN	?setImprovementType@CvPlot@@QAEXW4ImprovementTypes@@W4PlayerTypes@@@Z:PROC ; CvPlot::setImprovementType
EXTRN	?SetFriendshipWithMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z:PROC ; CvMinorCivAI::SetFriendshipWithMajor
EXTRN	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ:PROC ; CvPlayer::GetMinorCivAI
EXTRN	?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z:PROC ; CvTeam::SetHasDefensivePact
EXTRN	?SetAllowsOpenBordersToTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z:PROC ; CvTeam::SetAllowsOpenBordersToTeam
EXTRN	?setPermanentWarPeace@CvTeam@@QAEXW4TeamTypes@@_N@Z:PROC ; CvTeam::setPermanentWarPeace
EXTRN	?setAtWar@CvTeam@@QAEXW4TeamTypes@@_N@Z:PROC	; CvTeam::setAtWar
EXTRN	?meet@CvTeam@@QAEXW4TeamTypes@@_N@Z:PROC	; CvTeam::meet
EXTRN	?Init@CvTacticalAnalysisMap@@QAEXH@Z:PROC	; CvTacticalAnalysisMap::Init
EXTRN	?GetTacticalAnalysisMap@CvGame@@QAEPAVCvTacticalAnalysisMap@@XZ:PROC ; CvGame::GetTacticalAnalysisMap
EXTRN	?recalculateAreas@CvMap@@QAEXXZ:PROC		; CvMap::recalculateAreas
EXTRN	?SetContinentType@CvPlot@@QAEXD@Z:PROC		; CvPlot::SetContinentType
EXTRN	?setNEOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z:PROC ; CvPlot::setNEOfRiver
EXTRN	?setNWOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z:PROC ; CvPlot::setNWOfRiver
EXTRN	?setWOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z:PROC ; CvPlot::setWOfRiver
EXTRN	?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z:PROC ; CvPlot::setFeatureType
EXTRN	?setResourceType@CvPlot@@QAEXW4ResourceTypes@@H_N@Z:PROC ; CvPlot::setResourceType
EXTRN	?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z:PROC ; CvPlot::setPlotType
EXTRN	?setTerrainType@CvPlot@@QAEXW4TerrainTypes@@_N1@Z:PROC ; CvPlot::setTerrainType
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
EXTRN	?getStartingPlot@CvPlayer@@QBEPAVCvPlot@@XZ:PROC ; CvPlayer::getStartingPlot
EXTRN	?setStartingPlot@CvPlayer@@QAEXPAVCvPlot@@@Z:PROC ; CvPlayer::setStartingPlot
EXTRN	__imp__OutputDebugStringA@4:PROC
;	COMDAT ??_C@_0BD@FPKADGCN@Map?5Load?5Success?$CB?6?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0BD@FPKADGCN@Map?5Load?5Success?$CB?6?$AA@ DB 'Map Load Success!', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JLCKEMAB@Adding?5Scenario?5Elements?4?4?4?6?$AA@
CONST	SEGMENT
??_C@_0BN@JLCKEMAB@Adding?5Scenario?5Elements?4?4?4?6?$AA@ DB 'Adding Sce'
	DB	'nario Elements...', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NBCEOEJG@Calculating?5Areas?4?4?4?6?$AA@
CONST	SEGMENT
??_C@_0BG@NBCEOEJG@Calculating?5Areas?4?4?4?6?$AA@ DB 'Calculating Areas.'
	DB	'..', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LPGKJLCN@Setting?5up?5map?4?4?4?6?$AA@
CONST	SEGMENT
??_C@_0BD@LPGKJLCN@Setting?5up?5map?4?4?4?6?$AA@ DB 'Setting up map...', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@KKCBKBMH@Setting?5up?5players?4?4?4?6?$AA@
CONST	SEGMENT
??_C@_0BH@KKCBKBMH@Setting?5up?5players?4?4?4?6?$AA@ DB 'Setting up playe'
	DB	'rs...', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?InitMap@CvWorldBuilderMapLoader@@SA_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?InitMap@CvWorldBuilderMapLoader@@SA_NXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?InitMap@CvWorldBuilderMapLoader@@SA_NXZ$1
__ehfuncinfo$?InitMap@CvWorldBuilderMapLoader@@SA_NXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?InitMap@CvWorldBuilderMapLoader@@SA_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvworldbuildermaploader.cpp
xdata$x	ENDS
;	COMDAT ?InitMap@CvWorldBuilderMapLoader@@SA_NXZ
_TEXT	SEGMENT
tv1146 = -736						; size = 4
tv1095 = -732						; size = 4
tv897 = -728						; size = 4
tv752 = -724						; size = 4
tv757 = -720						; size = 4
tv704 = -716						; size = 4
tv709 = -712						; size = 4
tv718 = -708						; size = 4
tv669 = -704						; size = 4
$T229947 = -676						; size = 4
$T229925 = -669						; size = 1
$T229924 = -668						; size = 4
_byMask$229931 = -661					; size = 1
_uiByte$229929 = -660					; size = 4
_uiBit$229930 = -656					; size = 4
_uiMapSize$229935 = -652				; size = 4
$T229914 = -646						; size = 2
$T229908 = -644						; size = 2
$T229902 = -642						; size = 2
$T229896 = -640						; size = 4
$T229889 = -636						; size = 4
$T229871 = -632						; size = 4
$T229856 = -625						; size = 1
_uiSmall$229842 = -624					; size = 4
_uiStart$229845 = -620					; size = 4
_uiLarge$229841 = -616					; size = 4
_uiBitIndex$229852 = -612				; size = 4
_byMask$229855 = -605					; size = 1
_uiByte$229853 = -604					; size = 4
_uiBit$229854 = -600					; size = 4
$T229824 = -593						; size = 1
_uiSmall$229810 = -592					; size = 4
_uiStart$229813 = -588					; size = 4
_uiLarge$229809 = -584					; size = 4
_uiBitIndex$229820 = -580				; size = 4
_byMask$229823 = -573					; size = 1
_uiByte$229821 = -572					; size = 4
_uiBit$229822 = -568					; size = 4
$T229792 = -561						; size = 1
_uiSmall$229778 = -560					; size = 4
_uiStart$229781 = -556					; size = 4
_uiLarge$229777 = -552					; size = 4
_uiBitIndex$229788 = -548				; size = 4
_byMask$229791 = -541					; size = 1
_uiByte$229789 = -540					; size = 4
_uiBit$229790 = -536					; size = 4
$T229760 = -529						; size = 1
_uiSmall$229746 = -528					; size = 4
_uiStart$229749 = -524					; size = 4
_uiLarge$229745 = -520					; size = 4
_uiBitIndex$229756 = -516				; size = 4
_byMask$229759 = -509					; size = 1
_uiByte$229757 = -508					; size = 4
_uiBit$229758 = -504					; size = 4
$T229728 = -497						; size = 1
_uiSmall$229714 = -496					; size = 4
_uiStart$229717 = -492					; size = 4
_uiLarge$229713 = -488					; size = 4
_uiBitIndex$229724 = -484				; size = 4
_byMask$229727 = -477					; size = 1
_uiByte$229725 = -476					; size = 4
_uiBit$229726 = -472					; size = 4
$T229690 = -468						; size = 4
$T229686 = -464						; size = 4
$T229682 = -460						; size = 4
$T229678 = -453						; size = 1
$T229671 = -452						; size = 4
$T229661 = -448						; size = 4
$T229636 = -442						; size = 1
$T229632 = -441						; size = 1
$T229628 = -440						; size = 1
$T229624 = -439						; size = 1
$T229620 = -438						; size = 1
$T229613 = -437						; size = 1
$T229603 = -436						; size = 4
$T229591 = -432						; size = 4
$T229587 = -428						; size = 4
$T229569 = -413						; size = 1
$T229522 = -396						; size = 4
$T229516 = -389						; size = 1
$T229512 = -388						; size = 4
$T229511 = -384						; size = 4
$T229480 = -380						; size = 4
$T229475 = -376						; size = 4
$T229471 = -369						; size = 1
$T229460 = -368						; size = 4
$T229456 = -361						; size = 1
_iMapY$229510 = -360					; size = 4
_iMapX$229509 = -356					; size = 4
$T229449 = -352						; size = 4
$T229445 = -348						; size = 4
$T229430 = -344						; size = 4
$T229424 = -337						; size = 1
$T229420 = -336						; size = 4
$T229419 = -332						; size = 4
$T229386 = -328						; size = 4
$T229373 = -324						; size = 4
$T229369 = -320						; size = 4
$T229362 = -316						; size = 4
$T229358 = -309						; size = 1
$T229354 = -308						; size = 4
$T229350 = -301						; size = 1
_iMapY$229405 = -300					; size = 4
_iMapX$229404 = -296					; size = 4
$T229343 = -292						; size = 4
$T229339 = -288						; size = 4
$T229325 = -284						; size = 4
$T229318 = -278						; size = 1
$T229309 = -277						; size = 1
$T229308 = -276						; size = 4
$T229307 = -272						; size = 4
$T229306 = -266						; size = 1
$T229305 = -265						; size = 1
$T229304 = -264						; size = 1
$T229303 = -263						; size = 1
$T229302 = -262						; size = 1
$T229301 = -261						; size = 1
_pkCity$224596 = -260					; size = 4
_iCityID$224595 = -256					; size = 4
_eOwner$224593 = -252					; size = 4
_kPlotData$224590 = -248				; size = 4
_pkPlot$224591 = -244					; size = 4
_i$224586 = -240					; size = 4
_uiTeam$224580 = -236					; size = 4
_pkUnit$224576 = -232					; size = 4
_pkRouteInfo$224571 = -228				; size = 4
_pkTreasury$224570 = -224				; size = 4
_eOwner$224568 = -220					; size = 4
_eRoute$224565 = -216					; size = 4
_iPlotY$224558 = -212					; size = 4
_byNaturalWonder$224559 = -205				; size = 1
_kPlotData$224554 = -204				; size = 4
_iPlotX$224557 = -200					; size = 4
_pkCity$224574 = -196					; size = 4
_pkPlot$224555 = -192					; size = 4
_i$224550 = -188					; size = 4
_eMajorCivPlayer$224547 = -184				; size = 4
_uiMajorCiv$224543 = -180				; size = 4
_kCityState$224540 = -176				; size = 4
_pkAI$224541 = -172					; size = 4
_eCityStatePlayer$224537 = -168				; size = 4
_uiCityState$224533 = -164				; size = 4
_eTeam2$224524 = -160					; size = 4
_kTeam1$224526 = -156					; size = 4
_eTeam1$224522 = -152					; size = 4
_kTeam2$224527 = -148					; size = 4
_uiTeam2$224518 = -144					; size = 4
_uiTeam1$224514 = -140					; size = 4
_iResourceAmount$224493 = -136				; size = 4
_ePlotHeight$224488 = -132				; size = 4
_kPlotData$224484 = -128				; size = 4
_pkPlot$224485 = -124					; size = 4
_i$224480 = -120					; size = 4
_ePlayer$224469 = -116					; size = 4
_kPlayer$224470 = -112					; size = 4
_i$224465 = -108					; size = 4
_pkStartingPlot$224296 = -104				; size = 4
_ePlayer$224291 = -100					; size = 4
_kSavedPlayer$224294 = -96				; size = 4
_kGameplayPlayer$224293 = -92				; size = 4
_i$224287 = -88						; size = 4
_pkStartingPlot$224282 = -84				; size = 4
_ePlayer$224277 = -80					; size = 4
_kSavedPlayer$224280 = -76				; size = 4
_kGameplayPlayer$224279 = -72				; size = 4
_i$224273 = -68						; size = 4
_kMap$ = -64						; size = 4
_uiMinorCivsPlaced$ = -60				; size = 4
_uiCityStateCount$ = -56				; size = 4
_uiPlotCount$ = -52					; size = 4
_kMinorCivs$ = -48					; size = 12
_uiMajorCivsPlaced$ = -36				; size = 4
_uiTeamCount$ = -32					; size = 4
_uiPlayerCount$ = -28					; size = 4
_kMajorCivs$ = -24					; size = 12
__$EHRec$ = -12						; size = 12
?InitMap@CvWorldBuilderMapLoader@@SA_NXZ PROC		; CvWorldBuilderMapLoader::InitMap, COMDAT

; 1054 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?InitMap@CvWorldBuilderMapLoader@@SA_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 724				; 000002d4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1055 : 	CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 1056 : 
; 1057 : 	FAssertMsg(
; 1058 : 	    sg_kSave.GetWidth() == kMap.getGridWidth() &&
; 1059 : 	    sg_kSave.GetHeight() == kMap.getGridHeight(),
; 1060 : 	    "Save wrong size");
; 1061 : 
; 1062 : 	OutputDebugStringA("Setting up players...\n");

	push	OFFSET ??_C@_0BH@KKCBKBMH@Setting?5up?5players?4?4?4?6?$AA@
	call	DWORD PTR __imp__OutputDebugStringA@4

; 1063 : 
; 1064 : #ifdef AUI_WARNING_FIXES
; 1065 : 	const byte uiPlayerCount = MIN(sg_kSave.GetPlayerCount(), (byte)MAX_CIV_PLAYERS);
; 1066 : 	for (byte i = 0; i < uiPlayerCount; ++i)
; 1067 : #else
; 1068 : 	const uint uiPlayerCount = std::min(sg_kSave.GetPlayerCount(), (byte)MAX_CIV_PLAYERS);

	mov	BYTE PTR $T229301[ebp], 63		; 0000003fH
	mov	cl, BYTE PTR _sg_kSave+12316
	mov	BYTE PTR $T229318[ebp], cl
	mov	dl, BYTE PTR $T229318[ebp]
	mov	BYTE PTR $T229302[ebp], dl
	movzx	eax, BYTE PTR $T229301[ebp]
	movzx	ecx, BYTE PTR $T229302[ebp]
	cmp	eax, ecx
	jge	SHORT $LN95@InitMap
	lea	edx, DWORD PTR $T229301[ebp]
	mov	DWORD PTR tv669[ebp], edx
	jmp	SHORT $LN96@InitMap
$LN95@InitMap:
	lea	eax, DWORD PTR $T229302[ebp]
	mov	DWORD PTR tv669[ebp], eax
$LN96@InitMap:
	mov	ecx, DWORD PTR tv669[ebp]
	mov	DWORD PTR $T229325[ebp], ecx
	mov	edx, DWORD PTR $T229325[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR _uiPlayerCount$[ebp], eax

; 1069 : 	for(uint i = 0; i < uiPlayerCount; ++i)

	mov	DWORD PTR _i$224273[ebp], 0
	jmp	SHORT $LN84@InitMap
$LN83@InitMap:
	mov	ecx, DWORD PTR _i$224273[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$224273[ebp], ecx
$LN84@InitMap:
	mov	edx, DWORD PTR _i$224273[ebp]
	cmp	edx, DWORD PTR _uiPlayerCount$[ebp]
	jae	$LN82@InitMap

; 1070 : #endif
; 1071 : 	{
; 1072 : 		const PlayerTypes ePlayer = (PlayerTypes)i;

	mov	eax, DWORD PTR _i$224273[ebp]
	mov	DWORD PTR _ePlayer$224277[ebp], eax

; 1073 : 		CvPlayer& kGameplayPlayer = GET_PLAYER(ePlayer);

	mov	ecx, DWORD PTR _ePlayer$224277[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kGameplayPlayer$224279[ebp], ecx

; 1074 : 		const CvWorldBuilderMap::Player& kSavedPlayer = sg_kSave.GetPlayer(i);

	movzx	edx, BYTE PTR _i$224273[ebp]
	movzx	eax, BYTE PTR _sg_kSave+12316
	cmp	edx, eax
	jge	SHORT $LN100@InitMap
	movzx	ecx, BYTE PTR _i$224273[ebp]
	cmp	ecx, 32					; 00000020H
	jae	SHORT $LN100@InitMap
	movzx	edx, BYTE PTR _i$224273[ebp]
	imul	edx, 436				; 000001b4H
	add	edx, OFFSET _sg_kSave+536608
	mov	DWORD PTR _kSavedPlayer$224280[ebp], edx
	jmp	SHORT $LN101@InitMap
	jmp	SHORT $LN101@InitMap
$LN100@InitMap:
	mov	DWORD PTR _kSavedPlayer$224280[ebp], OFFSET ?sm_kErrorPlayer@CvWorldBuilderMap@@0UPlayer@1@A ; CvWorldBuilderMap::sm_kErrorPlayer
$LN101@InitMap:

; 1075 : 
; 1076 : 		if(kSavedPlayer.m_uiStartX < sg_kSave.GetWidth() &&
; 1077 : 		        kSavedPlayer.m_uiStartY < sg_kSave.GetHeight())

	mov	eax, DWORD PTR _sg_kSave+12228
	mov	DWORD PTR $T229339[ebp], eax
	mov	ecx, DWORD PTR _kSavedPlayer$224280[ebp]
	mov	edx, DWORD PTR [ecx+424]
	cmp	edx, DWORD PTR $T229339[ebp]
	jae	$LN81@InitMap
	mov	eax, DWORD PTR _sg_kSave+12232
	mov	DWORD PTR $T229343[ebp], eax
	mov	ecx, DWORD PTR _kSavedPlayer$224280[ebp]
	mov	edx, DWORD PTR [ecx+428]
	cmp	edx, DWORD PTR $T229343[ebp]
	jae	$LN81@InitMap

; 1078 : 		{
; 1079 : 			CvPlot* pkStartingPlot = kMap.plot(kSavedPlayer.m_uiStartX, kSavedPlayer.m_uiStartY);

	mov	eax, DWORD PTR _kSavedPlayer$224280[ebp]
	mov	ecx, DWORD PTR [eax+428]
	mov	DWORD PTR $T229420[ebp], ecx
	mov	edx, DWORD PTR _kSavedPlayer$224280[ebp]
	mov	eax, DWORD PTR [edx+424]
	mov	DWORD PTR $T229419[ebp], eax
	cmp	DWORD PTR $T229419[ebp], -2147483647	; 80000001H
	je	SHORT $LN107@InitMap
	cmp	DWORD PTR $T229420[ebp], -2147483647	; 80000001H
	jne	SHORT $LN108@InitMap
$LN107@InitMap:
	mov	DWORD PTR _pkStartingPlot$224282[ebp], 0
	jmp	$LN109@InitMap
$LN108@InitMap:
	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T229350[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T229354[ebp], ecx
	movzx	edx, BYTE PTR $T229350[ebp]
	push	edx
	mov	eax, DWORD PTR $T229354[ebp]
	push	eax
	mov	ecx, DWORD PTR $T229419[ebp]
	push	ecx
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapX$229404[ebp], eax
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T229358[ebp], al
	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T229362[ebp], edx
	movzx	eax, BYTE PTR $T229358[ebp]
	push	eax
	mov	ecx, DWORD PTR $T229362[ebp]
	push	ecx
	mov	edx, DWORD PTR $T229420[ebp]
	push	edx
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapY$229405[ebp], eax
	cmp	DWORD PTR _iMapX$229404[ebp], 0
	jl	SHORT $LN123@InitMap
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T229369[ebp], ecx
	mov	edx, DWORD PTR _iMapX$229404[ebp]
	cmp	edx, DWORD PTR $T229369[ebp]
	jge	SHORT $LN123@InitMap
	cmp	DWORD PTR _iMapY$229405[ebp], 0
	jl	SHORT $LN123@InitMap
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T229373[ebp], ecx
	mov	edx, DWORD PTR _iMapY$229405[ebp]
	cmp	edx, DWORD PTR $T229373[ebp]
	jge	SHORT $LN123@InitMap
	mov	DWORD PTR tv718[ebp], 1
	jmp	SHORT $LN121@InitMap
$LN123@InitMap:
	mov	DWORD PTR tv718[ebp], 0
$LN121@InitMap:
	cmp	DWORD PTR tv718[ebp], 0
	je	SHORT $LN111@InitMap
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T229386[ebp], ecx
	mov	edx, DWORD PTR _iMapY$229405[ebp]
	imul	edx, DWORD PTR $T229386[ebp]
	add	edx, DWORD PTR _iMapX$229404[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR _kMap$[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv709[ebp], edx
	jmp	SHORT $LN112@InitMap
$LN111@InitMap:
	mov	DWORD PTR tv709[ebp], 0
$LN112@InitMap:
	mov	ecx, DWORD PTR tv709[ebp]
	mov	DWORD PTR _pkStartingPlot$224282[ebp], ecx
$LN109@InitMap:

; 1080 : 			kGameplayPlayer.setStartingPlot(pkStartingPlot);

	mov	edx, DWORD PTR _pkStartingPlot$224282[ebp]
	push	edx
	mov	ecx, DWORD PTR _kGameplayPlayer$224279[ebp]
	call	?setStartingPlot@CvPlayer@@QAEXPAVCvPlot@@@Z ; CvPlayer::setStartingPlot
$LN81@InitMap:

; 1081 : 		}
; 1082 : 	}

	jmp	$LN83@InitMap
$LN82@InitMap:

; 1083 : 
; 1084 : #ifdef AUI_WARNING_FIXES
; 1085 : 	const byte uiCityStateCount = MIN(sg_kSave.GetCityStateCount(), (byte)MAX_MINOR_CIVS);
; 1086 : 	for (byte i = 0; i < uiCityStateCount; ++i)
; 1087 : #else
; 1088 : 	const uint uiCityStateCount = std::min(sg_kSave.GetCityStateCount(), (byte)MAX_MINOR_CIVS);

	mov	BYTE PTR $T229303[ebp], 41		; 00000029H
	mov	al, BYTE PTR _sg_kSave+12317
	mov	BYTE PTR $T229424[ebp], al
	mov	cl, BYTE PTR $T229424[ebp]
	mov	BYTE PTR $T229304[ebp], cl
	movzx	edx, BYTE PTR $T229303[ebp]
	movzx	eax, BYTE PTR $T229304[ebp]
	cmp	edx, eax
	jge	SHORT $LN137@InitMap
	lea	ecx, DWORD PTR $T229303[ebp]
	mov	DWORD PTR tv704[ebp], ecx
	jmp	SHORT $LN138@InitMap
$LN137@InitMap:
	lea	edx, DWORD PTR $T229304[ebp]
	mov	DWORD PTR tv704[ebp], edx
$LN138@InitMap:
	mov	eax, DWORD PTR tv704[ebp]
	mov	DWORD PTR $T229430[ebp], eax
	mov	ecx, DWORD PTR $T229430[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _uiCityStateCount$[ebp], edx

; 1089 : 	for(uint i = 0; i < uiCityStateCount; ++i)

	mov	DWORD PTR _i$224287[ebp], 0
	jmp	SHORT $LN80@InitMap
$LN79@InitMap:
	mov	eax, DWORD PTR _i$224287[ebp]
	add	eax, 1
	mov	DWORD PTR _i$224287[ebp], eax
$LN80@InitMap:
	mov	ecx, DWORD PTR _i$224287[ebp]
	cmp	ecx, DWORD PTR _uiCityStateCount$[ebp]
	jae	$LN78@InitMap

; 1090 : #endif
; 1091 : 	{
; 1092 : 		const PlayerTypes ePlayer = (PlayerTypes)(i + MAX_MAJOR_CIVS);

	mov	edx, DWORD PTR _i$224287[ebp]
	add	edx, 22					; 00000016H
	mov	DWORD PTR _ePlayer$224291[ebp], edx

; 1093 : 		CvPlayer& kGameplayPlayer = GET_PLAYER(ePlayer);

	mov	eax, DWORD PTR _ePlayer$224291[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kGameplayPlayer$224293[ebp], eax

; 1094 : 		const CvWorldBuilderMap::Player& kSavedPlayer = sg_kSave.GetCityState(i);

	movzx	ecx, BYTE PTR _i$224287[ebp]
	movzx	edx, BYTE PTR _sg_kSave+12317
	cmp	ecx, edx
	jge	SHORT $LN142@InitMap
	movzx	eax, BYTE PTR _i$224287[ebp]
	cmp	eax, 64					; 00000040H
	jae	SHORT $LN142@InitMap
	movzx	ecx, BYTE PTR _i$224287[ebp]
	imul	ecx, 436				; 000001b4H
	add	ecx, OFFSET _sg_kSave+550560
	mov	DWORD PTR _kSavedPlayer$224294[ebp], ecx
	jmp	SHORT $LN143@InitMap
	jmp	SHORT $LN143@InitMap
$LN142@InitMap:
	mov	DWORD PTR _kSavedPlayer$224294[ebp], OFFSET ?sm_kErrorPlayer@CvWorldBuilderMap@@0UPlayer@1@A ; CvWorldBuilderMap::sm_kErrorPlayer
$LN143@InitMap:

; 1095 : 
; 1096 : 		if(kSavedPlayer.m_uiStartX < sg_kSave.GetWidth() &&
; 1097 : 		        kSavedPlayer.m_uiStartY < sg_kSave.GetHeight())

	mov	edx, DWORD PTR _sg_kSave+12228
	mov	DWORD PTR $T229445[ebp], edx
	mov	eax, DWORD PTR _kSavedPlayer$224294[ebp]
	mov	ecx, DWORD PTR [eax+424]
	cmp	ecx, DWORD PTR $T229445[ebp]
	jae	$LN77@InitMap
	mov	edx, DWORD PTR _sg_kSave+12232
	mov	DWORD PTR $T229449[ebp], edx
	mov	eax, DWORD PTR _kSavedPlayer$224294[ebp]
	mov	ecx, DWORD PTR [eax+428]
	cmp	ecx, DWORD PTR $T229449[ebp]
	jae	$LN77@InitMap

; 1098 : 		{
; 1099 : 			CvPlot* pkStartingPlot = kMap.plot(kSavedPlayer.m_uiStartX, kSavedPlayer.m_uiStartY);

	mov	edx, DWORD PTR _kSavedPlayer$224294[ebp]
	mov	eax, DWORD PTR [edx+428]
	mov	DWORD PTR $T229512[ebp], eax
	mov	ecx, DWORD PTR _kSavedPlayer$224294[ebp]
	mov	edx, DWORD PTR [ecx+424]
	mov	DWORD PTR $T229511[ebp], edx
	cmp	DWORD PTR $T229511[ebp], -2147483647	; 80000001H
	je	SHORT $LN149@InitMap
	cmp	DWORD PTR $T229512[ebp], -2147483647	; 80000001H
	jne	SHORT $LN150@InitMap
$LN149@InitMap:
	mov	DWORD PTR _pkStartingPlot$224296[ebp], 0
	jmp	$LN151@InitMap
$LN150@InitMap:
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	cl, BYTE PTR [eax+4056]
	mov	BYTE PTR $T229456[ebp], cl
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T229460[ebp], eax
	movzx	ecx, BYTE PTR $T229456[ebp]
	test	ecx, ecx
	je	SHORT $LN162@InitMap
	cmp	DWORD PTR $T229511[ebp], 0
	jge	SHORT $LN161@InitMap
	mov	eax, DWORD PTR $T229511[ebp]
	cdq
	idiv	DWORD PTR $T229460[ebp]
	add	edx, DWORD PTR $T229460[ebp]
	mov	DWORD PTR _iMapX$229509[ebp], edx
	jmp	SHORT $LN163@InitMap
	jmp	SHORT $LN162@InitMap
$LN161@InitMap:
	mov	edx, DWORD PTR $T229511[ebp]
	cmp	edx, DWORD PTR $T229460[ebp]
	jl	SHORT $LN162@InitMap
	mov	eax, DWORD PTR $T229511[ebp]
	cdq
	idiv	DWORD PTR $T229460[ebp]
	mov	DWORD PTR _iMapX$229509[ebp], edx
	jmp	SHORT $LN163@InitMap
$LN162@InitMap:
	mov	eax, DWORD PTR $T229511[ebp]
	mov	DWORD PTR _iMapX$229509[ebp], eax
$LN163@InitMap:
	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T229471[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T229475[ebp], ecx
	movzx	edx, BYTE PTR $T229471[ebp]
	push	edx
	mov	eax, DWORD PTR $T229475[ebp]
	push	eax
	mov	ecx, DWORD PTR $T229512[ebp]
	push	ecx
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapY$229510[ebp], eax
	mov	edx, DWORD PTR _iMapY$229510[ebp]
	push	edx
	mov	eax, DWORD PTR _iMapX$229509[ebp]
	push	eax
	mov	ecx, DWORD PTR _kMap$[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN153@InitMap
	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T229480[ebp], edx
	mov	eax, DWORD PTR _iMapY$229510[ebp]
	imul	eax, DWORD PTR $T229480[ebp]
	add	eax, DWORD PTR _iMapX$229509[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR _kMap$[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv757[ebp], eax
	jmp	SHORT $LN154@InitMap
$LN153@InitMap:
	mov	DWORD PTR tv757[ebp], 0
$LN154@InitMap:
	mov	edx, DWORD PTR tv757[ebp]
	mov	DWORD PTR _pkStartingPlot$224296[ebp], edx
$LN151@InitMap:

; 1100 : 			kGameplayPlayer.setStartingPlot(pkStartingPlot);

	mov	eax, DWORD PTR _pkStartingPlot$224296[ebp]
	push	eax
	mov	ecx, DWORD PTR _kGameplayPlayer$224293[ebp]
	call	?setStartingPlot@CvPlayer@@QAEXPAVCvPlot@@@Z ; CvPlayer::setStartingPlot
$LN77@InitMap:

; 1101 : 		}
; 1102 : 	}

	jmp	$LN79@InitMap
$LN78@InitMap:

; 1103 : 
; 1104 : #ifdef NQM_FAST_COMP
; 1105 : 	const uint uiTeamCount = MIN(sg_kSave.GetTeamCount(), (byte)MAX_TEAMS);
; 1106 : #else
; 1107 : 	const uint uiTeamCount = std::min(sg_kSave.GetTeamCount(), (byte)MAX_TEAMS);

	mov	BYTE PTR $T229305[ebp], 64		; 00000040H
	mov	cl, BYTE PTR _sg_kSave+12318
	mov	BYTE PTR $T229516[ebp], cl
	mov	dl, BYTE PTR $T229516[ebp]
	mov	BYTE PTR $T229306[ebp], dl
	movzx	eax, BYTE PTR $T229305[ebp]
	movzx	ecx, BYTE PTR $T229306[ebp]
	cmp	eax, ecx
	jge	SHORT $LN177@InitMap
	lea	edx, DWORD PTR $T229305[ebp]
	mov	DWORD PTR tv752[ebp], edx
	jmp	SHORT $LN178@InitMap
$LN177@InitMap:
	lea	eax, DWORD PTR $T229306[ebp]
	mov	DWORD PTR tv752[ebp], eax
$LN178@InitMap:
	mov	ecx, DWORD PTR tv752[ebp]
	mov	DWORD PTR $T229522[ebp], ecx
	mov	edx, DWORD PTR $T229522[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR _uiTeamCount$[ebp], eax

; 1108 : #endif
; 1109 : 
; 1110 : 	// HACK: Call SetInitialItems early.  It has to be called later too :_(
; 1111 : 	// This is because of what is essentially a circular dependency.  Techs
; 1112 : 	// need to be initialized before units are created (for the embarkation
; 1113 : 	// promotion among other things).  However, units must be created before
; 1114 : 	// CvGame sets up the initial player state otherwise a scenario player may
; 1115 : 	// be given starting units they don't need and shouldn't have.  Unfortunately
; 1116 : 	// this also does stuff like reset starting techs.  Therefore SetInitialItems
; 1117 : 	// must be called AGAIN to put the player state back to where it should be.
; 1118 : 	// This second call is done from CvInitMgr::GameCoreNew.  You may be tempted to
; 1119 : 	// remove this hack but be very careful if you do and test thoroughly with scenario saves.
; 1120 : 	SetInitialItems(true);

	push	1
	call	?SetInitialItems@CvWorldBuilderMapLoader@@SAX_N@Z ; CvWorldBuilderMapLoader::SetInitialItems
	add	esp, 4

; 1121 : 
; 1122 : 	FFastVector<CvPlayer*> kMajorCivs;

	push	0
	lea	ecx, DWORD PTR _kMajorCivs$[ebp]
	call	??0?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAE@I@Z ; FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>::FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1123 : 	FFastVector<CvPlayer*> kMinorCivs;

	push	0
	lea	ecx, DWORD PTR _kMinorCivs$[ebp]
	call	??0?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAE@I@Z ; FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>::FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1124 : 	for(uint i = 0; i < MAX_CIV_PLAYERS; ++i)

	mov	DWORD PTR _i$224465[ebp], 0
	jmp	SHORT $LN76@InitMap
$LN75@InitMap:
	mov	ecx, DWORD PTR _i$224465[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$224465[ebp], ecx
$LN76@InitMap:
	cmp	DWORD PTR _i$224465[ebp], 63		; 0000003fH
	jae	$LN74@InitMap

; 1125 : 	{
; 1126 : 		PlayerTypes ePlayer = PlayerTypes(i);

	mov	edx, DWORD PTR _i$224465[ebp]
	mov	DWORD PTR _ePlayer$224469[ebp], edx

; 1127 : 		CvPlayer& kPlayer = GET_PLAYER(ePlayer);

	mov	eax, DWORD PTR _ePlayer$224469[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$224470[ebp], eax

; 1128 : 		if(kPlayer.isAlive() && kPlayer.getStartingPlot() == NULL)

	mov	ecx, DWORD PTR _kPlayer$224470[ebp]
	mov	dl, BYTE PTR [ecx+2256]
	mov	BYTE PTR $T229569[ebp], dl
	movzx	eax, BYTE PTR $T229569[ebp]
	test	eax, eax
	je	SHORT $LN73@InitMap
	mov	ecx, DWORD PTR _kPlayer$224470[ebp]
	call	?getStartingPlot@CvPlayer@@QBEPAVCvPlot@@XZ ; CvPlayer::getStartingPlot
	test	eax, eax
	jne	SHORT $LN73@InitMap

; 1129 : 		{
; 1130 : 			if(kPlayer.isMinorCiv())

	mov	ecx, DWORD PTR _kPlayer$224470[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN72@InitMap

; 1131 : 				kMinorCivs.push_back(&kPlayer);

	mov	edx, DWORD PTR _kPlayer$224470[ebp]
	mov	DWORD PTR $T229307[ebp], edx
	lea	eax, DWORD PTR $T229307[ebp]
	push	eax
	lea	ecx, DWORD PTR _kMinorCivs$[ebp]
	call	?push_back@?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAEIABQAVCvPlayer@@@Z ; FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>::push_back

; 1132 : 			else

	jmp	SHORT $LN73@InitMap
$LN72@InitMap:

; 1133 : 				kMajorCivs.push_back(&kPlayer);

	mov	ecx, DWORD PTR _kPlayer$224470[ebp]
	mov	DWORD PTR $T229308[ebp], ecx
	lea	edx, DWORD PTR $T229308[ebp]
	push	edx
	lea	ecx, DWORD PTR _kMajorCivs$[ebp]
	call	?push_back@?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAEIABQAVCvPlayer@@@Z ; FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>::push_back
$LN73@InitMap:

; 1134 : 		}
; 1135 : 	}

	jmp	$LN75@InitMap
$LN74@InitMap:

; 1136 : 
; 1137 : 	uint uiMajorCivsPlaced = 0;

	mov	DWORD PTR _uiMajorCivsPlaced$[ebp], 0

; 1138 : 	uint uiMinorCivsPlaced = 0;

	mov	DWORD PTR _uiMinorCivsPlaced$[ebp], 0

; 1139 : 
; 1140 : 	OutputDebugStringA("Setting up map...\n");

	push	OFFSET ??_C@_0BD@LPGKJLCN@Setting?5up?5map?4?4?4?6?$AA@
	call	DWORD PTR __imp__OutputDebugStringA@4

; 1141 : 	uint uiPlotCount = sg_kSave.GetWidth() * sg_kSave.GetHeight();

	mov	eax, DWORD PTR _sg_kSave+12228
	mov	DWORD PTR $T229587[ebp], eax
	mov	ecx, DWORD PTR _sg_kSave+12232
	mov	DWORD PTR $T229591[ebp], ecx
	mov	edx, DWORD PTR $T229587[ebp]
	imul	edx, DWORD PTR $T229591[ebp]
	mov	DWORD PTR _uiPlotCount$[ebp], edx

; 1142 : 	for(uint i = 0; i < uiPlotCount; ++i)

	mov	DWORD PTR _i$224480[ebp], 0
	jmp	SHORT $LN70@InitMap
$LN69@InitMap:
	mov	eax, DWORD PTR _i$224480[ebp]
	add	eax, 1
	mov	DWORD PTR _i$224480[ebp], eax
$LN70@InitMap:
	mov	ecx, DWORD PTR _i$224480[ebp]
	cmp	ecx, DWORD PTR _uiPlotCount$[ebp]
	jae	$LN68@InitMap

; 1143 : 	{
; 1144 : 		const CvWorldBuilderMap::PlotMapData& kPlotData = sg_kSave.GetPlotData(i);

	mov	edx, DWORD PTR _sg_kSave+12228
	imul	edx, DWORD PTR _sg_kSave+12232
	cmp	DWORD PTR _i$224480[ebp], edx
	jae	SHORT $LN224@InitMap
	cmp	DWORD PTR _i$224480[ebp], 32768		; 00008000H
	jae	SHORT $LN224@InitMap
	mov	eax, DWORD PTR _i$224480[ebp]
	lea	ecx, DWORD PTR _sg_kSave[eax*8+12320]
	mov	DWORD PTR _kPlotData$224484[ebp], ecx
	jmp	SHORT $LN225@InitMap
	jmp	SHORT $LN225@InitMap
$LN224@InitMap:
	mov	DWORD PTR _kPlotData$224484[ebp], OFFSET ?sm_kErrorPlotMapData@CvWorldBuilderMap@@0VPlotMapData@1@A ; CvWorldBuilderMap::sm_kErrorPlotMapData
$LN225@InitMap:

; 1145 : 		CvPlot* pkPlot = kMap.plotByIndex(i);

	cmp	DWORD PTR _i$224480[ebp], 0
	jl	SHORT $LN229@InitMap
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4028]
	mov	DWORD PTR $T229603[ebp], eax
	mov	ecx, DWORD PTR _i$224480[ebp]
	cmp	ecx, DWORD PTR $T229603[ebp]
	jge	SHORT $LN229@InitMap
	mov	edx, DWORD PTR _i$224480[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR _kMap$[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv897[ebp], edx
	jmp	SHORT $LN227@InitMap
$LN229@InitMap:
	mov	DWORD PTR tv897[ebp], 0
$LN227@InitMap:
	mov	ecx, DWORD PTR tv897[ebp]
	mov	DWORD PTR _pkPlot$224485[ebp], ecx

; 1146 : 		FAssertMsg(pkPlot, "Missing CvPlot for this location");
; 1147 : 		if(pkPlot == NULL) continue;

	cmp	DWORD PTR _pkPlot$224485[ebp], 0
	jne	SHORT $LN67@InitMap
	jmp	$LN69@InitMap
$LN67@InitMap:

; 1148 : 
; 1149 : 		pkPlot->setTerrainType((TerrainTypes)kPlotData.GetTerrainType(), false, false);

	mov	edx, DWORD PTR _kPlotData$224484[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR $T229613[ebp], al
	push	0
	push	0
	movzx	ecx, BYTE PTR $T229613[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkPlot$224485[ebp]
	call	?setTerrainType@CvPlot@@QAEXW4TerrainTypes@@_N1@Z ; CvPlot::setTerrainType

; 1150 : 
; 1151 : 		CvWorldBuilderMap::PlotMapData::PlotHeight ePlotHeight = kPlotData.GetPlotHeight();

	mov	edx, DWORD PTR _kPlotData$224484[ebp]
	movzx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR _ePlotHeight$224488[ebp], eax

; 1152 : 		if(ePlotHeight != CvWorldBuilderMap::PlotMapData::FLAT_TERRAIN)

	cmp	DWORD PTR _ePlotHeight$224488[ebp], 0
	je	SHORT $LN66@InitMap

; 1153 : 		{
; 1154 : 			if(ePlotHeight == CvWorldBuilderMap::PlotMapData::HILLS)

	cmp	DWORD PTR _ePlotHeight$224488[ebp], 1
	jne	SHORT $LN65@InitMap

; 1155 : 				pkPlot->setPlotType(PLOT_HILLS);

	push	1
	push	1
	push	1
	push	1
	mov	ecx, DWORD PTR _pkPlot$224485[ebp]
	call	?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z ; CvPlot::setPlotType

; 1156 : 			else

	jmp	SHORT $LN66@InitMap
$LN65@InitMap:

; 1157 : 				pkPlot->setPlotType(PLOT_MOUNTAIN);

	push	1
	push	1
	push	1
	push	0
	mov	ecx, DWORD PTR _pkPlot$224485[ebp]
	call	?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z ; CvPlot::setPlotType
$LN66@InitMap:

; 1158 : 		}
; 1159 : 
; 1160 : 		if(kPlotData.GetResourceType() != CvWorldBuilderMap::PlotMapData::InvalidResource)

	mov	ecx, DWORD PTR _kPlotData$224484[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR $T229620[ebp], dl
	movzx	eax, BYTE PTR $T229620[ebp]
	cmp	eax, 255				; 000000ffH
	je	SHORT $LN63@InitMap

; 1161 : 		{
; 1162 : 			int iResourceAmount = kPlotData.GetResourceAmount();

	mov	ecx, DWORD PTR _kPlotData$224484[ebp]
	mov	dl, BYTE PTR [ecx+7]
	mov	BYTE PTR $T229624[ebp], dl
	movzx	eax, BYTE PTR $T229624[ebp]
	mov	DWORD PTR _iResourceAmount$224493[ebp], eax

; 1163 : 			if(iResourceAmount <= 0)

	cmp	DWORD PTR _iResourceAmount$224493[ebp], 0
	jg	SHORT $LN62@InitMap

; 1164 : 				iResourceAmount = 1;

	mov	DWORD PTR _iResourceAmount$224493[ebp], 1
$LN62@InitMap:

; 1165 : 
; 1166 : 			pkPlot->setResourceType((ResourceTypes)kPlotData.GetResourceType(), iResourceAmount);

	mov	ecx, DWORD PTR _kPlotData$224484[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR $T229628[ebp], dl
	push	0
	mov	eax, DWORD PTR _iResourceAmount$224493[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T229628[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkPlot$224485[ebp]
	call	?setResourceType@CvPlot@@QAEXW4ResourceTypes@@H_N@Z ; CvPlot::setResourceType
$LN63@InitMap:

; 1167 : 		}
; 1168 : 
; 1169 : 		if(kPlotData.GetFeatureType() != CvWorldBuilderMap::PlotMapData::InvalidFeature)

	mov	edx, DWORD PTR _kPlotData$224484[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR $T229632[ebp], al
	movzx	ecx, BYTE PTR $T229632[ebp]
	cmp	ecx, 255				; 000000ffH
	je	SHORT $LN247@InitMap

; 1170 : 			pkPlot->setFeatureType((FeatureTypes)kPlotData.GetFeatureType());

	mov	edx, DWORD PTR _kPlotData$224484[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR $T229636[ebp], al
	push	-1
	movzx	ecx, BYTE PTR $T229636[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkPlot$224485[ebp]
	call	?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z ; CvPlot::setFeatureType

; 1171 : 
; 1172 : 		if(kPlotData.GetFlag(CvWorldBuilderMap::PlotMapData::W_OF_RIVER))

$LN247@InitMap:
	mov	edx, DWORD PTR _kPlotData$224484[ebp]
	movzx	eax, BYTE PTR [edx+3]
	and	eax, 1
	neg	eax
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN251@InitMap

; 1173 : 		{
; 1174 : 			if(kPlotData.GetFlag(CvWorldBuilderMap::PlotMapData::RIVER_FLOW_S))

	mov	edx, DWORD PTR _kPlotData$224484[ebp]
	movzx	eax, BYTE PTR [edx+3]
	and	eax, 8
	neg	eax
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN59@InitMap

; 1175 : 				pkPlot->setWOfRiver(true, FLOWDIRECTION_SOUTH);

	push	3
	push	1
	mov	ecx, DWORD PTR _pkPlot$224485[ebp]
	call	?setWOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z ; CvPlot::setWOfRiver

; 1176 : 			else

	jmp	SHORT $LN251@InitMap
$LN59@InitMap:

; 1177 : 				pkPlot->setWOfRiver(true, FLOWDIRECTION_NORTH);

	push	0
	push	1
	mov	ecx, DWORD PTR _pkPlot$224485[ebp]
	call	?setWOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z ; CvPlot::setWOfRiver

; 1178 : 		}
; 1179 : 
; 1180 : 		if(kPlotData.GetFlag(CvWorldBuilderMap::PlotMapData::NW_OF_RIVER))

$LN251@InitMap:
	mov	edx, DWORD PTR _kPlotData$224484[ebp]
	movzx	eax, BYTE PTR [edx+3]
	and	eax, 2
	neg	eax
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN255@InitMap

; 1181 : 		{
; 1182 : 			if(kPlotData.GetFlag(CvWorldBuilderMap::PlotMapData::RIVER_FLOW_NE))

	mov	edx, DWORD PTR _kPlotData$224484[ebp]
	movzx	eax, BYTE PTR [edx+3]
	and	eax, 16					; 00000010H
	neg	eax
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN56@InitMap

; 1183 : 				pkPlot->setNWOfRiver(true, FLOWDIRECTION_NORTHEAST);

	push	1
	push	1
	mov	ecx, DWORD PTR _pkPlot$224485[ebp]
	call	?setNWOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z ; CvPlot::setNWOfRiver

; 1184 : 			else

	jmp	SHORT $LN255@InitMap
$LN56@InitMap:

; 1185 : 				pkPlot->setNWOfRiver(true, FLOWDIRECTION_SOUTHWEST);

	push	4
	push	1
	mov	ecx, DWORD PTR _pkPlot$224485[ebp]
	call	?setNWOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z ; CvPlot::setNWOfRiver

; 1186 : 		}
; 1187 : 
; 1188 : 		if(kPlotData.GetFlag(CvWorldBuilderMap::PlotMapData::NE_OF_RIVER))

$LN255@InitMap:
	mov	edx, DWORD PTR _kPlotData$224484[ebp]
	movzx	eax, BYTE PTR [edx+3]
	and	eax, 4
	neg	eax
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN259@InitMap

; 1189 : 		{
; 1190 : 			if(kPlotData.GetFlag(CvWorldBuilderMap::PlotMapData::RIVER_FLOW_NW))

	mov	edx, DWORD PTR _kPlotData$224484[ebp]
	movzx	eax, BYTE PTR [edx+3]
	and	eax, 32					; 00000020H
	neg	eax
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN53@InitMap

; 1191 : 				pkPlot->setNEOfRiver(true, FLOWDIRECTION_NORTHWEST);

	push	5
	push	1
	mov	ecx, DWORD PTR _pkPlot$224485[ebp]
	call	?setNEOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z ; CvPlot::setNEOfRiver

; 1192 : 			else

	jmp	SHORT $LN259@InitMap
$LN53@InitMap:

; 1193 : 				pkPlot->setNEOfRiver(true, FLOWDIRECTION_SOUTHEAST);

	push	2
	push	1
	mov	ecx, DWORD PTR _pkPlot$224485[ebp]
	call	?setNEOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z ; CvPlot::setNEOfRiver

; 1194 : 		}
; 1195 : 
; 1196 : 		if(kPlotData.GetFlag(CvWorldBuilderMap::PlotMapData::START_POS_MAJOR))

$LN259@InitMap:
	mov	edx, DWORD PTR _kPlotData$224484[ebp]
	movzx	eax, BYTE PTR [edx+3]
	and	eax, 64					; 00000040H
	neg	eax
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN265@InitMap

; 1197 : 		{
; 1198 : 			if(uiMajorCivsPlaced < kMajorCivs.size())

	mov	edx, DWORD PTR _kMajorCivs$[ebp+4]
	mov	DWORD PTR $T229661[ebp], edx
	mov	eax, DWORD PTR _uiMajorCivsPlaced$[ebp]
	cmp	eax, DWORD PTR $T229661[ebp]
	jae	SHORT $LN50@InitMap

; 1199 : 			{
; 1200 : 				kMajorCivs[uiMajorCivsPlaced]->setStartingPlot(pkPlot);

	mov	ecx, DWORD PTR _pkPlot$224485[ebp]
	push	ecx
	mov	edx, DWORD PTR _uiMajorCivsPlaced$[ebp]
	mov	eax, DWORD PTR _kMajorCivs$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	call	?setStartingPlot@CvPlayer@@QAEXPAVCvPlot@@@Z ; CvPlayer::setStartingPlot

; 1201 : 				uiMajorCivsPlaced++;

	mov	ecx, DWORD PTR _uiMajorCivsPlaced$[ebp]
	add	ecx, 1
	mov	DWORD PTR _uiMajorCivsPlaced$[ebp], ecx
$LN50@InitMap:

; 1202 : 			}
; 1203 : 		}

	jmp	SHORT $LN49@InitMap

; 1204 : 		else if(kPlotData.GetFlag(CvWorldBuilderMap::PlotMapData::START_POS_MINOR))

$LN265@InitMap:
	mov	edx, DWORD PTR _kPlotData$224484[ebp]
	movzx	eax, BYTE PTR [edx+3]
	and	eax, 128				; 00000080H
	neg	eax
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN49@InitMap

; 1205 : 		{
; 1206 : 			if(uiMinorCivsPlaced < kMinorCivs.size())

	mov	edx, DWORD PTR _kMinorCivs$[ebp+4]
	mov	DWORD PTR $T229671[ebp], edx
	mov	eax, DWORD PTR _uiMinorCivsPlaced$[ebp]
	cmp	eax, DWORD PTR $T229671[ebp]
	jae	SHORT $LN49@InitMap

; 1207 : 			{
; 1208 : 				kMinorCivs[uiMinorCivsPlaced]->setStartingPlot(pkPlot);

	mov	ecx, DWORD PTR _pkPlot$224485[ebp]
	push	ecx
	mov	edx, DWORD PTR _uiMinorCivsPlaced$[ebp]
	mov	eax, DWORD PTR _kMinorCivs$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	call	?setStartingPlot@CvPlayer@@QAEXPAVCvPlot@@@Z ; CvPlayer::setStartingPlot

; 1209 : 				uiMinorCivsPlaced++;

	mov	ecx, DWORD PTR _uiMinorCivsPlaced$[ebp]
	add	ecx, 1
	mov	DWORD PTR _uiMinorCivsPlaced$[ebp], ecx
$LN49@InitMap:

; 1210 : 			}
; 1211 : 		}
; 1212 : 
; 1213 : 		pkPlot->SetContinentType(kPlotData.GetContinentType());

	mov	edx, DWORD PTR _kPlotData$224484[ebp]
	mov	al, BYTE PTR [edx+5]
	mov	BYTE PTR $T229678[ebp], al
	movzx	ecx, BYTE PTR $T229678[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkPlot$224485[ebp]
	call	?SetContinentType@CvPlot@@QAEXD@Z	; CvPlot::SetContinentType

; 1214 : 	}

	jmp	$LN69@InitMap
$LN68@InitMap:

; 1215 : 
; 1216 : 	OutputDebugStringA("Calculating Areas...\n");

	push	OFFSET ??_C@_0BG@NBCEOEJG@Calculating?5Areas?4?4?4?6?$AA@
	call	DWORD PTR __imp__OutputDebugStringA@4

; 1217 : 
; 1218 : 	kMap.recalculateAreas();

	mov	ecx, DWORD PTR _kMap$[ebp]
	call	?recalculateAreas@CvMap@@QAEXXZ		; CvMap::recalculateAreas

; 1219 : 
; 1220 : 	OutputDebugStringA("Adding Scenario Elements...\n");

	push	OFFSET ??_C@_0BN@JLCKEMAB@Adding?5Scenario?5Elements?4?4?4?6?$AA@
	call	DWORD PTR __imp__OutputDebugStringA@4

; 1221 : 
; 1222 : 	GC.getGame().GetTacticalAnalysisMap()->Init(GC.getMap().numPlots());

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T229682[ebp], edx
	mov	eax, DWORD PTR $T229682[ebp]
	mov	ecx, DWORD PTR [eax+4028]
	mov	DWORD PTR $T229686[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T229690[ebp], edx
	mov	eax, DWORD PTR $T229686[ebp]
	push	eax
	mov	ecx, DWORD PTR $T229690[ebp]
	call	?GetTacticalAnalysisMap@CvGame@@QAEPAVCvTacticalAnalysisMap@@XZ ; CvGame::GetTacticalAnalysisMap
	mov	ecx, eax
	call	?Init@CvTacticalAnalysisMap@@QAEXH@Z	; CvTacticalAnalysisMap::Init

; 1223 : 
; 1224 : 	// Init Diplomacy
; 1225 : 	for(uint uiTeam1 = 0; uiTeam1 < uiTeamCount; ++uiTeam1)

	mov	DWORD PTR _uiTeam1$224514[ebp], 0
	jmp	SHORT $LN46@InitMap
$LN45@InitMap:
	mov	ecx, DWORD PTR _uiTeam1$224514[ebp]
	add	ecx, 1
	mov	DWORD PTR _uiTeam1$224514[ebp], ecx
$LN46@InitMap:
	mov	edx, DWORD PTR _uiTeam1$224514[ebp]
	cmp	edx, DWORD PTR _uiTeamCount$[ebp]
	jae	$LN44@InitMap

; 1226 : 	{
; 1227 : 		for(uint uiTeam2 = uiTeam1 + 1; uiTeam2 < uiTeamCount; ++uiTeam2)

	mov	eax, DWORD PTR _uiTeam1$224514[ebp]
	add	eax, 1
	mov	DWORD PTR _uiTeam2$224518[ebp], eax
	jmp	SHORT $LN43@InitMap
$LN42@InitMap:
	mov	ecx, DWORD PTR _uiTeam2$224518[ebp]
	add	ecx, 1
	mov	DWORD PTR _uiTeam2$224518[ebp], ecx
$LN43@InitMap:
	mov	edx, DWORD PTR _uiTeam2$224518[ebp]
	cmp	edx, DWORD PTR _uiTeamCount$[ebp]
	jae	$LN41@InitMap

; 1228 : 		{
; 1229 : 			const TeamTypes eTeam1 = (TeamTypes)uiTeam1;

	mov	eax, DWORD PTR _uiTeam1$224514[ebp]
	mov	DWORD PTR _eTeam1$224522[ebp], eax

; 1230 : 			const TeamTypes eTeam2 = (TeamTypes)uiTeam2;

	mov	ecx, DWORD PTR _uiTeam2$224518[ebp]
	mov	DWORD PTR _eTeam2$224524[ebp], ecx

; 1231 : 			CvTeam& kTeam1 = GET_TEAM(eTeam1);

	mov	edx, DWORD PTR _eTeam1$224522[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR _kTeam1$224526[ebp], edx

; 1232 : 			CvTeam& kTeam2 = GET_TEAM(eTeam2);

	mov	eax, DWORD PTR _eTeam2$224524[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR _kTeam2$224527[ebp], eax

; 1233 : 
; 1234 : 			if(sg_kSave.m_kTeamsInContact.Get(uiTeam1, uiTeam2))

	mov	ecx, DWORD PTR _uiTeam1$224514[ebp]
	cmp	ecx, DWORD PTR _uiTeam2$224518[ebp]
	jne	SHORT $LN284@InitMap
	mov	BYTE PTR $T229728[ebp], 1
	jmp	$LN285@InitMap
	jmp	$LN285@InitMap
$LN284@InitMap:
	mov	edx, DWORD PTR _uiTeam1$224514[ebp]
	cmp	edx, DWORD PTR _uiTeam2$224518[ebp]
	jbe	SHORT $LN288@InitMap
	mov	eax, DWORD PTR _uiTeam1$224514[ebp]
	mov	DWORD PTR _uiLarge$229713[ebp], eax
	mov	ecx, DWORD PTR _uiTeam2$224518[ebp]
	mov	DWORD PTR _uiSmall$229714[ebp], ecx
	jmp	SHORT $LN291@InitMap
$LN288@InitMap:
	mov	edx, DWORD PTR _uiTeam2$224518[ebp]
	mov	DWORD PTR _uiLarge$229713[ebp], edx
	mov	eax, DWORD PTR _uiTeam1$224514[ebp]
	mov	DWORD PTR _uiSmall$229714[ebp], eax
$LN291@InitMap:
	mov	ecx, DWORD PTR _uiLarge$229713[ebp]
	sub	ecx, 1
	imul	ecx, DWORD PTR _uiLarge$229713[ebp]
	shr	ecx, 1
	mov	DWORD PTR _uiStart$229717[ebp], ecx
	mov	edx, DWORD PTR _uiStart$229717[ebp]
	add	edx, DWORD PTR _uiSmall$229714[ebp]
	mov	DWORD PTR _uiBitIndex$229724[ebp], edx
	mov	eax, DWORD PTR _uiBitIndex$229724[ebp]
	shr	eax, 3
	mov	DWORD PTR _uiByte$229725[ebp], eax
	mov	eax, DWORD PTR _uiBitIndex$229724[ebp]
	xor	edx, edx
	mov	ecx, 8
	div	ecx
	mov	DWORD PTR _uiBit$229726[ebp], edx
	mov	edx, 1
	mov	ecx, DWORD PTR _uiBit$229726[ebp]
	shl	edx, cl
	mov	BYTE PTR _byMask$229727[ebp], dl
	mov	eax, DWORD PTR _uiByte$229725[ebp]
	movzx	ecx, BYTE PTR _sg_kSave[eax]
	movzx	edx, BYTE PTR _byMask$229727[ebp]
	and	ecx, edx
	setne	al
	mov	BYTE PTR $T229728[ebp], al
$LN285@InitMap:
	movzx	ecx, BYTE PTR $T229728[ebp]
	test	ecx, ecx
	je	SHORT $LN40@InitMap

; 1235 : 				kTeam1.meet(eTeam2, true);

	push	1
	mov	edx, DWORD PTR _eTeam2$224524[ebp]
	push	edx
	mov	ecx, DWORD PTR _kTeam1$224526[ebp]
	call	?meet@CvTeam@@QAEXW4TeamTypes@@_N@Z	; CvTeam::meet
$LN40@InitMap:

; 1236 : 
; 1237 : 			if(sg_kSave.m_kTeamsAtWar.Get(uiTeam1, uiTeam2))

	mov	eax, DWORD PTR _uiTeam1$224514[ebp]
	cmp	eax, DWORD PTR _uiTeam2$224518[ebp]
	jne	SHORT $LN294@InitMap
	mov	BYTE PTR $T229760[ebp], 0
	jmp	$LN295@InitMap
	jmp	$LN295@InitMap
$LN294@InitMap:
	mov	ecx, DWORD PTR _uiTeam1$224514[ebp]
	cmp	ecx, DWORD PTR _uiTeam2$224518[ebp]
	jbe	SHORT $LN298@InitMap
	mov	edx, DWORD PTR _uiTeam1$224514[ebp]
	mov	DWORD PTR _uiLarge$229745[ebp], edx
	mov	eax, DWORD PTR _uiTeam2$224518[ebp]
	mov	DWORD PTR _uiSmall$229746[ebp], eax
	jmp	SHORT $LN301@InitMap
$LN298@InitMap:
	mov	ecx, DWORD PTR _uiTeam2$224518[ebp]
	mov	DWORD PTR _uiLarge$229745[ebp], ecx
	mov	edx, DWORD PTR _uiTeam1$224514[ebp]
	mov	DWORD PTR _uiSmall$229746[ebp], edx
$LN301@InitMap:
	mov	eax, DWORD PTR _uiLarge$229745[ebp]
	sub	eax, 1
	imul	eax, DWORD PTR _uiLarge$229745[ebp]
	shr	eax, 1
	mov	DWORD PTR _uiStart$229749[ebp], eax
	mov	ecx, DWORD PTR _uiStart$229749[ebp]
	add	ecx, DWORD PTR _uiSmall$229746[ebp]
	mov	DWORD PTR _uiBitIndex$229756[ebp], ecx
	mov	edx, DWORD PTR _uiBitIndex$229756[ebp]
	shr	edx, 3
	mov	DWORD PTR _uiByte$229757[ebp], edx
	mov	eax, DWORD PTR _uiBitIndex$229756[ebp]
	xor	edx, edx
	mov	ecx, 8
	div	ecx
	mov	DWORD PTR _uiBit$229758[ebp], edx
	mov	edx, 1
	mov	ecx, DWORD PTR _uiBit$229758[ebp]
	shl	edx, cl
	mov	BYTE PTR _byMask$229759[ebp], dl
	mov	eax, DWORD PTR _uiByte$229757[ebp]
	movzx	ecx, BYTE PTR _sg_kSave[eax+570]
	movzx	edx, BYTE PTR _byMask$229759[ebp]
	and	ecx, edx
	setne	al
	mov	BYTE PTR $T229760[ebp], al
$LN295@InitMap:
	movzx	ecx, BYTE PTR $T229760[ebp]
	test	ecx, ecx
	je	SHORT $LN39@InitMap

; 1238 : 			{
; 1239 : 				kTeam1.setAtWar(eTeam2, true);

	push	1
	mov	edx, DWORD PTR _eTeam2$224524[ebp]
	push	edx
	mov	ecx, DWORD PTR _kTeam1$224526[ebp]
	call	?setAtWar@CvTeam@@QAEXW4TeamTypes@@_N@Z	; CvTeam::setAtWar

; 1240 : 				kTeam2.setAtWar(eTeam1, true);

	push	1
	mov	eax, DWORD PTR _eTeam1$224522[ebp]
	push	eax
	mov	ecx, DWORD PTR _kTeam2$224527[ebp]
	call	?setAtWar@CvTeam@@QAEXW4TeamTypes@@_N@Z	; CvTeam::setAtWar
$LN39@InitMap:

; 1241 : 			}
; 1242 : 
; 1243 : 			if(sg_kSave.m_kTeamsAtPermanentWarOrPeace.Get(uiTeam1, uiTeam2))

	mov	ecx, DWORD PTR _uiTeam1$224514[ebp]
	cmp	ecx, DWORD PTR _uiTeam2$224518[ebp]
	jne	SHORT $LN304@InitMap
	mov	BYTE PTR $T229792[ebp], 1
	jmp	$LN305@InitMap
	jmp	$LN305@InitMap
$LN304@InitMap:
	mov	edx, DWORD PTR _uiTeam1$224514[ebp]
	cmp	edx, DWORD PTR _uiTeam2$224518[ebp]
	jbe	SHORT $LN308@InitMap
	mov	eax, DWORD PTR _uiTeam1$224514[ebp]
	mov	DWORD PTR _uiLarge$229777[ebp], eax
	mov	ecx, DWORD PTR _uiTeam2$224518[ebp]
	mov	DWORD PTR _uiSmall$229778[ebp], ecx
	jmp	SHORT $LN311@InitMap
$LN308@InitMap:
	mov	edx, DWORD PTR _uiTeam2$224518[ebp]
	mov	DWORD PTR _uiLarge$229777[ebp], edx
	mov	eax, DWORD PTR _uiTeam1$224514[ebp]
	mov	DWORD PTR _uiSmall$229778[ebp], eax
$LN311@InitMap:
	mov	ecx, DWORD PTR _uiLarge$229777[ebp]
	sub	ecx, 1
	imul	ecx, DWORD PTR _uiLarge$229777[ebp]
	shr	ecx, 1
	mov	DWORD PTR _uiStart$229781[ebp], ecx
	mov	edx, DWORD PTR _uiStart$229781[ebp]
	add	edx, DWORD PTR _uiSmall$229778[ebp]
	mov	DWORD PTR _uiBitIndex$229788[ebp], edx
	mov	eax, DWORD PTR _uiBitIndex$229788[ebp]
	shr	eax, 3
	mov	DWORD PTR _uiByte$229789[ebp], eax
	mov	eax, DWORD PTR _uiBitIndex$229788[ebp]
	xor	edx, edx
	mov	ecx, 8
	div	ecx
	mov	DWORD PTR _uiBit$229790[ebp], edx
	mov	edx, 1
	mov	ecx, DWORD PTR _uiBit$229790[ebp]
	shl	edx, cl
	mov	BYTE PTR _byMask$229791[ebp], dl
	mov	eax, DWORD PTR _uiByte$229789[ebp]
	movzx	ecx, BYTE PTR _sg_kSave[eax+1140]
	movzx	edx, BYTE PTR _byMask$229791[ebp]
	and	ecx, edx
	setne	al
	mov	BYTE PTR $T229792[ebp], al
$LN305@InitMap:
	movzx	ecx, BYTE PTR $T229792[ebp]
	test	ecx, ecx
	je	SHORT $LN38@InitMap

; 1244 : 			{
; 1245 : 				kTeam1.setPermanentWarPeace(eTeam2, true);

	push	1
	mov	edx, DWORD PTR _eTeam2$224524[ebp]
	push	edx
	mov	ecx, DWORD PTR _kTeam1$224526[ebp]
	call	?setPermanentWarPeace@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::setPermanentWarPeace

; 1246 : 				kTeam2.setPermanentWarPeace(eTeam1, true);

	push	1
	mov	eax, DWORD PTR _eTeam1$224522[ebp]
	push	eax
	mov	ecx, DWORD PTR _kTeam2$224527[ebp]
	call	?setPermanentWarPeace@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::setPermanentWarPeace
$LN38@InitMap:

; 1247 : 			}
; 1248 : 
; 1249 : 			if(sg_kSave.m_kTeamsSharingOpenBorders.Get(uiTeam1, uiTeam2))

	mov	ecx, DWORD PTR _uiTeam1$224514[ebp]
	cmp	ecx, DWORD PTR _uiTeam2$224518[ebp]
	jne	SHORT $LN314@InitMap
	mov	BYTE PTR $T229824[ebp], 1
	jmp	$LN315@InitMap
	jmp	$LN315@InitMap
$LN314@InitMap:
	mov	edx, DWORD PTR _uiTeam1$224514[ebp]
	cmp	edx, DWORD PTR _uiTeam2$224518[ebp]
	jbe	SHORT $LN318@InitMap
	mov	eax, DWORD PTR _uiTeam1$224514[ebp]
	mov	DWORD PTR _uiLarge$229809[ebp], eax
	mov	ecx, DWORD PTR _uiTeam2$224518[ebp]
	mov	DWORD PTR _uiSmall$229810[ebp], ecx
	jmp	SHORT $LN321@InitMap
$LN318@InitMap:
	mov	edx, DWORD PTR _uiTeam2$224518[ebp]
	mov	DWORD PTR _uiLarge$229809[ebp], edx
	mov	eax, DWORD PTR _uiTeam1$224514[ebp]
	mov	DWORD PTR _uiSmall$229810[ebp], eax
$LN321@InitMap:
	mov	ecx, DWORD PTR _uiLarge$229809[ebp]
	sub	ecx, 1
	imul	ecx, DWORD PTR _uiLarge$229809[ebp]
	shr	ecx, 1
	mov	DWORD PTR _uiStart$229813[ebp], ecx
	mov	edx, DWORD PTR _uiStart$229813[ebp]
	add	edx, DWORD PTR _uiSmall$229810[ebp]
	mov	DWORD PTR _uiBitIndex$229820[ebp], edx
	mov	eax, DWORD PTR _uiBitIndex$229820[ebp]
	shr	eax, 3
	mov	DWORD PTR _uiByte$229821[ebp], eax
	mov	eax, DWORD PTR _uiBitIndex$229820[ebp]
	xor	edx, edx
	mov	ecx, 8
	div	ecx
	mov	DWORD PTR _uiBit$229822[ebp], edx
	mov	edx, 1
	mov	ecx, DWORD PTR _uiBit$229822[ebp]
	shl	edx, cl
	mov	BYTE PTR _byMask$229823[ebp], dl
	mov	eax, DWORD PTR _uiByte$229821[ebp]
	movzx	ecx, BYTE PTR _sg_kSave[eax+1710]
	movzx	edx, BYTE PTR _byMask$229823[ebp]
	and	ecx, edx
	setne	al
	mov	BYTE PTR $T229824[ebp], al
$LN315@InitMap:
	movzx	ecx, BYTE PTR $T229824[ebp]
	test	ecx, ecx
	je	SHORT $LN37@InitMap

; 1250 : 			{
; 1251 : 				kTeam1.SetAllowsOpenBordersToTeam(eTeam2, true);

	push	1
	mov	edx, DWORD PTR _eTeam2$224524[ebp]
	push	edx
	mov	ecx, DWORD PTR _kTeam1$224526[ebp]
	call	?SetAllowsOpenBordersToTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetAllowsOpenBordersToTeam

; 1252 : 				kTeam2.SetAllowsOpenBordersToTeam(eTeam1, true);

	push	1
	mov	eax, DWORD PTR _eTeam1$224522[ebp]
	push	eax
	mov	ecx, DWORD PTR _kTeam2$224527[ebp]
	call	?SetAllowsOpenBordersToTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetAllowsOpenBordersToTeam
$LN37@InitMap:

; 1253 : 			}
; 1254 : 
; 1255 : 			if(sg_kSave.m_kTeamsSharingDefensivePacts.Get(uiTeam1, uiTeam2))

	mov	ecx, DWORD PTR _uiTeam1$224514[ebp]
	cmp	ecx, DWORD PTR _uiTeam2$224518[ebp]
	jne	SHORT $LN324@InitMap
	mov	BYTE PTR $T229856[ebp], 1
	jmp	$LN325@InitMap
	jmp	$LN325@InitMap
$LN324@InitMap:
	mov	edx, DWORD PTR _uiTeam1$224514[ebp]
	cmp	edx, DWORD PTR _uiTeam2$224518[ebp]
	jbe	SHORT $LN328@InitMap
	mov	eax, DWORD PTR _uiTeam1$224514[ebp]
	mov	DWORD PTR _uiLarge$229841[ebp], eax
	mov	ecx, DWORD PTR _uiTeam2$224518[ebp]
	mov	DWORD PTR _uiSmall$229842[ebp], ecx
	jmp	SHORT $LN331@InitMap
$LN328@InitMap:
	mov	edx, DWORD PTR _uiTeam2$224518[ebp]
	mov	DWORD PTR _uiLarge$229841[ebp], edx
	mov	eax, DWORD PTR _uiTeam1$224514[ebp]
	mov	DWORD PTR _uiSmall$229842[ebp], eax
$LN331@InitMap:
	mov	ecx, DWORD PTR _uiLarge$229841[ebp]
	sub	ecx, 1
	imul	ecx, DWORD PTR _uiLarge$229841[ebp]
	shr	ecx, 1
	mov	DWORD PTR _uiStart$229845[ebp], ecx
	mov	edx, DWORD PTR _uiStart$229845[ebp]
	add	edx, DWORD PTR _uiSmall$229842[ebp]
	mov	DWORD PTR _uiBitIndex$229852[ebp], edx
	mov	eax, DWORD PTR _uiBitIndex$229852[ebp]
	shr	eax, 3
	mov	DWORD PTR _uiByte$229853[ebp], eax
	mov	eax, DWORD PTR _uiBitIndex$229852[ebp]
	xor	edx, edx
	mov	ecx, 8
	div	ecx
	mov	DWORD PTR _uiBit$229854[ebp], edx
	mov	edx, 1
	mov	ecx, DWORD PTR _uiBit$229854[ebp]
	shl	edx, cl
	mov	BYTE PTR _byMask$229855[ebp], dl
	mov	eax, DWORD PTR _uiByte$229853[ebp]
	movzx	ecx, BYTE PTR _sg_kSave[eax+2280]
	movzx	edx, BYTE PTR _byMask$229855[ebp]
	and	ecx, edx
	setne	al
	mov	BYTE PTR $T229856[ebp], al
$LN325@InitMap:
	movzx	ecx, BYTE PTR $T229856[ebp]
	test	ecx, ecx
	je	SHORT $LN36@InitMap

; 1256 : 			{
; 1257 : 				kTeam1.SetHasDefensivePact(eTeam2, true);

	push	1
	mov	edx, DWORD PTR _eTeam2$224524[ebp]
	push	edx
	mov	ecx, DWORD PTR _kTeam1$224526[ebp]
	call	?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasDefensivePact

; 1258 : 				kTeam2.SetHasDefensivePact(eTeam1, true);

	push	1
	mov	eax, DWORD PTR _eTeam1$224522[ebp]
	push	eax
	mov	ecx, DWORD PTR _kTeam2$224527[ebp]
	call	?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasDefensivePact
$LN36@InitMap:

; 1259 : 			}
; 1260 : 		}

	jmp	$LN42@InitMap
$LN41@InitMap:

; 1261 : 	}

	jmp	$LN45@InitMap
$LN44@InitMap:

; 1262 : 
; 1263 : 	// Init City State Relationships
; 1264 : 	for(uint uiCityState = 0; uiCityState < uiCityStateCount; ++uiCityState)

	mov	DWORD PTR _uiCityState$224533[ebp], 0
	jmp	SHORT $LN35@InitMap
$LN34@InitMap:
	mov	ecx, DWORD PTR _uiCityState$224533[ebp]
	add	ecx, 1
	mov	DWORD PTR _uiCityState$224533[ebp], ecx
$LN35@InitMap:
	mov	edx, DWORD PTR _uiCityState$224533[ebp]
	cmp	edx, DWORD PTR _uiCityStateCount$[ebp]
	jae	$LN33@InitMap

; 1265 : 	{
; 1266 : 		const PlayerTypes eCityStatePlayer = GetPlayerType((byte)(uiCityState + CvWorldBuilderMap::MaxPlayers));

	mov	eax, DWORD PTR _uiCityState$224533[ebp]
	add	eax, 32					; 00000020H
	push	eax
	call	?GetPlayerType@@YA?AW4PlayerTypes@@E@Z	; GetPlayerType
	add	esp, 4
	mov	DWORD PTR _eCityStatePlayer$224537[ebp], eax

; 1267 : 		if(eCityStatePlayer != NO_PLAYER)

	cmp	DWORD PTR _eCityStatePlayer$224537[ebp], -1
	je	$LN32@InitMap

; 1268 : 		{
; 1269 : 			CvPlayer& kCityState = GET_PLAYER(eCityStatePlayer);

	mov	ecx, DWORD PTR _eCityStatePlayer$224537[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kCityState$224540[ebp], ecx

; 1270 : 			CvMinorCivAI* pkAI = kCityState.GetMinorCivAI();

	mov	ecx, DWORD PTR _kCityState$224540[ebp]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	DWORD PTR _pkAI$224541[ebp], eax

; 1271 : 			FAssertMsg(pkAI, "Cannot set minor civ influence.  Missing CvMinorCivAI.");
; 1272 : 			if(pkAI != NULL)

	cmp	DWORD PTR _pkAI$224541[ebp], 0
	je	SHORT $LN32@InitMap

; 1273 : 			{
; 1274 : 				for(uint uiMajorCiv = 0; uiMajorCiv < uiPlayerCount; ++uiMajorCiv)

	mov	DWORD PTR _uiMajorCiv$224543[ebp], 0
	jmp	SHORT $LN30@InitMap
$LN29@InitMap:
	mov	edx, DWORD PTR _uiMajorCiv$224543[ebp]
	add	edx, 1
	mov	DWORD PTR _uiMajorCiv$224543[ebp], edx
$LN30@InitMap:
	mov	eax, DWORD PTR _uiMajorCiv$224543[ebp]
	cmp	eax, DWORD PTR _uiPlayerCount$[ebp]
	jae	SHORT $LN32@InitMap

; 1275 : 				{
; 1276 : 					const PlayerTypes eMajorCivPlayer = GetPlayerType((byte)uiMajorCiv);

	movzx	ecx, BYTE PTR _uiMajorCiv$224543[ebp]
	push	ecx
	call	?GetPlayerType@@YA?AW4PlayerTypes@@E@Z	; GetPlayerType
	add	esp, 4
	mov	DWORD PTR _eMajorCivPlayer$224547[ebp], eax

; 1277 : 					if(eMajorCivPlayer != NO_PLAYER)

	cmp	DWORD PTR _eMajorCivPlayer$224547[ebp], -1
	je	SHORT $LN27@InitMap

; 1278 : 					{
; 1279 : 						pkAI->SetFriendshipWithMajor(eMajorCivPlayer, sg_kSave.m_aiCityStateInfluence[uiMajorCiv][uiCityState]);

	push	0
	mov	edx, DWORD PTR _uiMajorCiv$224543[ebp]
	shl	edx, 8
	mov	eax, DWORD PTR _uiCityState$224533[ebp]
	mov	ecx, DWORD PTR _sg_kSave[edx+eax*4+4032]
	push	ecx
	mov	edx, DWORD PTR _eMajorCivPlayer$224547[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkAI$224541[ebp]
	call	?SetFriendshipWithMajor@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z ; CvMinorCivAI::SetFriendshipWithMajor
$LN27@InitMap:

; 1280 : 					}
; 1281 : 				}

	jmp	SHORT $LN29@InitMap
$LN32@InitMap:

; 1282 : 			}
; 1283 : 		}
; 1284 : 	}

	jmp	$LN34@InitMap
$LN33@InitMap:

; 1285 : 
; 1286 : 	// Scenario elements must come after areas have been calculated
; 1287 : 	for(uint i = 0; i < uiPlotCount; ++i)

	mov	DWORD PTR _i$224550[ebp], 0
	jmp	SHORT $LN26@InitMap
$LN25@InitMap:
	mov	eax, DWORD PTR _i$224550[ebp]
	add	eax, 1
	mov	DWORD PTR _i$224550[ebp], eax
$LN26@InitMap:
	mov	ecx, DWORD PTR _i$224550[ebp]
	cmp	ecx, DWORD PTR _uiPlotCount$[ebp]
	jae	$LN24@InitMap

; 1288 : 	{
; 1289 : 		const CvWorldBuilderMap::PlotScenarioData& kPlotData = sg_kSave.GetPlotScenarioData(i);

	mov	edx, DWORD PTR _sg_kSave+12228
	imul	edx, DWORD PTR _sg_kSave+12232
	cmp	DWORD PTR _i$224550[ebp], edx
	jae	SHORT $LN336@InitMap
	cmp	DWORD PTR _i$224550[ebp], 32768		; 00008000H
	jae	SHORT $LN336@InitMap
	mov	eax, DWORD PTR _i$224550[ebp]
	lea	ecx, DWORD PTR _sg_kSave[eax*8+274464]
	mov	DWORD PTR _kPlotData$224554[ebp], ecx
	jmp	SHORT $LN337@InitMap
	jmp	SHORT $LN337@InitMap
$LN336@InitMap:
	mov	DWORD PTR _kPlotData$224554[ebp], OFFSET ?sm_kErrorPlotScenarioData@CvWorldBuilderMap@@0UPlotScenarioData@1@A ; CvWorldBuilderMap::sm_kErrorPlotScenarioData
$LN337@InitMap:

; 1290 : 		CvPlot* pkPlot = kMap.plotByIndex(i);

	cmp	DWORD PTR _i$224550[ebp], 0
	jl	SHORT $LN341@InitMap
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4028]
	mov	DWORD PTR $T229871[ebp], eax
	mov	ecx, DWORD PTR _i$224550[ebp]
	cmp	ecx, DWORD PTR $T229871[ebp]
	jge	SHORT $LN341@InitMap
	mov	edx, DWORD PTR _i$224550[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR _kMap$[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv1095[ebp], edx
	jmp	SHORT $LN339@InitMap
$LN341@InitMap:
	mov	DWORD PTR tv1095[ebp], 0
$LN339@InitMap:
	mov	ecx, DWORD PTR tv1095[ebp]
	mov	DWORD PTR _pkPlot$224555[ebp], ecx

; 1291 : 		FAssertMsg(pkPlot, "Missing CvPlot for this location");
; 1292 : 		if(pkPlot == NULL) continue;

	cmp	DWORD PTR _pkPlot$224555[ebp], 0
	jne	SHORT $LN345@InitMap
	jmp	$LN25@InitMap

; 1293 : 
; 1294 : 		const int iPlotX = pkPlot->getX();

$LN345@InitMap:
	mov	edx, DWORD PTR _pkPlot$224555[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR _iPlotX$224557[ebp], eax

; 1295 : 		const int iPlotY = pkPlot->getY();

	mov	ecx, DWORD PTR _pkPlot$224555[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR _iPlotY$224558[ebp], edx

; 1296 : 
; 1297 : 		const byte byNaturalWonder = sg_kSave.GetPlotData(i).GetNaturalWonderType();

	mov	eax, DWORD PTR _sg_kSave+12228
	imul	eax, DWORD PTR _sg_kSave+12232
	cmp	DWORD PTR _i$224550[ebp], eax
	jae	SHORT $LN350@InitMap
	cmp	DWORD PTR _i$224550[ebp], 32768		; 00008000H
	jae	SHORT $LN350@InitMap
	mov	ecx, DWORD PTR _i$224550[ebp]
	lea	edx, DWORD PTR _sg_kSave[ecx*8+12320]
	mov	DWORD PTR $T229889[ebp], edx
	jmp	SHORT $LN351@InitMap
	jmp	SHORT $LN351@InitMap
$LN350@InitMap:
	mov	DWORD PTR $T229889[ebp], OFFSET ?sm_kErrorPlotMapData@CvWorldBuilderMap@@0VPlotMapData@1@A ; CvWorldBuilderMap::sm_kErrorPlotMapData
$LN351@InitMap:
	mov	eax, DWORD PTR $T229889[ebp]
	mov	cl, BYTE PTR [eax+6]
	mov	BYTE PTR _byNaturalWonder$224559[ebp], cl

; 1298 : 		if(byNaturalWonder != CvWorldBuilderMap::PlotMapData::InvalidNaturalWonder)

	movzx	edx, BYTE PTR _byNaturalWonder$224559[ebp]
	cmp	edx, 255				; 000000ffH
	je	SHORT $LN22@InitMap

; 1299 : 			pkPlot->setFeatureType((FeatureTypes)byNaturalWonder);

	push	-1
	movzx	eax, BYTE PTR _byNaturalWonder$224559[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkPlot$224555[ebp]
	call	?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z ; CvPlot::setFeatureType
$LN22@InitMap:

; 1300 : 
; 1301 : 		if(kPlotData.m_byImprovement != CvWorldBuilderMap::PlotScenarioData::InvalidImprovement)

	mov	ecx, DWORD PTR _kPlotData$224554[ebp]
	movzx	edx, BYTE PTR [ecx+5]
	cmp	edx, 255				; 000000ffH
	je	SHORT $LN21@InitMap

; 1302 : 			pkPlot->setImprovementType((ImprovementTypes)kPlotData.m_byImprovement);

	push	-1
	mov	eax, DWORD PTR _kPlotData$224554[ebp]
	movzx	ecx, BYTE PTR [eax+5]
	push	ecx
	mov	ecx, DWORD PTR _pkPlot$224555[ebp]
	call	?setImprovementType@CvPlot@@QAEXW4ImprovementTypes@@W4PlayerTypes@@@Z ; CvPlot::setImprovementType
$LN21@InitMap:

; 1303 : 
; 1304 : 		if(kPlotData.m_byRoute != CvWorldBuilderMap::PlotScenarioData::InvalidImprovement)

	mov	edx, DWORD PTR _kPlotData$224554[ebp]
	movzx	eax, BYTE PTR [edx+6]
	cmp	eax, 255				; 000000ffH
	je	$LN20@InitMap

; 1305 : 		{
; 1306 : 			RouteTypes eRoute;
; 1307 : 			if(kPlotData.m_byRoute == 0)

	mov	ecx, DWORD PTR _kPlotData$224554[ebp]
	movzx	edx, BYTE PTR [ecx+6]
	test	edx, edx
	jne	SHORT $LN19@InitMap

; 1308 : 				eRoute = ROUTE_ROAD;

	mov	DWORD PTR _eRoute$224565[ebp], 0

; 1309 : 			else

	jmp	SHORT $LN18@InitMap
$LN19@InitMap:

; 1310 : 				eRoute = ROUTE_RAILROAD;

	mov	DWORD PTR _eRoute$224565[ebp], 1
$LN18@InitMap:

; 1311 : 
; 1312 : 			pkPlot->setRouteType(eRoute);

	mov	eax, DWORD PTR _eRoute$224565[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkPlot$224555[ebp]
	call	?setRouteType@CvPlot@@QAEXW4RouteTypes@@@Z ; CvPlot::setRouteType

; 1313 : 
; 1314 : 			const PlayerTypes eOwner = GetPlayerType(kPlotData.m_byRouteOwner);

	mov	ecx, DWORD PTR _kPlotData$224554[ebp]
	movzx	edx, BYTE PTR [ecx+7]
	push	edx
	call	?GetPlayerType@@YA?AW4PlayerTypes@@E@Z	; GetPlayerType
	add	esp, 4
	mov	DWORD PTR _eOwner$224568[ebp], eax

; 1315 : 			if(eOwner != NO_PLAYER && !pkPlot->isOwned())

	cmp	DWORD PTR _eOwner$224568[ebp], -1
	je	$LN20@InitMap
	mov	ecx, DWORD PTR _pkPlot$224555[ebp]
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	movzx	eax, al
	test	eax, eax
	jne	$LN20@InitMap

; 1316 : 			{
; 1317 : 				// Mark the player as responsible for this route and update the treasury
; 1318 : 				CvTreasury* pkTreasury = GET_PLAYER(eOwner).GetTreasury();

	mov	ecx, DWORD PTR _eOwner$224568[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T229896[ebp], ecx
	mov	ecx, DWORD PTR $T229896[ebp]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	DWORD PTR _pkTreasury$224570[ebp], eax

; 1319 : 				const CvRouteInfo* pkRouteInfo = GC.getRouteInfo(eRoute);

	mov	edx, DWORD PTR _eRoute$224565[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo
	mov	DWORD PTR _pkRouteInfo$224571[ebp], eax

; 1320 : 				if(pkTreasury != NULL && pkRouteInfo != NULL)

	cmp	DWORD PTR _pkTreasury$224570[ebp], 0
	je	SHORT $LN20@InitMap
	cmp	DWORD PTR _pkRouteInfo$224571[ebp], 0
	je	SHORT $LN20@InitMap

; 1321 : 				{
; 1322 : 					if(pkPlot->MustPayMaintenanceHere(eOwner))

	mov	eax, DWORD PTR _eOwner$224568[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkPlot$224555[ebp]
	call	?MustPayMaintenanceHere@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::MustPayMaintenanceHere
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN15@InitMap

; 1323 : 					{
; 1324 : 						pkTreasury->ChangeBaseImprovementGoldMaintenance(pkRouteInfo->GetGoldMaintenance());

	mov	ecx, DWORD PTR _pkRouteInfo$224571[ebp]
	call	?GetGoldMaintenance@CvRouteInfo@@QBEHXZ	; CvRouteInfo::GetGoldMaintenance
	push	eax
	mov	ecx, DWORD PTR _pkTreasury$224570[ebp]
	call	?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeBaseImprovementGoldMaintenance
$LN15@InitMap:

; 1325 : 					}
; 1326 : 					pkPlot->SetPlayerResponsibleForRoute(eOwner);

	mov	edx, DWORD PTR _eOwner$224568[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkPlot$224555[ebp]
	call	?SetPlayerResponsibleForRoute@CvPlot@@QAEXW4PlayerTypes@@@Z ; CvPlot::SetPlayerResponsibleForRoute
$LN20@InitMap:

; 1327 : 				}
; 1328 : 			}
; 1329 : 		}
; 1330 : 
; 1331 : 		const CvWorldBuilderMap::City* pkCity = sg_kSave.m_kCities[kPlotData.m_hCity];

	mov	eax, DWORD PTR _kPlotData$224554[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR $T229902[ebp], cx
	movzx	edx, WORD PTR $T229902[ebp]
	cmp	edx, DWORD PTR _sg_kSave+2884
	jae	SHORT $LN358@InitMap
	movzx	eax, WORD PTR $T229902[ebp]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _sg_kSave+2876
	mov	DWORD PTR _pkCity$224574[ebp], eax
	jmp	SHORT $LN359@InitMap
	jmp	SHORT $LN359@InitMap
$LN358@InitMap:
	mov	DWORD PTR _pkCity$224574[ebp], 0
$LN359@InitMap:

; 1332 : 		if(pkCity != NULL)

	cmp	DWORD PTR _pkCity$224574[ebp], 0
	je	SHORT $LN14@InitMap

; 1333 : 		{
; 1334 : 			SetupCity(*pkCity, iPlotX, iPlotY);

	mov	ecx, DWORD PTR _iPlotY$224558[ebp]
	push	ecx
	mov	edx, DWORD PTR _iPlotX$224557[ebp]
	push	edx
	mov	eax, DWORD PTR _pkCity$224574[ebp]
	push	eax
	call	?SetupCity@@YAXABUCity@CvWorldBuilderMap@@HH@Z ; SetupCity
	add	esp, 12					; 0000000cH
$LN14@InitMap:

; 1335 : 		}
; 1336 : 
; 1337 : 		// Note - All calls to SetupUnit for this plot must come after SetupCity for this plot.
; 1338 : 		// This is because of garrisoned units that need the city to be there first.
; 1339 : 		for(const CvWorldBuilderMap::Unit* pkUnit = sg_kSave.m_kUnits[kPlotData.m_hUnitStack];

	mov	ecx, DWORD PTR _kPlotData$224554[ebp]
	mov	dx, WORD PTR [ecx+2]
	mov	WORD PTR $T229908[ebp], dx
	movzx	eax, WORD PTR $T229908[ebp]
	cmp	eax, DWORD PTR _sg_kSave+2860
	jae	SHORT $LN362@InitMap
	movzx	ecx, WORD PTR $T229908[ebp]
	imul	ecx, 84					; 00000054H
	add	ecx, DWORD PTR _sg_kSave+2852
	mov	DWORD PTR _pkUnit$224576[ebp], ecx
	jmp	SHORT $LN363@InitMap
	jmp	SHORT $LN363@InitMap
$LN362@InitMap:
	mov	DWORD PTR _pkUnit$224576[ebp], 0
$LN363@InitMap:

; 1340 : 		        pkUnit != NULL;

	jmp	SHORT $LN13@InitMap
$LN12@InitMap:

; 1341 : 		        pkUnit = sg_kSave.m_kUnits[pkUnit->m_hStackedUnit])

	mov	edx, DWORD PTR _pkUnit$224576[ebp]
	mov	ax, WORD PTR [edx]
	mov	WORD PTR $T229914[ebp], ax
	movzx	ecx, WORD PTR $T229914[ebp]
	cmp	ecx, DWORD PTR _sg_kSave+2860
	jae	SHORT $LN366@InitMap
	movzx	edx, WORD PTR $T229914[ebp]
	imul	edx, 84					; 00000054H
	add	edx, DWORD PTR _sg_kSave+2852
	mov	DWORD PTR _pkUnit$224576[ebp], edx
	jmp	SHORT $LN13@InitMap
	jmp	SHORT $LN13@InitMap
$LN366@InitMap:
	mov	DWORD PTR _pkUnit$224576[ebp], 0
$LN13@InitMap:
	cmp	DWORD PTR _pkUnit$224576[ebp], 0
	je	SHORT $LN11@InitMap

; 1342 : 		{
; 1343 : 			SetupUnit(*pkUnit, iPlotX, iPlotY);

	mov	eax, DWORD PTR _iPlotY$224558[ebp]
	push	eax
	mov	ecx, DWORD PTR _iPlotX$224557[ebp]
	push	ecx
	mov	edx, DWORD PTR _pkUnit$224576[ebp]
	push	edx
	call	?SetupUnit@@YAXABUUnit@CvWorldBuilderMap@@HH@Z ; SetupUnit
	add	esp, 12					; 0000000cH

; 1344 : 		}

	jmp	SHORT $LN12@InitMap
$LN11@InitMap:

; 1345 : 
; 1346 : 		for(uint uiTeam = 0; uiTeam < uiTeamCount; ++uiTeam)

	mov	DWORD PTR _uiTeam$224580[ebp], 0
	jmp	SHORT $LN10@InitMap
$LN9@InitMap:
	mov	eax, DWORD PTR _uiTeam$224580[ebp]
	add	eax, 1
	mov	DWORD PTR _uiTeam$224580[ebp], eax
$LN10@InitMap:
	mov	ecx, DWORD PTR _uiTeam$224580[ebp]
	cmp	ecx, DWORD PTR _uiTeamCount$[ebp]
	jae	$LN8@InitMap

; 1347 : 		{
; 1348 : 			if(sg_kSave.GetVisibility(iPlotX, iPlotY, uiTeam))

	mov	edx, DWORD PTR _sg_kSave+12228
	imul	edx, DWORD PTR _sg_kSave+12232
	mov	DWORD PTR _uiMapSize$229935[ebp], edx
	mov	eax, DWORD PTR _uiTeam$224580[ebp]
	imul	eax, DWORD PTR _uiMapSize$229935[ebp]
	mov	ecx, DWORD PTR _iPlotY$224558[ebp]
	imul	ecx, DWORD PTR _sg_kSave+12228
	add	ecx, DWORD PTR _iPlotX$224557[ebp]
	add	ecx, eax
	mov	DWORD PTR $T229924[ebp], ecx
	mov	edx, DWORD PTR $T229924[ebp]
	shr	edx, 3
	mov	DWORD PTR _uiByte$229929[ebp], edx
	mov	eax, DWORD PTR $T229924[ebp]
	xor	edx, edx
	mov	ecx, 8
	div	ecx
	mov	DWORD PTR _uiBit$229930[ebp], edx
	mov	edx, 1
	mov	ecx, DWORD PTR _uiBit$229930[ebp]
	shl	edx, cl
	mov	BYTE PTR _byMask$229931[ebp], dl
	cmp	DWORD PTR _uiByte$229929[ebp], 393216	; 00060000H
	jae	SHORT $LN372@InitMap
	mov	eax, DWORD PTR _uiByte$229929[ebp]
	movzx	ecx, BYTE PTR _sg_kSave[eax+584672]
	movzx	edx, BYTE PTR _byMask$229931[ebp]
	and	ecx, edx
	setne	al
	mov	BYTE PTR $T229925[ebp], al
	jmp	SHORT $LN369@InitMap
	jmp	SHORT $LN369@InitMap
$LN372@InitMap:
	mov	BYTE PTR $T229925[ebp], 0
$LN369@InitMap:
	movzx	ecx, BYTE PTR $T229925[ebp]
	test	ecx, ecx
	je	SHORT $LN7@InitMap

; 1349 : 				pkPlot->setRevealed((TeamTypes)uiTeam, true);

	push	-1
	push	0
	push	1
	mov	edx, DWORD PTR _uiTeam$224580[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkPlot$224555[ebp]
	call	?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z ; CvPlot::setRevealed
$LN7@InitMap:

; 1350 : 		}

	jmp	$LN9@InitMap
$LN8@InitMap:

; 1351 : 	}

	jmp	$LN25@InitMap
$LN24@InitMap:

; 1352 : 
; 1353 : 	// Set culture.  This must come after all cities have been added.
; 1354 : 	for(uint i = 0; i < uiPlotCount; ++i)

	mov	DWORD PTR _i$224586[ebp], 0
	jmp	SHORT $LN6@InitMap
$LN5@InitMap:
	mov	eax, DWORD PTR _i$224586[ebp]
	add	eax, 1
	mov	DWORD PTR _i$224586[ebp], eax
$LN6@InitMap:
	mov	ecx, DWORD PTR _i$224586[ebp]
	cmp	ecx, DWORD PTR _uiPlotCount$[ebp]
	jae	$LN4@InitMap

; 1355 : 	{
; 1356 : 		const CvWorldBuilderMap::PlotScenarioData& kPlotData = sg_kSave.GetPlotScenarioData(i);

	mov	edx, DWORD PTR _sg_kSave+12228
	imul	edx, DWORD PTR _sg_kSave+12232
	cmp	DWORD PTR _i$224586[ebp], edx
	jae	SHORT $LN376@InitMap
	cmp	DWORD PTR _i$224586[ebp], 32768		; 00008000H
	jae	SHORT $LN376@InitMap
	mov	eax, DWORD PTR _i$224586[ebp]
	lea	ecx, DWORD PTR _sg_kSave[eax*8+274464]
	mov	DWORD PTR _kPlotData$224590[ebp], ecx
	jmp	SHORT $LN377@InitMap
	jmp	SHORT $LN377@InitMap
$LN376@InitMap:
	mov	DWORD PTR _kPlotData$224590[ebp], OFFSET ?sm_kErrorPlotScenarioData@CvWorldBuilderMap@@0UPlotScenarioData@1@A ; CvWorldBuilderMap::sm_kErrorPlotScenarioData
$LN377@InitMap:

; 1357 : 		CvPlot* pkPlot = kMap.plotByIndex(i);

	cmp	DWORD PTR _i$224586[ebp], 0
	jl	SHORT $LN381@InitMap
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4028]
	mov	DWORD PTR $T229947[ebp], eax
	mov	ecx, DWORD PTR _i$224586[ebp]
	cmp	ecx, DWORD PTR $T229947[ebp]
	jge	SHORT $LN381@InitMap
	mov	edx, DWORD PTR _i$224586[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR _kMap$[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv1146[ebp], edx
	jmp	SHORT $LN379@InitMap
$LN381@InitMap:
	mov	DWORD PTR tv1146[ebp], 0
$LN379@InitMap:
	mov	ecx, DWORD PTR tv1146[ebp]
	mov	DWORD PTR _pkPlot$224591[ebp], ecx

; 1358 : 		FAssertMsg(pkPlot, "Missing CvPlot for this location");
; 1359 : 		if(pkPlot == NULL) continue;

	cmp	DWORD PTR _pkPlot$224591[ebp], 0
	jne	SHORT $LN3@InitMap
	jmp	$LN5@InitMap
$LN3@InitMap:

; 1360 : 
; 1361 : 		const PlayerTypes eOwner = GetPlayerType(kPlotData.m_byCulture);

	mov	edx, DWORD PTR _kPlotData$224590[ebp]
	movzx	eax, BYTE PTR [edx+4]
	push	eax
	call	?GetPlayerType@@YA?AW4PlayerTypes@@E@Z	; GetPlayerType
	add	esp, 4
	mov	DWORD PTR _eOwner$224593[ebp], eax

; 1362 : 		if(eOwner != NO_PLAYER)

	cmp	DWORD PTR _eOwner$224593[ebp], -1
	je	SHORT $LN2@InitMap

; 1363 : 		{
; 1364 : 			int iCityID = 0;

	mov	DWORD PTR _iCityID$224595[ebp], 0

; 1365 : 			const CvCity* pkCity = FindClosestCity(eOwner, *pkPlot);

	mov	ecx, DWORD PTR _pkPlot$224591[ebp]
	push	ecx
	mov	edx, DWORD PTR _eOwner$224593[ebp]
	push	edx
	call	?FindClosestCity@@YAPBVCvCity@@W4PlayerTypes@@ABVCvPlot@@@Z ; FindClosestCity
	add	esp, 8
	mov	DWORD PTR _pkCity$224596[ebp], eax

; 1366 : 			if(pkCity) iCityID = pkCity->GetID();

	cmp	DWORD PTR _pkCity$224596[ebp], 0
	je	SHORT $LN1@InitMap
	mov	eax, DWORD PTR _pkCity$224596[ebp]
	mov	ecx, DWORD PTR [eax+120]
	mov	DWORD PTR _iCityID$224595[ebp], ecx
$LN1@InitMap:

; 1367 : 			pkPlot->setOwner(eOwner, iCityID);

	push	1
	push	1
	mov	edx, DWORD PTR _iCityID$224595[ebp]
	push	edx
	mov	eax, DWORD PTR _eOwner$224593[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkPlot$224591[ebp]
	call	?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z ; CvPlot::setOwner
$LN2@InitMap:

; 1368 : 		}
; 1369 : 	}

	jmp	$LN5@InitMap
$LN4@InitMap:

; 1370 : 
; 1371 : 	OutputDebugStringA("Map Load Success!\n");

	push	OFFSET ??_C@_0BD@FPKADGCN@Map?5Load?5Success?$CB?6?$AA@
	call	DWORD PTR __imp__OutputDebugStringA@4

; 1372 : 
; 1373 : 	return true;

	mov	BYTE PTR $T229309[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _kMinorCivs$[ebp]
	call	??1?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAE@XZ ; FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>::~FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _kMajorCivs$[ebp]
	call	??1?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAE@XZ ; FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>::~FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>
	mov	al, BYTE PTR $T229309[ebp]

; 1374 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?InitMap@CvWorldBuilderMapLoader@@SA_NXZ$0:
	lea	ecx, DWORD PTR _kMajorCivs$[ebp]
	jmp	??1?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAE@XZ ; FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>::~FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>
__unwindfunclet$?InitMap@CvWorldBuilderMapLoader@@SA_NXZ$1:
	lea	ecx, DWORD PTR _kMinorCivs$[ebp]
	jmp	??1?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAE@XZ ; FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>::~FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>
__ehhandler$?InitMap@CvWorldBuilderMapLoader@@SA_NXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-728]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?InitMap@CvWorldBuilderMapLoader@@SA_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?InitMap@CvWorldBuilderMapLoader@@SA_NXZ ENDP		; CvWorldBuilderMapLoader::InitMap
PUBLIC	?Load@CvWorldBuilderMapLoader@@SA_NPB_W@Z	; CvWorldBuilderMapLoader::Load
; Function compile flags: /Odtp
;	COMDAT ?Load@CvWorldBuilderMapLoader@@SA_NPB_W@Z
_TEXT	SEGMENT
tv74 = -4						; size = 4
_wszFilename$ = 8					; size = 4
?Load@CvWorldBuilderMapLoader@@SA_NPB_W@Z PROC		; CvWorldBuilderMapLoader::Load, COMDAT

; 1381 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1382 : 	InitTypeDesc();

	call	?InitTypeDesc@@YAXXZ			; InitTypeDesc

; 1383 : 
; 1384 : 	return sg_kSave.Load(wszFilename, sg_kMapTypeDesc) && InitMap();

	push	1
	push	OFFSET _sg_kMapTypeDesc
	mov	eax, DWORD PTR _wszFilename$[ebp]
	push	eax
	mov	ecx, OFFSET _sg_kSave
	call	?Load@CvWorldBuilderMap@@QAE_NPB_WABVCvWorldBuilderMapTypeDesc@@_N@Z ; CvWorldBuilderMap::Load
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@Load
	call	?InitMap@CvWorldBuilderMapLoader@@SA_NXZ ; CvWorldBuilderMapLoader::InitMap
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@Load
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@Load
$LN3@Load:
	mov	DWORD PTR tv74[ebp], 0
$LN4@Load:
	mov	al, BYTE PTR tv74[ebp]

; 1385 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Load@CvWorldBuilderMapLoader@@SA_NPB_W@Z ENDP		; CvWorldBuilderMapLoader::Load
_TEXT	ENDS
PUBLIC	??1FStringW@@QAE@XZ				; FStringW::~FStringW
PUBLIC	?SetFixedBuffer@FStringW@@QAEXPAUFStringWData@1@@Z ; FStringW::SetFixedBuffer
PUBLIC	__$ArrayPad$
PUBLIC	?Save@CvWorldBuilderMapLoader@@SA_NPB_WPBD@Z	; CvWorldBuilderMapLoader::Save
EXTRN	?Save@CvWorldBuilderMap@@QBE_NPB_WABVCvWorldBuilderMapTypeDesc@@_N@Z:PROC ; CvWorldBuilderMap::Save
EXTRN	?GetContinentType@CvPlot@@QBEDXZ:PROC		; CvPlot::GetContinentType
EXTRN	?getRiverSWFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ:PROC ; CvPlot::getRiverSWFlowDirection
EXTRN	?isNEOfRiver@CvPlot@@QBE_NXZ:PROC		; CvPlot::isNEOfRiver
EXTRN	?getRiverSEFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ:PROC ; CvPlot::getRiverSEFlowDirection
EXTRN	?isNWOfRiver@CvPlot@@QBE_NXZ:PROC		; CvPlot::isNWOfRiver
EXTRN	?getRiverEFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ:PROC ; CvPlot::getRiverEFlowDirection
EXTRN	?isWOfRiver@CvPlot@@QBE_NXZ:PROC		; CvPlot::isWOfRiver
EXTRN	?IsNaturalWonder@CvFeatureInfo@@QBE_NXZ:PROC	; CvFeatureInfo::IsNaturalWonder
EXTRN	?getNumResource@CvPlot@@QBEHXZ:PROC		; CvPlot::getNumResource
EXTRN	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::getResourceType
EXTRN	?SetWorldType@CvWorldBuilderMap@@QAEXPBD@Z:PROC	; CvWorldBuilderMap::SetWorldType
EXTRN	?getWorldInfo@CvMap@@QBEABVCvWorldInfo@@XZ:PROC	; CvMap::getWorldInfo
EXTRN	?Copy@FStringA@@QAEXHPBDH@Z:PROC		; FStringA::Copy
EXTRN	?CopyToUTF8@FStringW@@QBEXPAVFStringA@@@Z:PROC	; FStringW::CopyToUTF8
EXTRN	?ExtractFileTitle@FStringW@@QBEXAAV1@_W@Z:PROC	; FStringW::ExtractFileTitle
EXTRN	?Copy@FStringW@@QAEXHPB_WH@Z:PROC		; FStringW::Copy
EXTRN	?FStringW_GetStringInitData@@YAPAUFStringWData@FStringW@@XZ:PROC ; FStringW_GetStringInitData
EXTRN	?Resize@CvWorldBuilderMap@@QAEXII@Z:PROC	; CvWorldBuilderMap::Resize
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvworldbuildermap\include\cvworldbuildermap.h
xdata$x	SEGMENT
__unwindtable$?Save@CvWorldBuilderMapLoader@@SA_NPB_WPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Save@CvWorldBuilderMapLoader@@SA_NPB_WPBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Save@CvWorldBuilderMapLoader@@SA_NPB_WPBD@Z$1
__ehfuncinfo$?Save@CvWorldBuilderMapLoader@@SA_NPB_WPBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Save@CvWorldBuilderMapLoader@@SA_NPB_WPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvworldbuildermaploader.cpp
xdata$x	ENDS
;	COMDAT ?Save@CvWorldBuilderMapLoader@@SA_NPB_WPBD@Z
_TEXT	SEGMENT
tv334 = -1252						; size = 4
tv308 = -1248						; size = 4
tv306 = -1244						; size = 4
tv462 = -1237						; size = 1
tv459 = -1236						; size = 4
tv456 = -1232						; size = 4
tv300 = -1228						; size = 4
tv298 = -1224						; size = 4
tv447 = -1217						; size = 1
tv444 = -1216						; size = 4
tv441 = -1212						; size = 4
tv288 = -1208						; size = 4
tv286 = -1204						; size = 4
tv431 = -1198						; size = 2
tv428 = -1196						; size = 4
tv425 = -1192						; size = 4
$T230308 = -1188					; size = 1
_f$230247 = -1187					; size = 1
$T230241 = -1186					; size = 1
$T230219 = -1185					; size = 1
$T230206 = -1184					; size = 4
$T230194 = -1180					; size = 4
$T230190 = -1176					; size = 4
$T230186 = -1172					; size = 4
$T230177 = -1165					; size = 1
$T230074 = -1156					; size = 4
$T230055 = -1152					; size = 4
$T230049 = -1148					; size = 4
$T230045 = -1144					; size = 4
_pkFeatureInfo$224649 = -1140				; size = 4
_eFeatureType$224646 = -1136				; size = 4
_ePlotType$224636 = -1132				; size = 4
_kPlotData$224632 = -1128				; size = 4
_eResourceType$224641 = -1124				; size = 4
_pkPlot$224633 = -1120					; size = 4
_i$224628 = -1116					; size = 4
_sFilename$224609 = -1112				; size = 4
_FStringFixedBuffer_sFilename$224623 = -1108		; size = 532
_sFileTitle$224624 = -568				; size = 4
_FStringFixedBuffer_sFileTitle$224625 = -564		; size = 532
__$ArrayPad$ = -24					; size = 4
_kMap$ = -20						; size = 4
_uiPlotCount$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_wszFilename$ = 8					; size = 4
_szMapName$ = 12					; size = 4
?Save@CvWorldBuilderMapLoader@@SA_NPB_WPBD@Z PROC	; CvWorldBuilderMapLoader::Save, COMDAT

; 1392 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Save@CvWorldBuilderMapLoader@@SA_NPB_WPBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1240				; 000004d8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1393 : 	InitTypeDesc();

	call	?InitTypeDesc@@YAXXZ			; InitTypeDesc

; 1394 : 
; 1395 : 	CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 1396 : 	sg_kSave.Resize(kMap.getGridWidth(), kMap.getGridHeight());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T230045[ebp], edx
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T230049[ebp], ecx
	mov	edx, DWORD PTR $T230045[ebp]
	push	edx
	mov	eax, DWORD PTR $T230049[ebp]
	push	eax
	mov	ecx, OFFSET _sg_kSave
	call	?Resize@CvWorldBuilderMap@@QAEXII@Z	; CvWorldBuilderMap::Resize

; 1397 : 	sg_kSave.ClearScenarioData();

	push	0
	mov	ecx, OFFSET _sg_kSave
	call	?ClearScenarioData@CvWorldBuilderMap@@QAEX_N@Z ; CvWorldBuilderMap::ClearScenarioData

; 1398 : 
; 1399 : 	// Set map name
; 1400 : 	if(szMapName == NULL)

	cmp	DWORD PTR _szMapName$[ebp], 0
	jne	$LN28@Save

; 1401 : 	{
; 1402 : 		FStringFixedBufferW(sFilename, MAX_PATH);

	call	?FStringW_GetStringInitData@@YAPAUFStringWData@FStringW@@XZ ; FStringW_GetStringInitData
	mov	DWORD PTR $T230055[ebp], eax
	mov	ecx, DWORD PTR $T230055[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR _sFilename$224609[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	xor	edx, edx
	mov	WORD PTR _FStringFixedBuffer_sFilename$224623[ebp+8], dx
	mov	eax, 1
	mov	WORD PTR _FStringFixedBuffer_sFilename$224623[ebp+10], ax
	mov	DWORD PTR _FStringFixedBuffer_sFilename$224623[ebp], 260 ; 00000104H
	mov	DWORD PTR _FStringFixedBuffer_sFilename$224623[ebp+4], 0
	xor	ecx, ecx
	mov	WORD PTR _FStringFixedBuffer_sFilename$224623[ebp+12], cx
	lea	edx, DWORD PTR _FStringFixedBuffer_sFilename$224623[ebp]
	push	edx
	lea	ecx, DWORD PTR _sFilename$224609[ebp]
	call	?SetFixedBuffer@FStringW@@QAEXPAUFStringWData@1@@Z ; FStringW::SetFixedBuffer

; 1403 : 		FStringFixedBufferW(sFileTitle, MAX_PATH);

	call	?FStringW_GetStringInitData@@YAPAUFStringWData@FStringW@@XZ ; FStringW_GetStringInitData
	mov	DWORD PTR $T230074[ebp], eax
	mov	eax, DWORD PTR $T230074[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _sFileTitle$224624[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	xor	ecx, ecx
	mov	WORD PTR _FStringFixedBuffer_sFileTitle$224625[ebp+8], cx
	mov	edx, 1
	mov	WORD PTR _FStringFixedBuffer_sFileTitle$224625[ebp+10], dx
	mov	DWORD PTR _FStringFixedBuffer_sFileTitle$224625[ebp], 260 ; 00000104H
	mov	DWORD PTR _FStringFixedBuffer_sFileTitle$224625[ebp+4], 0
	xor	eax, eax
	mov	WORD PTR _FStringFixedBuffer_sFileTitle$224625[ebp+12], ax
	lea	ecx, DWORD PTR _FStringFixedBuffer_sFileTitle$224625[ebp]
	push	ecx
	lea	ecx, DWORD PTR _sFileTitle$224624[ebp]
	call	?SetFixedBuffer@FStringW@@QAEXPAUFStringWData@1@@Z ; FStringW::SetFixedBuffer

; 1404 : 
; 1405 : 		sFilename = wszFilename;

	cmp	DWORD PTR _wszFilename$[ebp], 0
	je	SHORT $LN59@Save
	mov	edx, DWORD PTR _wszFilename$[ebp]
	mov	DWORD PTR tv425[ebp], edx
	mov	eax, DWORD PTR tv425[ebp]
	add	eax, 2
	mov	DWORD PTR tv428[ebp], eax
$LL175@Save:
	mov	ecx, DWORD PTR tv425[ebp]
	mov	dx, WORD PTR [ecx]
	mov	WORD PTR tv431[ebp], dx
	add	DWORD PTR tv425[ebp], 2
	cmp	WORD PTR tv431[ebp], 0
	jne	SHORT $LL175@Save
	mov	eax, DWORD PTR tv425[ebp]
	sub	eax, DWORD PTR tv428[ebp]
	sar	eax, 1
	mov	DWORD PTR tv286[ebp], eax
	mov	ecx, DWORD PTR tv286[ebp]
	mov	DWORD PTR tv288[ebp], ecx
	jmp	SHORT $LN57@Save
$LN59@Save:
	mov	DWORD PTR tv288[ebp], 0
$LN57@Save:
	push	0
	mov	edx, DWORD PTR _wszFilename$[ebp]
	push	edx
	mov	eax, DWORD PTR tv288[ebp]
	push	eax
	lea	ecx, DWORD PTR _sFilename$224609[ebp]
	call	?Copy@FStringW@@QAEXHPB_WH@Z		; FStringW::Copy

; 1406 : 		sFilename.ExtractFileTitle(sFileTitle);

	push	92					; 0000005cH
	lea	ecx, DWORD PTR _sFileTitle$224624[ebp]
	push	ecx
	lea	ecx, DWORD PTR _sFilename$224609[ebp]
	call	?ExtractFileTitle@FStringW@@QBEXAAV1@_W@Z ; FStringW::ExtractFileTitle

; 1407 : 		sFileTitle.CopyToUTF8(&sg_kSave.m_sMapName);

	push	OFFSET _sg_kSave+4008
	lea	ecx, DWORD PTR _sFileTitle$224624[ebp]
	call	?CopyToUTF8@FStringW@@QBEXPAVFStringA@@@Z ; FStringW::CopyToUTF8

; 1408 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _sFileTitle$224624[ebp]
	call	??1FStringW@@QAE@XZ			; FStringW::~FStringW
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sFilename$224609[ebp]
	call	??1FStringW@@QAE@XZ			; FStringW::~FStringW

; 1409 : 	else

	jmp	SHORT $LN27@Save
$LN28@Save:

; 1410 : 	{
; 1411 : 		sg_kSave.m_sMapName = szMapName;

	cmp	DWORD PTR _szMapName$[ebp], 0
	je	SHORT $LN85@Save
	mov	edx, DWORD PTR _szMapName$[ebp]
	mov	DWORD PTR tv441[ebp], edx
	mov	eax, DWORD PTR tv441[ebp]
	add	eax, 1
	mov	DWORD PTR tv444[ebp], eax
$LL176@Save:
	mov	ecx, DWORD PTR tv441[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv447[ebp], dl
	add	DWORD PTR tv441[ebp], 1
	cmp	BYTE PTR tv447[ebp], 0
	jne	SHORT $LL176@Save
	mov	eax, DWORD PTR tv441[ebp]
	sub	eax, DWORD PTR tv444[ebp]
	mov	DWORD PTR tv298[ebp], eax
	mov	ecx, DWORD PTR tv298[ebp]
	mov	DWORD PTR tv300[ebp], ecx
	jmp	SHORT $LN83@Save
$LN85@Save:
	mov	DWORD PTR tv300[ebp], 0
$LN83@Save:
	push	0
	mov	edx, DWORD PTR _szMapName$[ebp]
	push	edx
	mov	eax, DWORD PTR tv300[ebp]
	push	eax
	mov	ecx, OFFSET _sg_kSave+4008
	call	?Copy@FStringA@@QAEXHPBDH@Z		; FStringA::Copy
$LN27@Save:

; 1412 : 	}
; 1413 : 
; 1414 : 	sg_kSave.m_sMapDescription = "";

	mov	ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
	test	ecx, ecx
	je	SHORT $LN91@Save
	mov	DWORD PTR tv456[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	edx, DWORD PTR tv456[ebp]
	add	edx, 1
	mov	DWORD PTR tv459[ebp], edx
$LL177@Save:
	mov	eax, DWORD PTR tv456[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv462[ebp], cl
	add	DWORD PTR tv456[ebp], 1
	cmp	BYTE PTR tv462[ebp], 0
	jne	SHORT $LL177@Save
	mov	edx, DWORD PTR tv456[ebp]
	sub	edx, DWORD PTR tv459[ebp]
	mov	DWORD PTR tv306[ebp], edx
	mov	eax, DWORD PTR tv306[ebp]
	mov	DWORD PTR tv308[ebp], eax
	jmp	SHORT $LN89@Save
$LN91@Save:
	mov	DWORD PTR tv308[ebp], 0
$LN89@Save:
	push	0
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR tv308[ebp]
	push	ecx
	mov	ecx, OFFSET _sg_kSave+4012
	call	?Copy@FStringA@@QAEXHPBDH@Z		; FStringA::Copy

; 1415 : 
; 1416 : 	sg_kSave.m_uiFlags = 0;

	mov	DWORD PTR _sg_kSave+12224, 0

; 1417 : 	sg_kSave.SetFlag(CvWorldBuilderMap::FLAG_WORLD_WRAP, kMap.isWrapX());

	mov	edx, DWORD PTR _kMap$[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T230177[ebp], al
	movzx	ecx, BYTE PTR $T230177[ebp]
	test	ecx, ecx
	je	SHORT $LN96@Save
	mov	edx, DWORD PTR _sg_kSave+12224
	or	edx, 1
	mov	DWORD PTR _sg_kSave+12224, edx
	jmp	SHORT $LN97@Save
$LN96@Save:
	mov	eax, 1
	not	eax
	and	eax, DWORD PTR _sg_kSave+12224
	mov	DWORD PTR _sg_kSave+12224, eax
$LN97@Save:

; 1418 : 
; 1419 : 	sg_kSave.SetWorldType(kMap.getWorldInfo().GetType());

	mov	ecx, DWORD PTR _kMap$[ebp]
	call	?getWorldInfo@CvMap@@QBEABVCvWorldInfo@@XZ ; CvMap::getWorldInfo
	mov	DWORD PTR $T230186[ebp], eax
	mov	ecx, DWORD PTR $T230186[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, OFFSET _sg_kSave
	call	?SetWorldType@CvWorldBuilderMap@@QAEXPBD@Z ; CvWorldBuilderMap::SetWorldType

; 1420 : 
; 1421 : 	uint uiPlotCount = sg_kSave.GetWidth() * sg_kSave.GetHeight();

	mov	ecx, DWORD PTR _sg_kSave+12228
	mov	DWORD PTR $T230190[ebp], ecx
	mov	edx, DWORD PTR _sg_kSave+12232
	mov	DWORD PTR $T230194[ebp], edx
	mov	eax, DWORD PTR $T230190[ebp]
	imul	eax, DWORD PTR $T230194[ebp]
	mov	DWORD PTR _uiPlotCount$[ebp], eax

; 1422 : 	for(uint i = 0; i < uiPlotCount; ++i)

	mov	DWORD PTR _i$224628[ebp], 0
	jmp	SHORT $LN26@Save
$LN25@Save:
	mov	ecx, DWORD PTR _i$224628[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$224628[ebp], ecx
$LN26@Save:
	mov	edx, DWORD PTR _i$224628[ebp]
	cmp	edx, DWORD PTR _uiPlotCount$[ebp]
	jae	$LN24@Save

; 1423 : 	{
; 1424 : 		CvWorldBuilderMap::PlotMapData& kPlotData = sg_kSave.GetPlotData(i);

	mov	eax, DWORD PTR _sg_kSave+12228
	imul	eax, DWORD PTR _sg_kSave+12232
	cmp	DWORD PTR _i$224628[ebp], eax
	jae	SHORT $LN106@Save
	cmp	DWORD PTR _i$224628[ebp], 32768		; 00008000H
	jae	SHORT $LN106@Save
	mov	ecx, DWORD PTR _i$224628[ebp]
	lea	edx, DWORD PTR _sg_kSave[ecx*8+12320]
	mov	DWORD PTR _kPlotData$224632[ebp], edx
	jmp	SHORT $LN107@Save
	jmp	SHORT $LN107@Save
$LN106@Save:
	mov	DWORD PTR _kPlotData$224632[ebp], OFFSET ?sm_kErrorPlotMapData@CvWorldBuilderMap@@0VPlotMapData@1@A ; CvWorldBuilderMap::sm_kErrorPlotMapData
$LN107@Save:

; 1425 : 		CvPlot* pkPlot = kMap.plotByIndex(i);

	cmp	DWORD PTR _i$224628[ebp], 0
	jl	SHORT $LN111@Save
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4028]
	mov	DWORD PTR $T230206[ebp], ecx
	mov	edx, DWORD PTR _i$224628[ebp]
	cmp	edx, DWORD PTR $T230206[ebp]
	jge	SHORT $LN111@Save
	mov	eax, DWORD PTR _i$224628[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR _kMap$[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv334[ebp], eax
	jmp	SHORT $LN109@Save
$LN111@Save:
	mov	DWORD PTR tv334[ebp], 0
$LN109@Save:
	mov	edx, DWORD PTR tv334[ebp]
	mov	DWORD PTR _pkPlot$224633[ebp], edx

; 1426 : 		FAssertMsg(pkPlot, "Missing CvPlot for this location");
; 1427 : 		if(pkPlot == NULL) continue;

	cmp	DWORD PTR _pkPlot$224633[ebp], 0
	jne	SHORT $LN115@Save
	jmp	$LN25@Save

; 1428 : 
; 1429 : 		kPlotData.SetTerrainType((byte)pkPlot->getTerrainType());

$LN115@Save:
	mov	eax, DWORD PTR _pkPlot$224633[ebp]
	movsx	ecx, BYTE PTR [eax+6]
	mov	BYTE PTR $T230219[ebp], cl
	mov	edx, DWORD PTR _kPlotData$224632[ebp]
	mov	al, BYTE PTR $T230219[ebp]
	mov	BYTE PTR [edx], al

; 1430 : 
; 1431 : 		PlotTypes ePlotType = pkPlot->getPlotType();

	mov	ecx, DWORD PTR _pkPlot$224633[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	mov	DWORD PTR _ePlotType$224636[ebp], edx

; 1432 : 		if(ePlotType == PLOT_HILLS)

	cmp	DWORD PTR _ePlotType$224636[ebp], 1
	jne	SHORT $LN22@Save

; 1433 : 			kPlotData.SetPlotHeight(CvWorldBuilderMap::PlotMapData::HILLS);

	mov	eax, DWORD PTR _kPlotData$224632[ebp]
	mov	BYTE PTR [eax+4], 1

; 1434 : 		else if(ePlotType == PLOT_MOUNTAIN)

	jmp	SHORT $LN21@Save
$LN22@Save:
	cmp	DWORD PTR _ePlotType$224636[ebp], 0
	jne	SHORT $LN20@Save

; 1435 : 			kPlotData.SetPlotHeight(CvWorldBuilderMap::PlotMapData::MOUNTAINS);

	mov	ecx, DWORD PTR _kPlotData$224632[ebp]
	mov	BYTE PTR [ecx+4], 2

; 1436 : 		else

	jmp	SHORT $LN21@Save
$LN20@Save:

; 1437 : 			kPlotData.SetPlotHeight(CvWorldBuilderMap::
; 1438 : 			                        PlotMapData::FLAT_TERRAIN);

	mov	edx, DWORD PTR _kPlotData$224632[ebp]
	mov	BYTE PTR [edx+4], 0
$LN21@Save:

; 1439 : 
; 1440 : 		ResourceTypes eResourceType = pkPlot->getResourceType();

	push	-1
	mov	ecx, DWORD PTR _pkPlot$224633[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _eResourceType$224641[ebp], eax

; 1441 : 		if(eResourceType == NO_RESOURCE)

	cmp	DWORD PTR _eResourceType$224641[ebp], -1
	jne	SHORT $LN18@Save

; 1442 : 		{
; 1443 : 			kPlotData.SetResourceType(CvWorldBuilderMap::PlotMapData::InvalidResource);

	mov	eax, DWORD PTR _kPlotData$224632[ebp]
	mov	BYTE PTR [eax+1], 255			; 000000ffH

; 1444 : 		}
; 1445 : 		else

	jmp	SHORT $LN135@Save
$LN18@Save:

; 1446 : 		{
; 1447 : 			kPlotData.SetResourceType((byte)eResourceType);

	mov	ecx, DWORD PTR _kPlotData$224632[ebp]
	mov	dl, BYTE PTR _eResourceType$224641[ebp]
	mov	BYTE PTR [ecx+1], dl

; 1448 : 			kPlotData.SetResourceAmount((byte)pkPlot->getNumResource());

	mov	ecx, DWORD PTR _pkPlot$224633[ebp]
	call	?getNumResource@CvPlot@@QBEHXZ		; CvPlot::getNumResource
	mov	BYTE PTR $T230241[ebp], al
	mov	eax, DWORD PTR _kPlotData$224632[ebp]
	mov	cl, BYTE PTR $T230241[ebp]
	mov	BYTE PTR [eax+7], cl

; 1449 : 		}
; 1450 : 
; 1451 : 		FeatureTypes eFeatureType = pkPlot->getFeatureType();

$LN135@Save:
	mov	edx, DWORD PTR _pkPlot$224633[ebp]
	mov	al, BYTE PTR [edx+432]
	mov	BYTE PTR _f$230247[ebp], al
	movsx	ecx, BYTE PTR _f$230247[ebp]
	mov	DWORD PTR _eFeatureType$224646[ebp], ecx

; 1452 : 		if(eFeatureType == NO_FEATURE)

	cmp	DWORD PTR _eFeatureType$224646[ebp], -1
	jne	SHORT $LN16@Save

; 1453 : 		{
; 1454 : 			kPlotData.SetFeatureType(CvWorldBuilderMap::PlotMapData::InvalidFeature);

	mov	edx, DWORD PTR _kPlotData$224632[ebp]
	mov	BYTE PTR [edx+2], 255			; 000000ffH

; 1455 : 			kPlotData.SetNaturalWonderType(CvWorldBuilderMap::PlotMapData::InvalidNaturalWonder);

	mov	eax, DWORD PTR _kPlotData$224632[ebp]
	mov	BYTE PTR [eax+6], 255			; 000000ffH

; 1456 : 		}
; 1457 : 		else

	jmp	SHORT $LN15@Save
$LN16@Save:

; 1458 : 		{
; 1459 : 			CvFeatureInfo* pkFeatureInfo = GC.getFeatureInfo(eFeatureType);

	mov	ecx, DWORD PTR _eFeatureType$224646[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	DWORD PTR _pkFeatureInfo$224649[ebp], eax

; 1460 : 			if(pkFeatureInfo != NULL && pkFeatureInfo->IsNaturalWonder())

	cmp	DWORD PTR _pkFeatureInfo$224649[ebp], 0
	je	SHORT $LN14@Save
	mov	ecx, DWORD PTR _pkFeatureInfo$224649[ebp]
	call	?IsNaturalWonder@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::IsNaturalWonder
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN14@Save

; 1461 : 			{
; 1462 : 				kPlotData.SetFeatureType(CvWorldBuilderMap::PlotMapData::InvalidFeature);

	mov	eax, DWORD PTR _kPlotData$224632[ebp]
	mov	BYTE PTR [eax+2], 255			; 000000ffH

; 1463 : 				kPlotData.SetNaturalWonderType((byte)eFeatureType);

	mov	ecx, DWORD PTR _kPlotData$224632[ebp]
	mov	dl, BYTE PTR _eFeatureType$224646[ebp]
	mov	BYTE PTR [ecx+6], dl

; 1464 : 			}
; 1465 : 			else

	jmp	SHORT $LN15@Save
$LN14@Save:

; 1466 : 			{
; 1467 : 				kPlotData.SetFeatureType((byte)eFeatureType);

	mov	eax, DWORD PTR _kPlotData$224632[ebp]
	mov	cl, BYTE PTR _eFeatureType$224646[ebp]
	mov	BYTE PTR [eax+2], cl

; 1468 : 				kPlotData.SetNaturalWonderType(CvWorldBuilderMap::PlotMapData::InvalidNaturalWonder);

	mov	edx, DWORD PTR _kPlotData$224632[ebp]
	mov	BYTE PTR [edx+6], 255			; 000000ffH
$LN15@Save:

; 1469 : 			}
; 1470 : 		}
; 1471 : 
; 1472 : 		if(pkPlot->isWOfRiver())

	mov	ecx, DWORD PTR _pkPlot$224633[ebp]
	call	?isWOfRiver@CvPlot@@QBE_NXZ		; CvPlot::isWOfRiver
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN12@Save

; 1473 : 		{
; 1474 : 			kPlotData.SetFlag(CvWorldBuilderMap::PlotMapData::W_OF_RIVER);

	mov	ecx, DWORD PTR _kPlotData$224632[ebp]
	movzx	edx, BYTE PTR [ecx+3]
	or	edx, 1
	mov	eax, DWORD PTR _kPlotData$224632[ebp]
	mov	BYTE PTR [eax+3], dl

; 1475 : 			if(pkPlot->getRiverEFlowDirection() == FLOWDIRECTION_SOUTH)

	mov	ecx, DWORD PTR _pkPlot$224633[ebp]
	call	?getRiverEFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ ; CvPlot::getRiverEFlowDirection
	cmp	eax, 3
	jne	SHORT $LN11@Save

; 1476 : 				kPlotData.SetFlag(CvWorldBuilderMap::PlotMapData::RIVER_FLOW_S);

	mov	ecx, DWORD PTR _kPlotData$224632[ebp]
	movzx	edx, BYTE PTR [ecx+3]
	or	edx, 8
	mov	eax, DWORD PTR _kPlotData$224632[ebp]
	mov	BYTE PTR [eax+3], dl

; 1477 : 			else

	jmp	SHORT $LN10@Save
$LN11@Save:

; 1478 : 				kPlotData.ClearFlag(CvWorldBuilderMap::PlotMapData::RIVER_FLOW_S);

	mov	ecx, 8
	not	ecx
	mov	edx, DWORD PTR _kPlotData$224632[ebp]
	movzx	eax, BYTE PTR [edx+3]
	and	eax, ecx
	mov	ecx, DWORD PTR _kPlotData$224632[ebp]
	mov	BYTE PTR [ecx+3], al
$LN10@Save:

; 1479 : 		}
; 1480 : 		else

	jmp	SHORT $LN9@Save
$LN12@Save:

; 1481 : 		{
; 1482 : 			kPlotData.ClearFlag(CvWorldBuilderMap::PlotMapData::W_OF_RIVER);

	mov	edx, 1
	not	edx
	mov	eax, DWORD PTR _kPlotData$224632[ebp]
	movzx	ecx, BYTE PTR [eax+3]
	and	ecx, edx
	mov	edx, DWORD PTR _kPlotData$224632[ebp]
	mov	BYTE PTR [edx+3], cl
$LN9@Save:

; 1483 : 		}
; 1484 : 
; 1485 : 		if(pkPlot->isNWOfRiver())

	mov	ecx, DWORD PTR _pkPlot$224633[ebp]
	call	?isNWOfRiver@CvPlot@@QBE_NXZ		; CvPlot::isNWOfRiver
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@Save

; 1486 : 		{
; 1487 : 			kPlotData.SetFlag(CvWorldBuilderMap::PlotMapData::NW_OF_RIVER);

	mov	ecx, DWORD PTR _kPlotData$224632[ebp]
	movzx	edx, BYTE PTR [ecx+3]
	or	edx, 2
	mov	eax, DWORD PTR _kPlotData$224632[ebp]
	mov	BYTE PTR [eax+3], dl

; 1488 : 			if(pkPlot->getRiverSEFlowDirection() == FLOWDIRECTION_NORTHEAST)

	mov	ecx, DWORD PTR _pkPlot$224633[ebp]
	call	?getRiverSEFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ ; CvPlot::getRiverSEFlowDirection
	cmp	eax, 1
	jne	SHORT $LN7@Save

; 1489 : 				kPlotData.SetFlag(CvWorldBuilderMap::PlotMapData::RIVER_FLOW_NE);

	mov	ecx, DWORD PTR _kPlotData$224632[ebp]
	movzx	edx, BYTE PTR [ecx+3]
	or	edx, 16					; 00000010H
	mov	eax, DWORD PTR _kPlotData$224632[ebp]
	mov	BYTE PTR [eax+3], dl

; 1490 : 			else

	jmp	SHORT $LN6@Save
$LN7@Save:

; 1491 : 				kPlotData.ClearFlag(CvWorldBuilderMap::PlotMapData::RIVER_FLOW_NE);

	mov	ecx, 16					; 00000010H
	not	ecx
	mov	edx, DWORD PTR _kPlotData$224632[ebp]
	movzx	eax, BYTE PTR [edx+3]
	and	eax, ecx
	mov	ecx, DWORD PTR _kPlotData$224632[ebp]
	mov	BYTE PTR [ecx+3], al
$LN6@Save:

; 1492 : 		}
; 1493 : 		else

	jmp	SHORT $LN5@Save
$LN8@Save:

; 1494 : 		{
; 1495 : 			kPlotData.ClearFlag(CvWorldBuilderMap::PlotMapData::NW_OF_RIVER);

	mov	edx, 2
	not	edx
	mov	eax, DWORD PTR _kPlotData$224632[ebp]
	movzx	ecx, BYTE PTR [eax+3]
	and	ecx, edx
	mov	edx, DWORD PTR _kPlotData$224632[ebp]
	mov	BYTE PTR [edx+3], cl
$LN5@Save:

; 1496 : 		}
; 1497 : 
; 1498 : 		if(pkPlot->isNEOfRiver())

	mov	ecx, DWORD PTR _pkPlot$224633[ebp]
	call	?isNEOfRiver@CvPlot@@QBE_NXZ		; CvPlot::isNEOfRiver
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@Save

; 1499 : 		{
; 1500 : 			kPlotData.SetFlag(CvWorldBuilderMap::PlotMapData::NE_OF_RIVER);

	mov	ecx, DWORD PTR _kPlotData$224632[ebp]
	movzx	edx, BYTE PTR [ecx+3]
	or	edx, 4
	mov	eax, DWORD PTR _kPlotData$224632[ebp]
	mov	BYTE PTR [eax+3], dl

; 1501 : 			if(pkPlot->getRiverSWFlowDirection() == FLOWDIRECTION_NORTHWEST)

	mov	ecx, DWORD PTR _pkPlot$224633[ebp]
	call	?getRiverSWFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ ; CvPlot::getRiverSWFlowDirection
	cmp	eax, 5
	jne	SHORT $LN3@Save

; 1502 : 				kPlotData.SetFlag(CvWorldBuilderMap::PlotMapData::RIVER_FLOW_NW);

	mov	ecx, DWORD PTR _kPlotData$224632[ebp]
	movzx	edx, BYTE PTR [ecx+3]
	or	edx, 32					; 00000020H
	mov	eax, DWORD PTR _kPlotData$224632[ebp]
	mov	BYTE PTR [eax+3], dl

; 1503 : 			else

	jmp	SHORT $LN2@Save
$LN3@Save:

; 1504 : 				kPlotData.ClearFlag(CvWorldBuilderMap::PlotMapData::RIVER_FLOW_NW);

	mov	ecx, 32					; 00000020H
	not	ecx
	mov	edx, DWORD PTR _kPlotData$224632[ebp]
	movzx	eax, BYTE PTR [edx+3]
	and	eax, ecx
	mov	ecx, DWORD PTR _kPlotData$224632[ebp]
	mov	BYTE PTR [ecx+3], al
$LN2@Save:

; 1505 : 		}
; 1506 : 		else

	jmp	SHORT $LN1@Save
$LN4@Save:

; 1507 : 		{
; 1508 : 			kPlotData.ClearFlag(CvWorldBuilderMap::PlotMapData::NE_OF_RIVER);

	mov	edx, 4
	not	edx
	mov	eax, DWORD PTR _kPlotData$224632[ebp]
	movzx	ecx, BYTE PTR [eax+3]
	and	ecx, edx
	mov	edx, DWORD PTR _kPlotData$224632[ebp]
	mov	BYTE PTR [edx+3], cl
$LN1@Save:

; 1509 : 		}
; 1510 : 
; 1511 : #ifdef AUI_WARNING_FIXES
; 1512 : 		kPlotData.SetContinentType((byte)pkPlot->GetContinentType());
; 1513 : #else
; 1514 : 		kPlotData.SetContinentType(pkPlot->GetContinentType());

	mov	ecx, DWORD PTR _pkPlot$224633[ebp]
	call	?GetContinentType@CvPlot@@QBEDXZ	; CvPlot::GetContinentType
	mov	BYTE PTR $T230308[ebp], al
	mov	eax, DWORD PTR _kPlotData$224632[ebp]
	mov	cl, BYTE PTR $T230308[ebp]
	mov	BYTE PTR [eax+5], cl

; 1515 : #endif
; 1516 : 	}

	jmp	$LN25@Save
$LN24@Save:

; 1517 : 
; 1518 : 	return sg_kSave.Save(wszFilename, sg_kMapTypeDesc, false);

	push	0
	push	OFFSET _sg_kMapTypeDesc
	mov	edx, DWORD PTR _wszFilename$[ebp]
	push	edx
	mov	ecx, OFFSET _sg_kSave
	call	?Save@CvWorldBuilderMap@@QBE_NPB_WABVCvWorldBuilderMapTypeDesc@@_N@Z ; CvWorldBuilderMap::Save

; 1519 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Save@CvWorldBuilderMapLoader@@SA_NPB_WPBD@Z$0:
	lea	ecx, DWORD PTR _sFilename$224609[ebp]
	jmp	??1FStringW@@QAE@XZ			; FStringW::~FStringW
__unwindfunclet$?Save@CvWorldBuilderMapLoader@@SA_NPB_WPBD@Z$1:
	lea	ecx, DWORD PTR _sFileTitle$224624[ebp]
	jmp	??1FStringW@@QAE@XZ			; FStringW::~FStringW
__ehhandler$?Save@CvWorldBuilderMapLoader@@SA_NPB_WPBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1244]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Save@CvWorldBuilderMapLoader@@SA_NPB_WPBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Save@CvWorldBuilderMapLoader@@SA_NPB_WPBD@Z ENDP	; CvWorldBuilderMapLoader::Save
PUBLIC	??_C@_05CKNOMBAL@Plots?$AA@			; `string'
PUBLIC	??_C@_07CJIGNMEG@Globals?$AA@			; `string'
PUBLIC	??_C@_0L@BKNGOEJJ@MapModData?$AA@		; `string'
PUBLIC	?LoadModData@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z ; CvWorldBuilderMapLoader::LoadModData
EXTRN	_lua_rawseti:PROC
EXTRN	_lua_pushvalue:PROC
EXTRN	?IsFieldDefaultValue@ModDataEntry@@QBE_NI@Z:PROC ; ModDataEntry::IsFieldDefaultValue
EXTRN	?GetPlotDataEntry@CvWorldBuilderMapModData@@QAE?AVModDataEntry@@I@Z:PROC ; CvWorldBuilderMapModData::GetPlotDataEntry
EXTRN	?GetFieldDefaultAsInt@ModType@@QBEHI@Z:PROC	; ModType::GetFieldDefaultAsInt
EXTRN	?GetFieldDefaultAsString@ModType@@QBEPBDI@Z:PROC ; ModType::GetFieldDefaultAsString
EXTRN	?GetFieldDefaultAsFloat@ModType@@QBEMI@Z:PROC	; ModType::GetFieldDefaultAsFloat
EXTRN	?GetFieldDefaultAsBool@ModType@@QBE_NI@Z:PROC	; ModType::GetFieldDefaultAsBool
EXTRN	_lua_pushnil:PROC
EXTRN	_lua_rawset:PROC
EXTRN	?GetMember@ModEnum@@QBEPBDI@Z:PROC		; ModEnum::GetMember
EXTRN	?GetFieldAsInt@ModDataEntry@@QBEHI@Z:PROC	; ModDataEntry::GetFieldAsInt
EXTRN	?GetFieldEnumType@ModType@@QBEPBVModEnum@@I@Z:PROC ; ModType::GetFieldEnumType
EXTRN	?GetFieldAsString@ModDataEntry@@QBEPBDI@Z:PROC	; ModDataEntry::GetFieldAsString
EXTRN	_lua_pushnumber:PROC
EXTRN	?GetFieldAsFloat@ModDataEntry@@QBEMI@Z:PROC	; ModDataEntry::GetFieldAsFloat
EXTRN	_lua_pushboolean:PROC
EXTRN	?GetFieldAsBool@ModDataEntry@@QBE_NI@Z:PROC	; ModDataEntry::GetFieldAsBool
EXTRN	?GetFieldType@ModType@@QBE?AW4FieldType@1@I@Z:PROC ; ModType::GetFieldType
EXTRN	?GetFieldName@ModType@@QBEPBDI@Z:PROC		; ModType::GetFieldName
EXTRN	_lua_createtable:PROC
EXTRN	_lua_pushstring:PROC
EXTRN	?GetMapDataEntry@CvWorldBuilderMapModData@@QAE?AVModDataEntry@@XZ:PROC ; CvWorldBuilderMapModData::GetMapDataEntry
EXTRN	?GetFieldCount@ModType@@QBEIXZ:PROC		; ModType::GetFieldCount
EXTRN	_lua_settop:PROC
EXTRN	_lua_type:PROC
EXTRN	_lua_getfield:PROC
EXTRN	_lua_gettop:PROC
;	COMDAT ??_C@_05CKNOMBAL@Plots?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvworldbuildermap\include\cvworldbuildermap.h
CONST	SEGMENT
??_C@_05CKNOMBAL@Plots?$AA@ DB 'Plots', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CJIGNMEG@Globals?$AA@
CONST	SEGMENT
??_C@_07CJIGNMEG@Globals?$AA@ DB 'Globals', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BKNGOEJJ@MapModData?$AA@
CONST	SEGMENT
??_C@_0L@BKNGOEJJ@MapModData?$AA@ DB 'MapModData', 00H	; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvworldbuildermaploader.cpp
CONST	ENDS
;	COMDAT ?LoadModData@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z
_TEXT	SEGMENT
tv303 = -168						; size = 4
tv192 = -164						; size = 4
tv133 = -160						; size = 4
_szMember$224765 = -156					; size = 4
_iValue$224762 = -152					; size = 4
_pkEnum$224763 = -148					; size = 4
_szField$224760 = -144					; size = 4
_fValue$224758 = -140					; size = 4
_bValue$224756 = -133					; size = 1
_uiField$224745 = -132					; size = 4
_kPlot$224743 = -128					; size = 8
_y$224739 = -120					; size = 4
_x$224735 = -116					; size = 4
_szMember$224728 = -112					; size = 4
_iValue$224725 = -108					; size = 4
_pkEnum$224726 = -104					; size = 4
_szField$224723 = -100					; size = 4
_fValue$224721 = -96					; size = 4
_bValue$224719 = -89					; size = 1
_szFieldName$224713 = -88				; size = 4
_uiField$224709 = -84					; size = 4
_uiMapWidth$224732 = -80				; size = 4
_uiMapHeight$224733 = -76				; size = 4
_iFieldStart$224708 = -72				; size = 4
_szMember$224700 = -68					; size = 4
_iValue$224699 = -64					; size = 4
_pkEnum$224697 = -60					; size = 4
_szField$224695 = -56					; size = 4
_fValue$224693 = -52					; size = 4
_bValue$224691 = -45					; size = 1
_szFieldName$224685 = -44				; size = 4
_uiField$224681 = -40					; size = 4
_kEntry$224678 = -36					; size = 8
_kGlobalsDataType$ = -28				; size = 4
_kPlotDataType$ = -24					; size = 4
_uiGlobalsCount$ = -20					; size = 4
_iModDataTable$ = -16					; size = 4
_uiFieldCount$ = -12					; size = 4
_bFoundTable$ = -5					; size = 1
_iTop$ = -4						; size = 4
_L$ = 8							; size = 4
?LoadModData@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z PROC ; CvWorldBuilderMapLoader::LoadModData, COMDAT

; 1522 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 168				; 000000a8H

; 1523 : 	if(L == NULL)

	cmp	DWORD PTR _L$[ebp], 0
	jne	SHORT $LN49@LoadModDat

; 1524 : 	{
; 1525 : 		FAssertMsg(L, "Seriously, you really need a lua state for this.");
; 1526 : 		return 0;

	xor	eax, eax
	jmp	$LN50@LoadModDat
$LN49@LoadModDat:

; 1527 : 	}
; 1528 : 
; 1529 : 	const int iTop = lua_gettop(L);

	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_gettop
	add	esp, 4
	mov	DWORD PTR _iTop$[ebp], eax

; 1530 : 
; 1531 : 	lua_getglobal(L, "MapModData");

	push	OFFSET ??_C@_0L@BKNGOEJJ@MapModData?$AA@
	push	-10002					; ffffd8eeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_getfield
	add	esp, 12					; 0000000cH

; 1532 : 	bool bFoundTable = lua_istable(L, -1);

	push	-1
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_type
	add	esp, 8
	xor	ecx, ecx
	cmp	eax, 5
	sete	cl
	mov	BYTE PTR _bFoundTable$[ebp], cl

; 1533 : 
; 1534 : 	FAssertMsg(bFoundTable, "Unable to find mod data table");
; 1535 : 	if(!bFoundTable)

	movzx	edx, BYTE PTR _bFoundTable$[ebp]
	test	edx, edx
	jne	SHORT $LN48@LoadModDat

; 1536 : 	{
; 1537 : 		lua_settop(L, iTop);

	mov	eax, DWORD PTR _iTop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_settop
	add	esp, 8

; 1538 : 		return 0;

	xor	eax, eax
	jmp	$LN50@LoadModDat
$LN48@LoadModDat:

; 1539 : 	}
; 1540 : 
; 1541 : 	const int iModDataTable = iTop + 1;

	mov	edx, DWORD PTR _iTop$[ebp]
	add	edx, 1
	mov	DWORD PTR _iModDataTable$[ebp], edx

; 1542 : 
; 1543 : 	ModType& kGlobalsDataType = sg_kSave.m_kModData.m_kMapModData;

	mov	DWORD PTR _kGlobalsDataType$[ebp], OFFSET _sg_kSave+2888

; 1544 : 	const uint uiGlobalsCount = kGlobalsDataType.GetFieldCount();

	mov	ecx, DWORD PTR _kGlobalsDataType$[ebp]
	call	?GetFieldCount@ModType@@QBEIXZ		; ModType::GetFieldCount
	mov	DWORD PTR _uiGlobalsCount$[ebp], eax

; 1545 : 	if(uiGlobalsCount > 0)

	cmp	DWORD PTR _uiGlobalsCount$[ebp], 0
	jbe	$LN47@LoadModDat

; 1546 : 	{
; 1547 : 		ModDataEntry kEntry = sg_kSave.m_kModData.GetMapDataEntry();

	lea	eax, DWORD PTR _kEntry$224678[ebp]
	push	eax
	mov	ecx, OFFSET _sg_kSave+2888
	call	?GetMapDataEntry@CvWorldBuilderMapModData@@QAE?AVModDataEntry@@XZ ; CvWorldBuilderMapModData::GetMapDataEntry

; 1548 : 
; 1549 : 		lua_pushstring(L, "Globals");

	push	OFFSET ??_C@_07CJIGNMEG@Globals?$AA@
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushstring
	add	esp, 8

; 1550 : 		lua_createtable(L, 0, uiGlobalsCount);

	mov	edx, DWORD PTR _uiGlobalsCount$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_createtable
	add	esp, 12					; 0000000cH

; 1551 : 		for(uint uiField = 0; uiField < uiGlobalsCount; ++uiField)

	mov	DWORD PTR _uiField$224681[ebp], 0
	jmp	SHORT $LN46@LoadModDat
$LN45@LoadModDat:
	mov	ecx, DWORD PTR _uiField$224681[ebp]
	add	ecx, 1
	mov	DWORD PTR _uiField$224681[ebp], ecx
$LN46@LoadModDat:
	mov	edx, DWORD PTR _uiField$224681[ebp]
	cmp	edx, DWORD PTR _uiGlobalsCount$[ebp]
	jae	$LN44@LoadModDat

; 1552 : 		{
; 1553 : 			const char* szFieldName = kGlobalsDataType.GetFieldName(uiField);

	mov	eax, DWORD PTR _uiField$224681[ebp]
	push	eax
	mov	ecx, DWORD PTR _kGlobalsDataType$[ebp]
	call	?GetFieldName@ModType@@QBEPBDI@Z	; ModType::GetFieldName
	mov	DWORD PTR _szFieldName$224685[ebp], eax

; 1554 : 			lua_pushstring(L, szFieldName);

	mov	ecx, DWORD PTR _szFieldName$224685[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushstring
	add	esp, 8

; 1555 : 
; 1556 : 			switch(kGlobalsDataType.GetFieldType(uiField))

	mov	eax, DWORD PTR _uiField$224681[ebp]
	push	eax
	mov	ecx, DWORD PTR _kGlobalsDataType$[ebp]
	call	?GetFieldType@ModType@@QBE?AW4FieldType@1@I@Z ; ModType::GetFieldType
	mov	DWORD PTR tv133[ebp], eax
	cmp	DWORD PTR tv133[ebp], 3
	ja	$LN42@LoadModDat
	mov	ecx, DWORD PTR tv133[ebp]
	jmp	DWORD PTR $LN56@LoadModDat[ecx*4]
$LN41@LoadModDat:

; 1557 : 			{
; 1558 : 			case ModType::TYPE_BOOL:
; 1559 : 			{
; 1560 : 				const bool bValue = kEntry.GetFieldAsBool(uiField);

	mov	edx, DWORD PTR _uiField$224681[ebp]
	push	edx
	lea	ecx, DWORD PTR _kEntry$224678[ebp]
	call	?GetFieldAsBool@ModDataEntry@@QBE_NI@Z	; ModDataEntry::GetFieldAsBool
	mov	BYTE PTR _bValue$224691[ebp], al

; 1561 : 				lua_pushboolean(L, bValue);

	movzx	eax, BYTE PTR _bValue$224691[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushboolean
	add	esp, 8

; 1562 : 			}
; 1563 : 			break;

	jmp	$LN42@LoadModDat
$LN40@LoadModDat:

; 1564 : 
; 1565 : 			case ModType::TYPE_FLOAT:
; 1566 : 			{
; 1567 : 				const float fValue = kEntry.GetFieldAsFloat(uiField);

	mov	edx, DWORD PTR _uiField$224681[ebp]
	push	edx
	lea	ecx, DWORD PTR _kEntry$224678[ebp]
	call	?GetFieldAsFloat@ModDataEntry@@QBEMI@Z	; ModDataEntry::GetFieldAsFloat
	fstp	DWORD PTR _fValue$224693[ebp]

; 1568 : 				lua_pushnumber(L, fValue);

	cvtss2sd xmm0, DWORD PTR _fValue$224693[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushnumber
	add	esp, 12					; 0000000cH

; 1569 : 			}
; 1570 : 			break;

	jmp	$LN42@LoadModDat
$LN39@LoadModDat:

; 1571 : 
; 1572 : 			case ModType::TYPE_STRING:
; 1573 : 			{
; 1574 : 				const char* szField = kEntry.GetFieldAsString(uiField);

	mov	ecx, DWORD PTR _uiField$224681[ebp]
	push	ecx
	lea	ecx, DWORD PTR _kEntry$224678[ebp]
	call	?GetFieldAsString@ModDataEntry@@QBEPBDI@Z ; ModDataEntry::GetFieldAsString
	mov	DWORD PTR _szField$224695[ebp], eax

; 1575 : 				lua_pushstring(L, szField);

	mov	edx, DWORD PTR _szField$224695[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushstring
	add	esp, 8

; 1576 : 			}
; 1577 : 			break;

	jmp	SHORT $LN42@LoadModDat
$LN38@LoadModDat:

; 1578 : 
; 1579 : 			case ModType::TYPE_ENUM:
; 1580 : 			{
; 1581 : 				const ModEnum* pkEnum = sg_kSave.m_kModData.m_kPlotModData.GetFieldEnumType(uiField);

	mov	ecx, DWORD PTR _uiField$224681[ebp]
	push	ecx
	mov	ecx, OFFSET _sg_kSave+3436
	call	?GetFieldEnumType@ModType@@QBEPBVModEnum@@I@Z ; ModType::GetFieldEnumType
	mov	DWORD PTR _pkEnum$224697[ebp], eax

; 1582 : 				if(pkEnum != NULL)

	cmp	DWORD PTR _pkEnum$224697[ebp], 0
	je	SHORT $LN37@LoadModDat

; 1583 : 				{
; 1584 : 					int iValue = kEntry.GetFieldAsInt(uiField);

	mov	edx, DWORD PTR _uiField$224681[ebp]
	push	edx
	lea	ecx, DWORD PTR _kEntry$224678[ebp]
	call	?GetFieldAsInt@ModDataEntry@@QBEHI@Z	; ModDataEntry::GetFieldAsInt
	mov	DWORD PTR _iValue$224699[ebp], eax

; 1585 : 					const char* szMember = pkEnum->GetMember((uint)iValue);

	mov	eax, DWORD PTR _iValue$224699[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkEnum$224697[ebp]
	call	?GetMember@ModEnum@@QBEPBDI@Z		; ModEnum::GetMember
	mov	DWORD PTR _szMember$224700[ebp], eax

; 1586 : 					if(szMember == NULL) szMember = "";

	cmp	DWORD PTR _szMember$224700[ebp], 0
	jne	SHORT $LN36@LoadModDat
	mov	DWORD PTR _szMember$224700[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN36@LoadModDat:

; 1587 : 					lua_pushstring(L, szMember);

	mov	ecx, DWORD PTR _szMember$224700[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushstring
	add	esp, 8

; 1588 : 				}
; 1589 : 				else

	jmp	SHORT $LN35@LoadModDat
$LN37@LoadModDat:

; 1590 : 				{
; 1591 : 					lua_pushstring(L, "");

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushstring
	add	esp, 8
$LN35@LoadModDat:
$LN42@LoadModDat:

; 1592 : 				}
; 1593 : 			}
; 1594 : 			}
; 1595 : 
; 1596 : 			lua_rawset(L, -3);

	push	-3					; fffffffdH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_rawset
	add	esp, 8

; 1597 : 		}

	jmp	$LN45@LoadModDat
$LN44@LoadModDat:

; 1598 : 
; 1599 : 		lua_rawset(L, iModDataTable);

	mov	edx, DWORD PTR _iModDataTable$[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_rawset
	add	esp, 8

; 1600 : 	}
; 1601 : 	else

	jmp	SHORT $LN34@LoadModDat
$LN47@LoadModDat:

; 1602 : 	{
; 1603 : 		lua_pushstring(L, "Globals");

	push	OFFSET ??_C@_07CJIGNMEG@Globals?$AA@
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushstring
	add	esp, 8

; 1604 : 		lua_pushnil(L);

	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushnil
	add	esp, 4

; 1605 : 		lua_rawset(L, iModDataTable);

	mov	eax, DWORD PTR _iModDataTable$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_rawset
	add	esp, 8
$LN34@LoadModDat:

; 1606 : 	}
; 1607 : 
; 1608 : 	ModType& kPlotDataType = sg_kSave.m_kModData.m_kPlotModData;

	mov	DWORD PTR _kPlotDataType$[ebp], OFFSET _sg_kSave+3436

; 1609 : 	const uint uiFieldCount = kPlotDataType.GetFieldCount();

	mov	ecx, DWORD PTR _kPlotDataType$[ebp]
	call	?GetFieldCount@ModType@@QBEIXZ		; ModType::GetFieldCount
	mov	DWORD PTR _uiFieldCount$[ebp], eax

; 1610 : 	if(uiFieldCount > 0)

	cmp	DWORD PTR _uiFieldCount$[ebp], 0
	jbe	$LN33@LoadModDat

; 1611 : 	{
; 1612 : 		const int iFieldStart = lua_gettop(L) + 1;

	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_gettop
	add	esp, 4
	add	eax, 1
	mov	DWORD PTR _iFieldStart$224708[ebp], eax

; 1613 : 		for(uint uiField = 0; uiField < uiFieldCount; ++uiField)

	mov	DWORD PTR _uiField$224709[ebp], 0
	jmp	SHORT $LN32@LoadModDat
$LN31@LoadModDat:
	mov	eax, DWORD PTR _uiField$224709[ebp]
	add	eax, 1
	mov	DWORD PTR _uiField$224709[ebp], eax
$LN32@LoadModDat:
	mov	ecx, DWORD PTR _uiField$224709[ebp]
	cmp	ecx, DWORD PTR _uiFieldCount$[ebp]
	jae	$LN30@LoadModDat

; 1614 : 		{
; 1615 : 			const char* szFieldName = kPlotDataType.GetFieldName(uiField);

	mov	edx, DWORD PTR _uiField$224709[ebp]
	push	edx
	mov	ecx, DWORD PTR _kPlotDataType$[ebp]
	call	?GetFieldName@ModType@@QBEPBDI@Z	; ModType::GetFieldName
	mov	DWORD PTR _szFieldName$224713[ebp], eax

; 1616 : 			lua_pushstring(L, szFieldName);

	mov	eax, DWORD PTR _szFieldName$224713[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushstring
	add	esp, 8

; 1617 : 
; 1618 : 			switch(kPlotDataType.GetFieldType(uiField))

	mov	edx, DWORD PTR _uiField$224709[ebp]
	push	edx
	mov	ecx, DWORD PTR _kPlotDataType$[ebp]
	call	?GetFieldType@ModType@@QBE?AW4FieldType@1@I@Z ; ModType::GetFieldType
	mov	DWORD PTR tv192[ebp], eax
	cmp	DWORD PTR tv192[ebp], 3
	ja	$LN28@LoadModDat
	mov	eax, DWORD PTR tv192[ebp]
	jmp	DWORD PTR $LN57@LoadModDat[eax*4]
$LN27@LoadModDat:

; 1619 : 			{
; 1620 : 			case ModType::TYPE_BOOL:
; 1621 : 			{
; 1622 : 				const bool bValue = kPlotDataType.GetFieldDefaultAsBool(uiField);

	mov	ecx, DWORD PTR _uiField$224709[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kPlotDataType$[ebp]
	call	?GetFieldDefaultAsBool@ModType@@QBE_NI@Z ; ModType::GetFieldDefaultAsBool
	mov	BYTE PTR _bValue$224719[ebp], al

; 1623 : 				lua_pushboolean(L, bValue);

	movzx	edx, BYTE PTR _bValue$224719[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushboolean
	add	esp, 8

; 1624 : 			}
; 1625 : 			break;

	jmp	$LN28@LoadModDat
$LN26@LoadModDat:

; 1626 : 
; 1627 : 			case ModType::TYPE_FLOAT:
; 1628 : 			{
; 1629 : 				const float fValue = kPlotDataType.GetFieldDefaultAsFloat(uiField);

	mov	ecx, DWORD PTR _uiField$224709[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kPlotDataType$[ebp]
	call	?GetFieldDefaultAsFloat@ModType@@QBEMI@Z ; ModType::GetFieldDefaultAsFloat
	fstp	DWORD PTR _fValue$224721[ebp]

; 1630 : 				lua_pushnumber(L, fValue);

	cvtss2sd xmm0, DWORD PTR _fValue$224721[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushnumber
	add	esp, 12					; 0000000cH

; 1631 : 			}
; 1632 : 			break;

	jmp	$LN28@LoadModDat
$LN25@LoadModDat:

; 1633 : 
; 1634 : 			case ModType::TYPE_STRING:
; 1635 : 			{
; 1636 : 				const char* szField = kPlotDataType.GetFieldDefaultAsString(uiField);

	mov	eax, DWORD PTR _uiField$224709[ebp]
	push	eax
	mov	ecx, DWORD PTR _kPlotDataType$[ebp]
	call	?GetFieldDefaultAsString@ModType@@QBEPBDI@Z ; ModType::GetFieldDefaultAsString
	mov	DWORD PTR _szField$224723[ebp], eax

; 1637 : 				lua_pushstring(L, szField);

	mov	ecx, DWORD PTR _szField$224723[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushstring
	add	esp, 8

; 1638 : 			}
; 1639 : 			break;

	jmp	SHORT $LN28@LoadModDat
$LN24@LoadModDat:

; 1640 : 
; 1641 : 			case ModType::TYPE_ENUM:
; 1642 : 			{
; 1643 : 				int iValue = kPlotDataType.GetFieldDefaultAsInt(uiField);

	mov	eax, DWORD PTR _uiField$224709[ebp]
	push	eax
	mov	ecx, DWORD PTR _kPlotDataType$[ebp]
	call	?GetFieldDefaultAsInt@ModType@@QBEHI@Z	; ModType::GetFieldDefaultAsInt
	mov	DWORD PTR _iValue$224725[ebp], eax

; 1644 : 				const ModEnum* pkEnum = sg_kSave.m_kModData.m_kPlotModData.GetFieldEnumType(uiField);

	mov	ecx, DWORD PTR _uiField$224709[ebp]
	push	ecx
	mov	ecx, OFFSET _sg_kSave+3436
	call	?GetFieldEnumType@ModType@@QBEPBVModEnum@@I@Z ; ModType::GetFieldEnumType
	mov	DWORD PTR _pkEnum$224726[ebp], eax

; 1645 : 				if(pkEnum != NULL)

	cmp	DWORD PTR _pkEnum$224726[ebp], 0
	je	SHORT $LN23@LoadModDat

; 1646 : 				{
; 1647 : 					const char* szMember = pkEnum->GetMember((uint)iValue);

	mov	edx, DWORD PTR _iValue$224725[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkEnum$224726[ebp]
	call	?GetMember@ModEnum@@QBEPBDI@Z		; ModEnum::GetMember
	mov	DWORD PTR _szMember$224728[ebp], eax

; 1648 : 					if(szMember == NULL) szMember = "";

	cmp	DWORD PTR _szMember$224728[ebp], 0
	jne	SHORT $LN22@LoadModDat
	mov	DWORD PTR _szMember$224728[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN22@LoadModDat:

; 1649 : 					lua_pushstring(L, szMember);

	mov	eax, DWORD PTR _szMember$224728[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushstring
	add	esp, 8

; 1650 : 				}
; 1651 : 				else

	jmp	SHORT $LN21@LoadModDat
$LN23@LoadModDat:

; 1652 : 				{
; 1653 : 					lua_pushstring(L, "");

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushstring
	add	esp, 8
$LN21@LoadModDat:
$LN28@LoadModDat:

; 1654 : 				}
; 1655 : 			}
; 1656 : 			}
; 1657 : 		}

	jmp	$LN31@LoadModDat
$LN30@LoadModDat:

; 1658 : 
; 1659 : 		const uint uiMapWidth = sg_kSave.GetWidth();

	mov	eax, DWORD PTR _sg_kSave+12228
	mov	DWORD PTR _uiMapWidth$224732[ebp], eax

; 1660 : 		const uint uiMapHeight = sg_kSave.GetHeight();

	mov	ecx, DWORD PTR _sg_kSave+12232
	mov	DWORD PTR _uiMapHeight$224733[ebp], ecx

; 1661 : 
; 1662 : 		lua_pushstring(L, "Plots");

	push	OFFSET ??_C@_05CKNOMBAL@Plots?$AA@
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushstring
	add	esp, 8

; 1663 : 		lua_createtable(L, uiMapWidth, 1);

	push	1
	mov	eax, DWORD PTR _uiMapWidth$224732[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_createtable
	add	esp, 12					; 0000000cH

; 1664 : 		for(uint x = 0; x < uiMapWidth; ++x)

	mov	DWORD PTR _x$224735[ebp], 0
	jmp	SHORT $LN20@LoadModDat
$LN19@LoadModDat:
	mov	edx, DWORD PTR _x$224735[ebp]
	add	edx, 1
	mov	DWORD PTR _x$224735[ebp], edx
$LN20@LoadModDat:
	mov	eax, DWORD PTR _x$224735[ebp]
	cmp	eax, DWORD PTR _uiMapWidth$224732[ebp]
	jae	$LN18@LoadModDat

; 1665 : 		{
; 1666 : 			lua_createtable(L, uiMapHeight, 1);

	push	1
	mov	ecx, DWORD PTR _uiMapHeight$224733[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_createtable
	add	esp, 12					; 0000000cH

; 1667 : 			for(uint y = 0; y < uiMapHeight; ++y)

	mov	DWORD PTR _y$224739[ebp], 0
	jmp	SHORT $LN17@LoadModDat
$LN16@LoadModDat:
	mov	eax, DWORD PTR _y$224739[ebp]
	add	eax, 1
	mov	DWORD PTR _y$224739[ebp], eax
$LN17@LoadModDat:
	mov	ecx, DWORD PTR _y$224739[ebp]
	cmp	ecx, DWORD PTR _uiMapHeight$224733[ebp]
	jae	$LN15@LoadModDat

; 1668 : 			{
; 1669 : 				lua_createtable(L, 0, uiFieldCount);

	mov	edx, DWORD PTR _uiFieldCount$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_createtable
	add	esp, 12					; 0000000cH

; 1670 : 				ModDataEntry kPlot = sg_kSave.m_kModData.GetPlotDataEntry(x + y * uiMapWidth);

	mov	ecx, DWORD PTR _y$224739[ebp]
	imul	ecx, DWORD PTR _uiMapWidth$224732[ebp]
	add	ecx, DWORD PTR _x$224735[ebp]
	push	ecx
	lea	edx, DWORD PTR _kPlot$224743[ebp]
	push	edx
	mov	ecx, OFFSET _sg_kSave+2888
	call	?GetPlotDataEntry@CvWorldBuilderMapModData@@QAE?AVModDataEntry@@I@Z ; CvWorldBuilderMapModData::GetPlotDataEntry

; 1671 : 				for(uint uiField = 0; uiField < uiFieldCount; ++uiField)

	mov	DWORD PTR _uiField$224745[ebp], 0
	jmp	SHORT $LN14@LoadModDat
$LN13@LoadModDat:
	mov	eax, DWORD PTR _uiField$224745[ebp]
	add	eax, 1
	mov	DWORD PTR _uiField$224745[ebp], eax
$LN14@LoadModDat:
	mov	ecx, DWORD PTR _uiField$224745[ebp]
	cmp	ecx, DWORD PTR _uiFieldCount$[ebp]
	jae	$LN12@LoadModDat

; 1672 : 				{
; 1673 : 					if(kPlot.IsFieldDefaultValue(uiField))

	mov	edx, DWORD PTR _uiField$224745[ebp]
	push	edx
	lea	ecx, DWORD PTR _kPlot$224743[ebp]
	call	?IsFieldDefaultValue@ModDataEntry@@QBE_NI@Z ; ModDataEntry::IsFieldDefaultValue
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN11@LoadModDat

; 1674 : 					{
; 1675 : 						lua_pushvalue(L, iFieldStart + 2 * uiField);

	mov	ecx, DWORD PTR _uiField$224745[ebp]
	mov	edx, DWORD PTR _iFieldStart$224708[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushvalue
	add	esp, 8

; 1676 : 						lua_pushvalue(L, iFieldStart + 2 * uiField + 1);

	mov	edx, DWORD PTR _uiField$224745[ebp]
	mov	eax, DWORD PTR _iFieldStart$224708[ebp]
	lea	ecx, DWORD PTR [eax+edx*2+1]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushvalue
	add	esp, 8

; 1677 : 						lua_rawset(L, -3);

	push	-3					; fffffffdH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_rawset
	add	esp, 8

; 1678 : 					}
; 1679 : 					else

	jmp	$LN8@LoadModDat
$LN11@LoadModDat:

; 1680 : 					{
; 1681 : 						switch(sg_kSave.m_kModData.m_kPlotModData.GetFieldType(uiField))

	mov	ecx, DWORD PTR _uiField$224745[ebp]
	push	ecx
	mov	ecx, OFFSET _sg_kSave+3436
	call	?GetFieldType@ModType@@QBE?AW4FieldType@1@I@Z ; ModType::GetFieldType
	mov	DWORD PTR tv303[ebp], eax
	cmp	DWORD PTR tv303[ebp], 3
	ja	$LN8@LoadModDat
	mov	edx, DWORD PTR tv303[ebp]
	jmp	DWORD PTR $LN58@LoadModDat[edx*4]
$LN7@LoadModDat:

; 1682 : 						{
; 1683 : 						case ModType::TYPE_BOOL:
; 1684 : 						{
; 1685 : 							const bool bValue = kPlot.GetFieldAsBool(uiField);

	mov	eax, DWORD PTR _uiField$224745[ebp]
	push	eax
	lea	ecx, DWORD PTR _kPlot$224743[ebp]
	call	?GetFieldAsBool@ModDataEntry@@QBE_NI@Z	; ModDataEntry::GetFieldAsBool
	mov	BYTE PTR _bValue$224756[ebp], al

; 1686 : 							lua_pushvalue(L, iFieldStart + 2 * uiField);

	mov	ecx, DWORD PTR _uiField$224745[ebp]
	mov	edx, DWORD PTR _iFieldStart$224708[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushvalue
	add	esp, 8

; 1687 : 							lua_pushboolean(L, bValue);

	movzx	edx, BYTE PTR _bValue$224756[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushboolean
	add	esp, 8

; 1688 : 							lua_rawset(L, -3);

	push	-3					; fffffffdH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_rawset
	add	esp, 8

; 1689 : 						}
; 1690 : 						break;

	jmp	$LN8@LoadModDat
$LN6@LoadModDat:

; 1691 : 
; 1692 : 						case ModType::TYPE_FLOAT:
; 1693 : 						{
; 1694 : 							const float fValue = kPlot.GetFieldAsFloat(uiField);

	mov	edx, DWORD PTR _uiField$224745[ebp]
	push	edx
	lea	ecx, DWORD PTR _kPlot$224743[ebp]
	call	?GetFieldAsFloat@ModDataEntry@@QBEMI@Z	; ModDataEntry::GetFieldAsFloat
	fstp	DWORD PTR _fValue$224758[ebp]

; 1695 : 							lua_pushvalue(L, iFieldStart + 2 * uiField);

	mov	eax, DWORD PTR _uiField$224745[ebp]
	mov	ecx, DWORD PTR _iFieldStart$224708[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushvalue
	add	esp, 8

; 1696 : 							lua_pushnumber(L, fValue);

	cvtss2sd xmm0, DWORD PTR _fValue$224758[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushnumber
	add	esp, 12					; 0000000cH

; 1697 : 							lua_rawset(L, -3);

	push	-3					; fffffffdH
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_rawset
	add	esp, 8

; 1698 : 						}
; 1699 : 						break;

	jmp	$LN8@LoadModDat
$LN5@LoadModDat:

; 1700 : 
; 1701 : 						case ModType::TYPE_STRING:
; 1702 : 						{
; 1703 : 							const char* szField = kPlot.GetFieldAsString(uiField);

	mov	eax, DWORD PTR _uiField$224745[ebp]
	push	eax
	lea	ecx, DWORD PTR _kPlot$224743[ebp]
	call	?GetFieldAsString@ModDataEntry@@QBEPBDI@Z ; ModDataEntry::GetFieldAsString
	mov	DWORD PTR _szField$224760[ebp], eax

; 1704 : 							lua_pushvalue(L, iFieldStart + 2 * uiField);

	mov	ecx, DWORD PTR _uiField$224745[ebp]
	mov	edx, DWORD PTR _iFieldStart$224708[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushvalue
	add	esp, 8

; 1705 : 							lua_pushstring(L, szField);

	mov	edx, DWORD PTR _szField$224760[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushstring
	add	esp, 8

; 1706 : 							lua_rawset(L, -3);

	push	-3					; fffffffdH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_rawset
	add	esp, 8

; 1707 : 						}
; 1708 : 						break;

	jmp	$LN8@LoadModDat
$LN4@LoadModDat:

; 1709 : 
; 1710 : 						case ModType::TYPE_ENUM:
; 1711 : 						{
; 1712 : 							int iValue = kPlot.GetFieldAsInt(uiField);

	mov	edx, DWORD PTR _uiField$224745[ebp]
	push	edx
	lea	ecx, DWORD PTR _kPlot$224743[ebp]
	call	?GetFieldAsInt@ModDataEntry@@QBEHI@Z	; ModDataEntry::GetFieldAsInt
	mov	DWORD PTR _iValue$224762[ebp], eax

; 1713 : 							const ModEnum* pkEnum = kPlotDataType.GetFieldEnumType(uiField);

	mov	eax, DWORD PTR _uiField$224745[ebp]
	push	eax
	mov	ecx, DWORD PTR _kPlotDataType$[ebp]
	call	?GetFieldEnumType@ModType@@QBEPBVModEnum@@I@Z ; ModType::GetFieldEnumType
	mov	DWORD PTR _pkEnum$224763[ebp], eax

; 1714 : 							if(pkEnum != NULL)

	cmp	DWORD PTR _pkEnum$224763[ebp], 0
	je	SHORT $LN2@LoadModDat

; 1715 : 							{
; 1716 : 								const char* szMember = pkEnum->GetMember((uint)iValue);

	mov	ecx, DWORD PTR _iValue$224762[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkEnum$224763[ebp]
	call	?GetMember@ModEnum@@QBEPBDI@Z		; ModEnum::GetMember
	mov	DWORD PTR _szMember$224765[ebp], eax

; 1717 : 								if(szMember != NULL)

	cmp	DWORD PTR _szMember$224765[ebp], 0
	je	SHORT $LN2@LoadModDat

; 1718 : 								{
; 1719 : 									lua_pushvalue(L, iFieldStart + 2 * uiField);

	mov	edx, DWORD PTR _uiField$224745[ebp]
	mov	eax, DWORD PTR _iFieldStart$224708[ebp]
	lea	ecx, DWORD PTR [eax+edx*2]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushvalue
	add	esp, 8

; 1720 : 									lua_pushstring(L, szMember);

	mov	eax, DWORD PTR _szMember$224765[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushstring
	add	esp, 8

; 1721 : 									lua_rawset(L, -3);

	push	-3					; fffffffdH
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_rawset
	add	esp, 8
$LN2@LoadModDat:
$LN8@LoadModDat:

; 1722 : 								}
; 1723 : 							}
; 1724 : 						}
; 1725 : 						}
; 1726 : 					}
; 1727 : 				}

	jmp	$LN13@LoadModDat
$LN12@LoadModDat:

; 1728 : 
; 1729 : 				lua_rawseti(L, -2, y);

	mov	eax, DWORD PTR _y$224739[ebp]
	push	eax
	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_rawseti
	add	esp, 12					; 0000000cH

; 1730 : 			}

	jmp	$LN16@LoadModDat
$LN15@LoadModDat:

; 1731 : 
; 1732 : 			lua_rawseti(L, -2, x);

	mov	edx, DWORD PTR _x$224735[ebp]
	push	edx
	push	-2					; fffffffeH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_rawseti
	add	esp, 12					; 0000000cH

; 1733 : 		}

	jmp	$LN19@LoadModDat
$LN18@LoadModDat:

; 1734 : 
; 1735 : 		lua_rawset(L, iModDataTable);

	mov	ecx, DWORD PTR _iModDataTable$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_rawset
	add	esp, 8

; 1736 : 	}
; 1737 : 	else

	jmp	SHORT $LN1@LoadModDat
$LN33@LoadModDat:

; 1738 : 	{
; 1739 : 		lua_pushstring(L, "Plots");

	push	OFFSET ??_C@_05CKNOMBAL@Plots?$AA@
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushstring
	add	esp, 8

; 1740 : 		lua_pushnil(L);

	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushnil
	add	esp, 4

; 1741 : 		lua_rawset(L, iModDataTable);

	mov	edx, DWORD PTR _iModDataTable$[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_rawset
	add	esp, 8
$LN1@LoadModDat:

; 1742 : 	}
; 1743 : 
; 1744 : 	lua_settop(L, iTop);

	mov	ecx, DWORD PTR _iTop$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_settop
	add	esp, 8

; 1745 : 
; 1746 : 	return 0;

	xor	eax, eax
$LN50@LoadModDat:

; 1747 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN56@LoadModDat:
	DD	$LN41@LoadModDat
	DD	$LN40@LoadModDat
	DD	$LN39@LoadModDat
	DD	$LN38@LoadModDat
$LN57@LoadModDat:
	DD	$LN27@LoadModDat
	DD	$LN26@LoadModDat
	DD	$LN25@LoadModDat
	DD	$LN24@LoadModDat
$LN58@LoadModDat:
	DD	$LN7@LoadModDat
	DD	$LN6@LoadModDat
	DD	$LN5@LoadModDat
	DD	$LN4@LoadModDat
?LoadModData@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z ENDP ; CvWorldBuilderMapLoader::LoadModData
_TEXT	ENDS
PUBLIC	??_C@_0P@OOCMDGKL@PostProcessMap?$AA@		; `string'
PUBLIC	??_C@_0BF@FCOBBAHN@PostProcessMapScript?$AA@	; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?RunPostProcessScript@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z ; CvWorldBuilderMapLoader::RunPostProcessScript
EXTRN	_memset:PROC
;	COMDAT ??_C@_0P@OOCMDGKL@PostProcessMap?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
CONST	SEGMENT
??_C@_0P@OOCMDGKL@PostProcessMap?$AA@ DB 'PostProcessMap', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FCOBBAHN@PostProcessMapScript?$AA@
CONST	SEGMENT
??_C@_0BF@FCOBBAHN@PostProcessMapScript?$AA@ DB 'PostProcessMapScript', 00H ; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvworldbuildermaploader.cpp
CONST	ENDS
;	COMDAT ?RunPostProcessScript@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z
_TEXT	SEGMENT
tv148 = -1136						; size = 4
tv137 = -1132						; size = 4
tv93 = -1128						; size = 4
tv224 = -1121						; size = 1
tv221 = -1120						; size = 4
tv218 = -1116						; size = 4
tv81 = -1112						; size = 4
tv208 = -1108						; size = 4
tv203 = -1102						; size = 1
tv196 = -1101						; size = 1
tv191 = -1100						; size = 4
tv193 = -1096						; size = 4
$T230339 = -1092					; size = 4
$T230335 = -1088					; size = 4
_bLoadedMapGenerator$224795 = -1082			; size = 1
_bResult$224793 = -1081					; size = 1
_szMapScriptPath$224792 = -1080				; size = 1040
__$ArrayPad$ = -40					; size = 4
_szLua$224787 = -36					; size = 4
_pkScriptSystem$224790 = -32				; size = 4
_szFieldName$224783 = -28				; size = 4
_uiField$224779 = -24					; size = 4
_kEntry$224777 = -20					; size = 8
_kGlobalsDataType$ = -12				; size = 4
_uiGlobalsCount$ = -8					; size = 4
_iTop$ = -4						; size = 4
_L$ = 8							; size = 4
?RunPostProcessScript@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z PROC ; CvWorldBuilderMapLoader::RunPostProcessScript, COMDAT

; 1752 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1136				; 00000470H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1753 : 	if(L == NULL)

	cmp	DWORD PTR _L$[ebp], 0
	jne	SHORT $LN14@RunPostPro

; 1754 : 	{
; 1755 : 		FAssertMsg(L, "Seriously, you really need a lua state for this.");
; 1756 : 		return 0;

	xor	eax, eax
	jmp	$LN15@RunPostPro
$LN14@RunPostPro:

; 1757 : 	}
; 1758 : 
; 1759 : 	const int iTop = lua_gettop(L);

	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_gettop
	add	esp, 4
	mov	DWORD PTR _iTop$[ebp], eax

; 1760 : 
; 1761 : 	ModType& kGlobalsDataType = sg_kSave.m_kModData.m_kMapModData;

	mov	DWORD PTR _kGlobalsDataType$[ebp], OFFSET _sg_kSave+2888

; 1762 : 	const uint uiGlobalsCount = kGlobalsDataType.GetFieldCount();

	mov	ecx, DWORD PTR _kGlobalsDataType$[ebp]
	call	?GetFieldCount@ModType@@QBEIXZ		; ModType::GetFieldCount
	mov	DWORD PTR _uiGlobalsCount$[ebp], eax

; 1763 : 	if(uiGlobalsCount > 0)

	cmp	DWORD PTR _uiGlobalsCount$[ebp], 0
	jbe	$LN13@RunPostPro

; 1764 : 	{
; 1765 : 		ModDataEntry kEntry = sg_kSave.m_kModData.GetMapDataEntry();

	lea	ecx, DWORD PTR _kEntry$224777[ebp]
	push	ecx
	mov	ecx, OFFSET _sg_kSave+2888
	call	?GetMapDataEntry@CvWorldBuilderMapModData@@QAE?AVModDataEntry@@XZ ; CvWorldBuilderMapModData::GetMapDataEntry

; 1766 : 		for(uint uiField = 0; uiField < uiGlobalsCount; ++uiField)

	mov	DWORD PTR _uiField$224779[ebp], 0
	jmp	SHORT $LN12@RunPostPro
$LN11@RunPostPro:
	mov	edx, DWORD PTR _uiField$224779[ebp]
	add	edx, 1
	mov	DWORD PTR _uiField$224779[ebp], edx
$LN12@RunPostPro:
	mov	eax, DWORD PTR _uiField$224779[ebp]
	cmp	eax, DWORD PTR _uiGlobalsCount$[ebp]
	jae	$LN13@RunPostPro

; 1767 : 		{
; 1768 : 			const char* szFieldName = kGlobalsDataType.GetFieldName(uiField);

	mov	ecx, DWORD PTR _uiField$224779[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kGlobalsDataType$[ebp]
	call	?GetFieldName@ModType@@QBEPBDI@Z	; ModType::GetFieldName
	mov	DWORD PTR _szFieldName$224783[ebp], eax

; 1769 : 			if(szFieldName != NULL && strcmp(szFieldName, "PostProcessMapScript") == 0)

	cmp	DWORD PTR _szFieldName$224783[ebp], 0
	je	$LN9@RunPostPro
	mov	DWORD PTR tv193[ebp], OFFSET ??_C@_0BF@FCOBBAHN@PostProcessMapScript?$AA@
	mov	edx, DWORD PTR _szFieldName$224783[ebp]
	mov	DWORD PTR tv191[ebp], edx
$LL21@RunPostPro:
	mov	eax, DWORD PTR tv191[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv196[ebp], cl
	mov	edx, DWORD PTR tv193[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN22@RunPostPro
	cmp	BYTE PTR tv196[ebp], 0
	je	SHORT $LN23@RunPostPro
	mov	eax, DWORD PTR tv191[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv203[ebp], cl
	mov	edx, DWORD PTR tv193[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN22@RunPostPro
	add	DWORD PTR tv191[ebp], 2
	add	DWORD PTR tv193[ebp], 2
	cmp	BYTE PTR tv203[ebp], 0
	jne	SHORT $LL21@RunPostPro
$LN23@RunPostPro:
	mov	DWORD PTR tv208[ebp], 0
	jmp	SHORT $LN24@RunPostPro
$LN22@RunPostPro:
	sbb	eax, eax
	sbb	eax, -1
	mov	DWORD PTR tv208[ebp], eax
$LN24@RunPostPro:
	mov	ecx, DWORD PTR tv208[ebp]
	mov	DWORD PTR tv81[ebp], ecx
	cmp	DWORD PTR tv81[ebp], 0
	jne	$LN9@RunPostPro

; 1770 : 			{
; 1771 : 				if(kGlobalsDataType.GetFieldType(uiField) == ModType::TYPE_STRING)

	mov	edx, DWORD PTR _uiField$224779[ebp]
	push	edx
	mov	ecx, DWORD PTR _kGlobalsDataType$[ebp]
	call	?GetFieldType@ModType@@QBE?AW4FieldType@1@I@Z ; ModType::GetFieldType
	cmp	eax, 2
	jne	$LN9@RunPostPro

; 1772 : 				{
; 1773 : 					const char* szLua = kEntry.GetFieldAsString(uiField);

	mov	eax, DWORD PTR _uiField$224779[ebp]
	push	eax
	lea	ecx, DWORD PTR _kEntry$224777[ebp]
	call	?GetFieldAsString@ModDataEntry@@QBEPBDI@Z ; ModDataEntry::GetFieldAsString
	mov	DWORD PTR _szLua$224787[ebp], eax

; 1774 : #ifdef AUI_WARNING_FIXES
; 1775 : 					if (szLua == NULL || szLua[0] == '\0')
; 1776 : #else
; 1777 : 					if(szLua == NULL || strlen(szLua) == 0)

	cmp	DWORD PTR _szLua$224787[ebp], 0
	je	SHORT $LN6@RunPostPro
	mov	ecx, DWORD PTR _szLua$224787[ebp]
	mov	DWORD PTR tv218[ebp], ecx
	mov	edx, DWORD PTR tv218[ebp]
	add	edx, 1
	mov	DWORD PTR tv221[ebp], edx
$LL25@RunPostPro:
	mov	eax, DWORD PTR tv218[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv224[ebp], cl
	add	DWORD PTR tv218[ebp], 1
	cmp	BYTE PTR tv224[ebp], 0
	jne	SHORT $LL25@RunPostPro
	mov	edx, DWORD PTR tv218[ebp]
	sub	edx, DWORD PTR tv221[ebp]
	mov	DWORD PTR tv93[ebp], edx
	jne	SHORT $LN7@RunPostPro
$LN6@RunPostPro:

; 1778 : #endif
; 1779 : 					{
; 1780 : 						szLua = kGlobalsDataType.GetFieldDefaultAsString(uiField);

	mov	eax, DWORD PTR _uiField$224779[ebp]
	push	eax
	mov	ecx, DWORD PTR _kGlobalsDataType$[ebp]
	call	?GetFieldDefaultAsString@ModType@@QBEPBDI@Z ; ModType::GetFieldDefaultAsString
	mov	DWORD PTR _szLua$224787[ebp], eax
$LN7@RunPostPro:

; 1781 : 					}
; 1782 : 					
; 1783 : 					ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR $T230335[ebp]
	mov	DWORD PTR tv137[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv137[ebp], edx
	mov	eax, DWORD PTR tv137[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv137[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pkScriptSystem$224790[ebp], eax

; 1784 : 					if(pkScriptSystem != NULL)

	cmp	DWORD PTR _pkScriptSystem$224790[ebp], 0
	je	$LN9@RunPostPro

; 1785 : 					{
; 1786 : 						//1040 == _MAX_PATH * 4
; 1787 : 						char szMapScriptPath[1040] = {0};

	mov	BYTE PTR _szMapScriptPath$224792[ebp], 0
	push	1039					; 0000040fH
	push	0
	lea	ecx, DWORD PTR _szMapScriptPath$224792[ebp+1]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 1788 : 						const bool bResult = gDLL->GetEvaluatedMapScriptPath(szLua, szMapScriptPath, 1040);

	mov	edx, DWORD PTR $T230339[ebp]
	mov	DWORD PTR tv148[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv148[ebp], eax
	push	1040					; 00000410H
	lea	ecx, DWORD PTR _szMapScriptPath$224792[ebp]
	push	ecx
	mov	edx, DWORD PTR _szLua$224787[ebp]
	push	edx
	mov	eax, DWORD PTR tv148[ebp]
	push	eax
	mov	ecx, DWORD PTR tv148[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+1036]
	call	eax
	mov	BYTE PTR _bResult$224793[ebp], al

; 1789 : 						if(!bResult)
; 1790 : 						{
; 1791 : 							FAssertMsg(0, "Failed to find \"PostProcessMap\" in Post Process Map Script.");
; 1792 : 						}
; 1793 : 
; 1794 : 						const bool bLoadedMapGenerator = pkScriptSystem->LoadFile(L, szMapScriptPath);

	lea	edx, DWORD PTR _szMapScriptPath$224792[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkScriptSystem$224790[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pkScriptSystem$224790[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	BYTE PTR _bLoadedMapGenerator$224795[ebp], al

; 1795 : 						FAssertMsg(bLoadedMapGenerator, "Failed to load Post Process Map Script.");
; 1796 : 						if(bLoadedMapGenerator)

	movzx	ecx, BYTE PTR _bLoadedMapGenerator$224795[ebp]
	test	ecx, ecx
	je	SHORT $LN9@RunPostPro

; 1797 : 						{
; 1798 : 							lua_getglobal(L, "PostProcessMap");

	push	OFFSET ??_C@_0P@OOCMDGKL@PostProcessMap?$AA@
	push	-10002					; ffffd8eeH
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_getfield
	add	esp, 12					; 0000000cH

; 1799 : 							if(lua_isfunction(L, -1))

	push	-1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_type
	add	esp, 8
	cmp	eax, 6
	jne	SHORT $LN9@RunPostPro

; 1800 : 								pkScriptSystem->CallFunction(L, 0, 0);

	push	0
	push	0
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pkScriptSystem$224790[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pkScriptSystem$224790[ebp]
	mov	edx, DWORD PTR [eax+28]
	call	edx
$LN9@RunPostPro:

; 1801 : 							else
; 1802 : 								FAssertMsg(0, "Failed to find \"PostProcessMap\" in Post Process Map Script.");
; 1803 : 						}
; 1804 : 					}
; 1805 : 				}
; 1806 : 			}
; 1807 : 		}

	jmp	$LN11@RunPostPro
$LN13@RunPostPro:

; 1808 : 	}
; 1809 : 
; 1810 : 	lua_settop(L, iTop);

	mov	eax, DWORD PTR _iTop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_settop
	add	esp, 8

; 1811 : 
; 1812 : 	return 0;

	xor	eax, eax
$LN15@RunPostPro:

; 1813 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?RunPostProcessScript@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z ENDP ; CvWorldBuilderMapLoader::RunPostProcessScript
_TEXT	ENDS
PUBLIC	?ValidateTerrain@CvWorldBuilderMapLoader@@SAXXZ	; CvWorldBuilderMapLoader::ValidateTerrain
; Function compile flags: /Odtp
;	COMDAT ?ValidateTerrain@CvWorldBuilderMapLoader@@SAXXZ
_TEXT	SEGMENT
tv139 = -60						; size = 4
$T230365 = -56						; size = 4
$T230358 = -52						; size = 4
$T230354 = -48						; size = 4
_pkTerrain$224824 = -44					; size = 4
_eTerrainType$224820 = -40				; size = 4
_pkPlot$224818 = -36					; size = 4
_i$224814 = -32						; size = 4
_eTerrain$224809 = -28					; size = 4
_pkTerrain$224811 = -24					; size = 4
_i$224805 = -20						; size = 4
_kMap$ = -16						; size = 4
_eValidTerrain$ = -12					; size = 4
_iPlotCount$ = -8					; size = 4
_iNumTerrainTypes$ = -4					; size = 4
?ValidateTerrain@CvWorldBuilderMapLoader@@SAXXZ PROC	; CvWorldBuilderMapLoader::ValidateTerrain, COMDAT

; 1817 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 1818 : 	CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 1819 : 
; 1820 : 	TerrainTypes eValidTerrain = NO_TERRAIN;

	mov	DWORD PTR _eValidTerrain$[ebp], -1

; 1821 : 	const int iNumTerrainTypes = GC.getNumTerrainInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTerrainInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTerrainInfos
	mov	DWORD PTR _iNumTerrainTypes$[ebp], eax

; 1822 : 	for(int i = 0; i < iNumTerrainTypes; ++i)

	mov	DWORD PTR _i$224805[ebp], 0
	jmp	SHORT $LN12@ValidateTe
$LN11@ValidateTe:
	mov	ecx, DWORD PTR _i$224805[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$224805[ebp], ecx
$LN12@ValidateTe:
	mov	edx, DWORD PTR _i$224805[ebp]
	cmp	edx, DWORD PTR _iNumTerrainTypes$[ebp]
	jge	SHORT $LN10@ValidateTe

; 1823 : 	{
; 1824 : 		const TerrainTypes eTerrain = (TerrainTypes)i;

	mov	eax, DWORD PTR _i$224805[ebp]
	mov	DWORD PTR _eTerrain$224809[ebp], eax

; 1825 : 		const CvTerrainInfo* pkTerrain = GC.getTerrainInfo(eTerrain);

	mov	ecx, DWORD PTR _eTerrain$224809[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo
	mov	DWORD PTR _pkTerrain$224811[ebp], eax

; 1826 : 		if(pkTerrain != NULL)

	cmp	DWORD PTR _pkTerrain$224811[ebp], 0
	je	SHORT $LN9@ValidateTe

; 1827 : 		{
; 1828 : 			eValidTerrain = eTerrain;

	mov	edx, DWORD PTR _eTerrain$224809[ebp]
	mov	DWORD PTR _eValidTerrain$[ebp], edx

; 1829 : 			break;

	jmp	SHORT $LN10@ValidateTe
$LN9@ValidateTe:

; 1830 : 		}
; 1831 : 	}

	jmp	SHORT $LN11@ValidateTe
$LN10@ValidateTe:

; 1832 : 
; 1833 : 	FAssertMsg(eValidTerrain != NO_TERRAIN, "Could not find ANY valid terrain types!");
; 1834 : 
; 1835 : 	const int iPlotCount = kMap.getGridWidth() * kMap.getGridHeight();

	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T230354[ebp], ecx
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T230358[ebp], eax
	mov	ecx, DWORD PTR $T230354[ebp]
	imul	ecx, DWORD PTR $T230358[ebp]
	mov	DWORD PTR _iPlotCount$[ebp], ecx

; 1836 : 	for(int i = 0; i < iPlotCount; ++i)

	mov	DWORD PTR _i$224814[ebp], 0
	jmp	SHORT $LN8@ValidateTe
$LN7@ValidateTe:
	mov	edx, DWORD PTR _i$224814[ebp]
	add	edx, 1
	mov	DWORD PTR _i$224814[ebp], edx
$LN8@ValidateTe:
	mov	eax, DWORD PTR _i$224814[ebp]
	cmp	eax, DWORD PTR _iPlotCount$[ebp]
	jge	$LN13@ValidateTe

; 1837 : 	{
; 1838 : 		CvPlot* pkPlot = kMap.plotByIndex(i);

	cmp	DWORD PTR _i$224814[ebp], 0
	jl	SHORT $LN23@ValidateTe
	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	edx, DWORD PTR [ecx+4028]
	mov	DWORD PTR $T230365[ebp], edx
	mov	eax, DWORD PTR _i$224814[ebp]
	cmp	eax, DWORD PTR $T230365[ebp]
	jge	SHORT $LN23@ValidateTe
	mov	ecx, DWORD PTR _i$224814[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _kMap$[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv139[ebp], ecx
	jmp	SHORT $LN21@ValidateTe
$LN23@ValidateTe:
	mov	DWORD PTR tv139[ebp], 0
$LN21@ValidateTe:
	mov	eax, DWORD PTR tv139[ebp]
	mov	DWORD PTR _pkPlot$224818[ebp], eax

; 1839 : 		if(pkPlot != NULL)

	cmp	DWORD PTR _pkPlot$224818[ebp], 0
	je	SHORT $LN5@ValidateTe

; 1840 : 		{
; 1841 : 			const TerrainTypes eTerrainType = pkPlot->getTerrainType();

	mov	ecx, DWORD PTR _pkPlot$224818[ebp]
	movsx	edx, BYTE PTR [ecx+6]
	mov	DWORD PTR _eTerrainType$224820[ebp], edx

; 1842 : 			if(eTerrainType < 0 || eTerrainType >= iNumTerrainTypes)

	cmp	DWORD PTR _eTerrainType$224820[ebp], 0
	jl	SHORT $LN3@ValidateTe
	mov	eax, DWORD PTR _eTerrainType$224820[ebp]
	cmp	eax, DWORD PTR _iNumTerrainTypes$[ebp]
	jl	SHORT $LN4@ValidateTe
$LN3@ValidateTe:

; 1843 : 			{
; 1844 : 				pkPlot->setTerrainType(eValidTerrain);

	push	1
	push	1
	mov	ecx, DWORD PTR _eValidTerrain$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkPlot$224818[ebp]
	call	?setTerrainType@CvPlot@@QAEXW4TerrainTypes@@_N1@Z ; CvPlot::setTerrainType

; 1845 : 			}
; 1846 : 			else

	jmp	SHORT $LN5@ValidateTe
$LN4@ValidateTe:

; 1847 : 			{
; 1848 : 				const CvTerrainInfo* pkTerrain = GC.getTerrainInfo(eTerrainType);

	mov	edx, DWORD PTR _eTerrainType$224820[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo
	mov	DWORD PTR _pkTerrain$224824[ebp], eax

; 1849 : 				if(pkTerrain == NULL)

	cmp	DWORD PTR _pkTerrain$224824[ebp], 0
	jne	SHORT $LN5@ValidateTe

; 1850 : 					pkPlot->setTerrainType(eValidTerrain);

	push	1
	push	1
	mov	eax, DWORD PTR _eValidTerrain$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkPlot$224818[ebp]
	call	?setTerrainType@CvPlot@@QAEXW4TerrainTypes@@_N1@Z ; CvPlot::setTerrainType
$LN5@ValidateTe:

; 1851 : 			}
; 1852 : 		}

	jmp	$LN7@ValidateTe
$LN13@ValidateTe:

; 1853 : 	}
; 1854 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ValidateTerrain@CvWorldBuilderMapLoader@@SAXXZ ENDP	; CvWorldBuilderMapLoader::ValidateTerrain
_TEXT	ENDS
PUBLIC	?ValidateCoast@CvWorldBuilderMapLoader@@SAXXZ	; CvWorldBuilderMapLoader::ValidateCoast
EXTRN	?isAdjacentToLand@CvPlot@@QBE_NXZ:PROC		; CvPlot::isAdjacentToLand
EXTRN	?isWater@CvTerrainInfo@@QBE_NXZ:PROC		; CvTerrainInfo::isWater
; Function compile flags: /Odtp
;	COMDAT ?ValidateCoast@CvWorldBuilderMapLoader@@SAXXZ
_TEXT	SEGMENT
tv162 = -84						; size = 4
tv177 = -80						; size = 4
$T230445 = -76						; size = 4
$T230432 = -72						; size = 4
$T230428 = -68						; size = 4
$T230414 = -64						; size = 4
$T230410 = -57						; size = 1
$T230399 = -56						; size = 4
$T230395 = -49						; size = 1
_iMapY$230482 = -48					; size = 4
_iMapX$230481 = -44					; size = 4
_pkTerrain$224846 = -40					; size = 4
_eTerrainType$224844 = -36				; size = 4
_pkPlot$224842 = -32					; size = 4
_x$224838 = -28						; size = 4
_y$224834 = -24						; size = 4
_kMap$ = -20						; size = 4
_iMapWidth$ = -16					; size = 4
_iMapHeight$ = -12					; size = 4
_eCoast$ = -8						; size = 4
_iNumTerrainTypes$ = -4					; size = 4
?ValidateCoast@CvWorldBuilderMapLoader@@SAXXZ PROC	; CvWorldBuilderMapLoader::ValidateCoast, COMDAT

; 1857 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H

; 1858 : 	//FTimer kTimer;
; 1859 : 	//kTimer.Start();
; 1860 : 
; 1861 : 	CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 1862 : 	const int iMapWidth = kMap.getGridWidth();

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR _iMapWidth$[ebp], edx

; 1863 : 	const int iMapHeight = kMap.getGridHeight();

	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR _iMapHeight$[ebp], ecx

; 1864 : 	const int iNumTerrainTypes = GC.getNumTerrainInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTerrainInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTerrainInfos
	mov	DWORD PTR _iNumTerrainTypes$[ebp], eax

; 1865 : 	const TerrainTypes eCoast = (TerrainTypes)GC.getSHALLOW_WATER_TERRAIN();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8396
	mov	DWORD PTR _eCoast$[ebp], edx

; 1866 : 
; 1867 : 	for(int y = 0; y < iMapHeight; ++y)

	mov	DWORD PTR _y$224834[ebp], 0
	jmp	SHORT $LN9@ValidateCo
$LN8@ValidateCo:
	mov	eax, DWORD PTR _y$224834[ebp]
	add	eax, 1
	mov	DWORD PTR _y$224834[ebp], eax
$LN9@ValidateCo:
	mov	ecx, DWORD PTR _y$224834[ebp]
	cmp	ecx, DWORD PTR _iMapHeight$[ebp]
	jge	$LN10@ValidateCo

; 1868 : 		for(int x = 0; x < iMapWidth; ++x)

	mov	DWORD PTR _x$224838[ebp], 0
	jmp	SHORT $LN6@ValidateCo
$LN5@ValidateCo:
	mov	edx, DWORD PTR _x$224838[ebp]
	add	edx, 1
	mov	DWORD PTR _x$224838[ebp], edx
$LN6@ValidateCo:
	mov	eax, DWORD PTR _x$224838[ebp]
	cmp	eax, DWORD PTR _iMapWidth$[ebp]
	jge	$LN4@ValidateCo

; 1869 : 		{
; 1870 : 			CvPlot* pkPlot = kMap.plot(x, y);

	cmp	DWORD PTR _x$224838[ebp], -2147483647	; 80000001H
	je	SHORT $LN20@ValidateCo
	cmp	DWORD PTR _y$224834[ebp], -2147483647	; 80000001H
	jne	SHORT $LN21@ValidateCo
$LN20@ValidateCo:
	mov	DWORD PTR _pkPlot$224842[ebp], 0
	jmp	$LN22@ValidateCo
$LN21@ValidateCo:
	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T230395[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T230399[ebp], ecx
	movzx	edx, BYTE PTR $T230395[ebp]
	test	edx, edx
	je	SHORT $LN33@ValidateCo
	cmp	DWORD PTR _x$224838[ebp], 0
	jge	SHORT $LN32@ValidateCo
	mov	eax, DWORD PTR _x$224838[ebp]
	cdq
	idiv	DWORD PTR $T230399[ebp]
	add	edx, DWORD PTR $T230399[ebp]
	mov	DWORD PTR _iMapX$230481[ebp], edx
	jmp	SHORT $LN34@ValidateCo
	jmp	SHORT $LN33@ValidateCo
$LN32@ValidateCo:
	mov	eax, DWORD PTR _x$224838[ebp]
	cmp	eax, DWORD PTR $T230399[ebp]
	jl	SHORT $LN33@ValidateCo
	mov	eax, DWORD PTR _x$224838[ebp]
	cdq
	idiv	DWORD PTR $T230399[ebp]
	mov	DWORD PTR _iMapX$230481[ebp], edx
	jmp	SHORT $LN34@ValidateCo
$LN33@ValidateCo:
	mov	ecx, DWORD PTR _x$224838[ebp]
	mov	DWORD PTR _iMapX$230481[ebp], ecx
$LN34@ValidateCo:
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T230410[ebp], al
	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T230414[ebp], edx
	movzx	eax, BYTE PTR $T230410[ebp]
	test	eax, eax
	je	SHORT $LN43@ValidateCo
	cmp	DWORD PTR _y$224834[ebp], 0
	jge	SHORT $LN42@ValidateCo
	mov	eax, DWORD PTR _y$224834[ebp]
	cdq
	idiv	DWORD PTR $T230414[ebp]
	add	edx, DWORD PTR $T230414[ebp]
	mov	DWORD PTR _iMapY$230482[ebp], edx
	jmp	SHORT $LN44@ValidateCo
	jmp	SHORT $LN43@ValidateCo
$LN42@ValidateCo:
	mov	ecx, DWORD PTR _y$224834[ebp]
	cmp	ecx, DWORD PTR $T230414[ebp]
	jl	SHORT $LN43@ValidateCo
	mov	eax, DWORD PTR _y$224834[ebp]
	cdq
	idiv	DWORD PTR $T230414[ebp]
	mov	DWORD PTR _iMapY$230482[ebp], edx
	jmp	SHORT $LN44@ValidateCo
$LN43@ValidateCo:
	mov	edx, DWORD PTR _y$224834[ebp]
	mov	DWORD PTR _iMapY$230482[ebp], edx
$LN44@ValidateCo:
	cmp	DWORD PTR _iMapX$230481[ebp], 0
	jl	SHORT $LN48@ValidateCo
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T230428[ebp], ecx
	mov	edx, DWORD PTR _iMapX$230481[ebp]
	cmp	edx, DWORD PTR $T230428[ebp]
	jge	SHORT $LN48@ValidateCo
	cmp	DWORD PTR _iMapY$230482[ebp], 0
	jl	SHORT $LN48@ValidateCo
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T230432[ebp], ecx
	mov	edx, DWORD PTR _iMapY$230482[ebp]
	cmp	edx, DWORD PTR $T230432[ebp]
	jge	SHORT $LN48@ValidateCo
	mov	DWORD PTR tv177[ebp], 1
	jmp	SHORT $LN46@ValidateCo
$LN48@ValidateCo:
	mov	DWORD PTR tv177[ebp], 0
$LN46@ValidateCo:
	cmp	DWORD PTR tv177[ebp], 0
	je	SHORT $LN24@ValidateCo
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T230445[ebp], ecx
	mov	edx, DWORD PTR _iMapY$230482[ebp]
	imul	edx, DWORD PTR $T230445[ebp]
	add	edx, DWORD PTR _iMapX$230481[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR _kMap$[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv162[ebp], edx
	jmp	SHORT $LN25@ValidateCo
$LN24@ValidateCo:
	mov	DWORD PTR tv162[ebp], 0
$LN25@ValidateCo:
	mov	ecx, DWORD PTR tv162[ebp]
	mov	DWORD PTR _pkPlot$224842[ebp], ecx
$LN22@ValidateCo:

; 1871 : 			if(pkPlot != NULL)

	cmp	DWORD PTR _pkPlot$224842[ebp], 0
	je	SHORT $LN3@ValidateCo

; 1872 : 			{
; 1873 : 				const TerrainTypes eTerrainType = pkPlot->getTerrainType();

	mov	edx, DWORD PTR _pkPlot$224842[ebp]
	movsx	eax, BYTE PTR [edx+6]
	mov	DWORD PTR _eTerrainType$224844[ebp], eax

; 1874 : 				if(eTerrainType >= 0 && eTerrainType < iNumTerrainTypes && eTerrainType != eCoast)

	cmp	DWORD PTR _eTerrainType$224844[ebp], 0
	jl	SHORT $LN3@ValidateCo
	mov	ecx, DWORD PTR _eTerrainType$224844[ebp]
	cmp	ecx, DWORD PTR _iNumTerrainTypes$[ebp]
	jge	SHORT $LN3@ValidateCo
	mov	edx, DWORD PTR _eTerrainType$224844[ebp]
	cmp	edx, DWORD PTR _eCoast$[ebp]
	je	SHORT $LN3@ValidateCo

; 1875 : 				{
; 1876 : 					const CvTerrainInfo* pkTerrain = GC.getTerrainInfo(eTerrainType);

	mov	eax, DWORD PTR _eTerrainType$224844[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo
	mov	DWORD PTR _pkTerrain$224846[ebp], eax

; 1877 : 					if(pkTerrain != NULL && pkTerrain->isWater() && pkPlot->isAdjacentToLand())

	cmp	DWORD PTR _pkTerrain$224846[ebp], 0
	je	SHORT $LN3@ValidateCo
	mov	ecx, DWORD PTR _pkTerrain$224846[ebp]
	call	?isWater@CvTerrainInfo@@QBE_NXZ		; CvTerrainInfo::isWater
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@ValidateCo
	mov	ecx, DWORD PTR _pkPlot$224842[ebp]
	call	?isAdjacentToLand@CvPlot@@QBE_NXZ	; CvPlot::isAdjacentToLand
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@ValidateCo

; 1878 : 					{
; 1879 : 						pkPlot->setTerrainType(eCoast);

	push	1
	push	1
	mov	eax, DWORD PTR _eCoast$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkPlot$224842[ebp]
	call	?setTerrainType@CvPlot@@QAEXW4TerrainTypes@@_N1@Z ; CvPlot::setTerrainType
$LN3@ValidateCo:

; 1880 : 					}
; 1881 : 				}
; 1882 : 			}

	jmp	$LN5@ValidateCo
$LN4@ValidateCo:

; 1883 : 		}

	jmp	$LN8@ValidateCo
$LN10@ValidateCo:

; 1884 : 
; 1885 : 	//kTimer.Stop();
; 1886 : 	//FStringFixedBuffer(sMsg, 64);
; 1887 : 	//sMsg.Format("CvWorldBuilderMapLoader::ValidateCoast() took %fs\n", kTimer.m_fTimer);
; 1888 : 	//OutputDebugStr(sMsg);
; 1889 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ValidateCoast@CvWorldBuilderMapLoader@@SAXXZ ENDP	; CvWorldBuilderMapLoader::ValidateCoast
_TEXT	ENDS
PUBLIC	?ClearResources@CvWorldBuilderMapLoader@@SAXXZ	; CvWorldBuilderMapLoader::ClearResources
; Function compile flags: /Odtp
;	COMDAT ?ClearResources@CvWorldBuilderMapLoader@@SAXXZ
_TEXT	SEGMENT
_kPlot$224855 = -12					; size = 4
_i$224851 = -8						; size = 4
_uiPlotCount$ = -4					; size = 4
?ClearResources@CvWorldBuilderMapLoader@@SAXXZ PROC	; CvWorldBuilderMapLoader::ClearResources, COMDAT

; 1892 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1893 : 	const uint uiPlotCount = sg_kSave.GetPlotCount();

	mov	eax, DWORD PTR _sg_kSave+12228
	imul	eax, DWORD PTR _sg_kSave+12232
	mov	DWORD PTR _uiPlotCount$[ebp], eax

; 1894 : 	for(uint i = 0; i < uiPlotCount; ++i)

	mov	DWORD PTR _i$224851[ebp], 0
	jmp	SHORT $LN3@ClearResou
$LN2@ClearResou:
	mov	ecx, DWORD PTR _i$224851[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$224851[ebp], ecx
$LN3@ClearResou:
	mov	edx, DWORD PTR _i$224851[ebp]
	cmp	edx, DWORD PTR _uiPlotCount$[ebp]
	jae	SHORT $LN4@ClearResou

; 1895 : 	{
; 1896 : 		CvWorldBuilderMap::PlotMapData& kPlot = sg_kSave.GetPlotData(i);

	mov	eax, DWORD PTR _sg_kSave+12228
	imul	eax, DWORD PTR _sg_kSave+12232
	cmp	DWORD PTR _i$224851[ebp], eax
	jae	SHORT $LN9@ClearResou
	cmp	DWORD PTR _i$224851[ebp], 32768		; 00008000H
	jae	SHORT $LN9@ClearResou
	mov	ecx, DWORD PTR _i$224851[ebp]
	lea	edx, DWORD PTR _sg_kSave[ecx*8+12320]
	mov	DWORD PTR _kPlot$224855[ebp], edx
	jmp	SHORT $LN10@ClearResou
	jmp	SHORT $LN10@ClearResou
$LN9@ClearResou:
	mov	DWORD PTR _kPlot$224855[ebp], OFFSET ?sm_kErrorPlotMapData@CvWorldBuilderMap@@0VPlotMapData@1@A ; CvWorldBuilderMap::sm_kErrorPlotMapData
$LN10@ClearResou:

; 1897 : 		kPlot.SetResourceType(CvWorldBuilderMap::PlotMapData::InvalidResource);

	mov	eax, DWORD PTR _kPlot$224855[ebp]
	mov	BYTE PTR [eax+1], 255			; 000000ffH

; 1898 : 	}

	jmp	SHORT $LN2@ClearResou
$LN4@ClearResou:

; 1899 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ClearResources@CvWorldBuilderMapLoader@@SAXXZ ENDP	; CvWorldBuilderMapLoader::ClearResources
_TEXT	ENDS
PUBLIC	?ClearGoodies@CvWorldBuilderMapLoader@@SAXXZ	; CvWorldBuilderMapLoader::ClearGoodies
; Function compile flags: /Odtp
;	COMDAT ?ClearGoodies@CvWorldBuilderMapLoader@@SAXXZ
_TEXT	SEGMENT
_pkImprovement$224867 = -20				; size = 4
_eType$224865 = -16					; size = 4
_kPlot$224863 = -12					; size = 4
_i$224859 = -8						; size = 4
_uiPlotCount$ = -4					; size = 4
?ClearGoodies@CvWorldBuilderMapLoader@@SAXXZ PROC	; CvWorldBuilderMapLoader::ClearGoodies, COMDAT

; 1902 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 1903 : 	const uint uiPlotCount = sg_kSave.GetPlotCount();

	mov	eax, DWORD PTR _sg_kSave+12228
	imul	eax, DWORD PTR _sg_kSave+12232
	mov	DWORD PTR _uiPlotCount$[ebp], eax

; 1904 : 	for(uint i = 0; i < uiPlotCount; ++i)

	mov	DWORD PTR _i$224859[ebp], 0
	jmp	SHORT $LN6@ClearGoodi
$LN5@ClearGoodi:
	mov	ecx, DWORD PTR _i$224859[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$224859[ebp], ecx
$LN6@ClearGoodi:
	mov	edx, DWORD PTR _i$224859[ebp]
	cmp	edx, DWORD PTR _uiPlotCount$[ebp]
	jae	SHORT $LN7@ClearGoodi

; 1905 : 	{
; 1906 : 		CvWorldBuilderMap::PlotScenarioData& kPlot = sg_kSave.GetPlotScenarioData(i);

	mov	eax, DWORD PTR _sg_kSave+12228
	imul	eax, DWORD PTR _sg_kSave+12232
	cmp	DWORD PTR _i$224859[ebp], eax
	jae	SHORT $LN12@ClearGoodi
	cmp	DWORD PTR _i$224859[ebp], 32768		; 00008000H
	jae	SHORT $LN12@ClearGoodi
	mov	ecx, DWORD PTR _i$224859[ebp]
	lea	edx, DWORD PTR _sg_kSave[ecx*8+274464]
	mov	DWORD PTR _kPlot$224863[ebp], edx
	jmp	SHORT $LN13@ClearGoodi
	jmp	SHORT $LN13@ClearGoodi
$LN12@ClearGoodi:
	mov	DWORD PTR _kPlot$224863[ebp], OFFSET ?sm_kErrorPlotScenarioData@CvWorldBuilderMap@@0UPlotScenarioData@1@A ; CvWorldBuilderMap::sm_kErrorPlotScenarioData
$LN13@ClearGoodi:

; 1907 : 		if(kPlot.m_byImprovement != CvWorldBuilderMap::PlotScenarioData::InvalidImprovement)

	mov	eax, DWORD PTR _kPlot$224863[ebp]
	movzx	ecx, BYTE PTR [eax+5]
	cmp	ecx, 255				; 000000ffH
	je	SHORT $LN3@ClearGoodi

; 1908 : 		{
; 1909 : 			ImprovementTypes eType = (ImprovementTypes)kPlot.m_byImprovement;

	mov	edx, DWORD PTR _kPlot$224863[ebp]
	movzx	eax, BYTE PTR [edx+5]
	mov	DWORD PTR _eType$224865[ebp], eax

; 1910 : 			const CvImprovementEntry* pkImprovement = GC.getImprovementInfo(eType);

	mov	ecx, DWORD PTR _eType$224865[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	DWORD PTR _pkImprovement$224867[ebp], eax

; 1911 : 			if(pkImprovement == NULL || pkImprovement->IsGoody())

	cmp	DWORD PTR _pkImprovement$224867[ebp], 0
	je	SHORT $LN1@ClearGoodi
	mov	ecx, DWORD PTR _pkImprovement$224867[ebp]
	call	?IsGoody@CvImprovementEntry@@QBE_NXZ	; CvImprovementEntry::IsGoody
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@ClearGoodi
$LN1@ClearGoodi:

; 1912 : 				kPlot.m_byImprovement = CvWorldBuilderMap::PlotScenarioData::InvalidImprovement;

	mov	eax, DWORD PTR _kPlot$224863[ebp]
	mov	BYTE PTR [eax+5], 255			; 000000ffH
$LN3@ClearGoodi:

; 1913 : 		}

	jmp	$LN5@ClearGoodi
$LN7@ClearGoodi:

; 1914 : 	}
; 1915 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ClearGoodies@CvWorldBuilderMapLoader@@SAXXZ ENDP	; CvWorldBuilderMapLoader::ClearGoodies
_TEXT	ENDS
PUBLIC	?GetWorldSizeType@CvWorldBuilderMapLoader@@SA?AW4WorldSizeTypes@@ABVCvWorldBuilderMap@@@Z ; CvWorldBuilderMapLoader::GetWorldSizeType
PUBLIC	?GetCurrentWorldSizeType@CvWorldBuilderMapLoader@@SA?AW4WorldSizeTypes@@XZ ; CvWorldBuilderMapLoader::GetCurrentWorldSizeType
; Function compile flags: /Odtp
;	COMDAT ?GetCurrentWorldSizeType@CvWorldBuilderMapLoader@@SA?AW4WorldSizeTypes@@XZ
_TEXT	SEGMENT
?GetCurrentWorldSizeType@CvWorldBuilderMapLoader@@SA?AW4WorldSizeTypes@@XZ PROC ; CvWorldBuilderMapLoader::GetCurrentWorldSizeType, COMDAT

; 1918 : {

	push	ebp
	mov	ebp, esp

; 1919 : 	return GetWorldSizeType(sg_kSave);

	push	OFFSET _sg_kSave
	call	?GetWorldSizeType@CvWorldBuilderMapLoader@@SA?AW4WorldSizeTypes@@ABVCvWorldBuilderMap@@@Z ; CvWorldBuilderMapLoader::GetWorldSizeType
	add	esp, 4

; 1920 : }

	pop	ebp
	ret	0
?GetCurrentWorldSizeType@CvWorldBuilderMapLoader@@SA?AW4WorldSizeTypes@@XZ ENDP ; CvWorldBuilderMapLoader::GetCurrentWorldSizeType
_TEXT	ENDS
PUBLIC	??1CvWorldInfo@@QAE@XZ				; CvWorldInfo::~CvWorldInfo
PUBLIC	??1CvBaseInfo@@QAE@XZ				; CvBaseInfo::~CvBaseInfo
PUBLIC	??_C@_06MEGNPIOK@Worlds?$AA@			; `string'
PUBLIC	??_C@_0CN@GMBBIMHE@Select?5ID?5from?5Worlds?5where?5Type@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?getGridHeight@CvWorldInfo@@QBEHXZ:PROC		; CvWorldInfo::getGridHeight
EXTRN	?getGridWidth@CvWorldInfo@@QBEHXZ:PROC		; CvWorldInfo::getGridWidth
EXTRN	?CacheResult@CvBaseInfo@@QAE_NAAVResults@Database@@@Z:PROC ; CvBaseInfo::CacheResult
EXTRN	??0CvWorldInfo@@QAE@XZ:PROC			; CvWorldInfo::CvWorldInfo
EXTRN	__imp_?SelectAll@Connection@Database@@QAE_NAAVResults@2@PBD@Z:PROC
EXTRN	__imp_??1Results@Database@@UAE@XZ:PROC
EXTRN	__imp_?GetInt@Results@Database@@QAEHH@Z:PROC
EXTRN	__imp_?Step@Results@Database@@QAE_NXZ:PROC
EXTRN	__imp_?Bind@Results@Database@@QAE_NHPBD_N@Z:PROC
EXTRN	__imp_?Execute@Connection@Database@@QBE_NAAVResults@2@PBDH@Z:PROC
EXTRN	__imp_??0Results@Database@@QAE@PBD@Z:PROC
;	COMDAT ??_C@_06MEGNPIOK@Worlds?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_06MEGNPIOK@Worlds?$AA@ DB 'Worlds', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@GMBBIMHE@Select?5ID?5from?5Worlds?5where?5Type@
CONST	SEGMENT
??_C@_0CN@GMBBIMHE@Select?5ID?5from?5Worlds?5where?5Type@ DB 'Select ID f'
	DB	'rom Worlds where Type = ? LIMIT 1', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetWorldSizeType@CvWorldBuilderMapLoader@@SA?AW4WorldSizeTypes@@ABVCvWorldBuilderMap@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetWorldSizeType@CvWorldBuilderMapLoader@@SA?AW4WorldSizeTypes@@ABVCvWorldBuilderMap@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetWorldSizeType@CvWorldBuilderMapLoader@@SA?AW4WorldSizeTypes@@ABVCvWorldBuilderMap@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?GetWorldSizeType@CvWorldBuilderMapLoader@@SA?AW4WorldSizeTypes@@ABVCvWorldBuilderMap@@@Z$2
__ehfuncinfo$?GetWorldSizeType@CvWorldBuilderMapLoader@@SA?AW4WorldSizeTypes@@ABVCvWorldBuilderMap@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?GetWorldSizeType@CvWorldBuilderMapLoader@@SA?AW4WorldSizeTypes@@ABVCvWorldBuilderMap@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvworldbuildermaploader.cpp
xdata$x	ENDS
;	COMDAT ?GetWorldSizeType@CvWorldBuilderMapLoader@@SA?AW4WorldSizeTypes@@ABVCvWorldBuilderMap@@@Z
_TEXT	SEGMENT
$T230542 = -528						; size = 4
$T230538 = -524						; size = 4
$T230534 = -520						; size = 4
$T230530 = -516						; size = 4
_iAreaDifference$224893 = -512				; size = 4
_kInfo$224891 = -508					; size = 340
__$ArrayPad$ = -164					; size = 4
_iSizeTypeArea$224892 = -160				; size = 4
_iArea$224883 = -156					; size = 4
_iSmallestAreaDifference$224885 = -152			; size = 4
_kWorldSizes$224886 = -148				; size = 64
_kWorldSize$224878 = -84				; size = 64
_szWorldType$ = -20					; size = 4
_eWorldSize$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_kMap$ = 8						; size = 4
?GetWorldSizeType@CvWorldBuilderMapLoader@@SA?AW4WorldSizeTypes@@ABVCvWorldBuilderMap@@@Z PROC ; CvWorldBuilderMapLoader::GetWorldSizeType, COMDAT

; 1923 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetWorldSizeType@CvWorldBuilderMapLoader@@SA?AW4WorldSizeTypes@@ABVCvWorldBuilderMap@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 552				; 00000228H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1924 : 	WorldSizeTypes eWorldSize = NO_WORLDSIZE;

	mov	DWORD PTR _eWorldSize$[ebp], -1

; 1925 : 	const char* szWorldType = kMap.GetWorldType();

	mov	eax, DWORD PTR _kMap$[ebp]
	add	eax, 584608				; 0008eba0H
	mov	DWORD PTR _szWorldType$[ebp], eax

; 1926 : 	if(szWorldType != NULL)

	je	SHORT $LN6@GetWorldSi

; 1927 : 	{
; 1928 : 		Database::Results kWorldSize;

	push	0
	lea	ecx, DWORD PTR _kWorldSize$224878[ebp]
	call	DWORD PTR __imp_??0Results@Database@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1929 : 		DB.Execute(kWorldSize, "Select ID from Worlds where Type = ? LIMIT 1");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+912
	mov	DWORD PTR $T230530[ebp], ecx
	push	-1
	push	OFFSET ??_C@_0CN@GMBBIMHE@Select?5ID?5from?5Worlds?5where?5Type@
	lea	edx, DWORD PTR _kWorldSize$224878[ebp]
	push	edx
	mov	ecx, DWORD PTR $T230530[ebp]
	call	DWORD PTR __imp_?Execute@Connection@Database@@QBE_NAAVResults@2@PBDH@Z

; 1930 : 
; 1931 : 		kWorldSize.Bind(1, szWorldType);

	push	1
	mov	eax, DWORD PTR _szWorldType$[ebp]
	push	eax
	push	1
	lea	ecx, DWORD PTR _kWorldSize$224878[ebp]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 1932 : 		if(kWorldSize.Step())

	lea	ecx, DWORD PTR _kWorldSize$224878[ebp]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@GetWorldSi

; 1933 : 		{
; 1934 : 			eWorldSize = (WorldSizeTypes)kWorldSize.GetInt(0);

	push	0
	lea	ecx, DWORD PTR _kWorldSize$224878[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _eWorldSize$[ebp], eax
$LN5@GetWorldSi:

; 1935 : 		}
; 1936 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _kWorldSize$224878[ebp]
	call	DWORD PTR __imp_??1Results@Database@@UAE@XZ
$LN6@GetWorldSi:

; 1937 : 
; 1938 : 	if(eWorldSize == NO_WORLDSIZE)

	cmp	DWORD PTR _eWorldSize$[ebp], -1
	jne	$LN4@GetWorldSi

; 1939 : 	{
; 1940 : 		const int iArea = (int)(kMap.GetWidth() * kMap.GetHeight());

	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+12228]
	mov	DWORD PTR $T230534[ebp], eax
	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	edx, DWORD PTR [ecx+12232]
	mov	DWORD PTR $T230538[ebp], edx
	mov	eax, DWORD PTR $T230534[ebp]
	imul	eax, DWORD PTR $T230538[ebp]
	mov	DWORD PTR _iArea$224883[ebp], eax

; 1941 : 		int iSmallestAreaDifference = 64000; // Arbitrarily large at start

	mov	DWORD PTR _iSmallestAreaDifference$224885[ebp], 64000 ; 0000fa00H

; 1942 : 
; 1943 : 		Database::Results kWorldSizes;

	push	0
	lea	ecx, DWORD PTR _kWorldSizes$224886[ebp]
	call	DWORD PTR __imp_??0Results@Database@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1944 : 		DB.SelectAll(kWorldSizes, "Worlds");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+912
	mov	DWORD PTR $T230542[ebp], ecx
	push	OFFSET ??_C@_06MEGNPIOK@Worlds?$AA@
	lea	edx, DWORD PTR _kWorldSizes$224886[ebp]
	push	edx
	mov	ecx, DWORD PTR $T230542[ebp]
	call	DWORD PTR __imp_?SelectAll@Connection@Database@@QAE_NAAVResults@2@PBD@Z
$LN3@GetWorldSi:

; 1945 : 		while(kWorldSizes.Step())

	lea	ecx, DWORD PTR _kWorldSizes$224886[ebp]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	movzx	eax, al
	test	eax, eax
	je	$LN2@GetWorldSi

; 1946 : 		{
; 1947 : 			CvWorldInfo kInfo;

	lea	ecx, DWORD PTR _kInfo$224891[ebp]
	call	??0CvWorldInfo@@QAE@XZ			; CvWorldInfo::CvWorldInfo
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1948 : 			kInfo.CacheResult(kWorldSizes);

	lea	ecx, DWORD PTR _kWorldSizes$224886[ebp]
	push	ecx
	lea	ecx, DWORD PTR _kInfo$224891[ebp]
	call	?CacheResult@CvBaseInfo@@QAE_NAAVResults@Database@@@Z ; CvBaseInfo::CacheResult

; 1949 : 
; 1950 : 			int iSizeTypeArea = kInfo.getGridWidth() * kInfo.getGridHeight();

	lea	ecx, DWORD PTR _kInfo$224891[ebp]
	call	?getGridWidth@CvWorldInfo@@QBEHXZ	; CvWorldInfo::getGridWidth
	mov	esi, eax
	lea	ecx, DWORD PTR _kInfo$224891[ebp]
	call	?getGridHeight@CvWorldInfo@@QBEHXZ	; CvWorldInfo::getGridHeight
	imul	esi, eax
	mov	DWORD PTR _iSizeTypeArea$224892[ebp], esi

; 1951 : 			int iAreaDifference = abs(iArea - iSizeTypeArea);

	mov	eax, DWORD PTR _iArea$224883[ebp]
	sub	eax, DWORD PTR _iSizeTypeArea$224892[ebp]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iAreaDifference$224893[ebp], eax

; 1952 : 			if(iAreaDifference < iSmallestAreaDifference)

	mov	edx, DWORD PTR _iAreaDifference$224893[ebp]
	cmp	edx, DWORD PTR _iSmallestAreaDifference$224885[ebp]
	jge	SHORT $LN1@GetWorldSi

; 1953 : 			{
; 1954 : 				iSmallestAreaDifference = iAreaDifference;

	mov	eax, DWORD PTR _iAreaDifference$224893[ebp]
	mov	DWORD PTR _iSmallestAreaDifference$224885[ebp], eax

; 1955 : 				eWorldSize = (WorldSizeTypes)kInfo.GetID();

	mov	ecx, DWORD PTR _kInfo$224891[ebp+4]
	mov	DWORD PTR _eWorldSize$[ebp], ecx
$LN1@GetWorldSi:

; 1956 : 			}
; 1957 : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _kInfo$224891[ebp]
	call	??1CvBaseInfo@@QAE@XZ
	jmp	$LN3@GetWorldSi
$LN2@GetWorldSi:

; 1958 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _kWorldSizes$224886[ebp]
	call	DWORD PTR __imp_??1Results@Database@@UAE@XZ
$LN4@GetWorldSi:

; 1959 : 
; 1960 : 	return eWorldSize;

	mov	eax, DWORD PTR _eWorldSize$[ebp]

; 1961 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetWorldSizeType@CvWorldBuilderMapLoader@@SA?AW4WorldSizeTypes@@ABVCvWorldBuilderMap@@@Z$0:
	lea	ecx, DWORD PTR _kWorldSize$224878[ebp]
	jmp	DWORD PTR __imp_??1Results@Database@@UAE@XZ
__unwindfunclet$?GetWorldSizeType@CvWorldBuilderMapLoader@@SA?AW4WorldSizeTypes@@ABVCvWorldBuilderMap@@@Z$1:
	lea	ecx, DWORD PTR _kWorldSizes$224886[ebp]
	jmp	DWORD PTR __imp_??1Results@Database@@UAE@XZ
__unwindfunclet$?GetWorldSizeType@CvWorldBuilderMapLoader@@SA?AW4WorldSizeTypes@@ABVCvWorldBuilderMap@@@Z$2:
	lea	ecx, DWORD PTR _kInfo$224891[ebp]
	jmp	??1CvWorldInfo@@QAE@XZ
__ehhandler$?GetWorldSizeType@CvWorldBuilderMapLoader@@SA?AW4WorldSizeTypes@@ABVCvWorldBuilderMap@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-560]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-152]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetWorldSizeType@CvWorldBuilderMapLoader@@SA?AW4WorldSizeTypes@@ABVCvWorldBuilderMap@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetWorldSizeType@CvWorldBuilderMapLoader@@SA?AW4WorldSizeTypes@@ABVCvWorldBuilderMap@@@Z ENDP ; CvWorldBuilderMapLoader::GetWorldSizeType
; Function compile flags: /Odtp
;	COMDAT ??1CvWorldInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -40						; size = 4
??1CvWorldInfo@@QAE@XZ PROC				; CvWorldInfo::~CvWorldInfo, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvBaseInfo@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvWorldInfo@@QAE@XZ ENDP				; CvWorldInfo::~CvWorldInfo
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CvBaseInfo@@QAE@XZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??1CvBaseInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvBaseInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1CvBaseInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T230724 = -48						; size = 4
$T230719 = -44						; size = 4
$T230714 = -40						; size = 4
$T230709 = -36						; size = 4
$T230704 = -32						; size = 4
$T230699 = -28						; size = 4
$T230694 = -24						; size = 4
$T230689 = -20						; size = 4
$T230684 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvBaseInfo@@QAE@XZ PROC				; CvBaseInfo::~CvBaseInfo, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvBaseInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 7
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 232				; 000000e8H
	mov	DWORD PTR $T230684[ebp], eax
	mov	ecx, DWORD PTR $T230684[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	mov	DWORD PTR $T230689[ebp], ecx
	mov	ecx, DWORD PTR $T230689[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 176				; 000000b0H
	mov	DWORD PTR $T230694[ebp], edx
	mov	ecx, DWORD PTR $T230694[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 148				; 00000094H
	mov	DWORD PTR $T230699[ebp], eax
	mov	ecx, DWORD PTR $T230699[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	mov	DWORD PTR $T230704[ebp], ecx
	mov	ecx, DWORD PTR $T230704[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 92					; 0000005cH
	mov	DWORD PTR $T230709[ebp], edx
	mov	ecx, DWORD PTR $T230709[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 64					; 00000040H
	mov	DWORD PTR $T230714[ebp], eax
	mov	ecx, DWORD PTR $T230714[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	mov	DWORD PTR $T230719[ebp], ecx
	mov	ecx, DWORD PTR $T230719[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	mov	DWORD PTR $T230724[ebp], edx
	mov	ecx, DWORD PTR $T230724[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvBaseInfo@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvBaseInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvBaseInfo@@QAE@XZ ENDP				; CvBaseInfo::~CvBaseInfo
PUBLIC	?ResetPlayerSlots@CvWorldBuilderMapLoader@@SAXXZ ; CvWorldBuilderMapLoader::ResetPlayerSlots
; Function compile flags: /Odtp
;	COMDAT ?ResetPlayerSlots@CvWorldBuilderMapLoader@@SAXXZ
_TEXT	SEGMENT
_i$224902 = -4						; size = 4
?ResetPlayerSlots@CvWorldBuilderMapLoader@@SAXXZ PROC	; CvWorldBuilderMapLoader::ResetPlayerSlots, COMDAT

; 1964 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1965 : 	for(uint i = 0; i < MAX_CIV_PLAYERS; ++i)

	mov	DWORD PTR _i$224902[ebp], 0
	jmp	SHORT $LN3@ResetPlaye
$LN2@ResetPlaye:
	mov	eax, DWORD PTR _i$224902[ebp]
	add	eax, 1
	mov	DWORD PTR _i$224902[ebp], eax
$LN3@ResetPlaye:
	cmp	DWORD PTR _i$224902[ebp], 63		; 0000003fH
	jae	SHORT $LN4@ResetPlaye

; 1966 : 		sg_auiPlayerSlots[i] = i;

	mov	ecx, DWORD PTR _i$224902[ebp]
	mov	edx, DWORD PTR _i$224902[ebp]
	mov	DWORD PTR _sg_auiPlayerSlots[ecx*4], edx
	jmp	SHORT $LN2@ResetPlaye
$LN4@ResetPlaye:

; 1967 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ResetPlayerSlots@CvWorldBuilderMapLoader@@SAXXZ ENDP	; CvWorldBuilderMapLoader::ResetPlayerSlots
_TEXT	ENDS
PUBLIC	?MapPlayerToSlot@CvWorldBuilderMapLoader@@SAXIW4PlayerTypes@@@Z ; CvWorldBuilderMapLoader::MapPlayerToSlot
; Function compile flags: /Odtp
;	COMDAT ?MapPlayerToSlot@CvWorldBuilderMapLoader@@SAXIW4PlayerTypes@@@Z
_TEXT	SEGMENT
_i$224914 = -12						; size = 4
_eOldSlot$224913 = -8					; size = 4
_uiCurrent$224911 = -4					; size = 4
_uiPlayer$ = 8						; size = 4
_ePlayerSlot$ = 12					; size = 4
?MapPlayerToSlot@CvWorldBuilderMapLoader@@SAXIW4PlayerTypes@@@Z PROC ; CvWorldBuilderMapLoader::MapPlayerToSlot, COMDAT

; 1970 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1971 : 	if(uiPlayer < MAX_CIV_PLAYERS && ePlayerSlot >= 0 && ePlayerSlot < MAX_CIV_PLAYERS)

	cmp	DWORD PTR _uiPlayer$[ebp], 63		; 0000003fH
	jae	SHORT $LN8@MapPlayerT
	cmp	DWORD PTR _ePlayerSlot$[ebp], 0
	jl	SHORT $LN8@MapPlayerT
	cmp	DWORD PTR _ePlayerSlot$[ebp], 63	; 0000003fH
	jge	SHORT $LN8@MapPlayerT

; 1972 : 	{
; 1973 : 		const uint uiCurrent = sg_auiPlayerSlots[ePlayerSlot];

	mov	eax, DWORD PTR _ePlayerSlot$[ebp]
	mov	ecx, DWORD PTR _sg_auiPlayerSlots[eax*4]
	mov	DWORD PTR _uiCurrent$224911[ebp], ecx

; 1974 : 		if(uiCurrent != uiPlayer)

	mov	edx, DWORD PTR _uiCurrent$224911[ebp]
	cmp	edx, DWORD PTR _uiPlayer$[ebp]
	je	SHORT $LN8@MapPlayerT

; 1975 : 		{
; 1976 : 			PlayerTypes eOldSlot = NO_PLAYER;

	mov	DWORD PTR _eOldSlot$224913[ebp], -1

; 1977 : 			for(uint i = 0; i < MAX_CIV_PLAYERS; ++i)

	mov	DWORD PTR _i$224914[ebp], 0
	jmp	SHORT $LN5@MapPlayerT
$LN4@MapPlayerT:
	mov	eax, DWORD PTR _i$224914[ebp]
	add	eax, 1
	mov	DWORD PTR _i$224914[ebp], eax
$LN5@MapPlayerT:
	cmp	DWORD PTR _i$224914[ebp], 63		; 0000003fH
	jae	SHORT $LN3@MapPlayerT

; 1978 : 			{
; 1979 : 				if(sg_auiPlayerSlots[i] == uiPlayer)

	mov	ecx, DWORD PTR _i$224914[ebp]
	mov	edx, DWORD PTR _sg_auiPlayerSlots[ecx*4]
	cmp	edx, DWORD PTR _uiPlayer$[ebp]
	jne	SHORT $LN2@MapPlayerT

; 1980 : 				{
; 1981 : 					eOldSlot = (PlayerTypes)i;

	mov	eax, DWORD PTR _i$224914[ebp]
	mov	DWORD PTR _eOldSlot$224913[ebp], eax

; 1982 : 					break;

	jmp	SHORT $LN3@MapPlayerT
$LN2@MapPlayerT:

; 1983 : 				}
; 1984 : 			}

	jmp	SHORT $LN4@MapPlayerT
$LN3@MapPlayerT:

; 1985 : 
; 1986 : 			sg_auiPlayerSlots[ePlayerSlot] = uiPlayer;

	mov	ecx, DWORD PTR _ePlayerSlot$[ebp]
	mov	edx, DWORD PTR _uiPlayer$[ebp]
	mov	DWORD PTR _sg_auiPlayerSlots[ecx*4], edx

; 1987 : 
; 1988 : 			FAssertMsg(eOldSlot != NO_PLAYER, "Player list has holes in it!")
; 1989 : 			if(eOldSlot != NO_PLAYER)

	cmp	DWORD PTR _eOldSlot$224913[ebp], -1
	je	SHORT $LN8@MapPlayerT

; 1990 : 				sg_auiPlayerSlots[eOldSlot] = uiCurrent;

	mov	eax, DWORD PTR _eOldSlot$224913[ebp]
	mov	ecx, DWORD PTR _uiCurrent$224911[ebp]
	mov	DWORD PTR _sg_auiPlayerSlots[eax*4], ecx
$LN8@MapPlayerT:

; 1991 : 		}
; 1992 : 	}
; 1993 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?MapPlayerToSlot@CvWorldBuilderMapLoader@@SAXIW4PlayerTypes@@@Z ENDP ; CvWorldBuilderMapLoader::MapPlayerToSlot
_TEXT	ENDS
PUBLIC	?GetMapPlayerSlot@CvWorldBuilderMapLoader@@SA?AW4PlayerTypes@@I@Z ; CvWorldBuilderMapLoader::GetMapPlayerSlot
; Function compile flags: /Odtp
;	COMDAT ?GetMapPlayerSlot@CvWorldBuilderMapLoader@@SA?AW4PlayerTypes@@I@Z
_TEXT	SEGMENT
_i$224924 = -4						; size = 4
_uiPlayer$ = 8						; size = 4
?GetMapPlayerSlot@CvWorldBuilderMapLoader@@SA?AW4PlayerTypes@@I@Z PROC ; CvWorldBuilderMapLoader::GetMapPlayerSlot, COMDAT

; 1996 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1997 : 	for(int i = 0; i < MAX_CIV_PLAYERS; ++i)

	mov	DWORD PTR _i$224924[ebp], 0
	jmp	SHORT $LN4@GetMapPlay
$LN3@GetMapPlay:
	mov	eax, DWORD PTR _i$224924[ebp]
	add	eax, 1
	mov	DWORD PTR _i$224924[ebp], eax
$LN4@GetMapPlay:
	cmp	DWORD PTR _i$224924[ebp], 63		; 0000003fH
	jge	SHORT $LN2@GetMapPlay

; 1998 : 	{
; 1999 : 		if(sg_auiPlayerSlots[i] == uiPlayer)

	mov	ecx, DWORD PTR _i$224924[ebp]
	mov	edx, DWORD PTR _sg_auiPlayerSlots[ecx*4]
	cmp	edx, DWORD PTR _uiPlayer$[ebp]
	jne	SHORT $LN1@GetMapPlay

; 2000 : 			return static_cast<PlayerTypes>(i);

	mov	eax, DWORD PTR _i$224924[ebp]
	jmp	SHORT $LN5@GetMapPlay
$LN1@GetMapPlay:

; 2001 : 	}

	jmp	SHORT $LN3@GetMapPlay
$LN2@GetMapPlay:

; 2002 : 
; 2003 : 	return NO_PLAYER;

	or	eax, -1
$LN5@GetMapPlay:

; 2004 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMapPlayerSlot@CvWorldBuilderMapLoader@@SA?AW4PlayerTypes@@I@Z ENDP ; CvWorldBuilderMapLoader::GetMapPlayerSlot
_TEXT	ENDS
PUBLIC	?GetMapPlayerCount@CvWorldBuilderMapLoader@@SAHXZ ; CvWorldBuilderMapLoader::GetMapPlayerCount
; Function compile flags: /Odtp
;	COMDAT ?GetMapPlayerCount@CvWorldBuilderMapLoader@@SAHXZ
_TEXT	SEGMENT
?GetMapPlayerCount@CvWorldBuilderMapLoader@@SAHXZ PROC	; CvWorldBuilderMapLoader::GetMapPlayerCount, COMDAT

; 2007 : {

	push	ebp
	mov	ebp, esp

; 2008 : 	return MAX_CIV_PLAYERS;

	mov	eax, 63					; 0000003fH

; 2009 : }

	pop	ebp
	ret	0
?GetMapPlayerCount@CvWorldBuilderMapLoader@@SAHXZ ENDP	; CvWorldBuilderMapLoader::GetMapPlayerCount
_TEXT	ENDS
PUBLIC	?PreviewPlayableCivCount@CvWorldBuilderMapLoader@@SAIPB_W@Z ; CvWorldBuilderMapLoader::PreviewPlayableCivCount
EXTRN	?PreviewPlayableCivCount@CvWorldBuilderMap@@SAIPB_W@Z:PROC ; CvWorldBuilderMap::PreviewPlayableCivCount
; Function compile flags: /Odtp
;	COMDAT ?PreviewPlayableCivCount@CvWorldBuilderMapLoader@@SAIPB_W@Z
_TEXT	SEGMENT
_wszFilename$ = 8					; size = 4
?PreviewPlayableCivCount@CvWorldBuilderMapLoader@@SAIPB_W@Z PROC ; CvWorldBuilderMapLoader::PreviewPlayableCivCount, COMDAT

; 2016 : {

	push	ebp
	mov	ebp, esp

; 2017 : 	return CvWorldBuilderMap::PreviewPlayableCivCount(wszFilename);

	mov	eax, DWORD PTR _wszFilename$[ebp]
	push	eax
	call	?PreviewPlayableCivCount@CvWorldBuilderMap@@SAIPB_W@Z ; CvWorldBuilderMap::PreviewPlayableCivCount
	add	esp, 4

; 2018 : }

	pop	ebp
	ret	0
?PreviewPlayableCivCount@CvWorldBuilderMapLoader@@SAIPB_W@Z ENDP ; CvWorldBuilderMapLoader::PreviewPlayableCivCount
_TEXT	ENDS
PUBLIC	?CheckTempMap@@YA_NPB_W@Z			; CheckTempMap
; Function compile flags: /Odtp
;	COMDAT ?CheckTempMap@@YA_NPB_W@Z
_TEXT	SEGMENT
tv70 = -20						; size = 4
tv92 = -16						; size = 4
tv87 = -12						; size = 2
tv80 = -10						; size = 2
tv75 = -8						; size = 4
tv77 = -4						; size = 4
_wszFilename$ = 8					; size = 4
?CheckTempMap@@YA_NPB_W@Z PROC				; CheckTempMap, COMDAT

; 2024 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 2025 : 	FAssert(wszFilename);
; 2026 : 
; 2027 : 	if(wszFilename && *wszFilename)

	cmp	DWORD PTR _wszFilename$[ebp], 0
	je	SHORT $LN1@CheckTempM
	mov	eax, DWORD PTR _wszFilename$[ebp]
	movzx	ecx, WORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN1@CheckTempM

; 2028 : 	{
; 2029 : 		return wcscmp(wszFilename, sg_wszTempMapName) == 0;

	mov	DWORD PTR tv77[ebp], OFFSET _sg_wszTempMapName
	mov	edx, DWORD PTR _wszFilename$[ebp]
	mov	DWORD PTR tv75[ebp], edx
$LL4@CheckTempM:
	mov	eax, DWORD PTR tv75[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR tv80[ebp], cx
	mov	edx, DWORD PTR tv77[ebp]
	cmp	cx, WORD PTR [edx]
	jne	SHORT $LN5@CheckTempM
	cmp	WORD PTR tv80[ebp], 0
	je	SHORT $LN6@CheckTempM
	mov	eax, DWORD PTR tv75[ebp]
	mov	cx, WORD PTR [eax+2]
	mov	WORD PTR tv87[ebp], cx
	mov	edx, DWORD PTR tv77[ebp]
	cmp	cx, WORD PTR [edx+2]
	jne	SHORT $LN5@CheckTempM
	add	DWORD PTR tv75[ebp], 4
	add	DWORD PTR tv77[ebp], 4
	cmp	WORD PTR tv87[ebp], 0
	jne	SHORT $LL4@CheckTempM
$LN6@CheckTempM:
	mov	DWORD PTR tv92[ebp], 0
	jmp	SHORT $LN7@CheckTempM
$LN5@CheckTempM:
	sbb	eax, eax
	sbb	eax, -1
	mov	DWORD PTR tv92[ebp], eax
$LN7@CheckTempM:
	mov	ecx, DWORD PTR tv92[ebp]
	mov	DWORD PTR tv70[ebp], ecx
	xor	eax, eax
	cmp	DWORD PTR tv70[ebp], 0
	sete	al
	jmp	SHORT $LN2@CheckTempM
$LN1@CheckTempM:

; 2030 : 	}
; 2031 : 
; 2032 : 	return false;

	xor	al, al
$LN2@CheckTempM:

; 2033 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CheckTempMap@@YA_NPB_W@Z ENDP				; CheckTempMap
_TEXT	ENDS
PUBLIC	?TempMapLoaded@@YAXPB_W@Z			; TempMapLoaded
EXTRN	__imp__wcscpy_s:PROC
; Function compile flags: /Odtp
;	COMDAT ?TempMapLoaded@@YAXPB_W@Z
_TEXT	SEGMENT
_wszFilename$ = 8					; size = 4
?TempMapLoaded@@YAXPB_W@Z PROC				; TempMapLoaded, COMDAT

; 2036 : {

	push	ebp
	mov	ebp, esp

; 2037 : 	wcscpy_s(sg_wszTempMapName, MAX_PATH, wszFilename);

	mov	eax, DWORD PTR _wszFilename$[ebp]
	push	eax
	push	260					; 00000104H
	push	OFFSET _sg_wszTempMapName
	call	DWORD PTR __imp__wcscpy_s
	add	esp, 12					; 0000000cH

; 2038 : }

	pop	ebp
	ret	0
?TempMapLoaded@@YAXPB_W@Z ENDP				; TempMapLoaded
_TEXT	ENDS
PUBLIC	??_C@_0N@IMDINEMO@VictoryTypes?$AA@		; `string'
PUBLIC	??_C@_0N@KOOAJHPE@DefaultSpeed?$AA@		; `string'
PUBLIC	??_C@_08JKBDOKML@StartEra?$AA@			; `string'
PUBLIC	??_C@_08NEKNLADO@MaxTurns?$AA@			; `string'
PUBLIC	??_C@_0P@HBKIFFCC@CityStateCount?$AA@		; `string'
PUBLIC	??_C@_0M@KEBDIAFG@PlayerCount?$AA@		; `string'
PUBLIC	??_C@_0M@OHKMKKDH@Description?$AA@		; `string'
PUBLIC	??_C@_04FABLJDN@Name?$AA@			; `string'
PUBLIC	??_C@_07HGNHMCMM@MapSize?$AA@			; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?GetMapPreview@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z ; CvWorldBuilderMapLoader::GetMapPreview
EXTRN	_lua_pushinteger:PROC
EXTRN	?GetText@CvBaseInfo@@QBEPBDXZ:PROC		; CvBaseInfo::GetText
EXTRN	?getGameSpeedInfo@CvGlobals@@QAEPAVCvGameSpeedInfo@@W4GameSpeedTypes@@@Z:PROC ; CvGlobals::getGameSpeedInfo
EXTRN	?getNumGameSpeedInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumGameSpeedInfos
EXTRN	__imp__MultiByteToWideChar@24:PROC
EXTRN	_luaL_checklstring:PROC
;	COMDAT ??_C@_0N@IMDINEMO@VictoryTypes?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
CONST	SEGMENT
??_C@_0N@IMDINEMO@VictoryTypes?$AA@ DB 'VictoryTypes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KOOAJHPE@DefaultSpeed?$AA@
CONST	SEGMENT
??_C@_0N@KOOAJHPE@DefaultSpeed?$AA@ DB 'DefaultSpeed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08JKBDOKML@StartEra?$AA@
CONST	SEGMENT
??_C@_08JKBDOKML@StartEra?$AA@ DB 'StartEra', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08NEKNLADO@MaxTurns?$AA@
CONST	SEGMENT
??_C@_08NEKNLADO@MaxTurns?$AA@ DB 'MaxTurns', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HBKIFFCC@CityStateCount?$AA@
CONST	SEGMENT
??_C@_0P@HBKIFFCC@CityStateCount?$AA@ DB 'CityStateCount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KEBDIAFG@PlayerCount?$AA@
CONST	SEGMENT
??_C@_0M@KEBDIAFG@PlayerCount?$AA@ DB 'PlayerCount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OHKMKKDH@Description?$AA@
CONST	SEGMENT
??_C@_0M@OHKMKKDH@Description?$AA@ DB 'Description', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04FABLJDN@Name?$AA@
CONST	SEGMENT
??_C@_04FABLJDN@Name?$AA@ DB 'Name', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07HGNHMCMM@MapSize?$AA@
CONST	SEGMENT
??_C@_07HGNHMCMM@MapSize?$AA@ DB 'MapSize', 00H		; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvworldbuildermaploader.cpp
CONST	ENDS
;	COMDAT ?GetMapPreview@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z
_TEXT	SEGMENT
tv414 = -652						; size = 8
tv176 = -644						; size = 4
tv382 = -640						; size = 4
tv377 = -634						; size = 1
tv370 = -633						; size = 1
tv366 = -632						; size = 4
tv367 = -628						; size = 4
tv145 = -624						; size = 4
tv350 = -620						; size = 4
tv345 = -614						; size = 1
tv338 = -613						; size = 1
tv333 = -612						; size = 4
tv334 = -608						; size = 4
$T230800 = -604						; size = 4
$T230796 = -599						; size = 1
$T230792 = -598						; size = 1
$T230764 = -597						; size = 1
_pkInfo$225001 = -596					; size = 4
_szVictoryType$225000 = -592				; size = 4
_i$224996 = -588					; size = 4
_pkEraInfo$224982 = -584				; size = 4
_iEra$224978 = -580					; size = 4
_bFound$224977 = -573					; size = 1
_kPlayer$224975 = -572					; size = 4
_i$224971 = -568					; size = 4
_pkSpeed$224968 = -564					; size = 4
_eSpeed$224966 = -560					; size = 4
_i$224962 = -556					; size = 4
_iVictoryTypes$224994 = -552				; size = 4
_szDefaultSpeed$224958 = -548				; size = 4
_iSpeedCount$224961 = -544				; size = 4
_eDefaultSpeed$224959 = -540				; size = 4
_eWorldSize$224957 = -536				; size = 4
_szStartEra$224970 = -532				; size = 4
_wszMapFile$ = -528					; size = 520
__$ArrayPad$ = -8					; size = 4
_szUTF8MapFile$ = -4					; size = 4
_L$ = 8							; size = 4
?GetMapPreview@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z PROC ; CvWorldBuilderMapLoader::GetMapPreview, COMDAT

; 2041 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 652				; 0000028cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2042 : 	if(L == NULL)

	cmp	DWORD PTR _L$[ebp], 0
	jne	SHORT $LN21@GetMapPrev

; 2043 : 	{
; 2044 : 		FAssertMsg(L, "Seriously, you really need a lua state for this.");
; 2045 : 		return 0;

	xor	eax, eax
	jmp	$LN22@GetMapPrev
$LN21@GetMapPrev:

; 2046 : 	}
; 2047 : 
; 2048 : 	const char* szUTF8MapFile = luaL_checkstring(L, 1);

	push	0
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_luaL_checklstring
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _szUTF8MapFile$[ebp], eax

; 2049 : 
; 2050 : 	wchar_t wszMapFile[MAX_PATH] = {0};

	xor	ecx, ecx
	mov	WORD PTR _wszMapFile$[ebp], cx
	push	518					; 00000206H
	push	0
	lea	edx, DWORD PTR _wszMapFile$[ebp+2]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 2051 : 	MultiByteToWideChar(CP_UTF8, 0, szUTF8MapFile, -1, wszMapFile, MAX_PATH);

	push	260					; 00000104H
	lea	eax, DWORD PTR _wszMapFile$[ebp]
	push	eax
	push	-1
	mov	ecx, DWORD PTR _szUTF8MapFile$[ebp]
	push	ecx
	push	0
	push	65001					; 0000fde9H
	call	DWORD PTR __imp__MultiByteToWideChar@24

; 2052 : 
; 2053 : 	if(CheckTempMap(wszMapFile) || sg_kTempMap.Load(wszMapFile, sg_kMapTypeDesc))

	lea	edx, DWORD PTR _wszMapFile$[ebp]
	push	edx
	call	?CheckTempMap@@YA_NPB_W@Z		; CheckTempMap
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN19@GetMapPrev
	push	1
	push	OFFSET _sg_kMapTypeDesc
	lea	ecx, DWORD PTR _wszMapFile$[ebp]
	push	ecx
	mov	ecx, OFFSET _sg_kTempMap
	call	?Load@CvWorldBuilderMap@@QAE_NPB_WABVCvWorldBuilderMapTypeDesc@@_N@Z ; CvWorldBuilderMap::Load
	movzx	edx, al
	test	edx, edx
	je	$LN20@GetMapPrev
$LN19@GetMapPrev:

; 2054 : 	{
; 2055 : 		TempMapLoaded(wszMapFile);

	lea	eax, DWORD PTR _wszMapFile$[ebp]
	push	eax
	call	?TempMapLoaded@@YAXPB_W@Z		; TempMapLoaded
	add	esp, 4

; 2056 : 
; 2057 : 		WorldSizeTypes eWorldSize = GetWorldSizeType(sg_kTempMap);

	push	OFFSET _sg_kTempMap
	call	?GetWorldSizeType@CvWorldBuilderMapLoader@@SA?AW4WorldSizeTypes@@ABVCvWorldBuilderMap@@@Z ; CvWorldBuilderMapLoader::GetWorldSizeType
	add	esp, 4
	mov	DWORD PTR _eWorldSize$224957[ebp], eax

; 2058 : 
; 2059 : 		const char* szDefaultSpeed = sg_kTempMap.GetDefaultGameSpeed();

	mov	DWORD PTR _szDefaultSpeed$224958[ebp], OFFSET _sg_kTempMap+12236

; 2060 : 		GameSpeedTypes eDefaultSpeed = (GameSpeedTypes)GC.getSTANDARD_GAMESPEED();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8464
	mov	DWORD PTR _eDefaultSpeed$224959[ebp], ecx

; 2061 : #ifdef AUI_WARNING_FIXES
; 2062 : 		for (uint i = 0; i < GC.getNumGameSpeedInfos(); ++i)
; 2063 : #else
; 2064 : 		const int iSpeedCount = GC.getNumGameSpeedInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumGameSpeedInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumGameSpeedInfos
	mov	DWORD PTR _iSpeedCount$224961[ebp], eax

; 2065 : 		for(int i = 0; i < iSpeedCount; ++i)

	mov	DWORD PTR _i$224962[ebp], 0
	jmp	SHORT $LN18@GetMapPrev
$LN17@GetMapPrev:
	mov	edx, DWORD PTR _i$224962[ebp]
	add	edx, 1
	mov	DWORD PTR _i$224962[ebp], edx
$LN18@GetMapPrev:
	mov	eax, DWORD PTR _i$224962[ebp]
	cmp	eax, DWORD PTR _iSpeedCount$224961[ebp]
	jge	$LN16@GetMapPrev

; 2066 : #endif
; 2067 : 		{
; 2068 : 			const GameSpeedTypes eSpeed = (GameSpeedTypes)i;

	mov	ecx, DWORD PTR _i$224962[ebp]
	mov	DWORD PTR _eSpeed$224966[ebp], ecx

; 2069 : 			const CvGameSpeedInfo* pkSpeed = GC.getGameSpeedInfo(eSpeed);

	mov	edx, DWORD PTR _eSpeed$224966[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getGameSpeedInfo@CvGlobals@@QAEPAVCvGameSpeedInfo@@W4GameSpeedTypes@@@Z ; CvGlobals::getGameSpeedInfo
	mov	DWORD PTR _pkSpeed$224968[ebp], eax

; 2070 : 			if(pkSpeed != NULL && strcmp(pkSpeed->GetType(), szDefaultSpeed) == 0)

	cmp	DWORD PTR _pkSpeed$224968[ebp], 0
	je	$LN15@GetMapPrev
	mov	eax, DWORD PTR _szDefaultSpeed$224958[ebp]
	mov	DWORD PTR tv334[ebp], eax
	mov	ecx, DWORD PTR _pkSpeed$224968[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR tv333[ebp], eax
$LL54@GetMapPrev:
	mov	ecx, DWORD PTR tv333[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv338[ebp], dl
	mov	eax, DWORD PTR tv334[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN55@GetMapPrev
	cmp	BYTE PTR tv338[ebp], 0
	je	SHORT $LN56@GetMapPrev
	mov	ecx, DWORD PTR tv333[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv345[ebp], dl
	mov	eax, DWORD PTR tv334[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN55@GetMapPrev
	add	DWORD PTR tv333[ebp], 2
	add	DWORD PTR tv334[ebp], 2
	cmp	BYTE PTR tv345[ebp], 0
	jne	SHORT $LL54@GetMapPrev
$LN56@GetMapPrev:
	mov	DWORD PTR tv350[ebp], 0
	jmp	SHORT $LN57@GetMapPrev
$LN55@GetMapPrev:
	sbb	ecx, ecx
	sbb	ecx, -1
	mov	DWORD PTR tv350[ebp], ecx
$LN57@GetMapPrev:
	mov	edx, DWORD PTR tv350[ebp]
	mov	DWORD PTR tv145[ebp], edx
	cmp	DWORD PTR tv145[ebp], 0
	jne	SHORT $LN15@GetMapPrev

; 2071 : 			{
; 2072 : 				eDefaultSpeed = eSpeed;

	mov	eax, DWORD PTR _eSpeed$224966[ebp]
	mov	DWORD PTR _eDefaultSpeed$224959[ebp], eax

; 2073 : 				break;

	jmp	SHORT $LN16@GetMapPrev
$LN15@GetMapPrev:

; 2074 : 			}
; 2075 : 		}

	jmp	$LN17@GetMapPrev
$LN16@GetMapPrev:

; 2076 : 
; 2077 : 		const char* szStartEra = "";

	mov	DWORD PTR _szStartEra$224970[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@

; 2078 : #ifdef AUI_WARNING_FIXES
; 2079 : 		for (byte i = 0; i < sg_kTempMap.GetPlayerCount(); ++i)
; 2080 : #else
; 2081 : 		for(int i = 0; i < sg_kTempMap.GetPlayerCount(); ++i)

	mov	DWORD PTR _i$224971[ebp], 0
	jmp	SHORT $LN14@GetMapPrev
$LN13@GetMapPrev:
	mov	ecx, DWORD PTR _i$224971[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$224971[ebp], ecx
$LN14@GetMapPrev:
	mov	dl, BYTE PTR _sg_kTempMap+12316
	mov	BYTE PTR $T230764[ebp], dl
	movzx	eax, BYTE PTR $T230764[ebp]
	cmp	DWORD PTR _i$224971[ebp], eax
	jge	$LN12@GetMapPrev

; 2082 : #endif
; 2083 : 		{
; 2084 : 			const CvWorldBuilderMap::Player& kPlayer = sg_kTempMap.GetPlayer(i);

	movzx	ecx, BYTE PTR _i$224971[ebp]
	movzx	edx, BYTE PTR _sg_kTempMap+12316
	cmp	ecx, edx
	jge	SHORT $LN33@GetMapPrev
	movzx	eax, BYTE PTR _i$224971[ebp]
	cmp	eax, 32					; 00000020H
	jae	SHORT $LN33@GetMapPrev
	movzx	ecx, BYTE PTR _i$224971[ebp]
	imul	ecx, 436				; 000001b4H
	add	ecx, OFFSET _sg_kTempMap+536608
	mov	DWORD PTR _kPlayer$224975[ebp], ecx
	jmp	SHORT $LN32@GetMapPrev
	jmp	SHORT $LN32@GetMapPrev
$LN33@GetMapPrev:
	mov	DWORD PTR _kPlayer$224975[ebp], OFFSET ?sm_kErrorPlayer@CvWorldBuilderMap@@0UPlayer@1@A ; CvWorldBuilderMap::sm_kErrorPlayer
$LN32@GetMapPrev:

; 2085 : 			if(kPlayer.m_bPlayable)

	mov	edx, DWORD PTR _kPlayer$224975[ebp]
	movzx	eax, BYTE PTR [edx+433]
	test	eax, eax
	je	$LN6@GetMapPrev

; 2086 : 			{
; 2087 : 				bool bFound = false;

	mov	BYTE PTR _bFound$224977[ebp], 0

; 2088 : #ifdef AUI_WARNING_FIXES
; 2089 : 				for (uint iEra = 0; iEra < GC.getNumEraInfos(); ++iEra)
; 2090 : #else
; 2091 : 				for(int iEra = 0; iEra < GC.getNumEraInfos(); ++iEra)

	mov	DWORD PTR _iEra$224978[ebp], 0
	jmp	SHORT $LN10@GetMapPrev
$LN9@GetMapPrev:
	mov	ecx, DWORD PTR _iEra$224978[ebp]
	add	ecx, 1
	mov	DWORD PTR _iEra$224978[ebp], ecx
$LN10@GetMapPrev:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumEraInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumEraInfos
	cmp	DWORD PTR _iEra$224978[ebp], eax
	jge	$LN8@GetMapPrev

; 2092 : #endif
; 2093 : 				{
; 2094 : 					CvEraInfo* pkEraInfo = GC.getEraInfo((EraTypes)iEra);

	mov	edx, DWORD PTR _iEra$224978[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getEraInfo@CvGlobals@@QAEPAVCvEraInfo@@W4EraTypes@@@Z ; CvGlobals::getEraInfo
	mov	DWORD PTR _pkEraInfo$224982[ebp], eax

; 2095 : 					if(pkEraInfo != NULL && strcmp(pkEraInfo->GetType(), kPlayer.m_szEra) == 0)

	cmp	DWORD PTR _pkEraInfo$224982[ebp], 0
	je	$LN7@GetMapPrev
	mov	eax, DWORD PTR _kPlayer$224975[ebp]
	add	eax, 288				; 00000120H
	mov	DWORD PTR tv367[ebp], eax
	mov	ecx, DWORD PTR _pkEraInfo$224982[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR tv366[ebp], eax
$LL58@GetMapPrev:
	mov	ecx, DWORD PTR tv366[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv370[ebp], dl
	mov	eax, DWORD PTR tv367[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN59@GetMapPrev
	cmp	BYTE PTR tv370[ebp], 0
	je	SHORT $LN60@GetMapPrev
	mov	ecx, DWORD PTR tv366[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv377[ebp], dl
	mov	eax, DWORD PTR tv367[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN59@GetMapPrev
	add	DWORD PTR tv366[ebp], 2
	add	DWORD PTR tv367[ebp], 2
	cmp	BYTE PTR tv377[ebp], 0
	jne	SHORT $LL58@GetMapPrev
$LN60@GetMapPrev:
	mov	DWORD PTR tv382[ebp], 0
	jmp	SHORT $LN61@GetMapPrev
$LN59@GetMapPrev:
	sbb	ecx, ecx
	sbb	ecx, -1
	mov	DWORD PTR tv382[ebp], ecx
$LN61@GetMapPrev:
	mov	edx, DWORD PTR tv382[ebp]
	mov	DWORD PTR tv176[ebp], edx
	cmp	DWORD PTR tv176[ebp], 0
	jne	SHORT $LN7@GetMapPrev

; 2096 : 					{
; 2097 : 						szStartEra = pkEraInfo->GetText();

	mov	ecx, DWORD PTR _pkEraInfo$224982[ebp]
	call	?GetText@CvBaseInfo@@QBEPBDXZ		; CvBaseInfo::GetText
	mov	DWORD PTR _szStartEra$224970[ebp], eax

; 2098 : 						bFound = true;

	mov	BYTE PTR _bFound$224977[ebp], 1

; 2099 : 						break;

	jmp	SHORT $LN8@GetMapPrev
$LN7@GetMapPrev:

; 2100 : 					}
; 2101 : 				}

	jmp	$LN9@GetMapPrev
$LN8@GetMapPrev:

; 2102 : 
; 2103 : 				if(bFound)

	movzx	eax, BYTE PTR _bFound$224977[ebp]
	test	eax, eax
	je	SHORT $LN6@GetMapPrev

; 2104 : 					break;

	jmp	SHORT $LN12@GetMapPrev
$LN6@GetMapPrev:

; 2105 : 			}
; 2106 : 		}

	jmp	$LN13@GetMapPrev
$LN12@GetMapPrev:

; 2107 : 
; 2108 : 		lua_createtable(L, 0, 8);

	push	8
	push	0
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_createtable
	add	esp, 12					; 0000000cH

; 2109 : 
; 2110 : 		lua_pushstring(L, "MapSize");

	push	OFFSET ??_C@_07HGNHMCMM@MapSize?$AA@
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushstring
	add	esp, 8

; 2111 : 		lua_pushinteger(L, eWorldSize);

	mov	eax, DWORD PTR _eWorldSize$224957[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushinteger
	add	esp, 8

; 2112 : 		lua_rawset(L, -3);

	push	-3					; fffffffdH
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_rawset
	add	esp, 8

; 2113 : 
; 2114 : 		lua_pushstring(L, "Name");

	push	OFFSET ??_C@_04FABLJDN@Name?$AA@
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushstring
	add	esp, 8

; 2115 : 		lua_pushstring(L, sg_kTempMap.m_sMapName);

	mov	ecx, DWORD PTR _sg_kTempMap+4008
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushstring
	add	esp, 8

; 2116 : 		lua_rawset(L, -3);

	push	-3					; fffffffdH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_rawset
	add	esp, 8

; 2117 : 
; 2118 : 		lua_pushstring(L, "Description");

	push	OFFSET ??_C@_0M@OHKMKKDH@Description?$AA@
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushstring
	add	esp, 8

; 2119 : 		lua_pushstring(L, sg_kTempMap.m_sMapDescription);

	mov	edx, DWORD PTR _sg_kTempMap+4012
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushstring
	add	esp, 8

; 2120 : 		lua_rawset(L, -3);

	push	-3					; fffffffdH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_rawset
	add	esp, 8

; 2121 : 
; 2122 : 		lua_pushstring(L, "PlayerCount");

	push	OFFSET ??_C@_0M@KEBDIAFG@PlayerCount?$AA@
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushstring
	add	esp, 8

; 2123 : 		lua_pushnumber(L, sg_kTempMap.GetPlayerCount());

	mov	al, BYTE PTR _sg_kTempMap+12316
	mov	BYTE PTR $T230792[ebp], al
	movzx	ecx, BYTE PTR $T230792[ebp]
	cvtsi2sd xmm0, ecx
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushnumber
	add	esp, 12					; 0000000cH

; 2124 : 		lua_rawset(L, -3);

	push	-3					; fffffffdH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_rawset
	add	esp, 8

; 2125 : 
; 2126 : 		lua_pushstring(L, "CityStateCount");

	push	OFFSET ??_C@_0P@HBKIFFCC@CityStateCount?$AA@
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushstring
	add	esp, 8

; 2127 : 		lua_pushnumber(L, sg_kTempMap.GetCityStateCount());

	mov	dl, BYTE PTR _sg_kTempMap+12317
	mov	BYTE PTR $T230796[ebp], dl
	movzx	eax, BYTE PTR $T230796[ebp]
	cvtsi2sd xmm0, eax
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushnumber
	add	esp, 12					; 0000000cH

; 2128 : 		lua_rawset(L, -3);

	push	-3					; fffffffdH
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_rawset
	add	esp, 8

; 2129 : 
; 2130 : 		lua_pushstring(L, "MaxTurns");

	push	OFFSET ??_C@_08NEKNLADO@MaxTurns?$AA@
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushstring
	add	esp, 8

; 2131 : 		lua_pushnumber(L, sg_kTempMap.GetMaxTurns());

	mov	ecx, DWORD PTR _sg_kTempMap+12304
	mov	DWORD PTR $T230800[ebp], ecx
	mov	edx, DWORD PTR $T230800[ebp]
	mov	DWORD PTR tv414[ebp], edx
	mov	DWORD PTR tv414[ebp+4], 0
	fild	QWORD PTR tv414[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushnumber
	add	esp, 12					; 0000000cH

; 2132 : 		lua_rawset(L, -3);

	push	-3					; fffffffdH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_rawset
	add	esp, 8

; 2133 : 
; 2134 : 		lua_pushstring(L, "StartEra");

	push	OFFSET ??_C@_08JKBDOKML@StartEra?$AA@
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushstring
	add	esp, 8

; 2135 : 		lua_pushstring(L, szStartEra);

	mov	eax, DWORD PTR _szStartEra$224970[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushstring
	add	esp, 8

; 2136 : 		lua_rawset(L, -3);

	push	-3					; fffffffdH
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_rawset
	add	esp, 8

; 2137 : 
; 2138 : 		lua_pushstring(L, "DefaultSpeed");

	push	OFFSET ??_C@_0N@KOOAJHPE@DefaultSpeed?$AA@
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushstring
	add	esp, 8

; 2139 : 		lua_pushinteger(L, eDefaultSpeed);

	mov	ecx, DWORD PTR _eDefaultSpeed$224959[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushinteger
	add	esp, 8

; 2140 : 		lua_rawset(L, -3);

	push	-3					; fffffffdH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_rawset
	add	esp, 8

; 2141 : 
; 2142 : 		const int iVictoryTypes = GC.getNumVictoryInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumVictoryInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumVictoryInfos
	mov	DWORD PTR _iVictoryTypes$224994[ebp], eax

; 2143 : 		lua_pushstring(L, "VictoryTypes");

	push	OFFSET ??_C@_0N@IMDINEMO@VictoryTypes?$AA@
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushstring
	add	esp, 8

; 2144 : 		lua_createtable(L, iVictoryTypes, 0);

	push	0
	mov	edx, DWORD PTR _iVictoryTypes$224994[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_createtable
	add	esp, 12					; 0000000cH

; 2145 : 		for(int i = 0; i < iVictoryTypes; ++i)

	mov	DWORD PTR _i$224996[ebp], 0
	jmp	SHORT $LN5@GetMapPrev
$LN4@GetMapPrev:
	mov	ecx, DWORD PTR _i$224996[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$224996[ebp], ecx
$LN5@GetMapPrev:
	mov	edx, DWORD PTR _i$224996[ebp]
	cmp	edx, DWORD PTR _iVictoryTypes$224994[ebp]
	jge	SHORT $LN3@GetMapPrev

; 2146 : 		{
; 2147 : 			const char* szVictoryType = "";

	mov	DWORD PTR _szVictoryType$225000[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@

; 2148 : 			const CvVictoryInfo* pkInfo = GC.getVictoryInfo((VictoryTypes)i);

	mov	eax, DWORD PTR _i$224996[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getVictoryInfo@CvGlobals@@QAEPAVCvVictoryInfo@@W4VictoryTypes@@@Z ; CvGlobals::getVictoryInfo
	mov	DWORD PTR _pkInfo$225001[ebp], eax

; 2149 : 			if(pkInfo != NULL)

	cmp	DWORD PTR _pkInfo$225001[ebp], 0
	je	SHORT $LN2@GetMapPrev

; 2150 : 				szVictoryType = pkInfo->GetType();

	mov	ecx, DWORD PTR _pkInfo$225001[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR _szVictoryType$225000[ebp], eax
$LN2@GetMapPrev:

; 2151 : 
; 2152 : 			lua_pushstring(L, szVictoryType);

	mov	ecx, DWORD PTR _szVictoryType$225000[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushstring
	add	esp, 8

; 2153 : 			lua_rawseti(L, -2, i + 1);

	mov	eax, DWORD PTR _i$224996[ebp]
	add	eax, 1
	push	eax
	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_rawseti
	add	esp, 12					; 0000000cH

; 2154 : 		}

	jmp	$LN4@GetMapPrev
$LN3@GetMapPrev:

; 2155 : 		lua_rawset(L, -3);

	push	-3					; fffffffdH
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_rawset
	add	esp, 8

; 2156 : 	}
; 2157 : 	else

	jmp	SHORT $LN1@GetMapPrev
$LN20@GetMapPrev:

; 2158 : 	{
; 2159 : 		lua_pushnil(L);

	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushnil
	add	esp, 4
$LN1@GetMapPrev:

; 2160 : 	}
; 2161 : 
; 2162 : 	return 1;

	mov	eax, 1
$LN22@GetMapPrev:

; 2163 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMapPreview@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z ENDP ; CvWorldBuilderMapLoader::GetMapPreview
_TEXT	ENDS
PUBLIC	??_C@_0BA@MMDBALPM@DefaultHandicap?$AA@		; `string'
PUBLIC	??_C@_08IBDGMIFI@Playable?$AA@			; `string'
PUBLIC	??_C@_07GJEFHDNN@CivType?$AA@			; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?GetMapPlayers@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z ; CvWorldBuilderMapLoader::GetMapPlayers
;	COMDAT ??_C@_0BA@MMDBALPM@DefaultHandicap?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
CONST	SEGMENT
??_C@_0BA@MMDBALPM@DefaultHandicap?$AA@ DB 'DefaultHandicap', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08IBDGMIFI@Playable?$AA@
CONST	SEGMENT
??_C@_08IBDGMIFI@Playable?$AA@ DB 'Playable', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07GJEFHDNN@CivType?$AA@
CONST	SEGMENT
??_C@_07GJEFHDNN@CivType?$AA@ DB 'CivType', 00H		; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvworldbuildermaploader.cpp
CONST	ENDS
;	COMDAT ?GetMapPlayers@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z
_TEXT	SEGMENT
tv173 = -624						; size = 4
tv298 = -620						; size = 4
tv293 = -614						; size = 1
tv286 = -613						; size = 1
tv282 = -612						; size = 4
tv283 = -608						; size = 4
tv153 = -604						; size = 4
tv267 = -600						; size = 4
tv262 = -594						; size = 1
tv255 = -593						; size = 1
tv251 = -592						; size = 4
tv252 = -588						; size = 4
$T230818 = -581						; size = 1
_pkHandicap$225038 = -580				; size = 4
_eCurrentHandicap$225036 = -576				; size = 4
_iHandicap$225032 = -572				; size = 4
_pkCiv$225028 = -568					; size = 4
_eCurrentCiv$225026 = -564				; size = 4
_iCiv$225022 = -560					; size = 4
_eHandicapType$225030 = -556				; size = 4
_eCivType$225021 = -552					; size = 4
_kPlayer$225020 = -548					; size = 4
_uiPlayer$225016 = -544					; size = 4
_iHandicapCount$225015 = -540				; size = 4
_uiPlayerCount$225013 = -536				; size = 4
_iCivCount$225014 = -532				; size = 4
_wszMapFile$ = -528					; size = 520
__$ArrayPad$ = -8					; size = 4
_szUTF8MapFile$ = -4					; size = 4
_L$ = 8							; size = 4
?GetMapPlayers@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z PROC ; CvWorldBuilderMapLoader::GetMapPlayers, COMDAT

; 2166 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 624				; 00000270H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2167 : 	if(L == NULL)

	cmp	DWORD PTR _L$[ebp], 0
	jne	SHORT $LN15@GetMapPlay@2

; 2168 : 	{
; 2169 : 		FAssertMsg(L, "Seriously, you really need a lua state for this.");
; 2170 : 		return 0;

	xor	eax, eax
	jmp	$LN16@GetMapPlay@2
$LN15@GetMapPlay@2:

; 2171 : 	}
; 2172 : 
; 2173 : 	const char* szUTF8MapFile = luaL_checkstring(L, 1);

	push	0
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_luaL_checklstring
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _szUTF8MapFile$[ebp], eax

; 2174 : 
; 2175 : 	wchar_t wszMapFile[MAX_PATH] = {0};

	xor	ecx, ecx
	mov	WORD PTR _wszMapFile$[ebp], cx
	push	518					; 00000206H
	push	0
	lea	edx, DWORD PTR _wszMapFile$[ebp+2]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 2176 : 	MultiByteToWideChar(CP_UTF8, 0, szUTF8MapFile, -1, wszMapFile, MAX_PATH);

	push	260					; 00000104H
	lea	eax, DWORD PTR _wszMapFile$[ebp]
	push	eax
	push	-1
	mov	ecx, DWORD PTR _szUTF8MapFile$[ebp]
	push	ecx
	push	0
	push	65001					; 0000fde9H
	call	DWORD PTR __imp__MultiByteToWideChar@24

; 2177 : 
; 2178 : 	if(CheckTempMap(wszMapFile) || sg_kTempMap.Load(wszMapFile, sg_kMapTypeDesc))

	lea	edx, DWORD PTR _wszMapFile$[ebp]
	push	edx
	call	?CheckTempMap@@YA_NPB_W@Z		; CheckTempMap
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN13@GetMapPlay@2
	push	1
	push	OFFSET _sg_kMapTypeDesc
	lea	ecx, DWORD PTR _wszMapFile$[ebp]
	push	ecx
	mov	ecx, OFFSET _sg_kTempMap
	call	?Load@CvWorldBuilderMap@@QAE_NPB_WABVCvWorldBuilderMapTypeDesc@@_N@Z ; CvWorldBuilderMap::Load
	movzx	edx, al
	test	edx, edx
	je	$LN14@GetMapPlay@2
$LN13@GetMapPlay@2:

; 2179 : 	{
; 2180 : 		TempMapLoaded(wszMapFile);

	lea	eax, DWORD PTR _wszMapFile$[ebp]
	push	eax
	call	?TempMapLoaded@@YAXPB_W@Z		; TempMapLoaded
	add	esp, 4

; 2181 : 
; 2182 : #ifdef AUI_WARNING_FIXES
; 2183 : 		const byte uiPlayerCount = sg_kTempMap.GetPlayerCount();
; 2184 : #else
; 2185 : 		const uint uiPlayerCount = sg_kTempMap.GetPlayerCount();

	mov	cl, BYTE PTR _sg_kTempMap+12316
	mov	BYTE PTR $T230818[ebp], cl
	movzx	edx, BYTE PTR $T230818[ebp]
	mov	DWORD PTR _uiPlayerCount$225013[ebp], edx

; 2186 : #endif
; 2187 : 		const int iCivCount = GC.getNumCivilizationInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumCivilizationInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumCivilizationInfos
	mov	DWORD PTR _iCivCount$225014[ebp], eax

; 2188 : 		const int iHandicapCount = GC.getNumHandicapInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumHandicapInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumHandicapInfos
	mov	DWORD PTR _iHandicapCount$225015[ebp], eax

; 2189 : 
; 2190 : 		lua_createtable(L, uiPlayerCount, 0);

	push	0
	mov	eax, DWORD PTR _uiPlayerCount$225013[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_createtable
	add	esp, 12					; 0000000cH

; 2191 : #ifdef AUI_WARNING_FIXES
; 2192 : 		for (byte uiPlayer = 0; uiPlayer < uiPlayerCount; ++uiPlayer)
; 2193 : #else
; 2194 : 		for(uint uiPlayer = 0; uiPlayer < uiPlayerCount; ++uiPlayer)

	mov	DWORD PTR _uiPlayer$225016[ebp], 0
	jmp	SHORT $LN12@GetMapPlay@2
$LN11@GetMapPlay@2:
	mov	edx, DWORD PTR _uiPlayer$225016[ebp]
	add	edx, 1
	mov	DWORD PTR _uiPlayer$225016[ebp], edx
$LN12@GetMapPlay@2:
	mov	eax, DWORD PTR _uiPlayer$225016[ebp]
	cmp	eax, DWORD PTR _uiPlayerCount$225013[ebp]
	jae	$LN10@GetMapPlay@2

; 2195 : #endif
; 2196 : 		{
; 2197 : 			const CvWorldBuilderMap::Player& kPlayer = sg_kTempMap.GetPlayer(uiPlayer);

	movzx	ecx, BYTE PTR _uiPlayer$225016[ebp]
	movzx	edx, BYTE PTR _sg_kTempMap+12316
	cmp	ecx, edx
	jge	SHORT $LN21@GetMapPlay@2
	movzx	eax, BYTE PTR _uiPlayer$225016[ebp]
	cmp	eax, 32					; 00000020H
	jae	SHORT $LN21@GetMapPlay@2
	movzx	ecx, BYTE PTR _uiPlayer$225016[ebp]
	imul	ecx, 436				; 000001b4H
	add	ecx, OFFSET _sg_kTempMap+536608
	mov	DWORD PTR _kPlayer$225020[ebp], ecx
	jmp	SHORT $LN22@GetMapPlay@2
	jmp	SHORT $LN22@GetMapPlay@2
$LN21@GetMapPlay@2:
	mov	DWORD PTR _kPlayer$225020[ebp], OFFSET ?sm_kErrorPlayer@CvWorldBuilderMap@@0UPlayer@1@A ; CvWorldBuilderMap::sm_kErrorPlayer
$LN22@GetMapPlay@2:

; 2198 : 
; 2199 : 			CivilizationTypes eCivType = NO_CIVILIZATION;

	mov	DWORD PTR _eCivType$225021[ebp], -1

; 2200 : 			for(int iCiv = 0; iCiv < iCivCount; ++iCiv)

	mov	DWORD PTR _iCiv$225022[ebp], 0
	jmp	SHORT $LN9@GetMapPlay@2
$LN8@GetMapPlay@2:
	mov	edx, DWORD PTR _iCiv$225022[ebp]
	add	edx, 1
	mov	DWORD PTR _iCiv$225022[ebp], edx
$LN9@GetMapPlay@2:
	mov	eax, DWORD PTR _iCiv$225022[ebp]
	cmp	eax, DWORD PTR _iCivCount$225014[ebp]
	jge	$LN7@GetMapPlay@2

; 2201 : 			{
; 2202 : 				const CivilizationTypes eCurrentCiv = (CivilizationTypes)iCiv;

	mov	ecx, DWORD PTR _iCiv$225022[ebp]
	mov	DWORD PTR _eCurrentCiv$225026[ebp], ecx

; 2203 : 				const CvCivilizationInfo* pkCiv = GC.getCivilizationInfo(eCurrentCiv);

	mov	edx, DWORD PTR _eCurrentCiv$225026[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z ; CvGlobals::getCivilizationInfo
	mov	DWORD PTR _pkCiv$225028[ebp], eax

; 2204 : 				if(pkCiv != NULL && strcmp(pkCiv->GetType(), kPlayer.m_szCivType) == 0)

	cmp	DWORD PTR _pkCiv$225028[ebp], 0
	je	$LN6@GetMapPlay@2
	mov	eax, DWORD PTR _kPlayer$225020[ebp]
	add	eax, 160				; 000000a0H
	mov	DWORD PTR tv252[ebp], eax
	mov	ecx, DWORD PTR _pkCiv$225028[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR tv251[ebp], eax
$LL30@GetMapPlay@2:
	mov	ecx, DWORD PTR tv251[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv255[ebp], dl
	mov	eax, DWORD PTR tv252[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN31@GetMapPlay@2
	cmp	BYTE PTR tv255[ebp], 0
	je	SHORT $LN32@GetMapPlay@2
	mov	ecx, DWORD PTR tv251[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv262[ebp], dl
	mov	eax, DWORD PTR tv252[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN31@GetMapPlay@2
	add	DWORD PTR tv251[ebp], 2
	add	DWORD PTR tv252[ebp], 2
	cmp	BYTE PTR tv262[ebp], 0
	jne	SHORT $LL30@GetMapPlay@2
$LN32@GetMapPlay@2:
	mov	DWORD PTR tv267[ebp], 0
	jmp	SHORT $LN33@GetMapPlay@2
$LN31@GetMapPlay@2:
	sbb	ecx, ecx
	sbb	ecx, -1
	mov	DWORD PTR tv267[ebp], ecx
$LN33@GetMapPlay@2:
	mov	edx, DWORD PTR tv267[ebp]
	mov	DWORD PTR tv153[ebp], edx
	cmp	DWORD PTR tv153[ebp], 0
	jne	SHORT $LN6@GetMapPlay@2

; 2205 : 				{
; 2206 : 					eCivType = eCurrentCiv;

	mov	eax, DWORD PTR _eCurrentCiv$225026[ebp]
	mov	DWORD PTR _eCivType$225021[ebp], eax

; 2207 : 					break;

	jmp	SHORT $LN7@GetMapPlay@2
$LN6@GetMapPlay@2:

; 2208 : 				}
; 2209 : 			}

	jmp	$LN8@GetMapPlay@2
$LN7@GetMapPlay@2:

; 2210 : 
; 2211 : 			HandicapTypes eHandicapType = (HandicapTypes)GC.getSTANDARD_HANDICAP();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8452
	mov	DWORD PTR _eHandicapType$225030[ebp], ecx

; 2212 : 			for(int iHandicap = 0; iHandicap < iHandicapCount; ++iHandicap)

	mov	DWORD PTR _iHandicap$225032[ebp], 0
	jmp	SHORT $LN5@GetMapPlay@2
$LN4@GetMapPlay@2:
	mov	edx, DWORD PTR _iHandicap$225032[ebp]
	add	edx, 1
	mov	DWORD PTR _iHandicap$225032[ebp], edx
$LN5@GetMapPlay@2:
	mov	eax, DWORD PTR _iHandicap$225032[ebp]
	cmp	eax, DWORD PTR _iHandicapCount$225015[ebp]
	jge	$LN3@GetMapPlay@2

; 2213 : 			{
; 2214 : 				const HandicapTypes eCurrentHandicap = (HandicapTypes)iHandicap;

	mov	ecx, DWORD PTR _iHandicap$225032[ebp]
	mov	DWORD PTR _eCurrentHandicap$225036[ebp], ecx

; 2215 : 				const CvHandicapInfo* pkHandicap = GC.getHandicapInfo(eCurrentHandicap);

	mov	edx, DWORD PTR _eCurrentHandicap$225036[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getHandicapInfo@CvGlobals@@QAEPAVCvHandicapInfo@@W4HandicapTypes@@@Z ; CvGlobals::getHandicapInfo
	mov	DWORD PTR _pkHandicap$225038[ebp], eax

; 2216 : 				if(pkHandicap != NULL && strcmp(pkHandicap->GetType(), kPlayer.m_szHandicap) == 0)

	cmp	DWORD PTR _pkHandicap$225038[ebp], 0
	je	$LN2@GetMapPlay@2
	mov	eax, DWORD PTR _kPlayer$225020[ebp]
	add	eax, 352				; 00000160H
	mov	DWORD PTR tv283[ebp], eax
	mov	ecx, DWORD PTR _pkHandicap$225038[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR tv282[ebp], eax
$LL34@GetMapPlay@2:
	mov	ecx, DWORD PTR tv282[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv286[ebp], dl
	mov	eax, DWORD PTR tv283[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN35@GetMapPlay@2
	cmp	BYTE PTR tv286[ebp], 0
	je	SHORT $LN36@GetMapPlay@2
	mov	ecx, DWORD PTR tv282[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv293[ebp], dl
	mov	eax, DWORD PTR tv283[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN35@GetMapPlay@2
	add	DWORD PTR tv282[ebp], 2
	add	DWORD PTR tv283[ebp], 2
	cmp	BYTE PTR tv293[ebp], 0
	jne	SHORT $LL34@GetMapPlay@2
$LN36@GetMapPlay@2:
	mov	DWORD PTR tv298[ebp], 0
	jmp	SHORT $LN37@GetMapPlay@2
$LN35@GetMapPlay@2:
	sbb	ecx, ecx
	sbb	ecx, -1
	mov	DWORD PTR tv298[ebp], ecx
$LN37@GetMapPlay@2:
	mov	edx, DWORD PTR tv298[ebp]
	mov	DWORD PTR tv173[ebp], edx
	cmp	DWORD PTR tv173[ebp], 0
	jne	SHORT $LN2@GetMapPlay@2

; 2217 : 				{
; 2218 : 					eHandicapType = eCurrentHandicap;

	mov	eax, DWORD PTR _eCurrentHandicap$225036[ebp]
	mov	DWORD PTR _eHandicapType$225030[ebp], eax

; 2219 : 					break;

	jmp	SHORT $LN3@GetMapPlay@2
$LN2@GetMapPlay@2:

; 2220 : 				}
; 2221 : 			}

	jmp	$LN4@GetMapPlay@2
$LN3@GetMapPlay@2:

; 2222 : 
; 2223 : 			lua_createtable(L, 0, 2);

	push	2
	push	0
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_createtable
	add	esp, 12					; 0000000cH

; 2224 : 
; 2225 : 			lua_pushstring(L, "CivType");

	push	OFFSET ??_C@_07GJEFHDNN@CivType?$AA@
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushstring
	add	esp, 8

; 2226 : 			lua_pushinteger(L, eCivType);

	mov	eax, DWORD PTR _eCivType$225021[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushinteger
	add	esp, 8

; 2227 : 			lua_rawset(L, -3);

	push	-3					; fffffffdH
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_rawset
	add	esp, 8

; 2228 : 
; 2229 : 			lua_pushstring(L, "Playable");

	push	OFFSET ??_C@_08IBDGMIFI@Playable?$AA@
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushstring
	add	esp, 8

; 2230 : 			lua_pushboolean(L, kPlayer.m_bPlayable);

	mov	ecx, DWORD PTR _kPlayer$225020[ebp]
	movzx	edx, BYTE PTR [ecx+433]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushboolean
	add	esp, 8

; 2231 : 			lua_rawset(L, -3);

	push	-3					; fffffffdH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_rawset
	add	esp, 8

; 2232 : 
; 2233 : 			lua_pushstring(L, "DefaultHandicap");

	push	OFFSET ??_C@_0BA@MMDBALPM@DefaultHandicap?$AA@
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushstring
	add	esp, 8

; 2234 : 			lua_pushinteger(L, eHandicapType);

	mov	eax, DWORD PTR _eHandicapType$225030[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushinteger
	add	esp, 8

; 2235 : 			lua_rawset(L, -3);

	push	-3					; fffffffdH
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_rawset
	add	esp, 8

; 2236 : 
; 2237 : 			lua_rawseti(L, -2, uiPlayer + 1);

	mov	eax, DWORD PTR _uiPlayer$225016[ebp]
	add	eax, 1
	push	eax
	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_rawseti
	add	esp, 12					; 0000000cH

; 2238 : 		}

	jmp	$LN11@GetMapPlay@2
$LN10@GetMapPlay@2:

; 2239 : 	}
; 2240 : 	else

	jmp	SHORT $LN1@GetMapPlay@2
$LN14@GetMapPlay@2:

; 2241 : 	{
; 2242 : 		lua_pushnil(L);

	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushnil
	add	esp, 4
$LN1@GetMapPlay@2:

; 2243 : 	}
; 2244 : 
; 2245 : 	return 1;

	mov	eax, 1
$LN16@GetMapPlay@2:

; 2246 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMapPlayers@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z ENDP ; CvWorldBuilderMapLoader::GetMapPlayers
_TEXT	ENDS
PUBLIC	??_C@_0BP@DNHIPNC@AddResourcesForWorldBuilderMap?$AA@ ; `string'
PUBLIC	??_C@_0L@JNKLPMBD@AddGoodies?$AA@		; `string'
PUBLIC	??_C@_0BM@CLNPACCC@WorldBuilderRandomItems?4lua?$AA@ ; `string'
PUBLIC	?AddRandomItems@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z ; CvWorldBuilderMapLoader::AddRandomItems
EXTRN	?loadWBScenario@CvPreGame@@YA_NXZ:PROC		; CvPreGame::loadWBScenario
;	COMDAT ??_C@_0BP@DNHIPNC@AddResourcesForWorldBuilderMap?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
CONST	SEGMENT
??_C@_0BP@DNHIPNC@AddResourcesForWorldBuilderMap?$AA@ DB 'AddResourcesFor'
	DB	'WorldBuilderMap', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JNKLPMBD@AddGoodies?$AA@
CONST	SEGMENT
??_C@_0L@JNKLPMBD@AddGoodies?$AA@ DB 'AddGoodies', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@CLNPACCC@WorldBuilderRandomItems?4lua?$AA@
CONST	SEGMENT
??_C@_0BM@CLNPACCC@WorldBuilderRandomItems?4lua?$AA@ DB 'WorldBuilderRand'
	DB	'omItems.lua', 00H				; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvworldbuildermaploader.cpp
CONST	ENDS
;	COMDAT ?AddRandomItems@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z
_TEXT	SEGMENT
tv91 = -36						; size = 4
tv80 = -29						; size = 1
$T230858 = -28						; size = 4
_szResourcesFunction$225064 = -24			; size = 4
_szGoodiesFunction$225059 = -20				; size = 4
_szLuaFile$225054 = -16					; size = 4
_bLoadedMapGenerator$225056 = -11			; size = 1
_bRandomResources$ = -10				; size = 1
_bRandomGoodies$ = -9					; size = 1
_pkScriptSystem$ = -8					; size = 4
_iTop$ = -4						; size = 4
_L$ = 8							; size = 4
?AddRandomItems@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z PROC ; CvWorldBuilderMapLoader::AddRandomItems, COMDAT

; 2249 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 2250 : 	if(L == NULL)

	cmp	DWORD PTR _L$[ebp], 0
	jne	SHORT $LN10@AddRandomI

; 2251 : 	{
; 2252 : 		FAssertMsg(L, "Seriously, you really need a lua state for this.");
; 2253 : 		return 0;

	xor	eax, eax
	jmp	$LN11@AddRandomI
$LN10@AddRandomI:

; 2254 : 	}
; 2255 : 
; 2256 : 	const int iTop = lua_gettop(L);

	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_gettop
	add	esp, 4
	mov	DWORD PTR _iTop$[ebp], eax

; 2257 : 
; 2258 : 	const bool bRandomGoodies =
; 2259 : 	    sg_kSave.GetFlag(CvWorldBuilderMap::FLAG_RANDOM_GOODIES) ||
; 2260 : 	    (sg_kSave.GetFlag(CvWorldBuilderMap::FLAG_OLD_GOODIE_RULES) && !CvPreGame::loadWBScenario());

	mov	ecx, DWORD PTR _sg_kSave+12224
	and	ecx, 4
	neg	ecx
	sbb	ecx, ecx
	neg	ecx
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN14@AddRandomI
	mov	eax, DWORD PTR _sg_kSave+12224
	and	eax, 8
	neg	eax
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN13@AddRandomI
	call	?loadWBScenario@CvPreGame@@YA_NXZ	; CvPreGame::loadWBScenario
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN14@AddRandomI
$LN13@AddRandomI:
	mov	BYTE PTR tv80[ebp], 0
	jmp	SHORT $LN15@AddRandomI
$LN14@AddRandomI:
	mov	BYTE PTR tv80[ebp], 1
$LN15@AddRandomI:
	mov	al, BYTE PTR tv80[ebp]
	mov	BYTE PTR _bRandomGoodies$[ebp], al

; 2261 : 
; 2262 : 	const bool bRandomResources = sg_kSave.GetFlag(CvWorldBuilderMap::FLAG_RANDOM_RECOURCES);

	mov	ecx, DWORD PTR _sg_kSave+12224
	and	ecx, 2
	neg	ecx
	sbb	ecx, ecx
	neg	ecx
	mov	BYTE PTR _bRandomResources$[ebp], cl

; 2263 : 
; 2264 : 	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	edx, DWORD PTR $T230858[ebp]
	mov	DWORD PTR tv91[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv91[ebp], eax
	mov	ecx, DWORD PTR tv91[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv91[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pkScriptSystem$[ebp], eax

; 2265 : 	if(pkScriptSystem != NULL && (bRandomResources || bRandomGoodies))

	cmp	DWORD PTR _pkScriptSystem$[ebp], 0
	je	$LN9@AddRandomI
	movzx	ecx, BYTE PTR _bRandomResources$[ebp]
	test	ecx, ecx
	jne	SHORT $LN8@AddRandomI
	movzx	edx, BYTE PTR _bRandomGoodies$[ebp]
	test	edx, edx
	je	$LN9@AddRandomI
$LN8@AddRandomI:

; 2266 : 	{
; 2267 : 		const char* szLuaFile = "WorldBuilderRandomItems.lua";

	mov	DWORD PTR _szLuaFile$225054[ebp], OFFSET ??_C@_0BM@CLNPACCC@WorldBuilderRandomItems?4lua?$AA@

; 2268 : 		const bool bLoadedMapGenerator = pkScriptSystem->LoadFile(L, szLuaFile);

	mov	eax, DWORD PTR _szLuaFile$225054[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pkScriptSystem$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pkScriptSystem$[ebp]
	mov	edx, DWORD PTR [eax+8]
	call	edx
	mov	BYTE PTR _bLoadedMapGenerator$225056[ebp], al

; 2269 : 		FAssertMsg1(bLoadedMapGenerator, "Failed to load %s", szLuaFile);
; 2270 : 		if(bLoadedMapGenerator)

	movzx	eax, BYTE PTR _bLoadedMapGenerator$225056[ebp]
	test	eax, eax
	je	$LN9@AddRandomI

; 2271 : 		{
; 2272 : 			if(bRandomGoodies)

	movzx	ecx, BYTE PTR _bRandomGoodies$[ebp]
	test	ecx, ecx
	je	SHORT $LN6@AddRandomI

; 2273 : 			{
; 2274 : 				const char* szGoodiesFunction = "AddGoodies";

	mov	DWORD PTR _szGoodiesFunction$225059[ebp], OFFSET ??_C@_0L@JNKLPMBD@AddGoodies?$AA@

; 2275 : 				lua_getglobal(L, szGoodiesFunction);

	mov	edx, DWORD PTR _szGoodiesFunction$225059[ebp]
	push	edx
	push	-10002					; ffffd8eeH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_getfield
	add	esp, 12					; 0000000cH

; 2276 : 				if(lua_isfunction(L, -1))

	push	-1
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_type
	add	esp, 8
	cmp	eax, 6
	jne	SHORT $LN6@AddRandomI

; 2277 : 					pkScriptSystem->CallFunction(L, 0, 0);

	push	0
	push	0
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	mov	eax, DWORD PTR _pkScriptSystem$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pkScriptSystem$[ebp]
	mov	eax, DWORD PTR [edx+28]
	call	eax
$LN6@AddRandomI:

; 2278 : 				else
; 2279 : 					FAssertMsg2(0, "Failed to find \"%s\" in %s", szGoodiesFunction, szLuaFile);
; 2280 : 			}
; 2281 : 
; 2282 : 			if(bRandomResources)

	movzx	ecx, BYTE PTR _bRandomResources$[ebp]
	test	ecx, ecx
	je	SHORT $LN9@AddRandomI

; 2283 : 			{
; 2284 : 				const char* szResourcesFunction = "AddResourcesForWorldBuilderMap";

	mov	DWORD PTR _szResourcesFunction$225064[ebp], OFFSET ??_C@_0BP@DNHIPNC@AddResourcesForWorldBuilderMap?$AA@

; 2285 : 				lua_getglobal(L, szResourcesFunction);

	mov	edx, DWORD PTR _szResourcesFunction$225064[ebp]
	push	edx
	push	-10002					; ffffd8eeH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_getfield
	add	esp, 12					; 0000000cH

; 2286 : 				if(lua_isfunction(L, -1))

	push	-1
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_type
	add	esp, 8
	cmp	eax, 6
	jne	SHORT $LN9@AddRandomI

; 2287 : 					pkScriptSystem->CallFunction(L, 0, 0);

	push	0
	push	0
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	mov	eax, DWORD PTR _pkScriptSystem$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pkScriptSystem$[ebp]
	mov	eax, DWORD PTR [edx+28]
	call	eax
$LN9@AddRandomI:

; 2288 : 				else
; 2289 : 					FAssertMsg2(0, "Failed to find \"%s\" in %s", szResourcesFunction, szLuaFile);
; 2290 : 			}
; 2291 : 		}
; 2292 : 	}
; 2293 : 
; 2294 : 	lua_settop(L, iTop);

	mov	ecx, DWORD PTR _iTop$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_settop
	add	esp, 8

; 2295 : 
; 2296 : 	return 0;

	xor	eax, eax
$LN11@AddRandomI:

; 2297 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AddRandomItems@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z ENDP ; CvWorldBuilderMapLoader::AddRandomItems
_TEXT	ENDS
PUBLIC	?ScatterResources@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z ; CvWorldBuilderMapLoader::ScatterResources
; Function compile flags: /Odtp
;	COMDAT ?ScatterResources@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z
_TEXT	SEGMENT
tv74 = -20						; size = 4
$T230864 = -16						; size = 4
_bLoadedMapGenerator$225075 = -9			; size = 1
_pkScriptSystem$ = -8					; size = 4
_iTop$ = -4						; size = 4
_L$ = 8							; size = 4
?ScatterResources@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z PROC ; CvWorldBuilderMapLoader::ScatterResources, COMDAT

; 2300 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 2301 : 	if(L == NULL)

	cmp	DWORD PTR _L$[ebp], 0
	jne	SHORT $LN5@ScatterRes

; 2302 : 	{
; 2303 : 		FAssertMsg(L, "Seriously, you really need a lua state for this.");
; 2304 : 		return 0;

	xor	eax, eax
	jmp	$LN6@ScatterRes
$LN5@ScatterRes:

; 2305 : 	}
; 2306 : 
; 2307 : 	const int iTop = lua_gettop(L);

	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_gettop
	add	esp, 4
	mov	DWORD PTR _iTop$[ebp], eax

; 2308 : 
; 2309 : 	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR $T230864[ebp]
	mov	DWORD PTR tv74[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv74[ebp], edx
	mov	eax, DWORD PTR tv74[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv74[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pkScriptSystem$[ebp], eax

; 2310 : 	if(pkScriptSystem != NULL)

	cmp	DWORD PTR _pkScriptSystem$[ebp], 0
	je	SHORT $LN4@ScatterRes

; 2311 : 	{
; 2312 : 		const bool bLoadedMapGenerator = pkScriptSystem->LoadFile(L, "WorldBuilderRandomItems.lua");

	push	OFFSET ??_C@_0BM@CLNPACCC@WorldBuilderRandomItems?4lua?$AA@
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pkScriptSystem$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pkScriptSystem$[ebp]
	mov	edx, DWORD PTR [eax+8]
	call	edx
	mov	BYTE PTR _bLoadedMapGenerator$225075[ebp], al

; 2313 : 		FAssertMsg(bLoadedMapGenerator, "Failed to load WorldBuilderRandomItems.lua");
; 2314 : 		if(bLoadedMapGenerator)

	movzx	eax, BYTE PTR _bLoadedMapGenerator$225075[ebp]
	test	eax, eax
	je	SHORT $LN4@ScatterRes

; 2315 : 		{
; 2316 : 			lua_getglobal(L, "AddResourcesForWorldBuilderMap");

	push	OFFSET ??_C@_0BP@DNHIPNC@AddResourcesForWorldBuilderMap?$AA@
	push	-10002					; ffffd8eeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_getfield
	add	esp, 12					; 0000000cH

; 2317 : 			if(lua_isfunction(L, -1))

	push	-1
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_type
	add	esp, 8
	cmp	eax, 6
	jne	SHORT $LN4@ScatterRes

; 2318 : 				pkScriptSystem->CallFunction(L, 0, 0);

	push	0
	push	0
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkScriptSystem$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pkScriptSystem$[ebp]
	mov	eax, DWORD PTR [edx+28]
	call	eax
$LN4@ScatterRes:

; 2319 : 			else
; 2320 : 				FAssertMsg(0, "Failed to find \"AddResourcesForWorldBuilderMap\" in WorldBuilderRandomItems.lua");
; 2321 : 		}
; 2322 : 	}
; 2323 : 
; 2324 : 	lua_settop(L, iTop);

	mov	ecx, DWORD PTR _iTop$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_settop
	add	esp, 8

; 2325 : 
; 2326 : 	return 0;

	xor	eax, eax
$LN6@ScatterRes:

; 2327 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ScatterResources@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z ENDP ; CvWorldBuilderMapLoader::ScatterResources
_TEXT	ENDS
PUBLIC	?ScatterGoodies@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z ; CvWorldBuilderMapLoader::ScatterGoodies
; Function compile flags: /Odtp
;	COMDAT ?ScatterGoodies@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z
_TEXT	SEGMENT
tv74 = -20						; size = 4
$T230870 = -16						; size = 4
_bLoadedMapGenerator$225086 = -9			; size = 1
_pkScriptSystem$ = -8					; size = 4
_iTop$ = -4						; size = 4
_L$ = 8							; size = 4
?ScatterGoodies@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z PROC ; CvWorldBuilderMapLoader::ScatterGoodies, COMDAT

; 2330 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 2331 : 	if(L == NULL)

	cmp	DWORD PTR _L$[ebp], 0
	jne	SHORT $LN5@ScatterGoo

; 2332 : 	{
; 2333 : 		FAssertMsg(L, "Seriously, you really need a lua state for this.");
; 2334 : 		return 0;

	xor	eax, eax
	jmp	$LN6@ScatterGoo
$LN5@ScatterGoo:

; 2335 : 	}
; 2336 : 
; 2337 : 	const int iTop = lua_gettop(L);

	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_gettop
	add	esp, 4
	mov	DWORD PTR _iTop$[ebp], eax

; 2338 : 
; 2339 : 	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR $T230870[ebp]
	mov	DWORD PTR tv74[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv74[ebp], edx
	mov	eax, DWORD PTR tv74[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv74[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pkScriptSystem$[ebp], eax

; 2340 : 	if(pkScriptSystem != NULL)

	cmp	DWORD PTR _pkScriptSystem$[ebp], 0
	je	SHORT $LN4@ScatterGoo

; 2341 : 	{
; 2342 : 		const bool bLoadedMapGenerator = pkScriptSystem->LoadFile(L, "WorldBuilderRandomItems.lua");

	push	OFFSET ??_C@_0BM@CLNPACCC@WorldBuilderRandomItems?4lua?$AA@
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pkScriptSystem$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pkScriptSystem$[ebp]
	mov	edx, DWORD PTR [eax+8]
	call	edx
	mov	BYTE PTR _bLoadedMapGenerator$225086[ebp], al

; 2343 : 		FAssertMsg(bLoadedMapGenerator, "Failed to load WorldBuilderRandomItems.lua");
; 2344 : 		if(bLoadedMapGenerator)

	movzx	eax, BYTE PTR _bLoadedMapGenerator$225086[ebp]
	test	eax, eax
	je	SHORT $LN4@ScatterGoo

; 2345 : 		{
; 2346 : 			lua_getglobal(L, "AddGoodies");

	push	OFFSET ??_C@_0L@JNKLPMBD@AddGoodies?$AA@
	push	-10002					; ffffd8eeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_getfield
	add	esp, 12					; 0000000cH

; 2347 : 			if(lua_isfunction(L, -1))

	push	-1
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_type
	add	esp, 8
	cmp	eax, 6
	jne	SHORT $LN4@ScatterGoo

; 2348 : 				pkScriptSystem->CallFunction(L, 0, 0);

	push	0
	push	0
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkScriptSystem$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pkScriptSystem$[ebp]
	mov	eax, DWORD PTR [edx+28]
	call	eax
$LN4@ScatterGoo:

; 2349 : 			else
; 2350 : 				FAssertMsg(0, "Failed to find \"AddGoodies\" in WorldBuilderRandomItems.lua");
; 2351 : 		}
; 2352 : 	}
; 2353 : 
; 2354 : 	lua_settop(L, iTop);

	mov	ecx, DWORD PTR _iTop$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_settop
	add	esp, 8

; 2355 : 
; 2356 : 	return 0;

	xor	eax, eax
$LN6@ScatterGoo:

; 2357 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ScatterGoodies@CvWorldBuilderMapLoader@@SAHPAUlua_State@@@Z ENDP ; CvWorldBuilderMapLoader::ScatterGoodies
_TEXT	ENDS
PUBLIC	??1?$BaseVector@PAVCvPlayer@@$0A@@@QAE@XZ	; BaseVector<CvPlayer *,0>::~BaseVector<CvPlayer *,0>
PUBLIC	??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ ; `string'
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ DB 'd:\sources\'
	DB	'lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\FF'
	DB	'astVector.h', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAE@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAE@I@Z$0
__ehfuncinfo$??0?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAE@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAE@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T230887 = -20						; size = 4
_pRet$230883 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_uiStartingMaxSize$ = 8					; size = 4
??0?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAE@I@Z PROC ; FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>::FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 309  : 	FFastVector(unsigned int uiStartingMaxSize = 0)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAE@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 310  : 	{
; 311  : #ifdef BREAK_ON_REPEATED_RESIZE
; 312  : 		m_nResizeTimes = 0;
; 313  : #endif
; 314  : 		m_pData = Alloc(uiStartingMaxSize);

	cmp	DWORD PTR _uiStartingMaxSize$[ebp], 0
	jbe	SHORT $LN6@FFastVecto
	push	85					; 00000055H
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR _uiStartingMaxSize$[ebp]
	shl	eax, 2
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$230883[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiStartingMaxSize$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _pRet$230883[ebp]
	mov	DWORD PTR $T230887[ebp], eax
	jmp	SHORT $LN7@FFastVecto
$LN6@FFastVecto:
	mov	DWORD PTR $T230887[ebp], 0
$LN7@FFastVecto:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T230887[ebp]
	mov	DWORD PTR [ecx], edx

; 315  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAE@I@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@PAVCvPlayer@@$0A@@@QAE@XZ ; BaseVector<CvPlayer *,0>::~BaseVector<CvPlayer *,0>
__ehhandler$??0?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAE@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAE@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAE@I@Z ENDP ; FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>::FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAE@XZ$0
__ehfuncinfo$??1?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T230922 = -24						; size = 4
$T230921 = -20						; size = 4
_i$230914 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAE@XZ PROC ; FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>::~FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 316  : 	~FFastVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 317  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T230922[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T230921[ebp], eax
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN4@FFastVecto@2
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN4@FFastVecto@2
	mov	DWORD PTR _i$230914[ebp], 0
	jmp	SHORT $LN9@FFastVecto@2
$LN8@FFastVecto@2:
	mov	eax, DWORD PTR _i$230914[ebp]
	add	eax, 1
	mov	DWORD PTR _i$230914[ebp], eax
$LN9@FFastVecto@2:
	mov	ecx, DWORD PTR _i$230914[ebp]
	cmp	ecx, DWORD PTR $T230922[ebp]
	jae	SHORT $LN4@FFastVecto@2
	jmp	SHORT $LN8@FFastVecto@2
$LN4@FFastVecto@2:
	mov	edx, DWORD PTR $T230921[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4

; 318  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@PAVCvPlayer@@$0A@@@QAE@XZ ; BaseVector<CvPlayer *,0>::~BaseVector<CvPlayer *,0>
__ehhandler$??1?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAE@XZ ENDP ; FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>::~FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>
PUBLIC	?GrowSize@?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@IAEXI@Z ; FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>::GrowSize
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAEIABQAVCvPlayer@@@Z
_TEXT	SEGMENT
tv139 = -56						; size = 4
tv130 = -52						; size = 4
_this$ = -48						; size = 4
$T230934 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAEIABQAVCvPlayer@@@Z PROC ; FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>::push_back, COMDAT
; _this$ = ecx

; 376  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN39@push_back

; 378  : 			GrowSize(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@IAEXI@Z ; FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>::GrowSize

; 379  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN39@push_back:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T230934[ebp], eax
	cmp	DWORD PTR $T230934[ebp], 0
	je	SHORT $LN4@push_back
	mov	ecx, DWORD PTR $T230934[ebp]
	mov	edx, DWORD PTR _element$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T230934[ebp]
	mov	DWORD PTR tv130[ebp], ecx
	jmp	SHORT $LN5@push_back
$LN4@push_back:
	mov	DWORD PTR tv130[ebp], 0
$LN5@push_back:

; 380  : 		return m_uiCurrSize++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR tv139[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR tv139[ebp]

; 381  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@QAEIABQAVCvPlayer@@@Z ENDP ; FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>::push_back
_TEXT	ENDS
PUBLIC	?Release@FStringW@@QAEXXZ			; FStringW::Release
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fstringw.inl
;	COMDAT ??1FStringW@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
??1FStringW@@QAE@XZ PROC				; FStringW::~FStringW, COMDAT
; _this$ = ecx

; 151  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 152  : 	Release();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Release@FStringW@@QAEXXZ		; FStringW::Release

; 153  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1FStringW@@QAE@XZ ENDP				; FStringW::~FStringW
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?erase@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE?AV?$_Vector_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@V?$_Vector_const_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
$T231147 = -64						; size = 4
$T231129 = -60						; size = 4
$T231128 = -56						; size = 4
$T231112 = -52						; size = 4
__Cat$231136 = -46					; size = 1
$T231134 = -45						; size = 1
$T231086 = -44						; size = 4
$T231085 = -40						; size = 4
$T231084 = -36						; size = 4
$T231067 = -30						; size = 1
$T231066 = -29						; size = 1
$T231065 = -28						; size = 4
$T231064 = -24						; size = 4
__Cat$231074 = -16					; size = 1
$T231072 = -15						; size = 1
$T231071 = -14						; size = 1
$T231070 = -13						; size = 1
__Ptr$225462 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE?AV?$_Vector_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@V?$_Vector_const_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@0@Z PROC ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	$LN1@erase

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T231086[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T231085[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T231084[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T231070[ebp], cl
	mov	dl, BYTE PTR __Cat$231074[ebp]
	mov	BYTE PTR $T231071[ebp], dl
	mov	al, BYTE PTR $T231070[ebp]
	mov	BYTE PTR $T231067[ebp], al
	mov	cl, BYTE PTR $T231072[ebp]
	mov	BYTE PTR $T231066[ebp], cl
	mov	edx, DWORD PTR $T231086[ebp]
	mov	DWORD PTR $T231065[ebp], edx
	mov	eax, DWORD PTR $T231084[ebp]
	mov	DWORD PTR $T231064[ebp], eax
	jmp	SHORT $LN28@erase
$LN27@erase:
	mov	ecx, DWORD PTR $T231065[ebp]
	add	ecx, 4
	mov	DWORD PTR $T231065[ebp], ecx
	mov	edx, DWORD PTR $T231064[ebp]
	add	edx, 4
	mov	DWORD PTR $T231064[ebp], edx
$LN28@erase:
	mov	eax, DWORD PTR $T231064[ebp]
	cmp	eax, DWORD PTR $T231085[ebp]
	je	SHORT $LN20@erase
	mov	ecx, DWORD PTR $T231064[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR $T231065[ebp]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN27@erase
$LN20@erase:
	mov	ecx, DWORD PTR $T231065[ebp]
	mov	DWORD PTR __Ptr$225462[ebp], ecx

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T231147[ebp], eax
	mov	ecx, DWORD PTR $T231147[ebp]
	mov	DWORD PTR $T231129[ebp], ecx
	mov	edx, DWORD PTR __Ptr$225462[ebp]
	mov	DWORD PTR $T231128[ebp], edx
	mov	al, BYTE PTR __Cat$231136[ebp]
	mov	BYTE PTR $T231134[ebp], al
	mov	ecx, DWORD PTR $T231128[ebp]
	mov	DWORD PTR $T231112[ebp], ecx
	jmp	SHORT $LN39@erase
$LN38@erase:
	mov	edx, DWORD PTR $T231112[ebp]
	add	edx, 4
	mov	DWORD PTR $T231112[ebp], edx
$LN39@erase:
	mov	eax, DWORD PTR $T231112[ebp]
	cmp	eax, DWORD PTR $T231129[ebp]
	je	SHORT $LN31@erase
	jmp	SHORT $LN38@erase
$LN31@erase:

; 1049 : 			_Mylast = _Ptr;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Ptr$225462[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN1@erase:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE?AV?$_Vector_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@V?$_Vector_const_iterator@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@2@0@Z ENDP ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::erase
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@PAVCvPlayer@@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@PAVCvPlayer@@$0A@@@QAE@XZ PROC		; BaseVector<CvPlayer *,0>::~BaseVector<CvPlayer *,0>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@PAVCvPlayer@@$0A@@@QAE@XZ ENDP		; BaseVector<CvPlayer *,0>::~BaseVector<CvPlayer *,0>
_TEXT	ENDS
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp
;	COMDAT ?GrowSize@?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@IAEXI@Z
_TEXT	SEGMENT
tv184 = -48						; size = 4
_this$ = -44						; size = 4
$T231194 = -40						; size = 4
$T231193 = -36						; size = 4
_i$231186 = -32						; size = 4
$T231165 = -28						; size = 4
_pRet$231161 = -24					; size = 4
$T231152 = -20						; size = 4
_i$225529 = -16						; size = 4
_uiNewSize$225520 = -12					; size = 4
_nOld$ = -8						; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@IAEXI@Z PROC ; FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>::GrowSize, COMDAT
; _this$ = ecx

; 422  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 423  : 		unsigned int nOld = m_uiCurrMaxSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _nOld$[ebp], ecx

; 424  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jne	SHORT $LN10@GrowSize
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 1
$LN10@GrowSize:

; 425  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiFit$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jb	SHORT $LN9@GrowSize

; 426  : 
; 427  : 			//Try to double size...
; 428  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 1
	mov	DWORD PTR _uiNewSize$225520[ebp], ecx

; 429  : 
; 430  : 			//...on overflow bail and set to exact size
; 431  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiNewSize$225520[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN8@GrowSize

; 432  : 				m_uiCurrMaxSize = uiFit;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 433  : 				break;

	jmp	SHORT $LN9@GrowSize
$LN8@GrowSize:

; 434  : 			}
; 435  : 
; 436  : 			//...otherwise use the doubled size
; 437  : 			m_uiCurrMaxSize = uiNewSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$225520[ebp]
	mov	DWORD PTR [eax+8], ecx

; 438  : 		}

	jmp	SHORT $LN10@GrowSize
$LN9@GrowSize:

; 439  : 
; 440  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T231165[ebp], eax
	cmp	DWORD PTR $T231165[ebp], 0
	jbe	SHORT $LN16@GrowSize
	push	85					; 00000055H
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	ecx, DWORD PTR $T231165[ebp]
	shl	ecx, 2
	push	ecx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$231161[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T231165[ebp]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _pRet$231161[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx
	jmp	SHORT $LN17@GrowSize
$LN16@GrowSize:
	mov	DWORD PTR _pTemp$[ebp], 0
$LN17@GrowSize:

; 441  : 		if (pTemp)

	cmp	DWORD PTR _pTemp$[ebp], 0
	je	$LN7@GrowSize

; 442  : 		{
; 443  : 			if( bPODType ){

	xor	edx, edx
	je	SHORT $LN6@GrowSize

; 444  : 				memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 445  : 			}else{

	jmp	SHORT $LN5@GrowSize
$LN6@GrowSize:

; 446  : 				for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$225529[ebp], 0
	jmp	SHORT $LN4@GrowSize
$LN3@GrowSize:
	mov	edx, DWORD PTR _i$225529[ebp]
	add	edx, 1
	mov	DWORD PTR _i$225529[ebp], edx
$LN4@GrowSize:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$225529[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN5@GrowSize

; 447  : 					new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$225529[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T231152[ebp], ecx
	cmp	DWORD PTR $T231152[ebp], 0
	je	SHORT $LN14@GrowSize
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T231152[ebp]
	mov	edx, DWORD PTR _i$225529[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T231152[ebp]
	mov	DWORD PTR tv184[ebp], ecx
	jmp	SHORT $LN15@GrowSize
$LN14@GrowSize:
	mov	DWORD PTR tv184[ebp], 0
$LN15@GrowSize:
	jmp	SHORT $LN3@GrowSize
$LN5@GrowSize:

; 448  : 			}
; 449  : 			Free(m_pData, m_uiCurrSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T231194[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T231193[ebp], edx
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN23@GrowSize
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN23@GrowSize
	mov	DWORD PTR _i$231186[ebp], 0
	jmp	SHORT $LN28@GrowSize
$LN27@GrowSize:
	mov	edx, DWORD PTR _i$231186[ebp]
	add	edx, 1
	mov	DWORD PTR _i$231186[ebp], edx
$LN28@GrowSize:
	mov	eax, DWORD PTR _i$231186[ebp]
	cmp	eax, DWORD PTR $T231194[ebp]
	jae	SHORT $LN23@GrowSize
	jmp	SHORT $LN27@GrowSize
$LN23@GrowSize:
	mov	ecx, DWORD PTR $T231193[ebp]
	push	ecx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4

; 450  : 			m_pData = pTemp;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], eax

; 451  : 		}
; 452  : 		else

	jmp	SHORT $LN12@GrowSize
$LN7@GrowSize:

; 453  : 		{
; 454  : 			FAssertMsg2(0, "Failed to grow array size from %u to %u", nOld, m_uiCurrMaxSize);
; 455  : 			m_uiCurrMaxSize = nOld;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nOld$[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN12@GrowSize:

; 456  : 		}
; 457  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FFastVector@PAVCvPlayer@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvPlayer@@$0A@@@@@IAEXI@Z ENDP ; FFastVector<CvPlayer *,0,0,0,BaseVector<CvPlayer *,0>::FDefaultFastVectorAllocator>::GrowSize
_TEXT	ENDS
PUBLIC	__TI3?AVout_of_range@std@@
PUBLIC	??_7out_of_range@std@@6B@			; std::out_of_range::`vftable'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_C@_0BL@HMFHJKFH@invalid?5bitset?$DMN?$DO?5position?$AA@ ; `string'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??1out_of_range@std@@UAE@XZ			; std::out_of_range::~out_of_range
PUBLIC	__CTA3?AVout_of_range@std@@
PUBLIC	__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVout_of_range@std@@@8			; std::out_of_range `RTTI Type Descriptor'
PUBLIC	??0out_of_range@std@@QAE@ABV01@@Z		; std::out_of_range::out_of_range
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
EXTRN	??_Eout_of_range@std@@UAEPAXI@Z:PROC		; std::out_of_range::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT
??_R0?AVout_of_range@std@@@8 DD FLAT:??_7type_info@@6B@	; std::out_of_range `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVout_of_range@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0out_of_range@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVout_of_range@std@@
xdata$x	SEGMENT
__CTA3?AVout_of_range@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVout_of_range@std@@
xdata$x	SEGMENT
__TI3?AVout_of_range@std@@ DD 00H
	DD	FLAT:??1out_of_range@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVout_of_range@std@@
xdata$x	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT
??_7out_of_range@std@@6B@ DD FLAT:??_Eout_of_range@std@@UAEPAXI@Z ; std::out_of_range::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_Elogic_error@std@@UAEPAXI@Z ; std::logic_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BL@HMFHJKFH@invalid?5bitset?$DMN?$DO?5position?$AA@
CONST	SEGMENT
??_C@_0BL@HMFHJKFH@invalid?5bitset?$DMN?$DO?5position?$AA@ DB 'invalid bi'
	DB	'tset<N> position', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xran@?$bitset@$0BAA@@std@@ABEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xran@?$bitset@$0BAA@@std@@ABEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xran@?$bitset@$0BAA@@std@@ABEXXZ$2
__ehfuncinfo$?_Xran@?$bitset@$0BAA@@std@@ABEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xran@?$bitset@$0BAA@@std@@ABEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\bitset
xdata$x	ENDS
;	COMDAT ?_Xran@?$bitset@$0BAA@@std@@ABEXXZ
_TEXT	SEGMENT
_this$ = -84						; size = 4
$T231199 = -80						; size = 28
$T231198 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xran@?$bitset@$0BAA@@std@@ABEXXZ PROC			; std::bitset<256>::_Xran, COMDAT
; _this$ = ecx

; 420  : 		{	// report bit index out of range

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xran@?$bitset@$0BAA@@std@@ABEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 421  : 		_THROW(out_of_range, "invalid bitset<N> position");

	push	OFFSET ??_C@_0BL@HMFHJKFH@invalid?5bitset?$DMN?$DO?5position?$AA@
	lea	ecx, DWORD PTR $T231199[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T231198[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T231198[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T231199[ebp]
	push	eax
	lea	ecx, DWORD PTR $T231198[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T231198[ebp], OFFSET ??_7out_of_range@std@@6B@
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	ecx, DWORD PTR $T231198[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T231199[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xran:

; 422  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xran@?$bitset@$0BAA@@std@@ABEXXZ$0:
	lea	ecx, DWORD PTR $T231199[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xran@?$bitset@$0BAA@@std@@ABEXXZ$2:
	lea	ecx, DWORD PTR $T231198[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xran@?$bitset@$0BAA@@std@@ABEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xran@?$bitset@$0BAA@@std@@ABEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xran@?$bitset@$0BAA@@std@@ABEXXZ ENDP			; std::bitset<256>::_Xran
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 34   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 36   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1out_of_range@std@@UAE@XZ PROC			; std::out_of_range::~out_of_range, COMDAT
; _this$ = ecx

; 133  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7out_of_range@std@@6B@

; 134  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1out_of_range@std@@UAE@XZ ENDP			; std::out_of_range::~out_of_range
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gout_of_range@std@@UAEPAXI@Z PROC			; std::out_of_range::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7out_of_range@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	edx, DWORD PTR ___flags$[ebp]
	and	edx, 1
	je	SHORT $LN1@scalar@2
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gout_of_range@std@@UAEPAXI@Z ENDP			; std::out_of_range::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xran@?$bitset@$0CAA@@std@@ABEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xran@?$bitset@$0CAA@@std@@ABEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xran@?$bitset@$0CAA@@std@@ABEXXZ$2
__ehfuncinfo$?_Xran@?$bitset@$0CAA@@std@@ABEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xran@?$bitset@$0CAA@@std@@ABEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\bitset
xdata$x	ENDS
;	COMDAT ?_Xran@?$bitset@$0CAA@@std@@ABEXXZ
_TEXT	SEGMENT
_this$ = -84						; size = 4
$T231243 = -80						; size = 28
$T231242 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xran@?$bitset@$0CAA@@std@@ABEXXZ PROC			; std::bitset<512>::_Xran, COMDAT
; _this$ = ecx

; 420  : 		{	// report bit index out of range

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xran@?$bitset@$0CAA@@std@@ABEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 421  : 		_THROW(out_of_range, "invalid bitset<N> position");

	push	OFFSET ??_C@_0BL@HMFHJKFH@invalid?5bitset?$DMN?$DO?5position?$AA@
	lea	ecx, DWORD PTR $T231243[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T231242[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T231242[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T231243[ebp]
	push	eax
	lea	ecx, DWORD PTR $T231242[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T231242[ebp], OFFSET ??_7out_of_range@std@@6B@
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	ecx, DWORD PTR $T231242[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T231243[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xran@2:

; 422  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xran@?$bitset@$0CAA@@std@@ABEXXZ$0:
	lea	ecx, DWORD PTR $T231243[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xran@?$bitset@$0CAA@@std@@ABEXXZ$2:
	lea	ecx, DWORD PTR $T231242[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xran@?$bitset@$0CAA@@std@@ABEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xran@?$bitset@$0CAA@@std@@ABEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xran@?$bitset@$0CAA@@std@@ABEXXZ ENDP			; std::bitset<512>::_Xran
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fstringw.inl
;	COMDAT ?Release@FStringW@@QAEXXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T231278 = -12						; size = 4
$T231273 = -8						; size = 4
$T231272 = -4						; size = 4
?Release@FStringW@@QAEXXZ PROC				; FStringW::Release, COMDAT
; _this$ = ecx

; 1008 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1009 : 	Release( GetData() );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 12					; 0000000cH
	mov	DWORD PTR $T231273[ebp], ecx
	je	SHORT $LN6@Release
	call	?FStringW_GetStringInitData@@YAPAUFStringWData@FStringW@@XZ ; FStringW_GetStringInitData
	cmp	DWORD PTR $T231273[ebp], eax
	je	SHORT $LN6@Release
	mov	edx, DWORD PTR $T231273[ebp]
	movzx	eax, WORD PTR [edx+10]
	test	eax, eax
	jne	SHORT $LN6@Release
	mov	ecx, DWORD PTR $T231273[ebp]
	mov	DWORD PTR $T231272[ebp], ecx
	mov	edx, DWORD PTR $T231272[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@Release:

; 1010 : 	Init();

	call	?FStringW_GetStringInitData@@YAPAUFStringWData@FStringW@@XZ ; FStringW_GetStringInitData
	mov	DWORD PTR $T231278[ebp], eax
	mov	eax, DWORD PTR $T231278[ebp]
	add	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 1011 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Release@FStringW@@QAEXXZ ENDP				; FStringW::Release
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?SetFixedBuffer@FStringW@@QAEXPAUFStringWData@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
_pkData$ = 8						; size = 4
?SetFixedBuffer@FStringW@@QAEXPAUFStringWData@1@@Z PROC	; FStringW::SetFixedBuffer, COMDAT
; _this$ = ecx

; 1033 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1034 : 	assert( pkData != NULL );
; 1035 : 	if(!pkData) return;

	cmp	DWORD PTR _pkData$[ebp], 0
	jne	SHORT $LN1@SetFixedBu
	jmp	SHORT $LN2@SetFixedBu
$LN1@SetFixedBu:

; 1036 : 	assert( pkData->m_bFixed == 1 );
; 1037 : 	assert( pkData->m_iAllocLength > 0 );
; 1038 : 	Release();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Release@FStringW@@QAEXXZ		; FStringW::Release

; 1039 : 	m_pszString = pkData->StringData();

	mov	eax, DWORD PTR _pkData$[ebp]
	add	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$LN2@SetFixedBu:

; 1040 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetFixedBuffer@FStringW@@QAEXPAUFStringWData@1@@Z ENDP	; FStringW::SetFixedBuffer
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0out_of_range@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0out_of_range@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0out_of_range@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0out_of_range@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV01@@Z PROC			; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0out_of_range@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7out_of_range@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0out_of_range@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0out_of_range@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0out_of_range@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0out_of_range@std@@QAE@ABV01@@Z ENDP			; std::out_of_range::out_of_range
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT

; 298  : {

	push	ebp
	mov	ebp, esp

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	DWORD PTR _p$[ebp], 0
	jl	SHORT $LN1@teamType
	cmp	DWORD PTR _p$[ebp], 64			; 00000040H
	jge	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	eax, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN2@teamType
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1
$LN2@teamType:

; 302  : }

	pop	ebp
	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T231345 = -4						; size = 4
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ PROC		; CvPlot::getPlotCity, COMDAT
; _this$ = ecx

; 532  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 533  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+104], 0
	jl	SHORT $LN1@getPlotCit
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+104], 64			; 00000040H
	jge	SHORT $LN1@getPlotCit

; 534  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T231345[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	mov	ecx, DWORD PTR $T231345[ebp]
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	jmp	SHORT $LN2@getPlotCit
$LN1@getPlotCit:

; 535  : 
; 536  : 		return NULL;

	xor	eax, eax
$LN2@getPlotCit:

; 537  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ ENDP		; CvPlot::getPlotCity
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
_TEXT	ENDS
;	COMDAT ?coordRange@@YAHHH_N@Z
_TEXT	SEGMENT
_iCoord$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?coordRange@@YAHHH_N@Z PROC				; coordRange, COMDAT

; 87   : {

	push	ebp
	mov	ebp, esp

; 88   : 	if(bWrap)

	movzx	eax, BYTE PTR _bWrap$[ebp]
	test	eax, eax
	je	SHORT $LN4@coordRange

; 89   : 	{
; 90   : 		if(iCoord < 0)

	cmp	DWORD PTR _iCoord$[ebp], 0
	jge	SHORT $LN3@coordRange

; 91   : 		{
; 92   : 			return (iRange + (iCoord % iRange));

	mov	eax, DWORD PTR _iCoord$[ebp]
	cdq
	idiv	DWORD PTR _iRange$[ebp]
	add	edx, DWORD PTR _iRange$[ebp]
	mov	eax, edx
	jmp	SHORT $LN5@coordRange
	jmp	SHORT $LN4@coordRange
$LN3@coordRange:

; 93   : 		}
; 94   : 		else if(iCoord >= iRange)

	mov	ecx, DWORD PTR _iCoord$[ebp]
	cmp	ecx, DWORD PTR _iRange$[ebp]
	jl	SHORT $LN4@coordRange

; 95   : 		{
; 96   : 			return (iCoord % iRange);

	mov	eax, DWORD PTR _iCoord$[ebp]
	cdq
	idiv	DWORD PTR _iRange$[ebp]
	mov	eax, edx
	jmp	SHORT $LN5@coordRange
$LN4@coordRange:

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;

	mov	eax, DWORD PTR _iCoord$[ebp]
$LN5@coordRange:

; 101  : }

	pop	ebp
	ret	0
?coordRange@@YAHHH_N@Z ENDP				; coordRange
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
tv72 = -16						; size = 4
_this$ = -12						; size = 4
$T231359 = -8						; size = 4
$T231355 = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	cmp	DWORD PTR _iX$[ebp], 0
	jl	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T231355[ebp], ecx
	mov	edx, DWORD PTR _iX$[ebp]
	cmp	edx, DWORD PTR $T231355[ebp]
	jge	SHORT $LN3@isPlot
	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T231359[ebp], ecx
	mov	edx, DWORD PTR _iY$[ebp]
	cmp	edx, DWORD PTR $T231359[ebp]
	jge	SHORT $LN3@isPlot
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN4@isPlot
$LN3@isPlot:
	mov	DWORD PTR tv72[ebp], 0
$LN4@isPlot:
	mov	eax, DWORD PTR tv72[ebp]

; 161  : #endif
; 162  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
EXTRN	_atexit:PROC
EXTRN	??0CvWorldBuilderMap@@QAE@XZ:PROC		; CvWorldBuilderMap::CvWorldBuilderMap
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvworldbuildermaploader.cpp
;	COMDAT ??__Esg_kSave@@YAXXZ
text$yc	SEGMENT
??__Esg_kSave@@YAXXZ PROC				; `dynamic initializer for 'sg_kSave'', COMDAT

; 24   : static CvWorldBuilderMap sg_kSave;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET _sg_kSave
	call	??0CvWorldBuilderMap@@QAE@XZ		; CvWorldBuilderMap::CvWorldBuilderMap
	push	OFFSET ??__Fsg_kSave@@YAXXZ		; `dynamic atexit destructor for 'sg_kSave''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__Esg_kSave@@YAXXZ ENDP				; `dynamic initializer for 'sg_kSave''
text$yc	ENDS
PUBLIC	??0CvWorldBuilderMapLoaderMapInfo@@QAE@XZ	; CvWorldBuilderMapLoaderMapInfo::CvWorldBuilderMapLoaderMapInfo
; Function compile flags: /Odtp
;	COMDAT ??__Esg_kMapInfo@@YAXXZ
text$yc	SEGMENT
??__Esg_kMapInfo@@YAXXZ PROC				; `dynamic initializer for 'sg_kMapInfo'', COMDAT

; 25   : static CvWorldBuilderMapLoaderMapInfo sg_kMapInfo;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET _sg_kMapInfo
	call	??0CvWorldBuilderMapLoaderMapInfo@@QAE@XZ ; CvWorldBuilderMapLoaderMapInfo::CvWorldBuilderMapLoaderMapInfo
	pop	ebp
	ret	0
??__Esg_kMapInfo@@YAXXZ ENDP				; `dynamic initializer for 'sg_kMapInfo''
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstructs.h
text$yc	ENDS
;	COMDAT ??0CvWorldBuilderMapLoaderMapInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvWorldBuilderMapLoaderMapInfo@@QAE@XZ PROC		; CvWorldBuilderMapLoaderMapInfo::CvWorldBuilderMapLoaderMapInfo, COMDAT
; _this$ = ecx

; 170  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+24], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+25], 0

; 171  : 
; 172  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvWorldBuilderMapLoaderMapInfo@@QAE@XZ ENDP		; CvWorldBuilderMapLoaderMapInfo::CvWorldBuilderMapLoaderMapInfo
_TEXT	ENDS
EXTRN	??0CvWorldBuilderMapTypeDesc@@QAE@XZ:PROC	; CvWorldBuilderMapTypeDesc::CvWorldBuilderMapTypeDesc
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvworldbuildermaploader.cpp
;	COMDAT ??__Esg_kMapTypeDesc@@YAXXZ
text$yc	SEGMENT
??__Esg_kMapTypeDesc@@YAXXZ PROC			; `dynamic initializer for 'sg_kMapTypeDesc'', COMDAT

; 26   : static CvWorldBuilderMapTypeDesc sg_kMapTypeDesc;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET _sg_kMapTypeDesc
	call	??0CvWorldBuilderMapTypeDesc@@QAE@XZ	; CvWorldBuilderMapTypeDesc::CvWorldBuilderMapTypeDesc
	push	OFFSET ??__Fsg_kMapTypeDesc@@YAXXZ	; `dynamic atexit destructor for 'sg_kMapTypeDesc''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__Esg_kMapTypeDesc@@YAXXZ ENDP			; `dynamic initializer for 'sg_kMapTypeDesc''
; Function compile flags: /Odtp
text$yc	ENDS
;	COMDAT ??__Esg_kTempMap@@YAXXZ
text$yc	SEGMENT
??__Esg_kTempMap@@YAXXZ PROC				; `dynamic initializer for 'sg_kTempMap'', COMDAT

; 2020 : static CvWorldBuilderMap sg_kTempMap;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET _sg_kTempMap
	call	??0CvWorldBuilderMap@@QAE@XZ		; CvWorldBuilderMap::CvWorldBuilderMap
	push	OFFSET ??__Fsg_kTempMap@@YAXXZ		; `dynamic atexit destructor for 'sg_kTempMap''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__Esg_kTempMap@@YAXXZ ENDP				; `dynamic initializer for 'sg_kTempMap''
text$yc	ENDS
EXTRN	??1CvWorldBuilderMap@@QAE@XZ:PROC		; CvWorldBuilderMap::~CvWorldBuilderMap
; Function compile flags: /Odtp
;	COMDAT ??__Fsg_kSave@@YAXXZ
text$yd	SEGMENT
??__Fsg_kSave@@YAXXZ PROC				; `dynamic atexit destructor for 'sg_kSave'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET _sg_kSave
	call	??1CvWorldBuilderMap@@QAE@XZ		; CvWorldBuilderMap::~CvWorldBuilderMap
	pop	ebp
	ret	0
??__Fsg_kSave@@YAXXZ ENDP				; `dynamic atexit destructor for 'sg_kSave''
text$yd	ENDS
PUBLIC	??1CvWorldBuilderMapTypeDesc@@QAE@XZ		; CvWorldBuilderMapTypeDesc::~CvWorldBuilderMapTypeDesc
; Function compile flags: /Odtp
;	COMDAT ??__Fsg_kMapTypeDesc@@YAXXZ
text$yd	SEGMENT
??__Fsg_kMapTypeDesc@@YAXXZ PROC			; `dynamic atexit destructor for 'sg_kMapTypeDesc'', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 324				; 00000144H
	mov	ecx, OFFSET _sg_kMapTypeDesc
	call	??1CvWorldBuilderMapTypeDesc@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??__Fsg_kMapTypeDesc@@YAXXZ ENDP			; `dynamic atexit destructor for 'sg_kMapTypeDesc''
text$yd	ENDS
PUBLIC	??1?$_Vector_val@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::~_Vector_val<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >
PUBLIC	??1TypeMap@CvWorldBuilderMapTypeDesc@@QAE@XZ	; CvWorldBuilderMapTypeDesc::TypeMap::~TypeMap
PUBLIC	?_Tidy@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@IAEXXZ ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CvWorldBuilderMapTypeDesc@@QAE@XZ DD 019930522H
	DD	013H
	DD	FLAT:__unwindtable$??1CvWorldBuilderMapTypeDesc@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvWorldBuilderMapTypeDesc@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvWorldBuilderMapTypeDesc@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvWorldBuilderMapTypeDesc@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvWorldBuilderMapTypeDesc@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvWorldBuilderMapTypeDesc@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvWorldBuilderMapTypeDesc@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvWorldBuilderMapTypeDesc@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvWorldBuilderMapTypeDesc@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvWorldBuilderMapTypeDesc@@QAE@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??1CvWorldBuilderMapTypeDesc@@QAE@XZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$??1CvWorldBuilderMapTypeDesc@@QAE@XZ$11
	DD	07H
	DD	FLAT:__unwindfunclet$??1CvWorldBuilderMapTypeDesc@@QAE@XZ$14
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvWorldBuilderMapTypeDesc@@QAE@XZ$17
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvWorldBuilderMapTypeDesc@@QAE@XZ$20
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvWorldBuilderMapTypeDesc@@QAE@XZ$23
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvWorldBuilderMapTypeDesc@@QAE@XZ$26
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvWorldBuilderMapTypeDesc@@QAE@XZ$29
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvWorldBuilderMapTypeDesc@@QAE@XZ$32
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvWorldBuilderMapTypeDesc@@QAE@XZ$35
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvWorldBuilderMapTypeDesc@@QAE@XZ$38
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1CvWorldBuilderMapTypeDesc@@QAE@XZ
_TEXT	SEGMENT
_this$ = -372						; size = 4
$T233153 = -336						; size = 4
$T233057 = -300						; size = 4
$T232961 = -264						; size = 4
$T232865 = -228						; size = 4
$T232769 = -192						; size = 4
$T232673 = -156						; size = 4
$T232577 = -120						; size = 4
$T232481 = -84						; size = 4
$T232385 = -48						; size = 4
__$EHRec$ = -12						; size = 12
??1CvWorldBuilderMapTypeDesc@@QAE@XZ PROC		; CvWorldBuilderMapTypeDesc::~CvWorldBuilderMapTypeDesc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvWorldBuilderMapTypeDesc@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 360				; 00000168H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 8
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 144				; 00000090H
	mov	DWORD PTR $T232385[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	mov	ecx, DWORD PTR $T232385[ebp]
	call	?_Tidy@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@IAEXXZ ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 128				; 00000080H
	mov	DWORD PTR $T232481[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	ecx, DWORD PTR $T232481[ebp]
	call	?_Tidy@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@IAEXXZ ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 112				; 00000070H
	mov	DWORD PTR $T232577[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	mov	ecx, DWORD PTR $T232577[ebp]
	call	?_Tidy@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@IAEXXZ ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 96					; 00000060H
	mov	DWORD PTR $T232673[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	mov	ecx, DWORD PTR $T232673[ebp]
	call	?_Tidy@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@IAEXXZ ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	mov	DWORD PTR $T232769[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH
	mov	ecx, DWORD PTR $T232769[ebp]
	call	?_Tidy@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@IAEXXZ ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 64					; 00000040H
	mov	DWORD PTR $T232865[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH
	mov	ecx, DWORD PTR $T232865[ebp]
	call	?_Tidy@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@IAEXXZ ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 48					; 00000030H
	mov	DWORD PTR $T232961[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 15		; 0000000fH
	mov	ecx, DWORD PTR $T232961[ebp]
	call	?_Tidy@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@IAEXXZ ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	mov	DWORD PTR $T233057[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 16		; 00000010H
	mov	ecx, DWORD PTR $T233057[ebp]
	call	?_Tidy@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@IAEXXZ ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR $T233153[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 17		; 00000011H
	mov	ecx, DWORD PTR $T233153[ebp]
	call	?_Tidy@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@IAEXXZ ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR __$EHRec$[ebp+8], 18		; 00000012H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@IAEXXZ ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvWorldBuilderMapTypeDesc@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1TypeMap@CvWorldBuilderMapTypeDesc@@QAE@XZ
__unwindfunclet$??1CvWorldBuilderMapTypeDesc@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1TypeMap@CvWorldBuilderMapTypeDesc@@QAE@XZ
__unwindfunclet$??1CvWorldBuilderMapTypeDesc@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	jmp	??1TypeMap@CvWorldBuilderMapTypeDesc@@QAE@XZ
__unwindfunclet$??1CvWorldBuilderMapTypeDesc@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	jmp	??1TypeMap@CvWorldBuilderMapTypeDesc@@QAE@XZ
__unwindfunclet$??1CvWorldBuilderMapTypeDesc@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1TypeMap@CvWorldBuilderMapTypeDesc@@QAE@XZ
__unwindfunclet$??1CvWorldBuilderMapTypeDesc@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	jmp	??1TypeMap@CvWorldBuilderMapTypeDesc@@QAE@XZ
__unwindfunclet$??1CvWorldBuilderMapTypeDesc@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 96					; 00000060H
	jmp	??1TypeMap@CvWorldBuilderMapTypeDesc@@QAE@XZ
__unwindfunclet$??1CvWorldBuilderMapTypeDesc@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	jmp	??1TypeMap@CvWorldBuilderMapTypeDesc@@QAE@XZ
__unwindfunclet$??1CvWorldBuilderMapTypeDesc@@QAE@XZ$8:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 128				; 00000080H
	jmp	??1TypeMap@CvWorldBuilderMapTypeDesc@@QAE@XZ
__unwindfunclet$??1CvWorldBuilderMapTypeDesc@@QAE@XZ$11:
	mov	ecx, DWORD PTR $T232385[ebp]
	jmp	??1?$_Vector_val@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE@XZ
__unwindfunclet$??1CvWorldBuilderMapTypeDesc@@QAE@XZ$14:
	mov	ecx, DWORD PTR $T232481[ebp]
	jmp	??1?$_Vector_val@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE@XZ
__unwindfunclet$??1CvWorldBuilderMapTypeDesc@@QAE@XZ$17:
	mov	ecx, DWORD PTR $T232577[ebp]
	jmp	??1?$_Vector_val@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE@XZ
__unwindfunclet$??1CvWorldBuilderMapTypeDesc@@QAE@XZ$20:
	mov	ecx, DWORD PTR $T232673[ebp]
	jmp	??1?$_Vector_val@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE@XZ
__unwindfunclet$??1CvWorldBuilderMapTypeDesc@@QAE@XZ$23:
	mov	ecx, DWORD PTR $T232769[ebp]
	jmp	??1?$_Vector_val@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE@XZ
__unwindfunclet$??1CvWorldBuilderMapTypeDesc@@QAE@XZ$26:
	mov	ecx, DWORD PTR $T232865[ebp]
	jmp	??1?$_Vector_val@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE@XZ
__unwindfunclet$??1CvWorldBuilderMapTypeDesc@@QAE@XZ$29:
	mov	ecx, DWORD PTR $T232961[ebp]
	jmp	??1?$_Vector_val@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE@XZ
__unwindfunclet$??1CvWorldBuilderMapTypeDesc@@QAE@XZ$32:
	mov	ecx, DWORD PTR $T233057[ebp]
	jmp	??1?$_Vector_val@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE@XZ
__unwindfunclet$??1CvWorldBuilderMapTypeDesc@@QAE@XZ$35:
	mov	ecx, DWORD PTR $T233153[ebp]
	jmp	??1?$_Vector_val@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE@XZ
__unwindfunclet$??1CvWorldBuilderMapTypeDesc@@QAE@XZ$38:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE@XZ
__ehhandler$??1CvWorldBuilderMapTypeDesc@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-364]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvWorldBuilderMapTypeDesc@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvWorldBuilderMapTypeDesc@@QAE@XZ ENDP		; CvWorldBuilderMapTypeDesc::~CvWorldBuilderMapTypeDesc
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1TypeMap@CvWorldBuilderMapTypeDesc@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1TypeMap@CvWorldBuilderMapTypeDesc@@QAE@XZ$1
__ehfuncinfo$??1TypeMap@CvWorldBuilderMapTypeDesc@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1TypeMap@CvWorldBuilderMapTypeDesc@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1TypeMap@CvWorldBuilderMapTypeDesc@@QAE@XZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
__$EHRec$ = -12						; size = 12
??1TypeMap@CvWorldBuilderMapTypeDesc@@QAE@XZ PROC	; CvWorldBuilderMapTypeDesc::TypeMap::~TypeMap, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1TypeMap@CvWorldBuilderMapTypeDesc@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@IAEXXZ ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1TypeMap@CvWorldBuilderMapTypeDesc@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE@XZ
__ehhandler$??1TypeMap@CvWorldBuilderMapTypeDesc@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1TypeMap@CvWorldBuilderMapTypeDesc@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1TypeMap@CvWorldBuilderMapTypeDesc@@QAE@XZ ENDP	; CvWorldBuilderMapTypeDesc::TypeMap::~TypeMap
; Function compile flags: /Odtp
;	COMDAT ??1?$_Vector_val@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::~_Vector_val<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::~_Vector_val<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T233423 = -32						; size = 4
$T233422 = -28						; size = 4
$T233418 = -24						; size = 4
$T233417 = -20						; size = 4
$T233399 = -16						; size = 4
$T233398 = -12						; size = 4
$T233382 = -8						; size = 4
__Cat$233406 = -2					; size = 1
$T233404 = -1						; size = 1
?_Tidy@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@IAEXXZ PROC ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T233418[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T233417[ebp], ecx
	mov	edx, DWORD PTR $T233418[ebp]
	mov	DWORD PTR $T233399[ebp], edx
	mov	eax, DWORD PTR $T233417[ebp]
	mov	DWORD PTR $T233398[ebp], eax
	mov	cl, BYTE PTR __Cat$233406[ebp]
	mov	BYTE PTR $T233404[ebp], cl
	mov	edx, DWORD PTR $T233398[ebp]
	mov	DWORD PTR $T233382[ebp], edx
	jmp	SHORT $LN12@Tidy
$LN11@Tidy:
	mov	eax, DWORD PTR $T233382[ebp]
	add	eax, 4
	mov	DWORD PTR $T233382[ebp], eax
$LN12@Tidy:
	mov	ecx, DWORD PTR $T233382[ebp]
	cmp	ecx, DWORD PTR $T233399[ebp]
	je	SHORT $LN4@Tidy
	jmp	SHORT $LN11@Tidy
$LN4@Tidy:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR $T233423[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T233422[ebp], eax
	mov	ecx, DWORD PTR $T233422[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@VString@CvWorldBuilderMapTypeDesc@@V?$allocator@VString@CvWorldBuilderMapTypeDesc@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvWorldBuilderMapTypeDesc::String,std::allocator<CvWorldBuilderMapTypeDesc::String> >::_Tidy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??__Fsg_kTempMap@@YAXXZ
text$yd	SEGMENT
??__Fsg_kTempMap@@YAXXZ PROC				; `dynamic atexit destructor for 'sg_kTempMap'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET _sg_kTempMap
	call	??1CvWorldBuilderMap@@QAE@XZ		; CvWorldBuilderMap::~CvWorldBuilderMap
	pop	ebp
	ret	0
??__Fsg_kTempMap@@YAXXZ ENDP				; `dynamic atexit destructor for 'sg_kTempMap''
text$yd	ENDS
_BSS	SEGMENT
_sg_kTempMap DB	0eebe0H DUP (?)
_sg_kMapTypeDesc DB 0a0H DUP (?)
_sg_kMapInfo DB	01cH DUP (?)
_sg_kSave DB	0eebe0H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_sg_kSave$initializer$ DD FLAT:??__Esg_kSave@@YAXXZ
_sg_kMapInfo$initializer$ DD FLAT:??__Esg_kMapInfo@@YAXXZ
_sg_kMapTypeDesc$initializer$ DD FLAT:??__Esg_kMapTypeDesc@@YAXXZ
_sg_kTempMap$initializer$ DD FLAT:??__Esg_kTempMap@@YAXXZ
CRT$XCU	ENDS
END
