; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvPlayerAI.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
PUBLIC	?m_aPlayers@CvPlayerAI@@1PAV1@A			; CvPlayerAI::m_aPlayers
_BSS	SEGMENT
?m_aPlayers@CvPlayerAI@@1PAV1@A DD 01H DUP (?)		; CvPlayerAI::m_aPlayers
_BSS	ENDS
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert
PUBLIC	??0CvPlayerAI@@QAE@XZ				; CvPlayerAI::CvPlayerAI
PUBLIC	??1CvPlayerAI@@UAE@XZ				; CvPlayerAI::~CvPlayerAI
PUBLIC	?initStatics@CvPlayerAI@@SAXXZ			; CvPlayerAI::initStatics
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
xdata$x	SEGMENT
__unwindtable$?initStatics@CvPlayerAI@@SAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?initStatics@CvPlayerAI@@SAXXZ$0
__ehfuncinfo$?initStatics@CvPlayerAI@@SAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?initStatics@CvPlayerAI@@SAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.cpp
xdata$x	ENDS
;	COMDAT ?initStatics@CvPlayerAI@@SAXXZ
_TEXT	SEGMENT
tv76 = -124						; size = 4
$T229036 = -120						; size = 4
$T229018 = -116						; size = 4
$T229034 = -40						; size = 8
$T229033 = -32						; size = 4
$T228874 = -28						; size = 4
$T228871 = -24						; size = 4
$T228870 = -20						; size = 4
_iI$225149 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?initStatics@CvPlayerAI@@SAXXZ PROC			; CvPlayerAI::initStatics, COMDAT

; 44   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?initStatics@CvPlayerAI@@SAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 45   : 	m_aPlayers = FNEW(CvPlayerAI[MAX_PLAYERS], c_eCiv5GameplayDLL, 0);

	push	4047108					; 003dc104H
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T228871[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T228871[ebp], 0
	je	SHORT $LN6@initStatic
	mov	eax, DWORD PTR $T228871[ebp]
	mov	DWORD PTR [eax], 64			; 00000040H
	push	OFFSET ??1CvPlayerAI@@UAE@XZ		; CvPlayerAI::~CvPlayerAI
	push	OFFSET ??0CvPlayerAI@@QAE@XZ		; CvPlayerAI::CvPlayerAI
	push	64					; 00000040H
	push	63236					; 0000f704H
	mov	ecx, DWORD PTR $T228871[ebp]
	add	ecx, 4
	push	ecx
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	mov	edx, DWORD PTR $T228871[ebp]
	add	edx, 4
	mov	DWORD PTR tv76[ebp], edx
	jmp	SHORT $LN7@initStatic
$LN6@initStatic:
	mov	DWORD PTR tv76[ebp], 0
$LN7@initStatic:
	mov	eax, DWORD PTR tv76[ebp]
	mov	DWORD PTR $T228870[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T228870[ebp]
	mov	DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A, ecx ; CvPlayerAI::m_aPlayers

; 46   : 	for(int iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$225149[ebp], 0
	jmp	SHORT $LN3@initStatic
$LN2@initStatic:
	mov	edx, DWORD PTR _iI$225149[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$225149[ebp], edx
$LN3@initStatic:
	cmp	DWORD PTR _iI$225149[ebp], 64		; 00000040H
	jge	SHORT $LN4@initStatic

; 47   : 	{
; 48   : 		m_aPlayers[iI].m_eID = ((PlayerTypes)iI);

	mov	eax, DWORD PTR _iI$225149[ebp]
	mov	DWORD PTR $T228874[ebp], eax
	mov	ecx, DWORD PTR _iI$225149[ebp]
	imul	ecx, 63236				; 0000f704H
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	eax, DWORD PTR [edx+ecx+40]
	mov	DWORD PTR $T229036[ebp], eax
	mov	ecx, DWORD PTR $T229036[ebp]
	mov	edx, DWORD PTR $T228874[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	je	SHORT $LN10@initStatic
	mov	eax, DWORD PTR $T229036[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR $T228874[ebp]
	je	SHORT $LN10@initStatic
	mov	edx, DWORD PTR $T229036[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T229018[ebp], eax
	mov	ecx, DWORD PTR $T229036[ebp]
	mov	DWORD PTR $T229033[ebp], ecx
	lea	edx, DWORD PTR $T229033[ebp]
	push	edx
	lea	eax, DWORD PTR $T229034[ebp]
	push	eax
	mov	ecx, DWORD PTR $T229018[ebp]
	add	ecx, 20					; 00000014H
	call	?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert
	mov	ecx, DWORD PTR $T229036[ebp]
	mov	edx, DWORD PTR $T228874[ebp]
	mov	DWORD PTR [ecx+4], edx
$LN10@initStatic:

; 49   : 	}

	jmp	SHORT $LN2@initStatic
$LN4@initStatic:

; 50   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?initStatics@CvPlayerAI@@SAXXZ$0:
	mov	eax, DWORD PTR $T228871[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__ehhandler$?initStatics@CvPlayerAI@@SAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-116]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?initStatics@CvPlayerAI@@SAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?initStatics@CvPlayerAI@@SAXXZ ENDP			; CvPlayerAI::initStatics
PUBLIC	??_ECvPlayerAI@@UAEPAXI@Z			; CvPlayerAI::`vector deleting destructor'
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
; Function compile flags: /Odtp
;	COMDAT ??_ECvPlayerAI@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_ECvPlayerAI@@UAEPAXI@Z PROC				; CvPlayerAI::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector
	push	OFFSET ??1CvPlayerAI@@UAE@XZ		; CvPlayerAI::~CvPlayerAI
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	63236					; 0000f704H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector
$LN3@vector:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvPlayerAI@@UAE@XZ			; CvPlayerAI::~CvPlayerAI
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector:
	mov	esp, ebp
	pop	ebp
	ret	4
??_ECvPlayerAI@@UAEPAXI@Z ENDP				; CvPlayerAI::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?freeStatics@CvPlayerAI@@SAXXZ			; CvPlayerAI::freeStatics
; Function compile flags: /Odtp
;	COMDAT ?freeStatics@CvPlayerAI@@SAXXZ
_TEXT	SEGMENT
tv80 = -20						; size = 4
tv79 = -16						; size = 4
$T229064 = -12						; size = 4
$T229063 = -8						; size = 4
$T229062 = -4						; size = 4
?freeStatics@CvPlayerAI@@SAXXZ PROC			; CvPlayerAI::freeStatics, COMDAT

; 53   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 54   : 	SAFE_DELETE_ARRAY(m_aPlayers);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T229064[ebp], eax
	mov	ecx, DWORD PTR $T229064[ebp]
	mov	DWORD PTR $T229063[ebp], ecx
	mov	edx, DWORD PTR $T229063[ebp]
	mov	DWORD PTR $T229062[ebp], edx
	cmp	DWORD PTR $T229062[ebp], 0
	je	SHORT $LN7@freeStatic
	mov	eax, DWORD PTR $T229062[ebp]
	cmp	DWORD PTR [eax-4], 0
	je	SHORT $LN5@freeStatic
	push	3
	mov	ecx, DWORD PTR $T229063[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T229063[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv79[ebp], eax
	jmp	SHORT $LN6@freeStatic
$LN5@freeStatic:
	mov	ecx, DWORD PTR $T229062[ebp]
	sub	ecx, 4
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR tv79[ebp], 0
$LN6@freeStatic:
	mov	edx, DWORD PTR tv79[ebp]
	mov	DWORD PTR tv80[ebp], edx
	jmp	SHORT $LN8@freeStatic
$LN7@freeStatic:
	mov	DWORD PTR tv80[ebp], 0
$LN8@freeStatic:
	mov	DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A, 0 ; CvPlayerAI::m_aPlayers

; 55   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?freeStatics@CvPlayerAI@@SAXXZ ENDP			; CvPlayerAI::freeStatics
_TEXT	ENDS
PUBLIC	?AI_reset@CvPlayerAI@@UAEXXZ			; CvPlayerAI::AI_reset
PUBLIC	??_7CvPlayerAI@@6B@				; CvPlayerAI::`vftable'
PUBLIC	?Read@CvPlayerAI@@UAEXAAVFDataStream@@@Z	; CvPlayerAI::Read
PUBLIC	?Write@CvPlayerAI@@UBEXAAVFDataStream@@@Z	; CvPlayerAI::Write
PUBLIC	?AI_init@CvPlayerAI@@UAEXXZ			; CvPlayerAI::AI_init
PUBLIC	?AI_doTurnPre@CvPlayerAI@@UAEXXZ		; CvPlayerAI::AI_doTurnPre
PUBLIC	?AI_doTurnPost@CvPlayerAI@@UAEXXZ		; CvPlayerAI::AI_doTurnPost
PUBLIC	?AI_doTurnUnitsPre@CvPlayerAI@@UAEXXZ		; CvPlayerAI::AI_doTurnUnitsPre
PUBLIC	?AI_doTurnUnitsPost@CvPlayerAI@@UAEXXZ		; CvPlayerAI::AI_doTurnUnitsPost
PUBLIC	?AI_updateFoundValues@CvPlayerAI@@UAEX_N@Z	; CvPlayerAI::AI_updateFoundValues
PUBLIC	?AI_unitUpdate@CvPlayerAI@@UAEXXZ		; CvPlayerAI::AI_unitUpdate
PUBLIC	?AI_conquerCity@CvPlayerAI@@UAEXPAVCvCity@@W4PlayerTypes@@@Z ; CvPlayerAI::AI_conquerCity
PUBLIC	?AI_foundValue@CvPlayerAI@@UAEHHHH_N@Z		; CvPlayerAI::AI_foundValue
PUBLIC	?AI_chooseFreeGreatPerson@CvPlayerAI@@UAEXXZ	; CvPlayerAI::AI_chooseFreeGreatPerson
PUBLIC	?AI_chooseFreeTech@CvPlayerAI@@UAEXXZ		; CvPlayerAI::AI_chooseFreeTech
PUBLIC	?AI_chooseResearch@CvPlayerAI@@UAEXXZ		; CvPlayerAI::AI_chooseResearch
PUBLIC	?AI_plotTargetMissionAIs@CvPlayerAI@@UAEHPAVCvPlot@@W4MissionAITypes@@H@Z ; CvPlayerAI::AI_plotTargetMissionAIs
PUBLIC	?AI_launch@CvPlayerAI@@UAEXW4VictoryTypes@@@Z	; CvPlayerAI::AI_launch
PUBLIC	?PeekAtNextUnitToBuildForOperationSlot@CvPlayerAI@@UAE?AUOperationSlot@@H@Z ; CvPlayerAI::PeekAtNextUnitToBuildForOperationSlot
PUBLIC	?CityCommitToBuildUnitForOperationSlot@CvPlayerAI@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z ; CvPlayerAI::CityCommitToBuildUnitForOperationSlot
PUBLIC	?CityUncommitToBuildUnitForOperationSlot@CvPlayerAI@@UAEXUOperationSlot@@@Z ; CvPlayerAI::CityUncommitToBuildUnitForOperationSlot
PUBLIC	?CityFinishedBuildingUnitForOperationSlot@CvPlayerAI@@UAEXUOperationSlot@@PAVCvUnit@@@Z ; CvPlayerAI::CityFinishedBuildingUnitForOperationSlot
PUBLIC	?GetNumUnitsNeededToBeBuilt@CvPlayerAI@@UAEHXZ	; CvPlayerAI::GetNumUnitsNeededToBeBuilt
EXTRN	??1CvPlayer@@UAE@XZ:PROC			; CvPlayer::~CvPlayer
EXTRN	??0CvPlayer@@QAE@XZ:PROC			; CvPlayer::CvPlayer
;	COMDAT ??_7CvPlayerAI@@6B@
CONST	SEGMENT
??_7CvPlayerAI@@6B@ DD FLAT:??_ECvPlayerAI@@UAEPAXI@Z	; CvPlayerAI::`vftable'
	DD	FLAT:?Read@CvPlayerAI@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvPlayerAI@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?AI_init@CvPlayerAI@@UAEXXZ
	DD	FLAT:?AI_reset@CvPlayerAI@@UAEXXZ
	DD	FLAT:?AI_doTurnPre@CvPlayerAI@@UAEXXZ
	DD	FLAT:?AI_doTurnPost@CvPlayerAI@@UAEXXZ
	DD	FLAT:?AI_doTurnUnitsPre@CvPlayerAI@@UAEXXZ
	DD	FLAT:?AI_doTurnUnitsPost@CvPlayerAI@@UAEXXZ
	DD	FLAT:?AI_updateFoundValues@CvPlayerAI@@UAEX_N@Z
	DD	FLAT:?AI_unitUpdate@CvPlayerAI@@UAEXXZ
	DD	FLAT:?AI_conquerCity@CvPlayerAI@@UAEXPAVCvCity@@W4PlayerTypes@@@Z
	DD	FLAT:?AI_foundValue@CvPlayerAI@@UAEHHHH_N@Z
	DD	FLAT:?AI_chooseFreeGreatPerson@CvPlayerAI@@UAEXXZ
	DD	FLAT:?AI_chooseFreeTech@CvPlayerAI@@UAEXXZ
	DD	FLAT:?AI_chooseResearch@CvPlayerAI@@UAEXXZ
	DD	FLAT:?AI_plotTargetMissionAIs@CvPlayerAI@@UAEHPAVCvPlot@@W4MissionAITypes@@H@Z
	DD	FLAT:?AI_launch@CvPlayerAI@@UAEXW4VictoryTypes@@@Z
	DD	FLAT:?PeekAtNextUnitToBuildForOperationSlot@CvPlayerAI@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CityCommitToBuildUnitForOperationSlot@CvPlayerAI@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?CityUncommitToBuildUnitForOperationSlot@CvPlayerAI@@UAEXUOperationSlot@@@Z
	DD	FLAT:?CityFinishedBuildingUnitForOperationSlot@CvPlayerAI@@UAEXUOperationSlot@@PAVCvUnit@@@Z
	DD	FLAT:?GetNumUnitsNeededToBeBuilt@CvPlayerAI@@UAEHXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CvPlayerAI@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvPlayerAI@@QAE@XZ$0
__ehfuncinfo$??0CvPlayerAI@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvPlayerAI@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0CvPlayerAI@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvPlayerAI@@QAE@XZ PROC				; CvPlayerAI::CvPlayerAI, COMDAT
; _this$ = ecx

; 59   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvPlayerAI@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CvPlayer@@QAE@XZ			; CvPlayer::CvPlayer
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvPlayerAI@@6B@

; 60   : 	AI_reset();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AI_reset@CvPlayerAI@@UAEXXZ		; CvPlayerAI::AI_reset

; 61   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvPlayerAI@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvPlayer@@UAE@XZ			; CvPlayer::~CvPlayer
__ehhandler$??0CvPlayerAI@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvPlayerAI@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvPlayerAI@@QAE@XZ ENDP				; CvPlayerAI::CvPlayerAI
PUBLIC	?AI_uninit@CvPlayerAI@@QAEXXZ			; CvPlayerAI::AI_uninit
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CvPlayerAI@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvPlayerAI@@UAE@XZ$0
__ehfuncinfo$??1CvPlayerAI@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CvPlayerAI@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1CvPlayerAI@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvPlayerAI@@UAE@XZ PROC				; CvPlayerAI::~CvPlayerAI, COMDAT
; _this$ = ecx

; 65   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvPlayerAI@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvPlayerAI@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 66   : 	AI_uninit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AI_uninit@CvPlayerAI@@QAEXXZ		; CvPlayerAI::AI_uninit

; 67   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvPlayer@@UAE@XZ			; CvPlayer::~CvPlayer
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvPlayerAI@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvPlayer@@UAE@XZ			; CvPlayer::~CvPlayer
__ehhandler$??1CvPlayerAI@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvPlayerAI@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvPlayerAI@@UAE@XZ ENDP				; CvPlayerAI::~CvPlayerAI
; Function compile flags: /Odtp
;	COMDAT ?AI_init@CvPlayerAI@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AI_init@CvPlayerAI@@UAEXXZ PROC			; CvPlayerAI::AI_init, COMDAT
; _this$ = ecx

; 71   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 72   : 	AI_reset();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax

; 73   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AI_init@CvPlayerAI@@UAEXXZ ENDP			; CvPlayerAI::AI_init
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?AI_uninit@CvPlayerAI@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AI_uninit@CvPlayerAI@@QAEXXZ PROC			; CvPlayerAI::AI_uninit, COMDAT
; _this$ = ecx

; 77   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 78   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AI_uninit@CvPlayerAI@@QAEXXZ ENDP			; CvPlayerAI::AI_uninit
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?AI_reset@CvPlayerAI@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AI_reset@CvPlayerAI@@UAEXXZ PROC			; CvPlayerAI::AI_reset, COMDAT
; _this$ = ecx

; 82   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 83   : 	AI_uninit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AI_uninit@CvPlayerAI@@QAEXXZ		; CvPlayerAI::AI_uninit

; 84   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AI_reset@CvPlayerAI@@UAEXXZ ENDP			; CvPlayerAI::AI_reset
_TEXT	ENDS
PUBLIC	?AI_considerAnnex@CvPlayerAI@@QAEXXZ		; CvPlayerAI::AI_considerAnnex
PUBLIC	?AI_doResearch@CvPlayerAI@@IAEXXZ		; CvPlayerAI::AI_doResearch
EXTRN	?isHuman@CvPlayer@@QBE_NXZ:PROC			; CvPlayer::isHuman
; Function compile flags: /Odtp
;	COMDAT ?AI_doTurnPre@CvPlayerAI@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AI_doTurnPre@CvPlayerAI@@UAEXXZ PROC			; CvPlayerAI::AI_doTurnPre, COMDAT
; _this$ = ecx

; 87   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 88   : 	AI_PERF_FORMAT("AI-perf.csv", ("CvPlayerAI::AI_doTurnPre, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), getCivilizationShortDescription()) );
; 89   : 	CvAssertMsg(getPersonalityType() != NO_LEADER, "getPersonalityType() is not expected to be equal with NO_LEADER");
; 90   : 	CvAssertMsg(getLeaderType() != NO_LEADER, "getLeaderType() is not expected to be equal with NO_LEADER");
; 91   : 	CvAssertMsg(getCivilizationType() != NO_CIVILIZATION, "getCivilizationType() is not expected to be equal with NO_CIVILIZATION");
; 92   : 
; 93   : 	if(isHuman())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@AI_doTurnP

; 94   : 	{
; 95   : 		return;

	jmp	SHORT $LN2@AI_doTurnP
$LN1@AI_doTurnP:

; 96   : 	}
; 97   : 
; 98   : 	AI_updateFoundValues();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	call	eax

; 99   : 
; 100  : 	AI_doResearch();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AI_doResearch@CvPlayerAI@@IAEXXZ	; CvPlayerAI::AI_doResearch

; 101  : 	AI_considerAnnex();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AI_considerAnnex@CvPlayerAI@@QAEXXZ	; CvPlayerAI::AI_considerAnnex
$LN2@AI_doTurnP:

; 102  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AI_doTurnPre@CvPlayerAI@@UAEXXZ ENDP			; CvPlayerAI::AI_doTurnPre
_TEXT	ENDS
PUBLIC	?ProcessGreatPeople@CvPlayerAI@@QAEXXZ		; CvPlayerAI::ProcessGreatPeople
EXTRN	?DoTurn@CvTradeAI@@QAEXXZ:PROC			; CvTradeAI::DoTurn
EXTRN	?GetTradeAI@CvPlayer@@QBEPAVCvTradeAI@@XZ:PROC	; CvPlayer::GetTradeAI
EXTRN	?DoTurn@CvEspionageAI@@QAEXXZ:PROC		; CvEspionageAI::DoTurn
EXTRN	?GetEspionageAI@CvPlayer@@QBEPAVCvEspionageAI@@XZ:PROC ; CvPlayer::GetEspionageAI
EXTRN	?getNumVictoryInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumVictoryInfos
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
EXTRN	?isBarbarian@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isBarbarian
; Function compile flags: /Odtp
;	COMDAT ?AI_doTurnPost@CvPlayerAI@@UAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$225199 = -4						; size = 4
?AI_doTurnPost@CvPlayerAI@@UAEXXZ PROC			; CvPlayerAI::AI_doTurnPost, COMDAT
; _this$ = ecx

; 106  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 107  : 	AI_PERF_FORMAT("AI-perf.csv", ("CvPlayerAI::AI_doTurnPost, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), getCivilizationShortDescription()) );
; 108  : 	if(isHuman())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@AI_doTurnP@2

; 109  : 	{
; 110  : 		return;

	jmp	SHORT $LN7@AI_doTurnP@2
$LN6@AI_doTurnP@2:

; 111  : 	}
; 112  : 
; 113  : 	if(isBarbarian())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@AI_doTurnP@2

; 114  : 	{
; 115  : 		return;

	jmp	SHORT $LN7@AI_doTurnP@2
$LN5@AI_doTurnP@2:

; 116  : 	}
; 117  : 
; 118  : 	if(isMinorCiv())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN4@AI_doTurnP@2

; 119  : 	{
; 120  : 		return;

	jmp	SHORT $LN7@AI_doTurnP@2
$LN4@AI_doTurnP@2:

; 121  : 	}
; 122  : 
; 123  : #ifdef AUI_WARNING_FIXES
; 124  : 	for (uint i = 0; i < GC.getNumVictoryInfos(); ++i)
; 125  : #else
; 126  : 	for(int i = 0; i < GC.getNumVictoryInfos(); ++i)

	mov	DWORD PTR _i$225199[ebp], 0
	jmp	SHORT $LN3@AI_doTurnP@2
$LN2@AI_doTurnP@2:
	mov	eax, DWORD PTR _i$225199[ebp]
	add	eax, 1
	mov	DWORD PTR _i$225199[ebp], eax
$LN3@AI_doTurnP@2:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumVictoryInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumVictoryInfos
	cmp	DWORD PTR _i$225199[ebp], eax
	jge	SHORT $LN1@AI_doTurnP@2

; 127  : #endif
; 128  : 	{
; 129  : 		AI_launch((VictoryTypes)i);

	mov	ecx, DWORD PTR _i$225199[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+68]
	call	edx

; 130  : 	}

	jmp	SHORT $LN2@AI_doTurnP@2
$LN1@AI_doTurnP@2:

; 131  : 
; 132  : 	ProcessGreatPeople();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ProcessGreatPeople@CvPlayerAI@@QAEXXZ	; CvPlayerAI::ProcessGreatPeople

; 133  : 	GetEspionageAI()->DoTurn();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEspionageAI@CvPlayer@@QBEPAVCvEspionageAI@@XZ ; CvPlayer::GetEspionageAI
	mov	ecx, eax
	call	?DoTurn@CvEspionageAI@@QAEXXZ		; CvEspionageAI::DoTurn

; 134  : 	GetTradeAI()->DoTurn();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTradeAI@CvPlayer@@QBEPAVCvTradeAI@@XZ ; CvPlayer::GetTradeAI
	mov	ecx, eax
	call	?DoTurn@CvTradeAI@@QAEXXZ		; CvTradeAI::DoTurn
$LN7@AI_doTurnP@2:

; 135  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AI_doTurnPost@CvPlayerAI@@UAEXXZ ENDP			; CvPlayerAI::AI_doTurnPost
_TEXT	ENDS
EXTRN	?InitializeQueuedAttacks@CvTacticalAI@@QAEXXZ:PROC ; CvTacticalAI::InitializeQueuedAttacks
EXTRN	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ:PROC ; CvPlayer::GetTacticalAI
; Function compile flags: /Odtp
;	COMDAT ?AI_doTurnUnitsPre@CvPlayerAI@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AI_doTurnUnitsPre@CvPlayerAI@@UAEXXZ PROC		; CvPlayerAI::AI_doTurnUnitsPre, COMDAT
; _this$ = ecx

; 139  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 	GetTacticalAI()->InitializeQueuedAttacks();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ ; CvPlayer::GetTacticalAI
	mov	ecx, eax
	call	?InitializeQueuedAttacks@CvTacticalAI@@QAEXXZ ; CvTacticalAI::InitializeQueuedAttacks

; 141  : 
; 142  : 	if(isHuman())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@AI_doTurnU

; 143  : 	{
; 144  : 		return;

	jmp	SHORT $LN3@AI_doTurnU
$LN2@AI_doTurnU:

; 145  : 	}
; 146  : 
; 147  : 	if(isBarbarian())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
$LN3@AI_doTurnU:

; 148  : 	{
; 149  : 		return;
; 150  : 	}
; 151  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AI_doTurnUnitsPre@CvPlayerAI@@UAEXXZ ENDP		; CvPlayerAI::AI_doTurnUnitsPre
_TEXT	ENDS
EXTRN	?AI_promote@CvUnit@@QAEXXZ:PROC			; CvUnit::AI_promote
EXTRN	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::nextUnit
EXTRN	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::firstUnit
; Function compile flags: /Odtp
;	COMDAT ?AI_doTurnUnitsPost@CvPlayerAI@@UAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_pLoopUnit$ = -8					; size = 4
_iLoop$ = -4						; size = 4
?AI_doTurnUnitsPost@CvPlayerAI@@UAEXXZ PROC		; CvPlayerAI::AI_doTurnUnitsPost, COMDAT
; _this$ = ecx

; 155  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 156  : 	CvUnit* pLoopUnit;
; 157  : 	int iLoop;
; 158  : 
; 159  : 	if(!isHuman())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN5@AI_doTurnU@2

; 160  : 	{
; 161  : 		for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))

	push	0
	lea	ecx, DWORD PTR _iLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN3@AI_doTurnU@2
$LN2@AI_doTurnU@2:
	push	0
	lea	edx, DWORD PTR _iLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
$LN3@AI_doTurnU@2:
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN5@AI_doTurnU@2

; 162  : 		{
; 163  : 			pLoopUnit->AI_promote();

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?AI_promote@CvUnit@@QAEXXZ		; CvUnit::AI_promote

; 164  : 		}

	jmp	SHORT $LN2@AI_doTurnU@2
$LN5@AI_doTurnU@2:

; 165  : 	}
; 166  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AI_doTurnUnitsPost@CvPlayerAI@@UAEXXZ ENDP		; CvPlayerAI::AI_doTurnUnitsPost
_TEXT	ENDS
EXTRN	?getTotalFoundValue@CvArea@@QBEHXZ:PROC		; CvArea::getTotalFoundValue
EXTRN	?isWater@CvArea@@QBE_NXZ:PROC			; CvArea::isWater
EXTRN	?getArea@CvMap@@QAEPAVCvArea@@H@Z:PROC		; CvMap::getArea
EXTRN	?GetSettlerSiteEvaluator@CvGame@@QAEPAVCvSiteEvaluatorForSettler@@XZ:PROC ; CvGame::GetSettlerSiteEvaluator
EXTRN	?setFoundValue@CvPlot@@QAEXW4PlayerTypes@@H@Z:PROC ; CvPlot::setFoundValue
EXTRN	?setTotalFoundValue@CvArea@@QAEXH@Z:PROC	; CvArea::setTotalFoundValue
EXTRN	?nextArea@CvMap@@QAEPAVCvArea@@PAH_N@Z:PROC	; CvMap::nextArea
EXTRN	?firstArea@CvMap@@QAEPAVCvArea@@PAH_N@Z:PROC	; CvMap::firstArea
; Function compile flags: /Odtp
;	COMDAT ?AI_updateFoundValues@CvPlayerAI@@UAEX_N@Z
_TEXT	SEGMENT
tv179 = -96						; size = 4
tv150 = -92						; size = 4
_this$ = -88						; size = 4
$T229176 = -84						; size = 4
$T229172 = -80						; size = 4
$T229168 = -76						; size = 4
_uiOffset$229163 = -72					; size = 4
$T229151 = -68						; size = 4
$T229147 = -64						; size = 4
$T229132 = -60						; size = 4
$T229120 = -56						; size = 4
$T229116 = -52						; size = 4
$T229109 = -48						; size = 4
_pLoopArea$225245 = -44					; size = 4
_iValue$225243 = -40					; size = 4
_pLoopPlot$225241 = -36					; size = 4
_iI$225237 = -32					; size = 4
_eTeam$225236 = -28					; size = 4
_iI$225231 = -24					; size = 4
_pLoopArea$225225 = -20					; size = 4
_eID$ = -16						; size = 4
_iGoodEnoughToBeWorthOurTime$ = -12			; size = 4
_iNumPlots$ = -8					; size = 4
_iLoop$ = -4						; size = 4
_bStartingLoc$ = 8					; size = 1
?AI_updateFoundValues@CvPlayerAI@@UAEX_N@Z PROC		; CvPlayerAI::AI_updateFoundValues, COMDAT
; _this$ = ecx

; 169  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 170  : 	int iGoodEnoughToBeWorthOurTime = GC.getAI_STRATEGY_MINIMUM_SETTLE_FERTILITY();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2028
	mov	DWORD PTR _iGoodEnoughToBeWorthOurTime$[ebp], eax

; 171  : 	int iLoop;
; 172  : 	const int iNumPlots = GC.getMap().numPlots();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T229109[ebp], ecx
	mov	edx, DWORD PTR $T229109[ebp]
	mov	eax, DWORD PTR [edx+4028]
	mov	DWORD PTR _iNumPlots$[ebp], eax

; 173  : 	for(CvArea* pLoopArea = GC.getMap().firstArea(&iLoop); pLoopArea != NULL; pLoopArea = GC.getMap().nextArea(&iLoop))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T229116[ebp], ecx
	push	0
	lea	edx, DWORD PTR _iLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T229116[ebp]
	call	?firstArea@CvMap@@QAEPAVCvArea@@PAH_N@Z	; CvMap::firstArea
	mov	DWORD PTR _pLoopArea$225225[ebp], eax
	jmp	SHORT $LN15@AI_updateF
$LN14@AI_updateF:
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T229120[ebp], eax
	push	0
	lea	ecx, DWORD PTR _iLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T229120[ebp]
	call	?nextArea@CvMap@@QAEPAVCvArea@@PAH_N@Z	; CvMap::nextArea
	mov	DWORD PTR _pLoopArea$225225[ebp], eax
$LN15@AI_updateF:
	cmp	DWORD PTR _pLoopArea$225225[ebp], 0
	je	SHORT $LN30@AI_updateF

; 174  : 	{
; 175  : 		pLoopArea->setTotalFoundValue(0);

	push	0
	mov	ecx, DWORD PTR _pLoopArea$225225[ebp]
	call	?setTotalFoundValue@CvArea@@QAEXH@Z	; CvArea::setTotalFoundValue

; 176  : 	}

	jmp	SHORT $LN14@AI_updateF

; 177  : 
; 178  : 	const PlayerTypes eID = GetID();

$LN30@AI_updateF:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR _eID$[ebp], eax

; 179  : 	if(bStartingLoc)

	movzx	ecx, BYTE PTR _bStartingLoc$[ebp]
	test	ecx, ecx
	je	SHORT $LN36@AI_updateF

; 180  : 	{
; 181  : 		for(int iI = 0; iI < iNumPlots; iI++)

	mov	DWORD PTR _iI$225231[ebp], 0
	jmp	SHORT $LN11@AI_updateF
$LN10@AI_updateF:
	mov	edx, DWORD PTR _iI$225231[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$225231[ebp], edx
$LN11@AI_updateF:
	mov	eax, DWORD PTR _iI$225231[ebp]
	cmp	eax, DWORD PTR _iNumPlots$[ebp]
	jge	SHORT $LN9@AI_updateF

; 182  : 		{
; 183  : 			GC.getMap().plotByIndexUnchecked(iI)->setFoundValue(eID, -1);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T229132[ebp], ecx
	push	-1
	mov	edx, DWORD PTR _eID$[ebp]
	push	edx
	mov	ecx, DWORD PTR _iI$225231[ebp]
	imul	ecx, 484				; 000001e4H
	mov	eax, DWORD PTR $T229132[ebp]
	add	ecx, DWORD PTR [eax+4068]
	call	?setFoundValue@CvPlot@@QAEXW4PlayerTypes@@H@Z ; CvPlot::setFoundValue

; 184  : 		}

	jmp	SHORT $LN10@AI_updateF
$LN9@AI_updateF:

; 185  : 	}
; 186  : 	else

	jmp	$LN16@AI_updateF

; 187  : 	{
; 188  : 		const TeamTypes eTeam = getTeam();

$LN36@AI_updateF:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$225236[ebp], eax

; 189  : 		GC.getGame().GetSettlerSiteEvaluator()->ComputeFlavorMultipliers(this);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T229147[ebp], eax
	mov	ecx, DWORD PTR $T229147[ebp]
	call	?GetSettlerSiteEvaluator@CvGame@@QAEPAVCvSiteEvaluatorForSettler@@XZ ; CvGame::GetSettlerSiteEvaluator
	mov	DWORD PTR tv150[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv150[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv150[ebp]
	mov	edx, DWORD PTR [eax+4]
	call	edx

; 190  : 		for (int iI = 0; iI < iNumPlots; iI++)

	mov	DWORD PTR _iI$225237[ebp], 0
	jmp	SHORT $LN7@AI_updateF
$LN6@AI_updateF:
	mov	eax, DWORD PTR _iI$225237[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$225237[ebp], eax
$LN7@AI_updateF:
	mov	ecx, DWORD PTR _iI$225237[ebp]
	cmp	ecx, DWORD PTR _iNumPlots$[ebp]
	jge	$LN16@AI_updateF

; 191  : 		{
; 192  : 			CvPlot* pLoopPlot = GC.getMap().plotByIndexUnchecked(iI);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T229151[ebp], edx
	mov	eax, DWORD PTR _iI$225237[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T229151[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR _pLoopPlot$225241[ebp], eax

; 193  : 
; 194  : 			if (pLoopPlot->isRevealed(eTeam))

	mov	edx, DWORD PTR _eTeam$225236[ebp]
	shr	edx, 5
	mov	DWORD PTR _uiOffset$229163[ebp], edx
	mov	eax, DWORD PTR _uiOffset$229163[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _eTeam$225236[ebp]
	sub	ecx, eax
	mov	edx, 1
	shl	edx, cl
	mov	eax, DWORD PTR _uiOffset$229163[ebp]
	mov	ecx, DWORD PTR _pLoopPlot$225241[ebp]
	and	edx, DWORD PTR [ecx+eax*4+8]
	setne	dl
	movzx	eax, dl
	test	eax, eax
	je	$LN4@AI_updateF

; 195  : 			{
; 196  : 				const int iValue = GC.getGame().GetSettlerSiteEvaluator()->PlotFoundValue(pLoopPlot, this, NO_YIELD, false);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T229168[ebp], ecx
	mov	ecx, DWORD PTR $T229168[ebp]
	call	?GetSettlerSiteEvaluator@CvGame@@QAEPAVCvSiteEvaluatorForSettler@@XZ ; CvGame::GetSettlerSiteEvaluator
	mov	DWORD PTR tv179[ebp], eax
	push	0
	push	-1
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _pLoopPlot$225241[ebp]
	push	eax
	mov	ecx, DWORD PTR tv179[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv179[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _iValue$225243[ebp], eax

; 197  : 				pLoopPlot->setFoundValue(eID, iValue);

	mov	ecx, DWORD PTR _iValue$225243[ebp]
	push	ecx
	mov	edx, DWORD PTR _eID$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pLoopPlot$225241[ebp]
	call	?setFoundValue@CvPlot@@QAEXW4PlayerTypes@@H@Z ; CvPlot::setFoundValue

; 198  : 				if (iValue >= iGoodEnoughToBeWorthOurTime)

	mov	eax, DWORD PTR _iValue$225243[ebp]
	cmp	eax, DWORD PTR _iGoodEnoughToBeWorthOurTime$[ebp]
	jl	SHORT $LN3@AI_updateF

; 199  : 				{
; 200  : 					CvArea* pLoopArea = GC.getMap().getArea(pLoopPlot->getArea());

	mov	ecx, DWORD PTR _pLoopPlot$225241[ebp]
	mov	edx, DWORD PTR [ecx+356]
	mov	DWORD PTR $T229172[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T229176[ebp], eax
	mov	ecx, DWORD PTR $T229172[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T229176[ebp]
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	mov	DWORD PTR _pLoopArea$225245[ebp], eax

; 201  : 					if(pLoopArea && !pLoopArea->isWater())

	cmp	DWORD PTR _pLoopArea$225245[ebp], 0
	je	SHORT $LN3@AI_updateF
	mov	ecx, DWORD PTR _pLoopArea$225245[ebp]
	call	?isWater@CvArea@@QBE_NXZ		; CvArea::isWater
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN3@AI_updateF

; 202  : 					{
; 203  : 						pLoopArea->setTotalFoundValue(pLoopArea->getTotalFoundValue() + iValue);

	mov	ecx, DWORD PTR _pLoopArea$225245[ebp]
	call	?getTotalFoundValue@CvArea@@QBEHXZ	; CvArea::getTotalFoundValue
	add	eax, DWORD PTR _iValue$225243[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopArea$225245[ebp]
	call	?setTotalFoundValue@CvArea@@QAEXH@Z	; CvArea::setTotalFoundValue
$LN3@AI_updateF:

; 204  : 					}
; 205  : 				}
; 206  : 			}
; 207  : 			else

	jmp	SHORT $LN1@AI_updateF
$LN4@AI_updateF:

; 208  : 			{
; 209  : 				pLoopPlot->setFoundValue(eID, -1);

	push	-1
	mov	eax, DWORD PTR _eID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopPlot$225241[ebp]
	call	?setFoundValue@CvPlot@@QAEXW4PlayerTypes@@H@Z ; CvPlot::setFoundValue
$LN1@AI_updateF:

; 210  : 			}

	jmp	$LN6@AI_updateF
$LN16@AI_updateF:

; 211  : 		}
; 212  : 	}
; 213  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?AI_updateFoundValues@CvPlayerAI@@UAEX_N@Z ENDP		; CvPlayerAI::AI_updateFoundValues
_TEXT	ENDS
PUBLIC	??_C@_0BG@FMLOPNPI@PlayerPreAIUnitUpdate?$AA@	; `string'
EXTRN	?RecruitUnits@CvHomelandAI@@QAEXXZ:PROC		; CvHomelandAI::RecruitUnits
EXTRN	?Update@CvTacticalAI@@QAEXXZ:PROC		; CvTacticalAI::Update
EXTRN	?CommandeerUnits@CvTacticalAI@@QAEXXZ:PROC	; CvTacticalAI::CommandeerUnits
EXTRN	?Update@CvHomelandAI@@QAEXXZ:PROC		; CvHomelandAI::Update
EXTRN	?FindAutomatedUnits@CvHomelandAI@@QAEXXZ:PROC	; CvHomelandAI::FindAutomatedUnits
EXTRN	?GetHomelandAI@CvPlayer@@QBEPAVCvHomelandAI@@XZ:PROC ; CvPlayer::GetHomelandAI
EXTRN	?dispatchingNetMessage@CvUnit@@SAX_N@Z:PROC	; CvUnit::dispatchingNetMessage
EXTRN	?hasBusyUnitOrCity@CvPlayer@@QBE_NXZ:PROC	; CvPlayer::hasBusyUnitOrCity
EXTRN	??1CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::~CvLuaArgsHandle
EXTRN	?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z:PROC ; LuaSupport::CallHook
EXTRN	??0CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::CvLuaArgsHandle
EXTRN	?getInfluenceFinder@CvGlobals@@QAEAAVCvAStar@@XZ:PROC ; CvGlobals::getInfluenceFinder
EXTRN	?GetTacticalAnalysisMapFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ:PROC ; CvGlobals::GetTacticalAnalysisMapFinder
EXTRN	?GetWaterRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ:PROC ; CvGlobals::GetWaterRouteFinder
EXTRN	?getRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ:PROC ; CvGlobals::getRouteFinder
EXTRN	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ:PROC ; CvGlobals::getIgnoreUnitsPathFinder
EXTRN	?getPathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ:PROC ; CvGlobals::getPathFinder
;	COMDAT ??_C@_0BG@FMLOPNPI@PlayerPreAIUnitUpdate?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvastar.h
CONST	SEGMENT
??_C@_0BG@FMLOPNPI@PlayerPreAIUnitUpdate?$AA@ DB 'PlayerPreAIUnitUpdate', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?AI_unitUpdate@CvPlayerAI@@UAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AI_unitUpdate@CvPlayerAI@@UAEXXZ$0
__ehfuncinfo$?AI_unitUpdate@CvPlayerAI@@UAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AI_unitUpdate@CvPlayerAI@@UAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.cpp
xdata$x	ENDS
;	COMDAT ?AI_unitUpdate@CvPlayerAI@@UAEXXZ
_TEXT	SEGMENT
tv176 = -168						; size = 4
tv165 = -164						; size = 4
_this$ = -160						; size = 4
$T229289 = -156						; size = 4
_bOldState$229286 = -149				; size = 1
$T229283 = -148						; size = 4
_bOldState$229280 = -141				; size = 1
$T229277 = -140						; size = 4
_bOldState$229274 = -133				; size = 1
$T229271 = -132						; size = 4
_bOldState$229268 = -125				; size = 1
$T229265 = -124						; size = 4
_bOldState$229262 = -117				; size = 1
$T229259 = -116						; size = 4
_bOldState$229256 = -109				; size = 1
$T229247 = -108						; size = 4
$T229235 = -104						; size = 4
$T229231 = -100						; size = 4
_bOldState$229229 = -93					; size = 1
$T229225 = -92						; size = 4
_bOldState$229223 = -85					; size = 1
$T229219 = -84						; size = 4
_bOldState$229217 = -77					; size = 1
$T229213 = -76						; size = 4
_bOldState$229211 = -69					; size = 1
$T229207 = -68						; size = 4
_bOldState$229205 = -61					; size = 1
$T229201 = -60						; size = 4
_bOldState$229199 = -53					; size = 1
$T229195 = -52						; size = 4
$T229191 = -48						; size = 4
$T229187 = -44						; size = 4
$T229183 = -40						; size = 4
_bResult$225260 = -33					; size = 1
_args$225259 = -32					; size = 4
_bIgnoreUnitsPathFinderMPCaching$ = -25			; size = 1
_bTacticalPathFinderMPCaching$ = -24			; size = 1
_bInfluencePathFinderMPCaching$ = -23			; size = 1
_bCommonPathFinderMPCaching$ = -22			; size = 1
_bWaterRoutePathFinderMPCaching$ = -21			; size = 1
_pkScriptSystem$ = -20					; size = 4
_bRoutePathFinderMPCaching$ = -13			; size = 1
__$EHRec$ = -12						; size = 12
?AI_unitUpdate@CvPlayerAI@@UAEXXZ PROC			; CvPlayerAI::AI_unitUpdate, COMDAT
; _this$ = ecx

; 217  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AI_unitUpdate@CvPlayerAI@@UAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 156				; 0000009cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 218  : 	GC.getPathFinder().ForceReset();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::getPathFinder
	mov	DWORD PTR $T229183[ebp], eax
	mov	eax, DWORD PTR $T229183[ebp]
	mov	BYTE PTR [eax+78], 1

; 219  : 	GC.getIgnoreUnitsPathFinder().ForceReset();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ ; CvGlobals::getIgnoreUnitsPathFinder
	mov	DWORD PTR $T229187[ebp], eax
	mov	ecx, DWORD PTR $T229187[ebp]
	mov	BYTE PTR [ecx+78], 1

; 220  : 	GC.getRouteFinder().ForceReset();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::getRouteFinder
	mov	DWORD PTR $T229191[ebp], eax
	mov	edx, DWORD PTR $T229191[ebp]
	mov	BYTE PTR [edx+78], 1

; 221  : 	GC.GetWaterRouteFinder().ForceReset();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetWaterRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetWaterRouteFinder
	mov	DWORD PTR $T229195[ebp], eax
	mov	eax, DWORD PTR $T229195[ebp]
	mov	BYTE PTR [eax+78], 1

; 222  : 
; 223  : 	// Set individual pathers as MP cache safe.  A global for all pathers might be simpler,
; 224  : 	// but this will allow selective control in case one type of pather is causing out-of-syncs.
; 225  : 	bool bCommonPathFinderMPCaching = GC.getPathFinder().SetMPCacheSafe(true);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::getPathFinder
	mov	DWORD PTR $T229201[ebp], eax
	mov	ecx, DWORD PTR $T229201[ebp]
	mov	dl, BYTE PTR [ecx+79]
	mov	BYTE PTR _bOldState$229199[ebp], dl
	mov	eax, 1
	mov	ecx, DWORD PTR $T229201[ebp]
	movzx	edx, BYTE PTR [ecx+79]
	cmp	eax, edx
	je	SHORT $LN18@AI_unitUpd
	mov	eax, DWORD PTR $T229201[ebp]
	mov	BYTE PTR [eax+78], 1
	mov	ecx, DWORD PTR $T229201[ebp]
	mov	BYTE PTR [ecx+79], 1
$LN18@AI_unitUpd:
	mov	dl, BYTE PTR _bOldState$229199[ebp]
	mov	BYTE PTR _bCommonPathFinderMPCaching$[ebp], dl

; 226  : 	bool bIgnoreUnitsPathFinderMPCaching = GC.getIgnoreUnitsPathFinder().SetMPCacheSafe(true);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ ; CvGlobals::getIgnoreUnitsPathFinder
	mov	DWORD PTR $T229207[ebp], eax
	mov	eax, DWORD PTR $T229207[ebp]
	mov	cl, BYTE PTR [eax+79]
	mov	BYTE PTR _bOldState$229205[ebp], cl
	mov	edx, 1
	mov	eax, DWORD PTR $T229207[ebp]
	movzx	ecx, BYTE PTR [eax+79]
	cmp	edx, ecx
	je	SHORT $LN21@AI_unitUpd
	mov	edx, DWORD PTR $T229207[ebp]
	mov	BYTE PTR [edx+78], 1
	mov	eax, DWORD PTR $T229207[ebp]
	mov	BYTE PTR [eax+79], 1
$LN21@AI_unitUpd:
	mov	cl, BYTE PTR _bOldState$229205[ebp]
	mov	BYTE PTR _bIgnoreUnitsPathFinderMPCaching$[ebp], cl

; 227  : 	bool bTacticalPathFinderMPCaching = GC.GetTacticalAnalysisMapFinder().SetMPCacheSafe(true);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetTacticalAnalysisMapFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::GetTacticalAnalysisMapFinder
	mov	DWORD PTR $T229213[ebp], eax
	mov	edx, DWORD PTR $T229213[ebp]
	mov	al, BYTE PTR [edx+79]
	mov	BYTE PTR _bOldState$229211[ebp], al
	mov	ecx, 1
	mov	edx, DWORD PTR $T229213[ebp]
	movzx	eax, BYTE PTR [edx+79]
	cmp	ecx, eax
	je	SHORT $LN24@AI_unitUpd
	mov	ecx, DWORD PTR $T229213[ebp]
	mov	BYTE PTR [ecx+78], 1
	mov	edx, DWORD PTR $T229213[ebp]
	mov	BYTE PTR [edx+79], 1
$LN24@AI_unitUpd:
	mov	al, BYTE PTR _bOldState$229211[ebp]
	mov	BYTE PTR _bTacticalPathFinderMPCaching$[ebp], al

; 228  : 	bool bInfluencePathFinderMPCaching = GC.getInfluenceFinder().SetMPCacheSafe(true);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfluenceFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::getInfluenceFinder
	mov	DWORD PTR $T229219[ebp], eax
	mov	ecx, DWORD PTR $T229219[ebp]
	mov	dl, BYTE PTR [ecx+79]
	mov	BYTE PTR _bOldState$229217[ebp], dl
	mov	eax, 1
	mov	ecx, DWORD PTR $T229219[ebp]
	movzx	edx, BYTE PTR [ecx+79]
	cmp	eax, edx
	je	SHORT $LN27@AI_unitUpd
	mov	eax, DWORD PTR $T229219[ebp]
	mov	BYTE PTR [eax+78], 1
	mov	ecx, DWORD PTR $T229219[ebp]
	mov	BYTE PTR [ecx+79], 1
$LN27@AI_unitUpd:
	mov	dl, BYTE PTR _bOldState$229217[ebp]
	mov	BYTE PTR _bInfluencePathFinderMPCaching$[ebp], dl

; 229  : 	bool bRoutePathFinderMPCaching = GC.getRouteFinder().SetMPCacheSafe(true);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::getRouteFinder
	mov	DWORD PTR $T229225[ebp], eax
	mov	eax, DWORD PTR $T229225[ebp]
	mov	cl, BYTE PTR [eax+79]
	mov	BYTE PTR _bOldState$229223[ebp], cl
	mov	edx, 1
	mov	eax, DWORD PTR $T229225[ebp]
	movzx	ecx, BYTE PTR [eax+79]
	cmp	edx, ecx
	je	SHORT $LN30@AI_unitUpd
	mov	edx, DWORD PTR $T229225[ebp]
	mov	BYTE PTR [edx+78], 1
	mov	eax, DWORD PTR $T229225[ebp]
	mov	BYTE PTR [eax+79], 1
$LN30@AI_unitUpd:
	mov	cl, BYTE PTR _bOldState$229223[ebp]
	mov	BYTE PTR _bRoutePathFinderMPCaching$[ebp], cl

; 230  : 	bool bWaterRoutePathFinderMPCaching = GC.GetWaterRouteFinder().SetMPCacheSafe(true);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetWaterRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetWaterRouteFinder
	mov	DWORD PTR $T229231[ebp], eax
	mov	edx, DWORD PTR $T229231[ebp]
	mov	al, BYTE PTR [edx+79]
	mov	BYTE PTR _bOldState$229229[ebp], al
	mov	ecx, 1
	mov	edx, DWORD PTR $T229231[ebp]
	movzx	eax, BYTE PTR [edx+79]
	cmp	ecx, eax
	je	SHORT $LN33@AI_unitUpd
	mov	ecx, DWORD PTR $T229231[ebp]
	mov	BYTE PTR [ecx+78], 1
	mov	edx, DWORD PTR $T229231[ebp]
	mov	BYTE PTR [edx+79], 1
$LN33@AI_unitUpd:
	mov	al, BYTE PTR _bOldState$229229[ebp]
	mov	BYTE PTR _bWaterRoutePathFinderMPCaching$[ebp], al

; 231  : 
; 232  : 	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR $T229235[ebp]
	mov	DWORD PTR tv165[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv165[ebp], edx
	mov	eax, DWORD PTR tv165[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv165[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pkScriptSystem$[ebp], eax

; 233  : 	if(pkScriptSystem)

	cmp	DWORD PTR _pkScriptSystem$[ebp], 0
	je	SHORT $LN5@AI_unitUpd

; 234  : 	{
; 235  : 		CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$225259[ebp]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 236  : 		args->Push(GetID());

	mov	ecx, DWORD PTR _args$225259[ebp]
	mov	DWORD PTR tv176[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T229247[ebp], eax
	mov	ecx, DWORD PTR $T229247[ebp]
	push	ecx
	mov	edx, DWORD PTR tv176[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv176[ebp]
	mov	edx, DWORD PTR [eax+8]
	call	edx

; 237  : 
; 238  : 		bool bResult;
; 239  : 		LuaSupport::CallHook(pkScriptSystem, "PlayerPreAIUnitUpdate", args.get(), bResult);

	lea	eax, DWORD PTR _bResult$225260[ebp]
	push	eax
	mov	ecx, DWORD PTR _args$225259[ebp]
	push	ecx
	push	OFFSET ??_C@_0BG@FMLOPNPI@PlayerPreAIUnitUpdate?$AA@
	mov	edx, DWORD PTR _pkScriptSystem$[ebp]
	push	edx
	call	?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallHook
	add	esp, 16					; 00000010H

; 240  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _args$225259[ebp]
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN5@AI_unitUpd:

; 241  : 
; 242  : 	//GC.getGame().GetTacticalAnalysisMap()->RefreshDataForNextPlayer(this);
; 243  : 
; 244  : 	// this was a !hasBusyUnit around the entire rest of the function, so I tried to make it a bit flatter.
; 245  : 	if(hasBusyUnitOrCity())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?hasBusyUnitOrCity@CvPlayer@@QBE_NXZ	; CvPlayer::hasBusyUnitOrCity
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@AI_unitUpd

; 246  : 	{
; 247  : 		return;

	jmp	$LN6@AI_unitUpd
$LN4@AI_unitUpd:

; 248  : 	}
; 249  : 
; 250  : 	if(isHuman())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@AI_unitUpd

; 251  : 	{
; 252  : 		CvUnit::dispatchingNetMessage(true);

	push	1
	call	?dispatchingNetMessage@CvUnit@@SAX_N@Z	; CvUnit::dispatchingNetMessage
	add	esp, 4

; 253  : 		// The homeland AI goes first.
; 254  : 		GetHomelandAI()->FindAutomatedUnits();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetHomelandAI@CvPlayer@@QBEPAVCvHomelandAI@@XZ ; CvPlayer::GetHomelandAI
	mov	ecx, eax
	call	?FindAutomatedUnits@CvHomelandAI@@QAEXXZ ; CvHomelandAI::FindAutomatedUnits

; 255  : 		GetHomelandAI()->Update();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetHomelandAI@CvPlayer@@QBEPAVCvHomelandAI@@XZ ; CvPlayer::GetHomelandAI
	mov	ecx, eax
	call	?Update@CvHomelandAI@@QAEXXZ		; CvHomelandAI::Update

; 256  : 		CvUnit::dispatchingNetMessage(false);

	push	0
	call	?dispatchingNetMessage@CvUnit@@SAX_N@Z	; CvUnit::dispatchingNetMessage
	add	esp, 4

; 257  : 	}
; 258  : 	else

	jmp	SHORT $LN2@AI_unitUpd
$LN3@AI_unitUpd:

; 259  : 	{
; 260  : 		// Update tactical AI
; 261  : 		GetTacticalAI()->CommandeerUnits();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ ; CvPlayer::GetTacticalAI
	mov	ecx, eax
	call	?CommandeerUnits@CvTacticalAI@@QAEXXZ	; CvTacticalAI::CommandeerUnits

; 262  : 
; 263  : 		// Now let the tactical AI run.  Putting it after the operations update allows units who have
; 264  : 		// just been handed off to the tactical AI to get a move in the same turn they switch between
; 265  : 		// AI subsystems
; 266  : 		GetTacticalAI()->Update();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ ; CvPlayer::GetTacticalAI
	mov	ecx, eax
	call	?Update@CvTacticalAI@@QAEXXZ		; CvTacticalAI::Update

; 267  : 
; 268  : 		// Skip homeland AI processing if a barbarian
; 269  : 		if(m_eID != BARBARIAN_PLAYER)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+44], 63			; 0000003fH
	je	SHORT $LN2@AI_unitUpd

; 270  : 		{
; 271  : 			// Now its the homeland AI's turn.
; 272  : 			GetHomelandAI()->RecruitUnits();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetHomelandAI@CvPlayer@@QBEPAVCvHomelandAI@@XZ ; CvPlayer::GetHomelandAI
	mov	ecx, eax
	call	?RecruitUnits@CvHomelandAI@@QAEXXZ	; CvHomelandAI::RecruitUnits

; 273  : 			GetHomelandAI()->Update();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetHomelandAI@CvPlayer@@QBEPAVCvHomelandAI@@XZ ; CvPlayer::GetHomelandAI
	mov	ecx, eax
	call	?Update@CvHomelandAI@@QAEXXZ		; CvHomelandAI::Update
$LN2@AI_unitUpd:

; 274  : 		}
; 275  : 	}
; 276  : 
; 277  : 	GC.getPathFinder().SetMPCacheSafe(bCommonPathFinderMPCaching);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::getPathFinder
	mov	DWORD PTR $T229259[ebp], eax
	mov	eax, DWORD PTR $T229259[ebp]
	mov	cl, BYTE PTR [eax+79]
	mov	BYTE PTR _bOldState$229256[ebp], cl
	movzx	edx, BYTE PTR _bCommonPathFinderMPCaching$[ebp]
	mov	eax, DWORD PTR $T229259[ebp]
	movzx	ecx, BYTE PTR [eax+79]
	cmp	edx, ecx
	je	SHORT $LN48@AI_unitUpd
	mov	edx, DWORD PTR $T229259[ebp]
	mov	BYTE PTR [edx+78], 1
	mov	eax, DWORD PTR $T229259[ebp]
	mov	cl, BYTE PTR _bCommonPathFinderMPCaching$[ebp]
	mov	BYTE PTR [eax+79], cl
$LN48@AI_unitUpd:

; 278  : 	GC.getIgnoreUnitsPathFinder().SetMPCacheSafe(bIgnoreUnitsPathFinderMPCaching);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ ; CvGlobals::getIgnoreUnitsPathFinder
	mov	DWORD PTR $T229265[ebp], eax
	mov	edx, DWORD PTR $T229265[ebp]
	mov	al, BYTE PTR [edx+79]
	mov	BYTE PTR _bOldState$229262[ebp], al
	movzx	ecx, BYTE PTR _bIgnoreUnitsPathFinderMPCaching$[ebp]
	mov	edx, DWORD PTR $T229265[ebp]
	movzx	eax, BYTE PTR [edx+79]
	cmp	ecx, eax
	je	SHORT $LN51@AI_unitUpd
	mov	ecx, DWORD PTR $T229265[ebp]
	mov	BYTE PTR [ecx+78], 1
	mov	edx, DWORD PTR $T229265[ebp]
	mov	al, BYTE PTR _bIgnoreUnitsPathFinderMPCaching$[ebp]
	mov	BYTE PTR [edx+79], al
$LN51@AI_unitUpd:

; 279  : 	GC.GetTacticalAnalysisMapFinder().SetMPCacheSafe(bTacticalPathFinderMPCaching);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetTacticalAnalysisMapFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::GetTacticalAnalysisMapFinder
	mov	DWORD PTR $T229271[ebp], eax
	mov	ecx, DWORD PTR $T229271[ebp]
	mov	dl, BYTE PTR [ecx+79]
	mov	BYTE PTR _bOldState$229268[ebp], dl
	movzx	eax, BYTE PTR _bTacticalPathFinderMPCaching$[ebp]
	mov	ecx, DWORD PTR $T229271[ebp]
	movzx	edx, BYTE PTR [ecx+79]
	cmp	eax, edx
	je	SHORT $LN54@AI_unitUpd
	mov	eax, DWORD PTR $T229271[ebp]
	mov	BYTE PTR [eax+78], 1
	mov	ecx, DWORD PTR $T229271[ebp]
	mov	dl, BYTE PTR _bTacticalPathFinderMPCaching$[ebp]
	mov	BYTE PTR [ecx+79], dl
$LN54@AI_unitUpd:

; 280  : 	GC.getInfluenceFinder().SetMPCacheSafe(bInfluencePathFinderMPCaching);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfluenceFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::getInfluenceFinder
	mov	DWORD PTR $T229277[ebp], eax
	mov	eax, DWORD PTR $T229277[ebp]
	mov	cl, BYTE PTR [eax+79]
	mov	BYTE PTR _bOldState$229274[ebp], cl
	movzx	edx, BYTE PTR _bInfluencePathFinderMPCaching$[ebp]
	mov	eax, DWORD PTR $T229277[ebp]
	movzx	ecx, BYTE PTR [eax+79]
	cmp	edx, ecx
	je	SHORT $LN57@AI_unitUpd
	mov	edx, DWORD PTR $T229277[ebp]
	mov	BYTE PTR [edx+78], 1
	mov	eax, DWORD PTR $T229277[ebp]
	mov	cl, BYTE PTR _bInfluencePathFinderMPCaching$[ebp]
	mov	BYTE PTR [eax+79], cl
$LN57@AI_unitUpd:

; 281  : 	GC.getRouteFinder().SetMPCacheSafe(bRoutePathFinderMPCaching);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::getRouteFinder
	mov	DWORD PTR $T229283[ebp], eax
	mov	edx, DWORD PTR $T229283[ebp]
	mov	al, BYTE PTR [edx+79]
	mov	BYTE PTR _bOldState$229280[ebp], al
	movzx	ecx, BYTE PTR _bRoutePathFinderMPCaching$[ebp]
	mov	edx, DWORD PTR $T229283[ebp]
	movzx	eax, BYTE PTR [edx+79]
	cmp	ecx, eax
	je	SHORT $LN60@AI_unitUpd
	mov	ecx, DWORD PTR $T229283[ebp]
	mov	BYTE PTR [ecx+78], 1
	mov	edx, DWORD PTR $T229283[ebp]
	mov	al, BYTE PTR _bRoutePathFinderMPCaching$[ebp]
	mov	BYTE PTR [edx+79], al
$LN60@AI_unitUpd:

; 282  : 	GC.GetWaterRouteFinder().SetMPCacheSafe(bWaterRoutePathFinderMPCaching);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetWaterRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetWaterRouteFinder
	mov	DWORD PTR $T229289[ebp], eax
	mov	ecx, DWORD PTR $T229289[ebp]
	mov	dl, BYTE PTR [ecx+79]
	mov	BYTE PTR _bOldState$229286[ebp], dl
	movzx	eax, BYTE PTR _bWaterRoutePathFinderMPCaching$[ebp]
	mov	ecx, DWORD PTR $T229289[ebp]
	movzx	edx, BYTE PTR [ecx+79]
	cmp	eax, edx
	je	SHORT $LN6@AI_unitUpd
	mov	eax, DWORD PTR $T229289[ebp]
	mov	BYTE PTR [eax+78], 1
	mov	ecx, DWORD PTR $T229289[ebp]
	mov	dl, BYTE PTR _bWaterRoutePathFinderMPCaching$[ebp]
	mov	BYTE PTR [ecx+79], dl
$LN6@AI_unitUpd:

; 283  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AI_unitUpdate@CvPlayerAI@@UAEXXZ$0:
	lea	ecx, DWORD PTR _args$225259[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__ehhandler$?AI_unitUpdate@CvPlayerAI@@UAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-160]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AI_unitUpdate@CvPlayerAI@@UAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?AI_unitUpdate@CvPlayerAI@@UAEXXZ ENDP			; CvPlayerAI::AI_unitUpdate
EXTRN	?DoCreatePuppet@CvCity@@QAEXXZ:PROC		; CvCity::DoCreatePuppet
EXTRN	?doTask@CvCity@@QAE?AW4CityTaskResult@@W4TaskTypes@@HH_N111@Z:PROC ; CvCity::doTask
EXTRN	?getGameTurn@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurn
EXTRN	?getNumCities@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getNumCities
EXTRN	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ:PROC ; CvPlayer::GetPlayerTraits
EXTRN	?GetAIMapHint@CvMap@@QAEHXZ:PROC		; CvMap::GetAIMapHint
EXTRN	?IsEmpireUnhappy@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::IsEmpireUnhappy
EXTRN	?canRaze@CvPlayer@@QBE_NPAVCvCity@@_N@Z:PROC	; CvPlayer::canRaze
EXTRN	?DoLiberatePlayer@CvPlayer@@QAEXW4PlayerTypes@@H@Z:PROC ; CvPlayer::DoLiberatePlayer
EXTRN	?IsGoingForDiploVictory@CvDiplomacyAI@@QAE_NXZ:PROC ; CvDiplomacyAI::IsGoingForDiploVictory
EXTRN	?IsDoFAccepted@CvDiplomacyAI@@QBE_NW4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::IsDoFAccepted
EXTRN	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC	; CvTeam::isAtWar
EXTRN	?IsHasDefensivePact@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC ; CvTeam::IsHasDefensivePact
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
EXTRN	?DoPossibleMinorLiberation@CvDiplomacyAI@@QAE_NW4PlayerTypes@@H@Z:PROC ; CvDiplomacyAI::DoPossibleMinorLiberation
EXTRN	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ:PROC ; CvPlayer::GetDiplomacyAI
EXTRN	?CanLiberatePlayerCity@CvPlayer@@QAE_NW4PlayerTypes@@@Z:PROC ; CvPlayer::CanLiberatePlayerCity
EXTRN	?getOriginalOwner@CvCity@@QBE?AW4PlayerTypes@@XZ:PROC ; CvCity::getOriginalOwner
; Function compile flags: /Odtp
;	COMDAT ?AI_conquerCity@CvPlayerAI@@UAEXPAVCvCity@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -108						; size = 4
$T229433 = -101						; size = 1
$T229432 = -100						; size = 4
$T229428 = -96						; size = 4
$T229421 = -92						; size = 4
$T229412 = -88						; size = 4
$T229408 = -84						; size = 4
$T229407 = -80						; size = 4
$T229403 = -76						; size = 4
$T229399 = -72						; size = 4
$T229390 = -68						; size = 4
$T229386 = -64						; size = 4
$T229382 = -60						; size = 4
$T229378 = -56						; size = 4
$T229369 = -52						; size = 4
$T229365 = -48						; size = 4
$T229348 = -44						; size = 4
$T229344 = -37						; size = 1
$T229335 = -36						; size = 4
$T229331 = -32						; size = 4
$T229322 = -28						; size = 4
$T229318 = -24						; size = 4
$T229301 = -20						; size = 4
_eOriginalOwnerTeam$225280 = -16			; size = 4
_bLiberate$225278 = -9					; size = 1
_eOldOwnerTeam$ = -8					; size = 4
_eOriginalOwner$ = -4					; size = 4
_pCity$ = 8						; size = 4
_eOldOwner$ = 12					; size = 4
?AI_conquerCity@CvPlayerAI@@UAEXPAVCvCity@@W4PlayerTypes@@@Z PROC ; CvPlayerAI::AI_conquerCity, COMDAT
; _this$ = ecx

; 287  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 288  : 	PlayerTypes eOriginalOwner = pCity->getOriginalOwner();

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getOriginalOwner@CvCity@@QBE?AW4PlayerTypes@@XZ ; CvCity::getOriginalOwner
	mov	DWORD PTR _eOriginalOwner$[ebp], eax

; 289  : 	TeamTypes eOldOwnerTeam = GET_PLAYER(eOldOwner).getTeam();

	mov	eax, DWORD PTR _eOldOwner$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T229301[ebp], eax
	mov	ecx, DWORD PTR $T229301[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eOldOwnerTeam$[ebp], eax

; 290  : 
; 291  : 	// Liberate a city?
; 292  : 	if(eOriginalOwner != eOldOwner && eOriginalOwner != GetID() && CanLiberatePlayerCity(eOriginalOwner))

	mov	eax, DWORD PTR _eOriginalOwner$[ebp]
	cmp	eax, DWORD PTR _eOldOwner$[ebp]
	je	$LN16@AI_conquer
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T229318[ebp], edx
	mov	eax, DWORD PTR _eOriginalOwner$[ebp]
	cmp	eax, DWORD PTR $T229318[ebp]
	je	$LN16@AI_conquer
	mov	ecx, DWORD PTR _eOriginalOwner$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CanLiberatePlayerCity@CvPlayer@@QAE_NW4PlayerTypes@@@Z ; CvPlayer::CanLiberatePlayerCity
	movzx	edx, al
	test	edx, edx
	je	$LN16@AI_conquer

; 293  : 	{
; 294  : 		// minor civ
; 295  : 		if(GET_PLAYER(eOriginalOwner).isMinorCiv())

	mov	eax, DWORD PTR _eOriginalOwner$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T229322[ebp], eax
	mov	ecx, DWORD PTR $T229322[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN15@AI_conquer

; 296  : 		{
; 297  : 			if(GetDiplomacyAI()->DoPossibleMinorLiberation(eOriginalOwner, pCity->GetID()))

	mov	edx, DWORD PTR _pCity$[ebp]
	mov	eax, DWORD PTR [edx+120]
	mov	DWORD PTR $T229331[ebp], eax
	mov	ecx, DWORD PTR $T229331[ebp]
	push	ecx
	mov	edx, DWORD PTR _eOriginalOwner$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?DoPossibleMinorLiberation@CvDiplomacyAI@@QAE_NW4PlayerTypes@@H@Z ; CvDiplomacyAI::DoPossibleMinorLiberation
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN14@AI_conquer

; 298  : 				return;

	jmp	$LN17@AI_conquer
$LN14@AI_conquer:

; 299  : 		}
; 300  : 		else // major civ

	jmp	$LN16@AI_conquer
$LN15@AI_conquer:

; 301  : 		{
; 302  : 			bool bLiberate = false;

	mov	BYTE PTR _bLiberate$225278[ebp], 0

; 303  : 			if (GET_PLAYER(eOriginalOwner).isAlive())

	mov	ecx, DWORD PTR _eOriginalOwner$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T229335[ebp], ecx
	mov	edx, DWORD PTR $T229335[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T229344[ebp], al
	movzx	ecx, BYTE PTR $T229344[ebp]
	test	ecx, ecx
	je	$LN12@AI_conquer

; 304  : 			{
; 305  : 				// If the original owner and this player have a defensive pact
; 306  : 				// and both the original owner and the player are at war with the old owner of this city
; 307  : 				// give the city back to the original owner
; 308  : 				TeamTypes eOriginalOwnerTeam = GET_PLAYER(eOriginalOwner).getTeam();

	mov	edx, DWORD PTR _eOriginalOwner$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T229348[ebp], edx
	mov	eax, DWORD PTR $T229348[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eOriginalOwnerTeam$225280[ebp], eax

; 309  : 				if (GET_TEAM(getTeam()).IsHasDefensivePact(eOriginalOwnerTeam) && GET_TEAM(getTeam()).isAtWar(eOldOwnerTeam) && GET_TEAM(eOriginalOwnerTeam).isAtWar(eOldOwnerTeam))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T229365[ebp], eax
	mov	ecx, DWORD PTR $T229365[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T229369[ebp], ecx
	mov	edx, DWORD PTR _eOriginalOwnerTeam$225280[ebp]
	push	edx
	mov	ecx, DWORD PTR $T229369[ebp]
	call	?IsHasDefensivePact@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsHasDefensivePact
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN11@AI_conquer
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T229378[ebp], eax
	mov	eax, DWORD PTR $T229378[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T229382[ebp], eax
	mov	ecx, DWORD PTR _eOldOwnerTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T229382[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN11@AI_conquer
	mov	eax, DWORD PTR _eOriginalOwnerTeam$225280[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T229386[ebp], eax
	mov	ecx, DWORD PTR _eOldOwnerTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T229386[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN11@AI_conquer

; 310  : 				{
; 311  : 					bLiberate = true;

	mov	BYTE PTR _bLiberate$225278[ebp], 1
	jmp	SHORT $LN10@AI_conquer
$LN11@AI_conquer:

; 312  : 				}
; 313  : 				// if the player is a friend and we're going for diplo victory, then liberate to score some friend points
; 314  : 				else if (GetDiplomacyAI()->IsDoFAccepted(eOriginalOwner) && GetDiplomacyAI()->IsGoingForDiploVictory())

	mov	eax, DWORD PTR _eOriginalOwner$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsDoFAccepted@CvDiplomacyAI@@QBE_NW4PlayerTypes@@@Z ; CvDiplomacyAI::IsDoFAccepted
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN10@AI_conquer
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsGoingForDiploVictory@CvDiplomacyAI@@QAE_NXZ ; CvDiplomacyAI::IsGoingForDiploVictory
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN10@AI_conquer

; 315  : 				{
; 316  : 					bLiberate = true;

	mov	BYTE PTR _bLiberate$225278[ebp], 1
$LN10@AI_conquer:

; 317  : 				}
; 318  : 			}

	jmp	SHORT $LN8@AI_conquer
$LN12@AI_conquer:

; 319  : 			// if the player isn't human and we're going for diplo victory, resurrect players to get super diplo bonuses
; 320  : 			else if (!GET_PLAYER(eOriginalOwner).isHuman() && GetDiplomacyAI()->IsGoingForDiploVictory())

	mov	eax, DWORD PTR _eOriginalOwner$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T229390[ebp], eax
	mov	ecx, DWORD PTR $T229390[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN8@AI_conquer
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsGoingForDiploVictory@CvDiplomacyAI@@QAE_NXZ ; CvDiplomacyAI::IsGoingForDiploVictory
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN8@AI_conquer

; 321  : 			{
; 322  : 				bLiberate = true;

	mov	BYTE PTR _bLiberate$225278[ebp], 1
$LN8@AI_conquer:

; 323  : 			}
; 324  : 
; 325  : 			if (bLiberate)

	movzx	eax, BYTE PTR _bLiberate$225278[ebp]
	test	eax, eax
	je	SHORT $LN16@AI_conquer

; 326  : 			{
; 327  : 				DoLiberatePlayer(eOriginalOwner, pCity->GetID());

	mov	ecx, DWORD PTR _pCity$[ebp]
	mov	edx, DWORD PTR [ecx+120]
	mov	DWORD PTR $T229399[ebp], edx
	mov	eax, DWORD PTR $T229399[ebp]
	push	eax
	mov	ecx, DWORD PTR _eOriginalOwner$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoLiberatePlayer@CvPlayer@@QAEXW4PlayerTypes@@H@Z ; CvPlayer::DoLiberatePlayer

; 328  : 				return;

	jmp	$LN17@AI_conquer
$LN16@AI_conquer:

; 329  : 			}
; 330  : 		}
; 331  : 	}
; 332  : 
; 333  : 	// Do we want to burn this city down?
; 334  : 	if(canRaze(pCity))

	push	0
	mov	edx, DWORD PTR _pCity$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?canRaze@CvPlayer@@QBE_NPAVCvCity@@_N@Z	; CvPlayer::canRaze
	movzx	eax, al
	test	eax, eax
	je	$LN75@AI_conquer

; 335  : 	{
; 336  : 		// Burn the city if the empire is unhappy - keeping the city will only make things worse or if map hint dictates
; 337  : 		// Huns will burn down everything possible once they have a core of a few cities (was 3, but this put Attila out of the running long term as a conqueror)
; 338  : 		if (IsEmpireUnhappy() || (GC.getMap().GetAIMapHint() & 2) || (GetPlayerTraits()->GetRazeSpeedModifier() > 0 && getNumCities() >= 3 + (GC.getGame().getGameTurn() / 100)) )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsEmpireUnhappy@CvPlayer@@QBE_NXZ	; CvPlayer::IsEmpireUnhappy
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@AI_conquer
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T229403[ebp], edx
	mov	ecx, DWORD PTR $T229403[ebp]
	call	?GetAIMapHint@CvMap@@QAEHXZ		; CvMap::GetAIMapHint
	and	eax, 2
	jne	SHORT $LN3@AI_conquer
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T229407[ebp], eax
	mov	eax, DWORD PTR $T229407[ebp]
	mov	ecx, DWORD PTR [eax+256]
	mov	DWORD PTR $T229408[ebp], ecx
	cmp	DWORD PTR $T229408[ebp], 0
	jle	SHORT $LN75@AI_conquer
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T229412[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	mov	esi, eax
	mov	ecx, DWORD PTR $T229412[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	add	eax, 3
	cmp	esi, eax
	jl	SHORT $LN75@AI_conquer
$LN3@AI_conquer:

; 339  : 		{
; 340  : 			pCity->doTask(TASK_RAZE);

	push	0
	push	0
	push	0
	push	0
	push	-1
	push	-1
	push	0
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?doTask@CvCity@@QAE?AW4CityTaskResult@@W4TaskTypes@@HH_N111@Z ; CvCity::doTask

; 341  : 			return;

	jmp	SHORT $LN17@AI_conquer

; 342  : 		}
; 343  : 	}
; 344  : 
; 345  : 	// Puppet the city
; 346  : 	if(pCity->getOriginalOwner() != GetID() || GET_PLAYER(m_eID).GetPlayerTraits()->IsNoAnnexing())

$LN75@AI_conquer:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T229421[ebp], eax
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getOriginalOwner@CvCity@@QBE?AW4PlayerTypes@@XZ ; CvCity::getOriginalOwner
	cmp	eax, DWORD PTR $T229421[ebp]
	jne	SHORT $LN1@AI_conquer
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T229428[ebp], edx
	mov	ecx, DWORD PTR $T229428[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T229432[ebp], eax
	mov	eax, DWORD PTR $T229432[ebp]
	mov	cl, BYTE PTR [eax+351]
	mov	BYTE PTR $T229433[ebp], cl
	movzx	edx, BYTE PTR $T229433[ebp]
	test	edx, edx
	je	SHORT $LN17@AI_conquer
$LN1@AI_conquer:

; 347  : 	{
; 348  : #ifdef AUI_CITIZENS_MID_TURN_ASSIGN_RUNS_SELF_CONSISTENCY
; 349  : 		pCity->DoCreatePuppet(false);
; 350  : #else
; 351  : 		pCity->DoCreatePuppet();

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?DoCreatePuppet@CvCity@@QAEXXZ		; CvCity::DoCreatePuppet
$LN17@AI_conquer:

; 352  : #endif
; 353  : 	}
; 354  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?AI_conquerCity@CvPlayerAI@@UAEXPAVCvCity@@W4PlayerTypes@@@Z ENDP ; CvPlayerAI::AI_conquerCity
_TEXT	ENDS
PUBLIC	?plotDistance@@YAHHHHH@Z			; plotDistance
PUBLIC	?AI_captureUnit@CvPlayerAI@@QAE_NW4UnitTypes@@PAVCvPlot@@@Z ; CvPlayerAI::AI_captureUnit
EXTRN	?findCity@CvMap@@QAEPAVCvCity@@HHW4PlayerTypes@@W4TeamTypes@@_N21W4DirectionTypes@@PBV2@@Z:PROC ; CvMap::findCity
EXTRN	?IsFriendlyTerritory@CvPlot@@QBE_NW4PlayerTypes@@@Z:PROC ; CvPlot::IsFriendlyTerritory
; Function compile flags: /Odtp
;	COMDAT ?AI_captureUnit@CvPlayerAI@@QAE_NW4UnitTypes@@PAVCvPlot@@@Z
_TEXT	SEGMENT
_this$ = -224						; size = 4
$T229620 = -140						; size = 4
$T229616 = -136						; size = 4
$T229612 = -132						; size = 4
$T229603 = -128						; size = 4
$T229594 = -124						; size = 4
$T229590 = -120						; size = 4
$T229586 = -116						; size = 4
$T229533 = -56						; size = 4
$T229529 = -52						; size = 4
$T229525 = -48						; size = 4
$T229516 = -44						; size = 4
$T229507 = -40						; size = 4
$T229503 = -36						; size = 4
$T229499 = -32						; size = 4
$T229495 = -28						; size = 4
$T229486 = -24						; size = 4
$T229477 = -20						; size = 4
_playerID$229474 = -16					; size = 4
$T229452 = -12						; size = 4
_playerID$229449 = -8					; size = 4
_pNearestCity$ = -4					; size = 4
___formal$ = 8						; size = 4
_pPlot$ = 12						; size = 4
?AI_captureUnit@CvPlayerAI@@QAE_NW4UnitTypes@@PAVCvPlot@@@Z PROC ; CvPlayerAI::AI_captureUnit, COMDAT
; _this$ = ecx

; 357  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 224				; 000000e0H
	mov	DWORD PTR _this$[ebp], ecx

; 358  : 	CvCity* pNearestCity;
; 359  : 
; 360  : 	CvAssert(!isHuman());
; 361  : 
; 362  : 	// Barbs always capture
; 363  : 	if (isBarbarian())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN15@AI_capture

; 364  : 		return true;

	mov	al, 1
	jmp	$LN9@AI_capture

; 365  : 
; 366  : 	// we own it
; 367  : 	if (pPlot->getTeam() == getTeam())

$LN15@AI_capture:
	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR _playerID$229449[ebp], edx
	cmp	DWORD PTR _playerID$229449[ebp], -1
	je	SHORT $LN12@AI_capture
	mov	eax, DWORD PTR _playerID$229449[ebp]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T229452[ebp], eax
	jmp	SHORT $LN19@AI_capture
	jmp	SHORT $LN19@AI_capture
$LN12@AI_capture:
	mov	DWORD PTR $T229452[ebp], -1
$LN19@AI_capture:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	DWORD PTR $T229452[ebp], eax
	jne	SHORT $LN27@AI_capture

; 368  : 		return true;

	mov	al, 1
	jmp	$LN9@AI_capture

; 369  : 
; 370  : 	// no man's land - may as well
; 371  : 	if (pPlot->getTeam() == NO_TEAM)

$LN27@AI_capture:
	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR _playerID$229474[ebp], ecx
	cmp	DWORD PTR _playerID$229474[ebp], -1
	je	SHORT $LN24@AI_capture
	mov	edx, DWORD PTR _playerID$229474[ebp]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T229477[ebp], eax
	jmp	SHORT $LN25@AI_capture
	jmp	SHORT $LN25@AI_capture
$LN24@AI_capture:
	mov	DWORD PTR $T229477[ebp], -1
$LN25@AI_capture:
	cmp	DWORD PTR $T229477[ebp], -1
	jne	SHORT $LN33@AI_capture

; 372  : 		return true;

	mov	al, 1
	jmp	$LN9@AI_capture

; 373  : 
; 374  : 	// friendly, sure (okay, this is pretty much just means open borders)
; 375  : 	if (pPlot->IsFriendlyTerritory(GetID()))

$LN33@AI_capture:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T229486[ebp], ecx
	mov	edx, DWORD PTR $T229486[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?IsFriendlyTerritory@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::IsFriendlyTerritory
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN37@AI_capture

; 376  : 		return true;

	mov	al, 1
	jmp	$LN9@AI_capture

; 377  : 
; 378  : 	// not friendly, but "near" us
; 379  : 	pNearestCity = GC.getMap().findCity(pPlot->getX(), pPlot->getY(), NO_PLAYER, getTeam());

$LN37@AI_capture:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T229495[ebp], eax
	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T229499[ebp], ecx
	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T229503[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T229507[ebp], ecx
	push	0
	push	-1
	push	-1
	push	0
	push	1
	mov	edx, DWORD PTR $T229495[ebp]
	push	edx
	push	-1
	mov	eax, DWORD PTR $T229499[ebp]
	push	eax
	mov	ecx, DWORD PTR $T229503[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T229507[ebp]
	call	?findCity@CvMap@@QAEPAVCvCity@@HHW4PlayerTypes@@W4TeamTypes@@_N21W4DirectionTypes@@PBV2@@Z ; CvMap::findCity
	mov	DWORD PTR _pNearestCity$[ebp], eax

; 380  : 	if (pNearestCity != NULL)

	cmp	DWORD PTR _pNearestCity$[ebp], 0
	je	SHORT $LN4@AI_capture

; 381  : 	{
; 382  : 		if (plotDistance(pPlot->getX(), pPlot->getY(), pNearestCity->getX(), pNearestCity->getY()) <= 7)

	mov	edx, DWORD PTR _pNearestCity$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR $T229516[ebp], eax
	mov	ecx, DWORD PTR _pNearestCity$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR $T229525[ebp], edx
	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T229529[ebp], ecx
	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T229533[ebp], eax
	mov	ecx, DWORD PTR $T229516[ebp]
	push	ecx
	mov	edx, DWORD PTR $T229525[ebp]
	push	edx
	mov	eax, DWORD PTR $T229529[ebp]
	push	eax
	mov	ecx, DWORD PTR $T229533[ebp]
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, 7
	jg	SHORT $LN4@AI_capture

; 383  : 			return true;

	mov	al, 1
	jmp	$LN9@AI_capture
$LN4@AI_capture:

; 384  : 	}
; 385  : 
; 386  : 	// very near someone we aren't friends with (and far from our nearest city)
; 387  : 	pNearestCity = GC.getMap().findCity(pPlot->getX(), pPlot->getY());

	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T229586[ebp], eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T229590[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T229594[ebp], eax
	push	0
	push	-1
	push	-1
	push	0
	push	1
	push	-1
	push	-1
	mov	ecx, DWORD PTR $T229586[ebp]
	push	ecx
	mov	edx, DWORD PTR $T229590[ebp]
	push	edx
	mov	ecx, DWORD PTR $T229594[ebp]
	call	?findCity@CvMap@@QAEPAVCvCity@@HHW4PlayerTypes@@W4TeamTypes@@_N21W4DirectionTypes@@PBV2@@Z ; CvMap::findCity
	mov	DWORD PTR _pNearestCity$[ebp], eax

; 388  : 	if (pNearestCity != NULL)

	cmp	DWORD PTR _pNearestCity$[ebp], 0
	je	SHORT $LN2@AI_capture

; 389  : 	{
; 390  : 		if (plotDistance(pPlot->getX(), pPlot->getY(), pNearestCity->getX(), pNearestCity->getY()) <= 4)

	mov	eax, DWORD PTR _pNearestCity$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR $T229603[ebp], ecx
	mov	edx, DWORD PTR _pNearestCity$[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR $T229612[ebp], eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T229616[ebp], edx
	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T229620[ebp], ecx
	mov	edx, DWORD PTR $T229603[ebp]
	push	edx
	mov	eax, DWORD PTR $T229612[ebp]
	push	eax
	mov	ecx, DWORD PTR $T229616[ebp]
	push	ecx
	mov	edx, DWORD PTR $T229620[ebp]
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, 4
	jg	SHORT $LN2@AI_capture

; 391  : 			return false;

	xor	al, al
	jmp	SHORT $LN9@AI_capture
$LN2@AI_capture:

; 392  : 	}
; 393  : 
; 394  : 	// I'd rather we grab it and run than destroy it
; 395  : 	return true;

	mov	al, 1
$LN9@AI_capture:

; 396  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?AI_captureUnit@CvPlayerAI@@QAE_NW4UnitTypes@@PAVCvPlot@@@Z ENDP ; CvPlayerAI::AI_captureUnit
_TEXT	ENDS
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDistance@@YAHHHHH@Z
_TEXT	SEGMENT
tv157 = -92						; size = 4
tv138 = -88						; size = 4
tv135 = -84						; size = 4
$T229789 = -80						; size = 4
$T229762 = -60						; size = 4
_iDY$ = -24						; size = 4
_iDX$ = -20						; size = 4
_iWrappedDX$ = -16					; size = 4
_iHX1$ = -12						; size = 4
_iHX2$ = -8						; size = 4
_iWrappedDY$ = -4					; size = 4
_iX1$ = 8						; size = 4
_iY1$ = 12						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?plotDistance@@YAHHHHH@Z PROC				; plotDistance, COMDAT

; 144  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH

; 145  : 	int iDX;
; 146  : 	int iWrappedDX = dxWrap(iX2 - iX1);

	mov	eax, DWORD PTR _iX2$[ebp]
	sub	eax, DWORD PTR _iX1$[ebp]
	push	eax
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedDX$[ebp], eax

; 147  : 	int iWrappedDY = dyWrap(iY2 - iY1);

	mov	ecx, DWORD PTR _iY2$[ebp]
	sub	ecx, DWORD PTR _iY1$[ebp]
	push	ecx
	call	?dyWrap@@YAHH@Z				; dyWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedDY$[ebp], eax

; 148  : 	int iDY = abs(iWrappedDY);

	mov	eax, DWORD PTR _iWrappedDY$[ebp]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDY$[ebp], eax

; 149  : 
; 150  : 	// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 151  : 	int iHX1 = xToHexspaceX(iX1, iY1);

	cmp	DWORD PTR _iY1$[ebp], 0
	jl	SHORT $LN35@plotDistan
	mov	edx, DWORD PTR _iY1$[ebp]
	sar	edx, 1
	mov	DWORD PTR tv135[ebp], edx
	jmp	SHORT $LN33@plotDistan
$LN35@plotDistan:
	mov	eax, DWORD PTR _iY1$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv135[ebp], eax
$LN33@plotDistan:
	mov	eax, DWORD PTR _iX1$[ebp]
	sub	eax, DWORD PTR tv135[ebp]
	mov	DWORD PTR _iHX1$[ebp], eax

; 152  : 	int iHX2 = xToHexspaceX(iX1 + iWrappedDX, iY1 + iWrappedDY);

	mov	ecx, DWORD PTR _iY1$[ebp]
	add	ecx, DWORD PTR _iWrappedDY$[ebp]
	mov	DWORD PTR $T229762[ebp], ecx
	js	SHORT $LN39@plotDistan
	mov	edx, DWORD PTR $T229762[ebp]
	sar	edx, 1
	mov	DWORD PTR tv138[ebp], edx
	jmp	SHORT $LN37@plotDistan
$LN39@plotDistan:
	mov	eax, DWORD PTR $T229762[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv138[ebp], eax
$LN37@plotDistan:
	mov	eax, DWORD PTR _iX1$[ebp]
	add	eax, DWORD PTR _iWrappedDX$[ebp]
	sub	eax, DWORD PTR tv138[ebp]
	mov	DWORD PTR _iHX2$[ebp], eax

; 153  : 
; 154  : 	iDX = abs(dxWrap(iHX2 - iHX1));

	mov	ecx, DWORD PTR _iHX2$[ebp]
	sub	ecx, DWORD PTR _iHX1$[ebp]
	push	ecx
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDX$[ebp], eax

; 155  : 
; 156  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 157  : 	if (((iHX2 - iHX1) ^ (iWrappedDY)) >= 0)  // the signs match
; 158  : #else
; 159  : 	if((iHX2 - iHX1 >= 0) == (iWrappedDY >= 0))  // the signs match

	mov	edx, DWORD PTR _iHX2$[ebp]
	sub	edx, DWORD PTR _iHX1$[ebp]
	xor	eax, eax
	test	edx, edx
	setge	al
	xor	ecx, ecx
	cmp	DWORD PTR _iWrappedDY$[ebp], 0
	setge	cl
	cmp	eax, ecx
	jne	SHORT $LN2@plotDistan

; 160  : #endif
; 161  : 	{
; 162  : 		return iDX + iDY;

	mov	eax, DWORD PTR _iDX$[ebp]
	add	eax, DWORD PTR _iDY$[ebp]
	jmp	SHORT $LN3@plotDistan

; 163  : 	}
; 164  : 	else

	jmp	SHORT $LN3@plotDistan
$LN2@plotDistan:

; 165  : 	{
; 166  : #ifdef NQM_FAST_COMP
; 167  : 		return (MAX(iDX, iDY));
; 168  : #else
; 169  : 		return (std::max(iDX, iDY));

	mov	edx, DWORD PTR _iDX$[ebp]
	cmp	edx, DWORD PTR _iDY$[ebp]
	jge	SHORT $LN57@plotDistan
	lea	eax, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv157[ebp], eax
	jmp	SHORT $LN58@plotDistan
$LN57@plotDistan:
	lea	ecx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv157[ebp], ecx
$LN58@plotDistan:
	mov	edx, DWORD PTR tv157[ebp]
	mov	DWORD PTR $T229789[ebp], edx
	mov	eax, DWORD PTR $T229789[ebp]
	mov	eax, DWORD PTR [eax]
$LN3@plotDistan:

; 170  : #endif
; 171  : 	}
; 172  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotDistance@@YAHHHHH@Z ENDP				; plotDistance
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
$T229812 = -16						; size = 4
$T229804 = -12						; size = 4
$T229800 = -5						; size = 1
_kMap$ = -4						; size = 4
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T229800[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T229804[ebp], ecx
	movzx	edx, BYTE PTR $T229800[ebp]
	test	edx, edx
	je	SHORT $LN12@dxWrap
	mov	eax, DWORD PTR $T229804[ebp]
	shr	eax, 1
	cmp	DWORD PTR _iDX$[ebp], eax
	jle	SHORT $LN11@dxWrap
	mov	ecx, DWORD PTR _iDX$[ebp]
	sub	ecx, DWORD PTR $T229804[ebp]
	mov	DWORD PTR $T229812[ebp], ecx
	jmp	SHORT $LN13@dxWrap
	jmp	SHORT $LN12@dxWrap
$LN11@dxWrap:
	mov	edx, DWORD PTR $T229804[ebp]
	shr	edx, 1
	neg	edx
	cmp	DWORD PTR _iDX$[ebp], edx
	jge	SHORT $LN12@dxWrap
	mov	eax, DWORD PTR _iDX$[ebp]
	add	eax, DWORD PTR $T229804[ebp]
	mov	DWORD PTR $T229812[ebp], eax
	jmp	SHORT $LN13@dxWrap
$LN12@dxWrap:
	mov	ecx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR $T229812[ebp], ecx
$LN13@dxWrap:
	mov	eax, DWORD PTR $T229812[ebp]

; 76   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
$T229833 = -16						; size = 4
$T229825 = -12						; size = 4
$T229821 = -5						; size = 1
_kMap$ = -4						; size = 4
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 79   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T229821[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T229825[ebp], ecx
	movzx	edx, BYTE PTR $T229821[ebp]
	test	edx, edx
	je	SHORT $LN12@dyWrap
	mov	eax, DWORD PTR $T229825[ebp]
	shr	eax, 1
	cmp	DWORD PTR _iDY$[ebp], eax
	jle	SHORT $LN11@dyWrap
	mov	ecx, DWORD PTR _iDY$[ebp]
	sub	ecx, DWORD PTR $T229825[ebp]
	mov	DWORD PTR $T229833[ebp], ecx
	jmp	SHORT $LN13@dyWrap
	jmp	SHORT $LN12@dyWrap
$LN11@dyWrap:
	mov	edx, DWORD PTR $T229825[ebp]
	shr	edx, 1
	neg	edx
	cmp	DWORD PTR _iDY$[ebp], edx
	jge	SHORT $LN12@dyWrap
	mov	eax, DWORD PTR _iDY$[ebp]
	add	eax, DWORD PTR $T229825[ebp]
	mov	DWORD PTR $T229833[ebp], eax
	jmp	SHORT $LN13@dyWrap
$LN12@dyWrap:
	mov	ecx, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR $T229833[ebp], ecx
$LN13@dyWrap:
	mov	eax, DWORD PTR $T229833[ebp]

; 82   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
_TEXT	ENDS
EXTRN	?GetStartSiteEvaluator@CvGame@@QAEPAVCvSiteEvaluatorForStart@@XZ:PROC ; CvGame::GetStartSiteEvaluator
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.cpp
;	COMDAT ?AI_foundValue@CvPlayerAI@@UAEHHHH_N@Z
_TEXT	SEGMENT
tv151 = -84						; size = 4
tv134 = -80						; size = 4
tv81 = -76						; size = 4
tv193 = -72						; size = 4
tv208 = -68						; size = 4
_this$ = -64						; size = 4
$T229952 = -60						; size = 4
$T229948 = -56						; size = 4
$T229944 = -52						; size = 4
$T229896 = -48						; size = 4
$T229883 = -44						; size = 4
$T229879 = -40						; size = 4
$T229865 = -36						; size = 4
$T229861 = -29						; size = 1
$T229850 = -28						; size = 4
$T229846 = -21						; size = 1
_iMapY$229940 = -20					; size = 4
_iMapX$229939 = -16					; size = 4
$T229839 = -12						; size = 4
_pPlot$ = -8						; size = 4
_rtnValue$ = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
___formal$ = 16						; size = 4
_bStartingLoc$ = 20					; size = 1
?AI_foundValue@CvPlayerAI@@UAEHHHH_N@Z PROC		; CvPlayerAI::AI_foundValue, COMDAT
; _this$ = ecx

; 399  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	DWORD PTR _this$[ebp], ecx

; 400  : 
; 401  : 	CvPlot* pPlot;
; 402  : 	int rtnValue = 0;

	mov	DWORD PTR _rtnValue$[ebp], 0

; 403  : 
; 404  : 	pPlot = GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T229839[ebp], eax
	cmp	DWORD PTR _iX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN7@AI_foundVa
	cmp	DWORD PTR _iY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN8@AI_foundVa
$LN7@AI_foundVa:
	mov	DWORD PTR _pPlot$[ebp], 0
	jmp	$LN9@AI_foundVa
$LN8@AI_foundVa:
	mov	ecx, DWORD PTR $T229839[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T229846[ebp], dl
	mov	eax, DWORD PTR $T229839[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T229850[ebp], ecx
	movzx	edx, BYTE PTR $T229846[ebp]
	test	edx, edx
	je	SHORT $LN20@AI_foundVa
	cmp	DWORD PTR _iX$[ebp], 0
	jge	SHORT $LN19@AI_foundVa
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T229850[ebp]
	add	edx, DWORD PTR $T229850[ebp]
	mov	DWORD PTR _iMapX$229939[ebp], edx
	jmp	SHORT $LN21@AI_foundVa
	jmp	SHORT $LN20@AI_foundVa
$LN19@AI_foundVa:
	mov	eax, DWORD PTR _iX$[ebp]
	cmp	eax, DWORD PTR $T229850[ebp]
	jl	SHORT $LN20@AI_foundVa
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T229850[ebp]
	mov	DWORD PTR _iMapX$229939[ebp], edx
	jmp	SHORT $LN21@AI_foundVa
$LN20@AI_foundVa:
	mov	ecx, DWORD PTR _iX$[ebp]
	mov	DWORD PTR _iMapX$229939[ebp], ecx
$LN21@AI_foundVa:
	mov	edx, DWORD PTR $T229839[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T229861[ebp], al
	mov	ecx, DWORD PTR $T229839[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T229865[ebp], edx
	movzx	eax, BYTE PTR $T229861[ebp]
	test	eax, eax
	je	SHORT $LN30@AI_foundVa
	cmp	DWORD PTR _iY$[ebp], 0
	jge	SHORT $LN29@AI_foundVa
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T229865[ebp]
	add	edx, DWORD PTR $T229865[ebp]
	mov	DWORD PTR _iMapY$229940[ebp], edx
	jmp	SHORT $LN31@AI_foundVa
	jmp	SHORT $LN30@AI_foundVa
$LN29@AI_foundVa:
	mov	ecx, DWORD PTR _iY$[ebp]
	cmp	ecx, DWORD PTR $T229865[ebp]
	jl	SHORT $LN30@AI_foundVa
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T229865[ebp]
	mov	DWORD PTR _iMapY$229940[ebp], edx
	jmp	SHORT $LN31@AI_foundVa
$LN30@AI_foundVa:
	mov	edx, DWORD PTR _iY$[ebp]
	mov	DWORD PTR _iMapY$229940[ebp], edx
$LN31@AI_foundVa:
	cmp	DWORD PTR _iMapX$229939[ebp], 0
	jl	SHORT $LN35@AI_foundVa
	mov	eax, DWORD PTR $T229839[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T229879[ebp], ecx
	mov	edx, DWORD PTR _iMapX$229939[ebp]
	cmp	edx, DWORD PTR $T229879[ebp]
	jge	SHORT $LN35@AI_foundVa
	cmp	DWORD PTR _iMapY$229940[ebp], 0
	jl	SHORT $LN35@AI_foundVa
	mov	eax, DWORD PTR $T229839[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T229883[ebp], ecx
	mov	edx, DWORD PTR _iMapY$229940[ebp]
	cmp	edx, DWORD PTR $T229883[ebp]
	jge	SHORT $LN35@AI_foundVa
	mov	DWORD PTR tv208[ebp], 1
	jmp	SHORT $LN33@AI_foundVa
$LN35@AI_foundVa:
	mov	DWORD PTR tv208[ebp], 0
$LN33@AI_foundVa:
	cmp	DWORD PTR tv208[ebp], 0
	je	SHORT $LN11@AI_foundVa
	mov	eax, DWORD PTR $T229839[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T229896[ebp], ecx
	mov	edx, DWORD PTR _iMapY$229940[ebp]
	imul	edx, DWORD PTR $T229896[ebp]
	add	edx, DWORD PTR _iMapX$229939[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T229839[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv193[ebp], edx
	jmp	SHORT $LN12@AI_foundVa
$LN11@AI_foundVa:
	mov	DWORD PTR tv193[ebp], 0
$LN12@AI_foundVa:
	mov	ecx, DWORD PTR tv193[ebp]
	mov	DWORD PTR _pPlot$[ebp], ecx
$LN9@AI_foundVa:

; 405  : 
; 406  : 	if(bStartingLoc)

	movzx	edx, BYTE PTR _bStartingLoc$[ebp]
	test	edx, edx
	je	SHORT $LN2@AI_foundVa

; 407  : 	{
; 408  : 		rtnValue =  GC.getGame().GetStartSiteEvaluator()->PlotFoundValue(pPlot, this);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T229944[ebp], eax
	mov	ecx, DWORD PTR $T229944[ebp]
	call	?GetStartSiteEvaluator@CvGame@@QAEPAVCvSiteEvaluatorForStart@@XZ ; CvGame::GetStartSiteEvaluator
	mov	DWORD PTR tv81[ebp], eax
	push	1
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pPlot$[ebp]
	push	edx
	mov	eax, DWORD PTR tv81[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv81[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _rtnValue$[ebp], eax

; 409  : 	}
; 410  : 	else

	jmp	SHORT $LN1@AI_foundVa
$LN2@AI_foundVa:

; 411  : 	{
; 412  : 		GC.getGame().GetSettlerSiteEvaluator()->ComputeFlavorMultipliers(this);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T229948[ebp], ecx
	mov	ecx, DWORD PTR $T229948[ebp]
	call	?GetSettlerSiteEvaluator@CvGame@@QAEPAVCvSiteEvaluatorForSettler@@XZ ; CvGame::GetSettlerSiteEvaluator
	mov	DWORD PTR tv134[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR tv134[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv134[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax

; 413  : 		rtnValue =  GC.getGame().GetSettlerSiteEvaluator()->PlotFoundValue(pPlot, this, NO_YIELD, false);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T229952[ebp], ecx
	mov	ecx, DWORD PTR $T229952[ebp]
	call	?GetSettlerSiteEvaluator@CvGame@@QAEPAVCvSiteEvaluatorForSettler@@XZ ; CvGame::GetSettlerSiteEvaluator
	mov	DWORD PTR tv151[ebp], eax
	push	0
	push	-1
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _pPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv151[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv151[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _rtnValue$[ebp], eax
$LN1@AI_foundVa:

; 414  : 	}
; 415  : 
; 416  : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[ebp]

; 417  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?AI_foundValue@CvPlayerAI@@UAEHHHH_N@Z ENDP		; CvPlayerAI::AI_foundValue
_TEXT	ENDS
PUBLIC	??_C@_0P@MKBOELIK@UNIT_SCIENTIST?$AA@		; `string'
PUBLIC	??_C@_0BK@CCPNHFB@AIGRANDSTRATEGY_SPACESHIP?$AA@ ; `string'
PUBLIC	??_C@_0O@HLOLPMBO@UNIT_MERCHANT?$AA@		; `string'
PUBLIC	??_C@_0BP@DOCBNDKB@AIGRANDSTRATEGY_UNITED_NATIONS?$AA@ ; `string'
PUBLIC	??_C@_0M@FNEDFKCL@UNIT_ARTIST?$AA@		; `string'
PUBLIC	??_C@_0BI@FNGLFDGI@AIGRANDSTRATEGY_CULTURE?$AA@	; `string'
PUBLIC	??_C@_0BD@CPBEDAAN@UNIT_GREAT_GENERAL?$AA@	; `string'
PUBLIC	??_C@_0BJ@GCKPAHPE@AIGRANDSTRATEGY_CONQUEST?$AA@ ; `string'
PUBLIC	??_C@_0O@FDAJPIMP@UNIT_ENGINEER?$AA@		; `string'
EXTRN	?ChangeNumFreeGreatPeople@CvPlayer@@QAEXH@Z:PROC ; CvPlayer::ChangeNumFreeGreatPeople
EXTRN	?DoSpawnGreatPerson@CvCityCitizens@@QAEXW4UnitTypes@@_N1@Z:PROC ; CvCityCitizens::DoSpawnGreatPerson
EXTRN	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ:PROC ; CvCity::GetCityCitizens
EXTRN	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ:PROC	; CvPlayer::getCapitalCity
EXTRN	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ:PROC ; CvGrandStrategyAI::GetActiveGrandStrategy
EXTRN	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ:PROC ; CvPlayer::GetGrandStrategyAI
EXTRN	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z:PROC ; CvGlobals::getInfoTypeForString
EXTRN	?getEstimateEndTurn@CvGame@@QBEHXZ:PROC		; CvGame::getEstimateEndTurn
EXTRN	?GetWonderCompetitiveness@CvDiplomacyAI@@QBEHXZ:PROC ; CvDiplomacyAI::GetWonderCompetitiveness
EXTRN	?GetNumFreeGreatPeople@CvPlayer@@QBEHXZ:PROC	; CvPlayer::GetNumFreeGreatPeople
;	COMDAT ??_C@_0P@MKBOELIK@UNIT_SCIENTIST?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
CONST	SEGMENT
??_C@_0P@MKBOELIK@UNIT_SCIENTIST?$AA@ DB 'UNIT_SCIENTIST', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CCPNHFB@AIGRANDSTRATEGY_SPACESHIP?$AA@
CONST	SEGMENT
??_C@_0BK@CCPNHFB@AIGRANDSTRATEGY_SPACESHIP?$AA@ DB 'AIGRANDSTRATEGY_SPAC'
	DB	'ESHIP', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HLOLPMBO@UNIT_MERCHANT?$AA@
CONST	SEGMENT
??_C@_0O@HLOLPMBO@UNIT_MERCHANT?$AA@ DB 'UNIT_MERCHANT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DOCBNDKB@AIGRANDSTRATEGY_UNITED_NATIONS?$AA@
CONST	SEGMENT
??_C@_0BP@DOCBNDKB@AIGRANDSTRATEGY_UNITED_NATIONS?$AA@ DB 'AIGRANDSTRATEG'
	DB	'Y_UNITED_NATIONS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FNEDFKCL@UNIT_ARTIST?$AA@
CONST	SEGMENT
??_C@_0M@FNEDFKCL@UNIT_ARTIST?$AA@ DB 'UNIT_ARTIST', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FNGLFDGI@AIGRANDSTRATEGY_CULTURE?$AA@
CONST	SEGMENT
??_C@_0BI@FNGLFDGI@AIGRANDSTRATEGY_CULTURE?$AA@ DB 'AIGRANDSTRATEGY_CULTU'
	DB	'RE', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CPBEDAAN@UNIT_GREAT_GENERAL?$AA@
CONST	SEGMENT
??_C@_0BD@CPBEDAAN@UNIT_GREAT_GENERAL?$AA@ DB 'UNIT_GREAT_GENERAL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@GCKPAHPE@AIGRANDSTRATEGY_CONQUEST?$AA@
CONST	SEGMENT
??_C@_0BJ@GCKPAHPE@AIGRANDSTRATEGY_CONQUEST?$AA@ DB 'AIGRANDSTRATEGY_CONQ'
	DB	'UEST', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FDAJPIMP@UNIT_ENGINEER?$AA@
CONST	SEGMENT
??_C@_0O@FDAJPIMP@UNIT_ENGINEER?$AA@ DB 'UNIT_ENGINEER', 00H ; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.cpp
CONST	ENDS
;	COMDAT ?AI_chooseFreeGreatPerson@CvPlayerAI@@UAEXXZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T229962 = -20						; size = 4
$T229958 = -16						; size = 4
_pCapital$225353 = -12					; size = 4
_eVictoryStrategy$225328 = -8				; size = 4
_eDesiredGreatPerson$225323 = -4			; size = 4
?AI_chooseFreeGreatPerson@CvPlayerAI@@UAEXXZ PROC	; CvPlayerAI::AI_chooseFreeGreatPerson, COMDAT
; _this$ = ecx

; 420  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx
$LN14@AI_chooseF:

; 421  : 	while(GetNumFreeGreatPeople() > 0)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumFreeGreatPeople@CvPlayer@@QBEHXZ	; CvPlayer::GetNumFreeGreatPeople
	test	eax, eax
	jle	$LN15@AI_chooseF

; 422  : 	{
; 423  : 		UnitTypes eDesiredGreatPerson = NO_UNIT;

	mov	DWORD PTR _eDesiredGreatPerson$225323[ebp], -1

; 424  : 
; 425  : 		// Highly wonder competitive and still early in game?
; 426  : 		if(GetDiplomacyAI()->GetWonderCompetitiveness() >= 8 && GC.getGame().getGameTurn() <= (GC.getGame().getEstimateEndTurn() / 2))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetWonderCompetitiveness@CvDiplomacyAI@@QBEHXZ ; CvDiplomacyAI::GetWonderCompetitiveness
	cmp	eax, 8
	jl	SHORT $LN12@AI_chooseF
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T229958[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T229962[ebp], ecx
	mov	ecx, DWORD PTR $T229958[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	esi, eax
	mov	ecx, DWORD PTR $T229962[ebp]
	call	?getEstimateEndTurn@CvGame@@QBEHXZ	; CvGame::getEstimateEndTurn
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	esi, eax
	jg	SHORT $LN12@AI_chooseF

; 427  : 		{
; 428  : 			eDesiredGreatPerson = (UnitTypes)GC.getInfoTypeForString("UNIT_ENGINEER");

	push	0
	push	OFFSET ??_C@_0O@FDAJPIMP@UNIT_ENGINEER?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eDesiredGreatPerson$225323[ebp], eax

; 429  : 		}
; 430  : 		else

	jmp	$LN11@AI_chooseF
$LN12@AI_chooseF:

; 431  : 		{
; 432  : 			// Pick the person based on our victory method
; 433  : 			AIGrandStrategyTypes eVictoryStrategy = GetGrandStrategyAI()->GetActiveGrandStrategy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ ; CvGrandStrategyAI::GetActiveGrandStrategy
	mov	DWORD PTR _eVictoryStrategy$225328[ebp], eax

; 434  : 			if(eVictoryStrategy == (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_CONQUEST"))

	push	0
	push	OFFSET ??_C@_0BJ@GCKPAHPE@AIGRANDSTRATEGY_CONQUEST?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	DWORD PTR _eVictoryStrategy$225328[ebp], eax
	jne	SHORT $LN10@AI_chooseF

; 435  : 			{
; 436  : 				eDesiredGreatPerson = (UnitTypes)GC.getInfoTypeForString("UNIT_GREAT_GENERAL");

	push	0
	push	OFFSET ??_C@_0BD@CPBEDAAN@UNIT_GREAT_GENERAL?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eDesiredGreatPerson$225323[ebp], eax
	jmp	$LN11@AI_chooseF
$LN10@AI_chooseF:

; 437  : 			}
; 438  : 			else if(eVictoryStrategy == (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_CULTURE"))

	push	0
	push	OFFSET ??_C@_0BI@FNGLFDGI@AIGRANDSTRATEGY_CULTURE?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	DWORD PTR _eVictoryStrategy$225328[ebp], eax
	jne	SHORT $LN8@AI_chooseF

; 439  : 			{
; 440  : 				eDesiredGreatPerson = (UnitTypes)GC.getInfoTypeForString("UNIT_ARTIST");

	push	0
	push	OFFSET ??_C@_0M@FNEDFKCL@UNIT_ARTIST?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eDesiredGreatPerson$225323[ebp], eax
	jmp	SHORT $LN11@AI_chooseF
$LN8@AI_chooseF:

; 441  : 			}
; 442  : 			else if(eVictoryStrategy == (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_UNITED_NATIONS"))

	push	0
	push	OFFSET ??_C@_0BP@DOCBNDKB@AIGRANDSTRATEGY_UNITED_NATIONS?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	DWORD PTR _eVictoryStrategy$225328[ebp], eax
	jne	SHORT $LN6@AI_chooseF

; 443  : 			{
; 444  : 				eDesiredGreatPerson = (UnitTypes)GC.getInfoTypeForString("UNIT_MERCHANT");

	push	0
	push	OFFSET ??_C@_0O@HLOLPMBO@UNIT_MERCHANT?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eDesiredGreatPerson$225323[ebp], eax
	jmp	SHORT $LN11@AI_chooseF
$LN6@AI_chooseF:

; 445  : 			}
; 446  : 			else if(eVictoryStrategy == (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_SPACESHIP"))

	push	0
	push	OFFSET ??_C@_0BK@CCPNHFB@AIGRANDSTRATEGY_SPACESHIP?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	DWORD PTR _eVictoryStrategy$225328[ebp], eax
	jne	SHORT $LN11@AI_chooseF

; 447  : 			{
; 448  : 				eDesiredGreatPerson = (UnitTypes)GC.getInfoTypeForString("UNIT_SCIENTIST");

	push	0
	push	OFFSET ??_C@_0P@MKBOELIK@UNIT_SCIENTIST?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eDesiredGreatPerson$225323[ebp], eax
$LN11@AI_chooseF:

; 449  : 			}
; 450  : 		}
; 451  : 
; 452  : 		if(eDesiredGreatPerson != NO_UNIT)

	cmp	DWORD PTR _eDesiredGreatPerson$225323[ebp], -1
	je	SHORT $LN3@AI_chooseF

; 453  : 		{
; 454  : 			CvCity* pCapital = getCapitalCity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	DWORD PTR _pCapital$225353[ebp], eax

; 455  : 			if(pCapital)

	cmp	DWORD PTR _pCapital$225353[ebp], 0
	je	SHORT $LN2@AI_chooseF

; 456  : 			{
; 457  : 				// NQMP GJS: AI should also get truly "free" Great People when the player would as well. Changed 2nd parameter below from true to false.
; 458  : 				pCapital->GetCityCitizens()->DoSpawnGreatPerson(eDesiredGreatPerson, false, false);

	push	0
	push	0
	mov	edx, DWORD PTR _eDesiredGreatPerson$225323[ebp]
	push	edx
	mov	ecx, DWORD PTR _pCapital$225353[ebp]
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?DoSpawnGreatPerson@CvCityCitizens@@QAEXW4UnitTypes@@_N1@Z ; CvCityCitizens::DoSpawnGreatPerson
$LN2@AI_chooseF:

; 459  : 			}
; 460  : 			ChangeNumFreeGreatPeople(-1);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChangeNumFreeGreatPeople@CvPlayer@@QAEXH@Z ; CvPlayer::ChangeNumFreeGreatPeople

; 461  : 		}
; 462  : 		else

	jmp	SHORT $LN1@AI_chooseF
$LN3@AI_chooseF:

; 463  : 		{
; 464  : 			break;

	jmp	SHORT $LN15@AI_chooseF
$LN1@AI_chooseF:

; 465  : 		}
; 466  : 	}

	jmp	$LN14@AI_chooseF
$LN15@AI_chooseF:

; 467  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?AI_chooseFreeGreatPerson@CvPlayerAI@@UAEXXZ ENDP	; CvPlayerAI::AI_chooseFreeGreatPerson
_TEXT	ENDS
EXTRN	?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z:PROC ; CvTeam::setHasTech
EXTRN	?ChooseNextTech@CvTechAI@@QAE?AW4TechTypes@@PAVCvPlayer@@_N@Z:PROC ; CvTechAI::ChooseNextTech
EXTRN	?GetTechAI@CvPlayerTechs@@QAEPAVCvTechAI@@XZ:PROC ; CvPlayerTechs::GetTechAI
EXTRN	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ:PROC ; CvPlayer::GetPlayerTechs
EXTRN	?clearResearchQueue@CvPlayer@@QAEXXZ:PROC	; CvPlayer::clearResearchQueue
; Function compile flags: /Odtp
;	COMDAT ?AI_chooseFreeTech@CvPlayerAI@@UAEXXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T229982 = -12						; size = 4
$T229973 = -8						; size = 4
_eBestTech$ = -4					; size = 4
?AI_chooseFreeTech@CvPlayerAI@@UAEXXZ PROC		; CvPlayerAI::AI_chooseFreeTech, COMDAT
; _this$ = ecx

; 470  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 471  : 	TechTypes eBestTech = NO_TECH;

	mov	DWORD PTR _eBestTech$[ebp], -1

; 472  : 
; 473  : 	clearResearchQueue();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clearResearchQueue@CvPlayer@@QAEXXZ	; CvPlayer::clearResearchQueue

; 474  : 
; 475  : 	// TODO: script override
; 476  : 
; 477  : 	if(eBestTech == NO_TECH)

	cmp	DWORD PTR _eBestTech$[ebp], -1
	jne	SHORT $LN2@AI_chooseF@2

; 478  : 	{
; 479  : 		eBestTech = GetPlayerTechs()->GetTechAI()->ChooseNextTech(this, /*bFreeTech*/ true);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?GetTechAI@CvPlayerTechs@@QAEPAVCvTechAI@@XZ ; CvPlayerTechs::GetTechAI
	mov	ecx, eax
	call	?ChooseNextTech@CvTechAI@@QAE?AW4TechTypes@@PAVCvPlayer@@_N@Z ; CvTechAI::ChooseNextTech
	mov	DWORD PTR _eBestTech$[ebp], eax
$LN2@AI_chooseF@2:

; 480  : 	}
; 481  : 
; 482  : 	if(eBestTech != NO_TECH)

	cmp	DWORD PTR _eBestTech$[ebp], -1
	je	SHORT $LN3@AI_chooseF@2

; 483  : 	{
; 484  : 		GET_TEAM(getTeam()).setHasTech(eBestTech, true, GetID(), true, true);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T229973[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T229982[ebp], eax
	push	1
	push	1
	mov	edx, DWORD PTR $T229973[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _eBestTech$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T229982[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z ; CvTeam::setHasTech
$LN3@AI_chooseF@2:

; 485  : 	}
; 486  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AI_chooseFreeTech@CvPlayerAI@@UAEXXZ ENDP		; CvPlayerAI::AI_chooseFreeTech
_TEXT	ENDS
EXTRN	?pushResearch@CvPlayer@@QAE_NW4TechTypes@@_N@Z:PROC ; CvPlayer::pushResearch
EXTRN	?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z:PROC ; CvPlayerTechs::CanResearch
EXTRN	?GetCurrentResearch@CvPlayerTechs@@QBE?AW4TechTypes@@XZ:PROC ; CvPlayerTechs::GetCurrentResearch
; Function compile flags: /Odtp
;	COMDAT ?AI_chooseResearch@CvPlayerAI@@UAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T230042 = -40						; size = 4
$T230038 = -36						; size = 4
$T230034 = -32						; size = 4
$T230022 = -28						; size = 4
$T230013 = -24						; size = 4
$T230009 = -20						; size = 4
$T230000 = -13						; size = 1
$T229991 = -12						; size = 4
_eBestTech$ = -8					; size = 4
_iI$ = -4						; size = 4
?AI_chooseResearch@CvPlayerAI@@UAEXXZ PROC		; CvPlayerAI::AI_chooseResearch, COMDAT
; _this$ = ecx

; 490  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 491  : #ifdef AUI_PERF_LOGGING_FORMATTING_TWEAKS
; 492  : 	AI_PERF_FORMAT("AI-perf.csv", ("AI_chooseResearch, Turn %03d, %s", GC.getGame().getGameTurn(), getCivilizationShortDescription()));
; 493  : #else
; 494  : 	AI_PERF("AI-perf.csv", "AI_chooseResearch");
; 495  : #endif
; 496  : 
; 497  : 	TechTypes eBestTech = NO_TECH;

	mov	DWORD PTR _eBestTech$[ebp], -1

; 498  : 	int iI;
; 499  : 
; 500  : 	clearResearchQueue();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clearResearchQueue@CvPlayer@@QAEXXZ	; CvPlayer::clearResearchQueue

; 501  : 
; 502  : 	if(GetPlayerTechs()->GetCurrentResearch() == NO_TECH)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?GetCurrentResearch@CvPlayerTechs@@QBE?AW4TechTypes@@XZ ; CvPlayerTechs::GetCurrentResearch
	cmp	eax, -1
	jne	$LN11@AI_chooseR

; 503  : 	{
; 504  : 		for(iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN10@AI_chooseR
$LN9@AI_chooseR:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN10@AI_chooseR:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	$LN11@AI_chooseR

; 505  : 		{
; 506  : 			if(GET_PLAYER((PlayerTypes)iI).isAlive())

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T229991[ebp], ecx
	mov	edx, DWORD PTR $T229991[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T230000[ebp], al
	movzx	ecx, BYTE PTR $T230000[ebp]
	test	ecx, ecx
	je	$LN7@AI_chooseR

; 507  : 			{
; 508  : 				if((iI != GetID()) && (GET_PLAYER((PlayerTypes)iI).getTeam() == getTeam()))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T230009[ebp], eax
	mov	ecx, DWORD PTR _iI$[ebp]
	cmp	ecx, DWORD PTR $T230009[ebp]
	je	$LN7@AI_chooseR
	mov	edx, DWORD PTR _iI$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T230013[ebp], edx
	mov	eax, DWORD PTR $T230013[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T230022[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	DWORD PTR $T230022[ebp], eax
	jne	$LN7@AI_chooseR

; 509  : 				{
; 510  : 					if(GET_PLAYER((PlayerTypes)iI).GetPlayerTechs()->GetCurrentResearch() != NO_TECH)

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T230034[ebp], ecx
	mov	ecx, DWORD PTR $T230034[ebp]
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?GetCurrentResearch@CvPlayerTechs@@QBE?AW4TechTypes@@XZ ; CvPlayerTechs::GetCurrentResearch
	cmp	eax, -1
	je	SHORT $LN7@AI_chooseR

; 511  : 					{
; 512  : 						if(GetPlayerTechs()->CanResearch(GET_PLAYER((PlayerTypes)iI).GetPlayerTechs()->GetCurrentResearch()))

	mov	edx, DWORD PTR _iI$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T230038[ebp], edx
	push	0
	mov	ecx, DWORD PTR $T230038[ebp]
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?GetCurrentResearch@CvPlayerTechs@@QBE?AW4TechTypes@@XZ ; CvPlayerTechs::GetCurrentResearch
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z ; CvPlayerTechs::CanResearch
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@AI_chooseR

; 513  : 						{
; 514  : 							pushResearch(GET_PLAYER((PlayerTypes)iI).GetPlayerTechs()->GetCurrentResearch());

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T230042[ebp], ecx
	push	0
	mov	ecx, DWORD PTR $T230042[ebp]
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?GetCurrentResearch@CvPlayerTechs@@QBE?AW4TechTypes@@XZ ; CvPlayerTechs::GetCurrentResearch
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?pushResearch@CvPlayer@@QAE_NW4TechTypes@@_N@Z ; CvPlayer::pushResearch
$LN7@AI_chooseR:

; 515  : 						}
; 516  : 					}
; 517  : 				}
; 518  : 			}
; 519  : 		}

	jmp	$LN9@AI_chooseR
$LN11@AI_chooseR:

; 520  : 	}
; 521  : 
; 522  : 	if(GetPlayerTechs()->GetCurrentResearch() == NO_TECH)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?GetCurrentResearch@CvPlayerTechs@@QBE?AW4TechTypes@@XZ ; CvPlayerTechs::GetCurrentResearch
	cmp	eax, -1
	jne	SHORT $LN12@AI_chooseR

; 523  : 	{
; 524  : 		//todo: script override
; 525  : 
; 526  : 		if(eBestTech == NO_TECH)

	cmp	DWORD PTR _eBestTech$[ebp], -1
	jne	SHORT $LN2@AI_chooseR

; 527  : 		{
; 528  : 			eBestTech = GetPlayerTechs()->GetTechAI()->ChooseNextTech(this);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?GetTechAI@CvPlayerTechs@@QAEPAVCvTechAI@@XZ ; CvPlayerTechs::GetTechAI
	mov	ecx, eax
	call	?ChooseNextTech@CvTechAI@@QAE?AW4TechTypes@@PAVCvPlayer@@_N@Z ; CvTechAI::ChooseNextTech
	mov	DWORD PTR _eBestTech$[ebp], eax
$LN2@AI_chooseR:

; 529  : 		}
; 530  : 
; 531  : 		if(eBestTech != NO_TECH)

	cmp	DWORD PTR _eBestTech$[ebp], -1
	je	SHORT $LN12@AI_chooseR

; 532  : 		{
; 533  : 			pushResearch(eBestTech);

	push	0
	mov	eax, DWORD PTR _eBestTech$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?pushResearch@CvPlayer@@QAE_NW4TechTypes@@_N@Z ; CvPlayer::pushResearch
$LN12@AI_chooseR:

; 534  : 		}
; 535  : 	}
; 536  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AI_chooseResearch@CvPlayerAI@@UAEXXZ ENDP		; CvPlayerAI::AI_chooseResearch
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ ; std::_Vector_val<CityAndProduction,std::allocator<CityAndProduction> >::~_Vector_val<CityAndProduction,std::allocator<CityAndProduction> >
PUBLIC	??1?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::~vector<CityAndProduction,std::allocator<CityAndProduction> >
PUBLIC	?_Tidy@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXXZ ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Tidy
PUBLIC	??$stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0UCityAndProductionEval@@@Z ; std::stable_sort<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval>
PUBLIC	?push_back@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAEXABUCityAndProduction@@@Z ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::push_back
PUBLIC	??0?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::vector<CityAndProduction,std::allocator<CityAndProduction> >
EXTRN	?IsResistance@CvCity@@QBE_NXZ:PROC		; CvCity::IsResistance
EXTRN	?GetBuildingClassProductionModifier@CvPlayerPolicies@@QAEHW4BuildingClassTypes@@@Z:PROC ; CvPlayerPolicies::GetBuildingClassProductionModifier
EXTRN	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ:PROC ; CvPlayer::GetPlayerPolicies
EXTRN	?GetBuildingClassType@CvBuildingEntry@@QBEHXZ:PROC ; CvBuildingEntry::GetBuildingClassType
EXTRN	?IsNoOccupiedUnhappiness@CvBuildingEntry@@QBE_NXZ:PROC ; CvBuildingEntry::IsNoOccupiedUnhappiness
EXTRN	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z:PROC ; CvGlobals::getBuildingInfo
EXTRN	?getNumBuildingInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumBuildingInfos
EXTRN	?getYieldRateTimes100@CvCity@@QBEHW4YieldTypes@@_N@Z:PROC ; CvCity::getYieldRateTimes100
EXTRN	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::nextCity
EXTRN	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::firstCity
EXTRN	?DoAnnex@CvCity@@QAEXXZ:PROC			; CvCity::DoAnnex
EXTRN	?IsPuppet@CvCity@@QBE_NXZ:PROC			; CvCity::IsPuppet
EXTRN	?IsGoingForCultureVictory@CvDiplomacyAI@@QAE_NXZ:PROC ; CvDiplomacyAI::IsGoingForCultureVictory
EXTRN	__fltused:DWORD
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?AI_considerAnnex@CvPlayerAI@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AI_considerAnnex@CvPlayerAI@@QAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AI_considerAnnex@CvPlayerAI@@QAEXXZ$4
__ehfuncinfo$?AI_considerAnnex@CvPlayerAI@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?AI_considerAnnex@CvPlayerAI@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.cpp
xdata$x	ENDS
;	COMDAT ?AI_considerAnnex@CvPlayerAI@@QAEXXZ
_TEXT	SEGMENT
tv415 = -264						; size = 8
tv413 = -256						; size = 4
tv410 = -250						; size = 2
tv407 = -248						; size = 8
_this$ = -240						; size = 4
$T230235 = -204						; size = 4
$T230145 = -152						; size = 4
$T230129 = -148						; size = 4
$T230053 = -97						; size = 1
$T230052 = -96						; size = 4
$T230047 = -92						; size = 4
$T230046 = -88						; size = 4
$T230045 = -81						; size = 1
_ui$225897 = -80					; size = 4
_eBuilding$225885 = -76					; size = 4
_buildingInfo$225887 = -72				; size = 4
_eBuildingType$225881 = -68				; size = 4
_kEval$225720 = -64					; size = 8
_eCourthouseType$ = -56					; size = 4
_uiCutOff$ = -52					; size = 4
_bCourthouseImprovement$ = -45				; size = 1
_pCity$ = -44						; size = 4
_pTargetCity$ = -40					; size = 4
_fCutoffValue$ = -36					; size = 4
_aCityAndProductions$ = -32				; size = 16
_iLoop$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?AI_considerAnnex@CvPlayerAI@@QAEXXZ PROC		; CvPlayerAI::AI_considerAnnex, COMDAT
; _this$ = ecx

; 554  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AI_considerAnnex@CvPlayerAI@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 252				; 000000fcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 555  : #ifdef AUI_PERF_LOGGING_FORMATTING_TWEAKS
; 556  : 	AI_PERF_FORMAT("AI-perf.csv", ("AI_considerAnnex, Turn %03d, %s", GC.getGame().getGameTurn(), getCivilizationShortDescription()));
; 557  : #else
; 558  : 	AI_PERF("AI-perf.csv", "AI_ considerAnnex");
; 559  : #endif
; 560  : 
; 561  : 	// if the empire is unhappy, don't consider annexing
; 562  : 	if (IsEmpireUnhappy())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsEmpireUnhappy@CvPlayer@@QBE_NXZ	; CvPlayer::IsEmpireUnhappy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN21@AI_conside

; 563  : 	{
; 564  : 		return;

	jmp	$LN22@AI_conside
$LN21@AI_conside:

; 565  : 	}
; 566  : 
; 567  : 	// if we're going for a culture victory, don't consider annexing
; 568  : 	if (GetDiplomacyAI()->IsGoingForCultureVictory())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsGoingForCultureVictory@CvDiplomacyAI@@QAE_NXZ ; CvDiplomacyAI::IsGoingForCultureVictory
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN20@AI_conside

; 569  : 	{
; 570  : 		return;

	jmp	$LN22@AI_conside
$LN20@AI_conside:

; 571  : 	}
; 572  : 
; 573  : 	// for Venice
; 574  : 	if (GetPlayerTraits()->IsNoAnnexing())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T230052[ebp], eax
	mov	edx, DWORD PTR $T230052[ebp]
	mov	al, BYTE PTR [edx+351]
	mov	BYTE PTR $T230053[ebp], al
	movzx	ecx, BYTE PTR $T230053[ebp]
	test	ecx, ecx
	je	SHORT $LN19@AI_conside

; 575  : 	{
; 576  : 		return;

	jmp	$LN22@AI_conside
$LN19@AI_conside:

; 577  : 	}
; 578  : 
; 579  : 	// if their capital city is puppeted, annex it
; 580  : 	CvCity* pCity = getCapitalCity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	DWORD PTR _pCity$[ebp], eax

; 581  : 	if (pCity && pCity->IsPuppet())

	cmp	DWORD PTR _pCity$[ebp], 0
	je	SHORT $LN18@AI_conside
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?IsPuppet@CvCity@@QBE_NXZ		; CvCity::IsPuppet
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN18@AI_conside

; 582  : 	{
; 583  : 		// we should only annex one city a turn, and sense this is one, we're done!
; 584  : 		pCity->DoAnnex();

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?DoAnnex@CvCity@@QAEXXZ			; CvCity::DoAnnex

; 585  : 		return;

	jmp	$LN22@AI_conside
$LN18@AI_conside:

; 586  : 	}
; 587  : 
; 588  : 	std::vector<CityAndProduction> aCityAndProductions;

	lea	ecx, DWORD PTR _aCityAndProductions$[ebp]
	call	??0?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::vector<CityAndProduction,std::allocator<CityAndProduction> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 589  : 	int iLoop = 0;

	mov	DWORD PTR _iLoop$[ebp], 0

; 590  : 	pCity = NULL;

	mov	DWORD PTR _pCity$[ebp], 0

; 591  : 
; 592  : 	// Find first coastal city in same area as settler
; 593  : 	for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pCity$[ebp], eax
	jmp	SHORT $LN17@AI_conside
$LN16@AI_conside:
	push	0
	lea	ecx, DWORD PTR _iLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pCity$[ebp], eax
$LN17@AI_conside:
	cmp	DWORD PTR _pCity$[ebp], 0
	je	SHORT $LN15@AI_conside

; 594  : 	{
; 595  : 		CityAndProduction kEval;
; 596  : 		kEval.pCity = pCity;

	mov	edx, DWORD PTR _pCity$[ebp]
	mov	DWORD PTR _kEval$225720[ebp], edx

; 597  : 		kEval.iProduction = pCity->getYieldRateTimes100(YIELD_PRODUCTION, false);

	push	0
	push	1
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getYieldRateTimes100@CvCity@@QBEHW4YieldTypes@@_N@Z ; CvCity::getYieldRateTimes100
	mov	DWORD PTR _kEval$225720[ebp+4], eax

; 598  : 		aCityAndProductions.push_back(kEval);

	lea	eax, DWORD PTR _kEval$225720[ebp]
	push	eax
	lea	ecx, DWORD PTR _aCityAndProductions$[ebp]
	call	?push_back@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAEXABUCityAndProduction@@@Z ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::push_back

; 599  : 	}

	jmp	SHORT $LN16@AI_conside
$LN15@AI_conside:

; 600  : 	
; 601  : 	std::stable_sort(aCityAndProductions.begin(), aCityAndProductions.end(), CityAndProductionEval());

	xor	ecx, ecx
	mov	BYTE PTR $T230045[ebp], cl
	mov	edx, DWORD PTR _aCityAndProductions$[ebp+8]
	mov	DWORD PTR $T230129[ebp], edx
	mov	eax, DWORD PTR $T230129[ebp]
	mov	DWORD PTR $T230046[ebp], eax
	mov	ecx, DWORD PTR _aCityAndProductions$[ebp+4]
	mov	DWORD PTR $T230145[ebp], ecx
	mov	edx, DWORD PTR $T230145[ebp]
	mov	DWORD PTR $T230047[ebp], edx
	movzx	eax, BYTE PTR $T230045[ebp]
	push	eax
	mov	ecx, DWORD PTR $T230046[ebp]
	push	ecx
	mov	edx, DWORD PTR $T230047[ebp]
	push	edx
	call	??$stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0UCityAndProductionEval@@@Z ; std::stable_sort<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval>
	add	esp, 12					; 0000000cH

; 602  : 	
; 603  : 	CvCity* pTargetCity = NULL;

	mov	DWORD PTR _pTargetCity$[ebp], 0

; 604  : 	float fCutoffValue = GC.getNORMAL_ANNEX();

	movss	xmm0, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8192
	movss	DWORD PTR _fCutoffValue$[ebp], xmm0

; 605  : 	BuildingClassTypes eCourthouseType = NO_BUILDINGCLASS;

	mov	DWORD PTR _eCourthouseType$[ebp], -1

; 606  : 	// find courthouse
; 607  : #ifdef AUI_WARNING_FIXES
; 608  : 	for (uint eBuildingType = 0; eBuildingType < GC.getNumBuildingInfos(); eBuildingType++)
; 609  : #else
; 610  : 	for(int eBuildingType = 0; eBuildingType < GC.getNumBuildingInfos(); eBuildingType++)

	mov	DWORD PTR _eBuildingType$225881[ebp], 0
	jmp	SHORT $LN14@AI_conside
$LN13@AI_conside:
	mov	eax, DWORD PTR _eBuildingType$225881[ebp]
	add	eax, 1
	mov	DWORD PTR _eBuildingType$225881[ebp], eax
$LN14@AI_conside:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	cmp	DWORD PTR _eBuildingType$225881[ebp], eax
	jge	SHORT $LN12@AI_conside

; 611  : #endif
; 612  : 	{
; 613  : 		const BuildingTypes eBuilding = static_cast<BuildingTypes>(eBuildingType);

	mov	ecx, DWORD PTR _eBuildingType$225881[ebp]
	mov	DWORD PTR _eBuilding$225885[ebp], ecx

; 614  : 		CvBuildingEntry* buildingInfo = GC.getBuildingInfo(eBuilding);

	mov	edx, DWORD PTR _eBuilding$225885[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	DWORD PTR _buildingInfo$225887[ebp], eax

; 615  : 
; 616  : 		if(buildingInfo)

	cmp	DWORD PTR _buildingInfo$225887[ebp], 0
	je	SHORT $LN10@AI_conside

; 617  : 		{
; 618  : 			if (buildingInfo->IsNoOccupiedUnhappiness())

	mov	ecx, DWORD PTR _buildingInfo$225887[ebp]
	call	?IsNoOccupiedUnhappiness@CvBuildingEntry@@QBE_NXZ ; CvBuildingEntry::IsNoOccupiedUnhappiness
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN10@AI_conside

; 619  : 			{
; 620  : 				eCourthouseType = (BuildingClassTypes)buildingInfo->GetBuildingClassType();

	mov	ecx, DWORD PTR _buildingInfo$225887[ebp]
	call	?GetBuildingClassType@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetBuildingClassType
	mov	DWORD PTR _eCourthouseType$[ebp], eax

; 621  : 				break;

	jmp	SHORT $LN12@AI_conside
$LN10@AI_conside:

; 622  : 			}
; 623  : 		}
; 624  : 	}

	jmp	SHORT $LN13@AI_conside
$LN12@AI_conside:

; 625  : 
; 626  : 	bool bCourthouseImprovement = false;

	mov	BYTE PTR _bCourthouseImprovement$[ebp], 0

; 627  : 	if (eCourthouseType != NO_BUILDINGCLASS)

	cmp	DWORD PTR _eCourthouseType$[ebp], -1
	je	SHORT $LN8@AI_conside

; 628  : 	{
; 629  : 		if (GetPlayerPolicies()->GetBuildingClassProductionModifier(eCourthouseType) > 0)

	mov	ecx, DWORD PTR _eCourthouseType$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetBuildingClassProductionModifier@CvPlayerPolicies@@QAEHW4BuildingClassTypes@@@Z ; CvPlayerPolicies::GetBuildingClassProductionModifier
	test	eax, eax
	jle	SHORT $LN8@AI_conside

; 630  : 		{
; 631  : 			bCourthouseImprovement = true;

	mov	BYTE PTR _bCourthouseImprovement$[ebp], 1
$LN8@AI_conside:

; 632  : 		}
; 633  : 	}
; 634  : 
; 635  : 	if (bCourthouseImprovement)

	movzx	edx, BYTE PTR _bCourthouseImprovement$[ebp]
	test	edx, edx
	je	SHORT $LN97@AI_conside

; 636  : 	{
; 637  : 		fCutoffValue = GC.getAGGRESIVE_ANNEX();

	movss	xmm0, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8196
	movss	DWORD PTR _fCutoffValue$[ebp], xmm0
$LN97@AI_conside:

; 638  : 	}
; 639  : 
; 640  : 	uint uiCutOff = (uint)(aCityAndProductions.size() * fCutoffValue);

	mov	eax, DWORD PTR _aCityAndProductions$[ebp+8]
	sub	eax, DWORD PTR _aCityAndProductions$[ebp+4]
	sar	eax, 3
	mov	DWORD PTR tv407[ebp], eax
	mov	DWORD PTR tv407[ebp+4], 0
	fild	QWORD PTR tv407[ebp]
	fmul	DWORD PTR _fCutoffValue$[ebp]
	fnstcw	WORD PTR tv410[ebp]
	movzx	eax, WORD PTR tv410[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv413[ebp], eax
	fldcw	WORD PTR tv413[ebp]
	fistp	QWORD PTR tv415[ebp]
	fldcw	WORD PTR tv410[ebp]
	mov	ecx, DWORD PTR tv415[ebp]
	mov	DWORD PTR _uiCutOff$[ebp], ecx

; 641  : 	for (uint ui = 0; ui < uiCutOff; ui++)

	mov	DWORD PTR _ui$225897[ebp], 0
	jmp	SHORT $LN6@AI_conside
$LN5@AI_conside:
	mov	edx, DWORD PTR _ui$225897[ebp]
	add	edx, 1
	mov	DWORD PTR _ui$225897[ebp], edx
$LN6@AI_conside:
	mov	eax, DWORD PTR _ui$225897[ebp]
	cmp	eax, DWORD PTR _uiCutOff$[ebp]
	jae	SHORT $LN4@AI_conside

; 642  : 	{
; 643  : 		if (aCityAndProductions[ui].pCity->IsPuppet())

	mov	ecx, DWORD PTR _aCityAndProductions$[ebp+4]
	mov	edx, DWORD PTR _ui$225897[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	DWORD PTR $T230235[ebp], eax
	mov	ecx, DWORD PTR $T230235[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?IsPuppet@CvCity@@QBE_NXZ		; CvCity::IsPuppet
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@AI_conside

; 644  : 		{
; 645  : 			pTargetCity = aCityAndProductions[ui].pCity;

	mov	eax, DWORD PTR _aCityAndProductions$[ebp+4]
	mov	ecx, DWORD PTR _ui$225897[ebp]
	mov	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR _pTargetCity$[ebp], edx

; 646  : 			break;

	jmp	SHORT $LN4@AI_conside
$LN3@AI_conside:

; 647  : 		}
; 648  : 	}

	jmp	SHORT $LN5@AI_conside
$LN4@AI_conside:

; 649  : 
; 650  : 	if (pTargetCity)

	cmp	DWORD PTR _pTargetCity$[ebp], 0
	je	SHORT $LN1@AI_conside

; 651  : 	{
; 652  : 		if (!pTargetCity->IsResistance())

	mov	ecx, DWORD PTR _pTargetCity$[ebp]
	call	?IsResistance@CvCity@@QBE_NXZ		; CvCity::IsResistance
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@AI_conside

; 653  : 		{
; 654  : 			pTargetCity->DoAnnex();

	mov	ecx, DWORD PTR _pTargetCity$[ebp]
	call	?DoAnnex@CvCity@@QAEXXZ			; CvCity::DoAnnex
$LN1@AI_conside:

; 655  : 		}
; 656  : 	}
; 657  : }

	mov	DWORD PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _aCityAndProductions$[ebp]
	call	?_Tidy@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXXZ ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN22@AI_conside:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AI_considerAnnex@CvPlayerAI@@QAEXXZ$0:
	lea	ecx, DWORD PTR _aCityAndProductions$[ebp]
	jmp	??1?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::~vector<CityAndProduction,std::allocator<CityAndProduction> >
__unwindfunclet$?AI_considerAnnex@CvPlayerAI@@QAEXXZ$4:
	lea	ecx, DWORD PTR _aCityAndProductions$[ebp]
	jmp	??1?$_Vector_val@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ
__ehhandler$?AI_considerAnnex@CvPlayerAI@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-256]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AI_considerAnnex@CvPlayerAI@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?AI_considerAnnex@CvPlayerAI@@QAEXXZ ENDP		; CvPlayerAI::AI_considerAnnex
EXTRN	?GetMissionAIType@CvUnit@@QAE?AW4MissionAITypes@@XZ:PROC ; CvUnit::GetMissionAIType
EXTRN	?GetMissionAIPlot@CvUnit@@QAEPAVCvPlot@@XZ:PROC	; CvUnit::GetMissionAIPlot
; Function compile flags: /Odtp
;	COMDAT ?AI_plotTargetMissionAIs@CvPlayerAI@@UAEHPAVCvPlot@@W4MissionAITypes@@H@Z
_TEXT	SEGMENT
_this$ = -124						; size = 4
$T230348 = -40						; size = 4
$T230344 = -36						; size = 4
$T230340 = -32						; size = 4
$T230336 = -28						; size = 4
_pMissionPlot$225916 = -24				; size = 4
_iDistance$225920 = -20					; size = 4
_eGroupMissionAI$225918 = -16				; size = 4
_pLoopUnit$225912 = -12					; size = 4
_iCount$ = -8						; size = 4
_iLoop$ = -4						; size = 4
_pPlot$ = 8						; size = 4
_eMissionAI$ = 12					; size = 4
_iRange$ = 16						; size = 4
?AI_plotTargetMissionAIs@CvPlayerAI@@UAEHPAVCvPlot@@W4MissionAITypes@@H@Z PROC ; CvPlayerAI::AI_plotTargetMissionAIs, COMDAT
; _this$ = ecx

; 660  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 	int iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0

; 662  : 
; 663  : 	int iLoop;
; 664  : 	for(CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$225912[ebp], eax
	jmp	SHORT $LN6@AI_plotTar
$LN5@AI_plotTar:
	push	0
	lea	ecx, DWORD PTR _iLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$225912[ebp], eax
$LN6@AI_plotTar:
	cmp	DWORD PTR _pLoopUnit$225912[ebp], 0
	je	SHORT $LN4@AI_plotTar

; 665  : 	{
; 666  : 		CvPlot* pMissionPlot = pLoopUnit->GetMissionAIPlot();

	mov	ecx, DWORD PTR _pLoopUnit$225912[ebp]
	call	?GetMissionAIPlot@CvUnit@@QAEPAVCvPlot@@XZ ; CvUnit::GetMissionAIPlot
	mov	DWORD PTR _pMissionPlot$225916[ebp], eax

; 667  : 		if(!pMissionPlot)

	cmp	DWORD PTR _pMissionPlot$225916[ebp], 0
	jne	SHORT $LN3@AI_plotTar

; 668  : 		{
; 669  : 			continue;

	jmp	SHORT $LN5@AI_plotTar
$LN3@AI_plotTar:

; 670  : 		}
; 671  : 
; 672  : 		MissionAITypes eGroupMissionAI = pLoopUnit->GetMissionAIType();

	mov	ecx, DWORD PTR _pLoopUnit$225912[ebp]
	call	?GetMissionAIType@CvUnit@@QAE?AW4MissionAITypes@@XZ ; CvUnit::GetMissionAIType
	mov	DWORD PTR _eGroupMissionAI$225918[ebp], eax

; 673  : 		if(eGroupMissionAI != eMissionAI)

	mov	edx, DWORD PTR _eGroupMissionAI$225918[ebp]
	cmp	edx, DWORD PTR _eMissionAI$[ebp]
	je	SHORT $LN2@AI_plotTar

; 674  : 		{
; 675  : 			continue;

	jmp	SHORT $LN5@AI_plotTar
$LN2@AI_plotTar:

; 676  : 		}
; 677  : 
; 678  : 		int iDistance = plotDistance(pPlot->getX(), pPlot->getY(), pMissionPlot->getX(), pMissionPlot->getY());

	mov	eax, DWORD PTR _pMissionPlot$225916[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T230336[ebp], ecx
	mov	edx, DWORD PTR _pMissionPlot$225916[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T230340[ebp], eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T230344[ebp], edx
	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T230348[ebp], ecx
	mov	edx, DWORD PTR $T230336[ebp]
	push	edx
	mov	eax, DWORD PTR $T230340[ebp]
	push	eax
	mov	ecx, DWORD PTR $T230344[ebp]
	push	ecx
	mov	edx, DWORD PTR $T230348[ebp]
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iDistance$225920[ebp], eax

; 679  : 		if(iDistance == iRange)

	mov	eax, DWORD PTR _iDistance$225920[ebp]
	cmp	eax, DWORD PTR _iRange$[ebp]
	jne	SHORT $LN1@AI_plotTar

; 680  : 		{
; 681  : 			iCount++;

	mov	ecx, DWORD PTR _iCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iCount$[ebp], ecx
$LN1@AI_plotTar:

; 682  : 		}
; 683  : 	}

	jmp	$LN5@AI_plotTar
$LN4@AI_plotTar:

; 684  : 
; 685  : 	return iCount;

	mov	eax, DWORD PTR _iCount$[ebp]

; 686  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?AI_plotTargetMissionAIs@CvPlayerAI@@UAEHPAVCvPlot@@W4MissionAITypes@@H@Z ENDP ; CvPlayerAI::AI_plotTargetMissionAIs
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?AI_doResearch@CvPlayerAI@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AI_doResearch@CvPlayerAI@@IAEXXZ PROC			; CvPlayerAI::AI_doResearch, COMDAT
; _this$ = ecx

; 691  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 692  : 	CvAssertMsg(!isHuman(), "isHuman did not return false as expected");
; 693  : 
; 694  : 	if(GetPlayerTechs()->GetCurrentResearch() == NO_TECH)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?GetCurrentResearch@CvPlayerTechs@@QBE?AW4TechTypes@@XZ ; CvPlayerTechs::GetCurrentResearch
	cmp	eax, -1
	jne	SHORT $LN2@AI_doResea

; 695  : 	{
; 696  : 		AI_chooseResearch();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	call	eax
$LN2@AI_doResea:

; 697  : 		//AI_forceUpdateStrategies(); //to account for current research.
; 698  : 	}
; 699  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AI_doResearch@CvPlayerAI@@IAEXXZ ENDP			; CvPlayerAI::AI_doResearch
_TEXT	ENDS
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
EXTRN	?Read@CvPlayer@@UAEXAAVFDataStream@@@Z:PROC	; CvPlayer::Read
; Function compile flags: /Odtp
;	COMDAT ?Read@CvPlayerAI@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Read@CvPlayerAI@@UAEXAAVFDataStream@@@Z PROC		; CvPlayerAI::Read, COMDAT
; _this$ = ecx

; 707  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 708  : 	CvPlayer::Read(kStream);	// read base class data first

	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Read@CvPlayer@@UAEXAAVFDataStream@@@Z	; CvPlayer::Read

; 709  : 
; 710  : 	// Version number to maintain backwards compatibility
; 711  : 	uint uiVersion;
; 712  : 	kStream >> uiVersion;

	lea	ecx, DWORD PTR _uiVersion$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 713  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Read@CvPlayerAI@@UAEXAAVFDataStream@@@Z ENDP		; CvPlayerAI::Read
_TEXT	ENDS
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
EXTRN	?Write@CvPlayer@@UBEXAAVFDataStream@@@Z:PROC	; CvPlayer::Write
; Function compile flags: /Odtp
;	COMDAT ?Write@CvPlayerAI@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Write@CvPlayerAI@@UBEXAAVFDataStream@@@Z PROC		; CvPlayerAI::Write, COMDAT
; _this$ = ecx

; 721  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 722  : 	CvPlayer::Write(kStream);	// write base class data first

	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Write@CvPlayer@@UBEXAAVFDataStream@@@Z	; CvPlayer::Write

; 723  : 
; 724  : 	// Current version number
; 725  : 	uint uiVersion = 1;

	mov	DWORD PTR _uiVersion$[ebp], 1

; 726  : 	kStream << uiVersion;

	lea	ecx, DWORD PTR _uiVersion$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 727  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Write@CvPlayerAI@@UBEXAAVFDataStream@@@Z ENDP		; CvPlayerAI::Write
_TEXT	ENDS
EXTRN	?launch@CvPlayer@@QAEXW4VictoryTypes@@@Z:PROC	; CvPlayer::launch
EXTRN	?canLaunch@CvTeam@@QBE_NW4VictoryTypes@@@Z:PROC	; CvTeam::canLaunch
EXTRN	?isHuman@CvTeam@@QBE_NXZ:PROC			; CvTeam::isHuman
; Function compile flags: /Odtp
;	COMDAT ?AI_launch@CvPlayerAI@@UAEXW4VictoryTypes@@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T230473 = -16						; size = 4
$T230469 = -12						; size = 4
$T230460 = -8						; size = 4
$T230456 = -4						; size = 4
_eVictory$ = 8						; size = 4
?AI_launch@CvPlayerAI@@UAEXW4VictoryTypes@@@Z PROC	; CvPlayerAI::AI_launch, COMDAT
; _this$ = ecx

; 730  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 	if(GET_TEAM(getTeam()).isHuman())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T230456[ebp], eax
	mov	edx, DWORD PTR $T230456[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T230460[ebp], edx
	mov	ecx, DWORD PTR $T230460[ebp]
	call	?isHuman@CvTeam@@QBE_NXZ		; CvTeam::isHuman
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN13@AI_launch

; 732  : 	{
; 733  : 		return;

	jmp	SHORT $LN3@AI_launch

; 734  : 	}
; 735  : 
; 736  : 	if(!GET_TEAM(getTeam()).canLaunch(eVictory))

$LN13@AI_launch:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T230469[ebp], eax
	mov	eax, DWORD PTR $T230469[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T230473[ebp], eax
	mov	ecx, DWORD PTR _eVictory$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T230473[ebp]
	call	?canLaunch@CvTeam@@QBE_NW4VictoryTypes@@@Z ; CvTeam::canLaunch
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN1@AI_launch

; 737  : 	{
; 738  : 		return;

	jmp	SHORT $LN3@AI_launch
$LN1@AI_launch:

; 739  : 	}
; 740  : 
; 741  : 	launch(eVictory);

	mov	eax, DWORD PTR _eVictory$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?launch@CvPlayer@@QAEXW4VictoryTypes@@@Z ; CvPlayer::launch
$LN3@AI_launch:

; 742  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?AI_launch@CvPlayerAI@@UAEXW4VictoryTypes@@@Z ENDP	; CvPlayerAI::AI_launch
_TEXT	ENDS
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::const_iterator::_Inc
; Function compile flags: /Odtp
;	COMDAT ?PeekAtNextUnitToBuildForOperationSlot@CvPlayerAI@@UAE?AUOperationSlot@@H@Z
_TEXT	SEGMENT
tv193 = -76						; size = 4
_this$ = -72						; size = 4
$T230581 = -68						; size = 4
$T230508 = -48						; size = 4
$T230495 = -44						; size = 4
$T230478 = -40						; size = 12
$T230477 = -28						; size = 4
$T230476 = -24						; size = 4
_pThisOperation$225967 = -20				; size = 4
_thisSlot$ = -16					; size = 12
_iter$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_iAreaID$ = 12						; size = 4
?PeekAtNextUnitToBuildForOperationSlot@CvPlayerAI@@UAE?AUOperationSlot@@H@Z PROC ; CvPlayerAI::PeekAtNextUnitToBuildForOperationSlot, COMDAT
; _this$ = ecx

; 745  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	DWORD PTR _this$[ebp], ecx

; 746  : 	OperationSlot thisSlot;

	mov	DWORD PTR _thisSlot$[ebp], -1
	mov	DWORD PTR _thisSlot$[ebp+4], -1
	mov	DWORD PTR _thisSlot$[ebp+8], -1

; 747  : 
; 748  : 	// search through our operations till we find one that needs a unit
; 749  : 	std::map<int, CvAIOperation*>::iterator iter;

	mov	DWORD PTR _iter$[ebp], 0

; 750  : 	for(iter = m_AIOperations.begin(); iter != m_AIOperations.end(); ++iter)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4532]
	mov	DWORD PTR $T230495[ebp], ecx
	mov	edx, DWORD PTR $T230495[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T230508[ebp], eax
	mov	ecx, DWORD PTR $T230508[ebp]
	mov	DWORD PTR $T230476[ebp], ecx
	mov	edx, DWORD PTR $T230476[ebp]
	mov	DWORD PTR _iter$[ebp], edx
	jmp	SHORT $LN5@PeekAtNext
$LN4@PeekAtNext:
	lea	ecx, DWORD PTR _iter$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::const_iterator::_Inc
$LN5@PeekAtNext:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4532]
	mov	DWORD PTR $T230581[ebp], ecx
	mov	edx, DWORD PTR $T230581[ebp]
	mov	DWORD PTR $T230477[ebp], edx
	mov	eax, DWORD PTR _iter$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T230477[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN3@PeekAtNext

; 751  : 	{
; 752  : 		CvAIOperation* pThisOperation = iter->second;

	mov	ecx, DWORD PTR _iter$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _pThisOperation$225967[ebp], edx

; 753  : 		if(pThisOperation)

	cmp	DWORD PTR _pThisOperation$225967[ebp], 0
	je	SHORT $LN2@PeekAtNext

; 754  : 		{
; 755  : 			thisSlot = pThisOperation->PeekAtNextUnitToBuild(iAreaID);

	mov	eax, DWORD PTR _iAreaID$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T230478[ebp]
	push	ecx
	mov	edx, DWORD PTR _pThisOperation$225967[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pThisOperation$225967[ebp]
	mov	edx, DWORD PTR [eax+96]
	call	edx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _thisSlot$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _thisSlot$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _thisSlot$[ebp+8], eax

; 756  : 			if(thisSlot.IsValid())

	cmp	DWORD PTR _thisSlot$[ebp+4], -1
	je	SHORT $LN80@PeekAtNext
	cmp	DWORD PTR _thisSlot$[ebp+8], -1
	je	SHORT $LN80@PeekAtNext
	cmp	DWORD PTR _thisSlot$[ebp], -1
	je	SHORT $LN80@PeekAtNext
	mov	DWORD PTR tv193[ebp], 1
	jmp	SHORT $LN78@PeekAtNext
$LN80@PeekAtNext:
	mov	DWORD PTR tv193[ebp], 0
$LN78@PeekAtNext:
	movzx	ecx, BYTE PTR tv193[ebp]
	test	ecx, ecx
	je	SHORT $LN2@PeekAtNext

; 757  : 			{
; 758  : 				break;

	jmp	SHORT $LN3@PeekAtNext
$LN2@PeekAtNext:

; 759  : 			}
; 760  : 		}
; 761  : 	}

	jmp	$LN4@PeekAtNext
$LN3@PeekAtNext:

; 762  : 
; 763  : 	return thisSlot;

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR _thisSlot$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _thisSlot$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _thisSlot$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 764  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?PeekAtNextUnitToBuildForOperationSlot@CvPlayerAI@@UAE?AUOperationSlot@@H@Z ENDP ; CvPlayerAI::PeekAtNextUnitToBuildForOperationSlot
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?CityCommitToBuildUnitForOperationSlot@CvPlayerAI@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
_TEXT	SEGMENT
tv195 = -76						; size = 4
_this$ = -72						; size = 4
$T230734 = -68						; size = 4
$T230661 = -48						; size = 4
$T230648 = -44						; size = 4
$T230631 = -40						; size = 12
$T230630 = -28						; size = 4
$T230629 = -24						; size = 4
_pThisOperation$226022 = -20				; size = 4
_thisSlot$ = -16					; size = 12
_iter$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_iAreaID$ = 12						; size = 4
_iTurns$ = 16						; size = 4
_pCity$ = 20						; size = 4
?CityCommitToBuildUnitForOperationSlot@CvPlayerAI@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z PROC ; CvPlayerAI::CityCommitToBuildUnitForOperationSlot, COMDAT
; _this$ = ecx

; 768  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	DWORD PTR _this$[ebp], ecx

; 769  : 	OperationSlot thisSlot;

	mov	DWORD PTR _thisSlot$[ebp], -1
	mov	DWORD PTR _thisSlot$[ebp+4], -1
	mov	DWORD PTR _thisSlot$[ebp+8], -1

; 770  : 
; 771  : 	// search through our operations till we find one that needs a unit
; 772  : 	std::map<int, CvAIOperation*>::iterator iter;

	mov	DWORD PTR _iter$[ebp], 0

; 773  : 	for(iter = m_AIOperations.begin(); iter != m_AIOperations.end(); ++iter)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4532]
	mov	DWORD PTR $T230648[ebp], ecx
	mov	edx, DWORD PTR $T230648[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T230661[ebp], eax
	mov	ecx, DWORD PTR $T230661[ebp]
	mov	DWORD PTR $T230629[ebp], ecx
	mov	edx, DWORD PTR $T230629[ebp]
	mov	DWORD PTR _iter$[ebp], edx
	jmp	SHORT $LN5@CityCommit
$LN4@CityCommit:
	lea	ecx, DWORD PTR _iter$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::const_iterator::_Inc
$LN5@CityCommit:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4532]
	mov	DWORD PTR $T230734[ebp], ecx
	mov	edx, DWORD PTR $T230734[ebp]
	mov	DWORD PTR $T230630[ebp], edx
	mov	eax, DWORD PTR _iter$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T230630[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN3@CityCommit

; 774  : 	{
; 775  : 		CvAIOperation* pThisOperation = iter->second;

	mov	ecx, DWORD PTR _iter$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _pThisOperation$226022[ebp], edx

; 776  : 		if(pThisOperation)

	cmp	DWORD PTR _pThisOperation$226022[ebp], 0
	je	SHORT $LN2@CityCommit

; 777  : 		{
; 778  : 			thisSlot = pThisOperation->CommitToBuildNextUnit(iAreaID, iTurns, pCity);

	mov	eax, DWORD PTR _pCity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iTurns$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iAreaID$[ebp]
	push	edx
	lea	eax, DWORD PTR $T230631[ebp]
	push	eax
	mov	ecx, DWORD PTR _pThisOperation$226022[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pThisOperation$226022[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _thisSlot$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _thisSlot$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _thisSlot$[ebp+8], eax

; 779  : 			if(thisSlot.IsValid())

	cmp	DWORD PTR _thisSlot$[ebp+4], -1
	je	SHORT $LN80@CityCommit
	cmp	DWORD PTR _thisSlot$[ebp+8], -1
	je	SHORT $LN80@CityCommit
	cmp	DWORD PTR _thisSlot$[ebp], -1
	je	SHORT $LN80@CityCommit
	mov	DWORD PTR tv195[ebp], 1
	jmp	SHORT $LN78@CityCommit
$LN80@CityCommit:
	mov	DWORD PTR tv195[ebp], 0
$LN78@CityCommit:
	movzx	ecx, BYTE PTR tv195[ebp]
	test	ecx, ecx
	je	SHORT $LN2@CityCommit

; 780  : 			{
; 781  : 				break;

	jmp	SHORT $LN3@CityCommit
$LN2@CityCommit:

; 782  : 			}
; 783  : 		}
; 784  : 	}

	jmp	$LN4@CityCommit
$LN3@CityCommit:

; 785  : 
; 786  : 	return thisSlot;

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR _thisSlot$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _thisSlot$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _thisSlot$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 787  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?CityCommitToBuildUnitForOperationSlot@CvPlayerAI@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z ENDP ; CvPlayerAI::CityCommitToBuildUnitForOperationSlot
_TEXT	ENDS
EXTRN	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z:PROC ; CvPlayer::getAIOperation
; Function compile flags: /Odtp
;	COMDAT ?CityUncommitToBuildUnitForOperationSlot@CvPlayerAI@@UAEXUOperationSlot@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pThisOperation$ = -4					; size = 4
_thisSlot$ = 8						; size = 12
?CityUncommitToBuildUnitForOperationSlot@CvPlayerAI@@UAEXUOperationSlot@@@Z PROC ; CvPlayerAI::CityUncommitToBuildUnitForOperationSlot, COMDAT
; _this$ = ecx

; 794  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 795  : 	// find this operation
; 796  : 	CvAIOperation* pThisOperation = getAIOperation(thisSlot.m_iOperationID);

	mov	eax, DWORD PTR _thisSlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	mov	DWORD PTR _pThisOperation$[ebp], eax

; 797  : 	if(pThisOperation)

	cmp	DWORD PTR _pThisOperation$[ebp], 0
	je	SHORT $LN2@CityUncomm

; 798  : 	{
; 799  : 		pThisOperation->UncommitToBuild(thisSlot);

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR _thisSlot$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _thisSlot$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _thisSlot$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _pThisOperation$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pThisOperation$[ebp]
	mov	eax, DWORD PTR [edx+104]
	call	eax
$LN2@CityUncomm:

; 800  : 	}
; 801  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?CityUncommitToBuildUnitForOperationSlot@CvPlayerAI@@UAEXUOperationSlot@@@Z ENDP ; CvPlayerAI::CityUncommitToBuildUnitForOperationSlot
_TEXT	ENDS
EXTRN	?AddUnit@CvArmyAI@@QAEXHH@Z:PROC		; CvArmyAI::AddUnit
EXTRN	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z:PROC	; CvPlayer::getArmyAI
; Function compile flags: /Odtp
;	COMDAT ?CityFinishedBuildingUnitForOperationSlot@CvPlayerAI@@UAEXUOperationSlot@@PAVCvUnit@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T230792 = -12						; size = 4
_pThisOperation$ = -8					; size = 4
_pThisArmy$ = -4					; size = 4
_thisSlot$ = 8						; size = 12
_pThisUnit$ = 20					; size = 4
?CityFinishedBuildingUnitForOperationSlot@CvPlayerAI@@UAEXUOperationSlot@@PAVCvUnit@@@Z PROC ; CvPlayerAI::CityFinishedBuildingUnitForOperationSlot, COMDAT
; _this$ = ecx

; 808  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 809  : 	// find this operation
; 810  : 	CvAIOperation* pThisOperation = getAIOperation(thisSlot.m_iOperationID);

	mov	eax, DWORD PTR _thisSlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	mov	DWORD PTR _pThisOperation$[ebp], eax

; 811  : 	CvArmyAI* pThisArmy = getArmyAI(thisSlot.m_iArmyID);

	mov	ecx, DWORD PTR _thisSlot$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI
	mov	DWORD PTR _pThisArmy$[ebp], eax

; 812  : 	if(pThisOperation && pThisArmy && pThisUnit)

	cmp	DWORD PTR _pThisOperation$[ebp], 0
	je	SHORT $LN2@CityFinish
	cmp	DWORD PTR _pThisArmy$[ebp], 0
	je	SHORT $LN2@CityFinish
	cmp	DWORD PTR _pThisUnit$[ebp], 0
	je	SHORT $LN2@CityFinish

; 813  : 	{
; 814  : 		pThisArmy->AddUnit(pThisUnit->GetID(), thisSlot.m_iSlotID);

	mov	edx, DWORD PTR _pThisUnit$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T230792[ebp], eax
	mov	ecx, DWORD PTR _thisSlot$[ebp+8]
	push	ecx
	mov	edx, DWORD PTR $T230792[ebp]
	push	edx
	mov	ecx, DWORD PTR _pThisArmy$[ebp]
	call	?AddUnit@CvArmyAI@@QAEXHH@Z		; CvArmyAI::AddUnit

; 815  : 		pThisOperation->FinishedBuilding(thisSlot);

	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	ecx, DWORD PTR _thisSlot$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _thisSlot$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _thisSlot$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _pThisOperation$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pThisOperation$[ebp]
	mov	edx, DWORD PTR [eax+108]
	call	edx
$LN2@CityFinish:

; 816  : 	}
; 817  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?CityFinishedBuildingUnitForOperationSlot@CvPlayerAI@@UAEXUOperationSlot@@PAVCvUnit@@@Z ENDP ; CvPlayerAI::CityFinishedBuildingUnitForOperationSlot
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetNumUnitsNeededToBeBuilt@CvPlayerAI@@UAEHXZ
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T230939 = -52						; size = 4
$T230896 = -48						; size = 4
$T230823 = -28						; size = 4
$T230810 = -24						; size = 4
$T230796 = -20						; size = 4
$T230795 = -16						; size = 4
_pThisOperation$226063 = -12				; size = 4
_iRtnValue$ = -8					; size = 4
_iter$ = -4						; size = 4
?GetNumUnitsNeededToBeBuilt@CvPlayerAI@@UAEHXZ PROC	; CvPlayerAI::GetNumUnitsNeededToBeBuilt, COMDAT
; _this$ = ecx

; 820  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 821  : 	int iRtnValue = 0;

	mov	DWORD PTR _iRtnValue$[ebp], 0

; 822  : 
; 823  : 	std::map<int, CvAIOperation*>::iterator iter;

	mov	DWORD PTR _iter$[ebp], 0

; 824  : 	for(iter = m_AIOperations.begin(); iter != m_AIOperations.end(); ++iter)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4532]
	mov	DWORD PTR $T230810[ebp], ecx
	mov	edx, DWORD PTR $T230810[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T230823[ebp], eax
	mov	ecx, DWORD PTR $T230823[ebp]
	mov	DWORD PTR $T230795[ebp], ecx
	mov	edx, DWORD PTR $T230795[ebp]
	mov	DWORD PTR _iter$[ebp], edx
	jmp	SHORT $LN4@GetNumUnit
$LN3@GetNumUnit:
	lea	ecx, DWORD PTR _iter$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::const_iterator::_Inc
$LN4@GetNumUnit:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4532]
	mov	DWORD PTR $T230896[ebp], ecx
	mov	edx, DWORD PTR $T230896[ebp]
	mov	DWORD PTR $T230796[ebp], edx
	mov	eax, DWORD PTR _iter$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T230796[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN2@GetNumUnit

; 825  : 	{
; 826  : 		CvAIOperation* pThisOperation = iter->second;

	mov	ecx, DWORD PTR _iter$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _pThisOperation$226063[ebp], edx

; 827  : 		if(pThisOperation)

	cmp	DWORD PTR _pThisOperation$226063[ebp], 0
	je	SHORT $LN1@GetNumUnit

; 828  : 		{
; 829  : 			iRtnValue += pThisOperation->GetNumUnitsNeededToBeBuilt();

	mov	eax, DWORD PTR _pThisOperation$226063[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR $T230939[ebp], eax
	mov	ecx, DWORD PTR $T230939[ebp]
	mov	edx, DWORD PTR $T230939[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	add	eax, DWORD PTR _iRtnValue$[ebp]
	mov	DWORD PTR _iRtnValue$[ebp], eax
$LN1@GetNumUnit:

; 830  : 		}
; 831  : 	}

	jmp	SHORT $LN3@GetNumUnit
$LN2@GetNumUnit:

; 832  : 
; 833  : 	return iRtnValue;

	mov	eax, DWORD PTR _iRtnValue$[ebp]

; 834  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumUnitsNeededToBeBuilt@CvPlayerAI@@UAEHXZ ENDP	; CvPlayerAI::GetNumUnitsNeededToBeBuilt
_TEXT	ENDS
PUBLIC	?GetDirectiveAdmiral@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ; CvPlayerAI::GetDirectiveAdmiral
PUBLIC	?GetDirectiveProphet@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ; CvPlayerAI::GetDirectiveProphet
PUBLIC	?GetDirectiveGeneral@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ; CvPlayerAI::GetDirectiveGeneral
PUBLIC	?GetDirectiveScientist@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ; CvPlayerAI::GetDirectiveScientist
PUBLIC	?GetDirectiveMerchant@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ; CvPlayerAI::GetDirectiveMerchant
PUBLIC	?GetDirectiveEngineer@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ; CvPlayerAI::GetDirectiveEngineer
PUBLIC	?GetDirectiveMusician@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ; CvPlayerAI::GetDirectiveMusician
PUBLIC	?GetDirectiveArtist@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ; CvPlayerAI::GetDirectiveArtist
PUBLIC	?GetDirectiveWriter@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ; CvPlayerAI::GetDirectiveWriter
PUBLIC	??_C@_0BD@NNACGNOP@SPECIALUNIT_PEOPLE?$AA@	; `string'
EXTRN	?SetGreatPeopleDirective@CvUnit@@QAEXW4GreatPeopleDirectiveTypes@@@Z:PROC ; CvUnit::SetGreatPeopleDirective
EXTRN	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ:PROC ; CvUnit::AI_getUnitAIType
EXTRN	?getSpecialUnitType@CvUnit@@QBE?AW4SpecialUnitTypes@@XZ:PROC ; CvUnit::getSpecialUnitType
;	COMDAT ??_C@_0BD@NNACGNOP@SPECIALUNIT_PEOPLE?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fautovariable.h
CONST	SEGMENT
??_C@_0BD@NNACGNOP@SPECIALUNIT_PEOPLE?$AA@ DB 'SPECIALUNIT_PEOPLE', 00H ; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.cpp
CONST	ENDS
;	COMDAT ?ProcessGreatPeople@CvPlayerAI@@QAEXXZ
_TEXT	SEGMENT
tv130 = -28						; size = 4
_this$ = -24						; size = 4
$T230954 = -17						; size = 1
_eDirective$226079 = -16				; size = 4
_pLoopUnit$226074 = -12					; size = 4
_eSpecialUnitGreatPerson$ = -8				; size = 4
_iLoop$ = -4						; size = 4
?ProcessGreatPeople@CvPlayerAI@@QAEXXZ PROC		; CvPlayerAI::ProcessGreatPeople, COMDAT
; _this$ = ecx

; 837  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 838  : 	SpecialUnitTypes eSpecialUnitGreatPerson = (SpecialUnitTypes) GC.getInfoTypeForString("SPECIALUNIT_PEOPLE");

	push	0
	push	OFFSET ??_C@_0BD@NNACGNOP@SPECIALUNIT_PEOPLE?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eSpecialUnitGreatPerson$[ebp], eax

; 839  : 
; 840  : 	CvAssert(isAlive());
; 841  : 
; 842  : 	if(!isAlive())

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+2256]
	mov	BYTE PTR $T230954[ebp], cl
	movzx	edx, BYTE PTR $T230954[ebp]
	test	edx, edx
	jne	SHORT $LN16@ProcessGre

; 843  : 		return;

	jmp	$LN17@ProcessGre
$LN16@ProcessGre:

; 844  : 
; 845  : 	int iLoop;
; 846  : 	for(CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$226074[ebp], eax
	jmp	SHORT $LN15@ProcessGre
$LN14@ProcessGre:
	push	0
	lea	ecx, DWORD PTR _iLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$226074[ebp], eax
$LN15@ProcessGre:
	cmp	DWORD PTR _pLoopUnit$226074[ebp], 0
	je	$LN17@ProcessGre

; 847  : 	{
; 848  : 		if(pLoopUnit->getSpecialUnitType() != eSpecialUnitGreatPerson)

	mov	ecx, DWORD PTR _pLoopUnit$226074[ebp]
	call	?getSpecialUnitType@CvUnit@@QBE?AW4SpecialUnitTypes@@XZ ; CvUnit::getSpecialUnitType
	cmp	eax, DWORD PTR _eSpecialUnitGreatPerson$[ebp]
	je	SHORT $LN12@ProcessGre

; 849  : 		{
; 850  : 			continue;

	jmp	SHORT $LN14@ProcessGre
$LN12@ProcessGre:

; 851  : 		}
; 852  : 
; 853  : 		GreatPeopleDirectiveTypes eDirective = NO_GREAT_PEOPLE_DIRECTIVE_TYPE;

	mov	DWORD PTR _eDirective$226079[ebp], -1

; 854  : 		switch(pLoopUnit->AI_getUnitAIType())

	mov	ecx, DWORD PTR _pLoopUnit$226074[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	mov	DWORD PTR tv130[ebp], eax
	mov	edx, DWORD PTR tv130[ebp]
	sub	edx, 11					; 0000000bH
	mov	DWORD PTR tv130[ebp], edx
	cmp	DWORD PTR tv130[ebp], 30		; 0000001eH
	ja	$LN10@ProcessGre
	mov	eax, DWORD PTR tv130[ebp]
	movzx	ecx, BYTE PTR $LN23@ProcessGre[eax]
	jmp	DWORD PTR $LN24@ProcessGre[ecx*4]
$LN9@ProcessGre:

; 855  : 		{
; 856  : 		case UNITAI_WRITER:
; 857  : 			eDirective = GetDirectiveWriter(pLoopUnit);

	mov	edx, DWORD PTR _pLoopUnit$226074[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDirectiveWriter@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ; CvPlayerAI::GetDirectiveWriter
	mov	DWORD PTR _eDirective$226079[ebp], eax

; 858  : 			break;

	jmp	$LN10@ProcessGre
$LN8@ProcessGre:

; 859  : 		case UNITAI_ARTIST:
; 860  : 			eDirective = GetDirectiveArtist(pLoopUnit);

	mov	eax, DWORD PTR _pLoopUnit$226074[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDirectiveArtist@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ; CvPlayerAI::GetDirectiveArtist
	mov	DWORD PTR _eDirective$226079[ebp], eax

; 861  : 			break;

	jmp	SHORT $LN10@ProcessGre
$LN7@ProcessGre:

; 862  : 		case UNITAI_MUSICIAN:
; 863  : 			eDirective = GetDirectiveMusician(pLoopUnit);

	mov	ecx, DWORD PTR _pLoopUnit$226074[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDirectiveMusician@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ; CvPlayerAI::GetDirectiveMusician
	mov	DWORD PTR _eDirective$226079[ebp], eax

; 864  : 			break;

	jmp	SHORT $LN10@ProcessGre
$LN6@ProcessGre:

; 865  : 		case UNITAI_ENGINEER:
; 866  : 			eDirective = GetDirectiveEngineer(pLoopUnit);

	mov	edx, DWORD PTR _pLoopUnit$226074[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDirectiveEngineer@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ; CvPlayerAI::GetDirectiveEngineer
	mov	DWORD PTR _eDirective$226079[ebp], eax

; 867  : 			break;

	jmp	SHORT $LN10@ProcessGre
$LN5@ProcessGre:

; 868  : 		case UNITAI_MERCHANT:
; 869  : 			eDirective = GetDirectiveMerchant(pLoopUnit);

	mov	eax, DWORD PTR _pLoopUnit$226074[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDirectiveMerchant@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ; CvPlayerAI::GetDirectiveMerchant
	mov	DWORD PTR _eDirective$226079[ebp], eax

; 870  : 			break;

	jmp	SHORT $LN10@ProcessGre
$LN4@ProcessGre:

; 871  : 		case UNITAI_SCIENTIST:
; 872  : 			eDirective = GetDirectiveScientist(pLoopUnit);

	mov	ecx, DWORD PTR _pLoopUnit$226074[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDirectiveScientist@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ; CvPlayerAI::GetDirectiveScientist
	mov	DWORD PTR _eDirective$226079[ebp], eax

; 873  : 			break;

	jmp	SHORT $LN10@ProcessGre
$LN3@ProcessGre:

; 874  : 		case UNITAI_GENERAL:
; 875  : 			eDirective = GetDirectiveGeneral(pLoopUnit);

	mov	edx, DWORD PTR _pLoopUnit$226074[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDirectiveGeneral@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ; CvPlayerAI::GetDirectiveGeneral
	mov	DWORD PTR _eDirective$226079[ebp], eax

; 876  : 			break;

	jmp	SHORT $LN10@ProcessGre
$LN2@ProcessGre:

; 877  : 		case UNITAI_PROPHET:
; 878  : 			eDirective = GetDirectiveProphet(pLoopUnit);

	mov	eax, DWORD PTR _pLoopUnit$226074[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDirectiveProphet@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ; CvPlayerAI::GetDirectiveProphet
	mov	DWORD PTR _eDirective$226079[ebp], eax

; 879  : 			break;

	jmp	SHORT $LN10@ProcessGre
$LN1@ProcessGre:

; 880  : 		case UNITAI_ADMIRAL:
; 881  : 			eDirective = GetDirectiveAdmiral(pLoopUnit);

	mov	ecx, DWORD PTR _pLoopUnit$226074[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDirectiveAdmiral@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ; CvPlayerAI::GetDirectiveAdmiral
	mov	DWORD PTR _eDirective$226079[ebp], eax
$LN10@ProcessGre:

; 882  : 			break;
; 883  : 		}
; 884  : 
; 885  : 		pLoopUnit->SetGreatPeopleDirective(eDirective);

	mov	edx, DWORD PTR _eDirective$226079[ebp]
	push	edx
	mov	ecx, DWORD PTR _pLoopUnit$226074[ebp]
	call	?SetGreatPeopleDirective@CvUnit@@QAEXW4GreatPeopleDirectiveTypes@@@Z ; CvUnit::SetGreatPeopleDirective
	jmp	$LN14@ProcessGre
$LN17@ProcessGre:

; 886  : 	}
; 887  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@ProcessGre:
	DD	$LN8@ProcessGre
	DD	$LN4@ProcessGre
	DD	$LN3@ProcessGre
	DD	$LN5@ProcessGre
	DD	$LN6@ProcessGre
	DD	$LN2@ProcessGre
	DD	$LN1@ProcessGre
	DD	$LN9@ProcessGre
	DD	$LN7@ProcessGre
	DD	$LN10@ProcessGre
$LN23@ProcessGre:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	5
	DB	9
	DB	9
	DB	6
	DB	9
	DB	9
	DB	7
	DB	8
?ProcessGreatPeople@CvPlayerAI@@QAEXXZ ENDP		; CvPlayerAI::ProcessGreatPeople
_TEXT	ENDS
PUBLIC	??_C@_0CE@MNJNOLKD@MILITARYAISTRATEGY_WAR_MOBILIZAT@ ; `string'
PUBLIC	?PreparingForWar@@YA_NPAVCvPlayerAI@@@Z		; PreparingForWar
EXTRN	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z:PROC ; CvMilitaryAI::IsUsingStrategy
EXTRN	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ:PROC ; CvPlayer::GetMilitaryAI
;	COMDAT ??_C@_0CE@MNJNOLKD@MILITARYAISTRATEGY_WAR_MOBILIZAT@
CONST	SEGMENT
??_C@_0CE@MNJNOLKD@MILITARYAISTRATEGY_WAR_MOBILIZAT@ DB 'MILITARYAISTRATE'
	DB	'GY_WAR_MOBILIZATION', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?PreparingForWar@@YA_NPAVCvPlayerAI@@@Z
_TEXT	SEGMENT
_pMilitaryAI$ = -8					; size = 4
_eWarMobilizationStrategy$ = -4				; size = 4
_pPlayer$ = 8						; size = 4
?PreparingForWar@@YA_NPAVCvPlayerAI@@@Z PROC		; PreparingForWar, COMDAT

; 890  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 891  : 	CvAssertMsg(pPlayer, "Need a player");
; 892  : 	if(!pPlayer)

	cmp	DWORD PTR _pPlayer$[ebp], 0
	jne	SHORT $LN3@PreparingF

; 893  : 	{
; 894  : 		return false;

	xor	al, al
	jmp	SHORT $LN4@PreparingF
$LN3@PreparingF:

; 895  : 	}
; 896  : 	CvMilitaryAI* pMilitaryAI = pPlayer->GetMilitaryAI();

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	DWORD PTR _pMilitaryAI$[ebp], eax

; 897  : 	CvAssertMsg(pMilitaryAI, "No military AI");
; 898  : 	if(!pMilitaryAI)

	cmp	DWORD PTR _pMilitaryAI$[ebp], 0
	jne	SHORT $LN2@PreparingF

; 899  : 	{
; 900  : 		return false;

	xor	al, al
	jmp	SHORT $LN4@PreparingF
$LN2@PreparingF:

; 901  : 	}
; 902  : 
; 903  : 	MilitaryAIStrategyTypes eWarMobilizationStrategy = (MilitaryAIStrategyTypes)GC.getInfoTypeForString("MILITARYAISTRATEGY_WAR_MOBILIZATION");

	push	0
	push	OFFSET ??_C@_0CE@MNJNOLKD@MILITARYAISTRATEGY_WAR_MOBILIZAT@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eWarMobilizationStrategy$[ebp], eax

; 904  : 	if(pMilitaryAI->IsUsingStrategy(eWarMobilizationStrategy))

	mov	eax, DWORD PTR _eWarMobilizationStrategy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pMilitaryAI$[ebp]
	call	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::IsUsingStrategy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@PreparingF

; 905  : 	{
; 906  : 		return true;

	mov	al, 1
	jmp	SHORT $LN4@PreparingF
$LN1@PreparingF:

; 907  : 	}
; 908  : 
; 909  : 	return false;

	xor	al, al
$LN4@PreparingF:

; 910  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PreparingForWar@@YA_NPAVCvPlayerAI@@@Z ENDP		; PreparingForWar
_TEXT	ENDS
PUBLIC	??_C@_0BK@KDAIIFJ@MILITARYAISTRATEGY_AT_WAR?$AA@ ; `string'
PUBLIC	?IsSafe@@YA_NPAVCvPlayerAI@@@Z			; IsSafe
EXTRN	?GetStateAllWars@CvDiplomacyAI@@QBE?AW4StateAllWars@@XZ:PROC ; CvDiplomacyAI::GetStateAllWars
;	COMDAT ??_C@_0BK@KDAIIFJ@MILITARYAISTRATEGY_AT_WAR?$AA@
CONST	SEGMENT
??_C@_0BK@KDAIIFJ@MILITARYAISTRATEGY_AT_WAR?$AA@ DB 'MILITARYAISTRATEGY_A'
	DB	'T_WAR', 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?IsSafe@@YA_NPAVCvPlayerAI@@@Z
_TEXT	SEGMENT
_pMilitaryAI$226109 = -8				; size = 4
_eAtWarStrategy$226111 = -4				; size = 4
_pPlayer$ = 8						; size = 4
?IsSafe@@YA_NPAVCvPlayerAI@@@Z PROC			; IsSafe, COMDAT

; 913  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 914  : 	CvAssertMsg(pPlayer, "Need a player");
; 915  : 	if(!pPlayer)

	cmp	DWORD PTR _pPlayer$[ebp], 0
	jne	SHORT $LN5@IsSafe

; 916  : 	{
; 917  : 		return false;

	xor	al, al
	jmp	SHORT $LN6@IsSafe
$LN5@IsSafe:

; 918  : 	}
; 919  : 
; 920  : 	if(pPlayer->GetDiplomacyAI()->GetStateAllWars() == STATE_ALL_WARS_WINNING)

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetStateAllWars@CvDiplomacyAI@@QBE?AW4StateAllWars@@XZ ; CvDiplomacyAI::GetStateAllWars
	cmp	eax, 1
	jne	SHORT $LN4@IsSafe

; 921  : 	{
; 922  : 		return true;

	mov	al, 1
	jmp	SHORT $LN6@IsSafe

; 923  : 	}
; 924  : 	else

	jmp	SHORT $LN6@IsSafe
$LN4@IsSafe:

; 925  : 	{
; 926  : 		CvMilitaryAI* pMilitaryAI = pPlayer->GetMilitaryAI();

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	DWORD PTR _pMilitaryAI$226109[ebp], eax

; 927  : 		CvAssertMsg(pMilitaryAI, "No military AI");
; 928  : 		if(!pMilitaryAI)

	cmp	DWORD PTR _pMilitaryAI$226109[ebp], 0
	jne	SHORT $LN2@IsSafe

; 929  : 		{
; 930  : 			return false;

	xor	al, al
	jmp	SHORT $LN6@IsSafe
$LN2@IsSafe:

; 931  : 		}
; 932  : 
; 933  : 		MilitaryAIStrategyTypes eAtWarStrategy = (MilitaryAIStrategyTypes)GC.getInfoTypeForString("MILITARYAISTRATEGY_AT_WAR");

	push	0
	push	OFFSET ??_C@_0BK@KDAIIFJ@MILITARYAISTRATEGY_AT_WAR?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eAtWarStrategy$226111[ebp], eax

; 934  : 		if(!pMilitaryAI->IsUsingStrategy(eAtWarStrategy))

	mov	eax, DWORD PTR _eAtWarStrategy$226111[ebp]
	push	eax
	mov	ecx, DWORD PTR _pMilitaryAI$226109[ebp]
	call	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::IsUsingStrategy
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@IsSafe

; 935  : 		{
; 936  : 			return true;

	mov	al, 1
	jmp	SHORT $LN6@IsSafe
$LN1@IsSafe:

; 937  : 		}
; 938  : 
; 939  : 		return false;

	xor	al, al
$LN6@IsSafe:

; 940  : 	}
; 941  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsSafe@@YA_NPAVCvPlayerAI@@@Z ENDP			; IsSafe
_TEXT	ENDS
EXTRN	?GetBestGreatWorkCity@CvEconomicAI@@QBEPAVCvCity@@PAVCvPlot@@W4GreatWorkType@@@Z:PROC ; CvEconomicAI::GetBestGreatWorkCity
EXTRN	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ:PROC ; CvPlayer::GetEconomicAI
EXTRN	?plot@CvUnit@@QBEPAVCvPlot@@XZ:PROC		; CvUnit::plot
EXTRN	?GetGreatWork@CvUnit@@QBE?AW4GreatWorkType@@XZ:PROC ; CvUnit::GetGreatWork
EXTRN	?CanGetAdvancedTenet@CvPlayerPolicies@@QBE_NXZ:PROC ; CvPlayerPolicies::CanGetAdvancedTenet
EXTRN	?GetPublicOpinionUnhappiness@CvPlayerCulture@@QBEHXZ:PROC ; CvPlayerCulture::GetPublicOpinionUnhappiness
EXTRN	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ:PROC ; CvPlayer::GetCulture
; Function compile flags: /Odtp
;	COMDAT ?GetDirectiveWriter@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_eGreatWork$ = -8					; size = 4
_eDirective$ = -4					; size = 4
_pGreatWriter$ = 8					; size = 4
?GetDirectiveWriter@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z PROC ; CvPlayerAI::GetDirectiveWriter, COMDAT
; _this$ = ecx

; 944  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 945  : 	GreatPeopleDirectiveTypes eDirective = NO_GREAT_PEOPLE_DIRECTIVE_TYPE;

	mov	DWORD PTR _eDirective$[ebp], -1

; 946  : 
; 947  : 	// Defend against ideology pressure if not going for culture win
; 948  : #ifdef AUI_WARNING_FIXES
; 949  : 	if (!GetDiplomacyAI()->IsGoingForCultureVictory() && GetCulture()->GetPublicOpinionUnhappiness() > 10)
; 950  : #else
; 951  : 	if (eDirective == NO_GREAT_PEOPLE_DIRECTIVE_TYPE && !GetDiplomacyAI()->IsGoingForCultureVictory() && GetCulture()->GetPublicOpinionUnhappiness() > 10)

	cmp	DWORD PTR _eDirective$[ebp], -1
	jne	SHORT $LN4@GetDirecti
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsGoingForCultureVictory@CvDiplomacyAI@@QAE_NXZ ; CvDiplomacyAI::IsGoingForCultureVictory
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@GetDirecti
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetPublicOpinionUnhappiness@CvPlayerCulture@@QBEHXZ ; CvPlayerCulture::GetPublicOpinionUnhappiness
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN4@GetDirecti

; 952  : #endif
; 953  : 	{
; 954  : 		eDirective = GREAT_PEOPLE_DIRECTIVE_CULTURE_BLAST;

	mov	DWORD PTR _eDirective$[ebp], 4
$LN4@GetDirecti:

; 955  : 	}
; 956  : 
; 957  : 	// If not going for culture win and a Level 2 or 3 Tenet is available, try to snag it
; 958  : 	if (eDirective == NO_GREAT_PEOPLE_DIRECTIVE_TYPE && !GetDiplomacyAI()->IsGoingForCultureVictory() && GetPlayerPolicies()->CanGetAdvancedTenet())

	cmp	DWORD PTR _eDirective$[ebp], -1
	jne	SHORT $LN3@GetDirecti
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsGoingForCultureVictory@CvDiplomacyAI@@QAE_NXZ ; CvDiplomacyAI::IsGoingForCultureVictory
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@GetDirecti
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?CanGetAdvancedTenet@CvPlayerPolicies@@QBE_NXZ ; CvPlayerPolicies::CanGetAdvancedTenet
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@GetDirecti

; 959  : 	{
; 960  : 		eDirective = GREAT_PEOPLE_DIRECTIVE_CULTURE_BLAST;

	mov	DWORD PTR _eDirective$[ebp], 4
$LN3@GetDirecti:

; 961  : 	}
; 962  : 
; 963  : 	// Create Great Work if there is a slot
; 964  : 	GreatWorkType eGreatWork = pGreatWriter->GetGreatWork();

	mov	ecx, DWORD PTR _pGreatWriter$[ebp]
	call	?GetGreatWork@CvUnit@@QBE?AW4GreatWorkType@@XZ ; CvUnit::GetGreatWork
	mov	DWORD PTR _eGreatWork$[ebp], eax

; 965  : 	if (eDirective == NO_GREAT_PEOPLE_DIRECTIVE_TYPE && GetEconomicAI()->GetBestGreatWorkCity(pGreatWriter->plot(), eGreatWork))

	cmp	DWORD PTR _eDirective$[ebp], -1
	jne	SHORT $LN2@GetDirecti
	mov	eax, DWORD PTR _eGreatWork$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pGreatWriter$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?GetBestGreatWorkCity@CvEconomicAI@@QBEPAVCvCity@@PAVCvPlot@@W4GreatWorkType@@@Z ; CvEconomicAI::GetBestGreatWorkCity
	test	eax, eax
	je	SHORT $LN2@GetDirecti

; 966  : 	{
; 967  : 		eDirective = GREAT_PEOPLE_DIRECTIVE_USE_POWER;

	mov	DWORD PTR _eDirective$[ebp], 1

; 968  : 	}
; 969  : 	else

	jmp	SHORT $LN1@GetDirecti
$LN2@GetDirecti:

; 970  : 	{
; 971  : 		eDirective = GREAT_PEOPLE_DIRECTIVE_CULTURE_BLAST;

	mov	DWORD PTR _eDirective$[ebp], 4
$LN1@GetDirecti:

; 972  : 	}
; 973  : 
; 974  : 	return eDirective;

	mov	eax, DWORD PTR _eDirective$[ebp]

; 975  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetDirectiveWriter@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ENDP ; CvPlayerAI::GetDirectiveWriter
_TEXT	ENDS
EXTRN	?GetNumCivsInfluentialOn@CvPlayerCulture@@QBEHXZ:PROC ; CvPlayerCulture::GetNumCivsInfluentialOn
EXTRN	?isGoldenAge@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isGoldenAge
EXTRN	?GetNumberCivsAtWarWith@CvMilitaryAI@@QBEHXZ:PROC ; CvMilitaryAI::GetNumberCivsAtWarWith
EXTRN	?IsTestStrategy_GS_SpaceshipHomestretch@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z:PROC ; EconomicAIHelpers::IsTestStrategy_GS_SpaceshipHomestretch
EXTRN	?IsGoingForSpaceshipVictory@CvDiplomacyAI@@QAE_NXZ:PROC ; CvDiplomacyAI::IsGoingForSpaceshipVictory
; Function compile flags: /Odtp
;	COMDAT ?GetDirectiveArtist@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T230974 = -24						; size = 4
$T230973 = -20						; size = 4
$T230969 = -16						; size = 4
$T230968 = -12						; size = 4
_eGreatWork$ = -8					; size = 4
_eDirective$ = -4					; size = 4
_pGreatArtist$ = 8					; size = 4
?GetDirectiveArtist@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z PROC ; CvPlayerAI::GetDirectiveArtist, COMDAT
; _this$ = ecx

; 978  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 979  : 	GreatPeopleDirectiveTypes eDirective = NO_GREAT_PEOPLE_DIRECTIVE_TYPE;

	mov	DWORD PTR _eDirective$[ebp], -1

; 980  : 
; 981  : 	// Defend against ideology pressure if not going for culture win
; 982  : #ifdef AUI_WARNING_FIXES
; 983  : 	if (!GetDiplomacyAI()->IsGoingForCultureVictory() && GetCulture()->GetPublicOpinionUnhappiness() > 10)
; 984  : #else
; 985  : 	if (eDirective == NO_GREAT_PEOPLE_DIRECTIVE_TYPE && !GetDiplomacyAI()->IsGoingForCultureVictory() && GetCulture()->GetPublicOpinionUnhappiness() > 10)

	cmp	DWORD PTR _eDirective$[ebp], -1
	jne	SHORT $LN7@GetDirecti@2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsGoingForCultureVictory@CvDiplomacyAI@@QAE_NXZ ; CvDiplomacyAI::IsGoingForCultureVictory
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN7@GetDirecti@2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetPublicOpinionUnhappiness@CvPlayerCulture@@QBEHXZ ; CvPlayerCulture::GetPublicOpinionUnhappiness
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN7@GetDirecti@2

; 986  : #endif
; 987  : 	{
; 988  : 		eDirective = GREAT_PEOPLE_DIRECTIVE_GOLDEN_AGE;

	mov	DWORD PTR _eDirective$[ebp], 0
$LN7@GetDirecti@2:

; 989  : 	}
; 990  : 
; 991  : 	// If prepping for war, Golden Age will build units quickly
; 992  : 	if (eDirective == NO_GREAT_PEOPLE_DIRECTIVE_TYPE && !GetDiplomacyAI()->IsGoingForCultureVictory() && PreparingForWar(this))

	cmp	DWORD PTR _eDirective$[ebp], -1
	jne	SHORT $LN6@GetDirecti@2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsGoingForCultureVictory@CvDiplomacyAI@@QAE_NXZ ; CvDiplomacyAI::IsGoingForCultureVictory
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN6@GetDirecti@2
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?PreparingForWar@@YA_NPAVCvPlayerAI@@@Z	; PreparingForWar
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@GetDirecti@2

; 993  : 	{
; 994  : 		eDirective = GREAT_PEOPLE_DIRECTIVE_GOLDEN_AGE;

	mov	DWORD PTR _eDirective$[ebp], 0
$LN6@GetDirecti@2:

; 995  : 	}
; 996  : 
; 997  : 	// If finishing up spaceship parts, Golden Age will help build those quickly
; 998  : 	if (eDirective == NO_GREAT_PEOPLE_DIRECTIVE_TYPE && GetDiplomacyAI()->IsGoingForSpaceshipVictory() && EconomicAIHelpers::IsTestStrategy_GS_SpaceshipHomestretch(this))

	cmp	DWORD PTR _eDirective$[ebp], -1
	jne	SHORT $LN5@GetDirecti@2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsGoingForSpaceshipVictory@CvDiplomacyAI@@QAE_NXZ ; CvDiplomacyAI::IsGoingForSpaceshipVictory
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@GetDirecti@2
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?IsTestStrategy_GS_SpaceshipHomestretch@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_GS_SpaceshipHomestretch
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@GetDirecti@2

; 999  : 	{
; 1000 : 		eDirective = GREAT_PEOPLE_DIRECTIVE_GOLDEN_AGE;

	mov	DWORD PTR _eDirective$[ebp], 0
$LN5@GetDirecti@2:

; 1001 : 	}
; 1002 : 
; 1003 : 	// If Persia and I'm at war, get a Golden Age going
; 1004 : 	if (eDirective == NO_GREAT_PEOPLE_DIRECTIVE_TYPE && GetPlayerTraits()->GetGoldenAgeMoveChange() > 0 && GetMilitaryAI()->GetNumberCivsAtWarWith() > 1 && !isGoldenAge())

	cmp	DWORD PTR _eDirective$[ebp], -1
	jne	SHORT $LN4@GetDirecti@2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T230968[ebp], eax
	mov	ecx, DWORD PTR $T230968[ebp]
	mov	edx, DWORD PTR [ecx+176]
	mov	DWORD PTR $T230969[ebp], edx
	cmp	DWORD PTR $T230969[ebp], 0
	jle	SHORT $LN4@GetDirecti@2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?GetNumberCivsAtWarWith@CvMilitaryAI@@QBEHXZ ; CvMilitaryAI::GetNumberCivsAtWarWith
	cmp	eax, 1
	jle	SHORT $LN4@GetDirecti@2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isGoldenAge@CvPlayer@@QBE_NXZ		; CvPlayer::isGoldenAge
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@GetDirecti@2

; 1005 : 	{
; 1006 : 		eDirective = GREAT_PEOPLE_DIRECTIVE_GOLDEN_AGE;

	mov	DWORD PTR _eDirective$[ebp], 0
$LN4@GetDirecti@2:

; 1007 : 	}
; 1008 : 
; 1009 : 	// If Brazil and we're closing in on Culture Victory
; 1010 : 	if (eDirective == NO_GREAT_PEOPLE_DIRECTIVE_TYPE && GetPlayerTraits()->GetGoldenAgeTourismModifier() > 0 && GetCulture()->GetNumCivsInfluentialOn() > 0)

	cmp	DWORD PTR _eDirective$[ebp], -1
	jne	SHORT $LN3@GetDirecti@2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T230973[ebp], eax
	mov	ecx, DWORD PTR $T230973[ebp]
	mov	edx, DWORD PTR [ecx+184]
	mov	DWORD PTR $T230974[ebp], edx
	cmp	DWORD PTR $T230974[ebp], 0
	jle	SHORT $LN3@GetDirecti@2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetNumCivsInfluentialOn@CvPlayerCulture@@QBEHXZ ; CvPlayerCulture::GetNumCivsInfluentialOn
	test	eax, eax
	jle	SHORT $LN3@GetDirecti@2

; 1011 : 	{
; 1012 : 		eDirective = GREAT_PEOPLE_DIRECTIVE_GOLDEN_AGE;

	mov	DWORD PTR _eDirective$[ebp], 0
$LN3@GetDirecti@2:

; 1013 : 	}
; 1014 : 
; 1015 : 	// Create Great Work if there is a slot
; 1016 : 	GreatWorkType eGreatWork = pGreatArtist->GetGreatWork();

	mov	ecx, DWORD PTR _pGreatArtist$[ebp]
	call	?GetGreatWork@CvUnit@@QBE?AW4GreatWorkType@@XZ ; CvUnit::GetGreatWork
	mov	DWORD PTR _eGreatWork$[ebp], eax

; 1017 : 	if (eDirective == NO_GREAT_PEOPLE_DIRECTIVE_TYPE && GetEconomicAI()->GetBestGreatWorkCity(pGreatArtist->plot(), eGreatWork))

	cmp	DWORD PTR _eDirective$[ebp], -1
	jne	SHORT $LN2@GetDirecti@2
	mov	eax, DWORD PTR _eGreatWork$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pGreatArtist$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?GetBestGreatWorkCity@CvEconomicAI@@QBEPAVCvCity@@PAVCvPlot@@W4GreatWorkType@@@Z ; CvEconomicAI::GetBestGreatWorkCity
	test	eax, eax
	je	SHORT $LN2@GetDirecti@2

; 1018 : 	{
; 1019 : 		eDirective = GREAT_PEOPLE_DIRECTIVE_USE_POWER;

	mov	DWORD PTR _eDirective$[ebp], 1
$LN2@GetDirecti@2:

; 1020 : 	}
; 1021 : 
; 1022 : 	if (eDirective == NO_GREAT_PEOPLE_DIRECTIVE_TYPE && !isGoldenAge())

	cmp	DWORD PTR _eDirective$[ebp], -1
	jne	SHORT $LN1@GetDirecti@2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isGoldenAge@CvPlayer@@QBE_NXZ		; CvPlayer::isGoldenAge
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@GetDirecti@2

; 1023 : 	{
; 1024 : 		eDirective = GREAT_PEOPLE_DIRECTIVE_GOLDEN_AGE;

	mov	DWORD PTR _eDirective$[ebp], 0
$LN1@GetDirecti@2:

; 1025 : 	}
; 1026 : 
; 1027 : 	return eDirective;

	mov	eax, DWORD PTR _eDirective$[ebp]

; 1028 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetDirectiveArtist@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ENDP ; CvPlayerAI::GetDirectiveArtist
_TEXT	ENDS
PUBLIC	?FindBestMusicianTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z ; CvPlayerAI::FindBestMusicianTargetPlot
EXTRN	?GetNumCivsInfluentialForWin@CvGameCulture@@QBEHXZ:PROC ; CvGameCulture::GetNumCivsInfluentialForWin
EXTRN	?GetGameCulture@CvGame@@QAEPAVCvGameCulture@@XZ:PROC ; CvGame::GetGameCulture
EXTRN	?getArmyID@CvUnit@@QBEHXZ:PROC			; CvUnit::getArmyID
; Function compile flags: /Odtp
;	COMDAT ?GetDirectiveMusician@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T230980 = -20						; size = 4
_pTarget$226150 = -16					; size = 4
_pTarget$226145 = -12					; size = 4
_eGreatWork$ = -8					; size = 4
_eDirective$ = -4					; size = 4
_pGreatMusician$ = 8					; size = 4
?GetDirectiveMusician@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z PROC ; CvPlayerAI::GetDirectiveMusician, COMDAT
; _this$ = ecx

; 1031 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1032 : 	GreatPeopleDirectiveTypes eDirective = NO_GREAT_PEOPLE_DIRECTIVE_TYPE;

	mov	DWORD PTR _eDirective$[ebp], -1

; 1033 : 
; 1034 : 	// If headed on a concert tour, keep going
; 1035 : 	if (pGreatMusician->getArmyID() != FFreeList::INVALID_INDEX)

	mov	ecx, DWORD PTR _pGreatMusician$[ebp]
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, -1
	je	SHORT $LN6@GetDirecti@3

; 1036 : 	{
; 1037 : 		eDirective = GREAT_PEOPLE_DIRECTIVE_TOURISM_BLAST;

	mov	DWORD PTR _eDirective$[ebp], 5
$LN6@GetDirecti@3:

; 1038 : 	}
; 1039 : 
; 1040 : 	// If closing in on a Culture win, go for the Concert Tour
; 1041 : 	if (eDirective == NO_GREAT_PEOPLE_DIRECTIVE_TYPE && GetDiplomacyAI()->IsGoingForCultureVictory() && GetCulture()->GetNumCivsInfluentialOn() > (GC.getGame().GetGameCulture()->GetNumCivsInfluentialForWin() / 2))

	cmp	DWORD PTR _eDirective$[ebp], -1
	jne	SHORT $LN5@GetDirecti@3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsGoingForCultureVictory@CvDiplomacyAI@@QAE_NXZ ; CvDiplomacyAI::IsGoingForCultureVictory
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@GetDirecti@3
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T230980[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetNumCivsInfluentialOn@CvPlayerCulture@@QBEHXZ ; CvPlayerCulture::GetNumCivsInfluentialOn
	mov	esi, eax
	mov	ecx, DWORD PTR $T230980[ebp]
	call	?GetGameCulture@CvGame@@QAEPAVCvGameCulture@@XZ ; CvGame::GetGameCulture
	mov	ecx, eax
	call	?GetNumCivsInfluentialForWin@CvGameCulture@@QBEHXZ ; CvGameCulture::GetNumCivsInfluentialForWin
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	esi, eax
	jle	SHORT $LN5@GetDirecti@3

; 1042 : 	{		
; 1043 : 		CvPlot* pTarget = FindBestMusicianTargetPlot(pGreatMusician, true);

	push	1
	mov	edx, DWORD PTR _pGreatMusician$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindBestMusicianTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z ; CvPlayerAI::FindBestMusicianTargetPlot
	mov	DWORD PTR _pTarget$226145[ebp], eax

; 1044 : 		if(pTarget)

	cmp	DWORD PTR _pTarget$226145[ebp], 0
	je	SHORT $LN5@GetDirecti@3

; 1045 : 		{
; 1046 : 			eDirective = GREAT_PEOPLE_DIRECTIVE_TOURISM_BLAST;

	mov	DWORD PTR _eDirective$[ebp], 5
$LN5@GetDirecti@3:

; 1047 : 		}
; 1048 : 	}
; 1049 : 
; 1050 : 	// Create Great Work if there is a slot
; 1051 : 	GreatWorkType eGreatWork = pGreatMusician->GetGreatWork();

	mov	ecx, DWORD PTR _pGreatMusician$[ebp]
	call	?GetGreatWork@CvUnit@@QBE?AW4GreatWorkType@@XZ ; CvUnit::GetGreatWork
	mov	DWORD PTR _eGreatWork$[ebp], eax

; 1052 : 	if (eDirective == NO_GREAT_PEOPLE_DIRECTIVE_TYPE && GetEconomicAI()->GetBestGreatWorkCity(pGreatMusician->plot(), eGreatWork))

	cmp	DWORD PTR _eDirective$[ebp], -1
	jne	SHORT $LN3@GetDirecti@3
	mov	eax, DWORD PTR _eGreatWork$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pGreatMusician$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?GetBestGreatWorkCity@CvEconomicAI@@QBEPAVCvCity@@PAVCvPlot@@W4GreatWorkType@@@Z ; CvEconomicAI::GetBestGreatWorkCity
	test	eax, eax
	je	SHORT $LN3@GetDirecti@3

; 1053 : 	{
; 1054 : 		eDirective = GREAT_PEOPLE_DIRECTIVE_USE_POWER;

	mov	DWORD PTR _eDirective$[ebp], 1

; 1055 : 	}
; 1056 : 	else

	jmp	SHORT $LN2@GetDirecti@3
$LN3@GetDirecti@3:

; 1057 : 	{
; 1058 : 		CvPlot* pTarget = FindBestMusicianTargetPlot(pGreatMusician, true);

	push	1
	mov	ecx, DWORD PTR _pGreatMusician$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindBestMusicianTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z ; CvPlayerAI::FindBestMusicianTargetPlot
	mov	DWORD PTR _pTarget$226150[ebp], eax

; 1059 : 		if(pTarget)

	cmp	DWORD PTR _pTarget$226150[ebp], 0
	je	SHORT $LN2@GetDirecti@3

; 1060 : 		{
; 1061 : 			eDirective = GREAT_PEOPLE_DIRECTIVE_TOURISM_BLAST;

	mov	DWORD PTR _eDirective$[ebp], 5
$LN2@GetDirecti@3:

; 1062 : 		}
; 1063 : 	}
; 1064 : 
; 1065 : 	return eDirective;

	mov	eax, DWORD PTR _eDirective$[ebp]

; 1066 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?GetDirectiveMusician@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ENDP ; CvPlayerAI::GetDirectiveMusician
_TEXT	ENDS
EXTRN	?getGameTurnCreated@CvUnit@@QBEHXZ:PROC		; CvUnit::getGameTurnCreated
EXTRN	?IsGoingForWorldConquest@CvDiplomacyAI@@QAE_NXZ:PROC ; CvDiplomacyAI::IsGoingForWorldConquest
EXTRN	?ChooseWonder@CvWonderProductionAI@@QAE?AW4BuildingTypes@@_N0AAH@Z:PROC ; CvWonderProductionAI::ChooseWonder
EXTRN	?GetWonderProductionAI@CvPlayer@@QBEPAVCvWonderProductionAI@@XZ:PROC ; CvPlayer::GetWonderProductionAI
; Function compile flags: /Odtp
;	COMDAT ?GetDirectiveEngineer@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T230998 = -28						; size = 4
$T230994 = -24						; size = 4
$T230990 = -20						; size = 4
$T230986 = -16						; size = 4
_eNextWonderDesired$226159 = -12			; size = 4
_iNextWonderWeight$226158 = -8				; size = 4
_eDirective$ = -4					; size = 4
_pGreatEngineer$ = 8					; size = 4
?GetDirectiveEngineer@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z PROC ; CvPlayerAI::GetDirectiveEngineer, COMDAT
; _this$ = ecx

; 1069 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1070 : 	GreatPeopleDirectiveTypes eDirective = NO_GREAT_PEOPLE_DIRECTIVE_TYPE;

	mov	DWORD PTR _eDirective$[ebp], -1

; 1071 : 
; 1072 : 	// look for a wonder to rush
; 1073 : 	if(eDirective == NO_GREAT_PEOPLE_DIRECTIVE_TYPE)

	cmp	DWORD PTR _eDirective$[ebp], -1
	jne	SHORT $LN5@GetDirecti@4

; 1074 : 	{
; 1075 : 		int iNextWonderWeight;
; 1076 : 		BuildingTypes eNextWonderDesired = GetWonderProductionAI()->ChooseWonder(false /*bUseAsyncRandom*/, false /*bAdjustForOtherPlayers*/, iNextWonderWeight);

	lea	eax, DWORD PTR _iNextWonderWeight$226158[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetWonderProductionAI@CvPlayer@@QBEPAVCvWonderProductionAI@@XZ ; CvPlayer::GetWonderProductionAI
	mov	ecx, eax
	call	?ChooseWonder@CvWonderProductionAI@@QAE?AW4BuildingTypes@@_N0AAH@Z ; CvWonderProductionAI::ChooseWonder
	mov	DWORD PTR _eNextWonderDesired$226159[ebp], eax

; 1077 : 		if(eNextWonderDesired != NO_BUILDING)

	cmp	DWORD PTR _eNextWonderDesired$226159[ebp], -1
	je	SHORT $LN5@GetDirecti@4

; 1078 : 		{
; 1079 : 			eDirective = GREAT_PEOPLE_DIRECTIVE_USE_POWER;

	mov	DWORD PTR _eDirective$[ebp], 1
$LN5@GetDirecti@4:

; 1080 : 		}
; 1081 : 	}
; 1082 : 
; 1083 : 	if (eDirective == NO_GREAT_PEOPLE_DIRECTIVE_TYPE && GC.getGame().getGameTurn() <= ((GC.getGame().getEstimateEndTurn() * 3) / 4))

	cmp	DWORD PTR _eDirective$[ebp], -1
	jne	SHORT $LN3@GetDirecti@4
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T230986[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T230990[ebp], edx
	mov	ecx, DWORD PTR $T230986[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	esi, eax
	mov	ecx, DWORD PTR $T230990[ebp]
	call	?getEstimateEndTurn@CvGame@@QBEHXZ	; CvGame::getEstimateEndTurn
	imul	eax, 3
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	cmp	esi, eax
	jg	SHORT $LN3@GetDirecti@4

; 1084 : 	{
; 1085 : 		if (GetDiplomacyAI()->IsGoingForWorldConquest())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsGoingForWorldConquest@CvDiplomacyAI@@QAE_NXZ ; CvDiplomacyAI::IsGoingForWorldConquest
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@GetDirecti@4

; 1086 : 		{
; 1087 : 			eDirective = GREAT_PEOPLE_DIRECTIVE_CONSTRUCT_IMPROVEMENT;

	mov	DWORD PTR _eDirective$[ebp], 2
$LN3@GetDirecti@4:

; 1088 : 		}
; 1089 : 	}
; 1090 : 
; 1091 : 	if(eDirective == NO_GREAT_PEOPLE_DIRECTIVE_TYPE && (GC.getGame().getGameTurn() - pGreatEngineer->getGameTurnCreated()) >= GC.getAI_HOMELAND_GREAT_PERSON_TURNS_TO_WAIT())

	cmp	DWORD PTR _eDirective$[ebp], -1
	jne	SHORT $LN1@GetDirecti@4
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T230994[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2700
	mov	DWORD PTR $T230998[ebp], edx
	mov	ecx, DWORD PTR $T230994[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	esi, eax
	mov	ecx, DWORD PTR _pGreatEngineer$[ebp]
	call	?getGameTurnCreated@CvUnit@@QBEHXZ	; CvUnit::getGameTurnCreated
	sub	esi, eax
	cmp	esi, DWORD PTR $T230998[ebp]
	jl	SHORT $LN1@GetDirecti@4

; 1092 : 	{
; 1093 : 		eDirective = GREAT_PEOPLE_DIRECTIVE_CONSTRUCT_IMPROVEMENT;

	mov	DWORD PTR _eDirective$[ebp], 2
$LN1@GetDirecti@4:

; 1094 : 	}
; 1095 : 
; 1096 : 	return eDirective;

	mov	eax, DWORD PTR _eDirective$[ebp]

; 1097 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?GetDirectiveEngineer@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ENDP ; CvPlayerAI::GetDirectiveEngineer
_TEXT	ENDS
PUBLIC	?FindBestMerchantTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z ; CvPlayerAI::FindBestMerchantTargetPlot
; Function compile flags: /Odtp
;	COMDAT ?GetDirectiveMerchant@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T231021 = -36						; size = 4
$T231017 = -32						; size = 4
$T231013 = -28						; size = 4
$T231009 = -24						; size = 4
$T231005 = -17						; size = 1
$T231004 = -16						; size = 4
_pTarget$226175 = -12					; size = 4
_bTheVeniceException$ = -5				; size = 1
_eDirective$ = -4					; size = 4
_pGreatMerchant$ = 8					; size = 4
?GetDirectiveMerchant@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z PROC ; CvPlayerAI::GetDirectiveMerchant, COMDAT
; _this$ = ecx

; 1100 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1101 : 	GreatPeopleDirectiveTypes eDirective = NO_GREAT_PEOPLE_DIRECTIVE_TYPE;

	mov	DWORD PTR _eDirective$[ebp], -1

; 1102 : 
; 1103 : 	bool bTheVeniceException = false;

	mov	BYTE PTR _bTheVeniceException$[ebp], 0

; 1104 : 	if (GetPlayerTraits()->IsNoAnnexing())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T231004[ebp], eax
	mov	eax, DWORD PTR $T231004[ebp]
	mov	cl, BYTE PTR [eax+351]
	mov	BYTE PTR $T231005[ebp], cl
	movzx	edx, BYTE PTR $T231005[ebp]
	test	edx, edx
	je	SHORT $LN7@GetDirecti@5

; 1105 : 	{
; 1106 : 		bTheVeniceException = true;

	mov	BYTE PTR _bTheVeniceException$[ebp], 1
$LN7@GetDirecti@5:

; 1107 : 	}
; 1108 : 
; 1109 : 	// if the merchant is in an army, he's already marching to a destination, so don't evaluate him
; 1110 : 	if(pGreatMerchant->getArmyID() != FFreeList::INVALID_INDEX)

	mov	ecx, DWORD PTR _pGreatMerchant$[ebp]
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, -1
	je	SHORT $LN6@GetDirecti@5

; 1111 : 	{
; 1112 : 		return NO_GREAT_PEOPLE_DIRECTIVE_TYPE;

	or	eax, -1
	jmp	$LN8@GetDirecti@5
$LN6@GetDirecti@5:

; 1113 : 	}
; 1114 : 
; 1115 : #ifdef AUI_WARNING_FIXES
; 1116 : 	if (GC.getGame().getGameTurn() <= ((GC.getGame().getEstimateEndTurn() * 2) / 4))
; 1117 : #else
; 1118 : 	if (eDirective == NO_GREAT_PEOPLE_DIRECTIVE_TYPE && GC.getGame().getGameTurn() <= ((GC.getGame().getEstimateEndTurn() * 2) / 4))

	cmp	DWORD PTR _eDirective$[ebp], -1
	jne	SHORT $LN5@GetDirecti@5
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T231009[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T231013[ebp], ecx
	mov	ecx, DWORD PTR $T231009[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	esi, eax
	mov	ecx, DWORD PTR $T231013[ebp]
	call	?getEstimateEndTurn@CvGame@@QBEHXZ	; CvGame::getEstimateEndTurn
	shl	eax, 1
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	cmp	esi, eax
	jg	SHORT $LN5@GetDirecti@5

; 1119 : #endif
; 1120 : 	{
; 1121 : 		if (GetDiplomacyAI()->IsGoingForDiploVictory() && !bTheVeniceException)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsGoingForDiploVictory@CvDiplomacyAI@@QAE_NXZ ; CvDiplomacyAI::IsGoingForDiploVictory
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN5@GetDirecti@5
	movzx	eax, BYTE PTR _bTheVeniceException$[ebp]
	test	eax, eax
	jne	SHORT $LN5@GetDirecti@5

; 1122 : 		{
; 1123 : 			eDirective = GREAT_PEOPLE_DIRECTIVE_CONSTRUCT_IMPROVEMENT;

	mov	DWORD PTR _eDirective$[ebp], 2
$LN5@GetDirecti@5:

; 1124 : 		}
; 1125 : 	}
; 1126 : 
; 1127 : 	// Attempt a run to a minor civ
; 1128 : 	if(eDirective == NO_GREAT_PEOPLE_DIRECTIVE_TYPE && IsSafe(this))

	cmp	DWORD PTR _eDirective$[ebp], -1
	jne	SHORT $LN3@GetDirecti@5
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?IsSafe@@YA_NPAVCvPlayerAI@@@Z		; IsSafe
	add	esp, 4
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@GetDirecti@5

; 1129 : 	{
; 1130 : 		CvPlot* pTarget = FindBestMerchantTargetPlot(pGreatMerchant, true);

	push	1
	mov	eax, DWORD PTR _pGreatMerchant$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindBestMerchantTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z ; CvPlayerAI::FindBestMerchantTargetPlot
	mov	DWORD PTR _pTarget$226175[ebp], eax

; 1131 : 		if(pTarget)

	cmp	DWORD PTR _pTarget$226175[ebp], 0
	je	SHORT $LN3@GetDirecti@5

; 1132 : 		{
; 1133 : 			eDirective = GREAT_PEOPLE_DIRECTIVE_USE_POWER;

	mov	DWORD PTR _eDirective$[ebp], 1
$LN3@GetDirecti@5:

; 1134 : 		}
; 1135 : 	}
; 1136 : 
; 1137 : 	if(eDirective == NO_GREAT_PEOPLE_DIRECTIVE_TYPE && (GC.getGame().getGameTurn() - pGreatMerchant->getGameTurnCreated()) >= GC.getAI_HOMELAND_GREAT_PERSON_TURNS_TO_WAIT() && !bTheVeniceException)

	cmp	DWORD PTR _eDirective$[ebp], -1
	jne	SHORT $LN1@GetDirecti@5
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T231017[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2700
	mov	DWORD PTR $T231021[ebp], edx
	mov	ecx, DWORD PTR $T231017[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	esi, eax
	mov	ecx, DWORD PTR _pGreatMerchant$[ebp]
	call	?getGameTurnCreated@CvUnit@@QBEHXZ	; CvUnit::getGameTurnCreated
	sub	esi, eax
	cmp	esi, DWORD PTR $T231021[ebp]
	jl	SHORT $LN1@GetDirecti@5
	movzx	eax, BYTE PTR _bTheVeniceException$[ebp]
	test	eax, eax
	jne	SHORT $LN1@GetDirecti@5

; 1138 : 	{
; 1139 : 		eDirective = GREAT_PEOPLE_DIRECTIVE_CONSTRUCT_IMPROVEMENT;

	mov	DWORD PTR _eDirective$[ebp], 2
$LN1@GetDirecti@5:

; 1140 : 	}
; 1141 : 
; 1142 : 	return eDirective;

	mov	eax, DWORD PTR _eDirective$[ebp]
$LN8@GetDirecti@5:

; 1143 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?GetDirectiveMerchant@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ENDP ; CvPlayerAI::GetDirectiveMerchant
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetDirectiveScientist@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T231031 = -12						; size = 4
$T231027 = -8						; size = 4
_eDirective$ = -4					; size = 4
___formal$ = 8						; size = 4
?GetDirectiveScientist@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z PROC ; CvPlayerAI::GetDirectiveScientist, COMDAT
; _this$ = ecx

; 1146 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1147 : 	GreatPeopleDirectiveTypes eDirective = NO_GREAT_PEOPLE_DIRECTIVE_TYPE;

	mov	DWORD PTR _eDirective$[ebp], -1

; 1148 : 
; 1149 : 	// If I'm in danger, use great person to get a tech boost
; 1150 : #ifdef AUI_WARNING_FIXES
; 1151 : 	if (!IsSafe(this))
; 1152 : #else
; 1153 : 	if(eDirective == NO_GREAT_PEOPLE_DIRECTIVE_TYPE && !IsSafe(this))

	cmp	DWORD PTR _eDirective$[ebp], -1
	jne	SHORT $LN4@GetDirecti@6
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?IsSafe@@YA_NPAVCvPlayerAI@@@Z		; IsSafe
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN4@GetDirecti@6

; 1154 : #endif
; 1155 : 	{
; 1156 : 		eDirective = GREAT_PEOPLE_DIRECTIVE_USE_POWER;

	mov	DWORD PTR _eDirective$[ebp], 1
$LN4@GetDirecti@6:

; 1157 : 	}
; 1158 : 
; 1159 : 	if(eDirective == NO_GREAT_PEOPLE_DIRECTIVE_TYPE && GC.getGame().getGameTurn() <= ((GC.getGame().getEstimateEndTurn() * 1) / 4))

	cmp	DWORD PTR _eDirective$[ebp], -1
	jne	SHORT $LN3@GetDirecti@6
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T231027[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T231031[ebp], eax
	mov	ecx, DWORD PTR $T231027[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	esi, eax
	mov	ecx, DWORD PTR $T231031[ebp]
	call	?getEstimateEndTurn@CvGame@@QBEHXZ	; CvGame::getEstimateEndTurn
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	cmp	esi, eax
	jg	SHORT $LN3@GetDirecti@6

; 1160 : 	{
; 1161 : 		if(GetDiplomacyAI()->IsGoingForSpaceshipVictory())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsGoingForSpaceshipVictory@CvDiplomacyAI@@QAE_NXZ ; CvDiplomacyAI::IsGoingForSpaceshipVictory
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@GetDirecti@6

; 1162 : 		{
; 1163 : 			eDirective = GREAT_PEOPLE_DIRECTIVE_CONSTRUCT_IMPROVEMENT;

	mov	DWORD PTR _eDirective$[ebp], 2
$LN3@GetDirecti@6:

; 1164 : 		}
; 1165 : 	}
; 1166 : 
; 1167 : 	if (eDirective == NO_GREAT_PEOPLE_DIRECTIVE_TYPE)

	cmp	DWORD PTR _eDirective$[ebp], -1
	jne	SHORT $LN1@GetDirecti@6

; 1168 : 	{
; 1169 : 		// a tech boost is never bad
; 1170 : 		eDirective = GREAT_PEOPLE_DIRECTIVE_USE_POWER;

	mov	DWORD PTR _eDirective$[ebp], 1
$LN1@GetDirecti@6:

; 1171 : 	}
; 1172 : 
; 1173 : 	return eDirective;

	mov	eax, DWORD PTR _eDirective$[ebp]

; 1174 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?GetDirectiveScientist@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ENDP ; CvPlayerAI::GetDirectiveScientist
_TEXT	ENDS
EXTRN	?GetGreatPeopleDirective@CvUnit@@QBE?AW4GreatPeopleDirectiveTypes@@XZ:PROC ; CvUnit::GetGreatPeopleDirective
; Function compile flags: /Odtp
;	COMDAT ?GetDirectiveGeneral@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T231047 = -32						; size = 4
$T231038 = -28						; size = 4
$T231037 = -24						; size = 4
_pLoopUnit$226196 = -20					; size = 4
_eSpecialUnitGreatPerson$ = -16				; size = 4
_iGreatGeneralCount$ = -12				; size = 4
_eDirective$ = -8					; size = 4
_iLoop$ = -4						; size = 4
_pGreatGeneral$ = 8					; size = 4
?GetDirectiveGeneral@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z PROC ; CvPlayerAI::GetDirectiveGeneral, COMDAT
; _this$ = ecx

; 1177 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 1178 : 	GreatPeopleDirectiveTypes eDirective = NO_GREAT_PEOPLE_DIRECTIVE_TYPE;

	mov	DWORD PTR _eDirective$[ebp], -1

; 1179 : 
; 1180 : 	SpecialUnitTypes eSpecialUnitGreatPerson = (SpecialUnitTypes) GC.getInfoTypeForString("SPECIALUNIT_PEOPLE");

	push	0
	push	OFFSET ??_C@_0BD@NNACGNOP@SPECIALUNIT_PEOPLE?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eSpecialUnitGreatPerson$[ebp], eax

; 1181 : 
; 1182 : 	int iGreatGeneralCount = 0;

	mov	DWORD PTR _iGreatGeneralCount$[ebp], 0

; 1183 : 
; 1184 : 	int iLoop;
; 1185 : 	for(CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$226196[ebp], eax
	jmp	SHORT $LN6@GetDirecti@7
$LN5@GetDirecti@7:
	push	0
	lea	ecx, DWORD PTR _iLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$226196[ebp], eax
$LN6@GetDirecti@7:
	cmp	DWORD PTR _pLoopUnit$226196[ebp], 0
	je	SHORT $LN4@GetDirecti@7

; 1186 : 	{
; 1187 : 		if(pLoopUnit->getSpecialUnitType() != eSpecialUnitGreatPerson)

	mov	ecx, DWORD PTR _pLoopUnit$226196[ebp]
	call	?getSpecialUnitType@CvUnit@@QBE?AW4SpecialUnitTypes@@XZ ; CvUnit::getSpecialUnitType
	cmp	eax, DWORD PTR _eSpecialUnitGreatPerson$[ebp]
	je	SHORT $LN3@GetDirecti@7

; 1188 : 		{
; 1189 : 			continue;

	jmp	SHORT $LN5@GetDirecti@7
$LN3@GetDirecti@7:

; 1190 : 		}
; 1191 : 
; 1192 : 		if(pLoopUnit->AI_getUnitAIType() == UNITAI_GENERAL && pLoopUnit->GetGreatPeopleDirective() != GREAT_PEOPLE_DIRECTIVE_GOLDEN_AGE)

	mov	ecx, DWORD PTR _pLoopUnit$226196[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN2@GetDirecti@7
	mov	ecx, DWORD PTR _pLoopUnit$226196[ebp]
	call	?GetGreatPeopleDirective@CvUnit@@QBE?AW4GreatPeopleDirectiveTypes@@XZ ; CvUnit::GetGreatPeopleDirective
	test	eax, eax
	je	SHORT $LN2@GetDirecti@7

; 1193 : 		{
; 1194 : 			iGreatGeneralCount++;

	mov	edx, DWORD PTR _iGreatGeneralCount$[ebp]
	add	edx, 1
	mov	DWORD PTR _iGreatGeneralCount$[ebp], edx
$LN2@GetDirecti@7:

; 1195 : 		}
; 1196 : 	}

	jmp	SHORT $LN5@GetDirecti@7
$LN4@GetDirecti@7:

; 1197 : 
; 1198 : 	if(iGreatGeneralCount > 2 && pGreatGeneral->plot()->getOwner() == pGreatGeneral->getOwner())

	cmp	DWORD PTR _iGreatGeneralCount$[ebp], 2
	jle	SHORT $LN1@GetDirecti@7
	mov	ecx, DWORD PTR _pGreatGeneral$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR $T231037[ebp], eax
	mov	eax, DWORD PTR $T231037[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR $T231038[ebp], ecx
	mov	edx, DWORD PTR _pGreatGeneral$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR $T231047[ebp], eax
	mov	ecx, DWORD PTR $T231038[ebp]
	cmp	ecx, DWORD PTR $T231047[ebp]
	jne	SHORT $LN1@GetDirecti@7

; 1199 : 	{
; 1200 : 		// we're using a power at this point because constructing the improvement goes through different code
; 1201 : 		eDirective = GREAT_PEOPLE_DIRECTIVE_USE_POWER;

	mov	DWORD PTR _eDirective$[ebp], 1
$LN1@GetDirecti@7:

; 1202 : 	}
; 1203 : 
; 1204 : 	return eDirective;

	mov	eax, DWORD PTR _eDirective$[ebp]

; 1205 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetDirectiveGeneral@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ENDP ; CvPlayerAI::GetDirectiveGeneral
_TEXT	ENDS
EXTRN	?GetNumReligionsStillToFound@CvGameReligions@@QBEHXZ:PROC ; CvGameReligions::GetNumReligionsStillToFound
EXTRN	?ChooseProphetConversionCity@CvReligionAI@@QBEPAVCvCity@@_N@Z:PROC ; CvReligionAI::ChooseProphetConversionCity
EXTRN	?GetReligionAI@CvPlayer@@QBEPAVCvReligionAI@@XZ:PROC ; CvPlayer::GetReligionAI
EXTRN	?GetReligion@CvGameReligions@@QBEPBVCvReligion@@W4ReligionTypes@@W4PlayerTypes@@@Z:PROC ; CvGameReligions::GetReligion
EXTRN	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ:PROC ; CvGame::GetGameReligions
EXTRN	?GetReligionCreatedByPlayer@CvPlayerReligions@@QBE?AW4ReligionTypes@@XZ:PROC ; CvPlayerReligions::GetReligionCreatedByPlayer
EXTRN	?GetReligions@CvPlayer@@QBEPAVCvPlayerReligions@@XZ:PROC ; CvPlayer::GetReligions
; Function compile flags: /Odtp
;	COMDAT ?GetDirectiveProphet@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T231066 = -24						; size = 4
$T231062 = -20						; size = 4
$T231058 = -16						; size = 4
_eReligion$ = -12					; size = 4
_pMyReligion$ = -8					; size = 4
_eDirective$ = -4					; size = 4
___formal$ = 8						; size = 4
?GetDirectiveProphet@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z PROC ; CvPlayerAI::GetDirectiveProphet, COMDAT
; _this$ = ecx

; 1208 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 1209 : 	GreatPeopleDirectiveTypes eDirective = NO_GREAT_PEOPLE_DIRECTIVE_TYPE;

	mov	DWORD PTR _eDirective$[ebp], -1

; 1210 : 
; 1211 : 	ReligionTypes eReligion = GetReligions()->GetReligionCreatedByPlayer();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetReligions@CvPlayer@@QBEPAVCvPlayerReligions@@XZ ; CvPlayer::GetReligions
	mov	ecx, eax
	call	?GetReligionCreatedByPlayer@CvPlayerReligions@@QBE?AW4ReligionTypes@@XZ ; CvPlayerReligions::GetReligionCreatedByPlayer
	mov	DWORD PTR _eReligion$[ebp], eax

; 1212 : 	const CvReligion* pMyReligion = GC.getGame().GetGameReligions()->GetReligion(eReligion, GetID());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T231058[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T231062[ebp], edx
	mov	eax, DWORD PTR $T231058[ebp]
	push	eax
	mov	ecx, DWORD PTR _eReligion$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T231062[ebp]
	call	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ ; CvGame::GetGameReligions
	mov	ecx, eax
	call	?GetReligion@CvGameReligions@@QBEPBVCvReligion@@W4ReligionTypes@@W4PlayerTypes@@@Z ; CvGameReligions::GetReligion
	mov	DWORD PTR _pMyReligion$[ebp], eax

; 1213 : 
; 1214 : 	// CASE 1: I have an enhanced religion
; 1215 : 	if (pMyReligion && pMyReligion->m_bEnhanced)

	cmp	DWORD PTR _pMyReligion$[ebp], 0
	je	SHORT $LN10@GetDirecti@8
	mov	edx, DWORD PTR _pMyReligion$[ebp]
	movzx	eax, BYTE PTR [edx+21]
	test	eax, eax
	je	SHORT $LN10@GetDirecti@8

; 1216 : 	{
; 1217 : 		// Spread religion if there is any city that needs it
; 1218 : 		if (GetReligionAI()->ChooseProphetConversionCity(false/*bOnlyBetterThanEnhancingReligion*/))

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetReligionAI@CvPlayer@@QBEPAVCvReligionAI@@XZ ; CvPlayer::GetReligionAI
	mov	ecx, eax
	call	?ChooseProphetConversionCity@CvReligionAI@@QBEPAVCvCity@@_N@Z ; CvReligionAI::ChooseProphetConversionCity
	test	eax, eax
	je	SHORT $LN9@GetDirecti@8

; 1219 : 		{
; 1220 : 			eDirective = GREAT_PEOPLE_DIRECTIVE_SPREAD_RELIGION;

	mov	DWORD PTR _eDirective$[ebp], 3

; 1221 : 		}
; 1222 : 		else

	jmp	SHORT $LN8@GetDirecti@8
$LN9@GetDirecti@8:

; 1223 : 		{
; 1224 : 			eDirective = GREAT_PEOPLE_DIRECTIVE_CONSTRUCT_IMPROVEMENT;

	mov	DWORD PTR _eDirective$[ebp], 2
$LN8@GetDirecti@8:

; 1225 : 		}

	jmp	SHORT $LN7@GetDirecti@8
$LN10@GetDirecti@8:

; 1226 : 	}
; 1227 : 
; 1228 : 
; 1229 : 	// CASE 2: I have a religion that hasn't yet been enhanced
; 1230 : 	else if (pMyReligion)

	cmp	DWORD PTR _pMyReligion$[ebp], 0
	je	SHORT $LN6@GetDirecti@8

; 1231 : 	{
; 1232 : 		// Spread religion if there is a city that needs it CRITICALLY
; 1233 : 		if (GetReligionAI()->ChooseProphetConversionCity(true/*bOnlyBetterThanEnhancingReligion*/))

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetReligionAI@CvPlayer@@QBEPAVCvReligionAI@@XZ ; CvPlayer::GetReligionAI
	mov	ecx, eax
	call	?ChooseProphetConversionCity@CvReligionAI@@QBEPAVCvCity@@_N@Z ; CvReligionAI::ChooseProphetConversionCity
	test	eax, eax
	je	SHORT $LN5@GetDirecti@8

; 1234 : 		{
; 1235 : 			eDirective = GREAT_PEOPLE_DIRECTIVE_SPREAD_RELIGION;

	mov	DWORD PTR _eDirective$[ebp], 3

; 1236 : 		}
; 1237 : 		else

	jmp	SHORT $LN4@GetDirecti@8
$LN5@GetDirecti@8:

; 1238 : 		{
; 1239 : 			eDirective = GREAT_PEOPLE_DIRECTIVE_USE_POWER;

	mov	DWORD PTR _eDirective$[ebp], 1
$LN4@GetDirecti@8:

; 1240 : 		}
; 1241 : 	}
; 1242 : 
; 1243 : 	// CASE 3: No religion for me yet
; 1244 : 	else

	jmp	SHORT $LN7@GetDirecti@8
$LN6@GetDirecti@8:

; 1245 : 	{
; 1246 : 		// Locked out?
; 1247 : 		if (GC.getGame().GetGameReligions()->GetNumReligionsStillToFound() <= 0)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T231066[ebp], ecx
	mov	ecx, DWORD PTR $T231066[ebp]
	call	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ ; CvGame::GetGameReligions
	mov	ecx, eax
	call	?GetNumReligionsStillToFound@CvGameReligions@@QBEHXZ ; CvGameReligions::GetNumReligionsStillToFound
	test	eax, eax
	jg	SHORT $LN2@GetDirecti@8

; 1248 : 		{
; 1249 : 			eDirective = GREAT_PEOPLE_DIRECTIVE_CONSTRUCT_IMPROVEMENT;

	mov	DWORD PTR _eDirective$[ebp], 2

; 1250 : 		}
; 1251 : 
; 1252 : 		// Not locked out
; 1253 : 		else

	jmp	SHORT $LN7@GetDirecti@8
$LN2@GetDirecti@8:

; 1254 : 		{
; 1255 : 			eDirective = GREAT_PEOPLE_DIRECTIVE_USE_POWER;

	mov	DWORD PTR _eDirective$[ebp], 1
$LN7@GetDirecti@8:

; 1256 : 		}
; 1257 : 	}
; 1258 : 
; 1259 : 	return eDirective;

	mov	eax, DWORD PTR _eDirective$[ebp]

; 1260 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetDirectiveProphet@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ENDP ; CvPlayerAI::GetDirectiveProphet
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetDirectiveAdmiral@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_eDirective$ = -4					; size = 4
___formal$ = 8						; size = 4
?GetDirectiveAdmiral@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z PROC ; CvPlayerAI::GetDirectiveAdmiral, COMDAT
; _this$ = ecx

; 1263 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1264 : 	GreatPeopleDirectiveTypes eDirective = NO_GREAT_PEOPLE_DIRECTIVE_TYPE;

	mov	DWORD PTR _eDirective$[ebp], -1

; 1265 : 
; 1266 : 	return eDirective;

	mov	eax, DWORD PTR _eDirective$[ebp]

; 1267 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetDirectiveAdmiral@CvPlayerAI@@QAE?AW4GreatPeopleDirectiveTypes@@PAVCvUnit@@@Z ENDP ; CvPlayerAI::GetDirectiveAdmiral
_TEXT	ENDS
PUBLIC	?GreatMerchantWantsCash@CvPlayerAI@@QAE_NXZ	; CvPlayerAI::GreatMerchantWantsCash
; Function compile flags: /Odtp
;	COMDAT ?GreatMerchantWantsCash@CvPlayerAI@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T231074 = -8						; size = 4
_bIsVenice$ = -1					; size = 1
?GreatMerchantWantsCash@CvPlayerAI@@QAE_NXZ PROC	; CvPlayerAI::GreatMerchantWantsCash, COMDAT
; _this$ = ecx

; 1270 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1271 : 	// slewis - everybody wants cash . . .
; 1272 : 	// slewis - . . . except Venice. Venice wants to buy city states, unless it already has enough cities, then it doesn't want city states.
; 1273 : 	bool bIsVenice = GetPlayerTraits()->IsNoAnnexing();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T231074[ebp], eax
	mov	eax, DWORD PTR $T231074[ebp]
	mov	cl, BYTE PTR [eax+351]
	mov	BYTE PTR _bIsVenice$[ebp], cl

; 1274 : 	if (bIsVenice)

	movzx	edx, BYTE PTR _bIsVenice$[ebp]
	test	edx, edx
	je	SHORT $LN3@GreatMerch

; 1275 : 	{
; 1276 : 		if (getNumCities() >= 4)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	cmp	eax, 4
	jl	SHORT $LN2@GreatMerch

; 1277 : 		{
; 1278 : 			return true;

	mov	al, 1
	jmp	SHORT $LN4@GreatMerch

; 1279 : 		}
; 1280 : 		else

	jmp	SHORT $LN3@GreatMerch
$LN2@GreatMerch:

; 1281 : 		{
; 1282 : 			return false;

	xor	al, al
	jmp	SHORT $LN4@GreatMerch
$LN3@GreatMerch:

; 1283 : 		}
; 1284 : 	}
; 1285 : 
; 1286 : 	return true;

	mov	al, 1
$LN4@GreatMerch:

; 1287 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GreatMerchantWantsCash@CvPlayerAI@@QAE_NXZ ENDP	; CvPlayerAI::GreatMerchantWantsCash
_TEXT	ENDS
PUBLIC	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
PUBLIC	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
EXTRN	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z:PROC ; TurnsToReachTarget
EXTRN	?GetWarGoal@CvDiplomacyAI@@QBE?AW4WarGoalTypes@@W4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetWarGoal
EXTRN	?GetMinorCivApproach@CvDiplomacyAI@@QBE?AW4MinorCivApproachTypes@@W4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetMinorCivApproach
EXTRN	?getStartingPlot@CvPlayer@@QBEPAVCvPlot@@XZ:PROC ; CvPlayer::getStartingPlot
EXTRN	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ:PROC ; CvUnit::getDestructionNotification
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?FindBestMerchantTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindBestMerchantTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z$0
__ehfuncinfo$?FindBestMerchantTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?FindBestMerchantTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.cpp
xdata$x	ENDS
;	COMDAT ?FindBestMerchantTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z
_TEXT	SEGMENT
tv237 = -204						; size = 4
tv236 = -200						; size = 4
_this$ = -196						; size = 4
$T231343 = -192						; size = 4
_uiOffset$231332 = -188					; size = 4
$T231323 = -184						; size = 4
$T231158 = -108						; size = 4
$T231154 = -104						; size = 4
$T231150 = -100						; size = 4
$T231141 = -96						; size = 4
$T231132 = -92						; size = 4
_uiOffset$231122 = -88					; size = 4
$T231113 = -84						; size = 4
$T231098 = -80						; size = 4
$T231078 = -76						; size = 4
$T231077 = -72						; size = 4
_bRightOwner$226265 = -66				; size = 1
_bIsRevealed$226267 = -65				; size = 1
_pAdjacentPlot$226262 = -64				; size = 4
_jJ$226258 = -60					; size = 4
_bMinorCivApproachIsCorrect$226254 = -53		; size = 1
_pCSPlot$226251 = -52					; size = 4
_bNotPlanningAWar$226256 = -46				; size = 1
_bNotAtWar$226255 = -45					; size = 1
_kPlayer$226248 = -44					; size = 4
_iI$226244 = -40					; size = 4
_pBestTargetPlot$ = -36					; size = 4
_iBestTurnsToReach$ = -32				; size = 4
_pMerchant$ = -28					; size = 8
_iPathTurns$ = -20					; size = 4
_kTeam$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pGreatMerchant$ = 8					; size = 4
_bOnlySafePaths$ = 12					; size = 1
?FindBestMerchantTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z PROC ; CvPlayerAI::FindBestMerchantTargetPlot, COMDAT
; _this$ = ecx

; 1290 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?FindBestMerchantTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1291 : 	CvAssertMsg(pGreatMerchant, "pGreatMerchant is null");
; 1292 : 	if(!pGreatMerchant)

	cmp	DWORD PTR _pGreatMerchant$[ebp], 0
	jne	SHORT $LN14@FindBestMe

; 1293 : 	{
; 1294 : 		return NULL;

	xor	eax, eax
	jmp	$LN15@FindBestMe
$LN14@FindBestMe:

; 1295 : 	}
; 1296 : 
; 1297 : 	int iBestTurnsToReach = MAX_INT;

	mov	DWORD PTR _iBestTurnsToReach$[ebp], 2147483647 ; 7fffffffH

; 1298 : 	CvPlot* pBestTargetPlot = NULL;

	mov	DWORD PTR _pBestTargetPlot$[ebp], 0

; 1299 : 	int iPathTurns;
; 1300 : 	UnitHandle pMerchant = UnitHandle(pGreatMerchant);

	mov	eax, DWORD PTR _pGreatMerchant$[ebp]
	mov	DWORD PTR _pMerchant$[ebp], eax
	mov	BYTE PTR _pMerchant$[ebp+4], 0
	cmp	DWORD PTR _pMerchant$[ebp], 0
	je	SHORT $LN20@FindBestMe
	mov	ecx, DWORD PTR _pMerchant$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN20@FindBestMe:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1301 : 	CvTeam& kTeam = GET_TEAM(getTeam());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T231098[ebp], eax
	mov	eax, DWORD PTR $T231098[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR _kTeam$[ebp], eax

; 1302 : 
; 1303 : 	//bool bIsVenice = GetPlayerTraits()->IsNoAnnexing();
; 1304 : 	//bool bWantsCash = GreatMerchantWantsCash();
; 1305 : 
; 1306 : 	// Loop through each city state
; 1307 : 	for(int iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$226244[ebp], 0
	jmp	SHORT $LN13@FindBestMe
$LN12@FindBestMe:
	mov	ecx, DWORD PTR _iI$226244[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$226244[ebp], ecx
$LN13@FindBestMe:
	cmp	DWORD PTR _iI$226244[ebp], 64		; 00000040H
	jge	$LN11@FindBestMe

; 1308 : 	{
; 1309 : 		CvPlayer& kPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	edx, DWORD PTR _iI$226244[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$226248[ebp], edx

; 1310 : 		if (!kPlayer.isMinorCiv())

	mov	ecx, DWORD PTR _kPlayer$226248[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN10@FindBestMe

; 1311 : 		{
; 1312 : 			continue;

	jmp	SHORT $LN12@FindBestMe
$LN10@FindBestMe:

; 1313 : 		}
; 1314 : 
; 1315 : 		// if I'm Venice, I don't want to send a Merchant of Venice to a buy a city that I have trade routes 
; 1316 : 		// with because it's probably more valuable as a trade partner than as an owned entity
; 1317 : 		//if (!bWantsCash)
; 1318 : 		//{
; 1319 : 		//	if (bIsVenice)
; 1320 : 		//	{
; 1321 : 		//		if (GetTrade()->IsConnectedToPlayer(kPlayer.GetID()))
; 1322 : 		//		{
; 1323 : 		//			continue;
; 1324 : 		//		}
; 1325 : 		//	}
; 1326 : 		//}
; 1327 : 
; 1328 : 		CvPlot* pCSPlot = kPlayer.getStartingPlot();

	mov	ecx, DWORD PTR _kPlayer$226248[ebp]
	call	?getStartingPlot@CvPlayer@@QBEPAVCvPlot@@XZ ; CvPlayer::getStartingPlot
	mov	DWORD PTR _pCSPlot$226251[ebp], eax

; 1329 : 		if (!pCSPlot)

	cmp	DWORD PTR _pCSPlot$226251[ebp], 0
	jne	SHORT $LN34@FindBestMe

; 1330 : 		{
; 1331 : 			continue;

	jmp	SHORT $LN12@FindBestMe

; 1332 : 		}
; 1333 : 
; 1334 : 		if (!pCSPlot->isRevealed(getTeam()))

$LN34@FindBestMe:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T231113[ebp], eax
	mov	eax, DWORD PTR $T231113[ebp]
	shr	eax, 5
	mov	DWORD PTR _uiOffset$231122[ebp], eax
	mov	ecx, DWORD PTR _uiOffset$231122[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR $T231113[ebp]
	sub	edx, ecx
	mov	eax, 1
	mov	ecx, edx
	shl	eax, cl
	mov	ecx, DWORD PTR _uiOffset$231122[ebp]
	mov	edx, DWORD PTR _pCSPlot$226251[ebp]
	and	eax, DWORD PTR [edx+ecx*4+8]
	setne	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN42@FindBestMe

; 1335 : 		{
; 1336 : 			continue;

	jmp	$LN12@FindBestMe

; 1337 : 		}
; 1338 : 
; 1339 : 		// Is this a minor we are friendly with?
; 1340 : 		bool bMinorCivApproachIsCorrect = (GetDiplomacyAI()->GetMinorCivApproach(kPlayer.GetID()) != MINOR_CIV_APPROACH_CONQUEST);

$LN42@FindBestMe:
	mov	edx, DWORD PTR _kPlayer$226248[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T231132[ebp], eax
	mov	ecx, DWORD PTR $T231132[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMinorCivApproach@CvDiplomacyAI@@QBE?AW4MinorCivApproachTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetMinorCivApproach
	xor	edx, edx
	cmp	eax, 3
	setne	dl
	mov	BYTE PTR _bMinorCivApproachIsCorrect$226254[ebp], dl

; 1341 : 		bool bNotAtWar = !kTeam.isAtWar(kPlayer.getTeam());

	mov	eax, DWORD PTR _kPlayer$226248[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T231141[ebp], eax
	mov	edx, DWORD PTR $T231141[ebp]
	push	edx
	mov	ecx, DWORD PTR _kTeam$[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1
	mov	BYTE PTR _bNotAtWar$226255[ebp], al

; 1342 : 		bool bNotPlanningAWar = GetDiplomacyAI()->GetWarGoal(kPlayer.GetID()) == NO_WAR_GOAL_TYPE;

	mov	ecx, DWORD PTR _kPlayer$226248[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T231150[ebp], edx
	mov	eax, DWORD PTR $T231150[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetWarGoal@CvDiplomacyAI@@QBE?AW4WarGoalTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetWarGoal
	xor	ecx, ecx
	cmp	eax, -1
	sete	cl
	mov	BYTE PTR _bNotPlanningAWar$226256[ebp], cl

; 1343 : 
; 1344 : 		if(bMinorCivApproachIsCorrect && bNotAtWar && bNotPlanningAWar)

	movzx	edx, BYTE PTR _bMinorCivApproachIsCorrect$226254[ebp]
	test	edx, edx
	je	$LN7@FindBestMe
	movzx	eax, BYTE PTR _bNotAtWar$226255[ebp]
	test	eax, eax
	je	$LN7@FindBestMe
	movzx	ecx, BYTE PTR _bNotPlanningAWar$226256[ebp]
	test	ecx, ecx
	je	$LN7@FindBestMe

; 1345 : 		{
; 1346 : 			// Search all the plots adjacent to this city (since can't enter the minor city plot itself)
; 1347 : 			for(int jJ = 0; jJ < NUM_DIRECTION_TYPES; jJ++)

	mov	DWORD PTR _jJ$226258[ebp], 0
	jmp	SHORT $LN6@FindBestMe
$LN5@FindBestMe:
	mov	edx, DWORD PTR _jJ$226258[ebp]
	add	edx, 1
	mov	DWORD PTR _jJ$226258[ebp], edx
$LN6@FindBestMe:
	cmp	DWORD PTR _jJ$226258[ebp], 6
	jge	$LN7@FindBestMe

; 1348 : 			{
; 1349 : 				CvPlot* pAdjacentPlot = plotDirection(pCSPlot->getX(), pCSPlot->getY(), ((DirectionTypes)jJ));

	mov	eax, DWORD PTR _pCSPlot$226251[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T231154[ebp], ecx
	mov	edx, DWORD PTR _pCSPlot$226251[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T231158[ebp], eax
	mov	ecx, DWORD PTR _jJ$226258[ebp]
	push	ecx
	mov	edx, DWORD PTR $T231154[ebp]
	push	edx
	mov	eax, DWORD PTR $T231158[ebp]
	push	eax
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$226262[ebp], eax

; 1350 : 				if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$226262[ebp], 0
	je	$LN3@FindBestMe

; 1351 : 				{
; 1352 : 					// Make sure this is still owned by the city state and is revealed to us and isn't a water tile
; 1353 : 					//if(pAdjacentPlot->getOwner() == (PlayerTypes)iI && pAdjacentPlot->isRevealed(getTeam()) && !pAdjacentPlot->isWater())
; 1354 : 					bool bRightOwner = (pAdjacentPlot->getOwner() == (PlayerTypes)iI);

	mov	ecx, DWORD PTR _pAdjacentPlot$226262[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	xor	eax, eax
	cmp	edx, DWORD PTR _iI$226244[ebp]
	sete	al
	mov	BYTE PTR _bRightOwner$226265[ebp], al

; 1355 : 					bool bIsRevealed = pAdjacentPlot->isRevealed(getTeam());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T231323[ebp], eax
	mov	eax, DWORD PTR $T231323[ebp]
	shr	eax, 5
	mov	DWORD PTR _uiOffset$231332[ebp], eax
	mov	ecx, DWORD PTR _uiOffset$231332[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR $T231323[ebp]
	sub	edx, ecx
	mov	eax, 1
	mov	ecx, edx
	shl	eax, cl
	mov	ecx, DWORD PTR _uiOffset$231332[ebp]
	mov	edx, DWORD PTR _pAdjacentPlot$226262[ebp]
	and	eax, DWORD PTR [edx+ecx*4+8]
	setne	al
	mov	BYTE PTR _bIsRevealed$226267[ebp], al

; 1356 : 					if(bRightOwner && bIsRevealed)

	movzx	ecx, BYTE PTR _bRightOwner$226265[ebp]
	test	ecx, ecx
	je	$LN3@FindBestMe
	movzx	edx, BYTE PTR _bIsRevealed$226267[ebp]
	test	edx, edx
	je	$LN3@FindBestMe

; 1357 : 					{
; 1358 : 						iPathTurns = TurnsToReachTarget(pMerchant, pAdjacentPlot, true /*bReusePaths*/, !bOnlySafePaths/*bIgnoreUnits*/);

	push	0
	movzx	eax, BYTE PTR _bOnlySafePaths$[ebp]
	test	eax, eax
	sete	cl
	movzx	edx, cl
	push	edx
	push	1
	mov	eax, DWORD PTR _pAdjacentPlot$226262[ebp]
	push	eax
	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR $T231077[ebp], esp
	mov	DWORD PTR $T231343[ebp], ecx
	mov	edx, DWORD PTR $T231343[ebp]
	mov	eax, DWORD PTR _pMerchant$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T231343[ebp]
	mov	dl, BYTE PTR _pMerchant$[ebp+4]
	mov	BYTE PTR [ecx+4], dl
	mov	eax, DWORD PTR $T231343[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN135@FindBestMe
	mov	ecx, DWORD PTR $T231343[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN135@FindBestMe:
	mov	edx, DWORD PTR $T231343[ebp]
	mov	DWORD PTR tv236[ebp], edx
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H
	mov	DWORD PTR tv237[ebp], eax
	mov	eax, DWORD PTR tv237[ebp]
	mov	DWORD PTR _iPathTurns$[ebp], eax

; 1359 : 						if(iPathTurns < iBestTurnsToReach)

	mov	ecx, DWORD PTR _iPathTurns$[ebp]
	cmp	ecx, DWORD PTR _iBestTurnsToReach$[ebp]
	jge	SHORT $LN3@FindBestMe

; 1360 : 						{
; 1361 : 							iBestTurnsToReach = iPathTurns;

	mov	edx, DWORD PTR _iPathTurns$[ebp]
	mov	DWORD PTR _iBestTurnsToReach$[ebp], edx

; 1362 : 							pBestTargetPlot = pAdjacentPlot;

	mov	eax, DWORD PTR _pAdjacentPlot$226262[ebp]
	mov	DWORD PTR _pBestTargetPlot$[ebp], eax
$LN3@FindBestMe:

; 1363 : 						}
; 1364 : 					}
; 1365 : 				}
; 1366 : 			}

	jmp	$LN5@FindBestMe
$LN7@FindBestMe:

; 1367 : 		}
; 1368 : 	}

	jmp	$LN12@FindBestMe
$LN11@FindBestMe:

; 1369 : 
; 1370 : 	return pBestTargetPlot;

	mov	ecx, DWORD PTR _pBestTargetPlot$[ebp]
	mov	DWORD PTR $T231078[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pMerchant$[ebp], 0
	je	SHORT $LN140@FindBestMe
	mov	ecx, DWORD PTR _pMerchant$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN140@FindBestMe:
	mov	eax, DWORD PTR $T231078[ebp]
$LN15@FindBestMe:

; 1371 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindBestMerchantTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z$0:
	lea	ecx, DWORD PTR _pMerchant$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?FindBestMerchantTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-196]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?FindBestMerchantTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindBestMerchantTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z ENDP ; CvPlayerAI::FindBestMerchantTargetPlot
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z
_TEXT	SEGMENT
tv198 = -100						; size = 4
tv213 = -96						; size = 4
tv168 = -92						; size = 4
tv151 = -88						; size = 4
tv155 = -84						; size = 4
$T231565 = -80						; size = 4
$T231520 = -76						; size = 4
$T231507 = -72						; size = 4
$T231503 = -68						; size = 4
$T231489 = -64						; size = 4
$T231485 = -57						; size = 1
$T231474 = -56						; size = 4
$T231470 = -49						; size = 1
_iMapY$231564 = -48					; size = 4
_iMapX$231563 = -44					; size = 4
$T231463 = -40						; size = 4
$T231439 = -36						; size = 4
$T231402 = -32						; size = 4
$T231390 = -28						; size = 4
$T231386 = -21						; size = 1
$T231375 = -20						; size = 4
$T231371 = -13						; size = 1
_iMapY$231411 = -12					; size = 4
_iMapX$231410 = -8					; size = 4
$T231364 = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_eDirection$ = 16					; size = 4
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z PROC ; plotDirection, COMDAT

; 193  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H

; 194  : 	if(eDirection == NO_DIRECTION)

	cmp	DWORD PTR _eDirection$[ebp], -1
	jne	$LN2@plotDirect

; 195  : 	{
; 196  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T231364[ebp], eax
	cmp	DWORD PTR _iX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN7@plotDirect
	cmp	DWORD PTR _iY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN8@plotDirect
$LN7@plotDirect:
	mov	DWORD PTR $T231439[ebp], 0
	jmp	$LN9@plotDirect
$LN8@plotDirect:
	mov	ecx, DWORD PTR $T231364[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T231371[ebp], dl
	mov	eax, DWORD PTR $T231364[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T231375[ebp], ecx
	movzx	edx, BYTE PTR $T231371[ebp]
	test	edx, edx
	je	SHORT $LN20@plotDirect
	cmp	DWORD PTR _iX$[ebp], 0
	jge	SHORT $LN19@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T231375[ebp]
	add	edx, DWORD PTR $T231375[ebp]
	mov	DWORD PTR _iMapX$231410[ebp], edx
	jmp	SHORT $LN21@plotDirect
	jmp	SHORT $LN20@plotDirect
$LN19@plotDirect:
	mov	eax, DWORD PTR _iX$[ebp]
	cmp	eax, DWORD PTR $T231375[ebp]
	jl	SHORT $LN20@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T231375[ebp]
	mov	DWORD PTR _iMapX$231410[ebp], edx
	jmp	SHORT $LN21@plotDirect
$LN20@plotDirect:
	mov	ecx, DWORD PTR _iX$[ebp]
	mov	DWORD PTR _iMapX$231410[ebp], ecx
$LN21@plotDirect:
	mov	edx, DWORD PTR $T231364[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T231386[ebp], al
	mov	ecx, DWORD PTR $T231364[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T231390[ebp], edx
	movzx	eax, BYTE PTR $T231386[ebp]
	test	eax, eax
	je	SHORT $LN30@plotDirect
	cmp	DWORD PTR _iY$[ebp], 0
	jge	SHORT $LN29@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T231390[ebp]
	add	edx, DWORD PTR $T231390[ebp]
	mov	DWORD PTR _iMapY$231411[ebp], edx
	jmp	SHORT $LN31@plotDirect
	jmp	SHORT $LN30@plotDirect
$LN29@plotDirect:
	mov	ecx, DWORD PTR _iY$[ebp]
	cmp	ecx, DWORD PTR $T231390[ebp]
	jl	SHORT $LN30@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T231390[ebp]
	mov	DWORD PTR _iMapY$231411[ebp], edx
	jmp	SHORT $LN31@plotDirect
$LN30@plotDirect:
	mov	edx, DWORD PTR _iY$[ebp]
	mov	DWORD PTR _iMapY$231411[ebp], edx
$LN31@plotDirect:
	mov	eax, DWORD PTR _iMapY$231411[ebp]
	push	eax
	mov	ecx, DWORD PTR _iMapX$231410[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T231364[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN11@plotDirect
	mov	edx, DWORD PTR $T231364[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T231402[ebp], eax
	mov	ecx, DWORD PTR _iMapY$231411[ebp]
	imul	ecx, DWORD PTR $T231402[ebp]
	add	ecx, DWORD PTR _iMapX$231410[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T231364[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv155[ebp], ecx
	jmp	SHORT $LN12@plotDirect
$LN11@plotDirect:
	mov	DWORD PTR tv155[ebp], 0
$LN12@plotDirect:
	mov	eax, DWORD PTR tv155[ebp]
	mov	DWORD PTR $T231439[ebp], eax
$LN9@plotDirect:
	mov	eax, DWORD PTR $T231439[ebp]
	jmp	$LN3@plotDirect

; 197  : 	}
; 198  : 	else

	jmp	$LN3@plotDirect
$LN2@plotDirect:

; 199  : 	{
; 200  : 		// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 201  : 		iX = xToHexspaceX(iX , iY);

	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN39@plotDirect
	mov	ecx, DWORD PTR _iY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv151[ebp], ecx
	jmp	SHORT $LN37@plotDirect
$LN39@plotDirect:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv151[ebp], eax
$LN37@plotDirect:
	mov	edx, DWORD PTR _iX$[ebp]
	sub	edx, DWORD PTR tv151[ebp]
	mov	DWORD PTR _iX$[ebp], edx

; 202  : 		iX += GC.getPlotDirectionX()[eDirection];

	mov	eax, DWORD PTR _eDirection$[ebp]
	mov	ecx, DWORD PTR _iX$[ebp]
	add	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A[eax*4+112]
	mov	DWORD PTR _iX$[ebp], ecx

; 203  : 		iY += GC.getPlotDirectionY()[eDirection];

	mov	edx, DWORD PTR _eDirection$[ebp]
	mov	eax, DWORD PTR _iY$[ebp]
	add	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A[edx*4+136]
	mov	DWORD PTR _iY$[ebp], eax

; 204  : 
; 205  : 		// convert from hex-space coordinates to the storage array
; 206  : 		iX = hexspaceXToX(iX, iY);

	js	SHORT $LN47@plotDirect
	mov	ecx, DWORD PTR _iY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv168[ebp], ecx
	jmp	SHORT $LN45@plotDirect
$LN47@plotDirect:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv168[ebp], eax
$LN45@plotDirect:
	mov	edx, DWORD PTR _iX$[ebp]
	add	edx, DWORD PTR tv168[ebp]
	mov	DWORD PTR _iX$[ebp], edx

; 207  : 
; 208  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T231463[ebp], eax
	cmp	DWORD PTR _iX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN51@plotDirect
	cmp	DWORD PTR _iY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN52@plotDirect
$LN51@plotDirect:
	mov	DWORD PTR $T231565[ebp], 0
	jmp	$LN53@plotDirect
$LN52@plotDirect:
	mov	ecx, DWORD PTR $T231463[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T231470[ebp], dl
	mov	eax, DWORD PTR $T231463[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T231474[ebp], ecx
	movzx	edx, BYTE PTR $T231470[ebp]
	test	edx, edx
	je	SHORT $LN64@plotDirect
	cmp	DWORD PTR _iX$[ebp], 0
	jge	SHORT $LN63@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T231474[ebp]
	add	edx, DWORD PTR $T231474[ebp]
	mov	DWORD PTR _iMapX$231563[ebp], edx
	jmp	SHORT $LN65@plotDirect
	jmp	SHORT $LN64@plotDirect
$LN63@plotDirect:
	mov	eax, DWORD PTR _iX$[ebp]
	cmp	eax, DWORD PTR $T231474[ebp]
	jl	SHORT $LN64@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T231474[ebp]
	mov	DWORD PTR _iMapX$231563[ebp], edx
	jmp	SHORT $LN65@plotDirect
$LN64@plotDirect:
	mov	ecx, DWORD PTR _iX$[ebp]
	mov	DWORD PTR _iMapX$231563[ebp], ecx
$LN65@plotDirect:
	mov	edx, DWORD PTR $T231463[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T231485[ebp], al
	mov	ecx, DWORD PTR $T231463[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T231489[ebp], edx
	movzx	eax, BYTE PTR $T231485[ebp]
	test	eax, eax
	je	SHORT $LN74@plotDirect
	cmp	DWORD PTR _iY$[ebp], 0
	jge	SHORT $LN73@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T231489[ebp]
	add	edx, DWORD PTR $T231489[ebp]
	mov	DWORD PTR _iMapY$231564[ebp], edx
	jmp	SHORT $LN75@plotDirect
	jmp	SHORT $LN74@plotDirect
$LN73@plotDirect:
	mov	ecx, DWORD PTR _iY$[ebp]
	cmp	ecx, DWORD PTR $T231489[ebp]
	jl	SHORT $LN74@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T231489[ebp]
	mov	DWORD PTR _iMapY$231564[ebp], edx
	jmp	SHORT $LN75@plotDirect
$LN74@plotDirect:
	mov	edx, DWORD PTR _iY$[ebp]
	mov	DWORD PTR _iMapY$231564[ebp], edx
$LN75@plotDirect:
	cmp	DWORD PTR _iMapX$231563[ebp], 0
	jl	SHORT $LN79@plotDirect
	mov	eax, DWORD PTR $T231463[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T231503[ebp], ecx
	mov	edx, DWORD PTR _iMapX$231563[ebp]
	cmp	edx, DWORD PTR $T231503[ebp]
	jge	SHORT $LN79@plotDirect
	cmp	DWORD PTR _iMapY$231564[ebp], 0
	jl	SHORT $LN79@plotDirect
	mov	eax, DWORD PTR $T231463[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T231507[ebp], ecx
	mov	edx, DWORD PTR _iMapY$231564[ebp]
	cmp	edx, DWORD PTR $T231507[ebp]
	jge	SHORT $LN79@plotDirect
	mov	DWORD PTR tv213[ebp], 1
	jmp	SHORT $LN77@plotDirect
$LN79@plotDirect:
	mov	DWORD PTR tv213[ebp], 0
$LN77@plotDirect:
	cmp	DWORD PTR tv213[ebp], 0
	je	SHORT $LN55@plotDirect
	mov	eax, DWORD PTR $T231463[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T231520[ebp], ecx
	mov	edx, DWORD PTR _iMapY$231564[ebp]
	imul	edx, DWORD PTR $T231520[ebp]
	add	edx, DWORD PTR _iMapX$231563[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T231463[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv198[ebp], edx
	jmp	SHORT $LN56@plotDirect
$LN55@plotDirect:
	mov	DWORD PTR tv198[ebp], 0
$LN56@plotDirect:
	mov	ecx, DWORD PTR tv198[ebp]
	mov	DWORD PTR $T231565[ebp], ecx
$LN53@plotDirect:
	mov	eax, DWORD PTR $T231565[ebp]
$LN3@plotDirect:

; 209  : 	}
; 210  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ENDP ; plotDirection
_TEXT	ENDS
EXTRN	?plotCity@@YAPAVCvPlot@@HHH@Z:PROC		; plotCity
EXTRN	?GetCivLowestInfluence@CvPlayerCulture@@QBE?AW4PlayerTypes@@_N@Z:PROC ; CvPlayerCulture::GetCivLowestInfluence
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?FindBestMusicianTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindBestMusicianTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z$0
__ehfuncinfo$?FindBestMusicianTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?FindBestMusicianTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.cpp
xdata$x	ENDS
;	COMDAT ?FindBestMusicianTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z
_TEXT	SEGMENT
tv246 = -224						; size = 4
tv245 = -220						; size = 4
tv239 = -216						; size = 4
tv238 = -212						; size = 4
_this$ = -208						; size = 4
$T231835 = -204						; size = 4
_uiOffset$231824 = -200					; size = 4
$T231815 = -196						; size = 4
$T231803 = -192						; size = 4
$T231794 = -188						; size = 4
$T231785 = -184						; size = 4
_uiOffset$231774 = -180					; size = 4
$T231765 = -176						; size = 4
$T231613 = -100						; size = 4
$T231604 = -96						; size = 4
$T231571 = -92						; size = 4
$T231570 = -88						; size = 4
$T231569 = -84						; size = 4
$T231568 = -80						; size = 4
_bRightOwner$226312 = -74				; size = 1
_bIsRevealed$226313 = -73				; size = 1
_iJ$226307 = -72					; size = 4
_pLoopPlot$226306 = -68					; size = 4
_bRightOwner$226300 = -62				; size = 1
_bIsRevealed$226301 = -61				; size = 1
_pAdjacentPlot$226297 = -60				; size = 4
_jJ$226293 = -56					; size = 4
_pBestTargetPlot$ = -52					; size = 4
_pBestTargetCity$ = -48					; size = 4
_iBestTurnsToReach$ = -44				; size = 4
_iPathTurns$ = -40					; size = 4
_eTargetPlayer$ = -36					; size = 4
_pMusician$ = -32					; size = 8
_kTargetPlayer$ = -24					; size = 4
_pLoopCity$ = -20					; size = 4
_iLoop$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pGreatMusician$ = 8					; size = 4
_bOnlySafePaths$ = 12					; size = 1
?FindBestMusicianTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z PROC ; CvPlayerAI::FindBestMusicianTargetPlot, COMDAT
; _this$ = ecx

; 1374 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?FindBestMusicianTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 212				; 000000d4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1375 : 	CvAssertMsg(pGreatMusician, "pGreatMusician is null");
; 1376 : 	if(!pGreatMusician)

	cmp	DWORD PTR _pGreatMusician$[ebp], 0
	jne	SHORT $LN18@FindBestMu

; 1377 : 	{
; 1378 : 		return NULL;

	xor	eax, eax
	jmp	$LN19@FindBestMu
$LN18@FindBestMu:

; 1379 : 	}
; 1380 : 
; 1381 : 	int iBestTurnsToReach = MAX_INT;

	mov	DWORD PTR _iBestTurnsToReach$[ebp], 2147483647 ; 7fffffffH

; 1382 : 	CvPlot* pBestTargetPlot = NULL;

	mov	DWORD PTR _pBestTargetPlot$[ebp], 0

; 1383 : 	CvCity* pBestTargetCity = NULL;

	mov	DWORD PTR _pBestTargetCity$[ebp], 0

; 1384 : 	int iPathTurns;
; 1385 : 	UnitHandle pMusician = UnitHandle(pGreatMusician);

	mov	eax, DWORD PTR _pGreatMusician$[ebp]
	mov	DWORD PTR _pMusician$[ebp], eax
	mov	BYTE PTR _pMusician$[ebp+4], 0
	cmp	DWORD PTR _pMusician$[ebp], 0
	je	SHORT $LN25@FindBestMu
	mov	ecx, DWORD PTR _pMusician$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN25@FindBestMu:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1386 : 
; 1387 : 	// Find target civ
; 1388 : 	PlayerTypes eTargetPlayer = GetCulture()->GetCivLowestInfluence(true /*bCheckOpenBorders*/);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetCivLowestInfluence@CvPlayerCulture@@QBE?AW4PlayerTypes@@_N@Z ; CvPlayerCulture::GetCivLowestInfluence
	mov	DWORD PTR _eTargetPlayer$[ebp], eax

; 1389 : 	if (eTargetPlayer == NO_PLAYER)

	cmp	DWORD PTR _eTargetPlayer$[ebp], -1
	jne	SHORT $LN34@FindBestMu

; 1390 : 	{
; 1391 : 		return NULL;

	mov	DWORD PTR $T231568[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pMusician$[ebp], 0
	je	SHORT $LN30@FindBestMu
	mov	ecx, DWORD PTR _pMusician$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN30@FindBestMu:
	mov	eax, DWORD PTR $T231568[ebp]
	jmp	$LN19@FindBestMu

; 1392 : 	}
; 1393 : 
; 1394 : 	CvPlayer &kTargetPlayer = GET_PLAYER(eTargetPlayer);

$LN34@FindBestMu:
	mov	ecx, DWORD PTR _eTargetPlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kTargetPlayer$[ebp], ecx

; 1395 : 
; 1396 : 	// Loop through each of that player's cities
; 1397 : 	int iLoop;
; 1398 : 	CvCity *pLoopCity;
; 1399 : 	for(pLoopCity = kTargetPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kTargetPlayer.nextCity(&iLoop))

	push	0
	lea	edx, DWORD PTR _iLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR _kTargetPlayer$[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
	jmp	SHORT $LN16@FindBestMu
$LN15@FindBestMu:
	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kTargetPlayer$[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
$LN16@FindBestMu:
	cmp	DWORD PTR _pLoopCity$[ebp], 0
	je	$LN14@FindBestMu

; 1400 : 	{
; 1401 : 		// Search all the plots adjacent to this city
; 1402 : 		for(int jJ = 0; jJ < NUM_DIRECTION_TYPES; jJ++)

	mov	DWORD PTR _jJ$226293[ebp], 0
	jmp	SHORT $LN13@FindBestMu
$LN12@FindBestMu:
	mov	ecx, DWORD PTR _jJ$226293[ebp]
	add	ecx, 1
	mov	DWORD PTR _jJ$226293[ebp], ecx
$LN13@FindBestMu:
	cmp	DWORD PTR _jJ$226293[ebp], 6
	jge	$LN11@FindBestMu

; 1403 : 		{
; 1404 : 			CvPlot* pAdjacentPlot = plotDirection(pLoopCity->getX(), pLoopCity->getY(), ((DirectionTypes)jJ));

	mov	edx, DWORD PTR _pLoopCity$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR $T231604[ebp], eax
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR $T231613[ebp], edx
	mov	eax, DWORD PTR _jJ$226293[ebp]
	push	eax
	mov	ecx, DWORD PTR $T231604[ebp]
	push	ecx
	mov	edx, DWORD PTR $T231613[ebp]
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$226297[ebp], eax

; 1405 : 			if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$226297[ebp], 0
	je	$LN10@FindBestMu

; 1406 : 			{
; 1407 : 				// Make sure this is still owned by target and is revealed to us
; 1408 : 				bool bRightOwner = (pAdjacentPlot->getOwner() == eTargetPlayer);

	mov	eax, DWORD PTR _pAdjacentPlot$226297[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR _eTargetPlayer$[ebp]
	sete	dl
	mov	BYTE PTR _bRightOwner$226300[ebp], dl

; 1409 : 				bool bIsRevealed = pAdjacentPlot->isRevealed(getTeam());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T231765[ebp], eax
	mov	edx, DWORD PTR $T231765[ebp]
	shr	edx, 5
	mov	DWORD PTR _uiOffset$231774[ebp], edx
	mov	eax, DWORD PTR _uiOffset$231774[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR $T231765[ebp]
	sub	ecx, eax
	mov	edx, 1
	shl	edx, cl
	mov	eax, DWORD PTR _uiOffset$231774[ebp]
	mov	ecx, DWORD PTR _pAdjacentPlot$226297[ebp]
	and	edx, DWORD PTR [ecx+eax*4+8]
	setne	dl
	mov	BYTE PTR _bIsRevealed$226301[ebp], dl

; 1410 : 				if(bRightOwner && bIsRevealed)

	movzx	eax, BYTE PTR _bRightOwner$226300[ebp]
	test	eax, eax
	je	$LN10@FindBestMu
	movzx	ecx, BYTE PTR _bIsRevealed$226301[ebp]
	test	ecx, ecx
	je	$LN10@FindBestMu

; 1411 : 				{
; 1412 : 					iPathTurns = TurnsToReachTarget(pMusician, pAdjacentPlot, true /*bReusePaths*/, !bOnlySafePaths/*bIgnoreUnits*/);

	push	0
	movzx	edx, BYTE PTR _bOnlySafePaths$[ebp]
	test	edx, edx
	sete	al
	movzx	ecx, al
	push	ecx
	push	1
	mov	edx, DWORD PTR _pAdjacentPlot$226297[ebp]
	push	edx
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR $T231569[ebp], esp
	mov	DWORD PTR $T231785[ebp], eax
	mov	ecx, DWORD PTR $T231785[ebp]
	mov	edx, DWORD PTR _pMusician$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR $T231785[ebp]
	mov	cl, BYTE PTR _pMusician$[ebp+4]
	mov	BYTE PTR [eax+4], cl
	mov	edx, DWORD PTR $T231785[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN117@FindBestMu
	mov	eax, DWORD PTR $T231785[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN117@FindBestMu:
	mov	ecx, DWORD PTR $T231785[ebp]
	mov	DWORD PTR tv238[ebp], ecx
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H
	mov	DWORD PTR tv239[ebp], eax
	mov	edx, DWORD PTR tv239[ebp]
	mov	DWORD PTR _iPathTurns$[ebp], edx

; 1413 : 					if(iPathTurns < iBestTurnsToReach)

	mov	eax, DWORD PTR _iPathTurns$[ebp]
	cmp	eax, DWORD PTR _iBestTurnsToReach$[ebp]
	jge	SHORT $LN10@FindBestMu

; 1414 : 					{
; 1415 : 						iBestTurnsToReach = iPathTurns;

	mov	ecx, DWORD PTR _iPathTurns$[ebp]
	mov	DWORD PTR _iBestTurnsToReach$[ebp], ecx

; 1416 : 						pBestTargetCity = pLoopCity;

	mov	edx, DWORD PTR _pLoopCity$[ebp]
	mov	DWORD PTR _pBestTargetCity$[ebp], edx
$LN10@FindBestMu:

; 1417 : 					}
; 1418 : 				}
; 1419 : 			}
; 1420 : 		}

	jmp	$LN12@FindBestMu
$LN11@FindBestMu:

; 1421 : 	}

	jmp	$LN15@FindBestMu
$LN14@FindBestMu:

; 1422 : 
; 1423 : 	// Found a city now look at ALL the plots owned by that player near that city
; 1424 : 	if (pBestTargetCity)

	cmp	DWORD PTR _pBestTargetCity$[ebp], 0
	je	$LN7@FindBestMu

; 1425 : 	{
; 1426 : 		iBestTurnsToReach = MAX_INT;

	mov	DWORD PTR _iBestTurnsToReach$[ebp], 2147483647 ; 7fffffffH

; 1427 : 		CvPlot *pLoopPlot;
; 1428 : 		for(int iJ = 0; iJ < NUM_CITY_PLOTS; iJ++)

	mov	DWORD PTR _iJ$226307[ebp], 0
	jmp	SHORT $LN6@FindBestMu
$LN5@FindBestMu:
	mov	eax, DWORD PTR _iJ$226307[ebp]
	add	eax, 1
	mov	DWORD PTR _iJ$226307[ebp], eax
$LN6@FindBestMu:
	cmp	DWORD PTR _iJ$226307[ebp], 37		; 00000025H
	jge	$LN7@FindBestMu

; 1429 : 		{
; 1430 : 			pLoopPlot = plotCity(pBestTargetCity->getX(), pBestTargetCity->getY(), iJ);

	mov	ecx, DWORD PTR _pBestTargetCity$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR $T231794[ebp], edx
	mov	eax, DWORD PTR _pBestTargetCity$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR $T231803[ebp], ecx
	mov	edx, DWORD PTR _iJ$226307[ebp]
	push	edx
	mov	eax, DWORD PTR $T231794[ebp]
	push	eax
	mov	ecx, DWORD PTR $T231803[ebp]
	push	ecx
	call	?plotCity@@YAPAVCvPlot@@HHH@Z		; plotCity
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pLoopPlot$226306[ebp], eax

; 1431 : 			if(pLoopPlot != NULL)

	cmp	DWORD PTR _pLoopPlot$226306[ebp], 0
	je	$LN3@FindBestMu

; 1432 : 			{
; 1433 : 				// Make sure this is still owned by target and is revealed to us
; 1434 : 				bool bRightOwner = (pLoopPlot->getOwner() == eTargetPlayer);

	mov	edx, DWORD PTR _pLoopPlot$226306[ebp]
	movsx	eax, BYTE PTR [edx+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR _eTargetPlayer$[ebp]
	sete	cl
	mov	BYTE PTR _bRightOwner$226312[ebp], cl

; 1435 : 				bool bIsRevealed = pLoopPlot->isRevealed(getTeam());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T231815[ebp], eax
	mov	ecx, DWORD PTR $T231815[ebp]
	shr	ecx, 5
	mov	DWORD PTR _uiOffset$231824[ebp], ecx
	mov	edx, DWORD PTR _uiOffset$231824[ebp]
	shl	edx, 5
	mov	ecx, DWORD PTR $T231815[ebp]
	sub	ecx, edx
	mov	eax, 1
	shl	eax, cl
	mov	ecx, DWORD PTR _uiOffset$231824[ebp]
	mov	edx, DWORD PTR _pLoopPlot$226306[ebp]
	and	eax, DWORD PTR [edx+ecx*4+8]
	setne	al
	mov	BYTE PTR _bIsRevealed$226313[ebp], al

; 1436 : 				if(bRightOwner && bIsRevealed)

	movzx	ecx, BYTE PTR _bRightOwner$226312[ebp]
	test	ecx, ecx
	je	$LN3@FindBestMu
	movzx	edx, BYTE PTR _bIsRevealed$226313[ebp]
	test	edx, edx
	je	$LN3@FindBestMu

; 1437 : 				{
; 1438 : 					iPathTurns = TurnsToReachTarget(pMusician, pLoopPlot, true /*bReusePaths*/, !bOnlySafePaths/*bIgnoreUnits*/);

	push	0
	movzx	eax, BYTE PTR _bOnlySafePaths$[ebp]
	test	eax, eax
	sete	cl
	movzx	edx, cl
	push	edx
	push	1
	mov	eax, DWORD PTR _pLoopPlot$226306[ebp]
	push	eax
	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR $T231570[ebp], esp
	mov	DWORD PTR $T231835[ebp], ecx
	mov	edx, DWORD PTR $T231835[ebp]
	mov	eax, DWORD PTR _pMusician$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T231835[ebp]
	mov	dl, BYTE PTR _pMusician$[ebp+4]
	mov	BYTE PTR [ecx+4], dl
	mov	eax, DWORD PTR $T231835[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN140@FindBestMu
	mov	ecx, DWORD PTR $T231835[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN140@FindBestMu:
	mov	edx, DWORD PTR $T231835[ebp]
	mov	DWORD PTR tv245[ebp], edx
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H
	mov	DWORD PTR tv246[ebp], eax
	mov	eax, DWORD PTR tv246[ebp]
	mov	DWORD PTR _iPathTurns$[ebp], eax

; 1439 : 					if(iPathTurns < iBestTurnsToReach)

	mov	ecx, DWORD PTR _iPathTurns$[ebp]
	cmp	ecx, DWORD PTR _iBestTurnsToReach$[ebp]
	jge	SHORT $LN3@FindBestMu

; 1440 : 					{
; 1441 : 						iBestTurnsToReach = iPathTurns;

	mov	edx, DWORD PTR _iPathTurns$[ebp]
	mov	DWORD PTR _iBestTurnsToReach$[ebp], edx

; 1442 : 						pBestTargetPlot = pLoopPlot;

	mov	eax, DWORD PTR _pLoopPlot$226306[ebp]
	mov	DWORD PTR _pBestTargetPlot$[ebp], eax
$LN3@FindBestMu:

; 1443 : 					}
; 1444 : 				}
; 1445 : 			}	
; 1446 : 		}

	jmp	$LN5@FindBestMu
$LN7@FindBestMu:

; 1447 : 	}
; 1448 : 
; 1449 : 	return pBestTargetPlot;

	mov	ecx, DWORD PTR _pBestTargetPlot$[ebp]
	mov	DWORD PTR $T231571[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pMusician$[ebp], 0
	je	SHORT $LN145@FindBestMu
	mov	ecx, DWORD PTR _pMusician$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN145@FindBestMu:
	mov	eax, DWORD PTR $T231571[ebp]
$LN19@FindBestMu:

; 1450 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindBestMusicianTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z$0:
	lea	ecx, DWORD PTR _pMusician$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?FindBestMusicianTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-216]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?FindBestMusicianTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindBestMusicianTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z ENDP ; CvPlayerAI::FindBestMusicianTargetPlot
PUBLIC	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ		; CvPlot::getPlotCity
PUBLIC	?FindBestArtistTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@AAH@Z ; CvPlayerAI::FindBestArtistTargetPlot
EXTRN	?getYield@CvPlot@@QBEHW4YieldTypes@@@Z:PROC	; CvPlot::getYield
EXTRN	?GetResourceWeight@CvBuilderTaskingAI@@QAEHW4ResourceTypes@@W4ImprovementTypes@@H@Z:PROC ; CvBuilderTaskingAI::GetResourceWeight
EXTRN	?GetBuilderTaskingAI@CvPlayer@@QBEPAVCvBuilderTaskingAI@@XZ:PROC ; CvPlayer::GetBuilderTaskingAI
EXTRN	?getNumResource@CvPlot@@QBEHXZ:PROC		; CvPlot::getNumResource
EXTRN	?GetLandDisputeLevel@CvDiplomacyAI@@QBE?AW4DisputeLevelTypes@@W4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetLandDisputeLevel
EXTRN	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z:PROC ; CvDiplomacyAI::GetMajorCivApproach
EXTRN	?GetCultureBombRadius@CvImprovementEntry@@QBEHXZ:PROC ; CvImprovementEntry::GetCultureBombRadius
EXTRN	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z:PROC ; CvGlobals::getImprovementInfo
EXTRN	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ:PROC ; CvPlot::getImprovementType
EXTRN	?isNoImprovement@CvFeatureInfo@@QBE_NXZ:PROC	; CvFeatureInfo::isNoImprovement
EXTRN	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z:PROC ; CvGlobals::getFeatureInfo
EXTRN	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ:PROC ; CvResourceInfo::getResourceUsage
EXTRN	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z:PROC ; CvGlobals::getResourceInfo
EXTRN	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::getResourceType
EXTRN	?IsAdjacentOwnedByOtherTeam@CvPlot@@QBE_NW4TeamTypes@@@Z:PROC ; CvPlot::IsAdjacentOwnedByOtherTeam
EXTRN	?GetPlots@CvPlayer@@QAEAAV?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@XZ:PROC ; CvPlayer::GetPlots
; Function compile flags: /Odtp
;	COMDAT ?FindBestArtistTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@AAH@Z
_TEXT	SEGMENT
tv251 = -232						; size = 4
tv289 = -228						; size = 4
_this$ = -224						; size = 4
$T232146 = -220						; size = 4
$T232126 = -212						; size = 4
_playerID$232118 = -208					; size = 4
$T232109 = -204						; size = 4
_playerID$232101 = -200					; size = 4
$T231912 = -116						; size = 4
$T231908 = -112						; size = 4
_f$231904 = -105					; size = 1
$T231895 = -104						; size = 4
$T231883 = -100						; size = 4
$T231876 = -96						; size = 4
$T231869 = -92						; size = 4
$T231865 = -88						; size = 4
_iYield$226372 = -84					; size = 4
_eLandDisputeLevel$226366 = -80				; size = 4
_bTickedAboutLand$226368 = -73				; size = 1
_eMajorApproach$226365 = -72				; size = 4
_bTicked$226367 = -65					; size = 1
_eMinorApproach$226362 = -64				; size = 4
_eOtherPlayer$226360 = -60				; size = 4
_pAdjacentPlot$226354 = -56				; size = 4
_iI$226350 = -52					; size = 4
_pkImprovementInfo$226346 = -48				; size = 4
_pkResource$226338 = -44				; size = 4
_pPlot$226333 = -40					; size = 4
_eImprovement$226343 = -36				; size = 4
_eFeature$226341 = -32					; size = 4
_iScore$226349 = -28					; size = 4
_eResource$226336 = -24					; size = 4
_ui$226328 = -20					; size = 4
_nPlots$ = -16						; size = 4
_pBestPlot$ = -12					; size = 4
_iBestScore$ = -8					; size = 4
_m_aiPlots$ = -4					; size = 4
_pGreatArtist$ = 8					; size = 4
_iResultScore$ = 12					; size = 4
?FindBestArtistTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@AAH@Z PROC ; CvPlayerAI::FindBestArtistTargetPlot, COMDAT
; _this$ = ecx

; 1453 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	mov	DWORD PTR _this$[ebp], ecx

; 1454 : 	CvAssertMsg(pGreatArtist, "pGreatArtist is null");
; 1455 : 	if(!pGreatArtist)

	cmp	DWORD PTR _pGreatArtist$[ebp], 0
	jne	SHORT $LN31@FindBestAr

; 1456 : 	{
; 1457 : 		return NULL;

	xor	eax, eax
	jmp	$LN32@FindBestAr
$LN31@FindBestAr:

; 1458 : 	}
; 1459 : 
; 1460 : 	iResultScore = 0;

	mov	eax, DWORD PTR _iResultScore$[ebp]
	mov	DWORD PTR [eax], 0

; 1461 : 
; 1462 : #ifndef AUI_WARNING_FIXES
; 1463 : 	CvPlotsVector& m_aiPlots = GetPlots();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlots@CvPlayer@@QAEAAV?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@XZ ; CvPlayer::GetPlots
	mov	DWORD PTR _m_aiPlots$[ebp], eax

; 1464 : #endif
; 1465 : 
; 1466 : 	CvPlot* pBestPlot = NULL;

	mov	DWORD PTR _pBestPlot$[ebp], 0

; 1467 : 	int iBestScore = 0;

	mov	DWORD PTR _iBestScore$[ebp], 0

; 1468 : 
; 1469 : 	// loop through plots and wipe out ones that are invalid
; 1470 : 	const uint nPlots = m_aiPlots.size();

	mov	ecx, DWORD PTR _m_aiPlots$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _nPlots$[ebp], edx

; 1471 : 	for(uint ui = 0; ui < nPlots; ui++)

	mov	DWORD PTR _ui$226328[ebp], 0
	jmp	SHORT $LN30@FindBestAr
$LN29@FindBestAr:
	mov	eax, DWORD PTR _ui$226328[ebp]
	add	eax, 1
	mov	DWORD PTR _ui$226328[ebp], eax
$LN30@FindBestAr:
	mov	ecx, DWORD PTR _ui$226328[ebp]
	cmp	ecx, DWORD PTR _nPlots$[ebp]
	jae	$LN28@FindBestAr

; 1472 : 	{
; 1473 : 		if(m_aiPlots[ui] == -1)

	mov	edx, DWORD PTR _m_aiPlots$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ui$226328[ebp]
	cmp	DWORD PTR [eax+ecx*4], -1
	jne	SHORT $LN27@FindBestAr

; 1474 : 		{
; 1475 : 			continue;

	jmp	SHORT $LN29@FindBestAr
$LN27@FindBestAr:

; 1476 : 		}
; 1477 : 
; 1478 : 		CvPlot* pPlot = GC.getMap().plotByIndex(m_aiPlots[ui]);

	mov	edx, DWORD PTR _m_aiPlots$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ui$226328[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T231865[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T231869[ebp], eax
	mov	ecx, DWORD PTR $T231865[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T231883[ebp], edx
	cmp	DWORD PTR $T231883[ebp], 0
	jl	SHORT $LN47@FindBestAr
	mov	eax, DWORD PTR $T231869[ebp]
	mov	ecx, DWORD PTR [eax+4028]
	mov	DWORD PTR $T231876[ebp], ecx
	mov	edx, DWORD PTR $T231883[ebp]
	cmp	edx, DWORD PTR $T231876[ebp]
	jge	SHORT $LN47@FindBestAr
	mov	eax, DWORD PTR $T231883[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T231869[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv289[ebp], eax
	jmp	SHORT $LN45@FindBestAr
$LN47@FindBestAr:
	mov	DWORD PTR tv289[ebp], 0
$LN45@FindBestAr:
	mov	edx, DWORD PTR tv289[ebp]
	mov	DWORD PTR _pPlot$226333[ebp], edx

; 1479 : 
; 1480 : 		if(pPlot->isWater())

	mov	eax, DWORD PTR _pPlot$226333[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN55@FindBestAr

; 1481 : 		{
; 1482 : 			continue;

	jmp	$LN29@FindBestAr

; 1483 : 		}
; 1484 : 
; 1485 : 		if(!pPlot->IsAdjacentOwnedByOtherTeam(getTeam()))

$LN55@FindBestAr:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T231895[ebp], eax
	mov	eax, DWORD PTR $T231895[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlot$226333[ebp]
	call	?IsAdjacentOwnedByOtherTeam@CvPlot@@QBE_NW4TeamTypes@@@Z ; CvPlot::IsAdjacentOwnedByOtherTeam
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN25@FindBestAr

; 1486 : 		{
; 1487 : 			continue;

	jmp	$LN29@FindBestAr
$LN25@FindBestAr:

; 1488 : 		}
; 1489 : 
; 1490 : 		// don't build over luxury resources
; 1491 : 		ResourceTypes eResource = pPlot->getResourceType();

	push	-1
	mov	ecx, DWORD PTR _pPlot$226333[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _eResource$226336[ebp], eax

; 1492 : 		if(eResource != NO_RESOURCE)

	cmp	DWORD PTR _eResource$226336[ebp], -1
	je	SHORT $LN59@FindBestAr

; 1493 : 		{
; 1494 : 			CvResourceInfo* pkResource = GC.getResourceInfo(eResource);

	mov	edx, DWORD PTR _eResource$226336[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	DWORD PTR _pkResource$226338[ebp], eax

; 1495 : 			if(pkResource != NULL)

	cmp	DWORD PTR _pkResource$226338[ebp], 0
	je	SHORT $LN59@FindBestAr

; 1496 : 			{
; 1497 : 				if (pkResource->getResourceUsage() == RESOURCEUSAGE_LUXURY)

	mov	ecx, DWORD PTR _pkResource$226338[ebp]
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	cmp	eax, 2
	jne	SHORT $LN59@FindBestAr

; 1498 : 				{
; 1499 : 					continue;

	jmp	$LN29@FindBestAr

; 1500 : 				}
; 1501 : 			}
; 1502 : 		}
; 1503 : 
; 1504 : 		// if no improvement can be built on this plot, then don't consider it
; 1505 : 		FeatureTypes eFeature = pPlot->getFeatureType();

$LN59@FindBestAr:
	mov	eax, DWORD PTR _pPlot$226333[ebp]
	mov	cl, BYTE PTR [eax+432]
	mov	BYTE PTR _f$231904[ebp], cl
	movsx	edx, BYTE PTR _f$231904[ebp]
	mov	DWORD PTR _eFeature$226341[ebp], edx

; 1506 : 		if (eFeature != NO_FEATURE && GC.getFeatureInfo(eFeature)->isNoImprovement())

	cmp	DWORD PTR _eFeature$226341[ebp], -1
	je	SHORT $LN21@FindBestAr
	mov	eax, DWORD PTR _eFeature$226341[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?isNoImprovement@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::isNoImprovement
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN21@FindBestAr

; 1507 : 		{
; 1508 : 			continue;

	jmp	$LN29@FindBestAr
$LN21@FindBestAr:

; 1509 : 		}
; 1510 : 
; 1511 : 		// Improvement already here?
; 1512 : 		ImprovementTypes eImprovement = (ImprovementTypes)pPlot->getImprovementType();

	mov	ecx, DWORD PTR _pPlot$226333[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	mov	DWORD PTR _eImprovement$226343[ebp], eax

; 1513 : 		if (eImprovement != NO_IMPROVEMENT)

	cmp	DWORD PTR _eImprovement$226343[ebp], -1
	je	SHORT $LN20@FindBestAr

; 1514 : 		{
; 1515 : 			CvImprovementEntry* pkImprovementInfo = GC.getImprovementInfo(eImprovement);

	mov	edx, DWORD PTR _eImprovement$226343[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	DWORD PTR _pkImprovementInfo$226346[ebp], eax

; 1516 : 			if(pkImprovementInfo)

	cmp	DWORD PTR _pkImprovementInfo$226346[ebp], 0
	je	SHORT $LN20@FindBestAr

; 1517 : 			{
; 1518 : 				if (pkImprovementInfo->GetCultureBombRadius() > 0)

	mov	ecx, DWORD PTR _pkImprovementInfo$226346[ebp]
	call	?GetCultureBombRadius@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetCultureBombRadius
	test	eax, eax
	jle	SHORT $LN20@FindBestAr

; 1519 : 				{
; 1520 : 					continue;

	jmp	$LN29@FindBestAr
$LN20@FindBestAr:

; 1521 : 				}
; 1522 : 			}
; 1523 : 		}
; 1524 : 
; 1525 : 		int iScore = 0;

	mov	DWORD PTR _iScore$226349[ebp], 0

; 1526 : 
; 1527 : 		for(int iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$226350[ebp], 0
	jmp	SHORT $LN17@FindBestAr
$LN16@FindBestAr:
	mov	eax, DWORD PTR _iI$226350[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$226350[ebp], eax
$LN17@FindBestAr:
	cmp	DWORD PTR _iI$226350[ebp], 6
	jge	$LN15@FindBestAr

; 1528 : 		{
; 1529 : 			CvPlot* pAdjacentPlot = plotDirection(pPlot->getX(), pPlot->getY(), ((DirectionTypes)iI));

	mov	ecx, DWORD PTR _pPlot$226333[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T231908[ebp], edx
	mov	eax, DWORD PTR _pPlot$226333[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T231912[ebp], ecx
	mov	edx, DWORD PTR _iI$226350[ebp]
	push	edx
	mov	eax, DWORD PTR $T231908[ebp]
	push	eax
	mov	ecx, DWORD PTR $T231912[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$226354[ebp], eax

; 1530 : 			// if there's no plot, bail
; 1531 : 			if(pAdjacentPlot == NULL)

	cmp	DWORD PTR _pAdjacentPlot$226354[ebp], 0
	jne	SHORT $LN145@FindBestAr

; 1532 : 			{
; 1533 : 				continue;

	jmp	SHORT $LN16@FindBestAr

; 1534 : 			}
; 1535 : 
; 1536 : 			// if the plot is ours or no one's, bail
; 1537 : 			if(pAdjacentPlot->getTeam() == NO_TEAM || pAdjacentPlot->getTeam() == getTeam())

$LN145@FindBestAr:
	mov	edx, DWORD PTR _pAdjacentPlot$226354[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR _playerID$232101[ebp], eax
	cmp	DWORD PTR _playerID$232101[ebp], -1
	je	SHORT $LN142@FindBestAr
	mov	ecx, DWORD PTR _playerID$232101[ebp]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T232109[ebp], eax
	jmp	SHORT $LN143@FindBestAr
	jmp	SHORT $LN143@FindBestAr
$LN142@FindBestAr:
	mov	DWORD PTR $T232109[ebp], -1
$LN143@FindBestAr:
	cmp	DWORD PTR $T232109[ebp], -1
	je	SHORT $LN12@FindBestAr
	mov	edx, DWORD PTR _pAdjacentPlot$226354[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR _playerID$232118[ebp], eax
	cmp	DWORD PTR _playerID$232118[ebp], -1
	je	SHORT $LN150@FindBestAr
	mov	ecx, DWORD PTR _playerID$232118[ebp]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T232126[ebp], eax
	jmp	SHORT $LN157@FindBestAr
	jmp	SHORT $LN157@FindBestAr
$LN150@FindBestAr:
	mov	DWORD PTR $T232126[ebp], -1
$LN157@FindBestAr:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	DWORD PTR $T232126[ebp], eax
	jne	SHORT $LN13@FindBestAr
$LN12@FindBestAr:

; 1538 : 			{
; 1539 : 				continue;

	jmp	$LN16@FindBestAr
$LN13@FindBestAr:

; 1540 : 			}
; 1541 : 
; 1542 : 			// don't evaluate city plots since we don't get ownership of them with the bomb
; 1543 : 			if(pAdjacentPlot->getPlotCity())

	mov	ecx, DWORD PTR _pAdjacentPlot$226354[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	test	eax, eax
	je	SHORT $LN166@FindBestAr

; 1544 : 			{
; 1545 : 				continue;

	jmp	$LN16@FindBestAr

; 1546 : 			}
; 1547 : 
; 1548 : 			const PlayerTypes eOtherPlayer = pAdjacentPlot->getOwner();

$LN166@FindBestAr:
	mov	ecx, DWORD PTR _pAdjacentPlot$226354[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR _eOtherPlayer$226360[ebp], edx

; 1549 : 			if(GET_PLAYER(eOtherPlayer).isMinorCiv())

	mov	eax, DWORD PTR _eOtherPlayer$226360[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232146[ebp], eax
	mov	ecx, DWORD PTR $T232146[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN10@FindBestAr

; 1550 : 			{
; 1551 : 				MinorCivApproachTypes eMinorApproach = GetDiplomacyAI()->GetMinorCivApproach(eOtherPlayer);

	mov	edx, DWORD PTR _eOtherPlayer$226360[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMinorCivApproach@CvDiplomacyAI@@QBE?AW4MinorCivApproachTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetMinorCivApproach
	mov	DWORD PTR _eMinorApproach$226362[ebp], eax

; 1552 : 				// if we're friendly or protective, don't be a jerk. Bail out.
; 1553 : 				if(eMinorApproach != MINOR_CIV_APPROACH_CONQUEST && eMinorApproach != MINOR_CIV_APPROACH_IGNORE)

	cmp	DWORD PTR _eMinorApproach$226362[ebp], 3
	je	SHORT $LN9@FindBestAr
	cmp	DWORD PTR _eMinorApproach$226362[ebp], 0
	je	SHORT $LN9@FindBestAr

; 1554 : 				{
; 1555 : 					iScore = 0;

	mov	DWORD PTR _iScore$226349[ebp], 0

; 1556 : 					break;

	jmp	$LN15@FindBestAr
$LN9@FindBestAr:

; 1557 : 				}
; 1558 : 			}
; 1559 : 			else

	jmp	$LN8@FindBestAr
$LN10@FindBestAr:

; 1560 : 			{
; 1561 : 				MajorCivApproachTypes eMajorApproach = GetDiplomacyAI()->GetMajorCivApproach(eOtherPlayer, true);

	push	1
	mov	eax, DWORD PTR _eOtherPlayer$226360[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z ; CvDiplomacyAI::GetMajorCivApproach
	mov	DWORD PTR _eMajorApproach$226365[ebp], eax

; 1562 : 				DisputeLevelTypes eLandDisputeLevel = GetDiplomacyAI()->GetLandDisputeLevel(eOtherPlayer);

	mov	ecx, DWORD PTR _eOtherPlayer$226360[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetLandDisputeLevel@CvDiplomacyAI@@QBE?AW4DisputeLevelTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetLandDisputeLevel
	mov	DWORD PTR _eLandDisputeLevel$226366[ebp], eax

; 1563 : 
; 1564 : 				bool bTicked = eMajorApproach == MAJOR_CIV_APPROACH_HOSTILE;

	xor	edx, edx
	cmp	DWORD PTR _eMajorApproach$226365[ebp], 1
	sete	dl
	mov	BYTE PTR _bTicked$226367[ebp], dl

; 1565 : 				bool bTickedAboutLand = eMajorApproach == MAJOR_CIV_APPROACH_NEUTRAL && (eLandDisputeLevel == DISPUTE_LEVEL_STRONG || eLandDisputeLevel == DISPUTE_LEVEL_FIERCE);

	cmp	DWORD PTR _eMajorApproach$226365[ebp], 6
	jne	SHORT $LN35@FindBestAr
	cmp	DWORD PTR _eLandDisputeLevel$226366[ebp], 2
	je	SHORT $LN34@FindBestAr
	cmp	DWORD PTR _eLandDisputeLevel$226366[ebp], 3
	jne	SHORT $LN35@FindBestAr
$LN34@FindBestAr:
	mov	DWORD PTR tv251[ebp], 1
	jmp	SHORT $LN36@FindBestAr
$LN35@FindBestAr:
	mov	DWORD PTR tv251[ebp], 0
$LN36@FindBestAr:
	mov	al, BYTE PTR tv251[ebp]
	mov	BYTE PTR _bTickedAboutLand$226368[ebp], al

; 1566 : 
; 1567 : 				// only bomb if we're hostile
; 1568 : 				if(!bTicked && !bTickedAboutLand)

	movzx	ecx, BYTE PTR _bTicked$226367[ebp]
	test	ecx, ecx
	jne	SHORT $LN8@FindBestAr
	movzx	edx, BYTE PTR _bTickedAboutLand$226368[ebp]
	test	edx, edx
	jne	SHORT $LN8@FindBestAr

; 1569 : 				{
; 1570 : 					iScore = 0;

	mov	DWORD PTR _iScore$226349[ebp], 0

; 1571 : 					break;

	jmp	SHORT $LN15@FindBestAr
$LN8@FindBestAr:

; 1572 : 				}
; 1573 : 			}
; 1574 : 
; 1575 : 			eResource = pAdjacentPlot->getResourceType();

	push	-1
	mov	ecx, DWORD PTR _pAdjacentPlot$226354[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _eResource$226336[ebp], eax

; 1576 : 			if(eResource != NO_RESOURCE)

	cmp	DWORD PTR _eResource$226336[ebp], -1
	je	SHORT $LN6@FindBestAr

; 1577 : 			{
; 1578 : 				iScore += GetBuilderTaskingAI()->GetResourceWeight(eResource, NO_IMPROVEMENT, pAdjacentPlot->getNumResource()) * 10;

	mov	ecx, DWORD PTR _pAdjacentPlot$226354[ebp]
	call	?getNumResource@CvPlot@@QBEHXZ		; CvPlot::getNumResource
	push	eax
	push	-1
	mov	eax, DWORD PTR _eResource$226336[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBuilderTaskingAI@CvPlayer@@QBEPAVCvBuilderTaskingAI@@XZ ; CvPlayer::GetBuilderTaskingAI
	mov	ecx, eax
	call	?GetResourceWeight@CvBuilderTaskingAI@@QAEHW4ResourceTypes@@W4ImprovementTypes@@H@Z ; CvBuilderTaskingAI::GetResourceWeight
	imul	eax, 10					; 0000000aH
	add	eax, DWORD PTR _iScore$226349[ebp]
	mov	DWORD PTR _iScore$226349[ebp], eax

; 1579 : 			}
; 1580 : 			else

	jmp	SHORT $LN5@FindBestAr
$LN6@FindBestAr:

; 1581 : 			{
; 1582 : 				for(int iYield = 0; iYield < NUM_YIELD_TYPES; iYield++)

	mov	DWORD PTR _iYield$226372[ebp], 0
	jmp	SHORT $LN4@FindBestAr
$LN3@FindBestAr:
	mov	ecx, DWORD PTR _iYield$226372[ebp]
	add	ecx, 1
	mov	DWORD PTR _iYield$226372[ebp], ecx
$LN4@FindBestAr:
	cmp	DWORD PTR _iYield$226372[ebp], 6
	jge	SHORT $LN5@FindBestAr

; 1583 : 				{
; 1584 : 					iScore += pAdjacentPlot->getYield((YieldTypes)iYield);

	mov	edx, DWORD PTR _iYield$226372[ebp]
	push	edx
	mov	ecx, DWORD PTR _pAdjacentPlot$226354[ebp]
	call	?getYield@CvPlot@@QBEHW4YieldTypes@@@Z	; CvPlot::getYield
	add	eax, DWORD PTR _iScore$226349[ebp]
	mov	DWORD PTR _iScore$226349[ebp], eax

; 1585 : 				}

	jmp	SHORT $LN3@FindBestAr
$LN5@FindBestAr:

; 1586 : 			}
; 1587 : 		}

	jmp	$LN16@FindBestAr
$LN15@FindBestAr:

; 1588 : 
; 1589 : 		if(iScore > iBestScore)

	mov	eax, DWORD PTR _iScore$226349[ebp]
	cmp	eax, DWORD PTR _iBestScore$[ebp]
	jle	SHORT $LN1@FindBestAr

; 1590 : 		{
; 1591 : 			iBestScore = iScore;

	mov	ecx, DWORD PTR _iScore$226349[ebp]
	mov	DWORD PTR _iBestScore$[ebp], ecx

; 1592 : 			pBestPlot = pPlot;

	mov	edx, DWORD PTR _pPlot$226333[ebp]
	mov	DWORD PTR _pBestPlot$[ebp], edx
$LN1@FindBestAr:

; 1593 : 		}
; 1594 : 	}

	jmp	$LN29@FindBestAr
$LN28@FindBestAr:

; 1595 : 
; 1596 : 	iResultScore = iBestScore;

	mov	eax, DWORD PTR _iResultScore$[ebp]
	mov	ecx, DWORD PTR _iBestScore$[ebp]
	mov	DWORD PTR [eax], ecx

; 1597 : 	return pBestPlot;

	mov	eax, DWORD PTR _pBestPlot$[ebp]
$LN32@FindBestAr:

; 1598 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?FindBestArtistTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@AAH@Z ENDP ; CvPlayerAI::FindBestArtistTargetPlot
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
_TEXT	ENDS
;	COMDAT ??1?$FObjectHandle@VCvUnit@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ PROC		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 146  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 147  : 		if(m_target) 

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@FObjectHan

; 148  : 		{
; 149  : 			m_target->getDestructionNotification().removeTarget(*this);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN2@FObjectHan:

; 150  : 		}
; 151  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ ENDP		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAE_NI@Z ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Buy
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv88 = -132						; size = 4
tv145 = -128						; size = 4
_this$ = -124						; size = 4
$T232183 = -30						; size = 1
$T232170 = -29						; size = 1
$T232166 = -28						; size = 4
$T232159 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ PROC ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::vector<CityAndProduction,std::allocator<CityAndProduction> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T232183[ebp]
	mov	DWORD PTR $T232159[ebp], eax
	lea	ecx, DWORD PTR $T232170[ebp]
	mov	DWORD PTR $T232166[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv145[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv88[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAE_NI@Z ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ ENDP ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::vector<CityAndProduction,std::allocator<CityAndProduction> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ PROC ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::~vector<CityAndProduction,std::allocator<CityAndProduction> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXXZ ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ ENDP ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::~vector<CityAndProduction,std::allocator<CityAndProduction> >
PUBLIC	?insert@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@V?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@ABUCityAndProduction@@@Z ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::insert
PUBLIC	??$_Uninit_fill_n@PAUCityAndProduction@@IU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAXPAUCityAndProduction@@IABU1@AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CityAndProduction *,unsigned int,CityAndProduction,std::allocator<CityAndProduction> >
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAEXABUCityAndProduction@@@Z
_TEXT	SEGMENT
tv129 = -64						; size = 4
_this$ = -60						; size = 4
$T232369 = -32						; size = 4
$T232359 = -28						; size = 4
$T232349 = -24						; size = 4
__Cat$232357 = -19					; size = 1
$T232355 = -18						; size = 1
$T232354 = -17						; size = 1
$T232326 = -16						; size = 4
$T232322 = -12						; size = 4
$T232321 = -8						; size = 4
$T232320 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAEXABUCityAndProduction@@@Z PROC ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 3
	mov	DWORD PTR $T232326[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN9@push_back
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN7@push_back
$LN9@push_back:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 3
	mov	DWORD PTR tv129[ebp], eax
$LN7@push_back:
	mov	ecx, DWORD PTR $T232326[ebp]
	cmp	ecx, DWORD PTR tv129[ebp]
	jae	SHORT $LN2@push_back

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T232359[ebp], eax
	mov	ecx, DWORD PTR $T232359[ebp]
	mov	DWORD PTR $T232349[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T232354[ebp], dl
	mov	al, BYTE PTR __Cat$232357[ebp]
	mov	BYTE PTR $T232355[ebp], al
	movzx	ecx, BYTE PTR $T232354[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T232355[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR $T232349[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAUCityAndProduction@@IU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAXPAUCityAndProduction@@IABU1@AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CityAndProduction *,unsigned int,CityAndProduction,std::allocator<CityAndProduction> >
	add	esp, 24					; 00000018H
	mov	eax, 1
	shl	eax, 3
	add	eax, DWORD PTR $T232359[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back
$LN2@push_back:

; 823  : 			insert(end(), _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T232369[ebp], eax
	mov	ecx, DWORD PTR $T232369[ebp]
	mov	DWORD PTR $T232321[ebp], ecx
	mov	edx, DWORD PTR $T232321[ebp]
	mov	DWORD PTR $T232320[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T232320[ebp]
	push	ecx
	lea	edx, DWORD PTR $T232322[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@V?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@ABUCityAndProduction@@@Z ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::insert
$LN3@push_back:

; 824  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAEXABUCityAndProduction@@@Z ENDP ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::push_back
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CityAndProduction,std::allocator<CityAndProduction> >::~_Vector_val<CityAndProduction,std::allocator<CityAndProduction> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CityAndProduction,std::allocator<CityAndProduction> >::~_Vector_val<CityAndProduction,std::allocator<CityAndProduction> >
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@V?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@ABUCityAndProduction@@@Z
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
__Tmp$232500 = -24					; size = 4
$T232478 = -20						; size = 4
$T232459 = -16						; size = 4
$T232446 = -12						; size = 4
$T232443 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@V?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@ABUCityAndProduction@@@Z PROC ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 3
	test	edx, edx
	jne	SHORT $LN3@insert
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert
$LN3@insert:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T232459[ebp], ecx
	mov	edx, DWORD PTR $T232459[ebp]
	mov	DWORD PTR $T232443[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	sub	eax, DWORD PTR $T232443[ebp]
	sar	eax, 3
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T232478[ebp], edx
	mov	eax, DWORD PTR $T232478[ebp]
	mov	DWORD PTR $T232446[ebp], eax
	mov	ecx, DWORD PTR $T232446[ebp]
	mov	DWORD PTR __Tmp$232500[ebp], ecx
	mov	edx, DWORD PTR __Off$[ebp]
	mov	eax, DWORD PTR __Tmp$232500[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR __Tmp$232500[ebp], ecx
	mov	edx, DWORD PTR __Tmp$232500[ebp]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@QAE?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@V?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@ABUCityAndProduction@@@Z ENDP ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::insert
_TEXT	ENDS
PUBLIC	??$_Allocate@UCityAndProduction@@@std@@YAPAUCityAndProduction@@IPAU1@@Z ; std::_Allocate<CityAndProduction>
PUBLIC	?_Xlen@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@KAXXZ ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$232517 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy
	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$232517[ebp], 536870911 ; 1fffffffH
	cmp	DWORD PTR __Count$232517[ebp], 0
	jbe	SHORT $LN11@Buy
	mov	eax, DWORD PTR __Count$232517[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy
$LN11@Buy:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@KAXXZ ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@UCityAndProduction@@@std@@YAPAUCityAndProduction@@IPAU1@@Z ; std::_Allocate<CityAndProduction>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T232611 = -32						; size = 4
$T232610 = -28						; size = 4
$T232606 = -24						; size = 4
$T232605 = -20						; size = 4
$T232587 = -16						; size = 4
$T232586 = -12						; size = 4
$T232570 = -8						; size = 4
__Cat$232593 = -2					; size = 1
$T232590 = -1						; size = 1
?_Tidy@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXXZ PROC ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T232606[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T232605[ebp], ecx
	mov	edx, DWORD PTR $T232606[ebp]
	mov	DWORD PTR $T232587[ebp], edx
	mov	eax, DWORD PTR $T232605[ebp]
	mov	DWORD PTR $T232586[ebp], eax
	mov	cl, BYTE PTR __Cat$232593[ebp]
	mov	BYTE PTR $T232590[ebp], cl
	mov	edx, DWORD PTR $T232586[ebp]
	mov	DWORD PTR $T232570[ebp], edx
	jmp	SHORT $LN12@Tidy
$LN11@Tidy:
	mov	eax, DWORD PTR $T232570[ebp]
	add	eax, 8
	mov	DWORD PTR $T232570[ebp], eax
$LN12@Tidy:
	mov	ecx, DWORD PTR $T232570[ebp]
	cmp	ecx, DWORD PTR $T232587[ebp]
	je	SHORT $LN4@Tidy
	jmp	SHORT $LN11@Tidy
$LN4@Tidy:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 3
	mov	DWORD PTR $T232611[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T232610[ebp], eax
	mov	ecx, DWORD PTR $T232610[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXXZ ENDP ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Tidy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T232648 = -16						; size = 4
$T232627 = -12						; size = 4
$T232620 = -8						; size = 4
__Pnode$226527 = -4					; size = 4
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 377  : 			{	// move to node with next larger value

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 378  : 
; 379  :  #if _HAS_ITERATOR_DEBUGGING
; 380  : 			if (this->_Mycont == 0
; 381  : 				|| _Ptr == 0
; 382  : 				|| _Isnil(_Ptr))
; 383  : 				{
; 384  : 				_DEBUG_ERROR("map/set iterator not incrementable");
; 385  : 				_SCL_SECURE_OUT_OF_RANGE;
; 386  : 				}
; 387  :  #else
; 388  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 389  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	je	SHORT $LN6@Inc
	jmp	$LN7@Inc
$LN6@Inc:

; 390  : 				{
; 391  : 				_SCL_SECURE_OUT_OF_RANGE;
; 392  : 				// end() shouldn't be incremented, don't move if _SCL_SECURE is not turned on
; 393  : 				}
; 394  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 395  : 
; 396  : 			else if (!_Isnil(_Right(_Ptr)))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	mov	DWORD PTR $T232620[ebp], ecx
	mov	edx, DWORD PTR $T232620[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+21]
	test	ecx, ecx
	jne	SHORT $LN27@Inc

; 397  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 8
	mov	DWORD PTR $T232627[ebp], eax
	mov	ecx, DWORD PTR $T232627[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T232648[ebp], edx
$LN23@Inc:
	mov	eax, DWORD PTR $T232648[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	jne	SHORT $LN19@Inc
	mov	eax, DWORD PTR $T232648[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T232648[ebp], ecx
	jmp	SHORT $LN23@Inc
$LN19@Inc:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T232648[ebp]
	mov	DWORD PTR [edx], eax

; 398  : 			else

	jmp	SHORT $LN7@Inc

; 399  : 				{	// climb looking for right subtree
; 400  : 				_Nodeptr _Pnode;
; 401  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 402  : 					&& _Ptr == _Right(_Pnode))

$LN27@Inc:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$226527[ebp], eax
	mov	ecx, DWORD PTR __Pnode$226527[ebp]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	jne	SHORT $LN1@Inc
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$226527[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN1@Inc

; 403  : 					_Ptr = _Pnode;	// ==> parent while right subtree

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$226527[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN27@Inc
$LN1@Inc:

; 404  : 				_Ptr = _Pnode;	// ==> parent (head if end())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Pnode$226527[ebp]
	mov	DWORD PTR [edx], eax
$LN7@Inc:

; 405  : 				}
; 406  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVCvAIOperation@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCvAIOperation@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,CvAIOperation *,std::less<int>,std::allocator<std::pair<int const ,CvAIOperation *> >,0> >::const_iterator::_Inc
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CityAndProduction *,CityAndProduction *,std::allocator<CityAndProduction> >
PUBLIC	??$unchecked_uninitialized_copy@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@stdext@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CityAndProduction *,CityAndProduction *,std::allocator<CityAndProduction> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z$2
__catchsym$?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z$0
__unwindtable$?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z$5
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z$6
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z
_TEXT	SEGMENT
tv84 = -432						; size = 4
tv304 = -428						; size = 4
tv290 = -424						; size = 4
tv282 = -420						; size = 4
_this$ = -416						; size = 4
$T233341 = -412						; size = 4
$T233333 = -408						; size = 4
$T233332 = -404						; size = 4
$T233309 = -398						; size = 1
$T233308 = -397						; size = 1
$T233307 = -396						; size = 4
$T233306 = -392						; size = 4
$T233294 = -385						; size = 1
$T233293 = -384						; size = 4
$T233292 = -380						; size = 4
$T233291 = -376						; size = 4
__Cat$233326 = -372					; size = 1
$T233324 = -371						; size = 1
$T233323 = -370						; size = 1
__Cat$233316 = -368					; size = 1
$T233314 = -367						; size = 1
$T233313 = -366						; size = 1
$T233312 = -365						; size = 1
$T233266 = -364						; size = 4
$T233247 = -360						; size = 4
$T233230 = -353						; size = 1
$T233229 = -352						; size = 4
$T233219 = -348						; size = 4
$T233218 = -344						; size = 4
__Cat$233263 = -338					; size = 1
$T233261 = -337						; size = 1
$T233260 = -336						; size = 1
__Cat$233255 = -335					; size = 1
$T233253 = -334						; size = 1
$T233252 = -333						; size = 1
$T233194 = -332						; size = 4
$T233186 = -328						; size = 4
$T233178 = -324						; size = 4
$T233160 = -320						; size = 4
$T233159 = -316						; size = 4
$T233143 = -312						; size = 4
__Cat$233167 = -306					; size = 1
$T233165 = -305						; size = 1
$T233117 = -304						; size = 4
$T233116 = -300						; size = 4
$T233106 = -296						; size = 4
__Cat$233115 = -291					; size = 1
$T233112 = -290						; size = 1
$T233111 = -289						; size = 1
$T233090 = -288						; size = 4
$T233071 = -284						; size = 4
$T233054 = -277						; size = 1
$T233053 = -276						; size = 4
$T233043 = -272						; size = 4
$T233042 = -268						; size = 4
__Cat$233087 = -262					; size = 1
$T233084 = -261						; size = 1
$T233083 = -260						; size = 1
__Cat$233079 = -259					; size = 1
$T233076 = -258						; size = 1
$T233075 = -257						; size = 1
$T233018 = -256						; size = 4
$T233017 = -252						; size = 4
$T233013 = -248						; size = 4
$T233012 = -244						; size = 4
$T232994 = -240						; size = 4
$T232993 = -236						; size = 4
$T232977 = -232						; size = 4
__Cat$233002 = -226					; size = 1
$T232999 = -225						; size = 1
$T232928 = -224						; size = 4
$T232927 = -220						; size = 4
$T232911 = -216						; size = 4
__Cat$232935 = -210					; size = 1
$T232932 = -209						; size = 1
$T232868 = -208						; size = 4
$T232867 = -204						; size = 4
$T232851 = -200						; size = 4
__Cat$232875 = -194					; size = 1
$T232872 = -193						; size = 1
$T232825 = -192						; size = 4
$T232813 = -188						; size = 4
$T232803 = -181						; size = 1
$T232802 = -180						; size = 4
__Cat$232820 = -175					; size = 1
$T232817 = -174						; size = 1
$T232816 = -173						; size = 1
$T232790 = -172						; size = 4
$T232778 = -168						; size = 4
$T232768 = -161						; size = 1
$T232767 = -160						; size = 4
__Cat$232785 = -155					; size = 1
$T232782 = -154						; size = 1
$T232781 = -153						; size = 1
$T232755 = -152						; size = 4
$T232745 = -148						; size = 4
__Cat$232753 = -143					; size = 1
$T232750 = -142						; size = 1
$T232749 = -141						; size = 1
__Count$232718 = -128					; size = 4
__Count$232692 = -56					; size = 4
__Tmp$226575 = -52					; size = 8
__Oldend$226576 = -44					; size = 4
__Tmp$226565 = -40					; size = 8
__Ncopied$226552 = -32					; size = 4
__Newvec$226550 = -28					; size = 4
__Whereoff$226551 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z PROC ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 416				; 000001a0H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN29@Insert_n
	mov	DWORD PTR tv282[ebp], 0
	jmp	SHORT $LN27@Insert_n
$LN29@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 3
	mov	DWORD PTR tv282[ebp], eax
$LN27@Insert_n:
	mov	ecx, DWORD PTR tv282[ebp]
	mov	DWORD PTR __Capacity$[ebp], ecx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n
	jmp	$LN16@Insert_n
$LN14@Insert_n:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$232692[ebp], 536870911 ; 1fffffffH
	cmp	DWORD PTR __Count$232692[ebp], 0
	jbe	SHORT $LN35@Insert_n
	mov	edx, DWORD PTR __Count$232692[ebp]
	mov	DWORD PTR tv290[ebp], edx
	jmp	SHORT $LN37@Insert_n
$LN35@Insert_n:
	mov	DWORD PTR tv290[ebp], 1
$LN37@Insert_n:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 3
	mov	eax, DWORD PTR tv290[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN42@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@KAXXZ ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Xlen
	jmp	$LN16@Insert_n

; 1167 : 		else if (_Capacity < size() + _Count)

$LN42@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 3
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$232718[ebp], 536870911 ; 1fffffffH
	cmp	DWORD PTR __Count$232718[ebp], 0
	jbe	SHORT $LN48@Insert_n
	mov	ecx, DWORD PTR __Count$232718[ebp]
	mov	DWORD PTR tv304[ebp], ecx
	jmp	SHORT $LN44@Insert_n
$LN48@Insert_n:
	mov	DWORD PTR tv304[ebp], 1
$LN44@Insert_n:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	mov	eax, DWORD PTR tv304[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	add	ecx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], ecx
$LN18@Insert_n:
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1171 : 			if (_Capacity < size() + _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 3
	add	edx, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], edx
	jae	SHORT $LN54@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 3
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN54@Insert_n:
	push	0
	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	call	??$_Allocate@UCityAndProduction@@@std@@YAPAUCityAndProduction@@IPAU1@@Z ; std::_Allocate<CityAndProduction>
	add	esp, 8
	mov	DWORD PTR __Newvec$226550[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 3
	mov	DWORD PTR __Whereoff$226551[ebp], edx

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$226552[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Whereoff$226551[ebp]
	mov	ecx, DWORD PTR __Newvec$226550[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR $T232755[ebp], edx
	mov	eax, DWORD PTR $T232755[ebp]
	mov	DWORD PTR $T232745[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T232749[ebp], cl
	mov	dl, BYTE PTR __Cat$232753[ebp]
	mov	BYTE PTR $T232750[ebp], dl
	movzx	eax, BYTE PTR $T232749[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T232750[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T232745[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAUCityAndProduction@@IU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAXPAUCityAndProduction@@IABU1@AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CityAndProduction *,unsigned int,CityAndProduction,std::allocator<CityAndProduction> >
	add	esp, 24					; 00000018H

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$226552[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$226552[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T232790[ebp], edx
	mov	eax, DWORD PTR __Newvec$226550[ebp]
	mov	DWORD PTR $T232778[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T232781[ebp], cl
	mov	dl, BYTE PTR __Cat$232785[ebp]
	mov	BYTE PTR $T232782[ebp], dl
	mov	al, BYTE PTR $T232781[ebp]
	mov	BYTE PTR $T232768[ebp], al
	mov	ecx, DWORD PTR $T232778[ebp]
	mov	DWORD PTR $T232767[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T232767[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T232790[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@stdext@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CityAndProduction *,CityAndProduction *,std::allocator<CityAndProduction> >
	add	esp, 16					; 00000010H

; 1182 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$226552[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$226552[ebp], eax

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T232825[ebp], edx
	mov	eax, DWORD PTR __Whereoff$226551[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Newvec$226550[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR $T232813[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T232816[ebp], al
	mov	cl, BYTE PTR __Cat$232820[ebp]
	mov	BYTE PTR $T232817[ebp], cl
	mov	dl, BYTE PTR $T232816[ebp]
	mov	BYTE PTR $T232803[ebp], dl
	mov	eax, DWORD PTR $T232813[ebp]
	mov	DWORD PTR $T232802[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T232802[ebp]
	push	edx
	mov	eax, DWORD PTR $T232825[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	call	??$unchecked_uninitialized_copy@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@stdext@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CityAndProduction *,CityAndProduction *,std::allocator<CityAndProduction> >
	add	esp, 16					; 00000010H
	jmp	$LN19@Insert_n
__catch$?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$226552[ebp], 1
	jle	SHORT $LN7@Insert_n

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	edx, DWORD PTR __Whereoff$226551[ebp]
	mov	eax, DWORD PTR __Newvec$226550[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T232868[ebp], ecx
	mov	edx, DWORD PTR __Newvec$226550[ebp]
	mov	DWORD PTR $T232867[ebp], edx
	mov	al, BYTE PTR __Cat$232875[ebp]
	mov	BYTE PTR $T232872[ebp], al
	mov	ecx, DWORD PTR $T232867[ebp]
	mov	DWORD PTR $T232851[ebp], ecx
	jmp	SHORT $LN91@Insert_n
$LN90@Insert_n:
	mov	edx, DWORD PTR $T232851[ebp]
	add	edx, 8
	mov	DWORD PTR $T232851[ebp], edx
$LN91@Insert_n:
	mov	eax, DWORD PTR $T232851[ebp]
	cmp	eax, DWORD PTR $T232868[ebp]
	je	SHORT $LN7@Insert_n
	jmp	SHORT $LN90@Insert_n
$LN7@Insert_n:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$226552[ebp], 0
	jle	SHORT $LN6@Insert_n

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Whereoff$226551[ebp]
	mov	edx, DWORD PTR __Newvec$226550[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T232928[ebp], edx
	mov	eax, DWORD PTR __Whereoff$226551[ebp]
	mov	ecx, DWORD PTR __Newvec$226550[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR $T232927[ebp], edx
	mov	al, BYTE PTR __Cat$232935[ebp]
	mov	BYTE PTR $T232932[ebp], al
	mov	ecx, DWORD PTR $T232927[ebp]
	mov	DWORD PTR $T232911[ebp], ecx
	jmp	SHORT $LN106@Insert_n
$LN105@Insert_n:
	mov	edx, DWORD PTR $T232911[ebp]
	add	edx, 8
	mov	DWORD PTR $T232911[ebp], edx
$LN106@Insert_n:
	mov	eax, DWORD PTR $T232911[ebp]
	cmp	eax, DWORD PTR $T232928[ebp]
	je	SHORT $LN6@Insert_n
	jmp	SHORT $LN105@Insert_n
$LN6@Insert_n:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	ecx, DWORD PTR __Newvec$226550[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN115@Insert_n
	ret	0
$LN19@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN115@Insert_n:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 3
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], ecx

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN5@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T233013[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T233012[ebp], eax
	mov	ecx, DWORD PTR $T233013[ebp]
	mov	DWORD PTR $T232994[ebp], ecx
	mov	edx, DWORD PTR $T233012[ebp]
	mov	DWORD PTR $T232993[ebp], edx
	mov	al, BYTE PTR __Cat$233002[ebp]
	mov	BYTE PTR $T232999[ebp], al
	mov	ecx, DWORD PTR $T232993[ebp]
	mov	DWORD PTR $T232977[ebp], ecx
	jmp	SHORT $LN125@Insert_n
$LN124@Insert_n:
	mov	edx, DWORD PTR $T232977[ebp]
	add	edx, 8
	mov	DWORD PTR $T232977[ebp], edx
$LN125@Insert_n:
	mov	eax, DWORD PTR $T232977[ebp]
	cmp	eax, DWORD PTR $T232994[ebp]
	je	SHORT $LN117@Insert_n
	jmp	SHORT $LN124@Insert_n
$LN117@Insert_n:

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 3
	mov	DWORD PTR $T233018[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T233017[ebp], edx
	mov	eax, DWORD PTR $T233017[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	ecx, DWORD PTR __Capacity$[ebp]
	mov	edx, DWORD PTR __Newvec$226550[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Newvec$226550[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newvec$226550[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	$LN16@Insert_n
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	sar	eax, 3
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$226565[ebp], edx
	mov	DWORD PTR __Tmp$226565[ebp+4], eax

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T233090[ebp], edx
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR $T233071[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T233075[ebp], al
	mov	cl, BYTE PTR __Cat$233079[ebp]
	mov	BYTE PTR $T233076[ebp], cl
	mov	dl, BYTE PTR $T233075[ebp]
	mov	BYTE PTR $T233054[ebp], dl
	mov	eax, DWORD PTR $T233071[ebp]
	mov	DWORD PTR $T233053[ebp], eax
	mov	ecx, DWORD PTR $T233053[ebp]
	mov	DWORD PTR $T233043[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T233042[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T233083[ebp], al
	mov	cl, BYTE PTR __Cat$233087[ebp]
	mov	BYTE PTR $T233084[ebp], cl
	movzx	edx, BYTE PTR $T233083[ebp]
	push	edx
	movzx	eax, BYTE PTR $T233084[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T233043[ebp]
	push	edx
	mov	eax, DWORD PTR $T233090[ebp]
	push	eax
	mov	ecx, DWORD PTR $T233042[ebp]
	push	ecx
	call	??$_Uninit_copy@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CityAndProduction *,CityAndProduction *,std::allocator<CityAndProduction> >
	add	esp, 24					; 00000018H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	sar	eax, 3
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, eax
	mov	DWORD PTR $T233117[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T233116[ebp], eax
	mov	ecx, DWORD PTR $T233116[ebp]
	mov	DWORD PTR $T233106[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T233111[ebp], dl
	mov	al, BYTE PTR __Cat$233115[ebp]
	mov	BYTE PTR $T233112[ebp], al
	movzx	ecx, BYTE PTR $T233111[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T233112[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$226565[ebp]
	push	ecx
	mov	edx, DWORD PTR $T233117[ebp]
	push	edx
	mov	eax, DWORD PTR $T233106[ebp]
	push	eax
	call	??$_Uninit_fill_n@PAUCityAndProduction@@IU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAXPAUCityAndProduction@@IABU1@AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CityAndProduction *,unsigned int,CityAndProduction,std::allocator<CityAndProduction> >
	add	esp, 24					; 00000018H
	jmp	SHORT $LN21@Insert_n
__catch$?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	DWORD PTR $T233178[ebp], ecx
	mov	edx, DWORD PTR $T233178[ebp]
	mov	DWORD PTR $T233160[ebp], edx
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR $T233159[ebp], edx
	mov	al, BYTE PTR __Cat$233167[ebp]
	mov	BYTE PTR $T233165[ebp], al
	mov	ecx, DWORD PTR $T233159[ebp]
	mov	DWORD PTR $T233143[ebp], ecx
	jmp	SHORT $LN160@Insert_n
$LN159@Insert_n:
	mov	edx, DWORD PTR $T233143[ebp]
	add	edx, 8
	mov	DWORD PTR $T233143[ebp], edx
$LN160@Insert_n:
	mov	eax, DWORD PTR $T233143[ebp]
	cmp	eax, DWORD PTR $T233160[ebp]
	je	SHORT $LN152@Insert_n
	jmp	SHORT $LN159@Insert_n
$LN152@Insert_n:

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z$3
	ret	0
$LN21@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, eax
	mov	DWORD PTR $T233194[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T233186[ebp], eax
	jmp	SHORT $LN171@Insert_n
$LN170@Insert_n:
	mov	ecx, DWORD PTR $T233186[ebp]
	add	ecx, 8
	mov	DWORD PTR $T233186[ebp], ecx
$LN171@Insert_n:
	mov	edx, DWORD PTR $T233186[ebp]
	cmp	edx, DWORD PTR $T233194[ebp]
	je	SHORT $LN167@Insert_n
	mov	eax, DWORD PTR __Tmp$226565[ebp]
	mov	ecx, DWORD PTR __Tmp$226565[ebp+4]
	mov	edx, DWORD PTR $T233186[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN170@Insert_n
$LN167@Insert_n:

; 1232 : 			}
; 1233 : 		else

	jmp	$LN16@Insert_n
$LN3@Insert_n:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$226575[ebp], ecx
	mov	DWORD PTR __Tmp$226575[ebp+4], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Oldend$226576[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T233266[ebp], eax
	mov	ecx, DWORD PTR $T233266[ebp]
	mov	DWORD PTR $T233247[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T233252[ebp], dl
	mov	al, BYTE PTR __Cat$233255[ebp]
	mov	BYTE PTR $T233253[ebp], al
	mov	cl, BYTE PTR $T233252[ebp]
	mov	BYTE PTR $T233230[ebp], cl
	mov	edx, DWORD PTR $T233247[ebp]
	mov	DWORD PTR $T233229[ebp], edx
	mov	eax, DWORD PTR $T233229[ebp]
	mov	DWORD PTR $T233219[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 3
	mov	edx, DWORD PTR __Oldend$226576[ebp]
	sub	edx, ecx
	mov	DWORD PTR $T233218[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T233260[ebp], al
	mov	cl, BYTE PTR __Cat$233263[ebp]
	mov	BYTE PTR $T233261[ebp], cl
	movzx	edx, BYTE PTR $T233260[ebp]
	push	edx
	movzx	eax, BYTE PTR $T233261[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T233219[ebp]
	push	edx
	mov	eax, DWORD PTR __Oldend$226576[ebp]
	push	eax
	mov	ecx, DWORD PTR $T233218[ebp]
	push	ecx
	call	??$_Uninit_copy@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CityAndProduction *,CityAndProduction *,std::allocator<CityAndProduction> >
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, DWORD PTR __Oldend$226576[ebp]
	mov	DWORD PTR $T233333[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T233332[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T233312[ebp], dl
	mov	al, BYTE PTR __Cat$233316[ebp]
	mov	BYTE PTR $T233313[ebp], al
	mov	cl, BYTE PTR $T233312[ebp]
	mov	BYTE PTR $T233309[ebp], cl
	mov	dl, BYTE PTR $T233314[ebp]
	mov	BYTE PTR $T233308[ebp], dl
	mov	eax, DWORD PTR $T233333[ebp]
	mov	DWORD PTR $T233307[ebp], eax
	mov	ecx, DWORD PTR $T233332[ebp]
	mov	DWORD PTR $T233306[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T233323[ebp], dl
	mov	al, BYTE PTR __Cat$233326[ebp]
	mov	BYTE PTR $T233324[ebp], al
	mov	cl, BYTE PTR $T233323[ebp]
	mov	BYTE PTR $T233294[ebp], cl
	mov	edx, DWORD PTR $T233307[ebp]
	mov	DWORD PTR $T233293[ebp], edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR __Oldend$226576[ebp]
	sub	ecx, eax
	mov	DWORD PTR $T233292[ebp], ecx
	mov	edx, DWORD PTR $T233306[ebp]
	mov	DWORD PTR $T233291[ebp], edx
$LN197@Insert_n:
	mov	eax, DWORD PTR $T233291[ebp]
	cmp	eax, DWORD PTR $T233292[ebp]
	je	SHORT $LN186@Insert_n
	mov	ecx, DWORD PTR $T233292[ebp]
	sub	ecx, 8
	mov	DWORD PTR $T233292[ebp], ecx
	mov	edx, DWORD PTR $T233293[ebp]
	sub	edx, 8
	mov	DWORD PTR $T233293[ebp], edx
	mov	eax, DWORD PTR $T233292[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T233293[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN197@Insert_n
$LN186@Insert_n:

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T233341[ebp], ecx
	jmp	SHORT $LN204@Insert_n
$LN203@Insert_n:
	mov	edx, DWORD PTR $T233341[ebp]
	add	edx, 8
	mov	DWORD PTR $T233341[ebp], edx
$LN204@Insert_n:
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	cmp	DWORD PTR $T233341[ebp], edx
	je	SHORT $LN16@Insert_n
	mov	eax, DWORD PTR __Tmp$226575[ebp]
	mov	ecx, DWORD PTR __Tmp$226575[ebp+4]
	mov	edx, DWORD PTR $T233341[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN203@Insert_n
$LN16@Insert_n:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-436]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@IABUCityAndProduction@@@Z ENDP ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Insert_n
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_Elength_error@std@@UAEPAXI@Z ; std::length_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_Elogic_error@std@@UAEPAXI@Z ; std::logic_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T233363 = -80						; size = 28
$T233362 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@KAXXZ PROC ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T233363[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T233362[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T233362[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T233363[ebp]
	push	eax
	lea	ecx, DWORD PTR $T233362[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T233362[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T233362[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T233363[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T233363[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T233362[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@KAXXZ ENDP ; std::vector<CityAndProduction,std::allocator<CityAndProduction> >::_Xlen
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 34   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 36   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@

; 110  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	edx, DWORD PTR ___flags$[ebp]
	and	edx, 1
	je	SHORT $LN1@scalar@2
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??$_Stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0PAHPAUCityAndProduction@@UCityAndProductionEval@@@Z ; std::_Stable_sort<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction,CityAndProductionEval>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0UCityAndProductionEval@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0UCityAndProductionEval@@@Z PROC ; std::stable_sort<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval>, COMDAT

; 3570 : 	{	// sort preserving order of equivalents, using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH

; 3571 : 	_DEBUG_RANGE(_First, _Last);
; 3572 : 	_DEBUG_POINTER(_Pred);
; 3573 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN2@stable_sor

; 3574 : 		{
; 3575 : 		_Stable_sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last),
; 3576 : 			_Dist_type(_First), _Val_type(_First), _Pred);

	movzx	ecx, BYTE PTR __Pred$[ebp]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0PAHPAUCityAndProduction@@UCityAndProductionEval@@@Z ; std::_Stable_sort<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction,CityAndProductionEval>
	add	esp, 20					; 00000014H
$LN2@stable_sor:

; 3577 : 		}
; 3578 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0UCityAndProductionEval@@@Z ENDP ; std::stable_sort<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R0?AVbad_alloc@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
xdata$x	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_Ebad_alloc@std@@UAEPAXI@Z ; std::bad_alloc::`vftable'
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
CONST	ENDS
;	COMDAT ??$_Allocate@UCityAndProduction@@@std@@YAPAUCityAndProduction@@IPAU1@@Z
_TEXT	SEGMENT
$T233594 = -16						; size = 4
$T233590 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UCityAndProduction@@@std@@YAPAUCityAndProduction@@IPAU1@@Z PROC ; std::_Allocate<CityAndProduction>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 8
	jae	SHORT $LN2@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T233594[ebp], 0
	lea	eax, DWORD PTR $T233594[ebp]
	push	eax
	lea	ecx, DWORD PTR $T233590[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T233590[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T233590[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 3
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@UCityAndProduction@@@std@@YAPAUCityAndProduction@@IPAU1@@Z ENDP ; std::_Allocate<CityAndProduction>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar@3
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$_Temp_iterator@UCityAndProduction@@@std@@QAE@XZ ; std::_Temp_iterator<CityAndProduction>::~_Temp_iterator<CityAndProduction>
PUBLIC	??$_Stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0HAAV?$_Temp_iterator@UCityAndProduction@@@0@UCityAndProductionEval@@@Z ; std::_Stable_sort<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction,CityAndProductionEval>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0PAHPAUCityAndProduction@@UCityAndProductionEval@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0PAHPAUCityAndProduction@@UCityAndProductionEval@@@Z$0
__ehfuncinfo$??$_Stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0PAHPAUCityAndProduction@@UCityAndProductionEval@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0PAHPAUCityAndProduction@@UCityAndProductionEval@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0PAHPAUCityAndProduction@@UCityAndProductionEval@@@Z
_TEXT	SEGMENT
$T233759 = -120						; size = 4
__Next$233767 = -116					; size = 4
$T233644 = -56						; size = 4
$T233640 = -52						; size = 4
$T233627 = -48						; size = 4
$T233626 = -44						; size = 4
__Tempbuf$ = -36					; size = 20
__Count$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0PAHPAUCityAndProduction@@UCityAndProductionEval@@@Z PROC ; std::_Stable_sort<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction,CityAndProductionEval>, COMDAT

; 3560 : 	{	// sort preserving order of equivalents, using _Pred

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0PAHPAUCityAndProduction@@UCityAndProductionEval@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 108				; 0000006cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 3561 : 	_Diff _Count = 0;

	mov	DWORD PTR __Count$[ebp], 0

; 3562 : 	_Distance(_First, _Last, _Count);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T233640[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T233627[ebp], ecx
	mov	edx, DWORD PTR $T233640[ebp]
	mov	DWORD PTR $T233626[ebp], edx
	mov	eax, DWORD PTR $T233627[ebp]
	sub	eax, DWORD PTR $T233626[ebp]
	sar	eax, 3
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 3563 : 	_Temp_iterator<_Ty> _Tempbuf((_Count + 1) / 2);

	mov	eax, DWORD PTR __Count$[ebp]
	add	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR $T233644[ebp], eax
	mov	DWORD PTR __Tempbuf$[ebp], 0
	mov	DWORD PTR __Tempbuf$[ebp+4], 0
	mov	DWORD PTR __Tempbuf$[ebp+8], 0
	mov	ecx, DWORD PTR $T233644[ebp]
	mov	DWORD PTR __Tempbuf$[ebp+12], ecx
	lea	edx, DWORD PTR __Tempbuf$[ebp]
	mov	DWORD PTR __Tempbuf$[ebp+16], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3564 : 	_Stable_sort(_First, _Last, _Count, _Tempbuf, _Pred);

	movzx	eax, BYTE PTR __Pred$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tempbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0HAAV?$_Temp_iterator@UCityAndProduction@@@0@UCityAndProductionEval@@@Z ; std::_Stable_sort<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction,CityAndProductionEval>
	add	esp, 20					; 00000014H

; 3565 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Tempbuf$[ebp], 0
	je	SHORT $LN1@Stable_sor
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	DWORD PTR __Next$233767[ebp], edx
	jmp	SHORT $LN74@Stable_sor
$LN73@Stable_sor:
	mov	eax, DWORD PTR __Next$233767[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$233767[ebp], eax
$LN74@Stable_sor:
	mov	ecx, DWORD PTR __Next$233767[ebp]
	cmp	ecx, DWORD PTR __Tempbuf$[ebp+8]
	je	SHORT $LN72@Stable_sor
	jmp	SHORT $LN73@Stable_sor
$LN72@Stable_sor:
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	DWORD PTR $T233759[ebp], edx
	mov	eax, DWORD PTR $T233759[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Stable_sor:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0PAHPAUCityAndProduction@@UCityAndProductionEval@@@Z$0:
	lea	ecx, DWORD PTR __Tempbuf$[ebp]
	jmp	??1?$_Temp_iterator@UCityAndProduction@@@std@@QAE@XZ ; std::_Temp_iterator<CityAndProduction>::~_Temp_iterator<CityAndProduction>
__ehhandler$??$_Stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0PAHPAUCityAndProduction@@UCityAndProductionEval@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-112]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0PAHPAUCityAndProduction@@UCityAndProductionEval@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0PAHPAUCityAndProduction@@UCityAndProductionEval@@@Z ENDP ; std::_Stable_sort<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction,CityAndProductionEval>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAUCityAndProduction@@IU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAXPAUCityAndProduction@@IABU1@AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAUCityAndProduction@@IU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAXPAUCityAndProduction@@IABU1@AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAUCityAndProduction@@IU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAXPAUCityAndProduction@@IABU1@AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAUCityAndProduction@@IU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAXPAUCityAndProduction@@IABU1@AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAUCityAndProduction@@IU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAXPAUCityAndProduction@@IABU1@AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_fill_n@PAUCityAndProduction@@IU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAXPAUCityAndProduction@@IABU1@AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAUCityAndProduction@@IU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAXPAUCityAndProduction@@IABU1@AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAUCityAndProduction@@IU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAXPAUCityAndProduction@@IABU1@AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUCityAndProduction@@IU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAXPAUCityAndProduction@@IABU1@AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv84 = -32						; size = 4
$T233801 = -28						; size = 4
__Vptr$233807 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAUCityAndProduction@@IU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAXPAUCityAndProduction@@IABU1@AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<CityAndProduction *,unsigned int,CityAndProduction,std::allocator<CityAndProduction> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAUCityAndProduction@@IU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAXPAUCityAndProduction@@IABU1@AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil
$LN5@Uninit_fil:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 8
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Vptr$233807[ebp], eax
	mov	ecx, DWORD PTR __Vptr$233807[ebp]
	mov	DWORD PTR $T233801[ebp], ecx
	cmp	DWORD PTR $T233801[ebp], 0
	je	SHORT $LN18@Uninit_fil
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T233801[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T233801[ebp]
	mov	DWORD PTR tv84[ebp], eax
	jmp	SHORT $LN14@Uninit_fil
$LN18@Uninit_fil:
	mov	DWORD PTR tv84[ebp], 0
$LN14@Uninit_fil:
	jmp	SHORT $LN5@Uninit_fil
$LN4@Uninit_fil:
	jmp	SHORT $LN10@Uninit_fil
__catch$??$_Uninit_fill_n@PAUCityAndProduction@@IU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAXPAUCityAndProduction@@IABU1@AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil
$LN2@Uninit_fil:
	mov	ecx, DWORD PTR __Next$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Next$[ebp], ecx
$LN3@Uninit_fil:
	mov	edx, DWORD PTR __Next$[ebp]
	cmp	edx, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil

; 407  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_fil
$LN1@Uninit_fil:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil
	ret	0
$LN10@Uninit_fil:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAUCityAndProduction@@IU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAXPAUCityAndProduction@@IABU1@AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAUCityAndProduction@@IU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAXPAUCityAndProduction@@IABU1@AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAUCityAndProduction@@IU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAXPAUCityAndProduction@@IABU1@AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CityAndProduction *,unsigned int,CityAndProduction,std::allocator<CityAndProduction> >
; Function compile flags: /Odtp
;	COMDAT ??1?$_Temp_iterator@UCityAndProduction@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T233834 = -8						; size = 4
__Next$227067 = -4					; size = 4
??1?$_Temp_iterator@UCityAndProduction@@@std@@QAE@XZ PROC ; std::_Temp_iterator<CityAndProduction>::~_Temp_iterator<CityAndProduction>, COMDAT
; _this$ = ecx

; 545  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 546  : 		if (_Buf._Begin != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@Temp_itera

; 547  : 			{	// destroy any constructed elements in buffer
; 548  : 			for (_Pty _Next = _Buf._Begin;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Next$227067[ebp], edx

; 549  : 				_Next != _Buf._Hiwater; ++_Next)

	jmp	SHORT $LN3@Temp_itera
$LN2@Temp_itera:
	mov	eax, DWORD PTR __Next$227067[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$227067[ebp], eax
$LN3@Temp_itera:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Next$227067[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN1@Temp_itera

; 550  : 				_Destroy(&*_Next);

	jmp	SHORT $LN2@Temp_itera
$LN1@Temp_itera:

; 551  : 			std::return_temporary_buffer(_Buf._Begin);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T233834[ebp], ecx
	mov	edx, DWORD PTR $T233834[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Temp_itera:

; 552  : 			}
; 553  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Temp_iterator@UCityAndProduction@@@std@@QAE@XZ ENDP ; std::_Temp_iterator<CityAndProduction>::~_Temp_iterator<CityAndProduction>
_TEXT	ENDS
PUBLIC	??$_Buffered_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@00HHAAV?$_Temp_iterator@UCityAndProduction@@@0@UCityAndProductionEval@@@Z ; std::_Buffered_merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction,CityAndProductionEval>
PUBLIC	??$_Buffered_merge_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0HAAV?$_Temp_iterator@UCityAndProduction@@@0@UCityAndProductionEval@@@Z ; std::_Buffered_merge_sort<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction,CityAndProductionEval>
PUBLIC	?_Maxlen@?$_Temp_iterator@UCityAndProduction@@@std@@QAEHXZ ; std::_Temp_iterator<CityAndProduction>::_Maxlen
PUBLIC	??$_Insertion_sort1@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@UCityAndProduction@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0UCityAndProductionEval@@PAUCityAndProduction@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval,CityAndProduction>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0HAAV?$_Temp_iterator@UCityAndProduction@@@0@UCityAndProductionEval@@@Z
_TEXT	SEGMENT
__Count2$227124 = -8					; size = 4
__Mid$227125 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0HAAV?$_Temp_iterator@UCityAndProduction@@@0@UCityAndProductionEval@@@Z PROC ; std::_Stable_sort<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction,CityAndProductionEval>, COMDAT

; 3529 : 	{	// sort preserving order of equivalents, using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 364				; 0000016cH

; 3530 : 	if (_Count <= _ISORT_MAX)

	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jg	SHORT $LN4@Stable_sor@2

; 3531 : 		std::_Insertion_sort(_First, _Last, _Pred);	// small

	push	0
	movzx	eax, BYTE PTR __Pred$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Insertion_sort1@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@UCityAndProduction@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0UCityAndProductionEval@@PAUCityAndProduction@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval,CityAndProduction>
	add	esp, 16					; 00000010H

; 3532 : 	else

	jmp	$LN5@Stable_sor@2
$LN4@Stable_sor@2:

; 3533 : 		{	// sort halves and merge
; 3534 : 		_Diff _Count2 = (_Count + 1) / 2;

	mov	eax, DWORD PTR __Count$[ebp]
	add	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2$227124[ebp], eax

; 3535 : 		_BidIt _Mid = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$227125[ebp], eax

; 3536 : 		std::advance(_Mid, _Count2);

	mov	ecx, DWORD PTR __Count2$227124[ebp]
	mov	edx, DWORD PTR __Mid$227125[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR __Mid$227125[ebp], eax

; 3537 : 
; 3538 : 		if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@UCityAndProduction@@@std@@QAEHXZ ; std::_Temp_iterator<CityAndProduction>::_Maxlen
	cmp	DWORD PTR __Count2$227124[ebp], eax
	jg	SHORT $LN2@Stable_sor@2

; 3539 : 			{	// temp buffer big enough, sort each half using buffer
; 3540 : 			_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);

	movzx	ecx, BYTE PTR __Pred$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count2$227124[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$227125[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Buffered_merge_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0HAAV?$_Temp_iterator@UCityAndProduction@@@0@UCityAndProductionEval@@@Z ; std::_Buffered_merge_sort<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction,CityAndProductionEval>
	add	esp, 20					; 00000014H

; 3541 : 			_Buffered_merge_sort(_Mid, _Last, _Count - _Count2,
; 3542 : 				_Tempbuf, _Pred);

	movzx	eax, BYTE PTR __Pred$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, DWORD PTR __Count2$227124[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$227125[ebp]
	push	ecx
	call	??$_Buffered_merge_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0HAAV?$_Temp_iterator@UCityAndProduction@@@0@UCityAndProductionEval@@@Z ; std::_Buffered_merge_sort<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction,CityAndProductionEval>
	add	esp, 20					; 00000014H

; 3543 : 			}
; 3544 : 		else

	jmp	SHORT $LN1@Stable_sor@2
$LN2@Stable_sor@2:

; 3545 : 			{	// temp buffer not big enough, divide and conquer
; 3546 : 			_Stable_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);

	movzx	edx, BYTE PTR __Pred$[ebp]
	push	edx
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count2$227124[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$227125[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0HAAV?$_Temp_iterator@UCityAndProduction@@@0@UCityAndProductionEval@@@Z ; std::_Stable_sort<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction,CityAndProductionEval>
	add	esp, 20					; 00000014H

; 3547 : 			_Stable_sort(_Mid, _Last, _Count - _Count2, _Tempbuf, _Pred);

	movzx	ecx, BYTE PTR __Pred$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, DWORD PTR __Count2$227124[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$227125[ebp]
	push	edx
	call	??$_Stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0HAAV?$_Temp_iterator@UCityAndProduction@@@0@UCityAndProductionEval@@@Z ; std::_Stable_sort<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction,CityAndProductionEval>
	add	esp, 20					; 00000014H
$LN1@Stable_sor@2:

; 3548 : 			}
; 3549 : 
; 3550 : 		_Buffered_merge(_First, _Mid, _Last,
; 3551 : 			_Count2, _Count - _Count2, _Tempbuf, _Pred);	// merge halves

	movzx	eax, BYTE PTR __Pred$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, DWORD PTR __Count2$227124[ebp]
	push	edx
	mov	eax, DWORD PTR __Count2$227124[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$227125[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Buffered_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@00HHAAV?$_Temp_iterator@UCityAndProduction@@@0@UCityAndProductionEval@@@Z ; std::_Buffered_merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction,CityAndProductionEval>
	add	esp, 28					; 0000001cH
$LN5@Stable_sor@2:

; 3552 : 		}
; 3553 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Stable_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0HAAV?$_Temp_iterator@UCityAndProduction@@@0@UCityAndProductionEval@@@Z ENDP ; std::_Stable_sort<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction,CityAndProductionEval>
_TEXT	ENDS
PUBLIC	??$get_temporary_buffer@UCityAndProduction@@@std@@YA?AU?$pair@PAUCityAndProduction@@H@0@H@Z ; std::get_temporary_buffer<CityAndProduction>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ?_Maxlen@?$_Temp_iterator@UCityAndProduction@@@std@@QAEHXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
__Pair$227212 = -8					; size = 8
?_Maxlen@?$_Temp_iterator@UCityAndProduction@@@std@@QAEHXZ PROC ; std::_Temp_iterator<CityAndProduction>::_Maxlen, COMDAT
; _this$ = ecx

; 607  : 		{	// return size of buffer

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 608  : 		if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN1@Maxlen
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	cmp	DWORD PTR [eax+12], 0
	jle	SHORT $LN1@Maxlen

; 609  : 			{	// allocate buffer on first size query
; 610  : 			pair<_Pty, _PDFT> _Pair =
; 611  : 				std::get_temporary_buffer<_Ty>(_Pbuf->_Size);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR __Pair$227212[ebp]
	push	ecx
	call	??$get_temporary_buffer@UCityAndProduction@@@std@@YA?AU?$pair@PAUCityAndProduction@@H@0@H@Z ; std::get_temporary_buffer<CityAndProduction>
	add	esp, 8

; 612  : 
; 613  : 			_Pbuf->_Begin = _Pair.first;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Pair$227212[ebp]
	mov	DWORD PTR [eax], ecx

; 614  : 			_Pbuf->_Current = _Pair.first;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Pair$227212[ebp]
	mov	DWORD PTR [eax+4], ecx

; 615  : 			_Pbuf->_Hiwater = _Pair.first;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Pair$227212[ebp]
	mov	DWORD PTR [eax+8], ecx

; 616  : 			_Pbuf->_Size = _Pair.second;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Pair$227212[ebp+4]
	mov	DWORD PTR [eax+12], ecx
$LN1@Maxlen:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	eax, DWORD PTR [eax+12]

; 619  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Maxlen@?$_Temp_iterator@UCityAndProduction@@@std@@QAEHXZ ENDP ; std::_Temp_iterator<CityAndProduction>::_Maxlen
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProductionEval@@@std@@YAXPAUCityAndProduction@@0V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@HHUCityAndProductionEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProductionEval>
PUBLIC	??$_Unchecked_chunked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@HUCityAndProductionEval@@@stdext@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@0V?$_Temp_iterator@UCityAndProduction@@@2@HHUCityAndProductionEval@@@Z ; stdext::_Unchecked_chunked_merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction>,int,CityAndProductionEval>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Buffered_merge_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0HAAV?$_Temp_iterator@UCityAndProduction@@@0@UCityAndProductionEval@@@Z
_TEXT	SEGMENT
tv144 = -216						; size = 4
$T234779 = -61						; size = 1
$T234449 = -60						; size = 4
$T234445 = -56						; size = 4
$T234408 = -32						; size = 4
$T234388 = -28						; size = 4
$T234345 = -20						; size = 4
__Chunk$227282 = -16					; size = 4
__Midn$227280 = -12					; size = 4
__Nleft$227276 = -8					; size = 4
__Mid$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Buffered_merge_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0HAAV?$_Temp_iterator@UCityAndProduction@@@0@UCityAndProductionEval@@@Z PROC ; std::_Buffered_merge_sort<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction,CityAndProductionEval>, COMDAT

; 3502 : 	{	// sort using temp buffer for merges, using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H

; 3503 : 	_BidIt _Mid = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$[ebp], eax

; 3504 : 	for (_Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX)

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Nleft$227276[ebp], ecx
	jmp	SHORT $LN6@Buffered_m
$LN5@Buffered_m:
	mov	edx, DWORD PTR __Nleft$227276[ebp]
	sub	edx, 32					; 00000020H
	mov	DWORD PTR __Nleft$227276[ebp], edx
$LN6@Buffered_m:
	cmp	DWORD PTR __Nleft$227276[ebp], 32	; 00000020H
	jl	SHORT $LN26@Buffered_m

; 3505 : 		{	// sort chunks
; 3506 : 		_BidIt _Midn = _Mid;

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Midn$227280[ebp], eax

; 3507 : 		std::advance(_Midn, (int)_ISORT_MAX);

	mov	ecx, 32					; 00000020H
	shl	ecx, 3
	add	ecx, DWORD PTR __Midn$227280[ebp]
	mov	DWORD PTR __Midn$227280[ebp], ecx

; 3508 : 
; 3509 : 		std::_Insertion_sort(_Mid, _Midn, _Pred);

	mov	edx, DWORD PTR __Midn$227280[ebp]
	mov	DWORD PTR $T234388[ebp], edx
	push	0
	movzx	eax, BYTE PTR __Pred$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234388[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	call	??$_Insertion_sort1@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@UCityAndProduction@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0UCityAndProductionEval@@PAUCityAndProduction@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval,CityAndProduction>
	add	esp, 16					; 00000010H

; 3510 : 		_Mid = _Midn;

	mov	eax, DWORD PTR __Midn$227280[ebp]
	mov	DWORD PTR __Mid$[ebp], eax

; 3511 : 		}

	jmp	SHORT $LN5@Buffered_m

; 3512 : 	std::_Insertion_sort(_Mid, _Last, _Pred);	// sort partial last chunk

$LN26@Buffered_m:
	push	0
	movzx	ecx, BYTE PTR __Pred$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	call	??$_Insertion_sort1@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@UCityAndProduction@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0UCityAndProductionEval@@PAUCityAndProduction@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval,CityAndProduction>
	add	esp, 16					; 00000010H

; 3513 : 
; 3514 : 	for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)

	mov	DWORD PTR __Chunk$227282[ebp], 32	; 00000020H
	jmp	SHORT $LN3@Buffered_m
$LN2@Buffered_m:
	mov	ecx, DWORD PTR __Chunk$227282[ebp]
	shl	ecx, 1
	mov	DWORD PTR __Chunk$227282[ebp], ecx
$LN3@Buffered_m:
	mov	edx, DWORD PTR __Chunk$227282[ebp]
	cmp	edx, DWORD PTR __Count$[ebp]
	jge	$LN7@Buffered_m

; 3515 : 		{	// merge adjacent pairs of chunks to and from temp buffer
; 3516 : 		_STDEXT _Unchecked_chunked_merge(_First, _Last, _Tempbuf._Init(),
; 3517 : 			_Chunk, _Count, _Pred);

	movzx	eax, BYTE PTR __Pred$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Chunk$227282[ebp]
	push	edx
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T234345[ebp], esp
	mov	DWORD PTR $T234408[ebp], edx
	mov	eax, DWORD PTR $T234408[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T234408[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T234408[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T234408[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T234408[ebp]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR $T234408[ebp]
	mov	DWORD PTR tv144[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_chunked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@HUCityAndProductionEval@@@stdext@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@0V?$_Temp_iterator@UCityAndProduction@@@2@HHUCityAndProductionEval@@@Z ; stdext::_Unchecked_chunked_merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction>,int,CityAndProductionEval>
	add	esp, 40					; 00000028H

; 3518 : 		_STDEXT _Unchecked_chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First,
; 3519 : 			_Chunk *= 2, _Count, _Pred);

	mov	ecx, DWORD PTR __Chunk$227282[ebp]
	shl	ecx, 1
	mov	DWORD PTR __Chunk$227282[ebp], ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T234445[ebp], ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T234449[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T234779[ebp], dl
	movzx	eax, BYTE PTR $T234779[ebp]
	push	eax
	movzx	ecx, BYTE PTR __Pred$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Chunk$227282[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T234445[ebp]
	push	edx
	mov	eax, DWORD PTR $T234449[ebp]
	push	eax
	call	??$_Chunked_merge@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProductionEval@@@std@@YAXPAUCityAndProduction@@0V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@HHUCityAndProductionEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProductionEval>
	add	esp, 28					; 0000001cH

; 3520 : 		}

	jmp	$LN2@Buffered_m
$LN7@Buffered_m:

; 3521 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Buffered_merge_sort@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0HAAV?$_Temp_iterator@UCityAndProduction@@@0@UCityAndProductionEval@@@Z ENDP ; std::_Buffered_merge_sort<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction,CityAndProductionEval>
_TEXT	ENDS
PUBLIC	??$_Buffered_rotate@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@00HHAAV?$_Temp_iterator@UCityAndProduction@@@0@@Z ; std::_Buffered_rotate<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction>
PUBLIC	??$_Upper_bound@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProduction@@HUCityAndProductionEval@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@0ABUCityAndProduction@@UCityAndProductionEval@@PAH@Z ; std::_Upper_bound<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProduction,int,CityAndProductionEval>
PUBLIC	??$_Lower_bound@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProduction@@HUCityAndProductionEval@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@0ABUCityAndProduction@@UCityAndProductionEval@@PAH@Z ; std::_Lower_bound<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProduction,int,CityAndProductionEval>
PUBLIC	??$_Merge_backward@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@PAUCityAndProduction@@V12@UCityAndProductionEval@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@0PAUCityAndProduction@@10UCityAndProductionEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval>
PUBLIC	??$_Merge@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V23@UCityAndProductionEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@PAUCityAndProduction@@0V10@11UCityAndProductionEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval,std::random_access_iterator_tag>
PUBLIC	??$unchecked_copy@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction> >
; Function compile flags: /Odtp
;	COMDAT ??$_Buffered_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@00HHAAV?$_Temp_iterator@UCityAndProduction@@@0@UCityAndProductionEval@@@Z
_TEXT	SEGMENT
tv244 = -344						; size = 4
tv243 = -340						; size = 4
tv240 = -336						; size = 4
tv239 = -332						; size = 4
$T235157 = -272						; size = 4
$T235144 = -268						; size = 4
$T235143 = -264						; size = 4
$T235121 = -257						; size = 1
$T235120 = -256						; size = 4
$T235119 = -252						; size = 4
$T235116 = -248						; size = 4
$T235108 = -244						; size = 4
$T235066 = -236						; size = 4
$T235053 = -232						; size = 4
$T235052 = -228						; size = 4
$T235030 = -221						; size = 1
$T235029 = -220						; size = 4
$T235026 = -216						; size = 4
$T235018 = -212						; size = 4
$T234960 = -205						; size = 1
$T234959 = -204						; size = 4
$T234958 = -200						; size = 4
$T234957 = -193						; size = 1
$T234952 = -192						; size = 4
$T234948 = -188						; size = 4
$T234933 = -184						; size = 4
__Next$234941 = -180					; size = 4
$T234925 = -176						; size = 4
$T234912 = -161						; size = 1
$T234911 = -160						; size = 4
$T234910 = -156						; size = 4
$T234909 = -152						; size = 4
$T234905 = -146						; size = 1
$T234904 = -145						; size = 1
$T234894 = -144						; size = 4
$T234890 = -140						; size = 4
$T234875 = -136						; size = 4
__Next$234883 = -132					; size = 4
$T234867 = -128						; size = 4
$T234854 = -116						; size = 4
$T234853 = -112						; size = 4
$T234838 = -108						; size = 4
__Tmp$234852 = -104					; size = 8
$T234824 = -96						; size = 4
$T234811 = -92						; size = 4
$T234802 = -88						; size = 4
$T234789 = -84						; size = 4
$T234788 = -80						; size = 4
$T234787 = -76						; size = 4
$T234786 = -72						; size = 20
$T234785 = -52						; size = 4
$T234784 = -48						; size = 4
$T234783 = -44						; size = 20
$T234782 = -24						; size = 4
__Firstn$227362 = -20					; size = 4
__Count2n$227365 = -16					; size = 4
__Midn$227388 = -12					; size = 4
__Lastn$227363 = -8					; size = 4
__Count1n$227364 = -4					; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Count1$ = 20						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
__Pred$ = 32						; size = 1
??$_Buffered_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@00HHAAV?$_Temp_iterator@UCityAndProduction@@@0@UCityAndProductionEval@@@Z PROC ; std::_Buffered_merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction,CityAndProductionEval>, COMDAT

; 2889 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 344				; 00000158H

; 2890 : 	if (_Count1 + _Count2 == 2)

	mov	eax, DWORD PTR __Count1$[ebp]
	add	eax, DWORD PTR __Count2$[ebp]
	cmp	eax, 2
	jne	SHORT $LN9@Buffered_m@2

; 2891 : 		{	// order two one-element partitions
; 2892 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T234802[ebp], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T234811[ebp], edx
	mov	eax, DWORD PTR $T234811[ebp]
	mov	ecx, DWORD PTR $T234802[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN8@Buffered_m@2

; 2893 : 			std::iter_swap(_First, _Mid);

	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T234854[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T234853[ebp], eax
	mov	ecx, DWORD PTR $T234854[ebp]
	mov	DWORD PTR $T234824[ebp], ecx
	mov	edx, DWORD PTR $T234853[ebp]
	mov	DWORD PTR $T234838[ebp], edx
	mov	eax, DWORD PTR $T234838[ebp]
	cmp	eax, DWORD PTR $T234824[ebp]
	je	SHORT $LN8@Buffered_m@2
	mov	ecx, DWORD PTR $T234838[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$234852[ebp], edx
	mov	DWORD PTR __Tmp$234852[ebp+4], eax
	mov	ecx, DWORD PTR $T234824[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T234838[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T234824[ebp]
	mov	eax, DWORD PTR __Tmp$234852[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$234852[ebp+4]
	mov	DWORD PTR [edx+4], ecx
$LN8@Buffered_m@2:

; 2894 : 		}

	jmp	$LN10@Buffered_m@2
$LN9@Buffered_m@2:

; 2895 : 	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	mov	edx, DWORD PTR __Count1$[ebp]
	cmp	edx, DWORD PTR __Count2$[ebp]
	jg	$LN6@Buffered_m@2
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@UCityAndProduction@@@std@@QAEHXZ ; std::_Temp_iterator<CityAndProduction>::_Maxlen
	cmp	DWORD PTR __Count1$[ebp], eax
	jg	$LN6@Buffered_m@2

; 2896 : 		{	// buffer left partition, then merge
; 2897 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T234782[ebp], esp
	mov	DWORD PTR $T234867[ebp], edx
	mov	eax, DWORD PTR $T234867[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T234867[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T234867[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T234867[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T234867[ebp]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR $T234867[ebp]
	mov	DWORD PTR tv239[ebp], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T234783[ebp]
	push	ecx
	call	??$unchecked_copy@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv240[ebp], eax
	cmp	DWORD PTR $T234783[ebp], 0
	je	SHORT $LN52@Buffered_m@2
	mov	edx, DWORD PTR $T234783[ebp]
	mov	DWORD PTR __Next$234883[ebp], edx
	jmp	SHORT $LN50@Buffered_m@2
$LN49@Buffered_m@2:
	mov	eax, DWORD PTR __Next$234883[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$234883[ebp], eax
$LN50@Buffered_m@2:
	mov	ecx, DWORD PTR __Next$234883[ebp]
	cmp	ecx, DWORD PTR $T234783[ebp+8]
	je	SHORT $LN48@Buffered_m@2
	jmp	SHORT $LN49@Buffered_m@2
$LN48@Buffered_m@2:
	mov	edx, DWORD PTR $T234783[ebp]
	mov	DWORD PTR $T234875[ebp], edx
	mov	eax, DWORD PTR $T234875[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN52@Buffered_m@2:

; 2898 : 		_STDEXT unchecked_merge(_Tempbuf._First(), _Tempbuf._Last(),
; 2899 : 			_Mid, _Last, _First, _Pred);

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T234890[ebp], eax
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T234894[ebp], eax
	mov	cl, BYTE PTR __Pred$[ebp]
	mov	BYTE PTR $T234912[ebp], cl
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T234911[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T234910[ebp], eax
	mov	ecx, DWORD PTR $T234894[ebp]
	mov	DWORD PTR $T234909[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T234904[ebp], dl
	movzx	eax, BYTE PTR $T234904[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T234905[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T234912[ebp]
	push	edx
	mov	eax, DWORD PTR $T234911[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T234910[ebp]
	push	edx
	mov	eax, DWORD PTR $T234890[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234909[ebp]
	push	ecx
	lea	edx, DWORD PTR $T234784[ebp]
	push	edx
	call	??$_Merge@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V23@UCityAndProductionEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@PAUCityAndProduction@@0V10@11UCityAndProductionEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval,std::random_access_iterator_tag>
	add	esp, 36					; 00000024H

; 2900 : 		}
; 2901 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	jmp	$LN10@Buffered_m@2
$LN6@Buffered_m@2:
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@UCityAndProduction@@@std@@QAEHXZ ; std::_Temp_iterator<CityAndProduction>::_Maxlen
	cmp	DWORD PTR __Count2$[ebp], eax
	jg	$LN4@Buffered_m@2

; 2902 : 		{	// buffer right partition, then merge
; 2903 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T234785[ebp], esp
	mov	DWORD PTR $T234925[ebp], edx
	mov	eax, DWORD PTR $T234925[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T234925[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T234925[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T234925[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T234925[ebp]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR $T234925[ebp]
	mov	DWORD PTR tv243[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T234786[ebp]
	push	ecx
	call	??$unchecked_copy@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv244[ebp], eax
	cmp	DWORD PTR $T234786[ebp], 0
	je	SHORT $LN79@Buffered_m@2
	mov	edx, DWORD PTR $T234786[ebp]
	mov	DWORD PTR __Next$234941[ebp], edx
	jmp	SHORT $LN77@Buffered_m@2
$LN76@Buffered_m@2:
	mov	eax, DWORD PTR __Next$234941[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$234941[ebp], eax
$LN77@Buffered_m@2:
	mov	ecx, DWORD PTR __Next$234941[ebp]
	cmp	ecx, DWORD PTR $T234786[ebp+8]
	je	SHORT $LN75@Buffered_m@2
	jmp	SHORT $LN76@Buffered_m@2
$LN75@Buffered_m@2:
	mov	edx, DWORD PTR $T234786[ebp]
	mov	DWORD PTR $T234933[ebp], edx
	mov	eax, DWORD PTR $T234933[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN79@Buffered_m@2:

; 2904 : 		_STDEXT _Unchecked_merge_backward(_First, _Mid, _Tempbuf._First(), _Tempbuf._Last(),
; 2905 : 			_Last, _Pred);

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T234948[ebp], eax
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T234952[ebp], eax
	mov	cl, BYTE PTR __Pred$[ebp]
	mov	BYTE PTR $T234960[ebp], cl
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T234959[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T234958[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T234957[ebp], cl
	movzx	edx, BYTE PTR $T234957[ebp]
	push	edx
	movzx	eax, BYTE PTR $T234960[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T234948[ebp]
	push	edx
	mov	eax, DWORD PTR $T234952[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234959[ebp]
	push	ecx
	mov	edx, DWORD PTR $T234958[ebp]
	push	edx
	lea	eax, DWORD PTR $T234787[ebp]
	push	eax
	call	??$_Merge_backward@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@PAUCityAndProduction@@V12@UCityAndProductionEval@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@0PAUCityAndProduction@@10UCityAndProductionEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval>
	add	esp, 32					; 00000020H

; 2906 : 		}
; 2907 : 	else

	jmp	$LN10@Buffered_m@2
$LN4@Buffered_m@2:

; 2908 : 		{	// buffer too small, divide and conquer
; 2909 : 		_BidIt _Firstn, _Lastn;

	mov	DWORD PTR __Firstn$227362[ebp], 0
	mov	DWORD PTR __Lastn$227363[ebp], 0

; 2910 : 		_Diff _Count1n, _Count2n;
; 2911 : 		if (_Count2 < _Count1)

	mov	ecx, DWORD PTR __Count2$[ebp]
	cmp	ecx, DWORD PTR __Count1$[ebp]
	jge	$LN2@Buffered_m@2

; 2912 : 			{	// left larger, cut it in half and partition right to match
; 2913 : 			_Count1n = _Count1 / 2, _Count2n = 0;

	mov	eax, DWORD PTR __Count1$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count1n$227364[ebp], eax
	mov	DWORD PTR __Count2n$227365[ebp], 0

; 2914 : 			_Firstn = _First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Firstn$227362[ebp], edx

; 2915 : 			std::advance(_Firstn, _Count1n);

	mov	eax, DWORD PTR __Count1n$227364[ebp]
	mov	ecx, DWORD PTR __Firstn$227362[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Firstn$227362[ebp], edx

; 2916 : 			_Lastn = lower_bound(_Mid, _Last, *_Firstn, _Pred);

	mov	eax, DWORD PTR __Firstn$227362[ebp]
	mov	DWORD PTR $T235018[ebp], eax
	mov	cl, BYTE PTR __Pred$[ebp]
	mov	BYTE PTR $T235030[ebp], cl
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T235029[ebp], edx
	push	0
	movzx	eax, BYTE PTR $T235030[ebp]
	push	eax
	mov	ecx, DWORD PTR $T235018[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR $T235029[ebp]
	push	eax
	lea	ecx, DWORD PTR $T235026[ebp]
	push	ecx
	call	??$_Lower_bound@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProduction@@HUCityAndProductionEval@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@0ABUCityAndProduction@@UCityAndProductionEval@@PAH@Z ; std::_Lower_bound<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProduction,int,CityAndProductionEval>
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T235029[ebp], edx
	mov	eax, DWORD PTR $T235029[ebp]
	mov	DWORD PTR $T234788[ebp], eax
	mov	ecx, DWORD PTR $T234788[ebp]
	mov	DWORD PTR __Lastn$227363[ebp], ecx

; 2917 : 			_Distance(_Mid, _Lastn, _Count2n);

	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T235066[ebp], edx
	mov	eax, DWORD PTR __Lastn$227363[ebp]
	mov	DWORD PTR $T235053[ebp], eax
	mov	ecx, DWORD PTR $T235066[ebp]
	mov	DWORD PTR $T235052[ebp], ecx
	mov	edx, DWORD PTR $T235053[ebp]
	sub	edx, DWORD PTR $T235052[ebp]
	sar	edx, 3
	add	edx, DWORD PTR __Count2n$227365[ebp]
	mov	DWORD PTR __Count2n$227365[ebp], edx

; 2918 : 			}
; 2919 : 		else

	jmp	$LN1@Buffered_m@2
$LN2@Buffered_m@2:

; 2920 : 			{	// right larger, cut it in half and partition left to match
; 2921 : 			_Count1n = 0, _Count2n = _Count2 / 2;

	mov	DWORD PTR __Count1n$227364[ebp], 0
	mov	eax, DWORD PTR __Count2$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2n$227365[ebp], eax

; 2922 : 			_Lastn = _Mid;

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Lastn$227363[ebp], eax

; 2923 : 			std::advance(_Lastn, _Count2n);

	mov	ecx, DWORD PTR __Count2n$227365[ebp]
	mov	edx, DWORD PTR __Lastn$227363[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR __Lastn$227363[ebp], eax

; 2924 : 			_Firstn = upper_bound(_First, _Mid, *_Lastn, _Pred);

	mov	ecx, DWORD PTR __Lastn$227363[ebp]
	mov	DWORD PTR $T235108[ebp], ecx
	mov	dl, BYTE PTR __Pred$[ebp]
	mov	BYTE PTR $T235121[ebp], dl
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T235120[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T235119[ebp], ecx
	push	0
	movzx	edx, BYTE PTR $T235121[ebp]
	push	edx
	mov	eax, DWORD PTR $T235108[ebp]
	push	eax
	mov	ecx, DWORD PTR $T235120[ebp]
	push	ecx
	mov	edx, DWORD PTR $T235119[ebp]
	push	edx
	lea	eax, DWORD PTR $T235116[ebp]
	push	eax
	call	??$_Upper_bound@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProduction@@HUCityAndProductionEval@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@0ABUCityAndProduction@@UCityAndProductionEval@@PAH@Z ; std::_Upper_bound<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProduction,int,CityAndProductionEval>
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T235119[ebp], ecx
	mov	edx, DWORD PTR $T235119[ebp]
	mov	DWORD PTR $T234789[ebp], edx
	mov	eax, DWORD PTR $T234789[ebp]
	mov	DWORD PTR __Firstn$227362[ebp], eax

; 2925 : 			_Distance(_First, _Firstn, _Count1n);

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T235157[ebp], ecx
	mov	edx, DWORD PTR __Firstn$227362[ebp]
	mov	DWORD PTR $T235144[ebp], edx
	mov	eax, DWORD PTR $T235157[ebp]
	mov	DWORD PTR $T235143[ebp], eax
	mov	ecx, DWORD PTR $T235144[ebp]
	sub	ecx, DWORD PTR $T235143[ebp]
	sar	ecx, 3
	add	ecx, DWORD PTR __Count1n$227364[ebp]
	mov	DWORD PTR __Count1n$227364[ebp], ecx
$LN1@Buffered_m@2:

; 2926 : 			}
; 2927 : 		_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
; 2928 : 			_Count1 - _Count1n, _Count2n, _Tempbuf);	// rearrange middle

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count2n$227365[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count1$[ebp]
	sub	ecx, DWORD PTR __Count1n$227364[ebp]
	push	ecx
	mov	edx, DWORD PTR __Lastn$227363[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Firstn$227362[ebp]
	push	ecx
	lea	edx, DWORD PTR __Midn$227388[ebp]
	push	edx
	call	??$_Buffered_rotate@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@00HHAAV?$_Temp_iterator@UCityAndProduction@@@0@@Z ; std::_Buffered_rotate<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction>
	add	esp, 28					; 0000001cH

; 2929 : 		_Buffered_merge(_First, _Firstn, _Midn,
; 2930 : 			_Count1n, _Count2n, _Tempbuf, _Pred);	// merge each new part

	movzx	eax, BYTE PTR __Pred$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count2n$227365[ebp]
	push	edx
	mov	eax, DWORD PTR __Count1n$227364[ebp]
	push	eax
	mov	ecx, DWORD PTR __Midn$227388[ebp]
	push	ecx
	mov	edx, DWORD PTR __Firstn$227362[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Buffered_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@00HHAAV?$_Temp_iterator@UCityAndProduction@@@0@UCityAndProductionEval@@@Z ; std::_Buffered_merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction,CityAndProductionEval>
	add	esp, 28					; 0000001cH

; 2931 : 		_Buffered_merge(_Midn, _Lastn, _Last,
; 2932 : 			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf, _Pred);

	movzx	ecx, BYTE PTR __Pred$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count2$[ebp]
	sub	eax, DWORD PTR __Count2n$227365[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count1$[ebp]
	sub	ecx, DWORD PTR __Count1n$227364[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Lastn$227363[ebp]
	push	eax
	mov	ecx, DWORD PTR __Midn$227388[ebp]
	push	ecx
	call	??$_Buffered_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@00HHAAV?$_Temp_iterator@UCityAndProduction@@@0@UCityAndProductionEval@@@Z ; std::_Buffered_merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction,CityAndProductionEval>
	add	esp, 28					; 0000001cH
$LN10@Buffered_m@2:

; 2933 : 		}
; 2934 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Buffered_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@UCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@00HHAAV?$_Temp_iterator@UCityAndProduction@@@0@UCityAndProductionEval@@@Z ENDP ; std::_Buffered_merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction,CityAndProductionEval>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@stdext@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@std@@@Z
_TEXT	SEGMENT
__Cat$235175 = -3					; size = 1
$T235172 = -2						; size = 1
$T235171 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@stdext@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<CityAndProduction *,CityAndProduction *,std::allocator<CityAndProduction> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T235171[ebp], al
	mov	cl, BYTE PTR __Cat$235175[ebp]
	mov	BYTE PTR $T235172[ebp], cl
	movzx	edx, BYTE PTR $T235171[ebp]
	push	edx
	movzx	eax, BYTE PTR $T235172[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninit_copy@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CityAndProduction *,CityAndProduction *,std::allocator<CityAndProduction> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@stdext@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<CityAndProduction *,CityAndProduction *,std::allocator<CityAndProduction> >
_TEXT	ENDS
EXTRN	??2@YAPAXIABUnothrow_t@std@@@Z:PROC		; operator new
EXTRN	?nothrow@std@@3Unothrow_t@1@B:BYTE		; std::nothrow
; Function compile flags: /Odtp
;	COMDAT ??$get_temporary_buffer@UCityAndProduction@@@std@@YA?AU?$pair@PAUCityAndProduction@@H@0@H@Z
_TEXT	SEGMENT
$T235183 = -20						; size = 4
$T235179 = -16						; size = 12
__Pbuf$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Count$ = 12						; size = 4
??$get_temporary_buffer@UCityAndProduction@@@std@@YA?AU?$pair@PAUCityAndProduction@@H@0@H@Z PROC ; std::get_temporary_buffer<CityAndProduction>, COMDAT

; 19   : 	{	// get raw temporary buffer of up to _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 20   : 	_Ty _FARQ *_Pbuf;
; 21   : 
; 22   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jg	SHORT $LN7@get_tempor

; 23   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN6@get_tempor
$LN7@get_tempor:

; 24   : 	else if (((size_t)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 8
	jae	SHORT $LN6@get_tempor

; 25   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T235183[ebp], 0
	lea	eax, DWORD PTR $T235183[ebp]
	push	eax
	lea	ecx, DWORD PTR $T235179[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T235179[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T235179[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN6@get_tempor:

; 26   : 
; 27   : 	for (_Pbuf = 0; 0 < _Count; _Count /= 2)

	mov	DWORD PTR __Pbuf$[ebp], 0
	jmp	SHORT $LN4@get_tempor
$LN3@get_tempor:
	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
$LN4@get_tempor:
	cmp	DWORD PTR __Count$[ebp], 0
	jle	SHORT $LN2@get_tempor

; 28   : 		if ((_Pbuf = (_Ty _FARQ *)operator new(
; 29   : 			(_SIZT)_Count * sizeof (_Ty), nothrow)) != 0)

	push	OFFSET ?nothrow@std@@3Unothrow_t@1@B	; std::nothrow
	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 3
	push	edx
	call	??2@YAPAXIABUnothrow_t@std@@@Z		; operator new
	add	esp, 8
	mov	DWORD PTR __Pbuf$[ebp], eax
	cmp	DWORD PTR __Pbuf$[ebp], 0
	je	SHORT $LN1@get_tempor

; 30   : 			break;

	jmp	SHORT $LN2@get_tempor
$LN1@get_tempor:

; 31   : 
; 32   : 	return (pair<_Ty _FARQ *, _PDFT>(_Pbuf, _Count));

	jmp	SHORT $LN3@get_tempor
$LN2@get_tempor:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Pbuf$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN9@get_tempor:

; 33   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$get_temporary_buffer@UCityAndProduction@@@std@@YA?AU?$pair@PAUCityAndProduction@@H@0@H@Z ENDP ; std::get_temporary_buffer<CityAndProduction>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
_TEXT	ENDS
;	COMDAT ??$_Insertion_sort1@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@UCityAndProduction@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0UCityAndProductionEval@@PAUCityAndProduction@@@Z
_TEXT	SEGMENT
$T235399 = -76						; size = 4
$T235387 = -72						; size = 4
$T235362 = -68						; size = 4
$T235361 = -64						; size = 4
$T235360 = -60						; size = 4
$T235324 = -54						; size = 1
$T235323 = -53						; size = 1
$T235322 = -52						; size = 4
$T235321 = -48						; size = 4
$T235320 = -44						; size = 4
$T235279 = -40						; size = 4
__Cat$235332 = -32					; size = 1
$T235329 = -31						; size = 1
$T235328 = -30						; size = 1
$T235327 = -29						; size = 1
$T235230 = -28						; size = 4
$T235189 = -24						; size = 4
__First1$227490 = -20					; size = 4
__Val$227479 = -16					; size = 8
__Next1$227478 = -8					; size = 4
__Next$227474 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
___formal$ = 20						; size = 4
??$_Insertion_sort1@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@UCityAndProduction@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0UCityAndProductionEval@@PAUCityAndProduction@@@Z PROC ; std::_Insertion_sort1<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval,CityAndProduction>, COMDAT

; 3123 : 	{	// insertion sort [_First, _Last), using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH

; 3124 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	$LN9@Insertion_

; 3125 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$227474[ebp], ecx
$LN7@Insertion_:
	mov	edx, DWORD PTR __Next$227474[ebp]
	add	edx, 8
	mov	DWORD PTR __Next$227474[ebp], edx
	mov	eax, DWORD PTR __Next$227474[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	$LN9@Insertion_

; 3126 : 			{	// order next element
; 3127 : 			_BidIt _Next1 = _Next;

	mov	ecx, DWORD PTR __Next$227474[ebp]
	mov	DWORD PTR __Next1$227478[ebp], ecx

; 3128 : 			_Ty _Val = *_Next;

	mov	edx, DWORD PTR __Next$227474[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Val$227479[ebp], eax
	mov	DWORD PTR __Val$227479[ebp+4], ecx

; 3129 : 
; 3130 : 			if (_DEBUG_LT_PRED(_Pred, _Val, *_First))

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T235230[ebp], edx
	mov	eax, DWORD PTR $T235230[ebp]
	mov	ecx, DWORD PTR __Val$227479[ebp+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	$LN5@Insertion_

; 3131 : 				{	// found new earliest element, move to front
; 3132 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	ecx, DWORD PTR __Next1$227478[ebp]
	add	ecx, 8
	mov	DWORD PTR __Next1$227478[ebp], ecx
	mov	edx, DWORD PTR __Next1$227478[ebp]
	mov	DWORD PTR $T235362[ebp], edx
	mov	eax, DWORD PTR __Next$227474[ebp]
	mov	DWORD PTR $T235361[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T235360[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T235327[ebp], dl
	mov	al, BYTE PTR __Cat$235332[ebp]
	mov	BYTE PTR $T235328[ebp], al
	mov	cl, BYTE PTR $T235327[ebp]
	mov	BYTE PTR $T235324[ebp], cl
	mov	dl, BYTE PTR $T235329[ebp]
	mov	BYTE PTR $T235323[ebp], dl
	mov	eax, DWORD PTR $T235362[ebp]
	mov	DWORD PTR $T235322[ebp], eax
	mov	ecx, DWORD PTR $T235361[ebp]
	mov	DWORD PTR $T235321[ebp], ecx
	mov	edx, DWORD PTR $T235360[ebp]
	mov	DWORD PTR $T235320[ebp], edx
$LN47@Insertion_:
	mov	eax, DWORD PTR $T235320[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T235321[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN43@Insertion_
	mov	ecx, DWORD PTR $T235321[ebp]
	sub	ecx, 8
	mov	DWORD PTR $T235321[ebp], ecx
	mov	edx, DWORD PTR $T235321[ebp]
	mov	DWORD PTR $T235279[ebp], edx
	mov	eax, DWORD PTR $T235322[ebp]
	sub	eax, 8
	mov	DWORD PTR $T235322[ebp], eax
	mov	ecx, DWORD PTR $T235279[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T235322[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN47@Insertion_
$LN43@Insertion_:
	mov	edx, DWORD PTR $T235322[ebp]
	mov	DWORD PTR $T235189[ebp], edx

; 3133 : 				*_First = _Val;

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Val$227479[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Val$227479[ebp+4]
	mov	DWORD PTR [eax+4], edx

; 3134 : 				}
; 3135 : 			else

	jmp	SHORT $LN4@Insertion_
$LN5@Insertion_:

; 3136 : 				{	// look for insertion point after first
; 3137 : 				for (_BidIt _First1 = _Next1;

	mov	eax, DWORD PTR __Next1$227478[ebp]
	mov	DWORD PTR __First1$227490[ebp], eax

; 3138 : 					_DEBUG_LT_PRED(_Pred, _Val, *--_First1);
; 3139 : 					_Next1 = _First1)

	jmp	SHORT $LN3@Insertion_
$LN2@Insertion_:
	mov	ecx, DWORD PTR __First1$227490[ebp]
	mov	DWORD PTR __Next1$227478[ebp], ecx
$LN3@Insertion_:
	mov	edx, DWORD PTR __First1$227490[ebp]
	sub	edx, 8
	mov	DWORD PTR __First1$227490[ebp], edx
	mov	eax, DWORD PTR __First1$227490[ebp]
	mov	DWORD PTR $T235387[ebp], eax
	mov	ecx, DWORD PTR $T235387[ebp]
	mov	edx, DWORD PTR __Val$227479[ebp+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN89@Insertion_

; 3140 : 					*_Next1 = *_First1;	// move hole down

	mov	edx, DWORD PTR __First1$227490[ebp]
	mov	DWORD PTR $T235399[ebp], edx
	mov	eax, DWORD PTR $T235399[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Next1$227478[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN2@Insertion_

; 3141 : 				*_Next1 = _Val;	// insert element in hole

$LN89@Insertion_:
	mov	ecx, DWORD PTR __Next1$227478[ebp]
	mov	edx, DWORD PTR __Val$227479[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Val$227479[ebp+4]
	mov	DWORD PTR [ecx+4], eax
$LN4@Insertion_:

; 3142 : 				}
; 3143 : 			}

	jmp	$LN7@Insertion_
$LN9@Insertion_:

; 3144 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Insertion_sort1@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@UCityAndProduction@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0UCityAndProductionEval@@PAUCityAndProduction@@@Z ENDP ; std::_Insertion_sort1<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval,CityAndProduction>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@HUCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0V?$_Temp_iterator@UCityAndProduction@@@0@HHUCityAndProductionEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction>,int,CityAndProductionEval>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Unchecked_chunked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@HUCityAndProductionEval@@@stdext@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@0V?$_Temp_iterator@UCityAndProduction@@@2@HHUCityAndProductionEval@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Unchecked_chunked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@HUCityAndProductionEval@@@stdext@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@0V?$_Temp_iterator@UCityAndProduction@@@2@HHUCityAndProductionEval@@@Z$0
__ehfuncinfo$??$_Unchecked_chunked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@HUCityAndProductionEval@@@stdext@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@0V?$_Temp_iterator@UCityAndProduction@@@2@HHUCityAndProductionEval@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Unchecked_chunked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@HUCityAndProductionEval@@@stdext@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@0V?$_Temp_iterator@UCityAndProduction@@@2@HHUCityAndProductionEval@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Unchecked_chunked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@HUCityAndProductionEval@@@stdext@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@0V?$_Temp_iterator@UCityAndProduction@@@2@HHUCityAndProductionEval@@@Z
_TEXT	SEGMENT
tv94 = -160						; size = 4
$T235611 = -156						; size = 4
__Next$235619 = -152					; size = 4
$T235430 = -24						; size = 4
$T235419 = -20						; size = 4
$T235418 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
__Count$ = 40						; size = 4
__Pred$ = 44						; size = 1
??$_Unchecked_chunked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@HUCityAndProductionEval@@@stdext@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@0V?$_Temp_iterator@UCityAndProduction@@@2@HHUCityAndProductionEval@@@Z PROC ; stdext::_Unchecked_chunked_merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction>,int,CityAndProductionEval>, COMDAT

; 5285 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Unchecked_chunked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@HUCityAndProductionEval@@@stdext@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@0V?$_Temp_iterator@UCityAndProduction@@@2@HHUCityAndProductionEval@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 148				; 00000094H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5286 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _Pred, _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T235418[ebp], al
	movzx	ecx, BYTE PTR $T235418[ebp]
	push	ecx
	movzx	edx, BYTE PTR __Pred$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Chunk$[ebp]
	push	ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T235419[ebp], esp
	mov	DWORD PTR $T235430[ebp], edx
	mov	eax, DWORD PTR $T235430[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T235430[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T235430[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T235430[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T235430[ebp]
	mov	edx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T235430[ebp]
	mov	DWORD PTR tv94[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Chunked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@HUCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0V?$_Temp_iterator@UCityAndProduction@@@0@HHUCityAndProductionEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction>,int,CityAndProductionEval>
	add	esp, 44					; 0000002cH

; 5287 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN1@Unchecked_
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$235619[ebp], eax
	jmp	SHORT $LN85@Unchecked_
$LN84@Unchecked_:
	mov	ecx, DWORD PTR __Next$235619[ebp]
	add	ecx, 8
	mov	DWORD PTR __Next$235619[ebp], ecx
$LN85@Unchecked_:
	mov	edx, DWORD PTR __Next$235619[ebp]
	cmp	edx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN83@Unchecked_
	jmp	SHORT $LN84@Unchecked_
$LN83@Unchecked_:
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T235611[ebp], eax
	mov	ecx, DWORD PTR $T235611[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Unchecked_:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Unchecked_chunked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@HUCityAndProductionEval@@@stdext@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@0V?$_Temp_iterator@UCityAndProduction@@@2@HHUCityAndProductionEval@@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@UCityAndProduction@@@std@@QAE@XZ ; std::_Temp_iterator<CityAndProduction>::~_Temp_iterator<CityAndProduction>
__ehhandler$??$_Unchecked_chunked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@HUCityAndProductionEval@@@stdext@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@0V?$_Temp_iterator@UCityAndProduction@@@2@HHUCityAndProductionEval@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-152]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Unchecked_chunked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@HUCityAndProductionEval@@@stdext@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@0V?$_Temp_iterator@UCityAndProduction@@@2@HHUCityAndProductionEval@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Unchecked_chunked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@HUCityAndProductionEval@@@stdext@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@0V?$_Temp_iterator@UCityAndProduction@@@2@HHUCityAndProductionEval@@@Z ENDP ; stdext::_Unchecked_chunked_merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction>,int,CityAndProductionEval>
PUBLIC	??$_Copy_opt@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UCityAndProduction@@@0@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction>,std::forward_iterator_tag>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$unchecked_copy@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@0V12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$unchecked_copy@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@0V12@@Z$0
__ehfuncinfo$??$unchecked_copy@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@0V12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$unchecked_copy@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@0V12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	ENDS
;	COMDAT ??$unchecked_copy@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@0V12@@Z
_TEXT	SEGMENT
tv135 = -48						; size = 4
tv134 = -44						; size = 4
$T235664 = -40						; size = 4
__Next$235672 = -36					; size = 4
$T235656 = -32						; size = 4
__Cat$235643 = -25					; size = 1
$T235638 = -24						; size = 4
$T235634 = -20						; size = 4
$T235633 = -15						; size = 1
$T235632 = -14						; size = 1
$T235631 = -13						; size = 1
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
??$unchecked_copy@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@0V12@@Z PROC ; stdext::unchecked_copy<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction> >, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$unchecked_copy@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@0V12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T235638[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T235631[ebp], al
	mov	cl, BYTE PTR __Cat$235643[ebp]
	mov	BYTE PTR $T235632[ebp], cl
	movzx	edx, BYTE PTR $T235631[ebp]
	push	edx
	movzx	eax, BYTE PTR $T235632[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T235633[ebp]
	push	ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T235634[ebp], esp
	mov	DWORD PTR $T235656[ebp], edx
	mov	eax, DWORD PTR $T235656[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T235656[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T235656[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T235656[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T235656[ebp]
	mov	edx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T235656[ebp]
	mov	DWORD PTR tv134[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??$_Copy_opt@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UCityAndProduction@@@0@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction>,std::forward_iterator_tag>
	add	esp, 44					; 0000002cH
	mov	DWORD PTR tv135[ebp], eax
	mov	ecx, DWORD PTR $T235638[ebp]
	or	ecx, 1
	mov	DWORD PTR $T235638[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN19@unchecked_
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$235672[ebp], edx
	jmp	SHORT $LN17@unchecked_
$LN16@unchecked_:
	mov	eax, DWORD PTR __Next$235672[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$235672[ebp], eax
$LN17@unchecked_:
	mov	ecx, DWORD PTR __Next$235672[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN15@unchecked_
	jmp	SHORT $LN16@unchecked_
$LN15@unchecked_:
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T235664[ebp], edx
	mov	eax, DWORD PTR $T235664[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN19@unchecked_:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 3607 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$unchecked_copy@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@0V12@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@UCityAndProduction@@@std@@QAE@XZ ; std::_Temp_iterator<CityAndProduction>::~_Temp_iterator<CityAndProduction>
__ehhandler$??$unchecked_copy@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@0V12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$unchecked_copy@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@0V12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$unchecked_copy@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@0V12@@Z ENDP ; stdext::unchecked_copy<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction> >
PUBLIC	??$_Rotate@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@00PAHPAUCityAndProduction@@@Z ; std::_Rotate<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction>
PUBLIC	??$_Copy_backward_opt@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::random_access_iterator_tag>
PUBLIC	??$_Copy_opt@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::random_access_iterator_tag>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Buffered_rotate@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@00HHAAV?$_Temp_iterator@UCityAndProduction@@@0@@Z
_TEXT	SEGMENT
tv180 = -256						; size = 4
tv179 = -252						; size = 4
tv176 = -248						; size = 4
tv175 = -244						; size = 4
$T236029 = -236						; size = 4
$T236028 = -232						; size = 4
$T236027 = -228						; size = 4
$T236005 = -221						; size = 1
$T236004 = -220						; size = 4
$T236003 = -216						; size = 4
$T236002 = -212						; size = 4
$T236007 = -205						; size = 1
$T235966 = -204						; size = 4
$T235965 = -200						; size = 4
$T235940 = -194						; size = 1
$T235939 = -193						; size = 1
$T235938 = -192						; size = 4
$T235937 = -188						; size = 4
__Cat$235947 = -180					; size = 1
$T235944 = -179						; size = 1
$T235943 = -178						; size = 1
$T235942 = -177						; size = 1
$T235894 = -176						; size = 4
$T235890 = -172						; size = 4
$T235886 = -168						; size = 4
$T235885 = -164						; size = 4
__Cat$235880 = -156					; size = 1
$T235877 = -155						; size = 1
$T235876 = -154						; size = 1
$T235875 = -153						; size = 1
$T235850 = -152						; size = 4
__Next$235858 = -148					; size = 4
$T235842 = -144						; size = 4
$T235829 = -132						; size = 4
$T235828 = -128						; size = 4
$T235804 = -122						; size = 1
$T235803 = -121						; size = 1
$T235802 = -120						; size = 4
$T235801 = -116						; size = 4
$T235800 = -112						; size = 4
__Cat$235811 = -104					; size = 1
$T235808 = -103						; size = 1
$T235807 = -102						; size = 1
$T235806 = -101						; size = 1
$T235758 = -100						; size = 4
$T235754 = -96						; size = 4
$T235750 = -92						; size = 4
$T235749 = -88						; size = 4
__Cat$235744 = -80					; size = 1
$T235741 = -79						; size = 1
$T235740 = -78						; size = 1
$T235739 = -77						; size = 1
$T235714 = -76						; size = 4
__Next$235722 = -72					; size = 4
$T235706 = -68						; size = 4
$T235689 = -56						; size = 4
$T235688 = -52						; size = 20
$T235687 = -32						; size = 4
$T235686 = -28						; size = 4
$T235685 = -24						; size = 20
$T235684 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Mid$ = 16						; size = 4
__Last$ = 20						; size = 4
__Count1$ = 24						; size = 4
__Count2$ = 28						; size = 4
__Tempbuf$ = 32						; size = 4
??$_Buffered_rotate@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@00HHAAV?$_Temp_iterator@UCityAndProduction@@@0@@Z PROC ; std::_Buffered_rotate<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction>, COMDAT

; 2683 : 	{	// rotate [_First, _Last) using temp buffer

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H

; 2684 : 	if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	mov	eax, DWORD PTR __Count1$[ebp]
	cmp	eax, DWORD PTR __Count2$[ebp]
	jg	$LN4@Buffered_r
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@UCityAndProduction@@@std@@QAEHXZ ; std::_Temp_iterator<CityAndProduction>::_Maxlen
	cmp	DWORD PTR __Count1$[ebp], eax
	jg	$LN4@Buffered_r

; 2685 : 		{	// buffer left partition, then copy parts
; 2686 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+4], edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T235684[ebp], esp
	mov	DWORD PTR $T235706[ebp], eax
	mov	ecx, DWORD PTR $T235706[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T235706[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T235706[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T235706[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T235706[ebp]
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], ecx
	mov	edx, DWORD PTR $T235706[ebp]
	mov	DWORD PTR tv175[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T235685[ebp]
	push	edx
	call	??$unchecked_copy@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv176[ebp], eax
	cmp	DWORD PTR $T235685[ebp], 0
	je	SHORT $LN24@Buffered_r
	mov	eax, DWORD PTR $T235685[ebp]
	mov	DWORD PTR __Next$235722[ebp], eax
	jmp	SHORT $LN22@Buffered_r
$LN21@Buffered_r:
	mov	ecx, DWORD PTR __Next$235722[ebp]
	add	ecx, 8
	mov	DWORD PTR __Next$235722[ebp], ecx
$LN22@Buffered_r:
	mov	edx, DWORD PTR __Next$235722[ebp]
	cmp	edx, DWORD PTR $T235685[ebp+8]
	je	SHORT $LN20@Buffered_r
	jmp	SHORT $LN21@Buffered_r
$LN20@Buffered_r:
	mov	eax, DWORD PTR $T235685[ebp]
	mov	DWORD PTR $T235714[ebp], eax
	mov	ecx, DWORD PTR $T235714[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN24@Buffered_r:

; 2687 : 		_STDEXT unchecked_copy(_Mid, _Last, _First);

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T235750[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T235749[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T235739[ebp], cl
	mov	dl, BYTE PTR __Cat$235744[ebp]
	mov	BYTE PTR $T235740[ebp], dl
	movzx	eax, BYTE PTR $T235739[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T235740[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T235741[ebp]
	push	edx
	mov	eax, DWORD PTR $T235750[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T235749[ebp]
	push	edx
	lea	eax, DWORD PTR $T235686[ebp]
	push	eax
	call	??$_Copy_opt@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH

; 2688 : 		return (_STDEXT unchecked_copy_backward(_Tempbuf._First(), _Tempbuf._Last(),
; 2689 : 			_Last));

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T235754[ebp], eax
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T235758[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T235829[ebp], ecx
	mov	edx, DWORD PTR $T235758[ebp]
	mov	DWORD PTR $T235828[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T235806[ebp], al
	mov	cl, BYTE PTR __Cat$235811[ebp]
	mov	BYTE PTR $T235807[ebp], cl
	mov	dl, BYTE PTR $T235806[ebp]
	mov	BYTE PTR $T235804[ebp], dl
	mov	al, BYTE PTR $T235808[ebp]
	mov	BYTE PTR $T235803[ebp], al
	mov	ecx, DWORD PTR $T235829[ebp]
	mov	DWORD PTR $T235802[ebp], ecx
	mov	edx, DWORD PTR $T235754[ebp]
	mov	DWORD PTR $T235801[ebp], edx
	mov	eax, DWORD PTR $T235828[ebp]
	mov	DWORD PTR $T235800[ebp], eax
$LN47@Buffered_r:
	mov	ecx, DWORD PTR $T235800[ebp]
	cmp	ecx, DWORD PTR $T235801[ebp]
	je	SHORT $LN46@Buffered_r
	mov	edx, DWORD PTR $T235801[ebp]
	sub	edx, 8
	mov	DWORD PTR $T235801[ebp], edx
	mov	eax, DWORD PTR $T235802[ebp]
	sub	eax, 8
	mov	DWORD PTR $T235802[ebp], eax
	mov	ecx, DWORD PTR $T235801[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T235802[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN47@Buffered_r
$LN46@Buffered_r:
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR $T235802[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN5@Buffered_r
	jmp	$LN5@Buffered_r
$LN4@Buffered_r:

; 2690 : 		}
; 2691 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@UCityAndProduction@@@std@@QAEHXZ ; std::_Temp_iterator<CityAndProduction>::_Maxlen
	cmp	DWORD PTR __Count2$[ebp], eax
	jg	$LN2@Buffered_r

; 2692 : 		{	// buffer right partition, then copy parts
; 2693 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+4], edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T235687[ebp], esp
	mov	DWORD PTR $T235842[ebp], eax
	mov	ecx, DWORD PTR $T235842[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T235842[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T235842[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T235842[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T235842[ebp]
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], ecx
	mov	edx, DWORD PTR $T235842[ebp]
	mov	DWORD PTR tv179[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T235688[ebp]
	push	edx
	call	??$unchecked_copy@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv180[ebp], eax
	cmp	DWORD PTR $T235688[ebp], 0
	je	SHORT $LN71@Buffered_r
	mov	eax, DWORD PTR $T235688[ebp]
	mov	DWORD PTR __Next$235858[ebp], eax
	jmp	SHORT $LN69@Buffered_r
$LN68@Buffered_r:
	mov	ecx, DWORD PTR __Next$235858[ebp]
	add	ecx, 8
	mov	DWORD PTR __Next$235858[ebp], ecx
$LN69@Buffered_r:
	mov	edx, DWORD PTR __Next$235858[ebp]
	cmp	edx, DWORD PTR $T235688[ebp+8]
	je	SHORT $LN67@Buffered_r
	jmp	SHORT $LN68@Buffered_r
$LN67@Buffered_r:
	mov	eax, DWORD PTR $T235688[ebp]
	mov	DWORD PTR $T235850[ebp], eax
	mov	ecx, DWORD PTR $T235850[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN71@Buffered_r:

; 2694 : 		_STDEXT unchecked_copy_backward(_First, _Mid, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T235886[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T235885[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T235875[ebp], cl
	mov	dl, BYTE PTR __Cat$235880[ebp]
	mov	BYTE PTR $T235876[ebp], dl
	movzx	eax, BYTE PTR $T235875[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T235876[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T235877[ebp]
	push	edx
	mov	eax, DWORD PTR $T235886[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T235885[ebp]
	push	edx
	lea	eax, DWORD PTR $T235689[ebp]
	push	eax
	call	??$_Copy_backward_opt@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH

; 2695 : 		return (_STDEXT unchecked_copy(_Tempbuf._First(), _Tempbuf._Last(), _First));

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T235890[ebp], eax
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T235894[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T235966[ebp], ecx
	mov	edx, DWORD PTR $T235894[ebp]
	mov	DWORD PTR $T235965[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T235942[ebp], al
	mov	cl, BYTE PTR __Cat$235947[ebp]
	mov	BYTE PTR $T235943[ebp], cl
	mov	dl, BYTE PTR $T235942[ebp]
	mov	BYTE PTR $T235940[ebp], dl
	mov	al, BYTE PTR $T235944[ebp]
	mov	BYTE PTR $T235939[ebp], al
	mov	ecx, DWORD PTR $T235966[ebp]
	mov	DWORD PTR $T235938[ebp], ecx
	mov	edx, DWORD PTR $T235965[ebp]
	mov	DWORD PTR $T235937[ebp], edx
	jmp	SHORT $LN95@Buffered_r
$LN94@Buffered_r:
	mov	eax, DWORD PTR $T235938[ebp]
	add	eax, 8
	mov	DWORD PTR $T235938[ebp], eax
	mov	ecx, DWORD PTR $T235937[ebp]
	add	ecx, 8
	mov	DWORD PTR $T235937[ebp], ecx
$LN95@Buffered_r:
	mov	edx, DWORD PTR $T235937[ebp]
	cmp	edx, DWORD PTR $T235890[ebp]
	je	SHORT $LN93@Buffered_r
	mov	eax, DWORD PTR $T235937[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T235938[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN94@Buffered_r
$LN93@Buffered_r:
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR $T235938[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN5@Buffered_r

; 2696 : 		}
; 2697 : 	else

	jmp	$LN5@Buffered_r
$LN2@Buffered_r:

; 2698 : 		{	// buffer too small, rotate in place
; 2699 : 		std::rotate(_First, _Mid, _Last);

	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T236029[ebp], eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T236028[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T236027[ebp], edx
	mov	eax, DWORD PTR $T236027[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T236028[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN127@Buffered_r
	mov	ecx, DWORD PTR $T236028[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T236029[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN127@Buffered_r
	mov	dl, BYTE PTR $T236007[ebp]
	mov	BYTE PTR $T236005[ebp], dl
	mov	eax, DWORD PTR $T236029[ebp]
	mov	DWORD PTR $T236004[ebp], eax
	mov	ecx, DWORD PTR $T236028[ebp]
	mov	DWORD PTR $T236003[ebp], ecx
	mov	edx, DWORD PTR $T236027[ebp]
	mov	DWORD PTR $T236002[ebp], edx
	push	0
	push	0
	mov	eax, DWORD PTR $T236004[ebp]
	push	eax
	mov	ecx, DWORD PTR $T236003[ebp]
	push	ecx
	mov	edx, DWORD PTR $T236002[ebp]
	push	edx
	call	??$_Rotate@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@00PAHPAUCityAndProduction@@@Z ; std::_Rotate<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction>
	add	esp, 20					; 00000014H

; 2700 : 		std::advance(_First, _Count2);

$LN127@Buffered_r:
	mov	eax, DWORD PTR __Count2$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __First$[ebp], edx

; 2701 : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN5@Buffered_r:

; 2702 : 		}
; 2703 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Buffered_rotate@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@00HHAAV?$_Temp_iterator@UCityAndProduction@@@0@@Z ENDP ; std::_Buffered_rotate<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction>
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv84 = -32						; size = 4
$T236087 = -28						; size = 4
__Vptr$236093 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CityAndProduction *,CityAndProduction *,std::allocator<CityAndProduction> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop
$LN5@Uninit_cop:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 8
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$236093[ebp], ecx
	mov	edx, DWORD PTR __Vptr$236093[ebp]
	mov	DWORD PTR $T236087[ebp], edx
	cmp	DWORD PTR $T236087[ebp], 0
	je	SHORT $LN18@Uninit_cop
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T236087[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR $T236087[ebp]
	mov	DWORD PTR tv84[ebp], ecx
	jmp	SHORT $LN14@Uninit_cop
$LN18@Uninit_cop:
	mov	DWORD PTR tv84[ebp], 0
$LN14@Uninit_cop:
	jmp	SHORT $LN5@Uninit_cop
$LN4@Uninit_cop:
	jmp	SHORT $LN10@Uninit_cop
__catch$??$_Uninit_copy@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop
$LN2@Uninit_cop:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 8
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_cop:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop

; 134  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_cop
$LN1@Uninit_cop:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAUCityAndProduction@@PAU1@V?$allocator@UCityAndProduction@@@std@@@std@@YAPAUCityAndProduction@@PAU1@00AAV?$allocator@UCityAndProduction@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CityAndProduction *,CityAndProduction *,std::allocator<CityAndProduction> >
PUBLIC	??$unchecked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@V?$_Temp_iterator@UCityAndProduction@@@2@UCityAndProductionEval@@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@000V12@UCityAndProductionEval@@@Z ; stdext::unchecked_merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction>,CityAndProductionEval>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Chunked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@HUCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0V?$_Temp_iterator@UCityAndProduction@@@0@HHUCityAndProductionEval@@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Chunked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@HUCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0V?$_Temp_iterator@UCityAndProduction@@@0@HHUCityAndProductionEval@@U_Range_checked_iterator_tag@0@@Z$0
__ehfuncinfo$??$_Chunked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@HUCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0V?$_Temp_iterator@UCityAndProduction@@@0@HHUCityAndProductionEval@@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Chunked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@HUCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0V?$_Temp_iterator@UCityAndProduction@@@0@HHUCityAndProductionEval@@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Chunked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@HUCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0V?$_Temp_iterator@UCityAndProduction@@@0@HHUCityAndProductionEval@@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv187 = -180						; size = 4
tv186 = -176						; size = 4
tv182 = -172						; size = 4
tv181 = -168						; size = 4
tv177 = -164						; size = 4
tv176 = -160						; size = 4
$T236321 = -156						; size = 4
__Next$236324 = -152					; size = 4
$T236302 = -148						; size = 4
__Next$236305 = -144					; size = 4
$T236294 = -140						; size = 4
$T236241 = -132						; size = 4
__Next$236249 = -128					; size = 4
$T236233 = -124						; size = 4
$T236213 = -120						; size = 4
__Next$236221 = -116					; size = 4
$T236205 = -112						; size = 4
$T236201 = -108						; size = 4
$T236119 = -100						; size = 20
$T236118 = -80						; size = 4
$T236117 = -76						; size = 20
$T236116 = -56						; size = 4
$T236115 = -52						; size = 20
$T236114 = -32						; size = 4
__Mid1$227907 = -28					; size = 4
__Mid2$227888 = -24					; size = 4
__Mid1$227887 = -20					; size = 4
__Chunk2$227883 = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
__Count$ = 40						; size = 4
__Pred$ = 44						; size = 1
___formal$ = 48						; size = 1
??$_Chunked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@HUCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0V?$_Temp_iterator@UCityAndProduction@@@0@HHUCityAndProductionEval@@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction>,int,CityAndProductionEval>, COMDAT

; 3434 : 	{	// copy merging chunks, using _Pred

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Chunked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@HUCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0V?$_Temp_iterator@UCityAndProduction@@@0@HHUCityAndProductionEval@@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 168				; 000000a8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3435 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	eax, DWORD PTR __Chunk$[ebp]
	shl	eax, 1
	mov	DWORD PTR __Chunk2$227883[ebp], eax
	jmp	SHORT $LN5@Chunked_me
$LN4@Chunked_me:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, DWORD PTR __Chunk2$227883[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN5@Chunked_me:
	mov	edx, DWORD PTR __Chunk2$227883[ebp]
	cmp	edx, DWORD PTR __Count$[ebp]
	jg	$LN3@Chunked_me

; 3436 : 		{	// copy merging pairs of adjacent chunks
; 3437 : 		_BidIt _Mid1 = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid1$227887[ebp], eax

; 3438 : 		std::advance(_Mid1, _Chunk);

	mov	ecx, DWORD PTR __Chunk$[ebp]
	mov	edx, DWORD PTR __Mid1$227887[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR __Mid1$227887[ebp], eax

; 3439 : 		_BidIt _Mid2 = _Mid1;

	mov	ecx, DWORD PTR __Mid1$227887[ebp]
	mov	DWORD PTR __Mid2$227888[ebp], ecx

; 3440 : 		std::advance(_Mid2, _Chunk);

	mov	edx, DWORD PTR __Chunk$[ebp]
	mov	eax, DWORD PTR __Mid2$227888[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR __Mid2$227888[ebp], ecx

; 3441 : 
; 3442 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);

	movzx	edx, BYTE PTR __Pred$[ebp]
	push	edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T236114[ebp], esp
	mov	DWORD PTR $T236201[ebp], eax
	mov	ecx, DWORD PTR $T236201[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T236201[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T236201[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T236201[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T236201[ebp]
	mov	eax, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR $T236201[ebp]
	mov	DWORD PTR tv176[ebp], ecx
	mov	edx, DWORD PTR __Mid2$227888[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid1$227887[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid1$227887[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T236115[ebp]
	push	eax
	call	??$unchecked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@V?$_Temp_iterator@UCityAndProduction@@@2@UCityAndProductionEval@@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@000V12@UCityAndProductionEval@@@Z ; stdext::unchecked_merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction>,CityAndProductionEval>
	add	esp, 44					; 0000002cH
	mov	DWORD PTR tv177[ebp], eax
	mov	ecx, DWORD PTR tv177[ebp]
	mov	DWORD PTR $T236205[ebp], ecx
	mov	edx, DWORD PTR $T236205[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR __Dest$[ebp+16], eax
	cmp	DWORD PTR $T236115[ebp], 0
	je	SHORT $LN45@Chunked_me
	mov	ecx, DWORD PTR $T236115[ebp]
	mov	DWORD PTR __Next$236221[ebp], ecx
	jmp	SHORT $LN43@Chunked_me
$LN42@Chunked_me:
	mov	edx, DWORD PTR __Next$236221[ebp]
	add	edx, 8
	mov	DWORD PTR __Next$236221[ebp], edx
$LN43@Chunked_me:
	mov	eax, DWORD PTR __Next$236221[ebp]
	cmp	eax, DWORD PTR $T236115[ebp+8]
	je	SHORT $LN41@Chunked_me
	jmp	SHORT $LN42@Chunked_me
$LN41@Chunked_me:
	mov	ecx, DWORD PTR $T236115[ebp]
	mov	DWORD PTR $T236213[ebp], ecx
	mov	edx, DWORD PTR $T236213[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN45@Chunked_me:

; 3443 : 		_First = _Mid2;

	mov	eax, DWORD PTR __Mid2$227888[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 3444 : 		}

	jmp	$LN4@Chunked_me
$LN3@Chunked_me:

; 3445 : 
; 3446 : 	if (_Count <= _Chunk)

	mov	ecx, DWORD PTR __Count$[ebp]
	cmp	ecx, DWORD PTR __Chunk$[ebp]
	jg	$LN2@Chunked_me

; 3447 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T236116[ebp], esp
	mov	DWORD PTR $T236233[ebp], edx
	mov	eax, DWORD PTR $T236233[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T236233[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T236233[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T236233[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T236233[ebp]
	mov	edx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T236233[ebp]
	mov	DWORD PTR tv181[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T236117[ebp]
	push	eax
	call	??$unchecked_copy@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv182[ebp], eax
	cmp	DWORD PTR $T236117[ebp], 0
	je	SHORT $LN59@Chunked_me
	mov	ecx, DWORD PTR $T236117[ebp]
	mov	DWORD PTR __Next$236249[ebp], ecx
	jmp	SHORT $LN57@Chunked_me
$LN56@Chunked_me:
	mov	edx, DWORD PTR __Next$236249[ebp]
	add	edx, 8
	mov	DWORD PTR __Next$236249[ebp], edx
$LN57@Chunked_me:
	mov	eax, DWORD PTR __Next$236249[ebp]
	cmp	eax, DWORD PTR $T236117[ebp+8]
	je	SHORT $LN55@Chunked_me
	jmp	SHORT $LN56@Chunked_me
$LN55@Chunked_me:
	mov	ecx, DWORD PTR $T236117[ebp]
	mov	DWORD PTR $T236241[ebp], ecx
	mov	edx, DWORD PTR $T236241[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN59@Chunked_me:

; 3448 : 	else

	jmp	$LN1@Chunked_me
$LN2@Chunked_me:

; 3449 : 		{	// copy merging whole and partial last chunk
; 3450 : 		_BidIt _Mid1 = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid1$227907[ebp], eax

; 3451 : 		std::advance(_Mid1, _Chunk);

	mov	ecx, DWORD PTR __Chunk$[ebp]
	mov	edx, DWORD PTR __Mid1$227907[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR __Mid1$227907[ebp], eax

; 3452 : 
; 3453 : 		_STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);

	movzx	ecx, BYTE PTR __Pred$[ebp]
	push	ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T236118[ebp], esp
	mov	DWORD PTR $T236294[ebp], edx
	mov	eax, DWORD PTR $T236294[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T236294[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T236294[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T236294[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T236294[ebp]
	mov	edx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T236294[ebp]
	mov	DWORD PTR tv186[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid1$227907[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid1$227907[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T236119[ebp]
	push	edx
	call	??$unchecked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@V?$_Temp_iterator@UCityAndProduction@@@2@UCityAndProductionEval@@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@000V12@UCityAndProductionEval@@@Z ; stdext::unchecked_merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction>,CityAndProductionEval>
	add	esp, 44					; 0000002cH
	mov	DWORD PTR tv187[ebp], eax
	cmp	DWORD PTR $T236119[ebp], 0
	je	SHORT $LN1@Chunked_me
	mov	eax, DWORD PTR $T236119[ebp]
	mov	DWORD PTR __Next$236305[ebp], eax
	jmp	SHORT $LN81@Chunked_me
$LN80@Chunked_me:
	mov	ecx, DWORD PTR __Next$236305[ebp]
	add	ecx, 8
	mov	DWORD PTR __Next$236305[ebp], ecx
$LN81@Chunked_me:
	mov	edx, DWORD PTR __Next$236305[ebp]
	cmp	edx, DWORD PTR $T236119[ebp+8]
	je	SHORT $LN79@Chunked_me
	jmp	SHORT $LN80@Chunked_me
$LN79@Chunked_me:
	mov	eax, DWORD PTR $T236119[ebp]
	mov	DWORD PTR $T236302[ebp], eax
	mov	ecx, DWORD PTR $T236302[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Chunked_me:

; 3454 : 		}
; 3455 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN6@Chunked_me
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$236324[ebp], edx
	jmp	SHORT $LN91@Chunked_me
$LN90@Chunked_me:
	mov	eax, DWORD PTR __Next$236324[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$236324[ebp], eax
$LN91@Chunked_me:
	mov	ecx, DWORD PTR __Next$236324[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN89@Chunked_me
	jmp	SHORT $LN90@Chunked_me
$LN89@Chunked_me:
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T236321[ebp], edx
	mov	eax, DWORD PTR $T236321[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@Chunked_me:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Chunked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@HUCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0V?$_Temp_iterator@UCityAndProduction@@@0@HHUCityAndProductionEval@@U_Range_checked_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@UCityAndProduction@@@std@@QAE@XZ ; std::_Temp_iterator<CityAndProduction>::~_Temp_iterator<CityAndProduction>
__ehhandler$??$_Chunked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@HUCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0V?$_Temp_iterator@UCityAndProduction@@@0@HHUCityAndProductionEval@@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-172]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Chunked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@HUCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0V?$_Temp_iterator@UCityAndProduction@@@0@HHUCityAndProductionEval@@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Chunked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@HUCityAndProductionEval@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0V?$_Temp_iterator@UCityAndProduction@@@0@HHUCityAndProductionEval@@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction>,int,CityAndProductionEval>
PUBLIC	??$_Merge@PAUCityAndProduction@@PAU1@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@PAUCityAndProduction@@000V10@UCityAndProductionEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CityAndProduction *,CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval,std::random_access_iterator_tag>
PUBLIC	??$unchecked_merge@PAUCityAndProduction@@PAU1@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@@stdext@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@PAUCityAndProduction@@000V12@UCityAndProductionEval@@@Z ; stdext::unchecked_merge<CityAndProduction *,CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval>
; Function compile flags: /Odtp
;	COMDAT ??$_Chunked_merge@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProductionEval@@@std@@YAXPAUCityAndProduction@@0V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@HHUCityAndProductionEval@@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T236757 = -180						; size = 4
$T236756 = -176						; size = 4
$T236755 = -172						; size = 4
$T236754 = -168						; size = 4
$T236749 = -100						; size = 1
$T236748 = -99						; size = 1
$T236549 = -96						; size = 4
$T236548 = -92						; size = 4
$T236523 = -86						; size = 1
$T236522 = -85						; size = 1
$T236521 = -84						; size = 4
$T236520 = -80						; size = 4
__Cat$236531 = -75					; size = 1
$T236528 = -74						; size = 1
$T236527 = -73						; size = 1
$T236526 = -72						; size = 1
$T236343 = -28						; size = 4
$T236342 = -24						; size = 4
$T236341 = -20						; size = 4
__Mid1$227939 = -16					; size = 4
__Mid2$227922 = -12					; size = 4
__Mid1$227915 = -8					; size = 4
__Chunk2$227911 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
__Count$ = 24						; size = 4
__Pred$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Chunked_merge@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProductionEval@@@std@@YAXPAUCityAndProduction@@0V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@HHUCityAndProductionEval@@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProductionEval>, COMDAT

; 3434 : 	{	// copy merging chunks, using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H

; 3435 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	eax, DWORD PTR __Chunk$[ebp]
	shl	eax, 1
	mov	DWORD PTR __Chunk2$227911[ebp], eax
	jmp	SHORT $LN5@Chunked_me@2
$LN4@Chunked_me@2:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, DWORD PTR __Chunk2$227911[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN5@Chunked_me@2:
	mov	edx, DWORD PTR __Chunk2$227911[ebp]
	cmp	edx, DWORD PTR __Count$[ebp]
	jg	SHORT $LN3@Chunked_me@2

; 3436 : 		{	// copy merging pairs of adjacent chunks
; 3437 : 		_BidIt _Mid1 = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid1$227915[ebp], eax

; 3438 : 		std::advance(_Mid1, _Chunk);

	mov	ecx, DWORD PTR __Chunk$[ebp]
	mov	edx, DWORD PTR __Mid1$227915[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR __Mid1$227915[ebp], eax

; 3439 : 		_BidIt _Mid2 = _Mid1;

	mov	ecx, DWORD PTR __Mid1$227915[ebp]
	mov	DWORD PTR __Mid2$227922[ebp], ecx

; 3440 : 		std::advance(_Mid2, _Chunk);

	mov	edx, DWORD PTR __Chunk$[ebp]
	mov	eax, DWORD PTR __Mid2$227922[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR __Mid2$227922[ebp], ecx

; 3441 : 
; 3442 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);

	movzx	edx, BYTE PTR __Pred$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid2$227922[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid1$227915[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid1$227915[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T236341[ebp]
	push	edx
	call	??$unchecked_merge@PAUCityAndProduction@@PAU1@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@@stdext@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@PAUCityAndProduction@@000V12@UCityAndProductionEval@@@Z ; stdext::unchecked_merge<CityAndProduction *,CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval>
	add	esp, 28					; 0000001cH
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Dest$[ebp], eax

; 3443 : 		_First = _Mid2;

	mov	ecx, DWORD PTR __Mid2$227922[ebp]
	mov	DWORD PTR __First$[ebp], ecx

; 3444 : 		}

	jmp	SHORT $LN4@Chunked_me@2
$LN3@Chunked_me@2:

; 3445 : 
; 3446 : 	if (_Count <= _Chunk)

	mov	edx, DWORD PTR __Count$[ebp]
	cmp	edx, DWORD PTR __Chunk$[ebp]
	jg	SHORT $LN2@Chunked_me@2

; 3447 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T236549[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T236548[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T236526[ebp], dl
	mov	al, BYTE PTR __Cat$236531[ebp]
	mov	BYTE PTR $T236527[ebp], al
	mov	cl, BYTE PTR $T236526[ebp]
	mov	BYTE PTR $T236523[ebp], cl
	mov	dl, BYTE PTR $T236528[ebp]
	mov	BYTE PTR $T236522[ebp], dl
	mov	eax, DWORD PTR $T236549[ebp]
	mov	DWORD PTR $T236521[ebp], eax
	mov	ecx, DWORD PTR $T236548[ebp]
	mov	DWORD PTR $T236520[ebp], ecx
	jmp	SHORT $LN59@Chunked_me@2
$LN58@Chunked_me@2:
	mov	edx, DWORD PTR $T236521[ebp]
	add	edx, 8
	mov	DWORD PTR $T236521[ebp], edx
	mov	eax, DWORD PTR $T236520[ebp]
	add	eax, 8
	mov	DWORD PTR $T236520[ebp], eax
$LN59@Chunked_me@2:
	mov	ecx, DWORD PTR $T236520[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN57@Chunked_me@2
	mov	edx, DWORD PTR $T236520[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T236521[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN58@Chunked_me@2
$LN57@Chunked_me@2:
	mov	eax, DWORD PTR $T236521[ebp]
	mov	DWORD PTR $T236342[ebp], eax

; 3448 : 	else

	jmp	SHORT $LN6@Chunked_me@2
$LN2@Chunked_me@2:

; 3449 : 		{	// copy merging whole and partial last chunk
; 3450 : 		_BidIt _Mid1 = _First;

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid1$227939[ebp], ecx

; 3451 : 		std::advance(_Mid1, _Chunk);

	mov	edx, DWORD PTR __Chunk$[ebp]
	mov	eax, DWORD PTR __Mid1$227939[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR __Mid1$227939[ebp], ecx

; 3452 : 
; 3453 : 		_STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);

	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T236757[ebp], edx
	mov	eax, DWORD PTR __Mid1$227939[ebp]
	mov	DWORD PTR $T236756[ebp], eax
	mov	ecx, DWORD PTR __Mid1$227939[ebp]
	mov	DWORD PTR $T236755[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T236754[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T236748[ebp], al
	movzx	ecx, BYTE PTR $T236748[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T236749[ebp]
	push	edx
	movzx	eax, BYTE PTR __Pred$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T236757[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR $T236756[ebp]
	push	eax
	mov	ecx, DWORD PTR $T236755[ebp]
	push	ecx
	mov	edx, DWORD PTR $T236754[ebp]
	push	edx
	lea	eax, DWORD PTR $T236343[ebp]
	push	eax
	call	??$_Merge@PAUCityAndProduction@@PAU1@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@PAUCityAndProduction@@000V10@UCityAndProductionEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CityAndProduction *,CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval,std::random_access_iterator_tag>
	add	esp, 36					; 00000024H
$LN6@Chunked_me@2:

; 3454 : 		}
; 3455 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Chunked_merge@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProductionEval@@@std@@YAXPAUCityAndProduction@@0V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@HHUCityAndProductionEval@@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProductionEval>
_TEXT	ENDS
PUBLIC	??4?$_Temp_iterator@UCityAndProduction@@@std@@QAEAAV01@ABUCityAndProduction@@@Z ; std::_Temp_iterator<CityAndProduction>::operator=
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Copy_opt@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UCityAndProduction@@@0@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Copy_opt@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UCityAndProduction@@@0@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__ehfuncinfo$??$_Copy_opt@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UCityAndProduction@@@0@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Copy_opt@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UCityAndProduction@@@0@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	ENDS
;	COMDAT ??$_Copy_opt@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UCityAndProduction@@@0@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T236826 = -40						; size = 4
__Next$236834 = -36					; size = 4
$T236791 = -20						; size = 4
$T236762 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
___formal$ = 48						; size = 1
??$_Copy_opt@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UCityAndProduction@@@0@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction>,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Copy_opt@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UCityAndProduction@@@0@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T236762[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN15@Copy_opt
$LN9@Copy_opt:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 8
	mov	DWORD PTR __First$[ebp], eax
$LN15@Copy_opt:
	mov	ecx, DWORD PTR __First$[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR __Last$[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@Copy_opt

; 2472 : 		*_Dest = *_First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T236791[ebp], edx
	mov	eax, DWORD PTR $T236791[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??4?$_Temp_iterator@UCityAndProduction@@@std@@QAEAAV01@ABUCityAndProduction@@@Z ; std::_Temp_iterator<CityAndProduction>::operator=
	jmp	SHORT $LN9@Copy_opt
$LN1@Copy_opt:

; 2473 : 	return (_Dest);

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR $T236762[ebp]
	or	ecx, 1
	mov	DWORD PTR $T236762[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN43@Copy_opt
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$236834[ebp], edx
	jmp	SHORT $LN41@Copy_opt
$LN40@Copy_opt:
	mov	eax, DWORD PTR __Next$236834[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$236834[ebp], eax
$LN41@Copy_opt:
	mov	ecx, DWORD PTR __Next$236834[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN39@Copy_opt
	jmp	SHORT $LN40@Copy_opt
$LN39@Copy_opt:
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T236826[ebp], edx
	mov	eax, DWORD PTR $T236826[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN43@Copy_opt:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2474 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Copy_opt@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UCityAndProduction@@@0@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@UCityAndProduction@@@std@@QAE@XZ ; std::_Temp_iterator<CityAndProduction>::~_Temp_iterator<CityAndProduction>
__ehhandler$??$_Copy_opt@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UCityAndProduction@@@0@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Copy_opt@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UCityAndProduction@@@0@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Copy_opt@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UCityAndProduction@@@0@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction>,std::forward_iterator_tag>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Merge@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V23@UCityAndProductionEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@PAUCityAndProduction@@0V10@11UCityAndProductionEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T237102 = -80						; size = 4
$T237101 = -76						; size = 4
$T237100 = -72						; size = 4
$T237063 = -66						; size = 1
$T237062 = -65						; size = 1
$T237061 = -64						; size = 4
$T237060 = -60						; size = 4
$T237059 = -56						; size = 4
$T237025 = -52						; size = 4
__Cat$237070 = -44					; size = 1
$T237067 = -43						; size = 1
$T237066 = -42						; size = 1
$T237065 = -41						; size = 1
$T236979 = -40						; size = 4
$T236978 = -36						; size = 4
$T236953 = -30						; size = 1
$T236952 = -29						; size = 1
$T236951 = -28						; size = 4
$T236950 = -24						; size = 4
__Cat$236960 = -16					; size = 1
$T236957 = -15						; size = 1
$T236956 = -14						; size = 1
$T236955 = -13						; size = 1
$T236883 = -12						; size = 4
$T236871 = -8						; size = 4
$T236846 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
__Pred$ = 32						; size = 1
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
??$_Merge@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V23@UCityAndProductionEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@PAUCityAndProduction@@0V10@11UCityAndProductionEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval,std::random_access_iterator_tag>, COMDAT

; 2593 : 	{	//  copy merging ranges, both using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H

; 2594 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2595 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2596 : 	_DEBUG_POINTER(_Dest);
; 2597 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	jmp	SHORT $LN5@Merge
$LN4@Merge:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 8
	mov	DWORD PTR __Dest$[ebp], eax
$LN5@Merge:
	mov	ecx, DWORD PTR __First1$[ebp]
	cmp	ecx, DWORD PTR __Last1$[ebp]
	je	SHORT $LN3@Merge
	mov	edx, DWORD PTR __First2$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last2$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN3@Merge

; 2598 : 		if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))

	mov	eax, DWORD PTR __First2$[ebp]
	mov	DWORD PTR $T236871[ebp], eax
	mov	ecx, DWORD PTR $T236871[ebp]
	mov	edx, DWORD PTR __First1$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN34@Merge

; 2599 : 			*_Dest = *_First2, ++_First2;

	mov	eax, DWORD PTR __First2$[ebp]
	mov	DWORD PTR $T236883[ebp], eax
	mov	ecx, DWORD PTR $T236883[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __First2$[ebp]
	add	edx, 8
	mov	DWORD PTR __First2$[ebp], edx

; 2600 : 		else

	jmp	SHORT $LN1@Merge

; 2601 : 			*_Dest = *_First1, ++_First1;

$LN34@Merge:
	mov	eax, DWORD PTR __First1$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __First1$[ebp]
	add	ecx, 8
	mov	DWORD PTR __First1$[ebp], ecx
$LN1@Merge:
	jmp	$LN4@Merge
$LN3@Merge:

; 2602 : 
; 2603 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T236979[ebp], edx
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR $T236978[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T236955[ebp], cl
	mov	dl, BYTE PTR __Cat$236960[ebp]
	mov	BYTE PTR $T236956[ebp], dl
	mov	al, BYTE PTR $T236955[ebp]
	mov	BYTE PTR $T236953[ebp], al
	mov	cl, BYTE PTR $T236957[ebp]
	mov	BYTE PTR $T236952[ebp], cl
	mov	edx, DWORD PTR $T236979[ebp]
	mov	DWORD PTR $T236951[ebp], edx
	mov	eax, DWORD PTR $T236978[ebp]
	mov	DWORD PTR $T236950[ebp], eax
	jmp	SHORT $LN46@Merge
$LN45@Merge:
	mov	ecx, DWORD PTR $T236951[ebp]
	add	ecx, 8
	mov	DWORD PTR $T236951[ebp], ecx
	mov	edx, DWORD PTR $T236950[ebp]
	add	edx, 8
	mov	DWORD PTR $T236950[ebp], edx
$LN46@Merge:
	mov	eax, DWORD PTR $T236950[ebp]
	cmp	eax, DWORD PTR __Last1$[ebp]
	je	SHORT $LN44@Merge
	mov	ecx, DWORD PTR $T236950[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T236951[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN45@Merge
$LN44@Merge:
	mov	edx, DWORD PTR $T236951[ebp]
	mov	DWORD PTR $T236846[ebp], edx
	mov	eax, DWORD PTR $T236846[ebp]
	mov	DWORD PTR __Dest$[ebp], eax

; 2604 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T237102[ebp], ecx
	mov	edx, DWORD PTR __Last2$[ebp]
	mov	DWORD PTR $T237101[ebp], edx
	mov	eax, DWORD PTR __First2$[ebp]
	mov	DWORD PTR $T237100[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T237065[ebp], cl
	mov	dl, BYTE PTR __Cat$237070[ebp]
	mov	BYTE PTR $T237066[ebp], dl
	mov	al, BYTE PTR $T237065[ebp]
	mov	BYTE PTR $T237063[ebp], al
	mov	cl, BYTE PTR $T237067[ebp]
	mov	BYTE PTR $T237062[ebp], cl
	mov	edx, DWORD PTR $T237102[ebp]
	mov	DWORD PTR $T237061[ebp], edx
	mov	eax, DWORD PTR $T237101[ebp]
	mov	DWORD PTR $T237060[ebp], eax
	mov	ecx, DWORD PTR $T237100[ebp]
	mov	DWORD PTR $T237059[ebp], ecx
	jmp	SHORT $LN76@Merge
$LN64@Merge:
	mov	edx, DWORD PTR $T237061[ebp]
	add	edx, 8
	mov	DWORD PTR $T237061[ebp], edx
	mov	eax, DWORD PTR $T237059[ebp]
	add	eax, 8
	mov	DWORD PTR $T237059[ebp], eax
$LN76@Merge:
	mov	ecx, DWORD PTR $T237059[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T237060[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN63@Merge
	mov	edx, DWORD PTR $T237059[ebp]
	mov	DWORD PTR $T237025[ebp], edx
	mov	eax, DWORD PTR $T237025[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T237061[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN64@Merge
$LN63@Merge:
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR $T237061[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2605 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Merge@PAUCityAndProduction@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V23@UCityAndProductionEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@PAUCityAndProduction@@0V10@11UCityAndProductionEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval,std::random_access_iterator_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Merge_backward@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@PAUCityAndProduction@@V12@UCityAndProductionEval@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@0PAUCityAndProduction@@10UCityAndProductionEval@@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T237328 = -80						; size = 4
$T237316 = -76						; size = 4
$T237299 = -72						; size = 4
$T237298 = -68						; size = 4
$T237297 = -64						; size = 4
$T237261 = -58						; size = 1
$T237260 = -57						; size = 1
$T237259 = -56						; size = 4
$T237258 = -52						; size = 4
$T237257 = -48						; size = 4
$T237216 = -44						; size = 4
__Cat$237269 = -36					; size = 1
$T237266 = -35						; size = 1
$T237265 = -34						; size = 1
$T237264 = -33						; size = 1
$T237178 = -32						; size = 4
$T237177 = -28						; size = 4
$T237153 = -22						; size = 1
$T237152 = -21						; size = 1
$T237151 = -20						; size = 4
$T237150 = -16						; size = 4
$T237149 = -12						; size = 4
__Cat$237160 = -4					; size = 1
$T237157 = -3						; size = 1
$T237156 = -2						; size = 1
$T237155 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
__Pred$ = 32						; size = 1
___formal$ = 36						; size = 1
??$_Merge_backward@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@PAUCityAndProduction@@V12@UCityAndProductionEval@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@0PAUCityAndProduction@@10UCityAndProductionEval@@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge_backward<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval>, COMDAT

; 2839 : 	{	// merge backwards to _Dest, using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H

; 2840 : 	for (; ; )
; 2841 : 		if (_First1 == _Last1)

$LN11@Merge_back:
	mov	eax, DWORD PTR __First1$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last1$[ebp]
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN6@Merge_back

; 2842 : 			return (_STDEXT unchecked_copy_backward(_First2, _Last2, _Dest));

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T237178[ebp], eax
	mov	ecx, DWORD PTR __First2$[ebp]
	mov	DWORD PTR $T237177[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T237155[ebp], dl
	mov	al, BYTE PTR __Cat$237160[ebp]
	mov	BYTE PTR $T237156[ebp], al
	mov	cl, BYTE PTR $T237155[ebp]
	mov	BYTE PTR $T237153[ebp], cl
	mov	dl, BYTE PTR $T237157[ebp]
	mov	BYTE PTR $T237152[ebp], dl
	mov	eax, DWORD PTR $T237178[ebp]
	mov	DWORD PTR $T237151[ebp], eax
	mov	ecx, DWORD PTR __Last2$[ebp]
	mov	DWORD PTR $T237150[ebp], ecx
	mov	edx, DWORD PTR $T237177[ebp]
	mov	DWORD PTR $T237149[ebp], edx
$LN20@Merge_back:
	mov	eax, DWORD PTR $T237149[ebp]
	cmp	eax, DWORD PTR $T237150[ebp]
	je	SHORT $LN19@Merge_back
	mov	ecx, DWORD PTR $T237150[ebp]
	sub	ecx, 8
	mov	DWORD PTR $T237150[ebp], ecx
	mov	edx, DWORD PTR $T237151[ebp]
	sub	edx, 8
	mov	DWORD PTR $T237151[ebp], edx
	mov	eax, DWORD PTR $T237150[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T237151[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN20@Merge_back
$LN19@Merge_back:
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR $T237151[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN9@Merge_back
	jmp	$LN5@Merge_back
$LN6@Merge_back:

; 2843 : 		else if (_First2 == _Last2)

	mov	eax, DWORD PTR __First2$[ebp]
	cmp	eax, DWORD PTR __Last2$[ebp]
	jne	$LN4@Merge_back

; 2844 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T237299[ebp], ecx
	mov	edx, DWORD PTR __Last1$[ebp]
	mov	DWORD PTR $T237298[ebp], edx
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR $T237297[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T237264[ebp], cl
	mov	dl, BYTE PTR __Cat$237269[ebp]
	mov	BYTE PTR $T237265[ebp], dl
	mov	al, BYTE PTR $T237264[ebp]
	mov	BYTE PTR $T237261[ebp], al
	mov	cl, BYTE PTR $T237266[ebp]
	mov	BYTE PTR $T237260[ebp], cl
	mov	edx, DWORD PTR $T237299[ebp]
	mov	DWORD PTR $T237259[ebp], edx
	mov	eax, DWORD PTR $T237298[ebp]
	mov	DWORD PTR $T237258[ebp], eax
	mov	ecx, DWORD PTR $T237297[ebp]
	mov	DWORD PTR $T237257[ebp], ecx
$LN41@Merge_back:
	mov	edx, DWORD PTR $T237257[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T237258[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN37@Merge_back
	mov	eax, DWORD PTR $T237258[ebp]
	sub	eax, 8
	mov	DWORD PTR $T237258[ebp], eax
	mov	ecx, DWORD PTR $T237258[ebp]
	mov	DWORD PTR $T237216[ebp], ecx
	mov	edx, DWORD PTR $T237259[ebp]
	sub	edx, 8
	mov	DWORD PTR $T237259[ebp], edx
	mov	eax, DWORD PTR $T237216[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T237259[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN41@Merge_back
$LN37@Merge_back:
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR $T237259[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN9@Merge_back
	jmp	SHORT $LN5@Merge_back
$LN4@Merge_back:

; 2845 : 		else if (_DEBUG_LT_PRED(_Pred, *--_Last2, *--_Last1))

	mov	eax, DWORD PTR __Last2$[ebp]
	sub	eax, 8
	mov	DWORD PTR __Last2$[ebp], eax
	mov	ecx, DWORD PTR __Last1$[ebp]
	sub	ecx, 8
	mov	DWORD PTR __Last1$[ebp], ecx
	mov	edx, DWORD PTR __Last1$[ebp]
	mov	DWORD PTR $T237316[ebp], edx
	mov	eax, DWORD PTR __Last2$[ebp]
	mov	ecx, DWORD PTR $T237316[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Merge_back

; 2846 : 			*--_Dest = *_Last1, ++_Last2;

	mov	edx, DWORD PTR __Last1$[ebp]
	mov	DWORD PTR $T237328[ebp], edx
	mov	eax, DWORD PTR __Dest$[ebp]
	sub	eax, 8
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR $T237328[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __Last2$[ebp]
	add	edx, 8
	mov	DWORD PTR __Last2$[ebp], edx

; 2847 : 		else

	jmp	SHORT $LN5@Merge_back
$LN2@Merge_back:

; 2848 : 			*--_Dest = *_Last2, ++_Last1;

	mov	eax, DWORD PTR __Dest$[ebp]
	sub	eax, 8
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR __Last2$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __Last1$[ebp]
	add	edx, 8
	mov	DWORD PTR __Last1$[ebp], edx
$LN5@Merge_back:
	jmp	$LN11@Merge_back
$LN9@Merge_back:

; 2849 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Merge_backward@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@PAUCityAndProduction@@V12@UCityAndProductionEval@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@0PAUCityAndProduction@@10UCityAndProductionEval@@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge_backward<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Lower_bound@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProduction@@HUCityAndProductionEval@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@0ABUCityAndProduction@@UCityAndProductionEval@@PAH@Z
_TEXT	SEGMENT
$T237448 = -36						; size = 4
$T237406 = -28						; size = 4
$T237393 = -24						; size = 4
$T237392 = -20						; size = 4
__Count2$227997 = -12					; size = 4
__Mid$227998 = -8					; size = 4
__Count$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
___formal$ = 28						; size = 4
??$_Lower_bound@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProduction@@HUCityAndProductionEval@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@0ABUCityAndProduction@@UCityAndProductionEval@@PAH@Z PROC ; std::_Lower_bound<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProduction,int,CityAndProductionEval>, COMDAT

; 2288 : 	{	// find first element not before _Val, using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 2289 : 	_DEBUG_POINTER(_Pred);
; 2290 : 	_DEBUG_ORDER_SINGLE_PRED(_First, _Last, _Pred, true);
; 2291 : 	_Diff _Count = 0;

	mov	DWORD PTR __Count$[ebp], 0

; 2292 : 	_Distance(_First, _Last, _Count);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T237406[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T237393[ebp], ecx
	mov	edx, DWORD PTR $T237406[ebp]
	mov	DWORD PTR $T237392[ebp], edx
	mov	eax, DWORD PTR $T237393[ebp]
	sub	eax, DWORD PTR $T237392[ebp]
	sar	eax, 3
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax
$LN4@Lower_boun:

; 2293 : 	for (; 0 < _Count; )

	cmp	DWORD PTR __Count$[ebp], 0
	jle	SHORT $LN3@Lower_boun

; 2294 : 		{	// divide and conquer, find half that contains answer
; 2295 : 		_Diff _Count2 = _Count / 2;

	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2$227997[ebp], eax

; 2296 : 		_FwdIt _Mid = _First;

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$227998[ebp], ecx

; 2297 : 		std::advance(_Mid, _Count2);

	mov	edx, DWORD PTR __Count2$227997[ebp]
	mov	eax, DWORD PTR __Mid$227998[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR __Mid$227998[ebp], ecx

; 2298 : 		_DEBUG_ORDER_SINGLE_PRED(_Mid, _Last, _Pred, false);
; 2299 : 
; 2300 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))

	mov	edx, DWORD PTR __Mid$227998[ebp]
	mov	DWORD PTR $T237448[ebp], edx
	mov	eax, DWORD PTR $T237448[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Lower_boun

; 2301 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	mov	edx, DWORD PTR __Mid$227998[ebp]
	add	edx, 8
	mov	DWORD PTR __Mid$227998[ebp], edx
	mov	eax, DWORD PTR __Mid$227998[ebp]
	mov	DWORD PTR __First$[ebp], eax
	mov	ecx, DWORD PTR __Count2$227997[ebp]
	add	ecx, 1
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, ecx
	mov	DWORD PTR __Count$[ebp], edx

; 2302 : 		else

	jmp	SHORT $LN1@Lower_boun
$LN2@Lower_boun:

; 2303 : 			_Count = _Count2;

	mov	eax, DWORD PTR __Count2$227997[ebp]
	mov	DWORD PTR __Count$[ebp], eax
$LN1@Lower_boun:

; 2304 : 		}

	jmp	SHORT $LN4@Lower_boun
$LN3@Lower_boun:

; 2305 : 	return (_First);

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2306 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Lower_bound@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProduction@@HUCityAndProductionEval@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@0ABUCityAndProduction@@UCityAndProductionEval@@PAH@Z ENDP ; std::_Lower_bound<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProduction,int,CityAndProductionEval>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Upper_bound@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProduction@@HUCityAndProductionEval@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@0ABUCityAndProduction@@UCityAndProductionEval@@PAH@Z
_TEXT	SEGMENT
$T237539 = -36						; size = 4
$T237497 = -28						; size = 4
$T237484 = -24						; size = 4
$T237483 = -20						; size = 4
__Count2$228007 = -12					; size = 4
__Mid$228008 = -8					; size = 4
__Count$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
___formal$ = 28						; size = 4
??$_Upper_bound@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProduction@@HUCityAndProductionEval@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@0ABUCityAndProduction@@UCityAndProductionEval@@PAH@Z PROC ; std::_Upper_bound<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProduction,int,CityAndProductionEval>, COMDAT

; 2359 : 	{	// find first element that _Val is before, using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 2360 : 	_DEBUG_POINTER(_Pred);
; 2361 : 	_DEBUG_ORDER_SINGLE_PRED(_First, _Last, _Pred, true);
; 2362 : 	_Diff _Count = 0;

	mov	DWORD PTR __Count$[ebp], 0

; 2363 : 	_Distance(_First, _Last, _Count);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T237497[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T237484[ebp], ecx
	mov	edx, DWORD PTR $T237497[ebp]
	mov	DWORD PTR $T237483[ebp], edx
	mov	eax, DWORD PTR $T237484[ebp]
	sub	eax, DWORD PTR $T237483[ebp]
	sar	eax, 3
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax
$LN4@Upper_boun:

; 2364 : 	for (; 0 < _Count; )

	cmp	DWORD PTR __Count$[ebp], 0
	jle	SHORT $LN3@Upper_boun

; 2365 : 		{	// divide and conquer, find half that contains answer
; 2366 : 		_Diff _Count2 = _Count / 2;

	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2$228007[ebp], eax

; 2367 : 		_FwdIt _Mid = _First;

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$228008[ebp], ecx

; 2368 : 		std::advance(_Mid, _Count2);

	mov	edx, DWORD PTR __Count2$228007[ebp]
	mov	eax, DWORD PTR __Mid$228008[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR __Mid$228008[ebp], ecx

; 2369 : 		_DEBUG_ORDER_SINGLE_PRED(_Mid, _Last, _Pred, false);
; 2370 : 
; 2371 : 		if (!_DEBUG_LT_PRED(_Pred, _Val, *_Mid))

	mov	edx, DWORD PTR __Mid$228008[ebp]
	mov	DWORD PTR $T237539[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR $T237539[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@Upper_boun

; 2372 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	mov	edx, DWORD PTR __Mid$228008[ebp]
	add	edx, 8
	mov	DWORD PTR __Mid$228008[ebp], edx
	mov	eax, DWORD PTR __Mid$228008[ebp]
	mov	DWORD PTR __First$[ebp], eax
	mov	ecx, DWORD PTR __Count2$228007[ebp]
	add	ecx, 1
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, ecx
	mov	DWORD PTR __Count$[ebp], edx

; 2373 : 		else

	jmp	SHORT $LN1@Upper_boun
$LN2@Upper_boun:

; 2374 : 			_Count = _Count2;

	mov	eax, DWORD PTR __Count2$228007[ebp]
	mov	DWORD PTR __Count$[ebp], eax
$LN1@Upper_boun:

; 2375 : 		}

	jmp	SHORT $LN4@Upper_boun
$LN3@Upper_boun:

; 2376 : 	return (_First);

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2377 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Upper_bound@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProduction@@HUCityAndProductionEval@@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@0ABUCityAndProduction@@UCityAndProductionEval@@PAH@Z ENDP ; std::_Upper_bound<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProduction,int,CityAndProductionEval>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??4?$_Temp_iterator@UCityAndProduction@@@std@@QAEAAV01@ABUCityAndProduction@@@Z
_TEXT	SEGMENT
tv128 = -20						; size = 4
_this$ = -16						; size = 4
$T237563 = -12						; size = 4
__Vptr$237561 = -8					; size = 4
__Ptr$228169 = -4					; size = 4
__Val$ = 8						; size = 4
??4?$_Temp_iterator@UCityAndProduction@@@std@@QAEAAV01@ABUCityAndProduction@@@Z PROC ; std::_Temp_iterator<CityAndProduction>::operator=, COMDAT
; _this$ = ecx

; 562  : 		{	// assign or construct value into active buffer, and increment

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 563  : 		if (_Pbuf->_Current < _Pbuf->_Hiwater)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN2@operator

; 564  : 			*_Pbuf->_Current++ = _Val;	// below high water mark, assign

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+16]
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 8
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+4], edx

; 565  : 		else

	jmp	SHORT $LN1@operator
$LN2@operator:

; 566  : 			{	// above high water mark, construct
; 567  : 			_SCL_SECURE_VALIDATE((_Pbuf->_Current - _Pbuf->_Begin) < _Pbuf->_Size);
; 568  : 			_Pty _Ptr = &*_Pbuf->_Current;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Ptr$228169[ebp], ecx

; 569  : 			_Construct(_Ptr, _Val);

	mov	edx, DWORD PTR __Ptr$228169[ebp]
	mov	DWORD PTR __Vptr$237561[ebp], edx
	mov	eax, DWORD PTR __Vptr$237561[ebp]
	mov	DWORD PTR $T237563[ebp], eax
	cmp	DWORD PTR $T237563[ebp], 0
	je	SHORT $LN7@operator
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T237563[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T237563[ebp]
	mov	DWORD PTR tv128[ebp], edx
	jmp	SHORT $LN5@operator
$LN7@operator:
	mov	DWORD PTR tv128[ebp], 0
$LN5@operator:

; 570  : 			_Pbuf->_Hiwater = ++_Pbuf->_Current;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 8
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], eax
$LN1@operator:

; 571  : 			}
; 572  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 573  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$_Temp_iterator@UCityAndProduction@@@std@@QAEAAV01@ABUCityAndProduction@@@Z ENDP ; std::_Temp_iterator<CityAndProduction>::operator=
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T237594 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Copy_backward_opt@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::random_access_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
	push	ecx

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

$LN5@Copy_backw:
	mov	eax, DWORD PTR __First$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN1@Copy_backw

; 2676 : 		*--_Dest = *--_Last;

	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, 8
	mov	DWORD PTR __Last$[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T237594[ebp], edx
	mov	eax, DWORD PTR __Dest$[ebp]
	sub	eax, 8
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR $T237594[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN5@Copy_backw
$LN1@Copy_backw:

; 2677 : 	return (_Dest);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2678 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@V?$_Temp_iterator@UCityAndProduction@@@2@UCityAndProductionEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UCityAndProduction@@@0@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@000V10@UCityAndProductionEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction>,CityAndProductionEval,std::forward_iterator_tag>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$unchecked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@V?$_Temp_iterator@UCityAndProduction@@@2@UCityAndProductionEval@@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@000V12@UCityAndProductionEval@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$unchecked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@V?$_Temp_iterator@UCityAndProduction@@@2@UCityAndProductionEval@@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@000V12@UCityAndProductionEval@@@Z$0
__ehfuncinfo$??$unchecked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@V?$_Temp_iterator@UCityAndProduction@@@2@UCityAndProductionEval@@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@000V12@UCityAndProductionEval@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$unchecked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@V?$_Temp_iterator@UCityAndProduction@@@2@UCityAndProductionEval@@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@000V12@UCityAndProductionEval@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$unchecked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@V?$_Temp_iterator@UCityAndProduction@@@2@UCityAndProductionEval@@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@000V12@UCityAndProductionEval@@@Z
_TEXT	SEGMENT
tv135 = -48						; size = 4
tv134 = -44						; size = 4
$T237641 = -40						; size = 4
__Next$237649 = -36					; size = 4
$T237633 = -32						; size = 4
$T237619 = -24						; size = 4
$T237615 = -20						; size = 4
$T237614 = -14						; size = 1
$T237613 = -13						; size = 1
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
__Pred$ = 48						; size = 1
??$unchecked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@V?$_Temp_iterator@UCityAndProduction@@@2@UCityAndProductionEval@@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@000V12@UCityAndProductionEval@@@Z PROC ; stdext::unchecked_merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction>,CityAndProductionEval>, COMDAT

; 5157 : 	{	//  copy merging ranges, both using _Pred

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$unchecked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@V?$_Temp_iterator@UCityAndProduction@@@2@UCityAndProductionEval@@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@000V12@UCityAndProductionEval@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T237619[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5158 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest, _Pred,
; 5159 : 			_STD _Iter_random(_First1, _First2,_Dest), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T237613[ebp], al
	movzx	ecx, BYTE PTR $T237613[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T237614[ebp]
	push	edx
	movzx	eax, BYTE PTR __Pred$[ebp]
	push	eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	DWORD PTR $T237615[ebp], esp
	mov	DWORD PTR $T237633[ebp], ecx
	mov	edx, DWORD PTR $T237633[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T237633[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR $T237633[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR $T237633[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR $T237633[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR $T237633[ebp]
	mov	DWORD PTR tv134[ebp], edx
	mov	eax, DWORD PTR __Last2$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last1$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	??$_Merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@V?$_Temp_iterator@UCityAndProduction@@@2@UCityAndProductionEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UCityAndProduction@@@0@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@000V10@UCityAndProductionEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction>,CityAndProductionEval,std::forward_iterator_tag>
	add	esp, 52					; 00000034H
	mov	DWORD PTR tv135[ebp], eax
	mov	edx, DWORD PTR $T237619[ebp]
	or	edx, 1
	mov	DWORD PTR $T237619[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN17@unchecked_@2
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$237649[ebp], eax
	jmp	SHORT $LN15@unchecked_@2
$LN14@unchecked_@2:
	mov	ecx, DWORD PTR __Next$237649[ebp]
	add	ecx, 8
	mov	DWORD PTR __Next$237649[ebp], ecx
$LN15@unchecked_@2:
	mov	edx, DWORD PTR __Next$237649[ebp]
	cmp	edx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN13@unchecked_@2
	jmp	SHORT $LN14@unchecked_@2
$LN13@unchecked_@2:
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T237641[ebp], eax
	mov	ecx, DWORD PTR $T237641[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@unchecked_@2:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 5160 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$unchecked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@V?$_Temp_iterator@UCityAndProduction@@@2@UCityAndProductionEval@@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@000V12@UCityAndProductionEval@@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@UCityAndProduction@@@std@@QAE@XZ ; std::_Temp_iterator<CityAndProduction>::~_Temp_iterator<CityAndProduction>
__ehhandler$??$unchecked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@V?$_Temp_iterator@UCityAndProduction@@@2@UCityAndProductionEval@@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@000V12@UCityAndProductionEval@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$unchecked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@V?$_Temp_iterator@UCityAndProduction@@@2@UCityAndProductionEval@@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@000V12@UCityAndProductionEval@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$unchecked_merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@V?$_Temp_iterator@UCityAndProduction@@@2@UCityAndProductionEval@@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@000V12@UCityAndProductionEval@@@Z ENDP ; stdext::unchecked_merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction>,CityAndProductionEval>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_merge@PAUCityAndProduction@@PAU1@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@@stdext@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@PAUCityAndProduction@@000V12@UCityAndProductionEval@@@Z
_TEXT	SEGMENT
$T237662 = -2						; size = 1
$T237661 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
__Pred$ = 32						; size = 1
??$unchecked_merge@PAUCityAndProduction@@PAU1@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@@stdext@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@PAUCityAndProduction@@000V12@UCityAndProductionEval@@@Z PROC ; stdext::unchecked_merge<CityAndProduction *,CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval>, COMDAT

; 5157 : 	{	//  copy merging ranges, both using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 5158 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest, _Pred,
; 5159 : 			_STD _Iter_random(_First1, _First2,_Dest), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T237661[ebp], al
	movzx	ecx, BYTE PTR $T237661[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T237662[ebp]
	push	edx
	movzx	eax, BYTE PTR __Pred$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First2$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last1$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??$_Merge@PAUCityAndProduction@@PAU1@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@PAUCityAndProduction@@000V10@UCityAndProductionEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CityAndProduction *,CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval,std::random_access_iterator_tag>
	add	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 5160 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_merge@PAUCityAndProduction@@PAU1@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@@stdext@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@PAUCityAndProduction@@000V12@UCityAndProductionEval@@@Z ENDP ; stdext::unchecked_merge<CityAndProduction *,CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T237874 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Copy_opt@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::random_access_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp
	push	ecx

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN14@Copy_opt@2
$LN2@Copy_opt@2:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 8
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 8
	mov	DWORD PTR __First$[ebp], ecx
$LN14@Copy_opt@2:
	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@Copy_opt@2

; 2472 : 		*_Dest = *_First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T237874[ebp], eax
	mov	ecx, DWORD PTR $T237874[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN2@Copy_opt@2
$LN1@Copy_opt@2:

; 2473 : 	return (_Dest);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2474 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::random_access_iterator_tag>
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@V?$_Temp_iterator@UCityAndProduction@@@2@UCityAndProductionEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UCityAndProduction@@@0@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@000V10@UCityAndProductionEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@V?$_Temp_iterator@UCityAndProduction@@@2@UCityAndProductionEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UCityAndProduction@@@0@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@000V10@UCityAndProductionEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__ehfuncinfo$??$_Merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@V?$_Temp_iterator@UCityAndProduction@@@2@UCityAndProductionEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UCityAndProduction@@@0@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@000V10@UCityAndProductionEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@V?$_Temp_iterator@UCityAndProduction@@@2@UCityAndProductionEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UCityAndProduction@@@0@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@000V10@UCityAndProductionEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@V?$_Temp_iterator@UCityAndProduction@@@2@UCityAndProductionEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UCityAndProduction@@@0@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@000V10@UCityAndProductionEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv197 = -128						; size = 4
tv196 = -124						; size = 4
tv192 = -120						; size = 4
tv191 = -116						; size = 4
$T238055 = -112						; size = 4
__Next$238063 = -108					; size = 4
$T238047 = -104						; size = 4
$T238027 = -100						; size = 4
__Next$238035 = -96					; size = 4
$T238019 = -92						; size = 4
$T238015 = -88						; size = 4
$T237979 = -72						; size = 4
$T237943 = -56						; size = 4
$T237931 = -52						; size = 4
$T237922 = -48						; size = 4
$T237893 = -44						; size = 4
$T237887 = -40						; size = 4
$T237886 = -36						; size = 20
$T237885 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
__Pred$ = 48						; size = 1
___formal$ = 52						; size = 1
___formal$ = 56						; size = 1
??$_Merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@V?$_Temp_iterator@UCityAndProduction@@@2@UCityAndProductionEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UCityAndProduction@@@0@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@000V10@UCityAndProductionEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction>,CityAndProductionEval,std::forward_iterator_tag>, COMDAT

; 2593 : 	{	//  copy merging ranges, both using _Pred

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@V?$_Temp_iterator@UCityAndProduction@@@2@UCityAndProductionEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UCityAndProduction@@@0@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@000V10@UCityAndProductionEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 116				; 00000074H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T237893[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2594 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2595 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2596 : 	_DEBUG_POINTER(_Dest);
; 2597 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

$LN16@Merge@2:
	mov	eax, DWORD PTR __First1$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last1$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN3@Merge@2
	mov	ecx, DWORD PTR __First2$[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR __Last2$[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@Merge@2

; 2598 : 		if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))

	mov	edx, DWORD PTR __First1$[ebp]
	mov	DWORD PTR $T237922[ebp], edx
	mov	eax, DWORD PTR __First2$[ebp]
	mov	DWORD PTR $T237931[ebp], eax
	mov	ecx, DWORD PTR $T237931[ebp]
	mov	edx, DWORD PTR $T237922[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN56@Merge@2

; 2599 : 			*_Dest = *_First2, ++_First2;

	mov	eax, DWORD PTR __First2$[ebp]
	mov	DWORD PTR $T237943[ebp], eax
	mov	ecx, DWORD PTR $T237943[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??4?$_Temp_iterator@UCityAndProduction@@@std@@QAEAAV01@ABUCityAndProduction@@@Z ; std::_Temp_iterator<CityAndProduction>::operator=
	mov	edx, DWORD PTR __First2$[ebp]
	add	edx, 8
	mov	DWORD PTR __First2$[ebp], edx

; 2600 : 		else

	jmp	SHORT $LN1@Merge@2

; 2601 : 			*_Dest = *_First1, ++_First1;

$LN56@Merge@2:
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR $T237979[ebp], eax
	mov	ecx, DWORD PTR $T237979[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??4?$_Temp_iterator@UCityAndProduction@@@std@@QAEAAV01@ABUCityAndProduction@@@Z ; std::_Temp_iterator<CityAndProduction>::operator=
	mov	edx, DWORD PTR __First1$[ebp]
	add	edx, 8
	mov	DWORD PTR __First1$[ebp], edx
$LN1@Merge@2:
	jmp	$LN16@Merge@2
$LN3@Merge@2:

; 2602 : 
; 2603 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T237885[ebp], esp
	mov	DWORD PTR $T238015[ebp], eax
	mov	ecx, DWORD PTR $T238015[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T238015[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T238015[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T238015[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T238015[ebp]
	mov	eax, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR $T238015[ebp]
	mov	DWORD PTR tv191[ebp], ecx
	mov	edx, DWORD PTR __Last1$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T237886[ebp]
	push	ecx
	call	??$unchecked_copy@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv192[ebp], eax
	mov	edx, DWORD PTR tv192[ebp]
	mov	DWORD PTR $T238019[ebp], edx
	mov	eax, DWORD PTR $T238019[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR __Dest$[ebp+16], ecx
	cmp	DWORD PTR $T237886[ebp], 0
	je	SHORT $LN84@Merge@2
	mov	edx, DWORD PTR $T237886[ebp]
	mov	DWORD PTR __Next$238035[ebp], edx
	jmp	SHORT $LN82@Merge@2
$LN81@Merge@2:
	mov	eax, DWORD PTR __Next$238035[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$238035[ebp], eax
$LN82@Merge@2:
	mov	ecx, DWORD PTR __Next$238035[ebp]
	cmp	ecx, DWORD PTR $T237886[ebp+8]
	je	SHORT $LN80@Merge@2
	jmp	SHORT $LN81@Merge@2
$LN80@Merge@2:
	mov	edx, DWORD PTR $T237886[ebp]
	mov	DWORD PTR $T238027[ebp], edx
	mov	eax, DWORD PTR $T238027[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN84@Merge@2:

; 2604 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	DWORD PTR $T237887[ebp], esp
	mov	DWORD PTR $T238047[ebp], ecx
	mov	edx, DWORD PTR $T238047[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T238047[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR $T238047[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR $T238047[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR $T238047[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR $T238047[ebp]
	mov	DWORD PTR tv196[ebp], edx
	mov	eax, DWORD PTR __Last2$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??$unchecked_copy@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V?$_Temp_iterator@UCityAndProduction@@@2@@stdext@@YA?AV?$_Temp_iterator@UCityAndProduction@@@std@@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv197[ebp], eax
	mov	eax, DWORD PTR $T237893[ebp]
	or	eax, 1
	mov	DWORD PTR $T237893[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN98@Merge@2
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$238063[ebp], ecx
	jmp	SHORT $LN96@Merge@2
$LN95@Merge@2:
	mov	edx, DWORD PTR __Next$238063[ebp]
	add	edx, 8
	mov	DWORD PTR __Next$238063[ebp], edx
$LN96@Merge@2:
	mov	eax, DWORD PTR __Next$238063[ebp]
	cmp	eax, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN94@Merge@2
	jmp	SHORT $LN95@Merge@2
$LN94@Merge@2:
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T238055[ebp], ecx
	mov	edx, DWORD PTR $T238055[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN98@Merge@2:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2605 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@V?$_Temp_iterator@UCityAndProduction@@@2@UCityAndProductionEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UCityAndProduction@@@0@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@000V10@UCityAndProductionEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@UCityAndProduction@@@std@@QAE@XZ ; std::_Temp_iterator<CityAndProduction>::~_Temp_iterator<CityAndProduction>
__ehhandler$??$_Merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@V?$_Temp_iterator@UCityAndProduction@@@2@UCityAndProductionEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UCityAndProduction@@@0@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@000V10@UCityAndProductionEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-120]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@V?$_Temp_iterator@UCityAndProduction@@@2@UCityAndProductionEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UCityAndProduction@@@0@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@000V10@UCityAndProductionEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Merge@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@V12@V?$_Temp_iterator@UCityAndProduction@@@2@UCityAndProductionEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UCityAndProduction@@@0@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@000V10@UCityAndProductionEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,std::_Temp_iterator<CityAndProduction>,CityAndProductionEval,std::forward_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Merge@PAUCityAndProduction@@PAU1@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@PAUCityAndProduction@@000V10@UCityAndProductionEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T238246 = -60						; size = 4
$T238245 = -56						; size = 4
$T238220 = -50						; size = 1
$T238219 = -49						; size = 1
$T238218 = -48						; size = 4
$T238217 = -44						; size = 4
__Cat$238227 = -36					; size = 1
$T238224 = -35						; size = 1
$T238223 = -34						; size = 1
$T238222 = -33						; size = 1
$T238174 = -32						; size = 4
$T238173 = -28						; size = 4
$T238148 = -22						; size = 1
$T238147 = -21						; size = 1
$T238146 = -20						; size = 4
$T238145 = -16						; size = 4
__Cat$238155 = -8					; size = 1
$T238152 = -7						; size = 1
$T238151 = -6						; size = 1
$T238150 = -5						; size = 1
$T238075 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
__Pred$ = 32						; size = 1
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
??$_Merge@PAUCityAndProduction@@PAU1@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@PAUCityAndProduction@@000V10@UCityAndProductionEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CityAndProduction *,CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval,std::random_access_iterator_tag>, COMDAT

; 2593 : 	{	//  copy merging ranges, both using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 2594 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2595 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2596 : 	_DEBUG_POINTER(_Dest);
; 2597 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	jmp	SHORT $LN5@Merge@3
$LN4@Merge@3:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 8
	mov	DWORD PTR __Dest$[ebp], eax
$LN5@Merge@3:
	mov	ecx, DWORD PTR __First1$[ebp]
	cmp	ecx, DWORD PTR __Last1$[ebp]
	je	SHORT $LN3@Merge@3
	mov	edx, DWORD PTR __First2$[ebp]
	cmp	edx, DWORD PTR __Last2$[ebp]
	je	SHORT $LN3@Merge@3

; 2598 : 		if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))

	mov	eax, DWORD PTR __First2$[ebp]
	mov	ecx, DWORD PTR __First1$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN18@Merge@3

; 2599 : 			*_Dest = *_First2, ++_First2;

	mov	edx, DWORD PTR __First2$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR __First2$[ebp]
	add	eax, 8
	mov	DWORD PTR __First2$[ebp], eax

; 2600 : 		else

	jmp	SHORT $LN1@Merge@3

; 2601 : 			*_Dest = *_First1, ++_First1;

$LN18@Merge@3:
	mov	ecx, DWORD PTR __First1$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __First1$[ebp]
	add	edx, 8
	mov	DWORD PTR __First1$[ebp], edx
$LN1@Merge@3:
	jmp	SHORT $LN4@Merge@3
$LN3@Merge@3:

; 2602 : 
; 2603 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T238174[ebp], eax
	mov	ecx, DWORD PTR __First1$[ebp]
	mov	DWORD PTR $T238173[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T238150[ebp], dl
	mov	al, BYTE PTR __Cat$238155[ebp]
	mov	BYTE PTR $T238151[ebp], al
	mov	cl, BYTE PTR $T238150[ebp]
	mov	BYTE PTR $T238148[ebp], cl
	mov	dl, BYTE PTR $T238152[ebp]
	mov	BYTE PTR $T238147[ebp], dl
	mov	eax, DWORD PTR $T238174[ebp]
	mov	DWORD PTR $T238146[ebp], eax
	mov	ecx, DWORD PTR $T238173[ebp]
	mov	DWORD PTR $T238145[ebp], ecx
	jmp	SHORT $LN30@Merge@3
$LN29@Merge@3:
	mov	edx, DWORD PTR $T238146[ebp]
	add	edx, 8
	mov	DWORD PTR $T238146[ebp], edx
	mov	eax, DWORD PTR $T238145[ebp]
	add	eax, 8
	mov	DWORD PTR $T238145[ebp], eax
$LN30@Merge@3:
	mov	ecx, DWORD PTR $T238145[ebp]
	cmp	ecx, DWORD PTR __Last1$[ebp]
	je	SHORT $LN28@Merge@3
	mov	edx, DWORD PTR $T238145[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T238146[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN29@Merge@3
$LN28@Merge@3:
	mov	eax, DWORD PTR $T238146[ebp]
	mov	DWORD PTR $T238075[ebp], eax
	mov	ecx, DWORD PTR $T238075[ebp]
	mov	DWORD PTR __Dest$[ebp], ecx

; 2604 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T238246[ebp], edx
	mov	eax, DWORD PTR __First2$[ebp]
	mov	DWORD PTR $T238245[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T238222[ebp], cl
	mov	dl, BYTE PTR __Cat$238227[ebp]
	mov	BYTE PTR $T238223[ebp], dl
	mov	al, BYTE PTR $T238222[ebp]
	mov	BYTE PTR $T238220[ebp], al
	mov	cl, BYTE PTR $T238224[ebp]
	mov	BYTE PTR $T238219[ebp], cl
	mov	edx, DWORD PTR $T238246[ebp]
	mov	DWORD PTR $T238218[ebp], edx
	mov	eax, DWORD PTR $T238245[ebp]
	mov	DWORD PTR $T238217[ebp], eax
	jmp	SHORT $LN49@Merge@3
$LN48@Merge@3:
	mov	ecx, DWORD PTR $T238218[ebp]
	add	ecx, 8
	mov	DWORD PTR $T238218[ebp], ecx
	mov	edx, DWORD PTR $T238217[ebp]
	add	edx, 8
	mov	DWORD PTR $T238217[ebp], edx
$LN49@Merge@3:
	mov	eax, DWORD PTR $T238217[ebp]
	cmp	eax, DWORD PTR __Last2$[ebp]
	je	SHORT $LN47@Merge@3
	mov	ecx, DWORD PTR $T238217[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T238218[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN48@Merge@3
$LN47@Merge@3:
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR $T238218[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2605 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Merge@PAUCityAndProduction@@PAU1@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@UCityAndProductionEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@PAUCityAndProduction@@000V10@UCityAndProductionEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CityAndProduction *,CityAndProduction *,std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,CityAndProductionEval,std::random_access_iterator_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Rotate@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@00PAHPAUCityAndProduction@@@Z
_TEXT	SEGMENT
tv193 = -96						; size = 4
tv149 = -92						; size = 4
__Tmp$238410 = -88					; size = 4
$T238399 = -84						; size = 4
__Tmp$238385 = -80					; size = 4
$T238358 = -76						; size = 4
__Tmp$238336 = -72					; size = 4
__Tmp$238317 = -68					; size = 4
__Tmp$238293 = -64					; size = 4
$T238256 = -60						; size = 4
$T238255 = -56						; size = 4
$T238254 = -52						; size = 4
$T238251 = -48						; size = 4
$T238250 = -44						; size = 4
$T238249 = -40						; size = 4
__Hole$228397 = -36					; size = 4
__Holeval$228400 = -32					; size = 8
__Next1$228401 = -24					; size = 4
__Next$228399 = -20					; size = 4
__Tmp$228392 = -16					; size = 4
__Factor$228388 = -12					; size = 4
__Shift$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Rotate@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@00PAHPAUCityAndProduction@@@Z PROC ; std::_Rotate<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction>, COMDAT

; 1679 : 	{	// rotate [_First, _Last), random-access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H

; 1680 : 	_DEBUG_RANGE(_First, _Mid);
; 1681 : 	_DEBUG_RANGE(_Mid, _Last);
; 1682 : 	_Diff _Shift = _Mid - _First;

	mov	eax, DWORD PTR __Mid$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	mov	DWORD PTR __Shift$[ebp], eax

; 1683 : 	_Diff _Count = _Last - _First;

	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 3
	mov	DWORD PTR __Count$[ebp], ecx

; 1684 : 
; 1685 : 	for (_Diff _Factor = _Shift; _Factor != 0; )

	mov	edx, DWORD PTR __Shift$[ebp]
	mov	DWORD PTR __Factor$228388[ebp], edx
$LN8@Rotate:
	cmp	DWORD PTR __Factor$228388[ebp], 0
	je	SHORT $LN23@Rotate

; 1686 : 		{	// find subcycle count as GCD of shift count and length
; 1687 : 		_Diff _Tmp = _Count % _Factor;

	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	idiv	DWORD PTR __Factor$228388[ebp]
	mov	DWORD PTR __Tmp$228392[ebp], edx

; 1688 : 		_Count = _Factor, _Factor = _Tmp;

	mov	eax, DWORD PTR __Factor$228388[ebp]
	mov	DWORD PTR __Count$[ebp], eax
	mov	ecx, DWORD PTR __Tmp$228392[ebp]
	mov	DWORD PTR __Factor$228388[ebp], ecx

; 1689 : 		}

	jmp	SHORT $LN8@Rotate

; 1690 : 
; 1691 : 	if (_Count < _Last - _First)

$LN23@Rotate:
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __First$[ebp]
	sar	edx, 3
	cmp	DWORD PTR __Count$[ebp], edx
	jge	$LN9@Rotate

; 1692 : 		for (; 0 < _Count; --_Count)

	jmp	SHORT $LN5@Rotate
$LN4@Rotate:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
$LN5@Rotate:
	cmp	DWORD PTR __Count$[ebp], 0
	jle	$LN9@Rotate

; 1693 : 			{	// rotate each subcycle
; 1694 : 			_RanIt _Hole = _First + _Count;

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$238293[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Tmp$238293[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR __Tmp$238293[ebp], ecx
	mov	edx, DWORD PTR __Tmp$238293[ebp]
	mov	DWORD PTR __Hole$228397[ebp], edx

; 1695 : 			_RanIt _Next = _Hole;

	mov	eax, DWORD PTR __Hole$228397[ebp]
	mov	DWORD PTR __Next$228399[ebp], eax

; 1696 : 			_Ty _Holeval = *_Hole;

	mov	ecx, DWORD PTR __Hole$228397[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Holeval$228400[ebp], edx
	mov	DWORD PTR __Holeval$228400[ebp+4], eax

; 1697 : 			_RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;

	mov	ecx, DWORD PTR __Next$228399[ebp]
	mov	DWORD PTR __Tmp$238317[ebp], ecx
	mov	edx, DWORD PTR __Shift$[ebp]
	mov	eax, DWORD PTR __Tmp$238317[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR __Tmp$238317[ebp], ecx
	mov	edx, DWORD PTR __Tmp$238317[ebp]
	mov	DWORD PTR $T238250[ebp], edx
	mov	eax, DWORD PTR $T238250[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last$[ebp]
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN11@Rotate
	lea	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR tv149[ebp], eax
	jmp	SHORT $LN12@Rotate
$LN11@Rotate:
	mov	ecx, DWORD PTR __Next$228399[ebp]
	mov	DWORD PTR __Tmp$238336[ebp], ecx
	mov	edx, DWORD PTR __Shift$[ebp]
	mov	eax, DWORD PTR __Tmp$238336[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR __Tmp$238336[ebp], ecx
	mov	edx, DWORD PTR __Tmp$238336[ebp]
	mov	DWORD PTR $T238251[ebp], edx
	lea	eax, DWORD PTR $T238251[ebp]
	mov	DWORD PTR tv149[ebp], eax
$LN12@Rotate:
	mov	ecx, DWORD PTR tv149[ebp]
	mov	DWORD PTR $T238249[ebp], ecx
	mov	edx, DWORD PTR $T238249[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Next1$228401[ebp], eax

; 1698 : 			while (_Next1 != _Hole)

$LN51@Rotate:
	mov	ecx, DWORD PTR __Next1$228401[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR __Hole$228397[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	$LN83@Rotate

; 1699 : 				{	// percolate elements back around subcycle
; 1700 : 				*_Next = *_Next1;

	mov	edx, DWORD PTR __Next1$228401[ebp]
	mov	DWORD PTR $T238358[ebp], edx
	mov	eax, DWORD PTR $T238358[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Next$228399[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 1701 : 				_Next = _Next1;

	mov	ecx, DWORD PTR __Next1$228401[ebp]
	mov	DWORD PTR __Next$228399[ebp], ecx

; 1702 : 				_Next1 = _Shift < _Last - _Next1 ? _Next1 + _Shift
; 1703 : 					: _First + (_Shift - (_Last - _Next1));

	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __Next1$228401[ebp]
	sar	edx, 3
	cmp	DWORD PTR __Shift$[ebp], edx
	jge	SHORT $LN75@Rotate
	mov	eax, DWORD PTR __Next1$228401[ebp]
	mov	DWORD PTR __Tmp$238385[ebp], eax
	mov	ecx, DWORD PTR __Shift$[ebp]
	mov	edx, DWORD PTR __Tmp$238385[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR __Tmp$238385[ebp], eax
	mov	ecx, DWORD PTR __Tmp$238385[ebp]
	mov	DWORD PTR $T238255[ebp], ecx
	lea	edx, DWORD PTR $T238255[ebp]
	mov	DWORD PTR tv193[ebp], edx
	jmp	SHORT $LN14@Rotate
$LN75@Rotate:
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __Next1$228401[ebp]
	sar	eax, 3
	mov	DWORD PTR $T238399[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$238410[ebp], ecx
	mov	edx, DWORD PTR __Shift$[ebp]
	sub	edx, DWORD PTR $T238399[ebp]
	mov	eax, DWORD PTR __Tmp$238410[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR __Tmp$238410[ebp], ecx
	mov	edx, DWORD PTR __Tmp$238410[ebp]
	mov	DWORD PTR $T238256[ebp], edx
	lea	eax, DWORD PTR $T238256[ebp]
	mov	DWORD PTR tv193[ebp], eax
$LN14@Rotate:
	mov	ecx, DWORD PTR tv193[ebp]
	mov	DWORD PTR $T238254[ebp], ecx
	mov	edx, DWORD PTR $T238254[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Next1$228401[ebp], eax

; 1704 : 				}

	jmp	$LN51@Rotate

; 1705 : 			*_Next = _Holeval;

$LN83@Rotate:
	mov	ecx, DWORD PTR __Next$228399[ebp]
	mov	edx, DWORD PTR __Holeval$228400[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Holeval$228400[ebp+4]
	mov	DWORD PTR [ecx+4], eax

; 1706 : 			}

	jmp	$LN4@Rotate
$LN9@Rotate:

; 1707 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Rotate@V?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@std@@HUCityAndProduction@@@std@@YAXV?$_Vector_iterator@UCityAndProduction@@V?$allocator@UCityAndProduction@@@std@@@0@00PAHPAUCityAndProduction@@@Z ENDP ; std::_Rotate<std::_Vector_iterator<CityAndProduction,std::allocator<CityAndProduction> >,int,CityAndProduction>
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT

; 298  : {

	push	ebp
	mov	ebp, esp

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	DWORD PTR _p$[ebp], 0
	jl	SHORT $LN1@teamType
	cmp	DWORD PTR _p$[ebp], 64			; 00000040H
	jge	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	eax, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN2@teamType
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1
$LN2@teamType:

; 302  : }

	pop	ebp
	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T238444 = -4						; size = 4
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ PROC		; CvPlot::getPlotCity, COMDAT
; _this$ = ecx

; 532  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 533  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+104], 0
	jl	SHORT $LN1@getPlotCit
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+104], 64			; 00000040H
	jge	SHORT $LN1@getPlotCit

; 534  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T238444[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	mov	ecx, DWORD PTR $T238444[ebp]
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	jmp	SHORT $LN2@getPlotCit
$LN1@getPlotCit:

; 535  : 
; 536  : 		return NULL;

	xor	eax, eax
$LN2@getPlotCit:

; 537  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ ENDP		; CvPlot::getPlotCity
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
_TEXT	ENDS
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
tv72 = -16						; size = 4
_this$ = -12						; size = 4
$T238456 = -8						; size = 4
$T238452 = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	cmp	DWORD PTR _iX$[ebp], 0
	jl	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T238452[ebp], ecx
	mov	edx, DWORD PTR _iX$[ebp]
	cmp	edx, DWORD PTR $T238452[ebp]
	jge	SHORT $LN3@isPlot
	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T238456[ebp], ecx
	mov	edx, DWORD PTR _iY$[ebp]
	cmp	edx, DWORD PTR $T238456[ebp]
	jge	SHORT $LN3@isPlot
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN4@isPlot
$LN3@isPlot:
	mov	DWORD PTR tv72[ebp], 0
$LN4@isPlot:
	mov	eax, DWORD PTR tv72[ebp]

; 161  : #endif
; 162  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Dec
PUBLIC	?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Insert
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z
_TEXT	SEGMENT
tv90 = -156						; size = 4
_this$ = -152						; size = 4
$T238591 = -148						; size = 4
$T238571 = -144						; size = 4
$T238556 = -140						; size = 4
$T238539 = -136						; size = 4
$T238526 = -132						; size = 4
$T238512 = -128						; size = 4
$T238468 = -45						; size = 1
$T238467 = -44						; size = 4
$T238466 = -37						; size = 1
$T238465 = -36						; size = 4
$T238464 = -29						; size = 1
$T238463 = -28						; size = 4
$T238462 = -24						; size = 4
$T238461 = -17						; size = 1
__Where$198767 = -16					; size = 4
__Trynode$ = -12					; size = 4
__Wherenode$ = -8					; size = 4
__Addleft$ = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert, COMDAT
; _this$ = ecx

; 630  : 		{	// try to insert node with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	mov	DWORD PTR _this$[ebp], ecx

; 631  : 		_Nodeptr _Trynode = _Root();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Trynode$[ebp], edx

; 632  : 		_Nodeptr _Wherenode = _Myhead;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 633  : 		bool _Addleft = true;	// add to left of head if tree empty

	mov	BYTE PTR __Addleft$[ebp], 1

; 634  : 		while (!_Isnil(_Trynode))

$LN19@insert@2:
	mov	edx, DWORD PTR __Trynode$[ebp]
	movsx	eax, BYTE PTR [edx+17]
	test	eax, eax
	jne	SHORT $LN9@insert@2

; 635  : 			{	// look for leaf to insert before (_Addleft) or after
; 636  : 			_Wherenode = _Trynode;

	mov	ecx, DWORD PTR __Trynode$[ebp]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 637  : 			_Addleft = _DEBUG_LT_PRED(this->comp,

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR __Trynode$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax+12]
	sbb	edx, edx
	neg	edx
	mov	BYTE PTR __Addleft$[ebp], dl

; 638  : 				this->_Kfn(_Val), _Key(_Trynode));
; 639  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

	movzx	eax, BYTE PTR __Addleft$[ebp]
	test	eax, eax
	je	SHORT $LN33@insert@2
	mov	ecx, DWORD PTR __Trynode$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv90[ebp], edx
	jmp	SHORT $LN14@insert@2
$LN33@insert@2:
	mov	eax, DWORD PTR __Trynode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv90[ebp], ecx
$LN14@insert@2:
	mov	edx, DWORD PTR tv90[ebp]
	mov	DWORD PTR __Trynode$[ebp], edx

; 640  : 			}

	jmp	SHORT $LN19@insert@2
$LN9@insert@2:

; 641  : 
; 642  : 		if (this->_Multi)

	xor	eax, eax
	je	SHORT $LN8@insert@2

; 643  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	BYTE PTR $T238461[ebp], 1
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	movzx	eax, BYTE PTR __Addleft$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T238462[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Insert
	mov	DWORD PTR $T238512[ebp], eax
	mov	edx, DWORD PTR $T238512[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	al, BYTE PTR $T238461[ebp]
	mov	BYTE PTR [edx+4], al
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN11@insert@2

; 644  : 		else

	jmp	$LN11@insert@2
$LN8@insert@2:

; 645  : 			{	// insert only if unique
; 646  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR __Where$198767[ebp], ecx

; 647  : 			if (!_Addleft)

	movzx	edx, BYTE PTR __Addleft$[ebp]
	test	edx, edx
	jne	SHORT $LN6@insert@2
	jmp	$LN79@insert@2
$LN6@insert@2:

; 648  : 				;	// need to test if insert after is okay
; 649  : 			else if (_Where == begin())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T238526[ebp], ecx
	mov	edx, DWORD PTR $T238526[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T238539[ebp], eax
	mov	ecx, DWORD PTR $T238539[ebp]
	mov	DWORD PTR $T238463[ebp], ecx
	mov	edx, DWORD PTR __Where$198767[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T238463[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@insert@2

; 650  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

	mov	BYTE PTR $T238464[ebp], 1
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	push	1
	lea	ecx, DWORD PTR $T238465[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Insert
	mov	DWORD PTR $T238556[ebp], eax
	mov	edx, DWORD PTR $T238556[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	al, BYTE PTR $T238464[ebp]
	mov	BYTE PTR [edx+4], al
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN11@insert@2

; 651  : 			else

	jmp	SHORT $LN79@insert@2
$LN4@insert@2:

; 652  : 				--_Where;	// need to test if insert before is okay

	lea	ecx, DWORD PTR __Where$198767[ebp]
	call	?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Dec

; 653  : 
; 654  : 			if (_DEBUG_LT_PRED(this->comp,

$LN79@insert@2:
	mov	ecx, DWORD PTR __Where$198767[ebp]
	mov	DWORD PTR $T238571[ebp], ecx
	mov	edx, DWORD PTR $T238571[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	cmp	ecx, DWORD PTR [eax]
	sbb	edx, edx
	neg	edx
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN2@insert@2

; 655  : 				_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 656  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	BYTE PTR $T238466[ebp], 1
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	movzx	eax, BYTE PTR __Addleft$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T238467[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Insert
	mov	DWORD PTR $T238591[ebp], eax
	mov	edx, DWORD PTR $T238591[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	al, BYTE PTR $T238466[ebp]
	mov	BYTE PTR [edx+4], al
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN11@insert@2

; 657  : 			else

	jmp	SHORT $LN11@insert@2
$LN2@insert@2:

; 658  : 				return (_Pairib(_Where, false));

	mov	BYTE PTR $T238468[ebp], 0
	mov	ecx, DWORD PTR __Where$198767[ebp]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	cl, BYTE PTR $T238468[ebp]
	mov	BYTE PTR [eax+4], cl
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN11@insert@2:

; 659  : 			}
; 660  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rrotate
PUBLIC	?_Lrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Lrotate
PUBLIC	?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Buynode
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z$0
__ehfuncinfo$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z
_TEXT	SEGMENT
tv277 = -196						; size = 4
_this$ = -192						; size = 4
$T239131 = -188						; size = 4
$T239043 = -172						; size = 4
$T238958 = -160						; size = 4
$T238942 = -156						; size = 4
$T238923 = -152						; size = 4
$T238919 = -148						; size = 4
$T238834 = -136						; size = 4
$T238733 = -120						; size = 4
$T238711 = -116						; size = 4
$T238704 = -112						; size = 4
$T238700 = -108						; size = 4
$T238661 = -104						; size = 4
$T238652 = -100						; size = 4
$T238632 = -96						; size = 4
__Count$238614 = -92					; size = 4
$T238598 = -88						; size = 28
$T238597 = -60						; size = 40
__Pnode$201484 = -20					; size = 4
__Newnode$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Insert, COMDAT
; _this$ = ecx

; 1187 : 		{	// add node with value next to _Wherenode, to left if _Addnode

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 184				; 000000b8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1188 : 		if (max_size() - 1 <= _Mysize)

	mov	DWORD PTR __Count$238614[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$238614[ebp], 0
	jbe	SHORT $LN25@Insert
	mov	eax, DWORD PTR __Count$238614[ebp]
	mov	DWORD PTR tv277[ebp], eax
	jmp	SHORT $LN21@Insert
$LN25@Insert:
	mov	DWORD PTR tv277[ebp], 1
$LN21@Insert:
	mov	ecx, DWORD PTR tv277[ebp]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR [edx+8]
	ja	SHORT $LN17@Insert

; 1189 : 			_THROW(length_error, "map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T238598[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T238598[ebp]
	push	eax
	lea	ecx, DWORD PTR $T238597[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR $T238597[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T238597[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T238598[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN17@Insert:

; 1190 : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1191 : 			_Val, _Red);

	push	0
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Buynode
	mov	DWORD PTR __Newnode$[ebp], eax

; 1192 : 
; 1193 : 		++_Mysize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1194 : 		if (_Wherenode == _Myhead)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Wherenode$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN16@Insert

; 1195 : 			{	// first node in tree, just set head values
; 1196 : 			_Root() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1197 : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T238632[ebp], edx
	mov	eax, DWORD PTR $T238632[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN15@Insert
$LN16@Insert:

; 1198 : 			}
; 1199 : 		else if (_Addleft)

	movzx	edx, BYTE PTR __Addleft$[ebp]
	test	edx, edx
	je	SHORT $LN52@Insert

; 1200 : 			{	// add to left of _Wherenode
; 1201 : 			_Left(_Wherenode) = _Newnode;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1202 : 			if (_Wherenode == _Lmost())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T238652[ebp], eax
	mov	ecx, DWORD PTR $T238652[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN13@Insert

; 1203 : 				_Lmost() = _Newnode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T238661[ebp], ecx
	mov	edx, DWORD PTR $T238661[ebp]
	mov	eax, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [edx], eax
$LN13@Insert:

; 1204 : 			}
; 1205 : 		else

	jmp	SHORT $LN15@Insert

; 1206 : 			{	// add to right of _Wherenode
; 1207 : 			_Right(_Wherenode) = _Newnode;

$LN52@Insert:
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 1208 : 			if (_Wherenode == _Rmost())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN15@Insert

; 1209 : 				_Rmost() = _Newnode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN15@Insert:

; 1210 : 			}
; 1211 : 
; 1212 : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

	mov	eax, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR __Pnode$201484[ebp], eax
$LN64@Insert:
	mov	ecx, DWORD PTR __Pnode$201484[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movsx	eax, BYTE PTR [edx+16]
	test	eax, eax
	jne	$LN360@Insert

; 1213 : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

	mov	ecx, DWORD PTR __Pnode$201484[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T238700[ebp], edx
	mov	eax, DWORD PTR $T238700[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T238704[ebp], ecx
	mov	edx, DWORD PTR __Pnode$201484[ebp]
	mov	eax, DWORD PTR $T238704[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax]
	jne	$LN216@Insert

; 1214 : 				{	// fixup red-red in left subtree
; 1215 : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR __Pnode$201484[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 4
	mov	DWORD PTR $T238711[ebp], eax
	mov	ecx, DWORD PTR $T238711[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1216 : 				if (_Color(_Wherenode) == _Red)

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	movsx	edx, BYTE PTR [ecx+16]
	test	edx, edx
	jne	SHORT $LN100@Insert

; 1217 : 					{	// parent has two red children, blacken both
; 1218 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$201484[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	BYTE PTR [ecx+16], 1

; 1219 : 					_Color(_Wherenode) = _Black;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [edx+16], 1

; 1220 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	eax, DWORD PTR __Pnode$201484[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T238733[ebp], ecx
	mov	edx, DWORD PTR $T238733[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+16], 0

; 1221 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	ecx, DWORD PTR __Pnode$201484[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$201484[ebp], eax

; 1222 : 					}
; 1223 : 				else

	jmp	SHORT $LN6@Insert

; 1224 : 					{	// parent has red and black children
; 1225 : 					if (_Pnode == _Right(_Parent(_Pnode)))

$LN100@Insert:
	mov	ecx, DWORD PTR __Pnode$201484[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Pnode$201484[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN155@Insert

; 1226 : 						{	// rotate right child to left
; 1227 : 						_Pnode = _Parent(_Pnode);

	mov	ecx, DWORD PTR __Pnode$201484[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Pnode$201484[ebp], edx

; 1228 : 						_Lrotate(_Pnode);

	mov	eax, DWORD PTR __Pnode$201484[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Lrotate

; 1229 : 						}
; 1230 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

$LN155@Insert:
	mov	ecx, DWORD PTR __Pnode$201484[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+16], 1

; 1231 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	eax, DWORD PTR __Pnode$201484[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T238834[ebp], ecx
	mov	edx, DWORD PTR $T238834[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+16], 0

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

	mov	ecx, DWORD PTR __Pnode$201484[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rrotate
$LN6@Insert:

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	$LN4@Insert

; 1236 : 				{	// fixup red-red in right subtree
; 1237 : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));

$LN216@Insert:
	mov	ecx, DWORD PTR __Pnode$201484[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T238919[ebp], edx
	mov	eax, DWORD PTR $T238919[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T238923[ebp], ecx
	mov	edx, DWORD PTR $T238923[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1238 : 				if (_Color(_Wherenode) == _Red)

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	movsx	edx, BYTE PTR [ecx+16]
	test	edx, edx
	jne	SHORT $LN240@Insert

; 1239 : 					{	// parent has two red children, blacken both
; 1240 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$201484[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	BYTE PTR [ecx+16], 1

; 1241 : 					_Color(_Wherenode) = _Black;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [edx+16], 1

; 1242 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	eax, DWORD PTR __Pnode$201484[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T238942[ebp], ecx
	mov	edx, DWORD PTR $T238942[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+16], 0

; 1243 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	ecx, DWORD PTR __Pnode$201484[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$201484[ebp], eax

; 1244 : 					}
; 1245 : 				else

	jmp	SHORT $LN4@Insert

; 1246 : 					{	// parent has red and black children
; 1247 : 					if (_Pnode == _Left(_Parent(_Pnode)))

$LN240@Insert:
	mov	ecx, DWORD PTR __Pnode$201484[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T238958[ebp], edx
	mov	eax, DWORD PTR $T238958[ebp]
	mov	ecx, DWORD PTR __Pnode$201484[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN297@Insert

; 1248 : 						{	// rotate left child to right
; 1249 : 						_Pnode = _Parent(_Pnode);

	mov	edx, DWORD PTR __Pnode$201484[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$201484[ebp], eax

; 1250 : 						_Rrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$201484[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rrotate

; 1251 : 						}
; 1252 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

$LN297@Insert:
	mov	edx, DWORD PTR __Pnode$201484[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	BYTE PTR [eax+16], 1

; 1253 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR __Pnode$201484[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T239043[ebp], edx
	mov	eax, DWORD PTR $T239043[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	BYTE PTR [ecx+16], 0

; 1254 : 					_Lrotate(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR __Pnode$201484[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Lrotate
$LN4@Insert:

; 1255 : 					}
; 1256 : 				}

	jmp	$LN64@Insert

; 1257 : 
; 1258 : 		_Color(_Root()) = _Black;	// root is always black

$LN360@Insert:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 4
	mov	DWORD PTR $T239131[ebp], eax
	mov	ecx, DWORD PTR $T239131[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	BYTE PTR [edx+16], 1

; 1259 : 		return (_TREE_ITERATOR(_Newnode));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN19@Insert:

; 1260 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z$0:
	lea	ecx, DWORD PTR $T238598[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-188]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Insert
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR __Message$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0length_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T239231 = -12						; size = 4
$T239224 = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1285 : 		{	// promote right node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1286 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1287 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+8], ecx

; 1288 : 
; 1289 : 		if (!_Isnil(_Left(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+17]
	test	ecx, ecx
	jne	SHORT $LN24@Lrotate

; 1290 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1291 : 		_Parent(_Pnode) = _Parent(_Wherenode);

$LN24@Lrotate:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 1292 : 
; 1293 : 		if (_Wherenode == _Root())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN34@Lrotate

; 1294 : 			_Root() = _Pnode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	SHORT $LN46@Lrotate

; 1295 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

$LN34@Lrotate:
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T239224[ebp], eax
	mov	ecx, DWORD PTR $T239224[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN44@Lrotate

; 1296 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T239231[ebp], ecx
	mov	edx, DWORD PTR $T239231[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx], eax

; 1297 : 		else

	jmp	SHORT $LN46@Lrotate

; 1298 : 			_Right(_Parent(_Wherenode)) = _Pnode;

$LN44@Lrotate:
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

$LN46@Lrotate:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [ecx], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1302 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Lrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Lrotate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T239307 = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1329 : 		{	// promote left node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1330 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1331 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], ecx

; 1332 : 
; 1333 : 		if (!_Isnil(_Right(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+17]
	test	ecx, ecx
	jne	SHORT $LN24@Rrotate

; 1334 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1335 : 		_Parent(_Pnode) = _Parent(_Wherenode);

$LN24@Rrotate:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 1336 : 
; 1337 : 		if (_Wherenode == _Root())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN36@Rrotate

; 1338 : 			_Root() = _Pnode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	SHORT $LN46@Rrotate

; 1339 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

$LN36@Rrotate:
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN42@Rrotate

; 1340 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1341 : 		else

	jmp	SHORT $LN46@Rrotate

; 1342 : 			_Left(_Parent(_Wherenode)) = _Pnode;

$LN42@Rrotate:
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T239307[ebp], eax
	mov	ecx, DWORD PTR $T239307[ebp]
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx], edx

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

$LN46@Rrotate:
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Rrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z$0
__unwindtable$?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z$3
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z
_TEXT	SEGMENT
tv86 = -52						; size = 4
_this$ = -48						; size = 4
$T239317 = -28						; size = 4
$T239316 = -24						; size = 4
__Wherenode$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1408 : 		{	// allocate a node with pointers, value, and color

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	0
	push	1
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>
	add	esp, 8
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1410 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR $T239317[ebp], eax
	cmp	DWORD PTR $T239317[ebp], 0
	je	SHORT $LN4@Buynode
	mov	ecx, DWORD PTR $T239317[ebp]
	mov	edx, DWORD PTR __Larg$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR $T239317[ebp]
	mov	ecx, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR $T239317[ebp]
	mov	eax, DWORD PTR __Rarg$[ebp]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR $T239317[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR $T239317[ebp]
	mov	dl, BYTE PTR __Carg$[ebp]
	mov	BYTE PTR [ecx+16], dl
	mov	eax, DWORD PTR $T239317[ebp]
	mov	BYTE PTR [eax+17], 0
	mov	ecx, DWORD PTR $T239317[ebp]
	mov	DWORD PTR tv86[ebp], ecx
	jmp	SHORT $LN5@Buynode
$LN4@Buynode:
	mov	DWORD PTR tv86[ebp], 0
$LN5@Buynode:
	mov	edx, DWORD PTR tv86[ebp]
	mov	DWORD PTR $T239316[ebp], edx
	jmp	SHORT $LN6@Buynode
__catch$?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z$0:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1414 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1415 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z$1
	ret	0
$LN6@Buynode:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z$1:

; 1416 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN3@Buynode:

; 1417 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Buynode
; Function compile flags: /Odtp
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T239394 = -16						; size = 4
$T239373 = -12						; size = 4
$T239366 = -8						; size = 4
__Pnode$202260 = -4					; size = 4
?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 320  : 			{	// move to node with next smaller value

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 321  : 
; 322  :  #if _HAS_ITERATOR_DEBUGGING
; 323  : 			if (this->_Mycont == 0
; 324  : 				|| _Ptr == 0)
; 325  : 				{
; 326  : 				_DEBUG_ERROR("map/set iterator not decrementable");
; 327  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 				}
; 329  :  #else
; 330  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 331  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 332  : 
; 333  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+17]
	test	edx, edx
	je	SHORT $LN9@Dec

; 334  : 			{
; 335  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx], eax

; 336  :    				if (_Isnil(_Ptr))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx+17]
	test	eax, eax
	je	SHORT $LN8@Dec

; 337  : #if _HAS_ITERATOR_DEBUGGING
; 338  : 				{
; 339  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 340  : 					_SCL_SECURE_OUT_OF_RANGE;
; 341  : 				}
; 342  : #elif _SECURE_SCL
; 343  : 				{
; 344  :     				_SCL_SECURE_OUT_OF_RANGE;
; 345  : 				}
; 346  : #else
; 347  : 				return;	// begin() shouldn't be incremented, don't move

	jmp	$LN10@Dec
$LN8@Dec:

; 348  : #endif
; 349  : 			}

	jmp	$LN10@Dec
$LN9@Dec:

; 350  : 			else if (!_Isnil(_Left(_Ptr)))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T239366[ebp], edx
	mov	eax, DWORD PTR $T239366[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+17]
	test	edx, edx
	jne	SHORT $LN34@Dec

; 351  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T239373[ebp], ecx
	mov	edx, DWORD PTR $T239373[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T239394[ebp], eax
$LN30@Dec:
	mov	ecx, DWORD PTR $T239394[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movsx	eax, BYTE PTR [edx+17]
	test	eax, eax
	jne	SHORT $LN26@Dec
	mov	ecx, DWORD PTR $T239394[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T239394[ebp], edx
	jmp	SHORT $LN30@Dec
$LN26@Dec:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T239394[ebp]
	mov	DWORD PTR [eax], ecx

; 352  : 			else

	jmp	SHORT $LN10@Dec

; 353  : 				{	// climb looking for left subtree
; 354  : 				_Nodeptr _Pnode;
; 355  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 356  : 					&& _Ptr == _Left(_Pnode))

$LN34@Dec:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Pnode$202260[ebp], ecx
	mov	edx, DWORD PTR __Pnode$202260[ebp]
	movsx	eax, BYTE PTR [edx+17]
	test	eax, eax
	jne	SHORT $LN40@Dec
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Pnode$202260[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN40@Dec

; 357  : 					_Ptr = _Pnode;	// ==> parent while left subtree

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Pnode$202260[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN34@Dec

; 358  : 				if (_Isnil(_Ptr))

$LN40@Dec:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+17]
	test	edx, edx
	je	SHORT $LN2@Dec

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move

	jmp	SHORT $LN10@Dec

; 370  :  #endif
; 371  : 				else

	jmp	SHORT $LN10@Dec
$LN2@Dec:

; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$202260[ebp]
	mov	DWORD PTR [eax], ecx
$LN10@Dec:

; 373  : 				}
; 374  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Dec
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T239413 = -16						; size = 4
$T239409 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@2
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 20					; 00000014H
	jae	SHORT $LN2@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T239413[ebp], 0
	lea	eax, DWORD PTR $T239413[ebp]
	push	eax
	lea	ecx, DWORD PTR $T239409[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T239409[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T239409[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 20					; 00000014H
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@2:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
END
