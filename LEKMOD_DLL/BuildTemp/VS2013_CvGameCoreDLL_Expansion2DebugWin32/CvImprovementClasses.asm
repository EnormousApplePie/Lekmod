; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvImprovementClasses.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??0CvImprovementResourceInfo@@QAE@XZ		; CvImprovementResourceInfo::CvImprovementResourceInfo
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvimprovementclasses.cpp
;	COMDAT ??0CvImprovementResourceInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvImprovementResourceInfo@@QAE@XZ PROC		; CvImprovementResourceInfo::CvImprovementResourceInfo, COMDAT
; _this$ = ecx

; 32   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+5], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 33   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvImprovementResourceInfo@@QAE@XZ ENDP		; CvImprovementResourceInfo::CvImprovementResourceInfo
_TEXT	ENDS
PUBLIC	??1CvImprovementResourceInfo@@QAE@XZ		; CvImprovementResourceInfo::~CvImprovementResourceInfo
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Odtp
;	COMDAT ??1CvImprovementResourceInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T219081 = -8						; size = 4
$T219080 = -4						; size = 4
??1CvImprovementResourceInfo@@QAE@XZ PROC		; CvImprovementResourceInfo::~CvImprovementResourceInfo, COMDAT
; _this$ = ecx

; 36   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 37   : 	SAFE_DELETE_ARRAY(m_piYieldChange);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	mov	DWORD PTR $T219081[ebp], eax
	mov	ecx, DWORD PTR $T219081[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T219080[ebp], edx
	mov	eax, DWORD PTR $T219080[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T219081[ebp]
	mov	DWORD PTR [ecx], 0

; 38   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1CvImprovementResourceInfo@@QAE@XZ ENDP		; CvImprovementResourceInfo::~CvImprovementResourceInfo
_TEXT	ENDS
PUBLIC	?getDiscoverRand@CvImprovementResourceInfo@@QBEHXZ ; CvImprovementResourceInfo::getDiscoverRand
; Function compile flags: /Odtp
;	COMDAT ?getDiscoverRand@CvImprovementResourceInfo@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getDiscoverRand@CvImprovementResourceInfo@@QBEHXZ PROC	; CvImprovementResourceInfo::getDiscoverRand, COMDAT
; _this$ = ecx

; 41   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 42   : 	return m_iDiscoverRand;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 43   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getDiscoverRand@CvImprovementResourceInfo@@QBEHXZ ENDP	; CvImprovementResourceInfo::getDiscoverRand
_TEXT	ENDS
PUBLIC	?isResourceMakesValid@CvImprovementResourceInfo@@QBE_NXZ ; CvImprovementResourceInfo::isResourceMakesValid
; Function compile flags: /Odtp
;	COMDAT ?isResourceMakesValid@CvImprovementResourceInfo@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isResourceMakesValid@CvImprovementResourceInfo@@QBE_NXZ PROC ; CvImprovementResourceInfo::isResourceMakesValid, COMDAT
; _this$ = ecx

; 46   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 	return m_bResourceMakesValid;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+4]

; 48   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isResourceMakesValid@CvImprovementResourceInfo@@QBE_NXZ ENDP ; CvImprovementResourceInfo::isResourceMakesValid
_TEXT	ENDS
PUBLIC	?isResourceTrade@CvImprovementResourceInfo@@QBE_NXZ ; CvImprovementResourceInfo::isResourceTrade
; Function compile flags: /Odtp
;	COMDAT ?isResourceTrade@CvImprovementResourceInfo@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isResourceTrade@CvImprovementResourceInfo@@QBE_NXZ PROC ; CvImprovementResourceInfo::isResourceTrade, COMDAT
; _this$ = ecx

; 51   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 52   : 	return m_bResourceTrade;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+5]

; 53   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isResourceTrade@CvImprovementResourceInfo@@QBE_NXZ ENDP ; CvImprovementResourceInfo::isResourceTrade
_TEXT	ENDS
PUBLIC	?getYieldChange@CvImprovementResourceInfo@@QBEHH@Z ; CvImprovementResourceInfo::getYieldChange
; Function compile flags: /Odtp
;	COMDAT ?getYieldChange@CvImprovementResourceInfo@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?getYieldChange@CvImprovementResourceInfo@@QBEHH@Z PROC	; CvImprovementResourceInfo::getYieldChange, COMDAT
; _this$ = ecx

; 56   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 57   : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 58   : 	CvAssertMsg(i > -1, "Index out of bounds");
; 59   : 	return m_piYieldChange ? m_piYieldChange[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN3@getYieldCh
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@getYieldCh
$LN3@getYieldCh:
	mov	DWORD PTR tv69[ebp], -1
$LN4@getYieldCh:
	mov	eax, DWORD PTR tv69[ebp]

; 60   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getYieldChange@CvImprovementResourceInfo@@QBEHH@Z ENDP	; CvImprovementResourceInfo::getYieldChange
_TEXT	ENDS
PUBLIC	??1CvBaseInfo@@QAE@XZ				; CvBaseInfo::~CvBaseInfo
PUBLIC	??_7CvImprovementEntry@@6B@			; CvImprovementEntry::`vftable'
PUBLIC	??0CvImprovementEntry@@QAE@XZ			; CvImprovementEntry::CvImprovementEntry
PUBLIC	?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvImprovementEntry::CacheResults
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	??0CvBaseInfo@@QAE@XZ:PROC			; CvBaseInfo::CvBaseInfo
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	??8CvBaseInfo@@UBE_NABV0@@Z:PROC		; CvBaseInfo::operator==
EXTRN	?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::readFrom
EXTRN	?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::writeTo
;	COMDAT ??_7CvImprovementEntry@@6B@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_7CvImprovementEntry@@6B@ DD FLAT:?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvImprovementEntry::`vftable'
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CvImprovementEntry@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvImprovementEntry@@QAE@XZ$0
__ehfuncinfo$??0CvImprovementEntry@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvImprovementEntry@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvimprovementclasses.cpp
xdata$x	ENDS
;	COMDAT ??0CvImprovementEntry@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T219100 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvImprovementEntry@@QAE@XZ PROC			; CvImprovementEntry::CvImprovementEntry, COMDAT
; _this$ = ecx

; 146  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvImprovementEntry@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvImprovementEntry@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+260], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+264], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+268], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+272], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+276], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+280], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+284], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+288], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+292], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+296], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+300], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+304], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+308], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+312], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+316], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+320], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+324], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+328], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+332], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+336], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+340], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+344], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+345], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+346], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+347], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+348], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+349], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+350], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+351], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+352], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+353], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+354], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+355], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+356], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+357], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+358], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+359], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+360], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+361], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+362], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+363], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+364], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+365], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+366], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+367], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+368], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+369], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+370], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+371], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+372], 0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 376				; 00000178H
	mov	DWORD PTR $T219100[ebp], eax
	mov	ecx, DWORD PTR $T219100[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+404], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+408], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+412], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+416], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+420], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+424], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+428], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+432], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+436], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+440], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+444], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+448], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+452], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+456], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+460], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+464], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+468], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+472], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+476], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+480], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+484], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+488], 0

; 147  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvImprovementEntry@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__ehhandler$??0CvImprovementEntry@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvImprovementEntry@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvImprovementEntry@@QAE@XZ ENDP			; CvImprovementEntry::CvImprovementEntry
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CvBaseInfo@@QAE@XZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??1CvBaseInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvBaseInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1CvBaseInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T219167 = -48						; size = 4
$T219162 = -44						; size = 4
$T219157 = -40						; size = 4
$T219152 = -36						; size = 4
$T219147 = -32						; size = 4
$T219142 = -28						; size = 4
$T219137 = -24						; size = 4
$T219132 = -20						; size = 4
$T219127 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvBaseInfo@@QAE@XZ PROC				; CvBaseInfo::~CvBaseInfo, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvBaseInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 7
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 232				; 000000e8H
	mov	DWORD PTR $T219127[ebp], eax
	mov	ecx, DWORD PTR $T219127[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	mov	DWORD PTR $T219132[ebp], ecx
	mov	ecx, DWORD PTR $T219132[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 176				; 000000b0H
	mov	DWORD PTR $T219137[ebp], edx
	mov	ecx, DWORD PTR $T219137[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 148				; 00000094H
	mov	DWORD PTR $T219142[ebp], eax
	mov	ecx, DWORD PTR $T219142[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	mov	DWORD PTR $T219147[ebp], ecx
	mov	ecx, DWORD PTR $T219147[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 92					; 0000005cH
	mov	DWORD PTR $T219152[ebp], edx
	mov	ecx, DWORD PTR $T219152[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 64					; 00000040H
	mov	DWORD PTR $T219157[ebp], eax
	mov	ecx, DWORD PTR $T219157[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	mov	DWORD PTR $T219162[ebp], ecx
	mov	ecx, DWORD PTR $T219162[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	mov	DWORD PTR $T219167[ebp], edx
	mov	ecx, DWORD PTR $T219167[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvBaseInfo@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvBaseInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvBaseInfo@@QAE@XZ ENDP				; CvBaseInfo::~CvBaseInfo
PUBLIC	??_ECvImprovementResourceInfo@@QAEPAXI@Z	; CvImprovementResourceInfo::`vector deleting destructor'
PUBLIC	??1CvImprovementEntry@@QAE@XZ			; CvImprovementEntry::~CvImprovementEntry
EXTRN	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z:PROC ; CvDatabaseUtility::SafeDelete2DArray
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??1CvImprovementEntry@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvImprovementEntry@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvImprovementEntry@@QAE@XZ$1
__ehfuncinfo$??1CvImprovementEntry@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1CvImprovementEntry@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvimprovementclasses.cpp
xdata$x	ENDS
;	COMDAT ??1CvImprovementEntry@@QAE@XZ
_TEXT	SEGMENT
tv195 = -184						; size = 4
_this$ = -180						; size = 4
$T219279 = -140						; size = 4
$T219274 = -136						; size = 4
$T219270 = -132						; size = 4
$T219269 = -128						; size = 4
$T219261 = -124						; size = 4
$T219259 = -120						; size = 4
$T219255 = -116						; size = 4
$T219253 = -112						; size = 4
$T219249 = -108						; size = 4
$T219247 = -104						; size = 4
$T219243 = -100						; size = 4
$T219241 = -96						; size = 4
$T219237 = -92						; size = 4
$T219235 = -88						; size = 4
$T219231 = -84						; size = 4
$T219229 = -80						; size = 4
$T219225 = -76						; size = 4
$T219223 = -72						; size = 4
$T219219 = -68						; size = 4
$T219217 = -64						; size = 4
$T219213 = -60						; size = 4
$T219211 = -56						; size = 4
$T219207 = -52						; size = 4
$T219205 = -48						; size = 4
$T219201 = -44						; size = 4
$T219199 = -40						; size = 4
$T219195 = -36						; size = 4
$T219193 = -32						; size = 4
$T219189 = -28						; size = 4
$T219187 = -24						; size = 4
$T219183 = -20						; size = 4
$T219181 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvImprovementEntry@@QAE@XZ PROC			; CvImprovementEntry::~CvImprovementEntry, COMDAT
; _this$ = ecx

; 151  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvImprovementEntry@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 172				; 000000acH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvImprovementEntry@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 152  : 	SAFE_DELETE_ARRAY(m_piResourceQuantityRequirements);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 416				; 000001a0H
	mov	DWORD PTR $T219183[ebp], ecx
	mov	edx, DWORD PTR $T219183[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T219181[ebp], eax
	mov	ecx, DWORD PTR $T219181[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T219183[ebp]
	mov	DWORD PTR [edx], 0

; 153  : 	SAFE_DELETE_ARRAY(m_piPrereqNatureYield);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 420				; 000001a4H
	mov	DWORD PTR $T219189[ebp], eax
	mov	ecx, DWORD PTR $T219189[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T219187[ebp], edx
	mov	eax, DWORD PTR $T219187[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T219189[ebp]
	mov	DWORD PTR [ecx], 0

; 154  : 	SAFE_DELETE_ARRAY(m_piYieldChange);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 424				; 000001a8H
	mov	DWORD PTR $T219195[ebp], edx
	mov	eax, DWORD PTR $T219195[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T219193[ebp], ecx
	mov	edx, DWORD PTR $T219193[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, DWORD PTR $T219195[ebp]
	mov	DWORD PTR [eax], 0

; 155  : 	SAFE_DELETE_ARRAY(m_piYieldPerEra);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 428				; 000001acH
	mov	DWORD PTR $T219201[ebp], ecx
	mov	edx, DWORD PTR $T219201[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T219199[ebp], eax
	mov	ecx, DWORD PTR $T219199[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T219201[ebp]
	mov	DWORD PTR [edx], 0

; 156  : 	SAFE_DELETE_ARRAY(m_piRiverSideYieldChange);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 432				; 000001b0H
	mov	DWORD PTR $T219207[ebp], eax
	mov	ecx, DWORD PTR $T219207[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T219205[ebp], edx
	mov	eax, DWORD PTR $T219205[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T219207[ebp]
	mov	DWORD PTR [ecx], 0

; 157  : 	SAFE_DELETE_ARRAY(m_piCoastalLandYieldChange);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 436				; 000001b4H
	mov	DWORD PTR $T219213[ebp], edx
	mov	eax, DWORD PTR $T219213[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T219211[ebp], ecx
	mov	edx, DWORD PTR $T219211[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, DWORD PTR $T219213[ebp]
	mov	DWORD PTR [eax], 0

; 158  : 	SAFE_DELETE_ARRAY(m_piHillsYieldChange);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 440				; 000001b8H
	mov	DWORD PTR $T219219[ebp], ecx
	mov	edx, DWORD PTR $T219219[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T219217[ebp], eax
	mov	ecx, DWORD PTR $T219217[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T219219[ebp]
	mov	DWORD PTR [edx], 0

; 159  : 	SAFE_DELETE_ARRAY(m_piFreshWaterChange);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 444				; 000001bcH
	mov	DWORD PTR $T219225[ebp], eax
	mov	ecx, DWORD PTR $T219225[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T219223[ebp], edx
	mov	eax, DWORD PTR $T219223[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T219225[ebp]
	mov	DWORD PTR [ecx], 0

; 160  : 	SAFE_DELETE_ARRAY(m_piAdjacentCityYieldChange);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 448				; 000001c0H
	mov	DWORD PTR $T219231[ebp], edx
	mov	eax, DWORD PTR $T219231[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T219229[ebp], ecx
	mov	edx, DWORD PTR $T219229[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, DWORD PTR $T219231[ebp]
	mov	DWORD PTR [eax], 0

; 161  : 	SAFE_DELETE_ARRAY(m_piAdjacentMountainYieldChange);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 452				; 000001c4H
	mov	DWORD PTR $T219237[ebp], ecx
	mov	edx, DWORD PTR $T219237[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T219235[ebp], eax
	mov	ecx, DWORD PTR $T219235[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T219237[ebp]
	mov	DWORD PTR [edx], 0

; 162  : 	SAFE_DELETE_ARRAY(m_piFlavorValue);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 456				; 000001c8H
	mov	DWORD PTR $T219243[ebp], eax
	mov	ecx, DWORD PTR $T219243[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T219241[ebp], edx
	mov	eax, DWORD PTR $T219241[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T219243[ebp]
	mov	DWORD PTR [ecx], 0

; 163  : 	SAFE_DELETE_ARRAY(m_pbTerrainMakesValid);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 460				; 000001ccH
	mov	DWORD PTR $T219249[ebp], edx
	mov	eax, DWORD PTR $T219249[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T219247[ebp], ecx
	mov	edx, DWORD PTR $T219247[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, DWORD PTR $T219249[ebp]
	mov	DWORD PTR [eax], 0

; 164  : 	SAFE_DELETE_ARRAY(m_pbFeatureMakesValid);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 464				; 000001d0H
	mov	DWORD PTR $T219255[ebp], ecx
	mov	edx, DWORD PTR $T219255[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T219253[ebp], eax
	mov	ecx, DWORD PTR $T219253[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T219255[ebp]
	mov	DWORD PTR [edx], 0

; 165  : 	SAFE_DELETE_ARRAY(m_pbImprovementMakesValid);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 468				; 000001d4H
	mov	DWORD PTR $T219261[ebp], eax
	mov	ecx, DWORD PTR $T219261[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T219259[ebp], edx
	mov	eax, DWORD PTR $T219259[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T219261[ebp]
	mov	DWORD PTR [ecx], 0

; 166  : 
; 167  : 	if(m_paImprovementResource != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+488], 0
	je	SHORT $LN5@CvImprovem

; 168  : 	{
; 169  : 		SAFE_DELETE_ARRAY(m_paImprovementResource); // XXX make sure this isn't leaking memory...

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 488				; 000001e8H
	mov	DWORD PTR $T219274[ebp], eax
	mov	ecx, DWORD PTR $T219274[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T219270[ebp], edx
	mov	eax, DWORD PTR $T219270[ebp]
	mov	DWORD PTR $T219269[ebp], eax
	cmp	DWORD PTR $T219269[ebp], 0
	je	SHORT $LN40@CvImprovem
	push	3
	mov	ecx, DWORD PTR $T219269[ebp]
	call	??_ECvImprovementResourceInfo@@QAEPAXI@Z
	mov	DWORD PTR tv195[ebp], eax
	jmp	SHORT $LN41@CvImprovem
$LN40@CvImprovem:
	mov	DWORD PTR tv195[ebp], 0
$LN41@CvImprovem:
	mov	ecx, DWORD PTR $T219274[ebp]
	mov	DWORD PTR [ecx], 0
$LN5@CvImprovem:

; 170  : 	}
; 171  : 
; 172  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 173  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiTechYieldChanges.first, m_ppiTechYieldChanges.second);
; 174  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiTechNoFreshWaterYieldChanges.first, m_ppiTechNoFreshWaterYieldChanges.second);
; 175  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiTechFreshWaterYieldChanges.first, m_ppiTechFreshWaterYieldChanges.second);
; 176  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiRouteYieldChanges.first, m_ppiRouteYieldChanges.second);
; 177  : #else
; 178  : 	if(m_ppiTechYieldChanges != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+472], 0
	je	SHORT $LN4@CvImprovem

; 179  : 	{
; 180  : 		CvDatabaseUtility::SafeDelete2DArray(m_ppiTechYieldChanges);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 472				; 000001d8H
	push	eax
	call	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z ; CvDatabaseUtility::SafeDelete2DArray
	add	esp, 4
$LN4@CvImprovem:

; 181  : 	}
; 182  : 
; 183  : 	if(m_ppiTechNoFreshWaterYieldChanges != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+476], 0
	je	SHORT $LN3@CvImprovem

; 184  : 	{
; 185  : 		CvDatabaseUtility::SafeDelete2DArray(m_ppiTechNoFreshWaterYieldChanges);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 476				; 000001dcH
	push	edx
	call	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z ; CvDatabaseUtility::SafeDelete2DArray
	add	esp, 4
$LN3@CvImprovem:

; 186  : 	}
; 187  : 
; 188  : 	if(m_ppiTechFreshWaterYieldChanges != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+480], 0
	je	SHORT $LN2@CvImprovem

; 189  : 	{
; 190  : 		CvDatabaseUtility::SafeDelete2DArray(m_ppiTechFreshWaterYieldChanges);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 480				; 000001e0H
	push	ecx
	call	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z ; CvDatabaseUtility::SafeDelete2DArray
	add	esp, 4
$LN2@CvImprovem:

; 191  : 	}
; 192  : 
; 193  : 	if(m_ppiRouteYieldChanges != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+484], 0
	je	SHORT $LN6@CvImprovem

; 194  : 	{
; 195  : 		CvDatabaseUtility::SafeDelete2DArray(m_ppiRouteYieldChanges);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 484				; 000001e4H
	push	eax
	call	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z ; CvDatabaseUtility::SafeDelete2DArray
	add	esp, 4
$LN6@CvImprovem:

; 196  : 	}
; 197  : #endif
; 198  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 376				; 00000178H
	mov	DWORD PTR $T219279[ebp], ecx
	mov	ecx, DWORD PTR $T219279[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvBaseInfo@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvImprovementEntry@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??1CvImprovementEntry@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 376				; 00000178H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvImprovementEntry@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-176]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvImprovementEntry@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvImprovementEntry@@QAE@XZ ENDP			; CvImprovementEntry::~CvImprovementEntry
PUBLIC	??_C@_0NB@EFFCGCCC@select?5Yields?4ID?5as?5YieldID?0?5Rou@ ; `string'
PUBLIC	??_C@_0CB@KLJHJIAH@Improvements?5?9?5RouteYieldChanges@ ; `string'
PUBLIC	??_C@_06LABKBOBK@Routes?$AA@			; `string'
PUBLIC	??_C@_0OJ@MGCJPING@select?5Yields?4ID?5as?5YieldID?0?5Tec@ ; `string'
PUBLIC	??_C@_0CK@IKFKMKDD@Improvements?5?9?5TechFreshWaterYie@ ; `string'
PUBLIC	??_C@_0OL@FJCOGNKM@select?5Yields?4ID?5as?5YieldID?0?5Tec@ ; `string'
PUBLIC	??_C@_0CM@OAENAEJK@Improvements?5?9?5TechNoFreshWaterY@ ; `string'
PUBLIC	??_C@_0NP@FDAJIDEK@select?5Yields?4ID?5as?5YieldID?0?5Tec@ ; `string'
PUBLIC	??_C@_0CA@MLIOACLH@Improvements?5?9?5TechYieldChanges?$AA@ ; `string'
PUBLIC	??_C@_05LNDKIJIJ@Yield?$AA@			; `string'
PUBLIC	??_C@_06JAMLCLDI@Yields?$AA@			; `string'
PUBLIC	??_C@_0BE@BHIANCDJ@QuantityRequirement?$AA@	; `string'
PUBLIC	??_C@_0O@ILMABPGL@DiscoveryRand?$AA@		; `string'
PUBLIC	??_C@_0O@OCBJCFBM@ResourceTrade?$AA@		; `string'
PUBLIC	??_C@_0BD@EAAJGMOP@ResourceMakesValid?$AA@	; `string'
PUBLIC	??_C@_0N@EPHJOCBJ@ResourceType?$AA@		; `string'
PUBLIC	??_C@_02OLOABKKD@ID?$AA@			; `string'
PUBLIC	??_C@_0JJ@KHHJOGON@select?5Yields?4ID?0?5Yield?5from?5Imp@ ; `string'
PUBLIC	??_C@_0BM@NJMJOCGJ@Improvements?5?9?5YieldResults?$AA@ ; `string'
PUBLIC	??_C@_0MD@JCBBECJP@select?5Resources?4ID?0?5ResourceTyp@ ; `string'
PUBLIC	??_C@_0BN@OECFNINC@Improvements?5?9?5ResourceTypes?$AA@ ; `string'
PUBLIC	?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z ; CvDatabaseUtility::InitializeArray
PUBLIC	??_C@_09FDCBPLKG@Resources?$AA@			; `string'
PUBLIC	??_C@_0BE@MGDAOLO@Improvement_Flavors?$AA@	; `string'
PUBLIC	??_C@_0BP@DNANAMLL@Improvement_PrereqNatureYields?$AA@ ; `string'
PUBLIC	??_C@_0BM@FNAFGHPN@Improvement_RiverSideYields?$AA@ ; `string'
PUBLIC	??_C@_0BI@MLCOMNFP@Improvement_HillsYields?$AA@	; `string'
PUBLIC	??_C@_0BN@GOMKPHOC@Improvement_FreshWaterYields?$AA@ ; `string'
PUBLIC	??_C@_0BO@MLDKINGM@Improvement_CoastalLandYields?$AA@ ; `string'
PUBLIC	??_C@_0CJ@DKNIFGIA@Improvement_AdjacentMountainYiel@ ; `string'
PUBLIC	??_C@_0BP@MOPDDKEG@Improvement_AdjacentCityYields?$AA@ ; `string'
PUBLIC	??_C@_0BI@FLAHPOKL@Improvement_YieldPerEra?$AA@	; `string'
PUBLIC	??_C@_0BD@CCIBEEC@Improvement_Yields?$AA@	; `string'
PUBLIC	??_C@_0N@CJDAHDJO@Improvements?$AA@		; `string'
PUBLIC	??_C@_0BO@PLHLCHHA@Improvement_ValidImprovements?$AA@ ; `string'
PUBLIC	??_C@_0BC@JKAACCPI@PrereqImprovement?$AA@	; `string'
PUBLIC	??_C@_08CLANBDND@Features?$AA@			; `string'
PUBLIC	??_C@_0BK@LNHHOEJ@Improvement_ValidFeatures?$AA@ ; `string'
PUBLIC	??_C@_0M@LJDMFNNN@FeatureType?$AA@		; `string'
PUBLIC	??_C@_08DHHJBCFH@Terrains?$AA@			; `string'
PUBLIC	??_C@_0BK@BHKDHPMN@Improvement_ValidTerrains?$AA@ ; `string'
PUBLIC	??_C@_0M@BBHDGKPJ@TerrainType?$AA@		; `string'
PUBLIC	??_C@_0BA@PMOLGEPK@ImprovementType?$AA@		; `string'
PUBLIC	??_C@_0BD@MPPFDDCN@ImprovementUpgrade?$AA@	; `string'
PUBLIC	??_C@_0BD@MCACIDCN@ImprovementPillage?$AA@	; `string'
PUBLIC	?Remark@@YA_NHPBDZZ				; Remark
PUBLIC	??_C@_0EA@OMPGKABL@Warning?3?5Missing?5soundscape?5defi@ ; `string'
PUBLIC	??_C@_0BL@EOODAKIM@WorldSoundscapeAudioScript?$AA@ ; `string'
PUBLIC	??_C@_0BB@GDPFJHJJ@CivilizationType?$AA@	; `string'
PUBLIC	??_C@_0BO@LOONOMNN@LuxuryCopiesSiphonedFromMinor?$AA@ ; `string'
PUBLIC	??_C@_0BG@HNLDIHFB@ResourceExtractionMod?$AA@	; `string'
PUBLIC	??_C@_0BE@JMIEJANC@SpecificCivRequired?$AA@	; `string'
PUBLIC	??_C@_0BF@OHDPBMDL@CreatedByGreatPerson?$AA@	; `string'
PUBLIC	??_C@_0P@JCCLNNJI@AllowsSailLand?$AA@		; `string'
PUBLIC	??_C@_0BA@DAJEJENL@AllowsWalkWater?$AA@		; `string'
PUBLIC	??_C@_0P@OPMKDMKP@AdjacentLuxury?$AA@		; `string'
PUBLIC	??_C@_0O@OPDLHEPJ@NoTwoAdjacent?$AA@		; `string'
PUBLIC	??_C@_0BH@JDPNOMKI@OnlyCityStateTerritory?$AA@	; `string'
PUBLIC	??_C@_0BA@DHOGLFDO@IgnoreOwnership?$AA@		; `string'
PUBLIC	??_C@_0BD@JNHNLDMJ@InAdjacentFriendly?$AA@	; `string'
PUBLIC	??_C@_0P@HHOKABHL@OutsideBorders?$AA@		; `string'
PUBLIC	??_C@_0M@CBOHOOCD@PillageGold?$AA@		; `string'
PUBLIC	??_C@_0BC@JCHHBBPA@NearbyEnemyDamage?$AA@	; `string'
PUBLIC	??_C@_0BG@FFFHFPGD@DefenseModifierGlobal?$AA@	; `string'
PUBLIC	??_C@_0BA@BLEBFEEF@DefenseModifier?$AA@		; `string'
PUBLIC	??_C@_0BF@FBPICDKJ@FreshWaterUpgradeMod?$AA@	; `string'
PUBLIC	??_C@_0BA@PGBFHPDG@HillsUpgradeMod?$AA@		; `string'
PUBLIC	??_C@_0BG@BOJPKJEI@CoastalLandUpgradeMod?$AA@	; `string'
PUBLIC	??_C@_0BE@GMJNJAOL@RiverSideUpgradeMod?$AA@	; `string'
PUBLIC	??_C@_0M@NLAHPCAM@UpgradeTime?$AA@		; `string'
PUBLIC	??_C@_0O@PLMBOHND@FeatureGrowth?$AA@		; `string'
PUBLIC	??_C@_0L@IOJDFNDI@GoodyRange?$AA@		; `string'
PUBLIC	??_C@_0O@MCNHIFJF@TilesPerGoody?$AA@		; `string'
PUBLIC	??_C@_09FHMJCGNI@Permanent?$AA@			; `string'
PUBLIC	??_C@_05JFGEMCAC@Goody?$AA@			; `string'
PUBLIC	??_C@_0O@FOCNADKB@BarbarianCamp?$AA@		; `string'
PUBLIC	??_C@_0BF@MDOCFNBI@BuildableOnResources?$AA@	; `string'
PUBLIC	??_C@_0BB@HAMCANB@DisplacePillager?$AA@		; `string'
PUBLIC	??_C@_0BG@DGACHGGA@DestroyedWhenPillaged?$AA@	; `string'
PUBLIC	??_C@_07FJOLCNAD@Coastal?$AA@			; `string'
PUBLIC	??_C@_05EMKMBNJK@Water?$AA@			; `string'
PUBLIC	??_C@_0BD@GHCHBJMK@PromptWhenComplete?$AA@	; `string'
PUBLIC	??_C@_0BA@IKLICPAM@RemovesResource?$AA@		; `string'
PUBLIC	??_C@_0BE@ONMAAIBI@RequiresImprovement?$AA@	; `string'
PUBLIC	??_C@_0BA@PKHCPDEE@RequiresFeature?$AA@		; `string'
PUBLIC	??_C@_0BO@GAKGDCFD@RequiresFlatlandsOrFreshWater?$AA@ ; `string'
PUBLIC	??_C@_0BC@IDFGBFEH@RequiresFlatlands?$AA@	; `string'
PUBLIC	??_C@_0N@KPIEECMK@NoFreshWater?$AA@		; `string'
PUBLIC	??_C@_0BE@HAPOKNPN@RiverSideMakesValid?$AA@	; `string'
PUBLIC	??_C@_0BF@ENJLBOLP@FreshWaterMakesValid?$AA@	; `string'
PUBLIC	??_C@_0BJ@KPFJLEOH@WaterAdjacencyMakesValid?$AA@ ; `string'
PUBLIC	??_C@_0BA@OKHGECCA@HillsMakesValid?$AA@		; `string'
PUBLIC	??_C@_0BI@EGCIFCHA@CultureAdjacentSameType?$AA@	; `string'
PUBLIC	??_C@_0BG@NLHAEONM@RequiresXAdjacentLand?$AA@	; `string'
PUBLIC	??_C@_0BJ@HNFKIGOI@CultureBombRadiusNeutral?$AA@ ; `string'
PUBLIC	??_C@_0BC@NEFPKCDN@CultureBombRadius?$AA@	; `string'
PUBLIC	??_C@_0BA@NGAILOKJ@GoldMaintenance?$AA@		; `string'
PUBLIC	?SetArtDefineTag@CvImprovementEntry@@QAEXPBD@Z	; CvImprovementEntry::SetArtDefineTag
PUBLIC	??_C@_0N@NLPPFOOH@ArtDefineTag?$AA@		; `string'
PUBLIC	__$ArrayPad$
EXTRN	__imp_?GetInt@Results@Database@@QAEHH@Z:PROC
EXTRN	?Initialize2DArray@CvDatabaseUtility@@QAEXAAPAPAHIIH@Z:PROC ; CvDatabaseUtility::Initialize2DArray
EXTRN	?getNumTechInfos@CvGlobals@@QAEHXZ:PROC		; CvGlobals::getNumTechInfos
EXTRN	__imp_?Reset@Results@Database@@QAE_NXZ:PROC
EXTRN	__imp_?Step@Results@Database@@QAE_NXZ:PROC
EXTRN	__imp_?Bind@Results@Database@@QAE_NHPBDH_N@Z:PROC
EXTRN	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z:PROC ; CvDatabaseUtility::PrepareResults
EXTRN	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; CvDatabaseUtility::GetResults
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z:PROC	; CvDatabaseUtility::MaxRows
EXTRN	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z:PROC ; CvDatabaseUtility::SetFlavors
EXTRN	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z:PROC ; CvDatabaseUtility::SetYields
EXTRN	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z:PROC ; CvDatabaseUtility::PopulateArrayByExistence
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
EXTRN	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z:PROC ; CvGlobals::getInfoTypeForString
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
EXTRN	__imp_?GetBool@Results@Database@@QAE_NPBD@Z:PROC
EXTRN	__imp_?GetInt@Results@Database@@QAEHPBD@Z:PROC
EXTRN	__imp_?GetText@Results@Database@@QAEPBDPBD@Z:PROC
EXTRN	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:PROC ; CvBaseInfo::CacheResults
;	COMDAT ??_C@_0NB@EFFCGCCC@select?5Yields?4ID?5as?5YieldID?0?5Rou@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdatabaseutility.h
CONST	SEGMENT
??_C@_0NB@EFFCGCCC@select?5Yields?4ID?5as?5YieldID?0?5Rou@ DB 'select Yie'
	DB	'lds.ID as YieldID, Routes.ID as RouteID, Yield from Improveme'
	DB	'nt_RouteYieldChanges inner join Yields on YieldType = Yields.'
	DB	'Type inner join Routes on RouteType = Routes.Type where Impro'
	DB	'vementType = ?;', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KLJHJIAH@Improvements?5?9?5RouteYieldChanges@
CONST	SEGMENT
??_C@_0CB@KLJHJIAH@Improvements?5?9?5RouteYieldChanges@ DB 'Improvements '
	DB	'- RouteYieldChanges', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06LABKBOBK@Routes?$AA@
CONST	SEGMENT
??_C@_06LABKBOBK@Routes?$AA@ DB 'Routes', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0OJ@MGCJPING@select?5Yields?4ID?5as?5YieldID?0?5Tec@
CONST	SEGMENT
??_C@_0OJ@MGCJPING@select?5Yields?4ID?5as?5YieldID?0?5Tec@ DB 'select Yie'
	DB	'lds.ID as YieldID, Technologies.ID as TechID, Yield from Impr'
	DB	'ovement_TechFreshWaterYieldChanges inner join Yields on Yield'
	DB	'Type = Yields.Type inner join Technologies on TechType = Tech'
	DB	'nologies.Type where ImprovementType = ?', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@IKFKMKDD@Improvements?5?9?5TechFreshWaterYie@
CONST	SEGMENT
??_C@_0CK@IKFKMKDD@Improvements?5?9?5TechFreshWaterYie@ DB 'Improvements '
	DB	'- TechFreshWaterYieldChanges', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0OL@FJCOGNKM@select?5Yields?4ID?5as?5YieldID?0?5Tec@
CONST	SEGMENT
??_C@_0OL@FJCOGNKM@select?5Yields?4ID?5as?5YieldID?0?5Tec@ DB 'select Yie'
	DB	'lds.ID as YieldID, Technologies.ID as TechID, Yield from Impr'
	DB	'ovement_TechNoFreshWaterYieldChanges inner join Yields on Yie'
	DB	'ldType = Yields.Type inner join Technologies on TechType = Te'
	DB	'chnologies.Type where ImprovementType = ?', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@OAENAEJK@Improvements?5?9?5TechNoFreshWaterY@
CONST	SEGMENT
??_C@_0CM@OAENAEJK@Improvements?5?9?5TechNoFreshWaterY@ DB 'Improvements '
	DB	'- TechNoFreshWaterYieldChanges', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0NP@FDAJIDEK@select?5Yields?4ID?5as?5YieldID?0?5Tec@
CONST	SEGMENT
??_C@_0NP@FDAJIDEK@select?5Yields?4ID?5as?5YieldID?0?5Tec@ DB 'select Yie'
	DB	'lds.ID as YieldID, Technologies.ID as TechID, Yield from Impr'
	DB	'ovement_TechYieldChanges inner join Yields on YieldType = Yie'
	DB	'lds.Type inner join Technologies on TechType = Technologies.T'
	DB	'ype where ImprovementType = ?', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@MLIOACLH@Improvements?5?9?5TechYieldChanges?$AA@
CONST	SEGMENT
??_C@_0CA@MLIOACLH@Improvements?5?9?5TechYieldChanges?$AA@ DB 'Improvemen'
	DB	'ts - TechYieldChanges', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05LNDKIJIJ@Yield?$AA@
CONST	SEGMENT
??_C@_05LNDKIJIJ@Yield?$AA@ DB 'Yield', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JAMLCLDI@Yields?$AA@
CONST	SEGMENT
??_C@_06JAMLCLDI@Yields?$AA@ DB 'Yields', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BHIANCDJ@QuantityRequirement?$AA@
CONST	SEGMENT
??_C@_0BE@BHIANCDJ@QuantityRequirement?$AA@ DB 'QuantityRequirement', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@ILMABPGL@DiscoveryRand?$AA@
CONST	SEGMENT
??_C@_0O@ILMABPGL@DiscoveryRand?$AA@ DB 'DiscoveryRand', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OCBJCFBM@ResourceTrade?$AA@
CONST	SEGMENT
??_C@_0O@OCBJCFBM@ResourceTrade?$AA@ DB 'ResourceTrade', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EAAJGMOP@ResourceMakesValid?$AA@
CONST	SEGMENT
??_C@_0BD@EAAJGMOP@ResourceMakesValid?$AA@ DB 'ResourceMakesValid', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EPHJOCBJ@ResourceType?$AA@
CONST	SEGMENT
??_C@_0N@EPHJOCBJ@ResourceType?$AA@ DB 'ResourceType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02OLOABKKD@ID?$AA@
CONST	SEGMENT
??_C@_02OLOABKKD@ID?$AA@ DB 'ID', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0JJ@KHHJOGON@select?5Yields?4ID?0?5Yield?5from?5Imp@
CONST	SEGMENT
??_C@_0JJ@KHHJOGON@select?5Yields?4ID?0?5Yield?5from?5Imp@ DB 'select Yie'
	DB	'lds.ID, Yield from Improvement_ResourceType_Yields inner join'
	DB	' Yields on YieldType = Yields.Type where ImprovementType = ? '
	DB	'and ResourceType = ?', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@NJMJOCGJ@Improvements?5?9?5YieldResults?$AA@
CONST	SEGMENT
??_C@_0BM@NJMJOCGJ@Improvements?5?9?5YieldResults?$AA@ DB 'Improvements -'
	DB	' YieldResults', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0MD@JCBBECJP@select?5Resources?4ID?0?5ResourceTyp@
CONST	SEGMENT
??_C@_0MD@JCBBECJP@select?5Resources?4ID?0?5ResourceTyp@ DB 'select Resou'
	DB	'rces.ID, ResourceType, ResourceMakesValid, ResourceTrade, Dis'
	DB	'coveryRand from Improvement_ResourceTypes inner join Resource'
	DB	's on ResourceType = Resources.Type where ImprovementType = ?', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@OECFNINC@Improvements?5?9?5ResourceTypes?$AA@
CONST	SEGMENT
??_C@_0BN@OECFNINC@Improvements?5?9?5ResourceTypes?$AA@ DB 'Improvements '
	DB	'- ResourceTypes', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09FDCBPLKG@Resources?$AA@
CONST	SEGMENT
??_C@_09FDCBPLKG@Resources?$AA@ DB 'Resources', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MGDAOLO@Improvement_Flavors?$AA@
CONST	SEGMENT
??_C@_0BE@MGDAOLO@Improvement_Flavors?$AA@ DB 'Improvement_Flavors', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DNANAMLL@Improvement_PrereqNatureYields?$AA@
CONST	SEGMENT
??_C@_0BP@DNANAMLL@Improvement_PrereqNatureYields?$AA@ DB 'Improvement_Pr'
	DB	'ereqNatureYields', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FNAFGHPN@Improvement_RiverSideYields?$AA@
CONST	SEGMENT
??_C@_0BM@FNAFGHPN@Improvement_RiverSideYields?$AA@ DB 'Improvement_River'
	DB	'SideYields', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MLCOMNFP@Improvement_HillsYields?$AA@
CONST	SEGMENT
??_C@_0BI@MLCOMNFP@Improvement_HillsYields?$AA@ DB 'Improvement_HillsYiel'
	DB	'ds', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@GOMKPHOC@Improvement_FreshWaterYields?$AA@
CONST	SEGMENT
??_C@_0BN@GOMKPHOC@Improvement_FreshWaterYields?$AA@ DB 'Improvement_Fres'
	DB	'hWaterYields', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@MLDKINGM@Improvement_CoastalLandYields?$AA@
CONST	SEGMENT
??_C@_0BO@MLDKINGM@Improvement_CoastalLandYields?$AA@ DB 'Improvement_Coa'
	DB	'stalLandYields', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@DKNIFGIA@Improvement_AdjacentMountainYiel@
CONST	SEGMENT
??_C@_0CJ@DKNIFGIA@Improvement_AdjacentMountainYiel@ DB 'Improvement_Adja'
	DB	'centMountainYieldChanges', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@MOPDDKEG@Improvement_AdjacentCityYields?$AA@
CONST	SEGMENT
??_C@_0BP@MOPDDKEG@Improvement_AdjacentCityYields?$AA@ DB 'Improvement_Ad'
	DB	'jacentCityYields', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FLAHPOKL@Improvement_YieldPerEra?$AA@
CONST	SEGMENT
??_C@_0BI@FLAHPOKL@Improvement_YieldPerEra?$AA@ DB 'Improvement_YieldPerE'
	DB	'ra', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CCIBEEC@Improvement_Yields?$AA@
CONST	SEGMENT
??_C@_0BD@CCIBEEC@Improvement_Yields?$AA@ DB 'Improvement_Yields', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CJDAHDJO@Improvements?$AA@
CONST	SEGMENT
??_C@_0N@CJDAHDJO@Improvements?$AA@ DB 'Improvements', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@PLHLCHHA@Improvement_ValidImprovements?$AA@
CONST	SEGMENT
??_C@_0BO@PLHLCHHA@Improvement_ValidImprovements?$AA@ DB 'Improvement_Val'
	DB	'idImprovements', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JKAACCPI@PrereqImprovement?$AA@
CONST	SEGMENT
??_C@_0BC@JKAACCPI@PrereqImprovement?$AA@ DB 'PrereqImprovement', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08CLANBDND@Features?$AA@
CONST	SEGMENT
??_C@_08CLANBDND@Features?$AA@ DB 'Features', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@LNHHOEJ@Improvement_ValidFeatures?$AA@
CONST	SEGMENT
??_C@_0BK@LNHHOEJ@Improvement_ValidFeatures?$AA@ DB 'Improvement_ValidFea'
	DB	'tures', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LJDMFNNN@FeatureType?$AA@
CONST	SEGMENT
??_C@_0M@LJDMFNNN@FeatureType?$AA@ DB 'FeatureType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08DHHJBCFH@Terrains?$AA@
CONST	SEGMENT
??_C@_08DHHJBCFH@Terrains?$AA@ DB 'Terrains', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BHKDHPMN@Improvement_ValidTerrains?$AA@
CONST	SEGMENT
??_C@_0BK@BHKDHPMN@Improvement_ValidTerrains?$AA@ DB 'Improvement_ValidTe'
	DB	'rrains', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BBHDGKPJ@TerrainType?$AA@
CONST	SEGMENT
??_C@_0M@BBHDGKPJ@TerrainType?$AA@ DB 'TerrainType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PMOLGEPK@ImprovementType?$AA@
CONST	SEGMENT
??_C@_0BA@PMOLGEPK@ImprovementType?$AA@ DB 'ImprovementType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MPPFDDCN@ImprovementUpgrade?$AA@
CONST	SEGMENT
??_C@_0BD@MPPFDDCN@ImprovementUpgrade?$AA@ DB 'ImprovementUpgrade', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MCACIDCN@ImprovementPillage?$AA@
CONST	SEGMENT
??_C@_0BD@MCACIDCN@ImprovementPillage?$AA@ DB 'ImprovementPillage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@OMPGKABL@Warning?3?5Missing?5soundscape?5defi@
CONST	SEGMENT
??_C@_0EA@OMPGKABL@Warning?3?5Missing?5soundscape?5defi@ DB 'Warning: Mis'
	DB	'sing soundscape definition in XML for feature: ''%s''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@EOODAKIM@WorldSoundscapeAudioScript?$AA@
CONST	SEGMENT
??_C@_0BL@EOODAKIM@WorldSoundscapeAudioScript?$AA@ DB 'WorldSoundscapeAud'
	DB	'ioScript', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GDPFJHJJ@CivilizationType?$AA@
CONST	SEGMENT
??_C@_0BB@GDPFJHJJ@CivilizationType?$AA@ DB 'CivilizationType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@LOONOMNN@LuxuryCopiesSiphonedFromMinor?$AA@
CONST	SEGMENT
??_C@_0BO@LOONOMNN@LuxuryCopiesSiphonedFromMinor?$AA@ DB 'LuxuryCopiesSip'
	DB	'honedFromMinor', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HNLDIHFB@ResourceExtractionMod?$AA@
CONST	SEGMENT
??_C@_0BG@HNLDIHFB@ResourceExtractionMod?$AA@ DB 'ResourceExtractionMod', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JMIEJANC@SpecificCivRequired?$AA@
CONST	SEGMENT
??_C@_0BE@JMIEJANC@SpecificCivRequired?$AA@ DB 'SpecificCivRequired', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OHDPBMDL@CreatedByGreatPerson?$AA@
CONST	SEGMENT
??_C@_0BF@OHDPBMDL@CreatedByGreatPerson?$AA@ DB 'CreatedByGreatPerson', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JCCLNNJI@AllowsSailLand?$AA@
CONST	SEGMENT
??_C@_0P@JCCLNNJI@AllowsSailLand?$AA@ DB 'AllowsSailLand', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DAJEJENL@AllowsWalkWater?$AA@
CONST	SEGMENT
??_C@_0BA@DAJEJENL@AllowsWalkWater?$AA@ DB 'AllowsWalkWater', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OPMKDMKP@AdjacentLuxury?$AA@
CONST	SEGMENT
??_C@_0P@OPMKDMKP@AdjacentLuxury?$AA@ DB 'AdjacentLuxury', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OPDLHEPJ@NoTwoAdjacent?$AA@
CONST	SEGMENT
??_C@_0O@OPDLHEPJ@NoTwoAdjacent?$AA@ DB 'NoTwoAdjacent', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JDPNOMKI@OnlyCityStateTerritory?$AA@
CONST	SEGMENT
??_C@_0BH@JDPNOMKI@OnlyCityStateTerritory?$AA@ DB 'OnlyCityStateTerritory'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DHOGLFDO@IgnoreOwnership?$AA@
CONST	SEGMENT
??_C@_0BA@DHOGLFDO@IgnoreOwnership?$AA@ DB 'IgnoreOwnership', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JNHNLDMJ@InAdjacentFriendly?$AA@
CONST	SEGMENT
??_C@_0BD@JNHNLDMJ@InAdjacentFriendly?$AA@ DB 'InAdjacentFriendly', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HHOKABHL@OutsideBorders?$AA@
CONST	SEGMENT
??_C@_0P@HHOKABHL@OutsideBorders?$AA@ DB 'OutsideBorders', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CBOHOOCD@PillageGold?$AA@
CONST	SEGMENT
??_C@_0M@CBOHOOCD@PillageGold?$AA@ DB 'PillageGold', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JCHHBBPA@NearbyEnemyDamage?$AA@
CONST	SEGMENT
??_C@_0BC@JCHHBBPA@NearbyEnemyDamage?$AA@ DB 'NearbyEnemyDamage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FFFHFPGD@DefenseModifierGlobal?$AA@
CONST	SEGMENT
??_C@_0BG@FFFHFPGD@DefenseModifierGlobal?$AA@ DB 'DefenseModifierGlobal', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BLEBFEEF@DefenseModifier?$AA@
CONST	SEGMENT
??_C@_0BA@BLEBFEEF@DefenseModifier?$AA@ DB 'DefenseModifier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FBPICDKJ@FreshWaterUpgradeMod?$AA@
CONST	SEGMENT
??_C@_0BF@FBPICDKJ@FreshWaterUpgradeMod?$AA@ DB 'FreshWaterUpgradeMod', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PGBFHPDG@HillsUpgradeMod?$AA@
CONST	SEGMENT
??_C@_0BA@PGBFHPDG@HillsUpgradeMod?$AA@ DB 'HillsUpgradeMod', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BOJPKJEI@CoastalLandUpgradeMod?$AA@
CONST	SEGMENT
??_C@_0BG@BOJPKJEI@CoastalLandUpgradeMod?$AA@ DB 'CoastalLandUpgradeMod', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GMJNJAOL@RiverSideUpgradeMod?$AA@
CONST	SEGMENT
??_C@_0BE@GMJNJAOL@RiverSideUpgradeMod?$AA@ DB 'RiverSideUpgradeMod', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NLAHPCAM@UpgradeTime?$AA@
CONST	SEGMENT
??_C@_0M@NLAHPCAM@UpgradeTime?$AA@ DB 'UpgradeTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PLMBOHND@FeatureGrowth?$AA@
CONST	SEGMENT
??_C@_0O@PLMBOHND@FeatureGrowth?$AA@ DB 'FeatureGrowth', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IOJDFNDI@GoodyRange?$AA@
CONST	SEGMENT
??_C@_0L@IOJDFNDI@GoodyRange?$AA@ DB 'GoodyRange', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MCNHIFJF@TilesPerGoody?$AA@
CONST	SEGMENT
??_C@_0O@MCNHIFJF@TilesPerGoody?$AA@ DB 'TilesPerGoody', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09FHMJCGNI@Permanent?$AA@
CONST	SEGMENT
??_C@_09FHMJCGNI@Permanent?$AA@ DB 'Permanent', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05JFGEMCAC@Goody?$AA@
CONST	SEGMENT
??_C@_05JFGEMCAC@Goody?$AA@ DB 'Goody', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FOCNADKB@BarbarianCamp?$AA@
CONST	SEGMENT
??_C@_0O@FOCNADKB@BarbarianCamp?$AA@ DB 'BarbarianCamp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MDOCFNBI@BuildableOnResources?$AA@
CONST	SEGMENT
??_C@_0BF@MDOCFNBI@BuildableOnResources?$AA@ DB 'BuildableOnResources', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HAMCANB@DisplacePillager?$AA@
CONST	SEGMENT
??_C@_0BB@HAMCANB@DisplacePillager?$AA@ DB 'DisplacePillager', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DGACHGGA@DestroyedWhenPillaged?$AA@
CONST	SEGMENT
??_C@_0BG@DGACHGGA@DestroyedWhenPillaged?$AA@ DB 'DestroyedWhenPillaged', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07FJOLCNAD@Coastal?$AA@
CONST	SEGMENT
??_C@_07FJOLCNAD@Coastal?$AA@ DB 'Coastal', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05EMKMBNJK@Water?$AA@
CONST	SEGMENT
??_C@_05EMKMBNJK@Water?$AA@ DB 'Water', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GHCHBJMK@PromptWhenComplete?$AA@
CONST	SEGMENT
??_C@_0BD@GHCHBJMK@PromptWhenComplete?$AA@ DB 'PromptWhenComplete', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IKLICPAM@RemovesResource?$AA@
CONST	SEGMENT
??_C@_0BA@IKLICPAM@RemovesResource?$AA@ DB 'RemovesResource', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@ONMAAIBI@RequiresImprovement?$AA@
CONST	SEGMENT
??_C@_0BE@ONMAAIBI@RequiresImprovement?$AA@ DB 'RequiresImprovement', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PKHCPDEE@RequiresFeature?$AA@
CONST	SEGMENT
??_C@_0BA@PKHCPDEE@RequiresFeature?$AA@ DB 'RequiresFeature', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GAKGDCFD@RequiresFlatlandsOrFreshWater?$AA@
CONST	SEGMENT
??_C@_0BO@GAKGDCFD@RequiresFlatlandsOrFreshWater?$AA@ DB 'RequiresFlatlan'
	DB	'dsOrFreshWater', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IDFGBFEH@RequiresFlatlands?$AA@
CONST	SEGMENT
??_C@_0BC@IDFGBFEH@RequiresFlatlands?$AA@ DB 'RequiresFlatlands', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KPIEECMK@NoFreshWater?$AA@
CONST	SEGMENT
??_C@_0N@KPIEECMK@NoFreshWater?$AA@ DB 'NoFreshWater', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@HAPOKNPN@RiverSideMakesValid?$AA@
CONST	SEGMENT
??_C@_0BE@HAPOKNPN@RiverSideMakesValid?$AA@ DB 'RiverSideMakesValid', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@ENJLBOLP@FreshWaterMakesValid?$AA@
CONST	SEGMENT
??_C@_0BF@ENJLBOLP@FreshWaterMakesValid?$AA@ DB 'FreshWaterMakesValid', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KPFJLEOH@WaterAdjacencyMakesValid?$AA@
CONST	SEGMENT
??_C@_0BJ@KPFJLEOH@WaterAdjacencyMakesValid?$AA@ DB 'WaterAdjacencyMakesV'
	DB	'alid', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OKHGECCA@HillsMakesValid?$AA@
CONST	SEGMENT
??_C@_0BA@OKHGECCA@HillsMakesValid?$AA@ DB 'HillsMakesValid', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@EGCIFCHA@CultureAdjacentSameType?$AA@
CONST	SEGMENT
??_C@_0BI@EGCIFCHA@CultureAdjacentSameType?$AA@ DB 'CultureAdjacentSameTy'
	DB	'pe', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NLHAEONM@RequiresXAdjacentLand?$AA@
CONST	SEGMENT
??_C@_0BG@NLHAEONM@RequiresXAdjacentLand?$AA@ DB 'RequiresXAdjacentLand', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HNFKIGOI@CultureBombRadiusNeutral?$AA@
CONST	SEGMENT
??_C@_0BJ@HNFKIGOI@CultureBombRadiusNeutral?$AA@ DB 'CultureBombRadiusNeu'
	DB	'tral', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NEFPKCDN@CultureBombRadius?$AA@
CONST	SEGMENT
??_C@_0BC@NEFPKCDN@CultureBombRadius?$AA@ DB 'CultureBombRadius', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NGAILOKJ@GoldMaintenance?$AA@
CONST	SEGMENT
??_C@_0BA@NGAILOKJ@GoldMaintenance?$AA@ DB 'GoldMaintenance', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NLPPFOOH@ArtDefineTag?$AA@
CONST	SEGMENT
??_C@_0N@NLPPFOOH@ArtDefineTag?$AA@ DB 'ArtDefineTag', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$6
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvimprovementclasses.cpp
xdata$x	ENDS
;	COMDAT ?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
tv544 = -384						; size = 4
tv400 = -380						; size = 4
tv1046 = -373						; size = 1
tv1043 = -372						; size = 4
tv1040 = -368						; size = 4
tv360 = -364						; size = 4
_this$ = -360						; size = 4
_count$219373 = -348					; size = 4
$T219359 = -336						; size = 4
$T219346 = -332						; size = 4
$T219345 = -328						; size = 4
$T219344 = -324						; size = 4
_route_idx$217787 = -320				; size = 4
_yield$217788 = -316					; size = 4
_yield_idx$217786 = -312				; size = 4
_pResults$217780 = -308					; size = 4
_strKey$217778 = -304					; size = 28
_iNumRoutes$217776 = -276				; size = 4
_yield$217775 = -272					; size = 4
_yield_idx$217773 = -268				; size = 4
_tech_idx$217774 = -264					; size = 4
_pResults$217767 = -260					; size = 4
_strKey$217765 = -256					; size = 28
_yield$217764 = -228					; size = 4
_yield_idx$217762 = -224				; size = 4
_tech_idx$217763 = -220					; size = 4
_pResults$217756 = -216					; size = 4
_strKey$217754 = -212					; size = 28
_yield$217753 = -184					; size = 4
_yield_idx$217751 = -180				; size = 4
_tech_idx$217752 = -176					; size = 4
_pResults$217745 = -172					; size = 4
_strKey$217743 = -168					; size = 28
_yieldIdx$217738 = -140					; size = 4
_yield$217739 = -136					; size = 4
_szResourceType$217727 = -132				; size = 4
_idx$217724 = -128					; size = 4
_pResourceInfo$217726 = -124				; size = 4
_pResourceTypes$217713 = -120				; size = 4
_strResourceTypesKey$217711 = -116			; size = 28
_pYieldResults$217718 = -88				; size = 4
_iNumResources$217697 = -84				; size = 4
_strYieldResultsKey$217716 = -80			; size = 28
__$ArrayPad$ = -52					; size = 4
_szImprovementType$ = -48				; size = 4
_szArtDefineTag$ = -44					; size = 4
_szCivilizationType$ = -40				; size = 4
_szImprovementPillage$ = -36				; size = 4
_iNumTechs$ = -32					; size = 4
_iNumYields$ = -28					; size = 4
_szWorldsoundscapeAudioScript$ = -24			; size = 4
_szImprovementUpgrade$ = -20				; size = 4
_lenImprovementType$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvImprovementEntry::CacheResults, COMDAT
; _this$ = ecx

; 202  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 372				; 00000174H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 203  : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kResults$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN21@CacheResul

; 204  : 		return false;

	xor	al, al
	jmp	$LN22@CacheResul
$LN21@CacheResul:

; 205  : 
; 206  : 	//Basic properties
; 207  : 	const char* szArtDefineTag = kResults.GetText("ArtDefineTag");

	push	OFFSET ??_C@_0N@NLPPFOOH@ArtDefineTag?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szArtDefineTag$[ebp], eax

; 208  : 	SetArtDefineTag(szArtDefineTag);

	mov	eax, DWORD PTR _szArtDefineTag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetArtDefineTag@CvImprovementEntry@@QAEXPBD@Z ; CvImprovementEntry::SetArtDefineTag

; 209  : 
; 210  : 	m_iGoldMaintenance = kResults.GetInt("GoldMaintenance");

	push	OFFSET ??_C@_0BA@NGAILOKJ@GoldMaintenance?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+260], eax

; 211  : 	m_iCultureBombRadius = kResults.GetInt("CultureBombRadius");

	push	OFFSET ??_C@_0BC@NEFPKCDN@CultureBombRadius?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+264], eax

; 212  : 	m_iCultureBombRadiusNeutral = kResults.GetInt("CultureBombRadiusNeutral");

	push	OFFSET ??_C@_0BJ@HNFKIGOI@CultureBombRadiusNeutral?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+268], eax

; 213  : 	m_iRequiresXAdjacentLand = kResults.GetInt("RequiresXAdjacentLand");

	push	OFFSET ??_C@_0BG@NLHAEONM@RequiresXAdjacentLand?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+340], eax

; 214  : 	m_iCultureAdjacentSameType = kResults.GetInt("CultureAdjacentSameType");

	push	OFFSET ??_C@_0BI@EGCIFCHA@CultureAdjacentSameType?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+272], eax

; 215  : 	m_bHillsMakesValid = kResults.GetBool("HillsMakesValid");

	push	OFFSET ??_C@_0BA@OKHGECCA@HillsMakesValid?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+344], al

; 216  : 	m_bWaterAdjacencyMakesValid = kResults.GetBool("WaterAdjacencyMakesValid");

	push	OFFSET ??_C@_0BJ@KPFJLEOH@WaterAdjacencyMakesValid?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+345], al

; 217  : 	m_bFreshWaterMakesValid = kResults.GetBool("FreshWaterMakesValid");

	push	OFFSET ??_C@_0BF@ENJLBOLP@FreshWaterMakesValid?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+346], al

; 218  : 	m_bRiverSideMakesValid = kResults.GetBool("RiverSideMakesValid");

	push	OFFSET ??_C@_0BE@HAPOKNPN@RiverSideMakesValid?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+347], al

; 219  : 	m_bNoFreshWater = kResults.GetBool("NoFreshWater");

	push	OFFSET ??_C@_0N@KPIEECMK@NoFreshWater?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+348], al

; 220  : 	m_bRequiresFlatlands = kResults.GetBool("RequiresFlatlands");

	push	OFFSET ??_C@_0BC@IDFGBFEH@RequiresFlatlands?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+349], al

; 221  : 	m_bRequiresFlatlandsOrFreshWater = kResults.GetBool("RequiresFlatlandsOrFreshWater");

	push	OFFSET ??_C@_0BO@GAKGDCFD@RequiresFlatlandsOrFreshWater?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+350], al

; 222  : 	m_bRequiresFeature = kResults.GetBool("RequiresFeature");

	push	OFFSET ??_C@_0BA@PKHCPDEE@RequiresFeature?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+351], al

; 223  : 	m_bRequiresImprovement = kResults.GetBool("RequiresImprovement");

	push	OFFSET ??_C@_0BE@ONMAAIBI@RequiresImprovement?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+352], al

; 224  : 	m_bRemovesResource = kResults.GetBool("RemovesResource");

	push	OFFSET ??_C@_0BA@IKLICPAM@RemovesResource?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+353], al

; 225  : 	m_bPromptWhenComplete = kResults.GetBool("PromptWhenComplete");

	push	OFFSET ??_C@_0BD@GHCHBJMK@PromptWhenComplete?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+354], al

; 226  : 	m_bWater = kResults.GetBool("Water");

	push	OFFSET ??_C@_05EMKMBNJK@Water?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+355], al

; 227  : 	m_bCoastal = kResults.GetBool("Coastal");

	push	OFFSET ??_C@_07FJOLCNAD@Coastal?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+356], al

; 228  : 	m_bDestroyedWhenPillaged = kResults.GetBool("DestroyedWhenPillaged");

	push	OFFSET ??_C@_0BG@DGACHGGA@DestroyedWhenPillaged?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+357], al

; 229  : 	m_bDisplacePillager = kResults.GetBool("DisplacePillager");

	push	OFFSET ??_C@_0BB@HAMCANB@DisplacePillager?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+358], al

; 230  : 	m_bBuildableOnResources = kResults.GetBool("BuildableOnResources");

	push	OFFSET ??_C@_0BF@MDOCFNBI@BuildableOnResources?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+359], al

; 231  : 	m_eImprovementUsageType = m_bBuildableOnResources ? IMPROVEMENTUSAGE_LANDMARK : IMPROVEMENTUSAGE_BASIC;

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+359]
	neg	eax
	sbb	eax, eax
	neg	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+404], eax

; 232  : 	m_bBarbarianCamp = kResults.GetBool("BarbarianCamp");

	push	OFFSET ??_C@_0O@FOCNADKB@BarbarianCamp?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+360], al

; 233  : 	m_bGoody = kResults.GetBool("Goody");

	push	OFFSET ??_C@_05JFGEMCAC@Goody?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+361], al

; 234  : 	m_bPermanent = kResults.GetBool("Permanent");

	push	OFFSET ??_C@_09FHMJCGNI@Permanent?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+362], al

; 235  : 	m_iTilesPerGoody = kResults.GetInt("TilesPerGoody");

	push	OFFSET ??_C@_0O@MCNHIFJF@TilesPerGoody?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+276], eax

; 236  : 	m_iGoodyUniqueRange = kResults.GetInt("GoodyRange");

	push	OFFSET ??_C@_0L@IOJDFNDI@GoodyRange?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+280], eax

; 237  : 	m_iFeatureGrowthProbability = kResults.GetInt("FeatureGrowth");

	push	OFFSET ??_C@_0O@PLMBOHND@FeatureGrowth?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+284], eax

; 238  : 	m_iUpgradeTime = kResults.GetInt("UpgradeTime");

	push	OFFSET ??_C@_0M@NLAHPCAM@UpgradeTime?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+288], eax

; 239  : 	m_iRiverSideUpgradeMod = kResults.GetInt("RiverSideUpgradeMod");

	push	OFFSET ??_C@_0BE@GMJNJAOL@RiverSideUpgradeMod?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+292], eax

; 240  : 	m_iCoastalLandUpgradeMod = kResults.GetInt("CoastalLandUpgradeMod");

	push	OFFSET ??_C@_0BG@BOJPKJEI@CoastalLandUpgradeMod?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+296], eax

; 241  : 	m_iHillsUpgradeMod = kResults.GetInt("HillsUpgradeMod");

	push	OFFSET ??_C@_0BA@PGBFHPDG@HillsUpgradeMod?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+300], eax

; 242  : 	m_iFreshWaterUpgradeMod = kResults.GetInt("FreshWaterUpgradeMod");

	push	OFFSET ??_C@_0BF@FBPICDKJ@FreshWaterUpgradeMod?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+304], eax

; 243  : 	m_iDefenseModifier = kResults.GetInt("DefenseModifier");

	push	OFFSET ??_C@_0BA@BLEBFEEF@DefenseModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+308], eax

; 244  : 	m_iDefenseModifierGlobal = kResults.GetInt("DefenseModifierGlobal");

	push	OFFSET ??_C@_0BG@FFFHFPGD@DefenseModifierGlobal?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+312], eax

; 245  : 	m_iNearbyEnemyDamage = kResults.GetInt("NearbyEnemyDamage");

	push	OFFSET ??_C@_0BC@JCHHBBPA@NearbyEnemyDamage?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+316], eax

; 246  : 	m_iPillageGold = kResults.GetInt("PillageGold");

	push	OFFSET ??_C@_0M@CBOHOOCD@PillageGold?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+320], eax

; 247  : 	m_bOutsideBorders = kResults.GetBool("OutsideBorders");

	push	OFFSET ??_C@_0P@HHOKABHL@OutsideBorders?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+363], al

; 248  : 	m_bInAdjacentFriendly = kResults.GetBool("InAdjacentFriendly");

	push	OFFSET ??_C@_0BD@JNHNLDMJ@InAdjacentFriendly?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+364], al

; 249  : 	m_bIgnoreOwnership = kResults.GetBool("IgnoreOwnership");

	push	OFFSET ??_C@_0BA@DHOGLFDO@IgnoreOwnership?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+365], al

; 250  : 	m_bOnlyCityStateTerritory = kResults.GetBool("OnlyCityStateTerritory");

	push	OFFSET ??_C@_0BH@JDPNOMKI@OnlyCityStateTerritory?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+366], al

; 251  : 	m_bNoTwoAdjacent = kResults.GetBool("NoTwoAdjacent");

	push	OFFSET ??_C@_0O@OPDLHEPJ@NoTwoAdjacent?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+367], al

; 252  : 	m_bAdjacentLuxury = kResults.GetBool("AdjacentLuxury");

	push	OFFSET ??_C@_0P@OPMKDMKP@AdjacentLuxury?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+368], al

; 253  : 	m_bAllowsWalkWater = kResults.GetBool("AllowsWalkWater");

	push	OFFSET ??_C@_0BA@DAJEJENL@AllowsWalkWater?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+369], al

; 254  : 	m_bAllowsSailLand = kResults.GetBool("AllowsSailLand"); // from Izy

	push	OFFSET ??_C@_0P@JCCLNNJI@AllowsSailLand?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+370], al

; 255  : 	m_bCreatedByGreatPerson = kResults.GetBool("CreatedByGreatPerson");

	push	OFFSET ??_C@_0BF@OHDPBMDL@CreatedByGreatPerson?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+371], al

; 256  : 	m_bSpecificCivRequired = kResults.GetBool("SpecificCivRequired");

	push	OFFSET ??_C@_0BE@JMIEJANC@SpecificCivRequired?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+372], al

; 257  : 	m_iResourceExtractionMod = kResults.GetInt("ResourceExtractionMod");

	push	OFFSET ??_C@_0BG@HNLDIHFB@ResourceExtractionMod?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+324], eax

; 258  : 	m_iLuxuryCopiesSiphonedFromMinor = kResults.GetInt("LuxuryCopiesSiphonedFromMinor");

	push	OFFSET ??_C@_0BO@LOONOMNN@LuxuryCopiesSiphonedFromMinor?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+328], eax

; 259  : 
; 260  : 	const char* szCivilizationType = kResults.GetText("CivilizationType");

	push	OFFSET ??_C@_0BB@GDPFJHJJ@CivilizationType?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szCivilizationType$[ebp], eax

; 261  : 	m_eRequiredCivilization = (CivilizationTypes)GC.getInfoTypeForString(szCivilizationType, true);

	push	1
	mov	eax, DWORD PTR _szCivilizationType$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+408], eax

; 262  : 
; 263  : 	//References
; 264  : 	const char* szWorldsoundscapeAudioScript = kResults.GetText("WorldSoundscapeAudioScript");

	push	OFFSET ??_C@_0BL@EOODAKIM@WorldSoundscapeAudioScript?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szWorldsoundscapeAudioScript$[ebp], eax

; 265  : 	if(szWorldsoundscapeAudioScript != NULL)

	cmp	DWORD PTR _szWorldsoundscapeAudioScript$[ebp], 0
	je	SHORT $LN20@CacheResul

; 266  : 	{
; 267  : 		m_iWorldSoundscapeScriptId = gDLL->GetAudioTagIndex(szWorldsoundscapeAudioScript, AUDIOTAG_SOUNDSCAPE);

	mov	edx, DWORD PTR $T219359[ebp]
	mov	DWORD PTR tv360[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv360[ebp], eax
	push	5
	mov	ecx, DWORD PTR _szWorldsoundscapeAudioScript$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv360[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv360[ebp]
	mov	edx, DWORD PTR [eax+508]
	call	edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+412], eax

; 268  : 	}
; 269  : 	else

	jmp	SHORT $LN19@CacheResul
$LN20@CacheResul:

; 270  : 	{
; 271  : 		m_iWorldSoundscapeScriptId = -1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+412], -1

; 272  : 		Remark(1, "Warning: Missing soundscape definition in XML for feature: '%s'", GetType());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0EA@OMPGKABL@Warning?3?5Missing?5soundscape?5defi@
	push	1
	call	?Remark@@YA_NHPBDZZ			; Remark
	add	esp, 12					; 0000000cH
$LN19@CacheResul:

; 273  : 	}
; 274  : 
; 275  : 	const char* szImprovementPillage = kResults.GetText("ImprovementPillage");

	push	OFFSET ??_C@_0BD@MCACIDCN@ImprovementPillage?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szImprovementPillage$[ebp], eax

; 276  : 	m_iImprovementPillage = GC.getInfoTypeForString(szImprovementPillage, true);

	push	1
	mov	eax, DWORD PTR _szImprovementPillage$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+332], eax

; 277  : 
; 278  : 	const char* szImprovementUpgrade = kResults.GetText("ImprovementUpgrade");

	push	OFFSET ??_C@_0BD@MPPFDDCN@ImprovementUpgrade?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szImprovementUpgrade$[ebp], eax

; 279  : 	m_iImprovementUpgrade = GC.getInfoTypeForString(szImprovementUpgrade, true);

	push	1
	mov	edx, DWORD PTR _szImprovementUpgrade$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+336], eax

; 280  : 
; 281  : 	//Arrays
; 282  : 	const char* szImprovementType = GetType();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR _szImprovementType$[ebp], eax

; 283  : 	const size_t lenImprovementType = strlen(szImprovementType);

	mov	edx, DWORD PTR _szImprovementType$[ebp]
	mov	DWORD PTR tv1040[ebp], edx
	mov	eax, DWORD PTR tv1040[ebp]
	add	eax, 1
	mov	DWORD PTR tv1043[ebp], eax
$LL56@CacheResul:
	mov	ecx, DWORD PTR tv1040[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv1046[ebp], dl
	add	DWORD PTR tv1040[ebp], 1
	cmp	BYTE PTR tv1046[ebp], 0
	jne	SHORT $LL56@CacheResul
	mov	eax, DWORD PTR tv1040[ebp]
	sub	eax, DWORD PTR tv1043[ebp]
	mov	DWORD PTR tv400[ebp], eax
	mov	ecx, DWORD PTR tv400[ebp]
	mov	DWORD PTR _lenImprovementType$[ebp], ecx

; 284  : 
; 285  : 	kUtility.PopulateArrayByExistence(m_pbTerrainMakesValid,
; 286  : 	                                  "Terrains",
; 287  : 	                                  "Improvement_ValidTerrains",
; 288  : 	                                  "TerrainType",
; 289  : 	                                  "ImprovementType",
; 290  : 	                                  szImprovementType);

	mov	edx, DWORD PTR _szImprovementType$[ebp]
	push	edx
	push	OFFSET ??_C@_0BA@PMOLGEPK@ImprovementType?$AA@
	push	OFFSET ??_C@_0M@BBHDGKPJ@TerrainType?$AA@
	push	OFFSET ??_C@_0BK@BHKDHPMN@Improvement_ValidTerrains?$AA@
	push	OFFSET ??_C@_08DHHJBCFH@Terrains?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 460				; 000001ccH
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence

; 291  : 
; 292  : 	kUtility.PopulateArrayByExistence(m_pbFeatureMakesValid,
; 293  : 	                                  "Features",
; 294  : 	                                  "Improvement_ValidFeatures",
; 295  : 	                                  "FeatureType",
; 296  : 	                                  "ImprovementType",
; 297  : 	                                  szImprovementType);

	mov	ecx, DWORD PTR _szImprovementType$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BA@PMOLGEPK@ImprovementType?$AA@
	push	OFFSET ??_C@_0M@LJDMFNNN@FeatureType?$AA@
	push	OFFSET ??_C@_0BK@LNHHOEJ@Improvement_ValidFeatures?$AA@
	push	OFFSET ??_C@_08CLANBDND@Features?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 464				; 000001d0H
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence

; 298  : 
; 299  : 	kUtility.PopulateArrayByExistence(m_pbImprovementMakesValid,
; 300  : 									  "Improvements",
; 301  : 									  "Improvement_ValidImprovements",
; 302  : 									  "PrereqImprovement",
; 303  : 									  "ImprovementType",
; 304  : 							          szImprovementType);

	mov	eax, DWORD PTR _szImprovementType$[ebp]
	push	eax
	push	OFFSET ??_C@_0BA@PMOLGEPK@ImprovementType?$AA@
	push	OFFSET ??_C@_0BC@JKAACCPI@PrereqImprovement?$AA@
	push	OFFSET ??_C@_0BO@PLHLCHHA@Improvement_ValidImprovements?$AA@
	push	OFFSET ??_C@_0N@CJDAHDJO@Improvements?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 468				; 000001d4H
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence

; 305  : 
; 306  : 	kUtility.SetYields(m_piYieldChange, "Improvement_Yields", "ImprovementType", szImprovementType);

	mov	edx, DWORD PTR _szImprovementType$[ebp]
	push	edx
	push	OFFSET ??_C@_0BA@PMOLGEPK@ImprovementType?$AA@
	push	OFFSET ??_C@_0BD@CCIBEEC@Improvement_Yields?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 424				; 000001a8H
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 307  : 	kUtility.SetYields(m_piYieldPerEra, "Improvement_YieldPerEra", "ImprovementType", szImprovementType);

	mov	ecx, DWORD PTR _szImprovementType$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BA@PMOLGEPK@ImprovementType?$AA@
	push	OFFSET ??_C@_0BI@FLAHPOKL@Improvement_YieldPerEra?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 428				; 000001acH
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 308  : 	kUtility.SetYields(m_piAdjacentCityYieldChange, "Improvement_AdjacentCityYields", "ImprovementType", szImprovementType);

	mov	eax, DWORD PTR _szImprovementType$[ebp]
	push	eax
	push	OFFSET ??_C@_0BA@PMOLGEPK@ImprovementType?$AA@
	push	OFFSET ??_C@_0BP@MOPDDKEG@Improvement_AdjacentCityYields?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 448				; 000001c0H
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 309  : 	kUtility.SetYields(m_piAdjacentMountainYieldChange, "Improvement_AdjacentMountainYieldChanges", "ImprovementType", szImprovementType);

	mov	edx, DWORD PTR _szImprovementType$[ebp]
	push	edx
	push	OFFSET ??_C@_0BA@PMOLGEPK@ImprovementType?$AA@
	push	OFFSET ??_C@_0CJ@DKNIFGIA@Improvement_AdjacentMountainYiel@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 452				; 000001c4H
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 310  : 	kUtility.SetYields(m_piCoastalLandYieldChange, "Improvement_CoastalLandYields", "ImprovementType", szImprovementType);

	mov	ecx, DWORD PTR _szImprovementType$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BA@PMOLGEPK@ImprovementType?$AA@
	push	OFFSET ??_C@_0BO@MLDKINGM@Improvement_CoastalLandYields?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 436				; 000001b4H
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 311  : 	kUtility.SetYields(m_piFreshWaterChange, "Improvement_FreshWaterYields", "ImprovementType", szImprovementType);

	mov	eax, DWORD PTR _szImprovementType$[ebp]
	push	eax
	push	OFFSET ??_C@_0BA@PMOLGEPK@ImprovementType?$AA@
	push	OFFSET ??_C@_0BN@GOMKPHOC@Improvement_FreshWaterYields?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 444				; 000001bcH
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 312  : 	kUtility.SetYields(m_piHillsYieldChange, "Improvement_HillsYields", "ImprovementType", szImprovementType);

	mov	edx, DWORD PTR _szImprovementType$[ebp]
	push	edx
	push	OFFSET ??_C@_0BA@PMOLGEPK@ImprovementType?$AA@
	push	OFFSET ??_C@_0BI@MLCOMNFP@Improvement_HillsYields?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 440				; 000001b8H
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 313  : 	kUtility.SetYields(m_piRiverSideYieldChange, "Improvement_RiverSideYields", "ImprovementType", szImprovementType);

	mov	ecx, DWORD PTR _szImprovementType$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BA@PMOLGEPK@ImprovementType?$AA@
	push	OFFSET ??_C@_0BM@FNAFGHPN@Improvement_RiverSideYields?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 432				; 000001b0H
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 314  : 	kUtility.SetYields(m_piPrereqNatureYield, "Improvement_PrereqNatureYields", "ImprovementType", szImprovementType);

	mov	eax, DWORD PTR _szImprovementType$[ebp]
	push	eax
	push	OFFSET ??_C@_0BA@PMOLGEPK@ImprovementType?$AA@
	push	OFFSET ??_C@_0BP@DNANAMLL@Improvement_PrereqNatureYields?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 420				; 000001a4H
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 315  : 
; 316  : 	kUtility.SetFlavors(m_piFlavorValue, "Improvement_Flavors", "ImprovementType", szImprovementType);

	push	0
	mov	edx, DWORD PTR _szImprovementType$[ebp]
	push	edx
	push	OFFSET ??_C@_0BA@PMOLGEPK@ImprovementType?$AA@
	push	OFFSET ??_C@_0BE@MGDAOLO@Improvement_Flavors?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 456				; 000001c8H
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z ; CvDatabaseUtility::SetFlavors

; 317  : 
; 318  : 	{
; 319  : 		//Initialize Improvement Resource Types to number of Resources
; 320  : 		const int iNumResources = kUtility.MaxRows("Resources");

	push	OFFSET ??_C@_09FDCBPLKG@Resources?$AA@
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z	; CvDatabaseUtility::MaxRows
	mov	DWORD PTR _iNumResources$217697[ebp], eax

; 321  : 		m_paImprovementResource = FNEW(CvImprovementResourceInfo[iNumResources], c_eCiv5GameplayDLL, 0);

	mov	ecx, DWORD PTR _iNumResources$217697[ebp]
	mov	DWORD PTR $T219344[ebp], ecx
	xor	ecx, ecx
	mov	eax, DWORD PTR $T219344[ebp]
	mov	edx, 12					; 0000000cH
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T219346[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T219346[ebp], 0
	je	SHORT $LN24@CacheResul
	mov	ecx, DWORD PTR $T219346[ebp]
	mov	edx, DWORD PTR $T219344[ebp]
	mov	DWORD PTR [ecx], edx
	push	OFFSET ??1CvImprovementResourceInfo@@QAE@XZ ; CvImprovementResourceInfo::~CvImprovementResourceInfo
	push	OFFSET ??0CvImprovementResourceInfo@@QAE@XZ ; CvImprovementResourceInfo::CvImprovementResourceInfo
	mov	eax, DWORD PTR $T219344[ebp]
	push	eax
	push	12					; 0000000cH
	mov	ecx, DWORD PTR $T219346[ebp]
	add	ecx, 4
	push	ecx
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	mov	edx, DWORD PTR $T219346[ebp]
	add	edx, 4
	mov	DWORD PTR tv544[ebp], edx
	jmp	SHORT $LN25@CacheResul
$LN24@CacheResul:
	mov	DWORD PTR tv544[ebp], 0
$LN25@CacheResul:
	mov	eax, DWORD PTR tv544[ebp]
	mov	DWORD PTR $T219345[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T219345[ebp]
	mov	DWORD PTR [ecx+488], edx

; 322  : 
; 323  : 		kUtility.InitializeArray(m_piResourceQuantityRequirements, iNumResources);

	push	0
	mov	eax, DWORD PTR _iNumResources$217697[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 416				; 000001a0H
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z ; CvDatabaseUtility::InitializeArray

; 324  : 
; 325  : 
; 326  : 		std::string strResourceTypesKey = "Improvements - ResourceTypes";

	push	OFFSET ??_C@_0BN@OECFNINC@Improvements?5?9?5ResourceTypes?$AA@
	lea	ecx, DWORD PTR _strResourceTypesKey$217711[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 327  : 		Database::Results* pResourceTypes = kUtility.GetResults(strResourceTypesKey);

	lea	edx, DWORD PTR _strResourceTypesKey$217711[ebp]
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResourceTypes$217713[ebp], eax

; 328  : 		if(pResourceTypes == NULL)

	cmp	DWORD PTR _pResourceTypes$217713[ebp], 0
	jne	SHORT $LN18@CacheResul

; 329  : 		{
; 330  : 			pResourceTypes = kUtility.PrepareResults(strResourceTypesKey, "select Resources.ID, ResourceType, ResourceMakesValid, ResourceTrade, DiscoveryRand from Improvement_ResourceTypes inner join Resources on ResourceType = Resources.Type where ImprovementType = ?");

	push	OFFSET ??_C@_0MD@JCBBECJP@select?5Resources?4ID?0?5ResourceTyp@
	lea	eax, DWORD PTR _strResourceTypesKey$217711[ebp]
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResourceTypes$217713[ebp], eax
$LN18@CacheResul:

; 331  : 		}
; 332  : 
; 333  : 		std::string strYieldResultsKey = "Improvements - YieldResults";

	push	OFFSET ??_C@_0BM@NJMJOCGJ@Improvements?5?9?5YieldResults?$AA@
	lea	ecx, DWORD PTR _strYieldResultsKey$217716[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 334  : 		Database::Results* pYieldResults = kUtility.GetResults(strYieldResultsKey);

	lea	ecx, DWORD PTR _strYieldResultsKey$217716[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pYieldResults$217718[ebp], eax

; 335  : 		if(pYieldResults == NULL)

	cmp	DWORD PTR _pYieldResults$217718[ebp], 0
	jne	SHORT $LN17@CacheResul

; 336  : 		{
; 337  : 			pYieldResults = kUtility.PrepareResults(strYieldResultsKey, "select Yields.ID, Yield from Improvement_ResourceType_Yields inner join Yields on YieldType = Yields.Type where ImprovementType = ? and ResourceType = ?");

	push	OFFSET ??_C@_0JJ@KHHJOGON@select?5Yields?4ID?0?5Yield?5from?5Imp@
	lea	edx, DWORD PTR _strYieldResultsKey$217716[ebp]
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pYieldResults$217718[ebp], eax
$LN17@CacheResul:

; 338  : 		}
; 339  : 
; 340  : 		pResourceTypes->Bind(1, szImprovementType, lenImprovementType, false);

	push	0
	mov	eax, DWORD PTR _lenImprovementType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szImprovementType$[ebp]
	push	ecx
	push	1
	mov	ecx, DWORD PTR _pResourceTypes$217713[ebp]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBDH_N@Z
$LN16@CacheResul:

; 341  : 
; 342  : 		while(pResourceTypes->Step())

	mov	ecx, DWORD PTR _pResourceTypes$217713[ebp]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	movzx	edx, al
	test	edx, edx
	je	$LN15@CacheResul

; 343  : 		{
; 344  : 			const int idx = pResourceTypes->GetInt("ID");

	push	OFFSET ??_C@_02OLOABKKD@ID?$AA@
	mov	ecx, DWORD PTR _pResourceTypes$217713[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	DWORD PTR _idx$217724[ebp], eax

; 345  : 			CvImprovementResourceInfo& pResourceInfo = m_paImprovementResource[idx];

	mov	eax, DWORD PTR _idx$217724[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+488]
	mov	DWORD PTR _pResourceInfo$217726[ebp], eax

; 346  : 
; 347  : 			const char* szResourceType = pResourceTypes->GetText("ResourceType");

	push	OFFSET ??_C@_0N@EPHJOCBJ@ResourceType?$AA@
	mov	ecx, DWORD PTR _pResourceTypes$217713[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szResourceType$217727[ebp], eax

; 348  : 			pResourceInfo.m_bResourceMakesValid = pResourceTypes->GetBool("ResourceMakesValid");

	push	OFFSET ??_C@_0BD@EAAJGMOP@ResourceMakesValid?$AA@
	mov	ecx, DWORD PTR _pResourceTypes$217713[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _pResourceInfo$217726[ebp]
	mov	BYTE PTR [edx+4], al

; 349  : 			pResourceInfo.m_bResourceTrade = pResourceTypes->GetBool("ResourceTrade");

	push	OFFSET ??_C@_0O@OCBJCFBM@ResourceTrade?$AA@
	mov	ecx, DWORD PTR _pResourceTypes$217713[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _pResourceInfo$217726[ebp]
	mov	BYTE PTR [ecx+5], al

; 350  : 			pResourceInfo.m_iDiscoverRand = pResourceTypes->GetInt("DiscoveryRand");

	push	OFFSET ??_C@_0O@ILMABPGL@DiscoveryRand?$AA@
	mov	ecx, DWORD PTR _pResourceTypes$217713[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _pResourceInfo$217726[ebp]
	mov	DWORD PTR [edx], eax

; 351  : 			m_piResourceQuantityRequirements[idx] = pResourceTypes->GetInt("QuantityRequirement");

	push	OFFSET ??_C@_0BE@BHIANCDJ@QuantityRequirement?$AA@
	mov	ecx, DWORD PTR _pResourceTypes$217713[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+416]
	mov	ecx, DWORD PTR _idx$217724[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 352  : 
; 353  : 			//Populate Yields for structure
; 354  : 			kUtility.InitializeArray(pResourceInfo.m_piYieldChange, "Yields");

	push	OFFSET ??_C@_06JAMLCLDI@Yields?$AA@
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z	; CvDatabaseUtility::MaxRows
	mov	DWORD PTR _count$219373[ebp], eax
	cmp	DWORD PTR _count$219373[ebp], 0
	jne	SHORT $LN46@CacheResul
	mov	DWORD PTR _count$219373[ebp], 1
$LN46@CacheResul:
	push	0
	mov	edx, DWORD PTR _count$219373[ebp]
	push	edx
	mov	eax, DWORD PTR _pResourceInfo$217726[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z ; CvDatabaseUtility::InitializeArray

; 355  : 
; 356  : 			pYieldResults->Bind(1, szImprovementType, lenImprovementType, false);

	push	0
	mov	ecx, DWORD PTR _lenImprovementType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _szImprovementType$[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _pYieldResults$217718[ebp]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBDH_N@Z

; 357  : 			pYieldResults->Bind(2, szResourceType, -1, false);

	push	0
	push	-1
	mov	eax, DWORD PTR _szResourceType$217727[ebp]
	push	eax
	push	2
	mov	ecx, DWORD PTR _pYieldResults$217718[ebp]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBDH_N@Z
$LN14@CacheResul:

; 358  : 			while(pYieldResults->Step())

	mov	ecx, DWORD PTR _pYieldResults$217718[ebp]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN13@CacheResul

; 359  : 			{
; 360  : 				const int yieldIdx = pYieldResults->GetInt("ID");

	push	OFFSET ??_C@_02OLOABKKD@ID?$AA@
	mov	ecx, DWORD PTR _pYieldResults$217718[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	DWORD PTR _yieldIdx$217738[ebp], eax

; 361  : 				const int yield = pYieldResults->GetInt("Yield");

	push	OFFSET ??_C@_05LNDKIJIJ@Yield?$AA@
	mov	ecx, DWORD PTR _pYieldResults$217718[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	DWORD PTR _yield$217739[ebp], eax

; 362  : 				pResourceInfo.m_piYieldChange[yieldIdx] = yield;

	mov	edx, DWORD PTR _pResourceInfo$217726[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _yieldIdx$217738[ebp]
	mov	edx, DWORD PTR _yield$217739[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 363  : 			}

	jmp	SHORT $LN14@CacheResul
$LN13@CacheResul:

; 364  : 
; 365  : 			pYieldResults->Reset();

	mov	ecx, DWORD PTR _pYieldResults$217718[ebp]
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 366  : 		}

	jmp	$LN16@CacheResul
$LN15@CacheResul:

; 367  : 
; 368  : 		pResourceTypes->Reset();

	mov	ecx, DWORD PTR _pResourceTypes$217713[ebp]
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 369  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strYieldResultsKey$217716[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strResourceTypesKey$217711[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 370  : 
; 371  : 
; 372  : 	const int iNumYields = kUtility.MaxRows("Yields");

	push	OFFSET ??_C@_06JAMLCLDI@Yields?$AA@
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z	; CvDatabaseUtility::MaxRows
	mov	DWORD PTR _iNumYields$[ebp], eax

; 373  : 	const int iNumTechs = GC.getNumTechInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	mov	DWORD PTR _iNumTechs$[ebp], eax

; 374  : 	CvAssertMsg(iNumTechs > 0, "Num Tech Infos <= 0");
; 375  : 
; 376  : 
; 377  : 	//TechYieldChanges
; 378  : 	{
; 379  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 380  : 		kUtility.Initialize2DArray(m_ppiTechYieldChanges.first, iNumTechs, iNumYields);
; 381  : 		m_ppiTechYieldChanges.second = iNumTechs;
; 382  : #else
; 383  : 		kUtility.Initialize2DArray(m_ppiTechYieldChanges, iNumTechs, iNumYields);

	push	0
	mov	eax, DWORD PTR _iNumYields$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iNumTechs$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 472				; 000001d8H
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?Initialize2DArray@CvDatabaseUtility@@QAEXAAPAPAHIIH@Z ; CvDatabaseUtility::Initialize2DArray

; 384  : #endif
; 385  : 
; 386  : 		std::string strKey = "Improvements - TechYieldChanges";

	push	OFFSET ??_C@_0CA@MLIOACLH@Improvements?5?9?5TechYieldChanges?$AA@
	lea	ecx, DWORD PTR _strKey$217743[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 3

; 387  : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	eax, DWORD PTR _strKey$217743[ebp]
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$217745[ebp], eax

; 388  : 		if(pResults == NULL)

	cmp	DWORD PTR _pResults$217745[ebp], 0
	jne	SHORT $LN12@CacheResul

; 389  : 		{
; 390  : 			pResults = kUtility.PrepareResults(strKey, "select Yields.ID as YieldID, Technologies.ID as TechID, Yield from Improvement_TechYieldChanges inner join Yields on YieldType = Yields.Type inner join Technologies on TechType = Technologies.Type where ImprovementType = ?");

	push	OFFSET ??_C@_0NP@FDAJIDEK@select?5Yields?4ID?5as?5YieldID?0?5Tec@
	lea	ecx, DWORD PTR _strKey$217743[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$217745[ebp], eax
$LN12@CacheResul:

; 391  : 		}
; 392  : 
; 393  : 		pResults->Bind(1, szImprovementType, lenImprovementType, false);

	push	0
	mov	edx, DWORD PTR _lenImprovementType$[ebp]
	push	edx
	mov	eax, DWORD PTR _szImprovementType$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _pResults$217745[ebp]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBDH_N@Z
$LN11@CacheResul:

; 394  : 
; 395  : 		while(pResults->Step())

	mov	ecx, DWORD PTR _pResults$217745[ebp]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN10@CacheResul

; 396  : 		{
; 397  : 			const int yield_idx = pResults->GetInt(0);

	push	0
	mov	ecx, DWORD PTR _pResults$217745[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _yield_idx$217751[ebp], eax

; 398  : 			CvAssert(yield_idx > -1);
; 399  : 
; 400  : 			const int tech_idx = pResults->GetInt(1);

	push	1
	mov	ecx, DWORD PTR _pResults$217745[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _tech_idx$217752[ebp], eax

; 401  : 			CvAssert(tech_idx > -1);
; 402  : 
; 403  : 			const int yield = pResults->GetInt(2);

	push	2
	mov	ecx, DWORD PTR _pResults$217745[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _yield$217753[ebp], eax

; 404  : 
; 405  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 406  : 			m_ppiTechYieldChanges.first[tech_idx][yield_idx] = yield;
; 407  : #else
; 408  : 			m_ppiTechYieldChanges[tech_idx][yield_idx] = yield;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+472]
	mov	ecx, DWORD PTR _tech_idx$217752[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _yield_idx$217751[ebp]
	mov	ecx, DWORD PTR _yield$217753[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 409  : #endif
; 410  : 		}

	jmp	SHORT $LN11@CacheResul
$LN10@CacheResul:

; 411  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strKey$217743[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 412  : 
; 413  : 	//TechNoFreshWaterYieldChanges
; 414  : 	{
; 415  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 416  : 		kUtility.Initialize2DArray(m_ppiTechNoFreshWaterYieldChanges.first, iNumTechs, iNumYields);
; 417  : 		m_ppiTechNoFreshWaterYieldChanges.second = iNumTechs;
; 418  : #else
; 419  : 		kUtility.Initialize2DArray(m_ppiTechNoFreshWaterYieldChanges, iNumTechs, iNumYields);

	push	0
	mov	edx, DWORD PTR _iNumYields$[ebp]
	push	edx
	mov	eax, DWORD PTR _iNumTechs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 476				; 000001dcH
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?Initialize2DArray@CvDatabaseUtility@@QAEXAAPAPAHIIH@Z ; CvDatabaseUtility::Initialize2DArray

; 420  : #endif
; 421  : 
; 422  : 		std::string strKey = "Improvements - TechNoFreshWaterYieldChanges";

	push	OFFSET ??_C@_0CM@OAENAEJK@Improvements?5?9?5TechNoFreshWaterY@
	lea	ecx, DWORD PTR _strKey$217754[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 4

; 423  : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	edx, DWORD PTR _strKey$217754[ebp]
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$217756[ebp], eax

; 424  : 		if(pResults == NULL)

	cmp	DWORD PTR _pResults$217756[ebp], 0
	jne	SHORT $LN9@CacheResul

; 425  : 		{
; 426  : 			pResults = kUtility.PrepareResults(strKey, "select Yields.ID as YieldID, Technologies.ID as TechID, Yield from Improvement_TechNoFreshWaterYieldChanges inner join Yields on YieldType = Yields.Type inner join Technologies on TechType = Technologies.Type where ImprovementType = ?");

	push	OFFSET ??_C@_0OL@FJCOGNKM@select?5Yields?4ID?5as?5YieldID?0?5Tec@
	lea	eax, DWORD PTR _strKey$217754[ebp]
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$217756[ebp], eax
$LN9@CacheResul:

; 427  : 		}
; 428  : 
; 429  : 		pResults->Bind(1, szImprovementType, lenImprovementType, false);

	push	0
	mov	ecx, DWORD PTR _lenImprovementType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _szImprovementType$[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _pResults$217756[ebp]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBDH_N@Z
$LN8@CacheResul:

; 430  : 
; 431  : 		while(pResults->Step())

	mov	ecx, DWORD PTR _pResults$217756[ebp]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@CacheResul

; 432  : 		{
; 433  : 			const int yield_idx = pResults->GetInt(0);

	push	0
	mov	ecx, DWORD PTR _pResults$217756[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _yield_idx$217762[ebp], eax

; 434  : 			CvAssert(yield_idx > -1);
; 435  : 
; 436  : 			const int tech_idx = pResults->GetInt(1);

	push	1
	mov	ecx, DWORD PTR _pResults$217756[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _tech_idx$217763[ebp], eax

; 437  : 			CvAssert(tech_idx > -1);
; 438  : 
; 439  : 			const int yield = pResults->GetInt(2);

	push	2
	mov	ecx, DWORD PTR _pResults$217756[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _yield$217764[ebp], eax

; 440  : 
; 441  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 442  : 			m_ppiTechNoFreshWaterYieldChanges.first[tech_idx][yield_idx] = yield;
; 443  : #else
; 444  : 			m_ppiTechNoFreshWaterYieldChanges[tech_idx][yield_idx] = yield;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+476]
	mov	eax, DWORD PTR _tech_idx$217763[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _yield_idx$217762[ebp]
	mov	eax, DWORD PTR _yield$217764[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 445  : #endif
; 446  : 		}

	jmp	SHORT $LN8@CacheResul
$LN7@CacheResul:

; 447  : 
; 448  : 		pResults->Reset();

	mov	ecx, DWORD PTR _pResults$217756[ebp]
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 449  : 
; 450  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strKey$217754[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 451  : 
; 452  : 	//TechFreshWaterYieldChanges
; 453  : 	{
; 454  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 455  : 		kUtility.Initialize2DArray(m_ppiTechFreshWaterYieldChanges.first, iNumTechs, iNumYields);
; 456  : 		m_ppiTechFreshWaterYieldChanges.second = iNumTechs;
; 457  : #else
; 458  : 		kUtility.Initialize2DArray(m_ppiTechFreshWaterYieldChanges, iNumTechs, iNumYields);

	push	0
	mov	ecx, DWORD PTR _iNumYields$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iNumTechs$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 480				; 000001e0H
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?Initialize2DArray@CvDatabaseUtility@@QAEXAAPAPAHIIH@Z ; CvDatabaseUtility::Initialize2DArray

; 459  : #endif
; 460  : 
; 461  : 		std::string strKey = "Improvements - TechFreshWaterYieldChanges";

	push	OFFSET ??_C@_0CK@IKFKMKDD@Improvements?5?9?5TechFreshWaterYie@
	lea	ecx, DWORD PTR _strKey$217765[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 5

; 462  : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	ecx, DWORD PTR _strKey$217765[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$217767[ebp], eax

; 463  : 		if(pResults == NULL)

	cmp	DWORD PTR _pResults$217767[ebp], 0
	jne	SHORT $LN6@CacheResul

; 464  : 		{
; 465  : 			pResults = kUtility.PrepareResults(strKey, "select Yields.ID as YieldID, Technologies.ID as TechID, Yield from Improvement_TechFreshWaterYieldChanges inner join Yields on YieldType = Yields.Type inner join Technologies on TechType = Technologies.Type where ImprovementType = ?");

	push	OFFSET ??_C@_0OJ@MGCJPING@select?5Yields?4ID?5as?5YieldID?0?5Tec@
	lea	edx, DWORD PTR _strKey$217765[ebp]
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$217767[ebp], eax
$LN6@CacheResul:

; 466  : 		}
; 467  : 
; 468  : 		pResults->Bind(1, szImprovementType, lenImprovementType, false);

	push	0
	mov	eax, DWORD PTR _lenImprovementType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szImprovementType$[ebp]
	push	ecx
	push	1
	mov	ecx, DWORD PTR _pResults$217767[ebp]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBDH_N@Z
$LN5@CacheResul:

; 469  : 
; 470  : 		while(pResults->Step())

	mov	ecx, DWORD PTR _pResults$217767[ebp]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN4@CacheResul

; 471  : 		{
; 472  : 			const int yield_idx = pResults->GetInt(0);

	push	0
	mov	ecx, DWORD PTR _pResults$217767[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _yield_idx$217773[ebp], eax

; 473  : 			CvAssert(yield_idx > -1);
; 474  : 
; 475  : 			const int tech_idx = pResults->GetInt(1);

	push	1
	mov	ecx, DWORD PTR _pResults$217767[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _tech_idx$217774[ebp], eax

; 476  : 			CvAssert(tech_idx > -1);
; 477  : 
; 478  : 			const int yield = pResults->GetInt(2);

	push	2
	mov	ecx, DWORD PTR _pResults$217767[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _yield$217775[ebp], eax

; 479  : 
; 480  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 481  : 			m_ppiTechFreshWaterYieldChanges.first[tech_idx][yield_idx] = yield;
; 482  : #else
; 483  : 			m_ppiTechFreshWaterYieldChanges[tech_idx][yield_idx] = yield;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+480]
	mov	edx, DWORD PTR _tech_idx$217774[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _yield_idx$217773[ebp]
	mov	edx, DWORD PTR _yield$217775[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 484  : #endif
; 485  : 		}

	jmp	SHORT $LN5@CacheResul
$LN4@CacheResul:

; 486  : 
; 487  : 		pResults->Reset();

	mov	ecx, DWORD PTR _pResults$217767[ebp]
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 488  : 
; 489  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strKey$217765[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 490  : 
; 491  : 	//RouteYieldChanges
; 492  : 	{
; 493  : 		const int iNumRoutes = kUtility.MaxRows("Routes");

	push	OFFSET ??_C@_06LABKBOBK@Routes?$AA@
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z	; CvDatabaseUtility::MaxRows
	mov	DWORD PTR _iNumRoutes$217776[ebp], eax

; 494  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 495  : 		kUtility.Initialize2DArray(m_ppiRouteYieldChanges.first, iNumRoutes, iNumYields);
; 496  : 		m_ppiRouteYieldChanges.second = iNumRoutes;
; 497  : #else
; 498  : 		kUtility.Initialize2DArray(m_ppiRouteYieldChanges, iNumRoutes, iNumYields);

	push	0
	mov	eax, DWORD PTR _iNumYields$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iNumRoutes$217776[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 484				; 000001e4H
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?Initialize2DArray@CvDatabaseUtility@@QAEXAAPAPAHIIH@Z ; CvDatabaseUtility::Initialize2DArray

; 499  : #endif
; 500  : 
; 501  : 		std::string strKey = "Improvements - RouteYieldChanges";

	push	OFFSET ??_C@_0CB@KLJHJIAH@Improvements?5?9?5RouteYieldChanges@
	lea	ecx, DWORD PTR _strKey$217778[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 6

; 502  : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	eax, DWORD PTR _strKey$217778[ebp]
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$217780[ebp], eax

; 503  : 		if(pResults == NULL)

	cmp	DWORD PTR _pResults$217780[ebp], 0
	jne	SHORT $LN3@CacheResul

; 504  : 		{
; 505  : 			pResults = kUtility.PrepareResults(strKey, "select Yields.ID as YieldID, Routes.ID as RouteID, Yield from Improvement_RouteYieldChanges inner join Yields on YieldType = Yields.Type inner join Routes on RouteType = Routes.Type where ImprovementType = ?;");

	push	OFFSET ??_C@_0NB@EFFCGCCC@select?5Yields?4ID?5as?5YieldID?0?5Rou@
	lea	ecx, DWORD PTR _strKey$217778[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$217780[ebp], eax
$LN3@CacheResul:

; 506  : 		}
; 507  : 
; 508  : 		pResults->Bind(1, szImprovementType, lenImprovementType, false);

	push	0
	mov	edx, DWORD PTR _lenImprovementType$[ebp]
	push	edx
	mov	eax, DWORD PTR _szImprovementType$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _pResults$217780[ebp]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBDH_N@Z
$LN2@CacheResul:

; 509  : 
; 510  : 		while(pResults->Step())

	mov	ecx, DWORD PTR _pResults$217780[ebp]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@CacheResul

; 511  : 		{
; 512  : 			const int yield_idx = pResults->GetInt(0);

	push	0
	mov	ecx, DWORD PTR _pResults$217780[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _yield_idx$217786[ebp], eax

; 513  : 			CvAssert(yield_idx > -1);
; 514  : 
; 515  : 			const int route_idx = pResults->GetInt(1);

	push	1
	mov	ecx, DWORD PTR _pResults$217780[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _route_idx$217787[ebp], eax

; 516  : 			CvAssert(route_idx > -1);
; 517  : 
; 518  : 			const int yield = pResults->GetInt(2);

	push	2
	mov	ecx, DWORD PTR _pResults$217780[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _yield$217788[ebp], eax

; 519  : 
; 520  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 521  : 			m_ppiRouteYieldChanges.first[route_idx][yield_idx] = yield;
; 522  : #else
; 523  : 			m_ppiRouteYieldChanges[route_idx][yield_idx] = yield;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+484]
	mov	ecx, DWORD PTR _route_idx$217787[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _yield_idx$217786[ebp]
	mov	ecx, DWORD PTR _yield$217788[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 524  : #endif
; 525  : 		}

	jmp	SHORT $LN2@CacheResul
$LN1@CacheResul:

; 526  : 
; 527  : 		pResults->Reset();

	mov	ecx, DWORD PTR _pResults$217780[ebp]
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 528  : 
; 529  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strKey$217778[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 530  : 
; 531  : 	return true;

	mov	al, 1
$LN22@CacheResul:

; 532  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0:
	mov	eax, DWORD PTR $T219346[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__unwindfunclet$?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$1:
	lea	ecx, DWORD PTR _strResourceTypesKey$217711[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$2:
	lea	ecx, DWORD PTR _strYieldResultsKey$217716[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$3:
	lea	ecx, DWORD PTR _strKey$217743[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$4:
	lea	ecx, DWORD PTR _strKey$217754[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$5:
	lea	ecx, DWORD PTR _strKey$217765[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$6:
	lea	ecx, DWORD PTR _strKey$217778[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-376]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvImprovementEntry::CacheResults
; Function compile flags: /Odtp
;	COMDAT ?Remark@@YA_NHPBDZZ
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?Remark@@YA_NHPBDZZ PROC				; Remark, COMDAT

; 21   : REMARK_GROUP("CvImprovementClasses");

	push	ebp
	mov	ebp, esp
	xor	al, al
	pop	ebp
	ret	0
?Remark@@YA_NHPBDZZ ENDP				; Remark
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
; Function compile flags: /Odtp
;	COMDAT ??_ECvImprovementResourceInfo@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_ECvImprovementResourceInfo@@QAEPAXI@Z PROC		; CvImprovementResourceInfo::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector
	push	OFFSET ??1CvImprovementResourceInfo@@QAE@XZ ; CvImprovementResourceInfo::~CvImprovementResourceInfo
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector
$LN3@vector:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvImprovementResourceInfo@@QAE@XZ	; CvImprovementResourceInfo::~CvImprovementResourceInfo
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector:
	mov	esp, ebp
	pop	ebp
	ret	4
??_ECvImprovementResourceInfo@@QAEPAXI@Z ENDP		; CvImprovementResourceInfo::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?GetGoldMaintenance@CvImprovementEntry@@QBEHXZ	; CvImprovementEntry::GetGoldMaintenance
; Function compile flags: /Odtp
;	COMDAT ?GetGoldMaintenance@CvImprovementEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGoldMaintenance@CvImprovementEntry@@QBEHXZ PROC	; CvImprovementEntry::GetGoldMaintenance, COMDAT
; _this$ = ecx

; 536  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 537  : 	return m_iGoldMaintenance;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+260]

; 538  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGoldMaintenance@CvImprovementEntry@@QBEHXZ ENDP	; CvImprovementEntry::GetGoldMaintenance
_TEXT	ENDS
PUBLIC	?GetCultureBombRadius@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetCultureBombRadius
; Function compile flags: /Odtp
;	COMDAT ?GetCultureBombRadius@CvImprovementEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCultureBombRadius@CvImprovementEntry@@QBEHXZ PROC	; CvImprovementEntry::GetCultureBombRadius, COMDAT
; _this$ = ecx

; 542  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 543  : 	return m_iCultureBombRadius;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+264]

; 544  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCultureBombRadius@CvImprovementEntry@@QBEHXZ ENDP	; CvImprovementEntry::GetCultureBombRadius
_TEXT	ENDS
PUBLIC	?GetCultureBombRadiusNeutral@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetCultureBombRadiusNeutral
; Function compile flags: /Odtp
;	COMDAT ?GetCultureBombRadiusNeutral@CvImprovementEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCultureBombRadiusNeutral@CvImprovementEntry@@QBEHXZ PROC ; CvImprovementEntry::GetCultureBombRadiusNeutral, COMDAT
; _this$ = ecx

; 547  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 548  : 	return m_iCultureBombRadiusNeutral;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+268]

; 549  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCultureBombRadiusNeutral@CvImprovementEntry@@QBEHXZ ENDP ; CvImprovementEntry::GetCultureBombRadiusNeutral
_TEXT	ENDS
PUBLIC	?GetRequiresXAdjacentLand@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetRequiresXAdjacentLand
; Function compile flags: /Odtp
;	COMDAT ?GetRequiresXAdjacentLand@CvImprovementEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRequiresXAdjacentLand@CvImprovementEntry@@QBEHXZ PROC ; CvImprovementEntry::GetRequiresXAdjacentLand, COMDAT
; _this$ = ecx

; 553  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 554  : 	return m_iRequiresXAdjacentLand;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+340]

; 555  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetRequiresXAdjacentLand@CvImprovementEntry@@QBEHXZ ENDP ; CvImprovementEntry::GetRequiresXAdjacentLand
_TEXT	ENDS
PUBLIC	?GetCultureAdjacentSameType@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetCultureAdjacentSameType
; Function compile flags: /Odtp
;	COMDAT ?GetCultureAdjacentSameType@CvImprovementEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCultureAdjacentSameType@CvImprovementEntry@@QBEHXZ PROC ; CvImprovementEntry::GetCultureAdjacentSameType, COMDAT
; _this$ = ecx

; 559  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 560  : 	return m_iCultureAdjacentSameType;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+272]

; 561  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCultureAdjacentSameType@CvImprovementEntry@@QBEHXZ ENDP ; CvImprovementEntry::GetCultureAdjacentSameType
_TEXT	ENDS
PUBLIC	?GetTilesPerGoody@CvImprovementEntry@@QBEHXZ	; CvImprovementEntry::GetTilesPerGoody
; Function compile flags: /Odtp
;	COMDAT ?GetTilesPerGoody@CvImprovementEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTilesPerGoody@CvImprovementEntry@@QBEHXZ PROC	; CvImprovementEntry::GetTilesPerGoody, COMDAT
; _this$ = ecx

; 565  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 	return m_iTilesPerGoody;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+276]

; 567  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTilesPerGoody@CvImprovementEntry@@QBEHXZ ENDP	; CvImprovementEntry::GetTilesPerGoody
_TEXT	ENDS
PUBLIC	?GetGoodyUniqueRange@CvImprovementEntry@@QBEHXZ	; CvImprovementEntry::GetGoodyUniqueRange
; Function compile flags: /Odtp
;	COMDAT ?GetGoodyUniqueRange@CvImprovementEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGoodyUniqueRange@CvImprovementEntry@@QBEHXZ PROC	; CvImprovementEntry::GetGoodyUniqueRange, COMDAT
; _this$ = ecx

; 571  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 572  : 	return m_iGoodyUniqueRange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+280]

; 573  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGoodyUniqueRange@CvImprovementEntry@@QBEHXZ ENDP	; CvImprovementEntry::GetGoodyUniqueRange
_TEXT	ENDS
PUBLIC	?GetFeatureGrowthProbability@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetFeatureGrowthProbability
; Function compile flags: /Odtp
;	COMDAT ?GetFeatureGrowthProbability@CvImprovementEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFeatureGrowthProbability@CvImprovementEntry@@QBEHXZ PROC ; CvImprovementEntry::GetFeatureGrowthProbability, COMDAT
; _this$ = ecx

; 577  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 578  : 	return m_iFeatureGrowthProbability;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+284]

; 579  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFeatureGrowthProbability@CvImprovementEntry@@QBEHXZ ENDP ; CvImprovementEntry::GetFeatureGrowthProbability
_TEXT	ENDS
PUBLIC	?GetUpgradeTime@CvImprovementEntry@@QBEHXZ	; CvImprovementEntry::GetUpgradeTime
; Function compile flags: /Odtp
;	COMDAT ?GetUpgradeTime@CvImprovementEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUpgradeTime@CvImprovementEntry@@QBEHXZ PROC		; CvImprovementEntry::GetUpgradeTime, COMDAT
; _this$ = ecx

; 583  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 584  : 	return m_iUpgradeTime;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+288]

; 585  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetUpgradeTime@CvImprovementEntry@@QBEHXZ ENDP		; CvImprovementEntry::GetUpgradeTime
_TEXT	ENDS
PUBLIC	?GetRiverSideUpgradeMod@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetRiverSideUpgradeMod
; Function compile flags: /Odtp
;	COMDAT ?GetRiverSideUpgradeMod@CvImprovementEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRiverSideUpgradeMod@CvImprovementEntry@@QBEHXZ PROC	; CvImprovementEntry::GetRiverSideUpgradeMod, COMDAT
; _this$ = ecx

; 589  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 590  : 	return m_iRiverSideUpgradeMod;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+292]

; 591  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetRiverSideUpgradeMod@CvImprovementEntry@@QBEHXZ ENDP	; CvImprovementEntry::GetRiverSideUpgradeMod
_TEXT	ENDS
PUBLIC	?GetCoastalLandUpgradeMod@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetCoastalLandUpgradeMod
; Function compile flags: /Odtp
;	COMDAT ?GetCoastalLandUpgradeMod@CvImprovementEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCoastalLandUpgradeMod@CvImprovementEntry@@QBEHXZ PROC ; CvImprovementEntry::GetCoastalLandUpgradeMod, COMDAT
; _this$ = ecx

; 595  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 596  : 	return m_iCoastalLandUpgradeMod;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+296]

; 597  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCoastalLandUpgradeMod@CvImprovementEntry@@QBEHXZ ENDP ; CvImprovementEntry::GetCoastalLandUpgradeMod
_TEXT	ENDS
PUBLIC	?GetHillsUpgradeMod@CvImprovementEntry@@QBEHXZ	; CvImprovementEntry::GetHillsUpgradeMod
; Function compile flags: /Odtp
;	COMDAT ?GetHillsUpgradeMod@CvImprovementEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetHillsUpgradeMod@CvImprovementEntry@@QBEHXZ PROC	; CvImprovementEntry::GetHillsUpgradeMod, COMDAT
; _this$ = ecx

; 601  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 602  : 	return m_iHillsUpgradeMod;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+300]

; 603  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetHillsUpgradeMod@CvImprovementEntry@@QBEHXZ ENDP	; CvImprovementEntry::GetHillsUpgradeMod
_TEXT	ENDS
PUBLIC	?GetFreshWaterUpgradeMod@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetFreshWaterUpgradeMod
; Function compile flags: /Odtp
;	COMDAT ?GetFreshWaterUpgradeMod@CvImprovementEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFreshWaterUpgradeMod@CvImprovementEntry@@QBEHXZ PROC ; CvImprovementEntry::GetFreshWaterUpgradeMod, COMDAT
; _this$ = ecx

; 607  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 608  : 	return m_iFreshWaterUpgradeMod;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+304]

; 609  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFreshWaterUpgradeMod@CvImprovementEntry@@QBEHXZ ENDP ; CvImprovementEntry::GetFreshWaterUpgradeMod
_TEXT	ENDS
PUBLIC	?GetDefenseModifier@CvImprovementEntry@@QBEHXZ	; CvImprovementEntry::GetDefenseModifier
; Function compile flags: /Odtp
;	COMDAT ?GetDefenseModifier@CvImprovementEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDefenseModifier@CvImprovementEntry@@QBEHXZ PROC	; CvImprovementEntry::GetDefenseModifier, COMDAT
; _this$ = ecx

; 613  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 614  : 	return m_iDefenseModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+308]

; 615  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetDefenseModifier@CvImprovementEntry@@QBEHXZ ENDP	; CvImprovementEntry::GetDefenseModifier
_TEXT	ENDS
PUBLIC	?GetDefenseModifierGlobal@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetDefenseModifierGlobal
; Function compile flags: /Odtp
;	COMDAT ?GetDefenseModifierGlobal@CvImprovementEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDefenseModifierGlobal@CvImprovementEntry@@QBEHXZ PROC ; CvImprovementEntry::GetDefenseModifierGlobal, COMDAT
; _this$ = ecx

; 619  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 620  : 	return m_iDefenseModifierGlobal;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+312]

; 621  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetDefenseModifierGlobal@CvImprovementEntry@@QBEHXZ ENDP ; CvImprovementEntry::GetDefenseModifierGlobal
_TEXT	ENDS
PUBLIC	?GetNearbyEnemyDamage@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetNearbyEnemyDamage
; Function compile flags: /Odtp
;	COMDAT ?GetNearbyEnemyDamage@CvImprovementEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNearbyEnemyDamage@CvImprovementEntry@@QBEHXZ PROC	; CvImprovementEntry::GetNearbyEnemyDamage, COMDAT
; _this$ = ecx

; 625  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 626  : 	return m_iNearbyEnemyDamage;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+316]

; 627  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNearbyEnemyDamage@CvImprovementEntry@@QBEHXZ ENDP	; CvImprovementEntry::GetNearbyEnemyDamage
_TEXT	ENDS
PUBLIC	?GetPillageGold@CvImprovementEntry@@QBEHXZ	; CvImprovementEntry::GetPillageGold
; Function compile flags: /Odtp
;	COMDAT ?GetPillageGold@CvImprovementEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPillageGold@CvImprovementEntry@@QBEHXZ PROC		; CvImprovementEntry::GetPillageGold, COMDAT
; _this$ = ecx

; 631  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 632  : 	return m_iPillageGold;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+320]

; 633  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPillageGold@CvImprovementEntry@@QBEHXZ ENDP		; CvImprovementEntry::GetPillageGold
_TEXT	ENDS
PUBLIC	?GetResourceExtractionMod@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetResourceExtractionMod
; Function compile flags: /Odtp
;	COMDAT ?GetResourceExtractionMod@CvImprovementEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetResourceExtractionMod@CvImprovementEntry@@QBEHXZ PROC ; CvImprovementEntry::GetResourceExtractionMod, COMDAT
; _this$ = ecx

; 637  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 638  : 	return m_iResourceExtractionMod;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+324]

; 639  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetResourceExtractionMod@CvImprovementEntry@@QBEHXZ ENDP ; CvImprovementEntry::GetResourceExtractionMod
_TEXT	ENDS
PUBLIC	?GetLuxuryCopiesSiphonedFromMinor@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetLuxuryCopiesSiphonedFromMinor
; Function compile flags: /Odtp
;	COMDAT ?GetLuxuryCopiesSiphonedFromMinor@CvImprovementEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLuxuryCopiesSiphonedFromMinor@CvImprovementEntry@@QBEHXZ PROC ; CvImprovementEntry::GetLuxuryCopiesSiphonedFromMinor, COMDAT
; _this$ = ecx

; 643  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 644  : 	return m_iLuxuryCopiesSiphonedFromMinor;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+328]

; 645  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetLuxuryCopiesSiphonedFromMinor@CvImprovementEntry@@QBEHXZ ENDP ; CvImprovementEntry::GetLuxuryCopiesSiphonedFromMinor
_TEXT	ENDS
PUBLIC	?GetImprovementPillage@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetImprovementPillage
; Function compile flags: /Odtp
;	COMDAT ?GetImprovementPillage@CvImprovementEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetImprovementPillage@CvImprovementEntry@@QBEHXZ PROC	; CvImprovementEntry::GetImprovementPillage, COMDAT
; _this$ = ecx

; 649  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 650  : 	return m_iImprovementPillage;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+332]

; 651  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetImprovementPillage@CvImprovementEntry@@QBEHXZ ENDP	; CvImprovementEntry::GetImprovementPillage
_TEXT	ENDS
PUBLIC	?SetImprovementPillage@CvImprovementEntry@@QAEXH@Z ; CvImprovementEntry::SetImprovementPillage
; Function compile flags: /Odtp
;	COMDAT ?SetImprovementPillage@CvImprovementEntry@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?SetImprovementPillage@CvImprovementEntry@@QAEXH@Z PROC	; CvImprovementEntry::SetImprovementPillage, COMDAT
; _this$ = ecx

; 655  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 	m_iImprovementPillage = i;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax+332], ecx

; 657  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetImprovementPillage@CvImprovementEntry@@QAEXH@Z ENDP	; CvImprovementEntry::SetImprovementPillage
_TEXT	ENDS
PUBLIC	?GetImprovementUpgrade@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetImprovementUpgrade
; Function compile flags: /Odtp
;	COMDAT ?GetImprovementUpgrade@CvImprovementEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetImprovementUpgrade@CvImprovementEntry@@QBEHXZ PROC	; CvImprovementEntry::GetImprovementUpgrade, COMDAT
; _this$ = ecx

; 661  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 662  : 	return m_iImprovementUpgrade;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+336]

; 663  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetImprovementUpgrade@CvImprovementEntry@@QBEHXZ ENDP	; CvImprovementEntry::GetImprovementUpgrade
_TEXT	ENDS
PUBLIC	?SetImprovementUpgrade@CvImprovementEntry@@QAEXH@Z ; CvImprovementEntry::SetImprovementUpgrade
; Function compile flags: /Odtp
;	COMDAT ?SetImprovementUpgrade@CvImprovementEntry@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?SetImprovementUpgrade@CvImprovementEntry@@QAEXH@Z PROC	; CvImprovementEntry::SetImprovementUpgrade, COMDAT
; _this$ = ecx

; 667  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 668  : 	m_iImprovementUpgrade = i;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax+336], ecx

; 669  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetImprovementUpgrade@CvImprovementEntry@@QAEXH@Z ENDP	; CvImprovementEntry::SetImprovementUpgrade
_TEXT	ENDS
PUBLIC	?IsHillsMakesValid@CvImprovementEntry@@QBE_NXZ	; CvImprovementEntry::IsHillsMakesValid
; Function compile flags: /Odtp
;	COMDAT ?IsHillsMakesValid@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsHillsMakesValid@CvImprovementEntry@@QBE_NXZ PROC	; CvImprovementEntry::IsHillsMakesValid, COMDAT
; _this$ = ecx

; 673  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 674  : 	return m_bHillsMakesValid;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+344]

; 675  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsHillsMakesValid@CvImprovementEntry@@QBE_NXZ ENDP	; CvImprovementEntry::IsHillsMakesValid
_TEXT	ENDS
PUBLIC	?IsWaterAdjacencyMakesValid@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsWaterAdjacencyMakesValid
; Function compile flags: /Odtp
;	COMDAT ?IsWaterAdjacencyMakesValid@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsWaterAdjacencyMakesValid@CvImprovementEntry@@QBE_NXZ PROC ; CvImprovementEntry::IsWaterAdjacencyMakesValid, COMDAT
; _this$ = ecx

; 678  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 679  : 	return m_bWaterAdjacencyMakesValid;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+345]

; 680  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsWaterAdjacencyMakesValid@CvImprovementEntry@@QBE_NXZ ENDP ; CvImprovementEntry::IsWaterAdjacencyMakesValid
_TEXT	ENDS
PUBLIC	?IsFreshWaterMakesValid@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsFreshWaterMakesValid
; Function compile flags: /Odtp
;	COMDAT ?IsFreshWaterMakesValid@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsFreshWaterMakesValid@CvImprovementEntry@@QBE_NXZ PROC ; CvImprovementEntry::IsFreshWaterMakesValid, COMDAT
; _this$ = ecx

; 684  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 685  : 	return m_bFreshWaterMakesValid;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+346]

; 686  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsFreshWaterMakesValid@CvImprovementEntry@@QBE_NXZ ENDP ; CvImprovementEntry::IsFreshWaterMakesValid
_TEXT	ENDS
PUBLIC	?IsRiverSideMakesValid@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsRiverSideMakesValid
; Function compile flags: /Odtp
;	COMDAT ?IsRiverSideMakesValid@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsRiverSideMakesValid@CvImprovementEntry@@QBE_NXZ PROC	; CvImprovementEntry::IsRiverSideMakesValid, COMDAT
; _this$ = ecx

; 690  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 691  : 	return m_bRiverSideMakesValid;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+347]

; 692  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsRiverSideMakesValid@CvImprovementEntry@@QBE_NXZ ENDP	; CvImprovementEntry::IsRiverSideMakesValid
_TEXT	ENDS
PUBLIC	?IsNoFreshWater@CvImprovementEntry@@QBE_NXZ	; CvImprovementEntry::IsNoFreshWater
; Function compile flags: /Odtp
;	COMDAT ?IsNoFreshWater@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsNoFreshWater@CvImprovementEntry@@QBE_NXZ PROC	; CvImprovementEntry::IsNoFreshWater, COMDAT
; _this$ = ecx

; 696  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 697  : 	return m_bNoFreshWater;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+348]

; 698  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsNoFreshWater@CvImprovementEntry@@QBE_NXZ ENDP	; CvImprovementEntry::IsNoFreshWater
_TEXT	ENDS
PUBLIC	?IsRequiresFlatlands@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsRequiresFlatlands
; Function compile flags: /Odtp
;	COMDAT ?IsRequiresFlatlands@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsRequiresFlatlands@CvImprovementEntry@@QBE_NXZ PROC	; CvImprovementEntry::IsRequiresFlatlands, COMDAT
; _this$ = ecx

; 702  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 703  : 	return m_bRequiresFlatlands;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+349]

; 704  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsRequiresFlatlands@CvImprovementEntry@@QBE_NXZ ENDP	; CvImprovementEntry::IsRequiresFlatlands
_TEXT	ENDS
PUBLIC	?IsRequiresFlatlandsOrFreshWater@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsRequiresFlatlandsOrFreshWater
; Function compile flags: /Odtp
;	COMDAT ?IsRequiresFlatlandsOrFreshWater@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsRequiresFlatlandsOrFreshWater@CvImprovementEntry@@QBE_NXZ PROC ; CvImprovementEntry::IsRequiresFlatlandsOrFreshWater, COMDAT
; _this$ = ecx

; 708  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 709  : 	return m_bRequiresFlatlandsOrFreshWater;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+350]

; 710  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsRequiresFlatlandsOrFreshWater@CvImprovementEntry@@QBE_NXZ ENDP ; CvImprovementEntry::IsRequiresFlatlandsOrFreshWater
_TEXT	ENDS
PUBLIC	?IsRequiresFeature@CvImprovementEntry@@QBE_NXZ	; CvImprovementEntry::IsRequiresFeature
; Function compile flags: /Odtp
;	COMDAT ?IsRequiresFeature@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsRequiresFeature@CvImprovementEntry@@QBE_NXZ PROC	; CvImprovementEntry::IsRequiresFeature, COMDAT
; _this$ = ecx

; 714  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 715  : 	return m_bRequiresFeature;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+351]

; 716  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsRequiresFeature@CvImprovementEntry@@QBE_NXZ ENDP	; CvImprovementEntry::IsRequiresFeature
_TEXT	ENDS
PUBLIC	?IsRequiresImprovement@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsRequiresImprovement
; Function compile flags: /Odtp
;	COMDAT ?IsRequiresImprovement@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsRequiresImprovement@CvImprovementEntry@@QBE_NXZ PROC	; CvImprovementEntry::IsRequiresImprovement, COMDAT
; _this$ = ecx

; 720  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 721  : 	return m_bRequiresImprovement;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+352]

; 722  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsRequiresImprovement@CvImprovementEntry@@QBE_NXZ ENDP	; CvImprovementEntry::IsRequiresImprovement
_TEXT	ENDS
PUBLIC	?IsRemovesResource@CvImprovementEntry@@QBE_NXZ	; CvImprovementEntry::IsRemovesResource
; Function compile flags: /Odtp
;	COMDAT ?IsRemovesResource@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsRemovesResource@CvImprovementEntry@@QBE_NXZ PROC	; CvImprovementEntry::IsRemovesResource, COMDAT
; _this$ = ecx

; 726  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 727  : 	return m_bRemovesResource;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+353]

; 728  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsRemovesResource@CvImprovementEntry@@QBE_NXZ ENDP	; CvImprovementEntry::IsRemovesResource
_TEXT	ENDS
PUBLIC	?IsPromptWhenComplete@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsPromptWhenComplete
; Function compile flags: /Odtp
;	COMDAT ?IsPromptWhenComplete@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsPromptWhenComplete@CvImprovementEntry@@QBE_NXZ PROC	; CvImprovementEntry::IsPromptWhenComplete, COMDAT
; _this$ = ecx

; 732  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 733  : 	return m_bPromptWhenComplete;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+354]

; 734  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsPromptWhenComplete@CvImprovementEntry@@QBE_NXZ ENDP	; CvImprovementEntry::IsPromptWhenComplete
_TEXT	ENDS
PUBLIC	?IsWater@CvImprovementEntry@@QBE_NXZ		; CvImprovementEntry::IsWater
; Function compile flags: /Odtp
;	COMDAT ?IsWater@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsWater@CvImprovementEntry@@QBE_NXZ PROC		; CvImprovementEntry::IsWater, COMDAT
; _this$ = ecx

; 738  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 739  : 	return m_bWater;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+355]

; 740  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsWater@CvImprovementEntry@@QBE_NXZ ENDP		; CvImprovementEntry::IsWater
_TEXT	ENDS
PUBLIC	?IsCoastal@CvImprovementEntry@@QBE_NXZ		; CvImprovementEntry::IsCoastal
; Function compile flags: /Odtp
;	COMDAT ?IsCoastal@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsCoastal@CvImprovementEntry@@QBE_NXZ PROC		; CvImprovementEntry::IsCoastal, COMDAT
; _this$ = ecx

; 744  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 	return m_bCoastal;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+356]

; 746  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsCoastal@CvImprovementEntry@@QBE_NXZ ENDP		; CvImprovementEntry::IsCoastal
_TEXT	ENDS
PUBLIC	?IsDestroyedWhenPillaged@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsDestroyedWhenPillaged
; Function compile flags: /Odtp
;	COMDAT ?IsDestroyedWhenPillaged@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsDestroyedWhenPillaged@CvImprovementEntry@@QBE_NXZ PROC ; CvImprovementEntry::IsDestroyedWhenPillaged, COMDAT
; _this$ = ecx

; 751  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 752  : 	return m_bDestroyedWhenPillaged;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+357]

; 753  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsDestroyedWhenPillaged@CvImprovementEntry@@QBE_NXZ ENDP ; CvImprovementEntry::IsDestroyedWhenPillaged
_TEXT	ENDS
PUBLIC	?IsDisplacePillager@CvImprovementEntry@@QBE_NXZ	; CvImprovementEntry::IsDisplacePillager
; Function compile flags: /Odtp
;	COMDAT ?IsDisplacePillager@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsDisplacePillager@CvImprovementEntry@@QBE_NXZ PROC	; CvImprovementEntry::IsDisplacePillager, COMDAT
; _this$ = ecx

; 757  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 758  : 	return m_bDisplacePillager;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+358]

; 759  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsDisplacePillager@CvImprovementEntry@@QBE_NXZ ENDP	; CvImprovementEntry::IsDisplacePillager
_TEXT	ENDS
PUBLIC	?IsBuildableOnResources@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsBuildableOnResources
; Function compile flags: /Odtp
;	COMDAT ?IsBuildableOnResources@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsBuildableOnResources@CvImprovementEntry@@QBE_NXZ PROC ; CvImprovementEntry::IsBuildableOnResources, COMDAT
; _this$ = ecx

; 763  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 764  : 	return m_bBuildableOnResources;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+359]

; 765  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsBuildableOnResources@CvImprovementEntry@@QBE_NXZ ENDP ; CvImprovementEntry::IsBuildableOnResources
_TEXT	ENDS
PUBLIC	?IsBarbarianCamp@CvImprovementEntry@@QBE_NXZ	; CvImprovementEntry::IsBarbarianCamp
; Function compile flags: /Odtp
;	COMDAT ?IsBarbarianCamp@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsBarbarianCamp@CvImprovementEntry@@QBE_NXZ PROC	; CvImprovementEntry::IsBarbarianCamp, COMDAT
; _this$ = ecx

; 769  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 770  : 	return m_bBarbarianCamp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+360]

; 771  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsBarbarianCamp@CvImprovementEntry@@QBE_NXZ ENDP	; CvImprovementEntry::IsBarbarianCamp
_TEXT	ENDS
PUBLIC	?IsGoody@CvImprovementEntry@@QBE_NXZ		; CvImprovementEntry::IsGoody
; Function compile flags: /Odtp
;	COMDAT ?IsGoody@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsGoody@CvImprovementEntry@@QBE_NXZ PROC		; CvImprovementEntry::IsGoody, COMDAT
; _this$ = ecx

; 775  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 776  : 	return m_bGoody;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+361]

; 777  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsGoody@CvImprovementEntry@@QBE_NXZ ENDP		; CvImprovementEntry::IsGoody
_TEXT	ENDS
PUBLIC	?IsPermanent@CvImprovementEntry@@QBE_NXZ	; CvImprovementEntry::IsPermanent
; Function compile flags: /Odtp
;	COMDAT ?IsPermanent@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsPermanent@CvImprovementEntry@@QBE_NXZ PROC		; CvImprovementEntry::IsPermanent, COMDAT
; _this$ = ecx

; 781  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 782  : 	return m_bPermanent;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+362]

; 783  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsPermanent@CvImprovementEntry@@QBE_NXZ ENDP		; CvImprovementEntry::IsPermanent
_TEXT	ENDS
PUBLIC	?IsOutsideBorders@CvImprovementEntry@@QBE_NXZ	; CvImprovementEntry::IsOutsideBorders
; Function compile flags: /Odtp
;	COMDAT ?IsOutsideBorders@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsOutsideBorders@CvImprovementEntry@@QBE_NXZ PROC	; CvImprovementEntry::IsOutsideBorders, COMDAT
; _this$ = ecx

; 787  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 788  : 	return m_bOutsideBorders;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+363]

; 789  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsOutsideBorders@CvImprovementEntry@@QBE_NXZ ENDP	; CvImprovementEntry::IsOutsideBorders
_TEXT	ENDS
PUBLIC	?IsIgnoreOwnership@CvImprovementEntry@@QBE_NXZ	; CvImprovementEntry::IsIgnoreOwnership
; Function compile flags: /Odtp
;	COMDAT ?IsIgnoreOwnership@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsIgnoreOwnership@CvImprovementEntry@@QBE_NXZ PROC	; CvImprovementEntry::IsIgnoreOwnership, COMDAT
; _this$ = ecx

; 793  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 794  : 	return m_bIgnoreOwnership;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+365]

; 795  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsIgnoreOwnership@CvImprovementEntry@@QBE_NXZ ENDP	; CvImprovementEntry::IsIgnoreOwnership
_TEXT	ENDS
PUBLIC	?IsOnlyCityStateTerritory@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsOnlyCityStateTerritory
; Function compile flags: /Odtp
;	COMDAT ?IsOnlyCityStateTerritory@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsOnlyCityStateTerritory@CvImprovementEntry@@QBE_NXZ PROC ; CvImprovementEntry::IsOnlyCityStateTerritory, COMDAT
; _this$ = ecx

; 799  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 800  : 	return m_bOnlyCityStateTerritory;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+366]

; 801  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsOnlyCityStateTerritory@CvImprovementEntry@@QBE_NXZ ENDP ; CvImprovementEntry::IsOnlyCityStateTerritory
_TEXT	ENDS
PUBLIC	?IsNoTwoAdjacent@CvImprovementEntry@@QBE_NXZ	; CvImprovementEntry::IsNoTwoAdjacent
; Function compile flags: /Odtp
;	COMDAT ?IsNoTwoAdjacent@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsNoTwoAdjacent@CvImprovementEntry@@QBE_NXZ PROC	; CvImprovementEntry::IsNoTwoAdjacent, COMDAT
; _this$ = ecx

; 805  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 806  : 	return m_bNoTwoAdjacent;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+367]

; 807  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsNoTwoAdjacent@CvImprovementEntry@@QBE_NXZ ENDP	; CvImprovementEntry::IsNoTwoAdjacent
_TEXT	ENDS
PUBLIC	?IsAdjacentLuxury@CvImprovementEntry@@QBE_NXZ	; CvImprovementEntry::IsAdjacentLuxury
; Function compile flags: /Odtp
;	COMDAT ?IsAdjacentLuxury@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAdjacentLuxury@CvImprovementEntry@@QBE_NXZ PROC	; CvImprovementEntry::IsAdjacentLuxury, COMDAT
; _this$ = ecx

; 811  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 812  : 	return m_bAdjacentLuxury;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+368]

; 813  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsAdjacentLuxury@CvImprovementEntry@@QBE_NXZ ENDP	; CvImprovementEntry::IsAdjacentLuxury
_TEXT	ENDS
PUBLIC	?IsAllowsWalkWater@CvImprovementEntry@@QBE_NXZ	; CvImprovementEntry::IsAllowsWalkWater
; Function compile flags: /Odtp
;	COMDAT ?IsAllowsWalkWater@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAllowsWalkWater@CvImprovementEntry@@QBE_NXZ PROC	; CvImprovementEntry::IsAllowsWalkWater, COMDAT
; _this$ = ecx

; 817  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 818  : 	return m_bAllowsWalkWater;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+369]

; 819  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsAllowsWalkWater@CvImprovementEntry@@QBE_NXZ ENDP	; CvImprovementEntry::IsAllowsWalkWater
_TEXT	ENDS
PUBLIC	?IsAllowsSailLand@CvImprovementEntry@@QBE_NXZ	; CvImprovementEntry::IsAllowsSailLand
; Function compile flags: /Odtp
;	COMDAT ?IsAllowsSailLand@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAllowsSailLand@CvImprovementEntry@@QBE_NXZ PROC	; CvImprovementEntry::IsAllowsSailLand, COMDAT
; _this$ = ecx

; 822  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 823  :     return m_bAllowsSailLand;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+370]

; 824  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsAllowsSailLand@CvImprovementEntry@@QBE_NXZ ENDP	; CvImprovementEntry::IsAllowsSailLand
_TEXT	ENDS
PUBLIC	?IsInAdjacentFriendly@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsInAdjacentFriendly
; Function compile flags: /Odtp
;	COMDAT ?IsInAdjacentFriendly@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsInAdjacentFriendly@CvImprovementEntry@@QBE_NXZ PROC	; CvImprovementEntry::IsInAdjacentFriendly, COMDAT
; _this$ = ecx

; 827  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 828  : 	return m_bInAdjacentFriendly;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+364]

; 829  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsInAdjacentFriendly@CvImprovementEntry@@QBE_NXZ ENDP	; CvImprovementEntry::IsInAdjacentFriendly
_TEXT	ENDS
PUBLIC	?IsCreatedByGreatPerson@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsCreatedByGreatPerson
; Function compile flags: /Odtp
;	COMDAT ?IsCreatedByGreatPerson@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsCreatedByGreatPerson@CvImprovementEntry@@QBE_NXZ PROC ; CvImprovementEntry::IsCreatedByGreatPerson, COMDAT
; _this$ = ecx

; 832  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 833  : 	return m_bCreatedByGreatPerson;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+371]

; 834  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsCreatedByGreatPerson@CvImprovementEntry@@QBE_NXZ ENDP ; CvImprovementEntry::IsCreatedByGreatPerson
_TEXT	ENDS
PUBLIC	?IsSpecificCivRequired@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsSpecificCivRequired
; Function compile flags: /Odtp
;	COMDAT ?IsSpecificCivRequired@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsSpecificCivRequired@CvImprovementEntry@@QBE_NXZ PROC	; CvImprovementEntry::IsSpecificCivRequired, COMDAT
; _this$ = ecx

; 837  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 838  : 	return m_bSpecificCivRequired;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+372]

; 839  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsSpecificCivRequired@CvImprovementEntry@@QBE_NXZ ENDP	; CvImprovementEntry::IsSpecificCivRequired
_TEXT	ENDS
PUBLIC	?GetRequiredCivilization@CvImprovementEntry@@QBE?AW4CivilizationTypes@@XZ ; CvImprovementEntry::GetRequiredCivilization
; Function compile flags: /Odtp
;	COMDAT ?GetRequiredCivilization@CvImprovementEntry@@QBE?AW4CivilizationTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRequiredCivilization@CvImprovementEntry@@QBE?AW4CivilizationTypes@@XZ PROC ; CvImprovementEntry::GetRequiredCivilization, COMDAT
; _this$ = ecx

; 842  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 843  : 	return m_eRequiredCivilization;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+408]

; 844  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetRequiredCivilization@CvImprovementEntry@@QBE?AW4CivilizationTypes@@XZ ENDP ; CvImprovementEntry::GetRequiredCivilization
_TEXT	ENDS
PUBLIC	?GetArtDefineTag@CvImprovementEntry@@QBEPBDXZ	; CvImprovementEntry::GetArtDefineTag
; Function compile flags: /Odtp
;	COMDAT ?GetArtDefineTag@CvImprovementEntry@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetArtDefineTag@CvImprovementEntry@@QBEPBDXZ PROC	; CvImprovementEntry::GetArtDefineTag, COMDAT
; _this$ = ecx

; 848  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 849  : 	return m_strArtDefineTag;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 376				; 00000178H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 850  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetArtDefineTag@CvImprovementEntry@@QBEPBDXZ ENDP	; CvImprovementEntry::GetArtDefineTag
_TEXT	ENDS
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
; Function compile flags: /Odtp
;	COMDAT ?SetArtDefineTag@CvImprovementEntry@@QAEXPBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T219504 = -4						; size = 4
_szVal$ = 8						; size = 4
?SetArtDefineTag@CvImprovementEntry@@QAEXPBD@Z PROC	; CvImprovementEntry::SetArtDefineTag, COMDAT
; _this$ = ecx

; 854  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 855  : 	m_strArtDefineTag = szVal;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 376				; 00000178H
	mov	DWORD PTR $T219504[ebp], eax
	cmp	DWORD PTR _szVal$[ebp], 0
	je	SHORT $LN4@SetArtDefi
	mov	ecx, DWORD PTR _szVal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T219504[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN1@SetArtDefi
$LN4@SetArtDefi:
	mov	ecx, DWORD PTR $T219504[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN1@SetArtDefi:

; 856  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetArtDefineTag@CvImprovementEntry@@QAEXPBD@Z ENDP	; CvImprovementEntry::SetArtDefineTag
_TEXT	ENDS
PUBLIC	?GetImprovementUsage@CvImprovementEntry@@QBE?AW4ImprovementUsageTypes@@XZ ; CvImprovementEntry::GetImprovementUsage
; Function compile flags: /Odtp
;	COMDAT ?GetImprovementUsage@CvImprovementEntry@@QBE?AW4ImprovementUsageTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetImprovementUsage@CvImprovementEntry@@QBE?AW4ImprovementUsageTypes@@XZ PROC ; CvImprovementEntry::GetImprovementUsage, COMDAT
; _this$ = ecx

; 859  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 860  : 	return m_eImprovementUsageType;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+404]

; 861  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetImprovementUsage@CvImprovementEntry@@QBE?AW4ImprovementUsageTypes@@XZ ENDP ; CvImprovementEntry::GetImprovementUsage
_TEXT	ENDS
PUBLIC	?SetImprovementUsage@CvImprovementEntry@@QAEXW4ImprovementUsageTypes@@@Z ; CvImprovementEntry::SetImprovementUsage
; Function compile flags: /Odtp
;	COMDAT ?SetImprovementUsage@CvImprovementEntry@@QAEXW4ImprovementUsageTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_usageType$ = 8						; size = 4
?SetImprovementUsage@CvImprovementEntry@@QAEXW4ImprovementUsageTypes@@@Z PROC ; CvImprovementEntry::SetImprovementUsage, COMDAT
; _this$ = ecx

; 864  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 865  : 	m_eImprovementUsageType = usageType;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _usageType$[ebp]
	mov	DWORD PTR [eax+404], ecx

; 866  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetImprovementUsage@CvImprovementEntry@@QAEXW4ImprovementUsageTypes@@@Z ENDP ; CvImprovementEntry::SetImprovementUsage
_TEXT	ENDS
PUBLIC	?GetWorldSoundscapeScriptId@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetWorldSoundscapeScriptId
; Function compile flags: /Odtp
;	COMDAT ?GetWorldSoundscapeScriptId@CvImprovementEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWorldSoundscapeScriptId@CvImprovementEntry@@QBEHXZ PROC ; CvImprovementEntry::GetWorldSoundscapeScriptId, COMDAT
; _this$ = ecx

; 870  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 871  : 	return m_iWorldSoundscapeScriptId;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+412]

; 872  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetWorldSoundscapeScriptId@CvImprovementEntry@@QBEHXZ ENDP ; CvImprovementEntry::GetWorldSoundscapeScriptId
_TEXT	ENDS
PUBLIC	?GetResourceQuantityRequirement@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetResourceQuantityRequirement
; Function compile flags: /Odtp
;	COMDAT ?GetResourceQuantityRequirement@CvImprovementEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetResourceQuantityRequirement@CvImprovementEntry@@QBEHH@Z PROC ; CvImprovementEntry::GetResourceQuantityRequirement, COMDAT
; _this$ = ecx

; 876  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 877  : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 878  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 879  : 	return m_piResourceQuantityRequirements ? m_piResourceQuantityRequirements[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+416], 0
	je	SHORT $LN3@GetResourc
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+416]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetResourc
$LN3@GetResourc:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetResourc:
	mov	eax, DWORD PTR tv69[ebp]

; 880  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetResourceQuantityRequirement@CvImprovementEntry@@QBEHH@Z ENDP ; CvImprovementEntry::GetResourceQuantityRequirement
_TEXT	ENDS
PUBLIC	?GetPrereqNatureYield@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetPrereqNatureYield
; Function compile flags: /Odtp
;	COMDAT ?GetPrereqNatureYield@CvImprovementEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetPrereqNatureYield@CvImprovementEntry@@QBEHH@Z PROC	; CvImprovementEntry::GetPrereqNatureYield, COMDAT
; _this$ = ecx

; 884  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 885  : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 886  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 887  : 	return m_piPrereqNatureYield ? m_piPrereqNatureYield[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+420], 0
	je	SHORT $LN3@GetPrereqN
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+420]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetPrereqN
$LN3@GetPrereqN:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetPrereqN:
	mov	eax, DWORD PTR tv69[ebp]

; 888  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetPrereqNatureYield@CvImprovementEntry@@QBEHH@Z ENDP	; CvImprovementEntry::GetPrereqNatureYield
_TEXT	ENDS
PUBLIC	?GetPrereqNatureYieldArray@CvImprovementEntry@@QAEPAHXZ ; CvImprovementEntry::GetPrereqNatureYieldArray
; Function compile flags: /Odtp
;	COMDAT ?GetPrereqNatureYieldArray@CvImprovementEntry@@QAEPAHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPrereqNatureYieldArray@CvImprovementEntry@@QAEPAHXZ PROC ; CvImprovementEntry::GetPrereqNatureYieldArray, COMDAT
; _this$ = ecx

; 891  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 892  : 	return m_piPrereqNatureYield;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+420]

; 893  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPrereqNatureYieldArray@CvImprovementEntry@@QAEPAHXZ ENDP ; CvImprovementEntry::GetPrereqNatureYieldArray
_TEXT	ENDS
PUBLIC	?GetYieldChange@CvImprovementEntry@@QBEHH@Z	; CvImprovementEntry::GetYieldChange
; Function compile flags: /Odtp
;	COMDAT ?GetYieldChange@CvImprovementEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetYieldChange@CvImprovementEntry@@QBEHH@Z PROC	; CvImprovementEntry::GetYieldChange, COMDAT
; _this$ = ecx

; 897  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 898  : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 899  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 900  : 	return m_piYieldChange ? m_piYieldChange[i] : 0;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+424], 0
	je	SHORT $LN3@GetYieldCh
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+424]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetYieldCh
$LN3@GetYieldCh:
	mov	DWORD PTR tv69[ebp], 0
$LN4@GetYieldCh:
	mov	eax, DWORD PTR tv69[ebp]

; 901  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetYieldChange@CvImprovementEntry@@QBEHH@Z ENDP	; CvImprovementEntry::GetYieldChange
_TEXT	ENDS
PUBLIC	?GetYieldChangeArray@CvImprovementEntry@@QAEPAHXZ ; CvImprovementEntry::GetYieldChangeArray
; Function compile flags: /Odtp
;	COMDAT ?GetYieldChangeArray@CvImprovementEntry@@QAEPAHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetYieldChangeArray@CvImprovementEntry@@QAEPAHXZ PROC	; CvImprovementEntry::GetYieldChangeArray, COMDAT
; _this$ = ecx

; 904  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 905  : 	return m_piYieldChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+424]

; 906  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetYieldChangeArray@CvImprovementEntry@@QAEPAHXZ ENDP	; CvImprovementEntry::GetYieldChangeArray
_TEXT	ENDS
PUBLIC	?GetYieldChangePerEra@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetYieldChangePerEra
; Function compile flags: /Odtp
;	COMDAT ?GetYieldChangePerEra@CvImprovementEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetYieldChangePerEra@CvImprovementEntry@@QBEHH@Z PROC	; CvImprovementEntry::GetYieldChangePerEra, COMDAT
; _this$ = ecx

; 910  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 911  : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 912  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 913  : 	return m_piYieldPerEra ? m_piYieldPerEra[i] : 0;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+428], 0
	je	SHORT $LN3@GetYieldCh@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+428]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetYieldCh@2
$LN3@GetYieldCh@2:
	mov	DWORD PTR tv69[ebp], 0
$LN4@GetYieldCh@2:
	mov	eax, DWORD PTR tv69[ebp]

; 914  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetYieldChangePerEra@CvImprovementEntry@@QBEHH@Z ENDP	; CvImprovementEntry::GetYieldChangePerEra
_TEXT	ENDS
PUBLIC	?GetRiverSideYieldChange@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetRiverSideYieldChange
; Function compile flags: /Odtp
;	COMDAT ?GetRiverSideYieldChange@CvImprovementEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetRiverSideYieldChange@CvImprovementEntry@@QBEHH@Z PROC ; CvImprovementEntry::GetRiverSideYieldChange, COMDAT
; _this$ = ecx

; 918  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 919  : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 920  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 921  : 	return m_piRiverSideYieldChange ? m_piRiverSideYieldChange[i] : 0;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+432], 0
	je	SHORT $LN3@GetRiverSi
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+432]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetRiverSi
$LN3@GetRiverSi:
	mov	DWORD PTR tv69[ebp], 0
$LN4@GetRiverSi:
	mov	eax, DWORD PTR tv69[ebp]

; 922  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetRiverSideYieldChange@CvImprovementEntry@@QBEHH@Z ENDP ; CvImprovementEntry::GetRiverSideYieldChange
_TEXT	ENDS
PUBLIC	?GetRiverSideYieldChangeArray@CvImprovementEntry@@QAEPAHXZ ; CvImprovementEntry::GetRiverSideYieldChangeArray
; Function compile flags: /Odtp
;	COMDAT ?GetRiverSideYieldChangeArray@CvImprovementEntry@@QAEPAHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRiverSideYieldChangeArray@CvImprovementEntry@@QAEPAHXZ PROC ; CvImprovementEntry::GetRiverSideYieldChangeArray, COMDAT
; _this$ = ecx

; 925  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 926  : 	return m_piRiverSideYieldChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+432]

; 927  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetRiverSideYieldChangeArray@CvImprovementEntry@@QAEPAHXZ ENDP ; CvImprovementEntry::GetRiverSideYieldChangeArray
_TEXT	ENDS
PUBLIC	?GetCoastalLandYieldChange@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetCoastalLandYieldChange
; Function compile flags: /Odtp
;	COMDAT ?GetCoastalLandYieldChange@CvImprovementEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetCoastalLandYieldChange@CvImprovementEntry@@QBEHH@Z PROC ; CvImprovementEntry::GetCoastalLandYieldChange, COMDAT
; _this$ = ecx

; 931  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 932  : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 933  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 934  : 	return m_piCoastalLandYieldChange ? m_piCoastalLandYieldChange[i] : 0;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+436], 0
	je	SHORT $LN3@GetCoastal
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+436]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetCoastal
$LN3@GetCoastal:
	mov	DWORD PTR tv69[ebp], 0
$LN4@GetCoastal:
	mov	eax, DWORD PTR tv69[ebp]

; 935  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetCoastalLandYieldChange@CvImprovementEntry@@QBEHH@Z ENDP ; CvImprovementEntry::GetCoastalLandYieldChange
_TEXT	ENDS
PUBLIC	?GetCoastalLandYieldChangeArray@CvImprovementEntry@@QAEPAHXZ ; CvImprovementEntry::GetCoastalLandYieldChangeArray
; Function compile flags: /Odtp
;	COMDAT ?GetCoastalLandYieldChangeArray@CvImprovementEntry@@QAEPAHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCoastalLandYieldChangeArray@CvImprovementEntry@@QAEPAHXZ PROC ; CvImprovementEntry::GetCoastalLandYieldChangeArray, COMDAT
; _this$ = ecx

; 938  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 939  : 	return m_piCoastalLandYieldChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+436]

; 940  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCoastalLandYieldChangeArray@CvImprovementEntry@@QAEPAHXZ ENDP ; CvImprovementEntry::GetCoastalLandYieldChangeArray
_TEXT	ENDS
PUBLIC	?GetHillsYieldChange@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetHillsYieldChange
; Function compile flags: /Odtp
;	COMDAT ?GetHillsYieldChange@CvImprovementEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetHillsYieldChange@CvImprovementEntry@@QBEHH@Z PROC	; CvImprovementEntry::GetHillsYieldChange, COMDAT
; _this$ = ecx

; 944  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 945  : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 946  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 947  : 	return m_piHillsYieldChange ? m_piHillsYieldChange[i] : 0;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+440], 0
	je	SHORT $LN3@GetHillsYi
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+440]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetHillsYi
$LN3@GetHillsYi:
	mov	DWORD PTR tv69[ebp], 0
$LN4@GetHillsYi:
	mov	eax, DWORD PTR tv69[ebp]

; 948  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetHillsYieldChange@CvImprovementEntry@@QBEHH@Z ENDP	; CvImprovementEntry::GetHillsYieldChange
_TEXT	ENDS
PUBLIC	?GetHillsYieldChangeArray@CvImprovementEntry@@QAEPAHXZ ; CvImprovementEntry::GetHillsYieldChangeArray
; Function compile flags: /Odtp
;	COMDAT ?GetHillsYieldChangeArray@CvImprovementEntry@@QAEPAHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetHillsYieldChangeArray@CvImprovementEntry@@QAEPAHXZ PROC ; CvImprovementEntry::GetHillsYieldChangeArray, COMDAT
; _this$ = ecx

; 951  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 952  : 	return m_piHillsYieldChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+440]

; 953  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetHillsYieldChangeArray@CvImprovementEntry@@QAEPAHXZ ENDP ; CvImprovementEntry::GetHillsYieldChangeArray
_TEXT	ENDS
PUBLIC	?GetFreshWaterYieldChange@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetFreshWaterYieldChange
; Function compile flags: /Odtp
;	COMDAT ?GetFreshWaterYieldChange@CvImprovementEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetFreshWaterYieldChange@CvImprovementEntry@@QBEHH@Z PROC ; CvImprovementEntry::GetFreshWaterYieldChange, COMDAT
; _this$ = ecx

; 957  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 958  : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 959  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 960  : 	return m_piFreshWaterChange ? m_piFreshWaterChange[i] : 0;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+444], 0
	je	SHORT $LN3@GetFreshWa
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+444]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetFreshWa
$LN3@GetFreshWa:
	mov	DWORD PTR tv69[ebp], 0
$LN4@GetFreshWa:
	mov	eax, DWORD PTR tv69[ebp]

; 961  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetFreshWaterYieldChange@CvImprovementEntry@@QBEHH@Z ENDP ; CvImprovementEntry::GetFreshWaterYieldChange
_TEXT	ENDS
PUBLIC	?GetFreshWaterYieldChangeArray@CvImprovementEntry@@QAEPAHXZ ; CvImprovementEntry::GetFreshWaterYieldChangeArray
; Function compile flags: /Odtp
;	COMDAT ?GetFreshWaterYieldChangeArray@CvImprovementEntry@@QAEPAHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFreshWaterYieldChangeArray@CvImprovementEntry@@QAEPAHXZ PROC ; CvImprovementEntry::GetFreshWaterYieldChangeArray, COMDAT
; _this$ = ecx

; 964  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 965  : 	return m_piFreshWaterChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+444]

; 966  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFreshWaterYieldChangeArray@CvImprovementEntry@@QAEPAHXZ ENDP ; CvImprovementEntry::GetFreshWaterYieldChangeArray
_TEXT	ENDS
PUBLIC	?GetAdjacentCityYieldChange@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetAdjacentCityYieldChange
; Function compile flags: /Odtp
;	COMDAT ?GetAdjacentCityYieldChange@CvImprovementEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetAdjacentCityYieldChange@CvImprovementEntry@@QBEHH@Z PROC ; CvImprovementEntry::GetAdjacentCityYieldChange, COMDAT
; _this$ = ecx

; 970  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 971  : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 972  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 973  : 	return m_piAdjacentCityYieldChange ? m_piAdjacentCityYieldChange[i] : 0;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+448], 0
	je	SHORT $LN3@GetAdjacen
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+448]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetAdjacen
$LN3@GetAdjacen:
	mov	DWORD PTR tv69[ebp], 0
$LN4@GetAdjacen:
	mov	eax, DWORD PTR tv69[ebp]

; 974  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetAdjacentCityYieldChange@CvImprovementEntry@@QBEHH@Z ENDP ; CvImprovementEntry::GetAdjacentCityYieldChange
_TEXT	ENDS
PUBLIC	?GetAdjacentCityYieldChangeArray@CvImprovementEntry@@QAEPAHXZ ; CvImprovementEntry::GetAdjacentCityYieldChangeArray
; Function compile flags: /Odtp
;	COMDAT ?GetAdjacentCityYieldChangeArray@CvImprovementEntry@@QAEPAHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAdjacentCityYieldChangeArray@CvImprovementEntry@@QAEPAHXZ PROC ; CvImprovementEntry::GetAdjacentCityYieldChangeArray, COMDAT
; _this$ = ecx

; 977  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 978  : 	return m_piAdjacentCityYieldChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+448]

; 979  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetAdjacentCityYieldChangeArray@CvImprovementEntry@@QAEPAHXZ ENDP ; CvImprovementEntry::GetAdjacentCityYieldChangeArray
_TEXT	ENDS
PUBLIC	?GetAdjacentMountainYieldChange@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetAdjacentMountainYieldChange
; Function compile flags: /Odtp
;	COMDAT ?GetAdjacentMountainYieldChange@CvImprovementEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetAdjacentMountainYieldChange@CvImprovementEntry@@QBEHH@Z PROC ; CvImprovementEntry::GetAdjacentMountainYieldChange, COMDAT
; _this$ = ecx

; 983  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 984  : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 985  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 986  : 	return m_piAdjacentMountainYieldChange ? m_piAdjacentMountainYieldChange[i] : 0;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+452], 0
	je	SHORT $LN3@GetAdjacen@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+452]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetAdjacen@2
$LN3@GetAdjacen@2:
	mov	DWORD PTR tv69[ebp], 0
$LN4@GetAdjacen@2:
	mov	eax, DWORD PTR tv69[ebp]

; 987  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetAdjacentMountainYieldChange@CvImprovementEntry@@QBEHH@Z ENDP ; CvImprovementEntry::GetAdjacentMountainYieldChange
_TEXT	ENDS
PUBLIC	?GetAdjacentMountainYieldChangeArray@CvImprovementEntry@@QAEPAHXZ ; CvImprovementEntry::GetAdjacentMountainYieldChangeArray
; Function compile flags: /Odtp
;	COMDAT ?GetAdjacentMountainYieldChangeArray@CvImprovementEntry@@QAEPAHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAdjacentMountainYieldChangeArray@CvImprovementEntry@@QAEPAHXZ PROC ; CvImprovementEntry::GetAdjacentMountainYieldChangeArray, COMDAT
; _this$ = ecx

; 990  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 991  : 	return m_piAdjacentMountainYieldChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+452]

; 992  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetAdjacentMountainYieldChangeArray@CvImprovementEntry@@QAEPAHXZ ENDP ; CvImprovementEntry::GetAdjacentMountainYieldChangeArray
_TEXT	ENDS
PUBLIC	?GetTerrainMakesValid@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::GetTerrainMakesValid
; Function compile flags: /Odtp
;	COMDAT ?GetTerrainMakesValid@CvImprovementEntry@@QBE_NH@Z
_TEXT	SEGMENT
tv68 = -5						; size = 1
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetTerrainMakesValid@CvImprovementEntry@@QBE_NH@Z PROC	; CvImprovementEntry::GetTerrainMakesValid, COMDAT
; _this$ = ecx

; 996  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 997  : 	CvAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
; 998  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 999  : 	return m_pbTerrainMakesValid ? m_pbTerrainMakesValid[i] : false;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+460], 0
	je	SHORT $LN3@GetTerrain
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+460]
	mov	eax, DWORD PTR _i$[ebp]
	mov	cl, BYTE PTR [edx+eax]
	mov	BYTE PTR tv68[ebp], cl
	jmp	SHORT $LN4@GetTerrain
$LN3@GetTerrain:
	mov	BYTE PTR tv68[ebp], 0
$LN4@GetTerrain:
	mov	al, BYTE PTR tv68[ebp]

; 1000 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetTerrainMakesValid@CvImprovementEntry@@QBE_NH@Z ENDP	; CvImprovementEntry::GetTerrainMakesValid
_TEXT	ENDS
PUBLIC	?GetFeatureMakesValid@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::GetFeatureMakesValid
; Function compile flags: /Odtp
;	COMDAT ?GetFeatureMakesValid@CvImprovementEntry@@QBE_NH@Z
_TEXT	SEGMENT
tv68 = -5						; size = 1
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetFeatureMakesValid@CvImprovementEntry@@QBE_NH@Z PROC	; CvImprovementEntry::GetFeatureMakesValid, COMDAT
; _this$ = ecx

; 1004 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1005 : 	CvAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
; 1006 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1007 : 	return m_pbFeatureMakesValid ? m_pbFeatureMakesValid[i] : false;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+464], 0
	je	SHORT $LN3@GetFeature
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+464]
	mov	eax, DWORD PTR _i$[ebp]
	mov	cl, BYTE PTR [edx+eax]
	mov	BYTE PTR tv68[ebp], cl
	jmp	SHORT $LN4@GetFeature
$LN3@GetFeature:
	mov	BYTE PTR tv68[ebp], 0
$LN4@GetFeature:
	mov	al, BYTE PTR tv68[ebp]

; 1008 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetFeatureMakesValid@CvImprovementEntry@@QBE_NH@Z ENDP	; CvImprovementEntry::GetFeatureMakesValid
_TEXT	ENDS
PUBLIC	?GetImprovementMakesValid@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::GetImprovementMakesValid
; Function compile flags: /Odtp
;	COMDAT ?GetImprovementMakesValid@CvImprovementEntry@@QBE_NH@Z
_TEXT	SEGMENT
tv68 = -5						; size = 1
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetImprovementMakesValid@CvImprovementEntry@@QBE_NH@Z PROC ; CvImprovementEntry::GetImprovementMakesValid, COMDAT
; _this$ = ecx

; 1012 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1013 : 	CvAssertMsg(i < GC.getNumImprovementInfos(), "Index out of bounds");
; 1014 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1015 : 	return m_pbImprovementMakesValid ? m_pbImprovementMakesValid[i] : false;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+468], 0
	je	SHORT $LN3@GetImprove
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+468]
	mov	eax, DWORD PTR _i$[ebp]
	mov	cl, BYTE PTR [edx+eax]
	mov	BYTE PTR tv68[ebp], cl
	jmp	SHORT $LN4@GetImprove
$LN3@GetImprove:
	mov	BYTE PTR tv68[ebp], 0
$LN4@GetImprove:
	mov	al, BYTE PTR tv68[ebp]

; 1016 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetImprovementMakesValid@CvImprovementEntry@@QBE_NH@Z ENDP ; CvImprovementEntry::GetImprovementMakesValid
_TEXT	ENDS
PUBLIC	?GetTechYieldChanges@CvImprovementEntry@@QBEHHH@Z ; CvImprovementEntry::GetTechYieldChanges
; Function compile flags: /Odtp
;	COMDAT ?GetTechYieldChanges@CvImprovementEntry@@QBEHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
_j$ = 12						; size = 4
?GetTechYieldChanges@CvImprovementEntry@@QBEHHH@Z PROC	; CvImprovementEntry::GetTechYieldChanges, COMDAT
; _this$ = ecx

; 1020 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1021 : 	CvAssertMsg(i < GC.getNumTechInfos(), "Index out of bounds");
; 1022 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1023 : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 1024 : 	CvAssertMsg(j > -1, "Index out of bounds");
; 1025 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 1026 : 	return m_ppiTechYieldChanges.first ? m_ppiTechYieldChanges.first[i][j] : 0;
; 1027 : #else
; 1028 : 	return m_ppiTechYieldChanges[i][j];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+472]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1029 : #endif
; 1030 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetTechYieldChanges@CvImprovementEntry@@QBEHHH@Z ENDP	; CvImprovementEntry::GetTechYieldChanges
_TEXT	ENDS
PUBLIC	?GetTechYieldChangesArray@CvImprovementEntry@@QAEPAHH@Z ; CvImprovementEntry::GetTechYieldChangesArray
; Function compile flags: /Odtp
;	COMDAT ?GetTechYieldChangesArray@CvImprovementEntry@@QAEPAHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetTechYieldChangesArray@CvImprovementEntry@@QAEPAHH@Z PROC ; CvImprovementEntry::GetTechYieldChangesArray, COMDAT
; _this$ = ecx

; 1033 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1034 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 1035 : 	return m_ppiTechYieldChanges.first ? m_ppiTechYieldChanges.first[i] : NULL;
; 1036 : #else
; 1037 : 	return m_ppiTechYieldChanges[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+472]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 1038 : #endif
; 1039 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetTechYieldChangesArray@CvImprovementEntry@@QAEPAHH@Z ENDP ; CvImprovementEntry::GetTechYieldChangesArray
_TEXT	ENDS
PUBLIC	?GetTechNoFreshWaterYieldChanges@CvImprovementEntry@@QBEHHH@Z ; CvImprovementEntry::GetTechNoFreshWaterYieldChanges
; Function compile flags: /Odtp
;	COMDAT ?GetTechNoFreshWaterYieldChanges@CvImprovementEntry@@QBEHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
_j$ = 12						; size = 4
?GetTechNoFreshWaterYieldChanges@CvImprovementEntry@@QBEHHH@Z PROC ; CvImprovementEntry::GetTechNoFreshWaterYieldChanges, COMDAT
; _this$ = ecx

; 1043 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1044 : 	CvAssertMsg(i < GC.getNumTechInfos(), "Index out of bounds");
; 1045 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1046 : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 1047 : 	CvAssertMsg(j > -1, "Index out of bounds");
; 1048 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 1049 : 	return m_ppiTechNoFreshWaterYieldChanges.first ? m_ppiTechNoFreshWaterYieldChanges.first[i][j] : 0;
; 1050 : #else
; 1051 : 	return m_ppiTechNoFreshWaterYieldChanges[i][j];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+476]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1052 : #endif
; 1053 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetTechNoFreshWaterYieldChanges@CvImprovementEntry@@QBEHHH@Z ENDP ; CvImprovementEntry::GetTechNoFreshWaterYieldChanges
_TEXT	ENDS
PUBLIC	?GetTechNoFreshWaterYieldChangesArray@CvImprovementEntry@@QAEPAHH@Z ; CvImprovementEntry::GetTechNoFreshWaterYieldChangesArray
; Function compile flags: /Odtp
;	COMDAT ?GetTechNoFreshWaterYieldChangesArray@CvImprovementEntry@@QAEPAHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetTechNoFreshWaterYieldChangesArray@CvImprovementEntry@@QAEPAHH@Z PROC ; CvImprovementEntry::GetTechNoFreshWaterYieldChangesArray, COMDAT
; _this$ = ecx

; 1056 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1057 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 1058 : 	return m_ppiTechNoFreshWaterYieldChanges.first ? m_ppiTechNoFreshWaterYieldChanges.first[i] : NULL;
; 1059 : #else
; 1060 : 	return m_ppiTechNoFreshWaterYieldChanges[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+476]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 1061 : #endif
; 1062 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetTechNoFreshWaterYieldChangesArray@CvImprovementEntry@@QAEPAHH@Z ENDP ; CvImprovementEntry::GetTechNoFreshWaterYieldChangesArray
_TEXT	ENDS
PUBLIC	?GetTechFreshWaterYieldChanges@CvImprovementEntry@@QBEHHH@Z ; CvImprovementEntry::GetTechFreshWaterYieldChanges
; Function compile flags: /Odtp
;	COMDAT ?GetTechFreshWaterYieldChanges@CvImprovementEntry@@QBEHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
_j$ = 12						; size = 4
?GetTechFreshWaterYieldChanges@CvImprovementEntry@@QBEHHH@Z PROC ; CvImprovementEntry::GetTechFreshWaterYieldChanges, COMDAT
; _this$ = ecx

; 1066 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1067 : 	CvAssertMsg(i < GC.getNumTechInfos(), "Index out of bounds");
; 1068 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1069 : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 1070 : 	CvAssertMsg(j > -1, "Index out of bounds");
; 1071 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 1072 : 	return m_ppiTechFreshWaterYieldChanges.first ? m_ppiTechFreshWaterYieldChanges.first[i][j] : 0;
; 1073 : #else
; 1074 : 	return m_ppiTechFreshWaterYieldChanges[i][j];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+480]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1075 : #endif
; 1076 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetTechFreshWaterYieldChanges@CvImprovementEntry@@QBEHHH@Z ENDP ; CvImprovementEntry::GetTechFreshWaterYieldChanges
_TEXT	ENDS
PUBLIC	?GetTechFreshWaterYieldChangesArray@CvImprovementEntry@@QAEPAHH@Z ; CvImprovementEntry::GetTechFreshWaterYieldChangesArray
; Function compile flags: /Odtp
;	COMDAT ?GetTechFreshWaterYieldChangesArray@CvImprovementEntry@@QAEPAHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetTechFreshWaterYieldChangesArray@CvImprovementEntry@@QAEPAHH@Z PROC ; CvImprovementEntry::GetTechFreshWaterYieldChangesArray, COMDAT
; _this$ = ecx

; 1079 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1080 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 1081 : 	return m_ppiTechFreshWaterYieldChanges.first ? m_ppiTechFreshWaterYieldChanges.first[i] : NULL;
; 1082 : #else
; 1083 : 	return m_ppiTechFreshWaterYieldChanges[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+480]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 1084 : #endif
; 1085 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetTechFreshWaterYieldChangesArray@CvImprovementEntry@@QAEPAHH@Z ENDP ; CvImprovementEntry::GetTechFreshWaterYieldChangesArray
_TEXT	ENDS
PUBLIC	?GetRouteYieldChanges@CvImprovementEntry@@QBEHHH@Z ; CvImprovementEntry::GetRouteYieldChanges
; Function compile flags: /Odtp
;	COMDAT ?GetRouteYieldChanges@CvImprovementEntry@@QBEHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
_j$ = 12						; size = 4
?GetRouteYieldChanges@CvImprovementEntry@@QBEHHH@Z PROC	; CvImprovementEntry::GetRouteYieldChanges, COMDAT
; _this$ = ecx

; 1089 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1090 : 	CvAssertMsg(i < GC.getNumRouteInfos(), "Index out of bounds");
; 1091 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1092 : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 1093 : 	CvAssertMsg(j > -1, "Index out of bounds");
; 1094 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 1095 : 	return m_ppiRouteYieldChanges.first ? m_ppiRouteYieldChanges.first[i][j] : 0;
; 1096 : #else
; 1097 : 	return m_ppiRouteYieldChanges[i][j];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+484]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1098 : #endif
; 1099 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetRouteYieldChanges@CvImprovementEntry@@QBEHHH@Z ENDP	; CvImprovementEntry::GetRouteYieldChanges
_TEXT	ENDS
PUBLIC	?GetRouteYieldChangesArray@CvImprovementEntry@@QAEPAHH@Z ; CvImprovementEntry::GetRouteYieldChangesArray
; Function compile flags: /Odtp
;	COMDAT ?GetRouteYieldChangesArray@CvImprovementEntry@@QAEPAHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetRouteYieldChangesArray@CvImprovementEntry@@QAEPAHH@Z PROC ; CvImprovementEntry::GetRouteYieldChangesArray, COMDAT
; _this$ = ecx

; 1102 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 1104 : 	return m_ppiRouteYieldChanges.first ? m_ppiRouteYieldChanges.first[i] : NULL;
; 1105 : #else
; 1106 : 	return m_ppiRouteYieldChanges[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+484]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 1107 : #endif
; 1108 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetRouteYieldChangesArray@CvImprovementEntry@@QAEPAHH@Z ENDP ; CvImprovementEntry::GetRouteYieldChangesArray
_TEXT	ENDS
PUBLIC	?GetImprovementResourceYield@CvImprovementEntry@@QBEHHH@Z ; CvImprovementEntry::GetImprovementResourceYield
; Function compile flags: /Odtp
;	COMDAT ?GetImprovementResourceYield@CvImprovementEntry@@QBEHHH@Z
_TEXT	SEGMENT
tv75 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
_j$ = 12						; size = 4
?GetImprovementResourceYield@CvImprovementEntry@@QBEHHH@Z PROC ; CvImprovementEntry::GetImprovementResourceYield, COMDAT
; _this$ = ecx

; 1112 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1113 : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 1114 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1115 : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 1116 : 	CvAssertMsg(j > -1, "Index out of bounds");
; 1117 : 	return m_paImprovementResource[i].m_piYieldChange ? m_paImprovementResource[i].getYieldChange(j) : 0;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+488]
	cmp	DWORD PTR [edx+eax+8], 0
	je	SHORT $LN3@GetImprove@2
	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+488]
	call	?getYieldChange@CvImprovementResourceInfo@@QBEHH@Z ; CvImprovementResourceInfo::getYieldChange
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN4@GetImprove@2
$LN3@GetImprove@2:
	mov	DWORD PTR tv75[ebp], 0
$LN4@GetImprove@2:
	mov	eax, DWORD PTR tv75[ebp]

; 1118 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetImprovementResourceYield@CvImprovementEntry@@QBEHHH@Z ENDP ; CvImprovementEntry::GetImprovementResourceYield
_TEXT	ENDS
PUBLIC	?IsImprovementResourceMakesValid@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::IsImprovementResourceMakesValid
; Function compile flags: /Odtp
;	COMDAT ?IsImprovementResourceMakesValid@CvImprovementEntry@@QBE_NH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?IsImprovementResourceMakesValid@CvImprovementEntry@@QBE_NH@Z PROC ; CvImprovementEntry::IsImprovementResourceMakesValid, COMDAT
; _this$ = ecx

; 1122 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1123 : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 1124 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1125 : 	return m_paImprovementResource[i].m_bResourceMakesValid;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+488]
	mov	al, BYTE PTR [edx+eax+4]

; 1126 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsImprovementResourceMakesValid@CvImprovementEntry@@QBE_NH@Z ENDP ; CvImprovementEntry::IsImprovementResourceMakesValid
_TEXT	ENDS
PUBLIC	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::IsImprovementResourceTrade
; Function compile flags: /Odtp
;	COMDAT ?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z PROC ; CvImprovementEntry::IsImprovementResourceTrade, COMDAT
; _this$ = ecx

; 1130 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1131 : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 1132 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1133 : 	return m_paImprovementResource[i].m_bResourceTrade;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+488]
	mov	al, BYTE PTR [edx+eax+5]

; 1134 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z ENDP ; CvImprovementEntry::IsImprovementResourceTrade
_TEXT	ENDS
PUBLIC	?GetImprovementResourceDiscoverRand@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetImprovementResourceDiscoverRand
; Function compile flags: /Odtp
;	COMDAT ?GetImprovementResourceDiscoverRand@CvImprovementEntry@@QBEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetImprovementResourceDiscoverRand@CvImprovementEntry@@QBEHH@Z PROC ; CvImprovementEntry::GetImprovementResourceDiscoverRand, COMDAT
; _this$ = ecx

; 1138 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 1140 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1141 : 	return m_paImprovementResource[i].m_iDiscoverRand;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+488]
	mov	eax, DWORD PTR [eax+edx]

; 1142 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetImprovementResourceDiscoverRand@CvImprovementEntry@@QBEHH@Z ENDP ; CvImprovementEntry::GetImprovementResourceDiscoverRand
_TEXT	ENDS
PUBLIC	?GetFlavorValue@CvImprovementEntry@@QBEHH@Z	; CvImprovementEntry::GetFlavorValue
; Function compile flags: /Odtp
;	COMDAT ?GetFlavorValue@CvImprovementEntry@@QBEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetFlavorValue@CvImprovementEntry@@QBEHH@Z PROC	; CvImprovementEntry::GetFlavorValue, COMDAT
; _this$ = ecx

; 1146 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1147 : 	CvAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 1148 : 	CvAssertMsg(i > -1, "Indes out of bounds");
; 1149 : 	return m_piFlavorValue[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+456]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 1150 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetFlavorValue@CvImprovementEntry@@QBEHH@Z ENDP	; CvImprovementEntry::GetFlavorValue
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::~_Vector_val<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >
PUBLIC	?_Buy@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::_Buy
PUBLIC	??0CvImprovementXMLEntries@@QAE@XZ		; CvImprovementXMLEntries::CvImprovementXMLEntries
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0CvImprovementXMLEntries@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvImprovementXMLEntries@@QAE@XZ$1
__ehfuncinfo$??0CvImprovementXMLEntries@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvImprovementXMLEntries@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvimprovementclasses.cpp
xdata$x	ENDS
;	COMDAT ??0CvImprovementXMLEntries@@QAE@XZ
_TEXT	SEGMENT
tv92 = -132						; size = 4
tv149 = -128						; size = 4
_this$ = -124						; size = 4
$T219640 = -30						; size = 1
$T219627 = -29						; size = 1
$T219623 = -28						; size = 4
$T219616 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0CvImprovementXMLEntries@@QAE@XZ PROC			; CvImprovementXMLEntries::CvImprovementXMLEntries, COMDAT
; _this$ = ecx

; 1158 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvImprovementXMLEntries@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T219640[ebp]
	mov	DWORD PTR $T219616[ebp], eax
	lea	ecx, DWORD PTR $T219627[ebp]
	mov	DWORD PTR $T219623[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv149[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv92[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::_Buy
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 1159 : 
; 1160 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvImprovementXMLEntries@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE@XZ
__ehhandler$??0CvImprovementXMLEntries@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvImprovementXMLEntries@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvImprovementXMLEntries@@QAE@XZ ENDP			; CvImprovementXMLEntries::CvImprovementXMLEntries
PUBLIC	??1?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE@XZ ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::~vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >
PUBLIC	?_Tidy@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@IAEXXZ ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::_Tidy
PUBLIC	?DeleteArray@CvImprovementXMLEntries@@QAEXXZ	; CvImprovementXMLEntries::DeleteArray
PUBLIC	??1CvImprovementXMLEntries@@QAE@XZ		; CvImprovementXMLEntries::~CvImprovementXMLEntries
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1CvImprovementXMLEntries@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvImprovementXMLEntries@@QAE@XZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvImprovementXMLEntries@@QAE@XZ$1
__ehfuncinfo$??1CvImprovementXMLEntries@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1CvImprovementXMLEntries@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvimprovementclasses.cpp
xdata$x	ENDS
;	COMDAT ??1CvImprovementXMLEntries@@QAE@XZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
__$EHRec$ = -12						; size = 12
??1CvImprovementXMLEntries@@QAE@XZ PROC			; CvImprovementXMLEntries::~CvImprovementXMLEntries, COMDAT
; _this$ = ecx

; 1164 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvImprovementXMLEntries@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1165 : 	DeleteArray();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DeleteArray@CvImprovementXMLEntries@@QAEXXZ ; CvImprovementXMLEntries::DeleteArray

; 1166 : }

	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@IAEXXZ ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvImprovementXMLEntries@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE@XZ ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::~vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >
__unwindfunclet$??1CvImprovementXMLEntries@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE@XZ
__ehhandler$??1CvImprovementXMLEntries@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvImprovementXMLEntries@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvImprovementXMLEntries@@QAE@XZ ENDP			; CvImprovementXMLEntries::~CvImprovementXMLEntries
PUBLIC	?GetImprovementEntries@CvImprovementXMLEntries@@QAEAAV?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@XZ ; CvImprovementXMLEntries::GetImprovementEntries
; Function compile flags: /Odtp
;	COMDAT ?GetImprovementEntries@CvImprovementXMLEntries@@QAEAAV?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetImprovementEntries@CvImprovementXMLEntries@@QAEAAV?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@XZ PROC ; CvImprovementXMLEntries::GetImprovementEntries, COMDAT
; _this$ = ecx

; 1170 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1171 : 	return m_paImprovementEntries;

	mov	eax, DWORD PTR _this$[ebp]

; 1172 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetImprovementEntries@CvImprovementXMLEntries@@QAEAAV?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@XZ ENDP ; CvImprovementXMLEntries::GetImprovementEntries
_TEXT	ENDS
PUBLIC	?GetNumImprovements@CvImprovementXMLEntries@@QAEHXZ ; CvImprovementXMLEntries::GetNumImprovements
; Function compile flags: /Odtp
;	COMDAT ?GetNumImprovements@CvImprovementXMLEntries@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumImprovements@CvImprovementXMLEntries@@QAEHXZ PROC ; CvImprovementXMLEntries::GetNumImprovements, COMDAT
; _this$ = ecx

; 1180 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1181 : 	return m_paImprovementEntries.size();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 1182 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumImprovements@CvImprovementXMLEntries@@QAEHXZ ENDP ; CvImprovementXMLEntries::GetNumImprovements
_TEXT	ENDS
PUBLIC	?GetEntry@CvImprovementXMLEntries@@QAEPAVCvImprovementEntry@@H@Z ; CvImprovementXMLEntries::GetEntry
; Function compile flags: /Odtp
;	COMDAT ?GetEntry@CvImprovementXMLEntries@@QAEPAVCvImprovementEntry@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?GetEntry@CvImprovementXMLEntries@@QAEPAVCvImprovementEntry@@H@Z PROC ; CvImprovementXMLEntries::GetEntry, COMDAT
; _this$ = ecx

; 1190 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1191 : 	return m_paImprovementEntries[index];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 1192 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetEntry@CvImprovementXMLEntries@@QAEPAVCvImprovementEntry@@H@Z ENDP ; CvImprovementXMLEntries::GetEntry
_TEXT	ENDS
PUBLIC	?GetImprovementForResource@CvImprovementXMLEntries@@QAEPAVCvImprovementEntry@@H@Z ; CvImprovementXMLEntries::GetImprovementForResource
; Function compile flags: /Odtp
;	COMDAT ?GetImprovementForResource@CvImprovementXMLEntries@@QAEPAVCvImprovementEntry@@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_pImprovement$218137 = -8				; size = 4
_iImprovement$218133 = -4				; size = 4
_eResource$ = 8						; size = 4
?GetImprovementForResource@CvImprovementXMLEntries@@QAEPAVCvImprovementEntry@@H@Z PROC ; CvImprovementXMLEntries::GetImprovementForResource, COMDAT
; _this$ = ecx

; 1196 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1197 : 	for(unsigned int iImprovement = 0; iImprovement < m_paImprovementEntries.size(); ++iImprovement)

	mov	DWORD PTR _iImprovement$218133[ebp], 0
	jmp	SHORT $LN7@GetImprove@3
$LN3@GetImprove@3:
	mov	eax, DWORD PTR _iImprovement$218133[ebp]
	add	eax, 1
	mov	DWORD PTR _iImprovement$218133[ebp], eax
$LN7@GetImprove@3:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	cmp	DWORD PTR _iImprovement$218133[ebp], eax
	jae	SHORT $LN2@GetImprove@3

; 1198 : 	{
; 1199 : 		CvImprovementEntry* pImprovement = GetEntry((ImprovementTypes)iImprovement);

	mov	ecx, DWORD PTR _iImprovement$218133[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEntry@CvImprovementXMLEntries@@QAEPAVCvImprovementEntry@@H@Z ; CvImprovementXMLEntries::GetEntry
	mov	DWORD PTR _pImprovement$218137[ebp], eax

; 1200 : 		if(pImprovement && pImprovement->IsImprovementResourceMakesValid(eResource))

	cmp	DWORD PTR _pImprovement$218137[ebp], 0
	je	SHORT $LN1@GetImprove@3
	mov	edx, DWORD PTR _eResource$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pImprovement$218137[ebp]
	call	?IsImprovementResourceMakesValid@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::IsImprovementResourceMakesValid
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@GetImprove@3

; 1201 : 		{
; 1202 : 			return pImprovement;

	mov	eax, DWORD PTR _pImprovement$218137[ebp]
	jmp	SHORT $LN5@GetImprove@3
$LN1@GetImprove@3:

; 1203 : 		}
; 1204 : 	}

	jmp	SHORT $LN3@GetImprove@3
$LN2@GetImprove@3:

; 1205 : 
; 1206 : 	return NULL;

	xor	eax, eax
$LN5@GetImprove@3:

; 1207 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetImprovementForResource@CvImprovementXMLEntries@@QAEPAVCvImprovementEntry@@H@Z ENDP ; CvImprovementXMLEntries::GetImprovementForResource
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@2@0@Z ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::erase
; Function compile flags: /Odtp
;	COMDAT ?DeleteArray@CvImprovementXMLEntries@@QAEXXZ
_TEXT	SEGMENT
tv143 = -116						; size = 4
_this$ = -112						; size = 4
$T219893 = -56						; size = 4
$T219877 = -52						; size = 4
$T219998 = -48						; size = 4
$T219997 = -44						; size = 4
$T219996 = -40						; size = 4
$T219995 = -36						; size = 4
$T219994 = -32						; size = 4
$T219861 = -28						; size = 4
$T219855 = -24						; size = 4
$T219854 = -20						; size = 4
$T219820 = -16						; size = 4
$T219796 = -12						; size = 4
$T219786 = -8						; size = 4
_it$218294 = -4						; size = 4
?DeleteArray@CvImprovementXMLEntries@@QAEXXZ PROC	; CvImprovementXMLEntries::DeleteArray, COMDAT
; _this$ = ecx

; 1211 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	DWORD PTR _this$[ebp], ecx

; 1212 : 	for(std::vector<CvImprovementEntry*>::iterator it = m_paImprovementEntries.begin(); it != m_paImprovementEntries.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T219796[ebp], ecx
	mov	edx, DWORD PTR $T219796[ebp]
	mov	DWORD PTR _it$218294[ebp], edx
	jmp	SHORT $LN3@DeleteArra
$LN2@DeleteArra:
	mov	eax, DWORD PTR _it$218294[ebp]
	add	eax, 4
	mov	DWORD PTR _it$218294[ebp], eax
$LN3@DeleteArra:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T219820[ebp], edx
	mov	eax, DWORD PTR $T219820[ebp]
	mov	DWORD PTR $T219786[ebp], eax
	mov	ecx, DWORD PTR _it$218294[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T219786[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@DeleteArra

; 1213 : 	{
; 1214 : 		SAFE_DELETE(*it);

	mov	edx, DWORD PTR _it$218294[ebp]
	mov	DWORD PTR $T219861[ebp], edx
	mov	eax, DWORD PTR $T219861[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T219855[ebp], ecx
	mov	edx, DWORD PTR $T219855[ebp]
	mov	DWORD PTR $T219854[ebp], edx
	cmp	DWORD PTR $T219854[ebp], 0
	je	SHORT $LN32@DeleteArra
	mov	ecx, DWORD PTR $T219854[ebp]
	call	??1CvImprovementEntry@@QAE@XZ		; CvImprovementEntry::~CvImprovementEntry
	mov	eax, 1
	and	eax, 1
	je	SHORT $LN35@DeleteArra
	mov	ecx, DWORD PTR $T219854[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN35@DeleteArra:
	mov	edx, DWORD PTR $T219854[ebp]
	mov	DWORD PTR tv143[ebp], edx
	jmp	SHORT $LN33@DeleteArra
$LN32@DeleteArra:
	mov	DWORD PTR tv143[ebp], 0
$LN33@DeleteArra:
	mov	eax, DWORD PTR $T219861[ebp]
	mov	DWORD PTR [eax], 0

; 1215 : 	}

	jmp	$LN2@DeleteArra
$LN1@DeleteArra:

; 1216 : 
; 1217 : 	m_paImprovementEntries.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T219877[ebp], edx
	mov	eax, DWORD PTR $T219877[ebp]
	mov	DWORD PTR $T219995[ebp], eax
	mov	ecx, DWORD PTR $T219995[ebp]
	mov	DWORD PTR $T219994[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T219893[ebp], eax
	mov	ecx, DWORD PTR $T219893[ebp]
	mov	DWORD PTR $T219997[ebp], ecx
	mov	edx, DWORD PTR $T219997[ebp]
	mov	DWORD PTR $T219996[ebp], edx
	mov	eax, DWORD PTR $T219994[ebp]
	push	eax
	mov	ecx, DWORD PTR $T219996[ebp]
	push	ecx
	lea	edx, DWORD PTR $T219998[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@2@0@Z ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::erase

; 1218 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DeleteArray@CvImprovementXMLEntries@@QAEXXZ ENDP	; CvImprovementXMLEntries::DeleteArray
_TEXT	ENDS
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
PUBLIC	??_C@_0CH@DGBBDFBA@LOAD?5ERROR?3?5Improvement?5Type?5not@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?Read@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAH@Z ; ImprovementArrayHelpers::Read
EXTRN	?LogMessage@CvGlobals@@QAEXPBD@Z:PROC		; CvGlobals::LogMessage
EXTRN	?getInfoTypeForHash@CvGlobals@@QBEHI_N@Z:PROC	; CvGlobals::getInfoTypeForHash
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
EXTRN	?getNumImprovementInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumImprovementInfos
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
;	COMDAT ??_C@_0CH@DGBBDFBA@LOAD?5ERROR?3?5Improvement?5Type?5not@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0CH@DGBBDFBA@LOAD?5ERROR?3?5Improvement?5Type?5not@ DB 'LOAD ERROR:'
	DB	' Improvement Type not found', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Read@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Read@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAH@Z$0
__ehfuncinfo$?Read@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Read@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvimprovementclasses.cpp
xdata$x	ENDS
;	COMDAT ?Read@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAH@Z
_TEXT	SEGMENT
_iDummy$218322 = -68					; size = 4
_szError$218320 = -64					; size = 28
__$ArrayPad$ = -36					; size = 4
_iType$218317 = -32					; size = 4
_uiHash$218314 = -28					; size = 4
_iI$218310 = -24					; size = 4
_iNumEntries$ = -20					; size = 4
_iArraySize$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_kStream$ = 8						; size = 4
_paiImprovementArray$ = 12				; size = 4
?Read@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAH@Z PROC ; ImprovementArrayHelpers::Read, COMDAT

; 1222 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Read@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1223 : 	int iNumEntries;
; 1224 : 
; 1225 : 	kStream >> iNumEntries;

	lea	eax, DWORD PTR _iNumEntries$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1226 : 
; 1227 : 	int iArraySize = GC.getNumImprovementInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumImprovementInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumImprovementInfos
	mov	DWORD PTR _iArraySize$[ebp], eax

; 1228 : 	for(int iI = 0; iI < iNumEntries; iI++)

	mov	DWORD PTR _iI$218310[ebp], 0
	jmp	SHORT $LN6@Read
$LN5@Read:
	mov	ecx, DWORD PTR _iI$218310[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$218310[ebp], ecx
$LN6@Read:
	mov	edx, DWORD PTR _iI$218310[ebp]
	cmp	edx, DWORD PTR _iNumEntries$[ebp]
	jge	$LN7@Read

; 1229 : 	{
; 1230 : 		uint uiHash;
; 1231 : 		kStream >> uiHash;

	lea	eax, DWORD PTR _uiHash$218314[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 1232 : 		if (uiHash != 0 && uiHash != (uint)NO_IMPROVEMENT)

	cmp	DWORD PTR _uiHash$218314[ebp], 0
	je	$LN3@Read
	cmp	DWORD PTR _uiHash$218314[ebp], -1
	je	$LN3@Read

; 1233 : 		{
; 1234 : 			int iType = GC.getInfoTypeForHash(uiHash);

	push	0
	mov	ecx, DWORD PTR _uiHash$218314[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForHash@CvGlobals@@QBEHI_N@Z ; CvGlobals::getInfoTypeForHash
	mov	DWORD PTR _iType$218317[ebp], eax

; 1235 : 			if(iType != -1 && iType < iArraySize)

	cmp	DWORD PTR _iType$218317[ebp], -1
	je	SHORT $LN2@Read
	mov	edx, DWORD PTR _iType$218317[ebp]
	cmp	edx, DWORD PTR _iArraySize$[ebp]
	jge	SHORT $LN2@Read

; 1236 : 			{
; 1237 : 				kStream >> paiImprovementArray[iType];

	mov	eax, DWORD PTR _iType$218317[ebp]
	mov	ecx, DWORD PTR _paiImprovementArray$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1238 : 			}
; 1239 : 			else

	jmp	SHORT $LN3@Read
$LN2@Read:

; 1240 : 			{
; 1241 : 				CvString szError;

	lea	ecx, DWORD PTR _szError$218320[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1242 : 				szError.Format("LOAD ERROR: Improvement Type not found");

	push	OFFSET ??_C@_0CH@DGBBDFBA@LOAD?5ERROR?3?5Improvement?5Type?5not@
	lea	eax, DWORD PTR _szError$218320[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 1243 : 				GC.LogMessage(szError.GetCString());

	lea	ecx, DWORD PTR _szError$218320[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?LogMessage@CvGlobals@@QAEXPBD@Z	; CvGlobals::LogMessage

; 1244 : 				CvAssertMsg(false, szError);
; 1245 : 
; 1246 : 				int iDummy;
; 1247 : 				kStream >> iDummy;

	lea	ecx, DWORD PTR _iDummy$218322[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1248 : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _szError$218320[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN3@Read:

; 1249 : 		}

	jmp	$LN5@Read
$LN7@Read:

; 1250 : 	}
; 1251 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Read@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAH@Z$0:
	lea	ecx, DWORD PTR _szError$218320[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?Read@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-60]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Read@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Read@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAH@Z ENDP ; ImprovementArrayHelpers::Read
PUBLIC	?Write@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAHH@Z ; ImprovementArrayHelpers::Write
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@PBVCvBaseInfo@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
EXTRN	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z:PROC ; CvGlobals::getImprovementInfo
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
; Function compile flags: /Odtp
;	COMDAT ?Write@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAHH@Z
_TEXT	SEGMENT
$T220046 = -16						; size = 4
_pkImprovementInfo$218334 = -12				; size = 4
_eImprovement$218332 = -8				; size = 4
_iI$218328 = -4						; size = 4
_kStream$ = 8						; size = 4
_paiImprovementArray$ = 12				; size = 4
_iArraySize$ = 16					; size = 4
?Write@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAHH@Z PROC ; ImprovementArrayHelpers::Write, COMDAT

; 1255 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1256 : 	kStream << iArraySize;

	lea	eax, DWORD PTR _iArraySize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1257 : 
; 1258 : 	for(int iI = 0; iI < iArraySize; iI++)

	mov	DWORD PTR _iI$218328[ebp], 0
	jmp	SHORT $LN5@Write
$LN4@Write:
	mov	ecx, DWORD PTR _iI$218328[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$218328[ebp], ecx
$LN5@Write:
	mov	edx, DWORD PTR _iI$218328[ebp]
	cmp	edx, DWORD PTR _iArraySize$[ebp]
	jge	SHORT $LN6@Write

; 1259 : 	{
; 1260 : 		const ImprovementTypes eImprovement = static_cast<ImprovementTypes>(iI);

	mov	eax, DWORD PTR _iI$218328[ebp]
	mov	DWORD PTR _eImprovement$218332[ebp], eax

; 1261 : 		CvImprovementEntry* pkImprovementInfo = GC.getImprovementInfo(eImprovement);

	mov	ecx, DWORD PTR _eImprovement$218332[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	DWORD PTR _pkImprovementInfo$218334[ebp], eax

; 1262 : 		if(pkImprovementInfo)

	cmp	DWORD PTR _pkImprovementInfo$218334[ebp], 0
	je	SHORT $LN2@Write

; 1263 : 		{
; 1264 : 			CvInfosSerializationHelper::WriteHashed(kStream, pkImprovementInfo);

	mov	edx, DWORD PTR _pkImprovementInfo$218334[ebp]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@PBVCvBaseInfo@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8

; 1265 : 			kStream << paiImprovementArray[iI];

	mov	ecx, DWORD PTR _iI$218328[ebp]
	mov	edx, DWORD PTR _paiImprovementArray$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1266 : 		}
; 1267 : 		else

	jmp	SHORT $LN1@Write
$LN2@Write:

; 1268 : 		{
; 1269 : 			kStream << (int)NO_IMPROVEMENT;

	mov	DWORD PTR $T220046[ebp], -1
	lea	ecx, DWORD PTR $T220046[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
$LN1@Write:

; 1270 : 		}

	jmp	SHORT $LN4@Write
$LN6@Write:

; 1271 : 	}
; 1272 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Write@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAHH@Z ENDP ; ImprovementArrayHelpers::Write
_TEXT	ENDS
PUBLIC	??_C@_0CN@JNHPHMJM@LOAD?5ERROR?3?5Improvement?5Type?5not@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?ReadYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z ; ImprovementArrayHelpers::ReadYieldArray
;	COMDAT ??_C@_0CN@JNHPHMJM@LOAD?5ERROR?3?5Improvement?5Type?5not@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0CN@JNHPHMJM@LOAD?5ERROR?3?5Improvement?5Type?5not@ DB 'LOAD ERROR:'
	DB	' Improvement Type not found: %08x', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ReadYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ReadYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z$0
__ehfuncinfo$?ReadYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ReadYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvimprovementclasses.cpp
xdata$x	ENDS
;	COMDAT ?ReadYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z
_TEXT	SEGMENT
$T220069 = -76						; size = 4
_iDummy$218365 = -72					; size = 4
_jJ$218361 = -68					; size = 4
_szError$218359 = -64					; size = 28
__$ArrayPad$ = -36					; size = 4
_jJ$218354 = -32					; size = 4
_iType$218352 = -28					; size = 4
_iHash$218349 = -24					; size = 4
_iI$218345 = -20					; size = 4
_iNumEntries$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_kStream$ = 8						; size = 4
_ppaaiImprovementYieldArray$ = 12			; size = 4
_iNumYields$ = 16					; size = 4
?ReadYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z PROC ; ImprovementArrayHelpers::ReadYieldArray, COMDAT

; 1276 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ReadYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1277 : 	int iNumEntries;
; 1278 : 
; 1279 : 	kStream >> iNumEntries;

	lea	eax, DWORD PTR _iNumEntries$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1280 : 
; 1281 : 	for(int iI = 0; iI < iNumEntries; iI++)

	mov	DWORD PTR _iI$218345[ebp], 0
	jmp	SHORT $LN12@ReadYieldA
$LN11@ReadYieldA:
	mov	ecx, DWORD PTR _iI$218345[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$218345[ebp], ecx
$LN12@ReadYieldA:
	mov	edx, DWORD PTR _iI$218345[ebp]
	cmp	edx, DWORD PTR _iNumEntries$[ebp]
	jge	$LN13@ReadYieldA

; 1282 : 	{
; 1283 : 		int iHash;
; 1284 : 		kStream >> iHash;

	lea	eax, DWORD PTR _iHash$218349[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1285 : 		if(iHash != (int)0)

	cmp	DWORD PTR _iHash$218349[ebp], 0
	je	$LN9@ReadYieldA

; 1286 : 		{
; 1287 : 			int iType = GC.getInfoTypeForHash(iHash);

	push	0
	mov	ecx, DWORD PTR _iHash$218349[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForHash@CvGlobals@@QBEHI_N@Z ; CvGlobals::getInfoTypeForHash
	mov	DWORD PTR _iType$218352[ebp], eax

; 1288 : 			if(iType != -1)

	cmp	DWORD PTR _iType$218352[ebp], -1
	je	SHORT $LN8@ReadYieldA

; 1289 : 			{
; 1290 : 				for(int jJ = 0; jJ < iNumYields; jJ++)

	mov	DWORD PTR _jJ$218354[ebp], 0
	jmp	SHORT $LN7@ReadYieldA
$LN6@ReadYieldA:
	mov	edx, DWORD PTR _jJ$218354[ebp]
	add	edx, 1
	mov	DWORD PTR _jJ$218354[ebp], edx
$LN7@ReadYieldA:
	mov	eax, DWORD PTR _jJ$218354[ebp]
	cmp	eax, DWORD PTR _iNumYields$[ebp]
	jge	SHORT $LN5@ReadYieldA

; 1291 : 				{
; 1292 : 					kStream >> ppaaiImprovementYieldArray[iType][jJ];

	mov	ecx, DWORD PTR _iType$218352[ebp]
	mov	edx, DWORD PTR _ppaaiImprovementYieldArray$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _jJ$218354[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T220069[ebp], edx
	mov	eax, DWORD PTR $T220069[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1293 : 				}

	jmp	SHORT $LN6@ReadYieldA
$LN5@ReadYieldA:

; 1294 : 			}
; 1295 : 			else

	jmp	SHORT $LN9@ReadYieldA
$LN8@ReadYieldA:

; 1296 : 			{
; 1297 : 				CvString szError;

	lea	ecx, DWORD PTR _szError$218359[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1298 : 				szError.Format("LOAD ERROR: Improvement Type not found: %08x", iHash);

	mov	ecx, DWORD PTR _iHash$218349[ebp]
	push	ecx
	push	OFFSET ??_C@_0CN@JNHPHMJM@LOAD?5ERROR?3?5Improvement?5Type?5not@
	lea	edx, DWORD PTR _szError$218359[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 1299 : 				GC.LogMessage(szError.GetCString());

	lea	ecx, DWORD PTR _szError$218359[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?LogMessage@CvGlobals@@QAEXPBD@Z	; CvGlobals::LogMessage

; 1300 : 				CvAssertMsg(false, szError);
; 1301 : 
; 1302 : 				for(int jJ = 0; jJ < iNumYields; jJ++)

	mov	DWORD PTR _jJ$218361[ebp], 0
	jmp	SHORT $LN3@ReadYieldA
$LN2@ReadYieldA:
	mov	eax, DWORD PTR _jJ$218361[ebp]
	add	eax, 1
	mov	DWORD PTR _jJ$218361[ebp], eax
$LN3@ReadYieldA:
	mov	ecx, DWORD PTR _jJ$218361[ebp]
	cmp	ecx, DWORD PTR _iNumYields$[ebp]
	jge	SHORT $LN1@ReadYieldA

; 1303 : 				{
; 1304 : 					int iDummy;
; 1305 : 					kStream >> iDummy;

	lea	edx, DWORD PTR _iDummy$218365[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1306 : 				}

	jmp	SHORT $LN2@ReadYieldA
$LN1@ReadYieldA:

; 1307 : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _szError$218359[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN9@ReadYieldA:

; 1308 : 		}

	jmp	$LN11@ReadYieldA
$LN13@ReadYieldA:

; 1309 : 	}
; 1310 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ReadYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z$0:
	lea	ecx, DWORD PTR _szError$218359[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ReadYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-68]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ReadYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ReadYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z ENDP ; ImprovementArrayHelpers::ReadYieldArray
PUBLIC	?WriteYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z ; ImprovementArrayHelpers::WriteYieldArray
; Function compile flags: /Odtp
;	COMDAT ?WriteYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z
_TEXT	SEGMENT
$T220099 = -24						; size = 4
$T220092 = -20						; size = 4
_jJ$218379 = -16					; size = 4
_pkImprovementInfo$218377 = -12				; size = 4
_eImprovement$218375 = -8				; size = 4
_iI$218371 = -4						; size = 4
_kStream$ = 8						; size = 4
_ppaaiImprovementYieldArray$ = 12			; size = 4
_iArraySize$ = 16					; size = 4
?WriteYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z PROC ; ImprovementArrayHelpers::WriteYieldArray, COMDAT

; 1314 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1315 : 	kStream << iArraySize;

	lea	eax, DWORD PTR _iArraySize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1316 : 
; 1317 : 	for(int iI = 0; iI < iArraySize; iI++)

	mov	DWORD PTR _iI$218371[ebp], 0
	jmp	SHORT $LN8@WriteYield
$LN7@WriteYield:
	mov	ecx, DWORD PTR _iI$218371[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$218371[ebp], ecx
$LN8@WriteYield:
	mov	edx, DWORD PTR _iI$218371[ebp]
	cmp	edx, DWORD PTR _iArraySize$[ebp]
	jge	SHORT $LN9@WriteYield

; 1318 : 	{
; 1319 : 		const ImprovementTypes eImprovement = static_cast<ImprovementTypes>(iI);

	mov	eax, DWORD PTR _iI$218371[ebp]
	mov	DWORD PTR _eImprovement$218375[ebp], eax

; 1320 : 		CvImprovementEntry* pkImprovementInfo = GC.getImprovementInfo(eImprovement);

	mov	ecx, DWORD PTR _eImprovement$218375[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	DWORD PTR _pkImprovementInfo$218377[ebp], eax

; 1321 : 		if(pkImprovementInfo)

	cmp	DWORD PTR _pkImprovementInfo$218377[ebp], 0
	je	SHORT $LN5@WriteYield

; 1322 : 		{
; 1323 : 			CvInfosSerializationHelper::WriteHashed(kStream, pkImprovementInfo);

	mov	edx, DWORD PTR _pkImprovementInfo$218377[ebp]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@PBVCvBaseInfo@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8

; 1324 : 			for(int jJ = 0; jJ < NUM_YIELD_TYPES; jJ++)

	mov	DWORD PTR _jJ$218379[ebp], 0
	jmp	SHORT $LN4@WriteYield
$LN3@WriteYield:
	mov	ecx, DWORD PTR _jJ$218379[ebp]
	add	ecx, 1
	mov	DWORD PTR _jJ$218379[ebp], ecx
$LN4@WriteYield:
	cmp	DWORD PTR _jJ$218379[ebp], 6
	jge	SHORT $LN2@WriteYield

; 1325 : 			{
; 1326 : 				kStream << ppaaiImprovementYieldArray[iI][jJ];

	mov	edx, DWORD PTR _iI$218371[ebp]
	mov	eax, DWORD PTR _ppaaiImprovementYieldArray$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _jJ$218379[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T220099[ebp], eax
	mov	ecx, DWORD PTR $T220099[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1327 : 			}

	jmp	SHORT $LN3@WriteYield
$LN2@WriteYield:

; 1328 : 		}
; 1329 : 		else

	jmp	SHORT $LN1@WriteYield
$LN5@WriteYield:

; 1330 : 		{
; 1331 : 			kStream << (int)0;

	mov	DWORD PTR $T220092[ebp], 0
	lea	edx, DWORD PTR $T220092[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
$LN1@WriteYield:

; 1332 : 		}

	jmp	$LN7@WriteYield
$LN9@WriteYield:

; 1333 : 	}
; 1334 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?WriteYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z ENDP ; ImprovementArrayHelpers::WriteYieldArray
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::~vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@IAEXXZ ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::~vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >
; Function compile flags: /Odtp
;	COMDAT ??1?$_Vector_val@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::~_Vector_val<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::~_Vector_val<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvImprovementEntry@@PAPAV1@@stdext@@YAPAPAVCvImprovementEntry@@PAPAV1@00@Z ; stdext::unchecked_copy<CvImprovementEntry * *,CvImprovementEntry * *>
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T220257 = -52						; size = 4
$T220246 = -48						; size = 4
$T220245 = -44						; size = 4
__Cat$220252 = -40					; size = 1
$T220249 = -39						; size = 1
__Ptr$218436 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@2@0@Z PROC ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@erase

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$unchecked_copy@PAPAVCvImprovementEntry@@PAPAV1@@stdext@@YAPAPAVCvImprovementEntry@@PAPAV1@00@Z ; stdext::unchecked_copy<CvImprovementEntry * *,CvImprovementEntry * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$218436[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T220257[ebp], edx
	mov	eax, DWORD PTR $T220257[ebp]
	mov	DWORD PTR $T220246[ebp], eax
	mov	ecx, DWORD PTR __Ptr$218436[ebp]
	mov	DWORD PTR $T220245[ebp], ecx
	mov	dl, BYTE PTR __Cat$220252[ebp]
	mov	BYTE PTR $T220249[ebp], dl

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$218436[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN1@erase:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@2@0@Z ENDP ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::erase
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvImprovementEntry@@@std@@YAPAPAVCvImprovementEntry@@IPAPAV1@@Z ; std::_Allocate<CvImprovementEntry *>
PUBLIC	?_Xlen@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@KAXXZ ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$220274 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy
	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$220274[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$220274[ebp], 0
	jbe	SHORT $LN11@Buy
	mov	eax, DWORD PTR __Count$220274[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy
$LN11@Buy:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@KAXXZ ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@PAVCvImprovementEntry@@@std@@YAPAPAVCvImprovementEntry@@IPAPAV1@@Z ; std::_Allocate<CvImprovementEntry *>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T220338 = -28						; size = 4
$T220337 = -24						; size = 4
$T220333 = -20						; size = 4
$T220332 = -16						; size = 4
$T220321 = -12						; size = 4
$T220320 = -8						; size = 4
__Cat$220327 = -2					; size = 1
$T220324 = -1						; size = 1
?_Tidy@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@IAEXXZ PROC ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T220333[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T220332[ebp], ecx
	mov	edx, DWORD PTR $T220333[ebp]
	mov	DWORD PTR $T220321[ebp], edx
	mov	eax, DWORD PTR $T220332[ebp]
	mov	DWORD PTR $T220320[ebp], eax
	mov	cl, BYTE PTR __Cat$220327[ebp]
	mov	BYTE PTR $T220324[ebp], cl

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR $T220338[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T220337[ebp], eax
	mov	ecx, DWORD PTR $T220337[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::_Tidy
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_Elength_error@std@@UAEPAXI@Z ; std::length_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_Elogic_error@std@@UAEPAXI@Z ; std::logic_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T220342 = -80						; size = 28
$T220341 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@KAXXZ PROC ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T220342[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T220341[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T220341[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T220342[ebp]
	push	eax
	lea	ecx, DWORD PTR $T220341[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T220341[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T220341[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T220342[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T220342[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T220341[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@KAXXZ ENDP ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::_Xlen
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 34   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 36   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@

; 110  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	edx, DWORD PTR ___flags$[ebp]
	and	edx, 1
	je	SHORT $LN1@scalar@2
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVCvImprovementEntry@@PAPAV1@@stdext@@YAPAPAVCvImprovementEntry@@PAPAV1@00@Z
_TEXT	SEGMENT
$T220405 = -26						; size = 1
$T220404 = -25						; size = 1
$T220403 = -24						; size = 4
$T220402 = -20						; size = 4
__Off$220399 = -16					; size = 4
__Result$220400 = -12					; size = 4
__Cat$220391 = -4					; size = 1
$T220387 = -3						; size = 1
$T220386 = -2						; size = 1
$T220385 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvImprovementEntry@@PAPAV1@@stdext@@YAPAPAVCvImprovementEntry@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvImprovementEntry * *,CvImprovementEntry * *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T220385[ebp], al
	mov	cl, BYTE PTR __Cat$220391[ebp]
	mov	BYTE PTR $T220386[ebp], cl
	mov	dl, BYTE PTR $T220385[ebp]
	mov	BYTE PTR $T220405[ebp], dl
	mov	al, BYTE PTR $T220387[ebp]
	mov	BYTE PTR $T220404[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T220403[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T220402[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR $T220402[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$220399[ebp], eax
	mov	ecx, DWORD PTR __Off$220399[ebp]
	mov	edx, DWORD PTR $T220403[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$220400[ebp], eax
	cmp	DWORD PTR __Off$220399[ebp], 0
	jle	SHORT $LN8@unchecked_
	mov	ecx, DWORD PTR __Off$220399[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR $T220402[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$220399[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR $T220403[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_:
	mov	eax, DWORD PTR __Result$220400[ebp]

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAPAVCvImprovementEntry@@PAPAV1@@stdext@@YAPAPAVCvImprovementEntry@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvImprovementEntry * *,CvImprovementEntry * *>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R0?AVbad_alloc@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
xdata$x	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_Ebad_alloc@std@@UAEPAXI@Z ; std::bad_alloc::`vftable'
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
CONST	ENDS
;	COMDAT ??$_Allocate@PAVCvImprovementEntry@@@std@@YAPAPAVCvImprovementEntry@@IPAPAV1@@Z
_TEXT	SEGMENT
$T220412 = -16						; size = 4
$T220408 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvImprovementEntry@@@std@@YAPAPAVCvImprovementEntry@@IPAPAV1@@Z PROC ; std::_Allocate<CvImprovementEntry *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T220412[ebp], 0
	lea	eax, DWORD PTR $T220412[ebp]
	push	eax
	lea	ecx, DWORD PTR $T220408[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T220408[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T220408[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVCvImprovementEntry@@@std@@YAPAPAVCvImprovementEntry@@IPAPAV1@@Z ENDP ; std::_Allocate<CvImprovementEntry *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar@3
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -48						; size = 28
__$ArrayPad$ = -20					; size = 4
_args$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 2124				; 0000084cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);

	lea	eax, DWORD PTR _lpszFormat$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _args$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpszFormat$[ebp]
	push	edx
	lea	eax, DWORD PTR _result$[ebp]
	push	eax
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);

	mov	DWORD PTR _args$[ebp], 0

; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-2128]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	__$ArrayPad$
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	__imp___vsnprintf:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
tv74 = -2096						; size = 4
$T220460 = -2092					; size = 4
$T220459 = -2088					; size = 4
$T220458 = -2084					; size = 4
_maxlen$95294 = -2080					; size = 4
_kMaxAttempts$ = -2076					; size = 4
_buf$ = -2072						; size = 2048
__$ArrayPad$ = -20					; size = 4
_len$ = -16						; size = 4
_attempts$ = -12					; size = 4
_success$ = -5						; size = 1
_pbuf$ = -4						; size = 4
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2096				; 00000830H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	lea	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _pbuf$[ebp], eax

; 194  : 	int len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 195  : 	int attempts = 0;

	mov	DWORD PTR _attempts$[ebp], 0

; 196  : 	bool success = false;

	mov	BYTE PTR _success$[ebp], 0

; 197  : 	const int kMaxAttempts = 40;

	mov	DWORD PTR _kMaxAttempts$[ebp], 40	; 00000028H
$LN10@formatv:

; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;

	mov	ecx, DWORD PTR _attempts$[ebp]
	shl	ecx, 11					; 0000000bH
	add	ecx, 2047				; 000007ffH
	mov	DWORD PTR _maxlen$95294[ebp], ecx

; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	edx, DWORD PTR _args$[ebp]
	push	edx
	mov	eax, DWORD PTR _fmt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _maxlen$95294[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbuf$[ebp]
	push	edx
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR _len$[ebp], eax

; 203  : 		attempts++;

	mov	eax, DWORD PTR _attempts$[ebp]
	add	eax, 1
	mov	DWORD PTR _attempts$[ebp], eax

; 204  : 		success = (len>=0 && len<=maxlen);

	cmp	DWORD PTR _len$[ebp], 0
	jl	SHORT $LN13@formatv
	mov	ecx, DWORD PTR _len$[ebp]
	cmp	ecx, DWORD PTR _maxlen$95294[ebp]
	jg	SHORT $LN13@formatv
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN14@formatv
$LN13@formatv:
	mov	DWORD PTR tv74[ebp], 0
$LN14@formatv:
	mov	dl, BYTE PTR tv74[ebp]
	mov	BYTE PTR _success$[ebp], dl

; 205  : 		if (!success)

	movzx	eax, BYTE PTR _success$[ebp]
	test	eax, eax
	jne	SHORT $LN9@formatv

; 206  : 		{
; 207  : 			if (pbuf!=buf)

	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, edx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T220458[ebp], eax
	mov	ecx, DWORD PTR $T220458[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	mov	edx, DWORD PTR _attempts$[ebp]
	shl	edx, 11					; 0000000bH
	add	edx, 2048				; 00000800H
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T220459[ebp], eax
	mov	eax, DWORD PTR $T220459[ebp]
	mov	DWORD PTR _pbuf$[ebp], eax
$LN9@formatv:

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	movzx	ecx, BYTE PTR _success$[ebp]
	test	ecx, ecx
	jne	SHORT $LN4@formatv
	cmp	DWORD PTR _attempts$[ebp], 40		; 00000028H
	jl	$LN10@formatv
$LN4@formatv:

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)

	movzx	edx, BYTE PTR _success$[ebp]
	test	edx, edx
	je	SHORT $LN3@formatv

; 220  : 		out = pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 221  : 	else

	jmp	SHORT $LN2@formatv
$LN3@formatv:

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN2@formatv:

; 223  : 
; 224  : 	if (pbuf!=buf)

	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, edx
	je	SHORT $LN1@formatv

; 225  : 		delete [] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T220460[ebp], eax
	mov	ecx, DWORD PTR $T220460[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN1@formatv:

; 226  : 
; 227  : 	return success;

	mov	al, BYTE PTR _success$[ebp]

; 228  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
EXTRN	_memset:PROC
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdatabaseutility.h
;	COMDAT ?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T220463 = -8						; size = 4
_i$172577 = -4						; size = 4
_pArray$ = 8						; size = 4
_count$ = 12						; size = 4
_iDefault$ = 16						; size = 4
?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z PROC	; CvDatabaseUtility::InitializeArray, COMDAT
; _this$ = ecx

; 120  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 121  : 	CvAssertMsg(count > 0, "Initializing array to 0 or less items.");
; 122  : #ifdef AUI_WARNING_FIXES
; 123  : 	delete[] pArray;
; 124  : #endif
; 125  : 	pArray = FNEW(int[count], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	eax, DWORD PTR _count$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T220463[ebp], eax
	mov	eax, DWORD PTR _pArray$[ebp]
	mov	ecx, DWORD PTR $T220463[ebp]
	mov	DWORD PTR [eax], ecx

; 126  : 	if(iDefault == 0)

	cmp	DWORD PTR _iDefault$[ebp], 0
	jne	SHORT $LN5@Initialize

; 127  : 	{
; 128  : 		ZeroMemory(pArray, sizeof(int) * count);

	mov	edx, DWORD PTR _count$[ebp]
	shl	edx, 2
	push	edx
	push	0
	mov	eax, DWORD PTR _pArray$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 129  : 	}
; 130  : 	else

	jmp	SHORT $LN6@Initialize
$LN5@Initialize:

; 131  : 	{
; 132  : 		for(size_t i = 0; i < count; ++i)

	mov	DWORD PTR _i$172577[ebp], 0
	jmp	SHORT $LN3@Initialize
$LN2@Initialize:
	mov	edx, DWORD PTR _i$172577[ebp]
	add	edx, 1
	mov	DWORD PTR _i$172577[ebp], edx
$LN3@Initialize:
	mov	eax, DWORD PTR _i$172577[ebp]
	cmp	eax, DWORD PTR _count$[ebp]
	jae	SHORT $LN6@Initialize

; 133  : 			pArray[i] = iDefault;

	mov	ecx, DWORD PTR _pArray$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _i$172577[ebp]
	mov	ecx, DWORD PTR _iDefault$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx
	jmp	SHORT $LN2@Initialize
$LN6@Initialize:

; 134  : 	}
; 135  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z ENDP	; CvDatabaseUtility::InitializeArray
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0length_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
; Function compile flags: /Odtp
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
END
