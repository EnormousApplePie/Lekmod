; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvTargeting.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_ms_LookBackX DD 00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	01H
_ms_LookBackY DD 0ffffffffH
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	0ffffffffH
_ms_HexDirection DD 00H
	DD	04H
	DD	05H
	DD	03H
	DD	00H
	DD	00H
	DD	02H
	DD	01H
	DD	00H
_DATA	ENDS
PUBLIC	?GetLastTargetingPathIndex@@YAHH@Z		; GetLastTargetingPathIndex
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtargeting.cpp
;	COMDAT ?GetLastTargetingPathIndex@@YAHH@Z
_TEXT	SEGMENT
_plotIndex$ = 8						; size = 4
?GetLastTargetingPathIndex@@YAHH@Z PROC			; GetLastTargetingPathIndex, COMDAT

; 35   : {

	push	ebp
	mov	ebp, esp

; 36   : #if defined(TARGETING_DEBUG)
; 37   : 	int iIndex = 0;
; 38   : 	for (std::vector<int>::const_iterator itr = ms_lastTargetingPath.begin(); itr != ms_lastTargetingPath.end(); ++itr)
; 39   : 	{
; 40   : 		if ((*itr) == plotIndex)
; 41   : 			return iIndex;
; 42   : 		++iIndex;
; 43   : 	}
; 44   : #else
; 45   : 	UNREFERENCED_PARAMETER(plotIndex);
; 46   : #endif
; 47   : 
; 48   : 	return -1;

	or	eax, -1

; 49   : }

	pop	ebp
	ret	0
?GetLastTargetingPathIndex@@YAHH@Z ENDP			; GetLastTargetingPathIndex
_TEXT	ENDS
PUBLIC	?hexDistance@@YAHHH@Z				; hexDistance
PUBLIC	?PlotFromHex@@YAPAVCvPlot@@AAVCvMap@@HH@Z	; PlotFromHex
PUBLIC	?CanSeeDisplacementPlot@CvTargeting@@SA_NHHHHH@Z ; CvTargeting::CanSeeDisplacementPlot
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Odtp
;	COMDAT ?CanSeeDisplacementPlot@CvTargeting@@SA_NHHHHH@Z
_TEXT	SEGMENT
tv129 = -76						; size = 4
_iHexDistanceBetweenPlots$217285 = -12			; size = 4
_kMap$ = -8						; size = 4
_pPlot$ = -4						; size = 4
_startX$ = 8						; size = 4
_startY$ = 12						; size = 4
_dx$ = 16						; size = 4
_dy$ = 20						; size = 4
_fromLevel$ = 24					; size = 4
?CanSeeDisplacementPlot@CvTargeting@@SA_NHHHHH@Z PROC	; CvTargeting::CanSeeDisplacementPlot, COMDAT

; 628  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH

; 629  : 	CLEAR_TARGET_PATH_DEBUG;
; 630  : 
; 631  : 	// convert the start coord to hex-space coordinates
; 632  : 	// No need to convert the Y coord, it is the same in both systems
; 633  : 	startX = xToHexspaceX(startX, startY);

	cmp	DWORD PTR _startY$[ebp], 0
	jl	SHORT $LN9@CanSeeDisp
	mov	eax, DWORD PTR _startY$[ebp]
	sar	eax, 1
	mov	DWORD PTR tv129[ebp], eax
	jmp	SHORT $LN7@CanSeeDisp
$LN9@CanSeeDisp:
	mov	eax, DWORD PTR _startY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv129[ebp], eax
$LN7@CanSeeDisp:
	mov	ecx, DWORD PTR _startX$[ebp]
	sub	ecx, DWORD PTR tv129[ebp]
	mov	DWORD PTR _startX$[ebp], ecx

; 634  : 
; 635  : 	CvMap& kMap = GC.getMap();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], edx

; 636  : 	CvPlot* pPlot = PlotFromHex(kMap, startX + dx, startY + dy);

	mov	eax, DWORD PTR _startY$[ebp]
	add	eax, DWORD PTR _dy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _startX$[ebp]
	add	ecx, DWORD PTR _dx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _kMap$[ebp]
	push	edx
	call	?PlotFromHex@@YAPAVCvPlot@@AAVCvMap@@HH@Z ; PlotFromHex
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pPlot$[ebp], eax

; 637  : 	if(pPlot != NULL)

	cmp	DWORD PTR _pPlot$[ebp], 0
	je	SHORT $LN4@CanSeeDisp

; 638  : 	{
; 639  : 		int iHexDistanceBetweenPlots = hexDistance(dx, dy);

	mov	eax, DWORD PTR _dy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dx$[ebp]
	push	ecx
	call	?hexDistance@@YAHHH@Z			; hexDistance
	add	esp, 8
	mov	DWORD PTR _iHexDistanceBetweenPlots$217285[ebp], eax

; 640  : 		// assume that we can always see our plot and the plot next door
; 641  : 		if(iHexDistanceBetweenPlots <= 1)

	cmp	DWORD PTR _iHexDistanceBetweenPlots$217285[ebp], 1
	jg	SHORT $LN3@CanSeeDisp

; 642  : 			return true;

	mov	al, 1
	jmp	SHORT $LN5@CanSeeDisp
$LN3@CanSeeDisp:

; 643  : 
; 644  : 		// If over STRICT_LOOSE_CUTOFF away, any blockage past the STRICT_LOOSE_CUTOFF will result in not being able to target.
; 645  : 		if (iHexDistanceBetweenPlots > STRICT_LOOSE_CUTOFF /*&& GC.getGame().isOption("STRICT_RANGE_TARGETING")*/)

	cmp	DWORD PTR _iHexDistanceBetweenPlots$217285[ebp], 2
	jle	SHORT $LN2@CanSeeDisp

; 646  : 			return CanSeeDisplacementPlot_Strict(startX, startY, dx, dy, fromLevel);

	mov	edx, DWORD PTR _fromLevel$[ebp]
	push	edx
	mov	eax, DWORD PTR _dy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _startY$[ebp]
	push	edx
	mov	eax, DWORD PTR _startX$[ebp]
	push	eax
	call	?CanSeeDisplacementPlot_Strict@@YA_NHHHHH@Z ; CanSeeDisplacementPlot_Strict
	add	esp, 20					; 00000014H
	jmp	SHORT $LN5@CanSeeDisp

; 647  : 		else

	jmp	SHORT $LN4@CanSeeDisp
$LN2@CanSeeDisp:

; 648  : 			return CanSeeDisplacementPlot_Loose(startX, startY, dx, dy, fromLevel);

	mov	ecx, DWORD PTR _fromLevel$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dy$[ebp]
	push	edx
	mov	eax, DWORD PTR _dx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _startY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _startX$[ebp]
	push	edx
	call	?CanSeeDisplacementPlot_Loose@@YA_NHHHHH@Z ; CanSeeDisplacementPlot_Loose
	add	esp, 20					; 00000014H
	jmp	SHORT $LN5@CanSeeDisp
$LN4@CanSeeDisp:

; 649  : 
; 650  : 	}
; 651  : 
; 652  : 	return false;

	xor	al, al
$LN5@CanSeeDisp:

; 653  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CanSeeDisplacementPlot@CvTargeting@@SA_NHHHHH@Z ENDP	; CvTargeting::CanSeeDisplacementPlot
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
_TEXT	ENDS
;	COMDAT ?hexDistance@@YAHHH@Z
_TEXT	SEGMENT
tv83 = -36						; size = 4
tv81 = -32						; size = 4
tv78 = -28						; size = 4
tv74 = -24						; size = 4
tv71 = -20						; size = 4
_iAbsDY$216713 = -16					; size = 4
_iAbsDX$216712 = -12					; size = 4
_iAbsDY$216710 = -8					; size = 4
_iAbsDX$216709 = -4					; size = 4
_iDX$ = 8						; size = 4
_iDY$ = 12						; size = 4
?hexDistance@@YAHHH@Z PROC				; hexDistance, COMDAT

; 95   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 96   : 	// I'm assuming iDX and iDY are in hex-space
; 97   : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 98   : 	// Delnar: Using abs() because I trust the compiler to generate more efficient code than if I'd write an abs(int) function myself, especially if the CPU has an abs(int) operation
; 99   : 	if ((iDX ^ iDY) >= 0)  // the signs match
; 100  : 	{
; 101  : 		return abs(iDX) + abs(iDY);
; 102  : 	}
; 103  : 	else
; 104  : 	{
; 105  : 		return MAX(abs(iDX), abs(iDY));
; 106  : 	}
; 107  : #else
; 108  : 	if((iDX >= 0) == (iDY >= 0))  // the signs match

	xor	eax, eax
	cmp	DWORD PTR _iDX$[ebp], 0
	setge	al
	xor	ecx, ecx
	cmp	DWORD PTR _iDY$[ebp], 0
	setge	cl
	cmp	eax, ecx
	jne	SHORT $LN2@hexDistanc

; 109  : 	{
; 110  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	cmp	DWORD PTR _iDX$[ebp], 0
	jl	SHORT $LN5@hexDistanc
	mov	edx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv71[ebp], edx
	jmp	SHORT $LN6@hexDistanc
$LN5@hexDistanc:
	mov	eax, DWORD PTR _iDX$[ebp]
	neg	eax
	mov	DWORD PTR tv71[ebp], eax
$LN6@hexDistanc:
	mov	ecx, DWORD PTR tv71[ebp]
	mov	DWORD PTR _iAbsDX$216709[ebp], ecx

; 111  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	cmp	DWORD PTR _iDY$[ebp], 0
	jl	SHORT $LN7@hexDistanc
	mov	edx, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv74[ebp], edx
	jmp	SHORT $LN8@hexDistanc
$LN7@hexDistanc:
	mov	eax, DWORD PTR _iDY$[ebp]
	neg	eax
	mov	DWORD PTR tv74[ebp], eax
$LN8@hexDistanc:
	mov	ecx, DWORD PTR tv74[ebp]
	mov	DWORD PTR _iAbsDY$216710[ebp], ecx

; 112  : 		return iAbsDX + iAbsDY;

	mov	eax, DWORD PTR _iAbsDX$216709[ebp]
	add	eax, DWORD PTR _iAbsDY$216710[ebp]
	jmp	SHORT $LN3@hexDistanc

; 113  : 	}
; 114  : 	else

	jmp	SHORT $LN3@hexDistanc
$LN2@hexDistanc:

; 115  : 	{
; 116  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	cmp	DWORD PTR _iDX$[ebp], 0
	jl	SHORT $LN9@hexDistanc
	mov	edx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv78[ebp], edx
	jmp	SHORT $LN10@hexDistanc
$LN9@hexDistanc:
	mov	eax, DWORD PTR _iDX$[ebp]
	neg	eax
	mov	DWORD PTR tv78[ebp], eax
$LN10@hexDistanc:
	mov	ecx, DWORD PTR tv78[ebp]
	mov	DWORD PTR _iAbsDX$216712[ebp], ecx

; 117  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	cmp	DWORD PTR _iDY$[ebp], 0
	jl	SHORT $LN11@hexDistanc
	mov	edx, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv81[ebp], edx
	jmp	SHORT $LN12@hexDistanc
$LN11@hexDistanc:
	mov	eax, DWORD PTR _iDY$[ebp]
	neg	eax
	mov	DWORD PTR tv81[ebp], eax
$LN12@hexDistanc:
	mov	ecx, DWORD PTR tv81[ebp]
	mov	DWORD PTR _iAbsDY$216713[ebp], ecx

; 118  : 		return iAbsDX >= iAbsDY ? iAbsDX : iAbsDY;

	mov	edx, DWORD PTR _iAbsDX$216712[ebp]
	cmp	edx, DWORD PTR _iAbsDY$216713[ebp]
	jl	SHORT $LN13@hexDistanc
	mov	eax, DWORD PTR _iAbsDX$216712[ebp]
	mov	DWORD PTR tv83[ebp], eax
	jmp	SHORT $LN14@hexDistanc
$LN13@hexDistanc:
	mov	ecx, DWORD PTR _iAbsDY$216713[ebp]
	mov	DWORD PTR tv83[ebp], ecx
$LN14@hexDistanc:
	mov	eax, DWORD PTR tv83[ebp]
$LN3@hexDistanc:

; 119  : 	}
; 120  : #endif
; 121  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?hexDistance@@YAHHH@Z ENDP				; hexDistance
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?PlotFromHex@@YAPAVCvPlot@@AAVCvMap@@HH@Z
_TEXT	SEGMENT
tv137 = -56						; size = 4
tv152 = -52						; size = 4
tv75 = -48						; size = 4
$T217668 = -44						; size = 4
$T217667 = -40						; size = 4
$T217622 = -36						; size = 4
$T217609 = -32						; size = 4
$T217605 = -28						; size = 4
$T217591 = -24						; size = 4
$T217587 = -17						; size = 1
$T217576 = -16						; size = 4
$T217572 = -9						; size = 1
_iMapY$217666 = -8					; size = 4
_iMapX$217665 = -4					; size = 4
_kMap$ = 8						; size = 4
_iHexX$ = 12						; size = 4
_iHexY$ = 16						; size = 4
?PlotFromHex@@YAPAVCvPlot@@AAVCvMap@@HH@Z PROC		; PlotFromHex, COMDAT

; 227  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 228  : 	// NOTE: Y is the same in both hex space and grid space.
; 229  : 	return kMap.plot( hexspaceXToX(iHexX, iHexY), iHexY );	

	cmp	DWORD PTR _iHexY$[ebp], 0
	jl	SHORT $LN5@PlotFromHe
	mov	eax, DWORD PTR _iHexY$[ebp]
	sar	eax, 1
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN3@PlotFromHe
$LN5@PlotFromHe:
	mov	eax, DWORD PTR _iHexY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv75[ebp], eax
$LN3@PlotFromHe:
	mov	ecx, DWORD PTR _iHexX$[ebp]
	add	ecx, DWORD PTR tv75[ebp]
	mov	DWORD PTR $T217667[ebp], ecx
	cmp	DWORD PTR $T217667[ebp], -2147483647	; 80000001H
	je	SHORT $LN7@PlotFromHe
	cmp	DWORD PTR _iHexY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN8@PlotFromHe
$LN7@PlotFromHe:
	mov	DWORD PTR $T217668[ebp], 0
	jmp	$LN9@PlotFromHe
$LN8@PlotFromHe:
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T217572[ebp], al
	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T217576[ebp], edx
	movzx	eax, BYTE PTR $T217572[ebp]
	test	eax, eax
	je	SHORT $LN20@PlotFromHe
	cmp	DWORD PTR $T217667[ebp], 0
	jge	SHORT $LN19@PlotFromHe
	mov	eax, DWORD PTR $T217667[ebp]
	cdq
	idiv	DWORD PTR $T217576[ebp]
	add	edx, DWORD PTR $T217576[ebp]
	mov	DWORD PTR _iMapX$217665[ebp], edx
	jmp	SHORT $LN21@PlotFromHe
	jmp	SHORT $LN20@PlotFromHe
$LN19@PlotFromHe:
	mov	ecx, DWORD PTR $T217667[ebp]
	cmp	ecx, DWORD PTR $T217576[ebp]
	jl	SHORT $LN20@PlotFromHe
	mov	eax, DWORD PTR $T217667[ebp]
	cdq
	idiv	DWORD PTR $T217576[ebp]
	mov	DWORD PTR _iMapX$217665[ebp], edx
	jmp	SHORT $LN21@PlotFromHe
$LN20@PlotFromHe:
	mov	edx, DWORD PTR $T217667[ebp]
	mov	DWORD PTR _iMapX$217665[ebp], edx
$LN21@PlotFromHe:
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T217587[ebp], cl
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T217591[ebp], eax
	movzx	ecx, BYTE PTR $T217587[ebp]
	test	ecx, ecx
	je	SHORT $LN30@PlotFromHe
	cmp	DWORD PTR _iHexY$[ebp], 0
	jge	SHORT $LN29@PlotFromHe
	mov	eax, DWORD PTR _iHexY$[ebp]
	cdq
	idiv	DWORD PTR $T217591[ebp]
	add	edx, DWORD PTR $T217591[ebp]
	mov	DWORD PTR _iMapY$217666[ebp], edx
	jmp	SHORT $LN31@PlotFromHe
	jmp	SHORT $LN30@PlotFromHe
$LN29@PlotFromHe:
	mov	edx, DWORD PTR _iHexY$[ebp]
	cmp	edx, DWORD PTR $T217591[ebp]
	jl	SHORT $LN30@PlotFromHe
	mov	eax, DWORD PTR _iHexY$[ebp]
	cdq
	idiv	DWORD PTR $T217591[ebp]
	mov	DWORD PTR _iMapY$217666[ebp], edx
	jmp	SHORT $LN31@PlotFromHe
$LN30@PlotFromHe:
	mov	eax, DWORD PTR _iHexY$[ebp]
	mov	DWORD PTR _iMapY$217666[ebp], eax
$LN31@PlotFromHe:
	cmp	DWORD PTR _iMapX$217665[ebp], 0
	jl	SHORT $LN35@PlotFromHe
	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T217605[ebp], edx
	mov	eax, DWORD PTR _iMapX$217665[ebp]
	cmp	eax, DWORD PTR $T217605[ebp]
	jge	SHORT $LN35@PlotFromHe
	cmp	DWORD PTR _iMapY$217666[ebp], 0
	jl	SHORT $LN35@PlotFromHe
	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T217609[ebp], edx
	mov	eax, DWORD PTR _iMapY$217666[ebp]
	cmp	eax, DWORD PTR $T217609[ebp]
	jge	SHORT $LN35@PlotFromHe
	mov	DWORD PTR tv152[ebp], 1
	jmp	SHORT $LN33@PlotFromHe
$LN35@PlotFromHe:
	mov	DWORD PTR tv152[ebp], 0
$LN33@PlotFromHe:
	cmp	DWORD PTR tv152[ebp], 0
	je	SHORT $LN11@PlotFromHe
	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T217622[ebp], edx
	mov	eax, DWORD PTR _iMapY$217666[ebp]
	imul	eax, DWORD PTR $T217622[ebp]
	add	eax, DWORD PTR _iMapX$217665[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR _kMap$[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv137[ebp], eax
	jmp	SHORT $LN12@PlotFromHe
$LN11@PlotFromHe:
	mov	DWORD PTR tv137[ebp], 0
$LN12@PlotFromHe:
	mov	edx, DWORD PTR tv137[ebp]
	mov	DWORD PTR $T217668[ebp], edx
$LN9@PlotFromHe:
	mov	eax, DWORD PTR $T217668[ebp]

; 230  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PlotFromHex@@YAPAVCvPlot@@AAVCvMap@@HH@Z ENDP		; PlotFromHex
_TEXT	ENDS
EXTRN	?seeThroughLevel@CvPlot@@QBEH_N@Z:PROC		; CvPlot::seeThroughLevel
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtargeting.cpp
;	COMDAT ?CanSeeDisplacementPlot_Strict@@YA_NHHHHH@Z
_TEXT	SEGMENT
tv221 = -456						; size = 4
tv77 = -452						; size = 4
_passThroughPlot$217184 = -96				; size = 4
_passThroughPlot$217173 = -92				; size = 4
_passThroughPlot$217179 = -88				; size = 4
_passThroughPlot$217190 = -84				; size = 4
_shortAxisStepFactor$217165 = -80			; size = 4
_passThroughPlot$217155 = -76				; size = 4
_passThroughPlot$217144 = -72				; size = 4
_passThroughPlot$217150 = -68				; size = 4
_passThroughPlot$217161 = -64				; size = 4
_shortAxisStepFactor$217136 = -60			; size = 4
_kMap$ = -56						; size = 4
_straightThrough$ = -49					; size = 1
_stepY$ = -48						; size = 4
_currentDY$ = -44					; size = 4
_originalDY$ = -40					; size = 4
_originalDX$ = -36					; size = 4
_stepX$ = -32						; size = 4
_lastDY$ = -28						; size = 4
_lastDX$ = -24						; size = 4
_oddQuadrant$ = -17					; size = 1
_iBlockedCount$ = -16					; size = 4
_lookbackDirection$ = -12				; size = 4
_stepCount$ = -8					; size = 4
_currentDX$ = -4					; size = 4
_startX$ = 8						; size = 4
_startY$ = 12						; size = 4
_dx$ = 16						; size = 4
_dy$ = 20						; size = 4
_fromLevel$ = 24					; size = 4
?CanSeeDisplacementPlot_Strict@@YA_NHHHHH@Z PROC	; CanSeeDisplacementPlot_Strict, COMDAT

; 103  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 456				; 000001c8H

; 104  : 	int originalDX = dx;

	mov	eax, DWORD PTR _dx$[ebp]
	mov	DWORD PTR _originalDX$[ebp], eax

; 105  : 	int originalDY = dy;

	mov	ecx, DWORD PTR _dy$[ebp]
	mov	DWORD PTR _originalDY$[ebp], ecx

; 106  : 
; 107  : 	CvMap& kMap = GC.getMap();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], edx

; 108  : 
; 109  : 	// Use Bresenham's line algorithm, with a slight modification, to step through the cells.
; 110  : 	// The modification is that if we are stepping in the upper-right or lower-left quadrant,
; 111  : 	// and we need to take a step on the 'short' axis, we will check the plot with just the
; 112  : 	// adjustment to the X axis, before we do the normal check for the step on the X and Y
; 113  : 	// axis.  This is needed because in those quadrants a change on both the X and Y axis 
; 114  : 	// is not contiguous.
; 115  : 
; 116  : 	// Because the hex grid is low-resolution, checks are also made to allow the ray to continue 
; 117  : 	// around a blockage if that blockage obscures only part of the next hex cell along the ray.
; 118  : 	// This is done by 'looking back' at the alternate path the ray could have taken as it is 
; 119  : 	// traversing the hex grid.
; 120  : 
; 121  : 	// Make DX and DY positive and adjust the step constant for the opposite axis.
; 122  : #ifdef AUI_PLOT_VISIBILITY_OPTIMIZATIONS
; 123  : 	int stepY = 1;
; 124  : #else
; 125  : 	int stepY;
; 126  : #endif
; 127  : 	if (dy < 0) 

	cmp	DWORD PTR _dy$[ebp], 0
	jge	SHORT $LN50@CanSeeDisp@2

; 128  : 	{ 
; 129  : 		dy = -dy;  

	mov	eax, DWORD PTR _dy$[ebp]
	neg	eax
	mov	DWORD PTR _dy$[ebp], eax

; 130  : 		stepY = -1; 

	mov	DWORD PTR _stepY$[ebp], -1

; 131  : 	} 
; 132  : #ifdef AUI_PLOT_VISIBILITY_OPTIMIZATIONS
; 133  : 	int stepX = 1;
; 134  : #else
; 135  : 	else 

	jmp	SHORT $LN49@CanSeeDisp@2
$LN50@CanSeeDisp@2:

; 136  : 		stepY = 1; 

	mov	DWORD PTR _stepY$[ebp], 1
$LN49@CanSeeDisp@2:

; 137  : 
; 138  : 	int stepX;
; 139  : #endif
; 140  : 	if (dx < 0) 

	cmp	DWORD PTR _dx$[ebp], 0
	jge	SHORT $LN48@CanSeeDisp@2

; 141  : 	{ 
; 142  : 		dx = -dx;  

	mov	ecx, DWORD PTR _dx$[ebp]
	neg	ecx
	mov	DWORD PTR _dx$[ebp], ecx

; 143  : 		stepX = -1; 

	mov	DWORD PTR _stepX$[ebp], -1

; 144  : 	} 
; 145  : #ifndef AUI_PLOT_VISIBILITY_OPTIMIZATIONS
; 146  : 	else 

	jmp	SHORT $LN47@CanSeeDisp@2
$LN48@CanSeeDisp@2:

; 147  : 		stepX = 1;

	mov	DWORD PTR _stepX$[ebp], 1
$LN47@CanSeeDisp@2:

; 148  : #endif
; 149  : 
; 150  : 	dy <<= 1;

	mov	edx, DWORD PTR _dy$[ebp]
	shl	edx, 1
	mov	DWORD PTR _dy$[ebp], edx

; 151  : 	dx <<= 1;

	mov	eax, DWORD PTR _dx$[ebp]
	shl	eax, 1
	mov	DWORD PTR _dx$[ebp], eax

; 152  : 
; 153  : 	int currentDX = 0;

	mov	DWORD PTR _currentDX$[ebp], 0

; 154  : 	int currentDY = 0;

	mov	DWORD PTR _currentDY$[ebp], 0

; 155  : 
; 156  : 	// If in an odd quadrant, stepping down on the short axis requires two checks to be contiguous
; 157  : 	bool oddQuadrant = stepX != stepY;

	mov	ecx, DWORD PTR _stepX$[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR _stepY$[ebp]
	setne	dl
	mov	BYTE PTR _oddQuadrant$[ebp], dl

; 158  : 	// Is the line going to go such that it travels through the centers of the hexes?
; 159  : 	// If so, we don't have to worry about testing to see if we can look around blocked hexes.
; 160  : #ifdef AUI_PLOT_VISIBILITY_OPTIMIZATIONS
; 161  : 	bool straightThrough = dx == 0 || dy == 0 || (dx == dy && oddQuadrant);
; 162  : #else
; 163  : 	bool straightThrough = dx == 0 || dy == 0;

	cmp	DWORD PTR _dx$[ebp], 0
	je	SHORT $LN53@CanSeeDisp@2
	cmp	DWORD PTR _dy$[ebp], 0
	je	SHORT $LN53@CanSeeDisp@2
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN54@CanSeeDisp@2
$LN53@CanSeeDisp@2:
	mov	DWORD PTR tv77[ebp], 1
$LN54@CanSeeDisp@2:
	mov	al, BYTE PTR tv77[ebp]
	mov	BYTE PTR _straightThrough$[ebp], al

; 164  : #endif
; 165  : 
; 166  : 	// Start from the next cell after the source plot
; 167  : 	int lastDX = currentDX;

	mov	ecx, DWORD PTR _currentDX$[ebp]
	mov	DWORD PTR _lastDX$[ebp], ecx

; 168  : 	int lastDY = currentDY;

	mov	edx, DWORD PTR _currentDY$[ebp]
	mov	DWORD PTR _lastDY$[ebp], edx

; 169  : 	int lookbackDirection = -1;

	mov	DWORD PTR _lookbackDirection$[ebp], -1

; 170  : 	int stepCount = 0;

	mov	DWORD PTR _stepCount$[ebp], 0

; 171  : 	int iBlockedCount = 0;

	mov	DWORD PTR _iBlockedCount$[ebp], 0

; 172  : 
; 173  : 	// If dx is greater than dy, scan along the x axis, adjusting the Y as needed
; 174  : 	if (dx > dy) 

	mov	eax, DWORD PTR _dx$[ebp]
	cmp	eax, DWORD PTR _dy$[ebp]
	jle	$LN46@CanSeeDisp@2

; 175  : 	{
; 176  : 		int shortAxisStepFactor = (dx >> 1); 

	mov	ecx, DWORD PTR _dx$[ebp]
	sar	ecx, 1
	mov	DWORD PTR _shortAxisStepFactor$217136[ebp], ecx
$LN45@CanSeeDisp@2:

; 177  : 		while (currentDX != originalDX) 

	mov	edx, DWORD PTR _currentDX$[ebp]
	cmp	edx, DWORD PTR _originalDX$[ebp]
	je	$LN44@CanSeeDisp@2

; 178  : 		{
; 179  : 			shortAxisStepFactor += dy;

	mov	eax, DWORD PTR _shortAxisStepFactor$217136[ebp]
	add	eax, DWORD PTR _dy$[ebp]
	mov	DWORD PTR _shortAxisStepFactor$217136[ebp], eax

; 180  : 
; 181  : 			if (shortAxisStepFactor >= dx) 

	mov	ecx, DWORD PTR _shortAxisStepFactor$217136[ebp]
	cmp	ecx, DWORD PTR _dx$[ebp]
	jl	$LN43@CanSeeDisp@2

; 182  : 			{
; 183  : 				shortAxisStepFactor -= dx;

	mov	edx, DWORD PTR _shortAxisStepFactor$217136[ebp]
	sub	edx, DWORD PTR _dx$[ebp]
	mov	DWORD PTR _shortAxisStepFactor$217136[ebp], edx

; 184  : 
; 185  : 				if (oddQuadrant)

	movzx	eax, BYTE PTR _oddQuadrant$[ebp]
	test	eax, eax
	je	SHORT $LN42@CanSeeDisp@2

; 186  : 				{
; 187  : 					currentDX += stepX;

	mov	ecx, DWORD PTR _currentDX$[ebp]
	add	ecx, DWORD PTR _stepX$[ebp]
	mov	DWORD PTR _currentDX$[ebp], ecx

; 188  : 					currentDY += stepY;

	mov	edx, DWORD PTR _currentDY$[ebp]
	add	edx, DWORD PTR _stepY$[ebp]
	mov	DWORD PTR _currentDY$[ebp], edx

; 189  : 				}
; 190  : 				else

	jmp	$LN41@CanSeeDisp@2
$LN42@CanSeeDisp@2:

; 191  : 				{
; 192  : 					currentDX += stepX;

	mov	eax, DWORD PTR _currentDX$[ebp]
	add	eax, DWORD PTR _stepX$[ebp]
	mov	DWORD PTR _currentDX$[ebp], eax

; 193  : 
; 194  : 					// Look back to see if we were possibly blocked by the alternate route to this hex.  We will ignore the check if inside the rings that allow the user to look around obstacles.
; 195  : 					if (!straightThrough && lookbackDirection != -1)

	movzx	ecx, BYTE PTR _straightThrough$[ebp]
	test	ecx, ecx
	jne	SHORT $LN40@CanSeeDisp@2
	cmp	DWORD PTR _lookbackDirection$[ebp], -1
	je	SHORT $LN40@CanSeeDisp@2

; 196  : 					{
; 197  : 						CvPlot* passThroughPlot = PlotFromHex(kMap, startX + currentDX + ms_LookBackX[lookbackDirection], startY + currentDY + ms_LookBackY[lookbackDirection]);

	mov	edx, DWORD PTR _startY$[ebp]
	add	edx, DWORD PTR _currentDY$[ebp]
	mov	eax, DWORD PTR _lookbackDirection$[ebp]
	add	edx, DWORD PTR _ms_LookBackY[eax*4]
	push	edx
	mov	ecx, DWORD PTR _startX$[ebp]
	add	ecx, DWORD PTR _currentDX$[ebp]
	mov	edx, DWORD PTR _lookbackDirection$[ebp]
	add	ecx, DWORD PTR _ms_LookBackX[edx*4]
	push	ecx
	mov	eax, DWORD PTR _kMap$[ebp]
	push	eax
	call	?PlotFromHex@@YAPAVCvPlot@@AAVCvMap@@HH@Z ; PlotFromHex
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _passThroughPlot$217144[ebp], eax

; 198  : 						TRACK_LAST_TARGET_PATH_ENTRY(passThroughPlot);
; 199  : 						if(!passThroughPlot || fromLevel < passThroughPlot->seeThroughLevel())

	cmp	DWORD PTR _passThroughPlot$217144[ebp], 0
	je	SHORT $LN38@CanSeeDisp@2
	push	1
	mov	ecx, DWORD PTR _passThroughPlot$217144[ebp]
	call	?seeThroughLevel@CvPlot@@QBEH_N@Z	; CvPlot::seeThroughLevel
	cmp	DWORD PTR _fromLevel$[ebp], eax
	jge	SHORT $LN40@CanSeeDisp@2
$LN38@CanSeeDisp@2:

; 200  : 						{
; 201  : 							++iBlockedCount;

	mov	ecx, DWORD PTR _iBlockedCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iBlockedCount$[ebp], ecx

; 202  : 							if (stepCount > STRICT_LOOSE_CUTOFF || iBlockedCount >= 2)

	cmp	DWORD PTR _stepCount$[ebp], 2
	jg	SHORT $LN36@CanSeeDisp@2
	cmp	DWORD PTR _iBlockedCount$[ebp], 2
	jl	SHORT $LN40@CanSeeDisp@2
$LN36@CanSeeDisp@2:

; 203  : 								return false;

	xor	al, al
	jmp	$LN51@CanSeeDisp@2
$LN40@CanSeeDisp@2:

; 204  : 						}
; 205  : 					}
; 206  : 
; 207  : 					// Don't test the destination, we only want to test the plots between the start and the destination
; 208  : 					if (currentDX == originalDX && currentDY == originalDY)

	mov	edx, DWORD PTR _currentDX$[ebp]
	cmp	edx, DWORD PTR _originalDX$[ebp]
	jne	SHORT $LN35@CanSeeDisp@2
	mov	eax, DWORD PTR _currentDY$[ebp]
	cmp	eax, DWORD PTR _originalDY$[ebp]
	jne	SHORT $LN35@CanSeeDisp@2

; 209  : 						break;	

	jmp	$LN44@CanSeeDisp@2
$LN35@CanSeeDisp@2:

; 210  : 
; 211  : 					CvPlot* passThroughPlot = PlotFromHex(kMap, startX + currentDX, startY + currentDY);

	mov	ecx, DWORD PTR _startY$[ebp]
	add	ecx, DWORD PTR _currentDY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _startX$[ebp]
	add	edx, DWORD PTR _currentDX$[ebp]
	push	edx
	mov	eax, DWORD PTR _kMap$[ebp]
	push	eax
	call	?PlotFromHex@@YAPAVCvPlot@@AAVCvMap@@HH@Z ; PlotFromHex
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _passThroughPlot$217150[ebp], eax

; 212  : 					TRACK_LAST_TARGET_PATH_ENTRY(passThroughPlot);
; 213  : 					if(!passThroughPlot || fromLevel < passThroughPlot->seeThroughLevel())

	cmp	DWORD PTR _passThroughPlot$217150[ebp], 0
	je	SHORT $LN33@CanSeeDisp@2
	push	1
	mov	ecx, DWORD PTR _passThroughPlot$217150[ebp]
	call	?seeThroughLevel@CvPlot@@QBEH_N@Z	; CvPlot::seeThroughLevel
	cmp	DWORD PTR _fromLevel$[ebp], eax
	jge	SHORT $LN34@CanSeeDisp@2
$LN33@CanSeeDisp@2:

; 214  : 						return false;

	xor	al, al
	jmp	$LN51@CanSeeDisp@2
$LN34@CanSeeDisp@2:

; 215  : 
; 216  : 					lookbackDirection = ms_HexDirection[(currentDX - lastDX) + 1][(currentDY - lastDY) + 1];

	mov	ecx, DWORD PTR _currentDX$[ebp]
	sub	ecx, DWORD PTR _lastDX$[ebp]
	add	ecx, 1
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _currentDY$[ebp]
	sub	edx, DWORD PTR _lastDY$[ebp]
	mov	eax, DWORD PTR _ms_HexDirection[ecx+edx*4+4]
	mov	DWORD PTR _lookbackDirection$[ebp], eax

; 217  : 
; 218  : 					++stepCount;

	mov	ecx, DWORD PTR _stepCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _stepCount$[ebp], ecx

; 219  : 					lastDX = currentDX; lastDY = currentDY;

	mov	edx, DWORD PTR _currentDX$[ebp]
	mov	DWORD PTR _lastDX$[ebp], edx
	mov	eax, DWORD PTR _currentDY$[ebp]
	mov	DWORD PTR _lastDY$[ebp], eax

; 220  : 
; 221  : 					currentDY += stepY;

	mov	ecx, DWORD PTR _currentDY$[ebp]
	add	ecx, DWORD PTR _stepY$[ebp]
	mov	DWORD PTR _currentDY$[ebp], ecx
$LN41@CanSeeDisp@2:

; 222  : 				}
; 223  : 			}
; 224  : 			else

	jmp	SHORT $LN32@CanSeeDisp@2
$LN43@CanSeeDisp@2:

; 225  : 				currentDX += stepX;

	mov	edx, DWORD PTR _currentDX$[ebp]
	add	edx, DWORD PTR _stepX$[ebp]
	mov	DWORD PTR _currentDX$[ebp], edx
$LN32@CanSeeDisp@2:

; 226  : 
; 227  : 			// Look back to see if we were possibly blocked by the alternate route to this hex.
; 228  : 			if (!straightThrough && lookbackDirection != -1)

	movzx	eax, BYTE PTR _straightThrough$[ebp]
	test	eax, eax
	jne	SHORT $LN31@CanSeeDisp@2
	cmp	DWORD PTR _lookbackDirection$[ebp], -1
	je	SHORT $LN31@CanSeeDisp@2

; 229  : 			{
; 230  : 				CvPlot* passThroughPlot = PlotFromHex(kMap, startX + currentDX + ms_LookBackX[lookbackDirection], startY + currentDY + ms_LookBackY[lookbackDirection]);

	mov	ecx, DWORD PTR _startY$[ebp]
	add	ecx, DWORD PTR _currentDY$[ebp]
	mov	edx, DWORD PTR _lookbackDirection$[ebp]
	add	ecx, DWORD PTR _ms_LookBackY[edx*4]
	push	ecx
	mov	eax, DWORD PTR _startX$[ebp]
	add	eax, DWORD PTR _currentDX$[ebp]
	mov	ecx, DWORD PTR _lookbackDirection$[ebp]
	add	eax, DWORD PTR _ms_LookBackX[ecx*4]
	push	eax
	mov	edx, DWORD PTR _kMap$[ebp]
	push	edx
	call	?PlotFromHex@@YAPAVCvPlot@@AAVCvMap@@HH@Z ; PlotFromHex
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _passThroughPlot$217155[ebp], eax

; 231  : 				TRACK_LAST_TARGET_PATH_ENTRY(passThroughPlot);
; 232  : 				if(!passThroughPlot || fromLevel < passThroughPlot->seeThroughLevel())

	cmp	DWORD PTR _passThroughPlot$217155[ebp], 0
	je	SHORT $LN29@CanSeeDisp@2
	push	1
	mov	ecx, DWORD PTR _passThroughPlot$217155[ebp]
	call	?seeThroughLevel@CvPlot@@QBEH_N@Z	; CvPlot::seeThroughLevel
	cmp	DWORD PTR _fromLevel$[ebp], eax
	jge	SHORT $LN31@CanSeeDisp@2
$LN29@CanSeeDisp@2:

; 233  : 				{
; 234  : 					if (stepCount > STRICT_LOOSE_CUTOFF || ++iBlockedCount >= 2)

	cmp	DWORD PTR _stepCount$[ebp], 2
	jg	SHORT $LN27@CanSeeDisp@2
	mov	eax, DWORD PTR _iBlockedCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _iBlockedCount$[ebp], eax
	cmp	DWORD PTR _iBlockedCount$[ebp], 2
	jl	SHORT $LN31@CanSeeDisp@2
$LN27@CanSeeDisp@2:

; 235  : 						return false;

	xor	al, al
	jmp	$LN51@CanSeeDisp@2
$LN31@CanSeeDisp@2:

; 236  : 				}
; 237  : 			}
; 238  : 
; 239  : 			// Don't test the destination, we only want to test the plots between the start and the destination
; 240  : 			if (currentDX == originalDX && currentDY == originalDY)

	mov	ecx, DWORD PTR _currentDX$[ebp]
	cmp	ecx, DWORD PTR _originalDX$[ebp]
	jne	SHORT $LN26@CanSeeDisp@2
	mov	edx, DWORD PTR _currentDY$[ebp]
	cmp	edx, DWORD PTR _originalDY$[ebp]
	jne	SHORT $LN26@CanSeeDisp@2

; 241  : 				break;	

	jmp	SHORT $LN44@CanSeeDisp@2
$LN26@CanSeeDisp@2:

; 242  : 
; 243  : 			CvPlot* passThroughPlot = PlotFromHex(kMap, startX + currentDX, startY + currentDY);

	mov	eax, DWORD PTR _startY$[ebp]
	add	eax, DWORD PTR _currentDY$[ebp]
	push	eax
	mov	ecx, DWORD PTR _startX$[ebp]
	add	ecx, DWORD PTR _currentDX$[ebp]
	push	ecx
	mov	edx, DWORD PTR _kMap$[ebp]
	push	edx
	call	?PlotFromHex@@YAPAVCvPlot@@AAVCvMap@@HH@Z ; PlotFromHex
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _passThroughPlot$217161[ebp], eax

; 244  : 			TRACK_LAST_TARGET_PATH_ENTRY(passThroughPlot);
; 245  : 			if(!passThroughPlot || fromLevel < passThroughPlot->seeThroughLevel())

	cmp	DWORD PTR _passThroughPlot$217161[ebp], 0
	je	SHORT $LN24@CanSeeDisp@2
	push	1
	mov	ecx, DWORD PTR _passThroughPlot$217161[ebp]
	call	?seeThroughLevel@CvPlot@@QBEH_N@Z	; CvPlot::seeThroughLevel
	cmp	DWORD PTR _fromLevel$[ebp], eax
	jge	SHORT $LN25@CanSeeDisp@2
$LN24@CanSeeDisp@2:

; 246  : 				return false;

	xor	al, al
	jmp	$LN51@CanSeeDisp@2
$LN25@CanSeeDisp@2:

; 247  : 
; 248  : 			lookbackDirection = ms_HexDirection[(currentDX - lastDX) + 1][(currentDY - lastDY) + 1];

	mov	eax, DWORD PTR _currentDX$[ebp]
	sub	eax, DWORD PTR _lastDX$[ebp]
	add	eax, 1
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _currentDY$[ebp]
	sub	ecx, DWORD PTR _lastDY$[ebp]
	mov	edx, DWORD PTR _ms_HexDirection[eax+ecx*4+4]
	mov	DWORD PTR _lookbackDirection$[ebp], edx

; 249  : 
; 250  : 			++stepCount;

	mov	eax, DWORD PTR _stepCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _stepCount$[ebp], eax

; 251  : 			lastDX = currentDX; lastDY = currentDY;

	mov	ecx, DWORD PTR _currentDX$[ebp]
	mov	DWORD PTR _lastDX$[ebp], ecx
	mov	edx, DWORD PTR _currentDY$[ebp]
	mov	DWORD PTR _lastDY$[ebp], edx

; 252  : 		}

	jmp	$LN45@CanSeeDisp@2
$LN44@CanSeeDisp@2:

; 253  : 	} 
; 254  : 	else 

	jmp	$LN23@CanSeeDisp@2
$LN46@CanSeeDisp@2:

; 255  : 	{
; 256  : 		// Y axis runs are longer, scan along them and adjust the X as needed.
; 257  : 		// The short axis step is primed slightly differently if the step ratio is 2:1
; 258  : 		// so that the initial step goes in a more favorable direction
; 259  : 		int shortAxisStepFactor = (dy!=dx && dx != 0 && (dy>>1) == dx)?((dy >> 1) - dx):(dy >> 1);

	mov	eax, DWORD PTR _dy$[ebp]
	cmp	eax, DWORD PTR _dx$[ebp]
	je	SHORT $LN55@CanSeeDisp@2
	cmp	DWORD PTR _dx$[ebp], 0
	je	SHORT $LN55@CanSeeDisp@2
	mov	ecx, DWORD PTR _dy$[ebp]
	sar	ecx, 1
	cmp	ecx, DWORD PTR _dx$[ebp]
	jne	SHORT $LN55@CanSeeDisp@2
	mov	edx, DWORD PTR _dy$[ebp]
	sar	edx, 1
	sub	edx, DWORD PTR _dx$[ebp]
	mov	DWORD PTR tv221[ebp], edx
	jmp	SHORT $LN56@CanSeeDisp@2
$LN55@CanSeeDisp@2:
	mov	eax, DWORD PTR _dy$[ebp]
	sar	eax, 1
	mov	DWORD PTR tv221[ebp], eax
$LN56@CanSeeDisp@2:
	mov	ecx, DWORD PTR tv221[ebp]
	mov	DWORD PTR _shortAxisStepFactor$217165[ebp], ecx
$LN22@CanSeeDisp@2:

; 260  : 		//int fraction = (dy >> 1);
; 261  : 		while (currentDY != originalDY) 

	mov	edx, DWORD PTR _currentDY$[ebp]
	cmp	edx, DWORD PTR _originalDY$[ebp]
	je	$LN23@CanSeeDisp@2

; 262  : 		{
; 263  : 			shortAxisStepFactor += dx;

	mov	eax, DWORD PTR _shortAxisStepFactor$217165[ebp]
	add	eax, DWORD PTR _dx$[ebp]
	mov	DWORD PTR _shortAxisStepFactor$217165[ebp], eax

; 264  : 
; 265  : 			if (shortAxisStepFactor >= dy) 

	mov	ecx, DWORD PTR _shortAxisStepFactor$217165[ebp]
	cmp	ecx, DWORD PTR _dy$[ebp]
	jl	$LN20@CanSeeDisp@2

; 266  : 			{
; 267  : 				shortAxisStepFactor -= dy;

	mov	edx, DWORD PTR _shortAxisStepFactor$217165[ebp]
	sub	edx, DWORD PTR _dy$[ebp]
	mov	DWORD PTR _shortAxisStepFactor$217165[ebp], edx

; 268  : 
; 269  : 				if (oddQuadrant)

	movzx	eax, BYTE PTR _oddQuadrant$[ebp]
	test	eax, eax
	je	SHORT $LN19@CanSeeDisp@2

; 270  : 				{
; 271  : 					// A change in the X and Y axis will yield a contiguous line
; 272  : 					currentDX += stepX;

	mov	ecx, DWORD PTR _currentDX$[ebp]
	add	ecx, DWORD PTR _stepX$[ebp]
	mov	DWORD PTR _currentDX$[ebp], ecx

; 273  : 					currentDY += stepY;

	mov	edx, DWORD PTR _currentDY$[ebp]
	add	edx, DWORD PTR _stepY$[ebp]
	mov	DWORD PTR _currentDY$[ebp], edx

; 274  : 				}
; 275  : 				else

	jmp	$LN18@CanSeeDisp@2
$LN19@CanSeeDisp@2:

; 276  : 				{
; 277  : 					// Adjust just the X axis, then check so that the line is contiguous.
; 278  : 					currentDX += stepX;

	mov	eax, DWORD PTR _currentDX$[ebp]
	add	eax, DWORD PTR _stepX$[ebp]
	mov	DWORD PTR _currentDX$[ebp], eax

; 279  : 
; 280  : 					// Look back to see if we were possibly blocked by the alternate route to this hex.
; 281  : 					if (!straightThrough && lookbackDirection != -1)

	movzx	ecx, BYTE PTR _straightThrough$[ebp]
	test	ecx, ecx
	jne	SHORT $LN17@CanSeeDisp@2
	cmp	DWORD PTR _lookbackDirection$[ebp], -1
	je	SHORT $LN17@CanSeeDisp@2

; 282  : 					{
; 283  : 						CvPlot* passThroughPlot = PlotFromHex(kMap, startX + currentDX + ms_LookBackX[lookbackDirection], startY + currentDY + ms_LookBackY[lookbackDirection]);

	mov	edx, DWORD PTR _startY$[ebp]
	add	edx, DWORD PTR _currentDY$[ebp]
	mov	eax, DWORD PTR _lookbackDirection$[ebp]
	add	edx, DWORD PTR _ms_LookBackY[eax*4]
	push	edx
	mov	ecx, DWORD PTR _startX$[ebp]
	add	ecx, DWORD PTR _currentDX$[ebp]
	mov	edx, DWORD PTR _lookbackDirection$[ebp]
	add	ecx, DWORD PTR _ms_LookBackX[edx*4]
	push	ecx
	mov	eax, DWORD PTR _kMap$[ebp]
	push	eax
	call	?PlotFromHex@@YAPAVCvPlot@@AAVCvMap@@HH@Z ; PlotFromHex
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _passThroughPlot$217173[ebp], eax

; 284  : 						TRACK_LAST_TARGET_PATH_ENTRY(passThroughPlot);
; 285  : 						if(!passThroughPlot || fromLevel < passThroughPlot->seeThroughLevel())

	cmp	DWORD PTR _passThroughPlot$217173[ebp], 0
	je	SHORT $LN15@CanSeeDisp@2
	push	1
	mov	ecx, DWORD PTR _passThroughPlot$217173[ebp]
	call	?seeThroughLevel@CvPlot@@QBEH_N@Z	; CvPlot::seeThroughLevel
	cmp	DWORD PTR _fromLevel$[ebp], eax
	jge	SHORT $LN17@CanSeeDisp@2
$LN15@CanSeeDisp@2:

; 286  : 						{
; 287  : 							if (stepCount > STRICT_LOOSE_CUTOFF || ++iBlockedCount >= 2)

	cmp	DWORD PTR _stepCount$[ebp], 2
	jg	SHORT $LN13@CanSeeDisp@2
	mov	ecx, DWORD PTR _iBlockedCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iBlockedCount$[ebp], ecx
	cmp	DWORD PTR _iBlockedCount$[ebp], 2
	jl	SHORT $LN17@CanSeeDisp@2
$LN13@CanSeeDisp@2:

; 288  : 								return false;

	xor	al, al
	jmp	$LN51@CanSeeDisp@2
$LN17@CanSeeDisp@2:

; 289  : 						}
; 290  : 					}
; 291  : 
; 292  : 					// Don't test the destination, we only want to test the plots between the start and the destination
; 293  : 					if (currentDX == originalDX && currentDY == originalDY)

	mov	edx, DWORD PTR _currentDX$[ebp]
	cmp	edx, DWORD PTR _originalDX$[ebp]
	jne	SHORT $LN12@CanSeeDisp@2
	mov	eax, DWORD PTR _currentDY$[ebp]
	cmp	eax, DWORD PTR _originalDY$[ebp]
	jne	SHORT $LN12@CanSeeDisp@2

; 294  : 						break;	

	jmp	$LN23@CanSeeDisp@2
$LN12@CanSeeDisp@2:

; 295  : 
; 296  : 					CvPlot* passThroughPlot = PlotFromHex(kMap, startX + currentDX, startY + currentDY);

	mov	ecx, DWORD PTR _startY$[ebp]
	add	ecx, DWORD PTR _currentDY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _startX$[ebp]
	add	edx, DWORD PTR _currentDX$[ebp]
	push	edx
	mov	eax, DWORD PTR _kMap$[ebp]
	push	eax
	call	?PlotFromHex@@YAPAVCvPlot@@AAVCvMap@@HH@Z ; PlotFromHex
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _passThroughPlot$217179[ebp], eax

; 297  : 					TRACK_LAST_TARGET_PATH_ENTRY(passThroughPlot);
; 298  : 					if(!passThroughPlot || fromLevel < passThroughPlot->seeThroughLevel())

	cmp	DWORD PTR _passThroughPlot$217179[ebp], 0
	je	SHORT $LN10@CanSeeDisp@2
	push	1
	mov	ecx, DWORD PTR _passThroughPlot$217179[ebp]
	call	?seeThroughLevel@CvPlot@@QBEH_N@Z	; CvPlot::seeThroughLevel
	cmp	DWORD PTR _fromLevel$[ebp], eax
	jge	SHORT $LN11@CanSeeDisp@2
$LN10@CanSeeDisp@2:

; 299  : 						return false;

	xor	al, al
	jmp	$LN51@CanSeeDisp@2
$LN11@CanSeeDisp@2:

; 300  : 
; 301  : 					lookbackDirection = ms_HexDirection[(currentDX - lastDX) + 1][(currentDY - lastDY) + 1];

	mov	ecx, DWORD PTR _currentDX$[ebp]
	sub	ecx, DWORD PTR _lastDX$[ebp]
	add	ecx, 1
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _currentDY$[ebp]
	sub	edx, DWORD PTR _lastDY$[ebp]
	mov	eax, DWORD PTR _ms_HexDirection[ecx+edx*4+4]
	mov	DWORD PTR _lookbackDirection$[ebp], eax

; 302  : 
; 303  : 					++stepCount;

	mov	ecx, DWORD PTR _stepCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _stepCount$[ebp], ecx

; 304  : 					lastDX = currentDX; lastDY = currentDY;

	mov	edx, DWORD PTR _currentDX$[ebp]
	mov	DWORD PTR _lastDX$[ebp], edx
	mov	eax, DWORD PTR _currentDY$[ebp]
	mov	DWORD PTR _lastDY$[ebp], eax

; 305  : 
; 306  : 					currentDY += stepY;

	mov	ecx, DWORD PTR _currentDY$[ebp]
	add	ecx, DWORD PTR _stepY$[ebp]
	mov	DWORD PTR _currentDY$[ebp], ecx
$LN18@CanSeeDisp@2:

; 307  : 				}
; 308  : 			}
; 309  : 			else

	jmp	SHORT $LN9@CanSeeDisp@2
$LN20@CanSeeDisp@2:

; 310  : 				currentDY += stepY;

	mov	edx, DWORD PTR _currentDY$[ebp]
	add	edx, DWORD PTR _stepY$[ebp]
	mov	DWORD PTR _currentDY$[ebp], edx
$LN9@CanSeeDisp@2:

; 311  : 
; 312  : 			// Look back to see if we were possibly blocked by the alternate route to this hex.
; 313  : 			if (!straightThrough && lookbackDirection != -1)

	movzx	eax, BYTE PTR _straightThrough$[ebp]
	test	eax, eax
	jne	SHORT $LN8@CanSeeDisp@2
	cmp	DWORD PTR _lookbackDirection$[ebp], -1
	je	SHORT $LN8@CanSeeDisp@2

; 314  : 			{
; 315  : 				CvPlot* passThroughPlot = PlotFromHex(kMap, startX + currentDX + ms_LookBackX[lookbackDirection], startY + currentDY + ms_LookBackY[lookbackDirection]);

	mov	ecx, DWORD PTR _startY$[ebp]
	add	ecx, DWORD PTR _currentDY$[ebp]
	mov	edx, DWORD PTR _lookbackDirection$[ebp]
	add	ecx, DWORD PTR _ms_LookBackY[edx*4]
	push	ecx
	mov	eax, DWORD PTR _startX$[ebp]
	add	eax, DWORD PTR _currentDX$[ebp]
	mov	ecx, DWORD PTR _lookbackDirection$[ebp]
	add	eax, DWORD PTR _ms_LookBackX[ecx*4]
	push	eax
	mov	edx, DWORD PTR _kMap$[ebp]
	push	edx
	call	?PlotFromHex@@YAPAVCvPlot@@AAVCvMap@@HH@Z ; PlotFromHex
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _passThroughPlot$217184[ebp], eax

; 316  : 				TRACK_LAST_TARGET_PATH_ENTRY(passThroughPlot);
; 317  : 				if(!passThroughPlot || fromLevel < passThroughPlot->seeThroughLevel())

	cmp	DWORD PTR _passThroughPlot$217184[ebp], 0
	je	SHORT $LN6@CanSeeDisp@2
	push	1
	mov	ecx, DWORD PTR _passThroughPlot$217184[ebp]
	call	?seeThroughLevel@CvPlot@@QBEH_N@Z	; CvPlot::seeThroughLevel
	cmp	DWORD PTR _fromLevel$[ebp], eax
	jge	SHORT $LN8@CanSeeDisp@2
$LN6@CanSeeDisp@2:

; 318  : 				{
; 319  : 					if (stepCount > STRICT_LOOSE_CUTOFF || ++iBlockedCount >= 2)

	cmp	DWORD PTR _stepCount$[ebp], 2
	jg	SHORT $LN4@CanSeeDisp@2
	mov	eax, DWORD PTR _iBlockedCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _iBlockedCount$[ebp], eax
	cmp	DWORD PTR _iBlockedCount$[ebp], 2
	jl	SHORT $LN8@CanSeeDisp@2
$LN4@CanSeeDisp@2:

; 320  : 						return false;

	xor	al, al
	jmp	$LN51@CanSeeDisp@2
$LN8@CanSeeDisp@2:

; 321  : 				}
; 322  : 			}
; 323  : 
; 324  : 			// Don't test the destination, we only want to test the plots between the start and the destination
; 325  : 			if (currentDX == originalDX && currentDY == originalDY)

	mov	ecx, DWORD PTR _currentDX$[ebp]
	cmp	ecx, DWORD PTR _originalDX$[ebp]
	jne	SHORT $LN3@CanSeeDisp@2
	mov	edx, DWORD PTR _currentDY$[ebp]
	cmp	edx, DWORD PTR _originalDY$[ebp]
	jne	SHORT $LN3@CanSeeDisp@2

; 326  : 				break;	

	jmp	SHORT $LN23@CanSeeDisp@2
$LN3@CanSeeDisp@2:

; 327  : 
; 328  : 			CvPlot* passThroughPlot = PlotFromHex(kMap, startX + currentDX, startY + currentDY);

	mov	eax, DWORD PTR _startY$[ebp]
	add	eax, DWORD PTR _currentDY$[ebp]
	push	eax
	mov	ecx, DWORD PTR _startX$[ebp]
	add	ecx, DWORD PTR _currentDX$[ebp]
	push	ecx
	mov	edx, DWORD PTR _kMap$[ebp]
	push	edx
	call	?PlotFromHex@@YAPAVCvPlot@@AAVCvMap@@HH@Z ; PlotFromHex
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _passThroughPlot$217190[ebp], eax

; 329  : 			TRACK_LAST_TARGET_PATH_ENTRY(passThroughPlot);
; 330  : 			if(!passThroughPlot || fromLevel < passThroughPlot->seeThroughLevel())

	cmp	DWORD PTR _passThroughPlot$217190[ebp], 0
	je	SHORT $LN1@CanSeeDisp@2
	push	1
	mov	ecx, DWORD PTR _passThroughPlot$217190[ebp]
	call	?seeThroughLevel@CvPlot@@QBEH_N@Z	; CvPlot::seeThroughLevel
	cmp	DWORD PTR _fromLevel$[ebp], eax
	jge	SHORT $LN2@CanSeeDisp@2
$LN1@CanSeeDisp@2:

; 331  : 				return false;

	xor	al, al
	jmp	SHORT $LN51@CanSeeDisp@2
$LN2@CanSeeDisp@2:

; 332  : 
; 333  : 			lookbackDirection = ms_HexDirection[(currentDX - lastDX) + 1][(currentDY - lastDY) + 1];

	mov	eax, DWORD PTR _currentDX$[ebp]
	sub	eax, DWORD PTR _lastDX$[ebp]
	add	eax, 1
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _currentDY$[ebp]
	sub	ecx, DWORD PTR _lastDY$[ebp]
	mov	edx, DWORD PTR _ms_HexDirection[eax+ecx*4+4]
	mov	DWORD PTR _lookbackDirection$[ebp], edx

; 334  : 
; 335  : 			++stepCount;

	mov	eax, DWORD PTR _stepCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _stepCount$[ebp], eax

; 336  : 			lastDX = currentDX; lastDY = currentDY;

	mov	ecx, DWORD PTR _currentDX$[ebp]
	mov	DWORD PTR _lastDX$[ebp], ecx
	mov	edx, DWORD PTR _currentDY$[ebp]
	mov	DWORD PTR _lastDY$[ebp], edx

; 337  : 		}

	jmp	$LN22@CanSeeDisp@2
$LN23@CanSeeDisp@2:

; 338  : 	}
; 339  : 
; 340  : 	return true;

	mov	al, 1
$LN51@CanSeeDisp@2:

; 341  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CanSeeDisplacementPlot_Strict@@YA_NHHHHH@Z ENDP	; CanSeeDisplacementPlot_Strict
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?CanSeeDisplacementPlot_Loose@@YA_NHHHHH@Z
_TEXT	SEGMENT
tv223 = -452						; size = 4
tv77 = -448						; size = 4
_passThroughPlot$217267 = -92				; size = 4
_passThroughPlot$217256 = -88				; size = 4
_passThroughPlot$217261 = -84				; size = 4
_passThroughPlot$217272 = -80				; size = 4
_shortAxisStepFactor$217247 = -76			; size = 4
_passThroughPlot$217238 = -72				; size = 4
_passThroughPlot$217227 = -68				; size = 4
_passThroughPlot$217232 = -64				; size = 4
_passThroughPlot$217243 = -60				; size = 4
_shortAxisStepFactor$217218 = -56			; size = 4
_kMap$ = -52						; size = 4
_straightThrough$ = -45					; size = 1
_blockedDirection$ = -44				; size = 4
_stepY$ = -40						; size = 4
_currentDY$ = -36					; size = 4
_originalDY$ = -32					; size = 4
_originalDX$ = -28					; size = 4
_stepX$ = -24						; size = 4
_lastDY$ = -20						; size = 4
_lastDX$ = -16						; size = 4
_oddQuadrant$ = -9					; size = 1
_currentDX$ = -8					; size = 4
_bBlocked$ = -1						; size = 1
_startX$ = 8						; size = 4
_startY$ = 12						; size = 4
_dx$ = 16						; size = 4
_dy$ = 20						; size = 4
_fromLevel$ = 24					; size = 4
?CanSeeDisplacementPlot_Loose@@YA_NHHHHH@Z PROC		; CanSeeDisplacementPlot_Loose, COMDAT

; 348  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 452				; 000001c4H

; 349  : 	int originalDX = dx;

	mov	eax, DWORD PTR _dx$[ebp]
	mov	DWORD PTR _originalDX$[ebp], eax

; 350  : 	int originalDY = dy;

	mov	ecx, DWORD PTR _dy$[ebp]
	mov	DWORD PTR _originalDY$[ebp], ecx

; 351  : 
; 352  : 	CvMap& kMap = GC.getMap();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], edx

; 353  : 
; 354  : 	// Use Bresenham's line algorithm, with a slight modification, to step through the cells.
; 355  : 	// The modification is that if we are stepping in the upper-right or lower-left quadrant,
; 356  : 	// and we need to take a step on the 'short' axis, we will check the plot with just the
; 357  : 	// adjustment to the X axis, before we do the normal check for the step on the X and Y
; 358  : 	// axis.  This is needed because in those quadrants a change on both the X and Y axis 
; 359  : 	// is not contiguous.
; 360  : 
; 361  : 	// Because the hex grid is low-resolution, checks are also made to allow the ray to continue 
; 362  : 	// around a blockage if that blockage obscures only part of the next hex cell along the ray.
; 363  : 	// This is done by 'looking back' at the alternate path the ray could have taken as it is 
; 364  : 	// traversing the hex grid.
; 365  : 
; 366  : 	// Make DX and DY positive and adjust the step constant for the opposite axis.
; 367  : #ifdef AUI_PLOT_VISIBILITY_OPTIMIZATIONS
; 368  : 	int stepY = 1;
; 369  : #else
; 370  : 	int stepY;
; 371  : #endif
; 372  : 	if (dy < 0) 

	cmp	DWORD PTR _dy$[ebp], 0
	jge	SHORT $LN50@CanSeeDisp@3

; 373  : 	{ 
; 374  : 		dy = -dy;  

	mov	eax, DWORD PTR _dy$[ebp]
	neg	eax
	mov	DWORD PTR _dy$[ebp], eax

; 375  : 		stepY = -1; 

	mov	DWORD PTR _stepY$[ebp], -1

; 376  : 	} 
; 377  : #ifdef AUI_PLOT_VISIBILITY_OPTIMIZATIONS
; 378  : 	int stepX = 1;
; 379  : #else
; 380  : 	else 

	jmp	SHORT $LN49@CanSeeDisp@3
$LN50@CanSeeDisp@3:

; 381  : 		stepY = 1; 

	mov	DWORD PTR _stepY$[ebp], 1
$LN49@CanSeeDisp@3:

; 382  : 
; 383  : 	int stepX;
; 384  : #endif
; 385  : 	if (dx < 0) 

	cmp	DWORD PTR _dx$[ebp], 0
	jge	SHORT $LN48@CanSeeDisp@3

; 386  : 	{ 
; 387  : 		dx = -dx;  

	mov	ecx, DWORD PTR _dx$[ebp]
	neg	ecx
	mov	DWORD PTR _dx$[ebp], ecx

; 388  : 		stepX = -1; 

	mov	DWORD PTR _stepX$[ebp], -1

; 389  : 	} 
; 390  : #ifndef AUI_PLOT_VISIBILITY_OPTIMIZATIONS
; 391  : 	else 

	jmp	SHORT $LN47@CanSeeDisp@3
$LN48@CanSeeDisp@3:

; 392  : 		stepX = 1;

	mov	DWORD PTR _stepX$[ebp], 1
$LN47@CanSeeDisp@3:

; 393  : #endif
; 394  : 
; 395  : 	dy <<= 1;

	mov	edx, DWORD PTR _dy$[ebp]
	shl	edx, 1
	mov	DWORD PTR _dy$[ebp], edx

; 396  : 	dx <<= 1;

	mov	eax, DWORD PTR _dx$[ebp]
	shl	eax, 1
	mov	DWORD PTR _dx$[ebp], eax

; 397  : 
; 398  : 	int currentDX = 0;

	mov	DWORD PTR _currentDX$[ebp], 0

; 399  : 	int currentDY = 0;

	mov	DWORD PTR _currentDY$[ebp], 0

; 400  : 
; 401  : 	bool bBlocked = false;

	mov	BYTE PTR _bBlocked$[ebp], 0

; 402  : 	// If in an odd quadrant, stepping down on the short axis requires two checks to be contiguous
; 403  : 	bool oddQuadrant = stepX != stepY;

	mov	ecx, DWORD PTR _stepX$[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR _stepY$[ebp]
	setne	dl
	mov	BYTE PTR _oddQuadrant$[ebp], dl

; 404  : 	// Is the line going to go such that it travels through the centers of the hexes?
; 405  : 	// If so, we don't have to worry about testing to see if we can look around blocked hexes.
; 406  : #ifdef AUI_PLOT_VISIBILITY_OPTIMIZATIONS
; 407  : 	bool straightThrough = dx == 0 || dy == 0 || (dx == dy && oddQuadrant);
; 408  : #else
; 409  : 	bool straightThrough = dx == 0 || dy == 0;

	cmp	DWORD PTR _dx$[ebp], 0
	je	SHORT $LN53@CanSeeDisp@3
	cmp	DWORD PTR _dy$[ebp], 0
	je	SHORT $LN53@CanSeeDisp@3
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN54@CanSeeDisp@3
$LN53@CanSeeDisp@3:
	mov	DWORD PTR tv77[ebp], 1
$LN54@CanSeeDisp@3:
	mov	al, BYTE PTR tv77[ebp]
	mov	BYTE PTR _straightThrough$[ebp], al

; 410  : #endif
; 411  : 
; 412  : 	// Start from the next cell after the source plot
; 413  : 	int lastDX = currentDX;

	mov	ecx, DWORD PTR _currentDX$[ebp]
	mov	DWORD PTR _lastDX$[ebp], ecx

; 414  : 	int lastDY = currentDY;

	mov	edx, DWORD PTR _currentDY$[ebp]
	mov	DWORD PTR _lastDY$[ebp], edx

; 415  : 	int blockedDirection = 0;

	mov	DWORD PTR _blockedDirection$[ebp], 0

; 416  : 
; 417  : 	// If dx is greater than dy, scan along the x axis, adjusting the Y as needed
; 418  : 	if (dx > dy) 

	mov	eax, DWORD PTR _dx$[ebp]
	cmp	eax, DWORD PTR _dy$[ebp]
	jle	$LN46@CanSeeDisp@3

; 419  : 	{
; 420  : 		int shortAxisStepFactor = (dx >> 1); 

	mov	ecx, DWORD PTR _dx$[ebp]
	sar	ecx, 1
	mov	DWORD PTR _shortAxisStepFactor$217218[ebp], ecx
$LN45@CanSeeDisp@3:

; 421  : 		while (currentDX != originalDX) 

	mov	edx, DWORD PTR _currentDX$[ebp]
	cmp	edx, DWORD PTR _originalDX$[ebp]
	je	$LN44@CanSeeDisp@3

; 422  : 		{
; 423  : 			shortAxisStepFactor += dy;

	mov	eax, DWORD PTR _shortAxisStepFactor$217218[ebp]
	add	eax, DWORD PTR _dy$[ebp]
	mov	DWORD PTR _shortAxisStepFactor$217218[ebp], eax

; 424  : 
; 425  : 			if (shortAxisStepFactor >= dx) 

	mov	ecx, DWORD PTR _shortAxisStepFactor$217218[ebp]
	cmp	ecx, DWORD PTR _dx$[ebp]
	jl	$LN43@CanSeeDisp@3

; 426  : 			{
; 427  : 				shortAxisStepFactor -= dx;

	mov	edx, DWORD PTR _shortAxisStepFactor$217218[ebp]
	sub	edx, DWORD PTR _dx$[ebp]
	mov	DWORD PTR _shortAxisStepFactor$217218[ebp], edx

; 428  : 
; 429  : 				if (oddQuadrant)

	movzx	eax, BYTE PTR _oddQuadrant$[ebp]
	test	eax, eax
	je	SHORT $LN42@CanSeeDisp@3

; 430  : 				{
; 431  : 					currentDX += stepX;

	mov	ecx, DWORD PTR _currentDX$[ebp]
	add	ecx, DWORD PTR _stepX$[ebp]
	mov	DWORD PTR _currentDX$[ebp], ecx

; 432  : 					currentDY += stepY;

	mov	edx, DWORD PTR _currentDY$[ebp]
	add	edx, DWORD PTR _stepY$[ebp]
	mov	DWORD PTR _currentDY$[ebp], edx

; 433  : 				}
; 434  : 				else

	jmp	$LN41@CanSeeDisp@3
$LN42@CanSeeDisp@3:

; 435  : 				{
; 436  : 					currentDX += stepX;

	mov	eax, DWORD PTR _currentDX$[ebp]
	add	eax, DWORD PTR _stepX$[ebp]
	mov	DWORD PTR _currentDX$[ebp], eax

; 437  : 
; 438  : 					// If we were blocked by the previous hex, see if we are able to look around the adjacent one if we split between them
; 439  : 					if (bBlocked)

	movzx	ecx, BYTE PTR _bBlocked$[ebp]
	test	ecx, ecx
	je	SHORT $LN40@CanSeeDisp@3

; 440  : 					{
; 441  : 						if (!straightThrough)

	movzx	edx, BYTE PTR _straightThrough$[ebp]
	test	edx, edx
	jne	SHORT $LN39@CanSeeDisp@3

; 442  : 						{
; 443  : 							CvPlot* passThroughPlot = PlotFromHex(kMap, startX + currentDX + ms_LookBackX[blockedDirection], startY + currentDY + ms_LookBackY[blockedDirection]);

	mov	eax, DWORD PTR _startY$[ebp]
	add	eax, DWORD PTR _currentDY$[ebp]
	mov	ecx, DWORD PTR _blockedDirection$[ebp]
	add	eax, DWORD PTR _ms_LookBackY[ecx*4]
	push	eax
	mov	edx, DWORD PTR _startX$[ebp]
	add	edx, DWORD PTR _currentDX$[ebp]
	mov	eax, DWORD PTR _blockedDirection$[ebp]
	add	edx, DWORD PTR _ms_LookBackX[eax*4]
	push	edx
	mov	ecx, DWORD PTR _kMap$[ebp]
	push	ecx
	call	?PlotFromHex@@YAPAVCvPlot@@AAVCvMap@@HH@Z ; PlotFromHex
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _passThroughPlot$217227[ebp], eax

; 444  : 							if(passThroughPlot)

	cmp	DWORD PTR _passThroughPlot$217227[ebp], 0
	je	SHORT $LN38@CanSeeDisp@3

; 445  : 							{
; 446  : 								TRACK_LAST_TARGET_PATH_ENTRY(passThroughPlot);
; 447  : 								bBlocked = (fromLevel < passThroughPlot->seeThroughLevel());

	push	1
	mov	ecx, DWORD PTR _passThroughPlot$217227[ebp]
	call	?seeThroughLevel@CvPlot@@QBEH_N@Z	; CvPlot::seeThroughLevel
	xor	edx, edx
	cmp	DWORD PTR _fromLevel$[ebp], eax
	setl	dl
	mov	BYTE PTR _bBlocked$[ebp], dl
$LN38@CanSeeDisp@3:

; 448  : 							}
; 449  : 
; 450  : 							if (bBlocked)

	movzx	eax, BYTE PTR _bBlocked$[ebp]
	test	eax, eax
	je	SHORT $LN37@CanSeeDisp@3

; 451  : 								return false;

	xor	al, al
	jmp	$LN51@CanSeeDisp@3
$LN37@CanSeeDisp@3:

; 452  : 						}
; 453  : 						else

	jmp	SHORT $LN40@CanSeeDisp@3
$LN39@CanSeeDisp@3:

; 454  : 							return false;

	xor	al, al
	jmp	$LN51@CanSeeDisp@3
$LN40@CanSeeDisp@3:

; 455  : 					}
; 456  : 
; 457  : 					// Don't test the destination, we only want to test the plots between the start and the destination
; 458  : 					if (currentDX == originalDX && currentDY == originalDY)

	mov	ecx, DWORD PTR _currentDX$[ebp]
	cmp	ecx, DWORD PTR _originalDX$[ebp]
	jne	SHORT $LN35@CanSeeDisp@3
	mov	edx, DWORD PTR _currentDY$[ebp]
	cmp	edx, DWORD PTR _originalDY$[ebp]
	jne	SHORT $LN35@CanSeeDisp@3

; 459  : 						break;	

	jmp	$LN44@CanSeeDisp@3
$LN35@CanSeeDisp@3:

; 460  : 
; 461  : 					CvPlot* passThroughPlot = PlotFromHex(kMap, startX + currentDX, startY + currentDY);

	mov	eax, DWORD PTR _startY$[ebp]
	add	eax, DWORD PTR _currentDY$[ebp]
	push	eax
	mov	ecx, DWORD PTR _startX$[ebp]
	add	ecx, DWORD PTR _currentDX$[ebp]
	push	ecx
	mov	edx, DWORD PTR _kMap$[ebp]
	push	edx
	call	?PlotFromHex@@YAPAVCvPlot@@AAVCvMap@@HH@Z ; PlotFromHex
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _passThroughPlot$217232[ebp], eax

; 462  : 					TRACK_LAST_TARGET_PATH_ENTRY(passThroughPlot);
; 463  : 					if(!passThroughPlot || fromLevel < passThroughPlot->seeThroughLevel())

	cmp	DWORD PTR _passThroughPlot$217232[ebp], 0
	je	SHORT $LN33@CanSeeDisp@3
	push	1
	mov	ecx, DWORD PTR _passThroughPlot$217232[ebp]
	call	?seeThroughLevel@CvPlot@@QBEH_N@Z	; CvPlot::seeThroughLevel
	cmp	DWORD PTR _fromLevel$[ebp], eax
	jge	SHORT $LN34@CanSeeDisp@3
$LN33@CanSeeDisp@3:

; 464  : 					{
; 465  : 						bBlocked = true;

	mov	BYTE PTR _bBlocked$[ebp], 1

; 466  : 						blockedDirection = ms_HexDirection[(currentDX - lastDX) + 1][(currentDY - lastDY) + 1];

	mov	eax, DWORD PTR _currentDX$[ebp]
	sub	eax, DWORD PTR _lastDX$[ebp]
	add	eax, 1
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _currentDY$[ebp]
	sub	ecx, DWORD PTR _lastDY$[ebp]
	mov	edx, DWORD PTR _ms_HexDirection[eax+ecx*4+4]
	mov	DWORD PTR _blockedDirection$[ebp], edx
$LN34@CanSeeDisp@3:

; 467  : 					}
; 468  : 
; 469  : 					lastDX = currentDX; lastDY = currentDY;

	mov	eax, DWORD PTR _currentDX$[ebp]
	mov	DWORD PTR _lastDX$[ebp], eax
	mov	ecx, DWORD PTR _currentDY$[ebp]
	mov	DWORD PTR _lastDY$[ebp], ecx

; 470  : 
; 471  : 					currentDY += stepY;

	mov	edx, DWORD PTR _currentDY$[ebp]
	add	edx, DWORD PTR _stepY$[ebp]
	mov	DWORD PTR _currentDY$[ebp], edx
$LN41@CanSeeDisp@3:

; 472  : 				}
; 473  : 			}
; 474  : 			else

	jmp	SHORT $LN32@CanSeeDisp@3
$LN43@CanSeeDisp@3:

; 475  : 				currentDX += stepX;

	mov	eax, DWORD PTR _currentDX$[ebp]
	add	eax, DWORD PTR _stepX$[ebp]
	mov	DWORD PTR _currentDX$[ebp], eax
$LN32@CanSeeDisp@3:

; 476  : 
; 477  : 			// If we were blocked by the previous hex, see if we are able to look around the adjacent one if we split between them
; 478  : 			if (bBlocked)

	movzx	ecx, BYTE PTR _bBlocked$[ebp]
	test	ecx, ecx
	je	SHORT $LN31@CanSeeDisp@3

; 479  : 			{
; 480  : 				if (!straightThrough)	// If going along a single axis, we are looking directly down the middle of a hex so there is nothing to look around.

	movzx	edx, BYTE PTR _straightThrough$[ebp]
	test	edx, edx
	jne	SHORT $LN30@CanSeeDisp@3

; 481  : 				{
; 482  : 					CvPlot* passThroughPlot = PlotFromHex(kMap, startX + currentDX + ms_LookBackX[blockedDirection], startY + currentDY + ms_LookBackY[blockedDirection]);

	mov	eax, DWORD PTR _startY$[ebp]
	add	eax, DWORD PTR _currentDY$[ebp]
	mov	ecx, DWORD PTR _blockedDirection$[ebp]
	add	eax, DWORD PTR _ms_LookBackY[ecx*4]
	push	eax
	mov	edx, DWORD PTR _startX$[ebp]
	add	edx, DWORD PTR _currentDX$[ebp]
	mov	eax, DWORD PTR _blockedDirection$[ebp]
	add	edx, DWORD PTR _ms_LookBackX[eax*4]
	push	edx
	mov	ecx, DWORD PTR _kMap$[ebp]
	push	ecx
	call	?PlotFromHex@@YAPAVCvPlot@@AAVCvMap@@HH@Z ; PlotFromHex
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _passThroughPlot$217238[ebp], eax

; 483  : 					if(passThroughPlot)

	cmp	DWORD PTR _passThroughPlot$217238[ebp], 0
	je	SHORT $LN29@CanSeeDisp@3

; 484  : 					{
; 485  : 						TRACK_LAST_TARGET_PATH_ENTRY(passThroughPlot);
; 486  : 						bBlocked = (fromLevel < passThroughPlot->seeThroughLevel());

	push	1
	mov	ecx, DWORD PTR _passThroughPlot$217238[ebp]
	call	?seeThroughLevel@CvPlot@@QBEH_N@Z	; CvPlot::seeThroughLevel
	xor	edx, edx
	cmp	DWORD PTR _fromLevel$[ebp], eax
	setl	dl
	mov	BYTE PTR _bBlocked$[ebp], dl
$LN29@CanSeeDisp@3:

; 487  : 					}
; 488  : 
; 489  : 					if (bBlocked)

	movzx	eax, BYTE PTR _bBlocked$[ebp]
	test	eax, eax
	je	SHORT $LN28@CanSeeDisp@3

; 490  : 						return false;

	xor	al, al
	jmp	$LN51@CanSeeDisp@3
$LN28@CanSeeDisp@3:

; 491  : 				}
; 492  : 				else

	jmp	SHORT $LN31@CanSeeDisp@3
$LN30@CanSeeDisp@3:

; 493  : 					return false;

	xor	al, al
	jmp	$LN51@CanSeeDisp@3
$LN31@CanSeeDisp@3:

; 494  : 			}
; 495  : 
; 496  : 			// Don't test the destination, we only want to test the plots between the start and the destination
; 497  : 			if (currentDX == originalDX && currentDY == originalDY)

	mov	ecx, DWORD PTR _currentDX$[ebp]
	cmp	ecx, DWORD PTR _originalDX$[ebp]
	jne	SHORT $LN26@CanSeeDisp@3
	mov	edx, DWORD PTR _currentDY$[ebp]
	cmp	edx, DWORD PTR _originalDY$[ebp]
	jne	SHORT $LN26@CanSeeDisp@3

; 498  : 				break;	

	jmp	SHORT $LN44@CanSeeDisp@3
$LN26@CanSeeDisp@3:

; 499  : 
; 500  : 			CvPlot* passThroughPlot = PlotFromHex(kMap, startX + currentDX, startY + currentDY);

	mov	eax, DWORD PTR _startY$[ebp]
	add	eax, DWORD PTR _currentDY$[ebp]
	push	eax
	mov	ecx, DWORD PTR _startX$[ebp]
	add	ecx, DWORD PTR _currentDX$[ebp]
	push	ecx
	mov	edx, DWORD PTR _kMap$[ebp]
	push	edx
	call	?PlotFromHex@@YAPAVCvPlot@@AAVCvMap@@HH@Z ; PlotFromHex
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _passThroughPlot$217243[ebp], eax

; 501  : 			TRACK_LAST_TARGET_PATH_ENTRY(passThroughPlot);
; 502  : 			if(!passThroughPlot || fromLevel < passThroughPlot->seeThroughLevel())

	cmp	DWORD PTR _passThroughPlot$217243[ebp], 0
	je	SHORT $LN24@CanSeeDisp@3
	push	1
	mov	ecx, DWORD PTR _passThroughPlot$217243[ebp]
	call	?seeThroughLevel@CvPlot@@QBEH_N@Z	; CvPlot::seeThroughLevel
	cmp	DWORD PTR _fromLevel$[ebp], eax
	jge	SHORT $LN25@CanSeeDisp@3
$LN24@CanSeeDisp@3:

; 503  : 			{
; 504  : 				bBlocked = true;

	mov	BYTE PTR _bBlocked$[ebp], 1

; 505  : 				blockedDirection = ms_HexDirection[(currentDX - lastDX) + 1][(currentDY - lastDY) + 1];

	mov	eax, DWORD PTR _currentDX$[ebp]
	sub	eax, DWORD PTR _lastDX$[ebp]
	add	eax, 1
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _currentDY$[ebp]
	sub	ecx, DWORD PTR _lastDY$[ebp]
	mov	edx, DWORD PTR _ms_HexDirection[eax+ecx*4+4]
	mov	DWORD PTR _blockedDirection$[ebp], edx
$LN25@CanSeeDisp@3:

; 506  : 			}
; 507  : 
; 508  : 			lastDX = currentDX; lastDY = currentDY;

	mov	eax, DWORD PTR _currentDX$[ebp]
	mov	DWORD PTR _lastDX$[ebp], eax
	mov	ecx, DWORD PTR _currentDY$[ebp]
	mov	DWORD PTR _lastDY$[ebp], ecx

; 509  : 		}

	jmp	$LN45@CanSeeDisp@3
$LN44@CanSeeDisp@3:

; 510  : 	} 
; 511  : 	else 

	jmp	$LN23@CanSeeDisp@3
$LN46@CanSeeDisp@3:

; 512  : 	{
; 513  : 		// Y axis runs are longer, scan along them and adjust the X as needed.
; 514  : 		// The short axis step is primed slightly differently if the step ratio is 2:1
; 515  : 		// so that the initial step goes in a more favorable direction
; 516  : 		int shortAxisStepFactor = (dy!=dx && dx != 0 && (dy>>1) == dx)?((dy >> 1) - dx):(dy >> 1);

	mov	edx, DWORD PTR _dy$[ebp]
	cmp	edx, DWORD PTR _dx$[ebp]
	je	SHORT $LN55@CanSeeDisp@3
	cmp	DWORD PTR _dx$[ebp], 0
	je	SHORT $LN55@CanSeeDisp@3
	mov	eax, DWORD PTR _dy$[ebp]
	sar	eax, 1
	cmp	eax, DWORD PTR _dx$[ebp]
	jne	SHORT $LN55@CanSeeDisp@3
	mov	ecx, DWORD PTR _dy$[ebp]
	sar	ecx, 1
	sub	ecx, DWORD PTR _dx$[ebp]
	mov	DWORD PTR tv223[ebp], ecx
	jmp	SHORT $LN56@CanSeeDisp@3
$LN55@CanSeeDisp@3:
	mov	edx, DWORD PTR _dy$[ebp]
	sar	edx, 1
	mov	DWORD PTR tv223[ebp], edx
$LN56@CanSeeDisp@3:
	mov	eax, DWORD PTR tv223[ebp]
	mov	DWORD PTR _shortAxisStepFactor$217247[ebp], eax
$LN22@CanSeeDisp@3:

; 517  : 		//int fraction = (dy >> 1);
; 518  : 		while (currentDY != originalDY) 

	mov	ecx, DWORD PTR _currentDY$[ebp]
	cmp	ecx, DWORD PTR _originalDY$[ebp]
	je	$LN23@CanSeeDisp@3

; 519  : 		{
; 520  : 			shortAxisStepFactor += dx;

	mov	edx, DWORD PTR _shortAxisStepFactor$217247[ebp]
	add	edx, DWORD PTR _dx$[ebp]
	mov	DWORD PTR _shortAxisStepFactor$217247[ebp], edx

; 521  : 
; 522  : 			if (shortAxisStepFactor >= dy) 

	mov	eax, DWORD PTR _shortAxisStepFactor$217247[ebp]
	cmp	eax, DWORD PTR _dy$[ebp]
	jl	$LN20@CanSeeDisp@3

; 523  : 			{
; 524  : 				shortAxisStepFactor -= dy;

	mov	ecx, DWORD PTR _shortAxisStepFactor$217247[ebp]
	sub	ecx, DWORD PTR _dy$[ebp]
	mov	DWORD PTR _shortAxisStepFactor$217247[ebp], ecx

; 525  : 
; 526  : 				if (oddQuadrant)

	movzx	edx, BYTE PTR _oddQuadrant$[ebp]
	test	edx, edx
	je	SHORT $LN19@CanSeeDisp@3

; 527  : 				{
; 528  : 					// A change in the X and Y axis will yield a contiguous line
; 529  : 					currentDX += stepX;

	mov	eax, DWORD PTR _currentDX$[ebp]
	add	eax, DWORD PTR _stepX$[ebp]
	mov	DWORD PTR _currentDX$[ebp], eax

; 530  : 					currentDY += stepY;

	mov	ecx, DWORD PTR _currentDY$[ebp]
	add	ecx, DWORD PTR _stepY$[ebp]
	mov	DWORD PTR _currentDY$[ebp], ecx

; 531  : 				}
; 532  : 				else

	jmp	$LN18@CanSeeDisp@3
$LN19@CanSeeDisp@3:

; 533  : 				{
; 534  : 					// Adjust just the X axis, then check so that the line is contiguous.
; 535  : 					currentDX += stepX;

	mov	edx, DWORD PTR _currentDX$[ebp]
	add	edx, DWORD PTR _stepX$[ebp]
	mov	DWORD PTR _currentDX$[ebp], edx

; 536  : 
; 537  : 					// If we were blocked by the previous hex, see if we are able to look around the adjacent one if we split between them
; 538  : 					if (bBlocked)

	movzx	eax, BYTE PTR _bBlocked$[ebp]
	test	eax, eax
	je	SHORT $LN17@CanSeeDisp@3

; 539  : 					{
; 540  : 						if (!straightThrough)	// If going along a single axis, we are looking directly down the middle of a hex so there is nothing to look around.

	movzx	ecx, BYTE PTR _straightThrough$[ebp]
	test	ecx, ecx
	jne	SHORT $LN16@CanSeeDisp@3

; 541  : 						{
; 542  : 							CvPlot* passThroughPlot = PlotFromHex(kMap, startX + currentDX + ms_LookBackX[blockedDirection], startY + currentDY + ms_LookBackY[blockedDirection]);

	mov	edx, DWORD PTR _startY$[ebp]
	add	edx, DWORD PTR _currentDY$[ebp]
	mov	eax, DWORD PTR _blockedDirection$[ebp]
	add	edx, DWORD PTR _ms_LookBackY[eax*4]
	push	edx
	mov	ecx, DWORD PTR _startX$[ebp]
	add	ecx, DWORD PTR _currentDX$[ebp]
	mov	edx, DWORD PTR _blockedDirection$[ebp]
	add	ecx, DWORD PTR _ms_LookBackX[edx*4]
	push	ecx
	mov	eax, DWORD PTR _kMap$[ebp]
	push	eax
	call	?PlotFromHex@@YAPAVCvPlot@@AAVCvMap@@HH@Z ; PlotFromHex
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _passThroughPlot$217256[ebp], eax

; 543  : 							if(passThroughPlot)

	cmp	DWORD PTR _passThroughPlot$217256[ebp], 0
	je	SHORT $LN15@CanSeeDisp@3

; 544  : 							{
; 545  : 								TRACK_LAST_TARGET_PATH_ENTRY(passThroughPlot);
; 546  : 								bBlocked = (fromLevel < passThroughPlot->seeThroughLevel());

	push	1
	mov	ecx, DWORD PTR _passThroughPlot$217256[ebp]
	call	?seeThroughLevel@CvPlot@@QBEH_N@Z	; CvPlot::seeThroughLevel
	xor	ecx, ecx
	cmp	DWORD PTR _fromLevel$[ebp], eax
	setl	cl
	mov	BYTE PTR _bBlocked$[ebp], cl
$LN15@CanSeeDisp@3:

; 547  : 							}
; 548  : 
; 549  : 							if (bBlocked)

	movzx	edx, BYTE PTR _bBlocked$[ebp]
	test	edx, edx
	je	SHORT $LN14@CanSeeDisp@3

; 550  : 								return false;

	xor	al, al
	jmp	$LN51@CanSeeDisp@3
$LN14@CanSeeDisp@3:

; 551  : 						}
; 552  : 						else

	jmp	SHORT $LN17@CanSeeDisp@3
$LN16@CanSeeDisp@3:

; 553  : 							return false;

	xor	al, al
	jmp	$LN51@CanSeeDisp@3
$LN17@CanSeeDisp@3:

; 554  : 					}
; 555  : 
; 556  : 					// Don't test the destination, we only want to test the plots between the start and the destination
; 557  : 					if (currentDX == originalDX && currentDY == originalDY)

	mov	eax, DWORD PTR _currentDX$[ebp]
	cmp	eax, DWORD PTR _originalDX$[ebp]
	jne	SHORT $LN12@CanSeeDisp@3
	mov	ecx, DWORD PTR _currentDY$[ebp]
	cmp	ecx, DWORD PTR _originalDY$[ebp]
	jne	SHORT $LN12@CanSeeDisp@3

; 558  : 						break;	

	jmp	$LN23@CanSeeDisp@3
$LN12@CanSeeDisp@3:

; 559  : 
; 560  : 					CvPlot* passThroughPlot = PlotFromHex(kMap, startX + currentDX, startY + currentDY);

	mov	edx, DWORD PTR _startY$[ebp]
	add	edx, DWORD PTR _currentDY$[ebp]
	push	edx
	mov	eax, DWORD PTR _startX$[ebp]
	add	eax, DWORD PTR _currentDX$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kMap$[ebp]
	push	ecx
	call	?PlotFromHex@@YAPAVCvPlot@@AAVCvMap@@HH@Z ; PlotFromHex
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _passThroughPlot$217261[ebp], eax

; 561  : 					TRACK_LAST_TARGET_PATH_ENTRY(passThroughPlot);
; 562  : 					if(!passThroughPlot || fromLevel < passThroughPlot->seeThroughLevel())

	cmp	DWORD PTR _passThroughPlot$217261[ebp], 0
	je	SHORT $LN10@CanSeeDisp@3
	push	1
	mov	ecx, DWORD PTR _passThroughPlot$217261[ebp]
	call	?seeThroughLevel@CvPlot@@QBEH_N@Z	; CvPlot::seeThroughLevel
	cmp	DWORD PTR _fromLevel$[ebp], eax
	jge	SHORT $LN11@CanSeeDisp@3
$LN10@CanSeeDisp@3:

; 563  : 					{
; 564  : 						bBlocked = true;

	mov	BYTE PTR _bBlocked$[ebp], 1

; 565  : 						blockedDirection = ms_HexDirection[(currentDX - lastDX) + 1][(currentDY - lastDY) + 1];

	mov	edx, DWORD PTR _currentDX$[ebp]
	sub	edx, DWORD PTR _lastDX$[ebp]
	add	edx, 1
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _currentDY$[ebp]
	sub	eax, DWORD PTR _lastDY$[ebp]
	mov	ecx, DWORD PTR _ms_HexDirection[edx+eax*4+4]
	mov	DWORD PTR _blockedDirection$[ebp], ecx
$LN11@CanSeeDisp@3:

; 566  : 					}
; 567  : 
; 568  : 					lastDX = currentDX; lastDY = currentDY;

	mov	edx, DWORD PTR _currentDX$[ebp]
	mov	DWORD PTR _lastDX$[ebp], edx
	mov	eax, DWORD PTR _currentDY$[ebp]
	mov	DWORD PTR _lastDY$[ebp], eax

; 569  : 
; 570  : 					currentDY += stepY;

	mov	ecx, DWORD PTR _currentDY$[ebp]
	add	ecx, DWORD PTR _stepY$[ebp]
	mov	DWORD PTR _currentDY$[ebp], ecx
$LN18@CanSeeDisp@3:

; 571  : 				}
; 572  : 			}
; 573  : 			else

	jmp	SHORT $LN9@CanSeeDisp@3
$LN20@CanSeeDisp@3:

; 574  : 				currentDY += stepY;

	mov	edx, DWORD PTR _currentDY$[ebp]
	add	edx, DWORD PTR _stepY$[ebp]
	mov	DWORD PTR _currentDY$[ebp], edx
$LN9@CanSeeDisp@3:

; 575  : 
; 576  : 			// If we were blocked by the previous hex, see if we are able to look around the adjacent one if we split between them
; 577  : 			if (bBlocked)

	movzx	eax, BYTE PTR _bBlocked$[ebp]
	test	eax, eax
	je	SHORT $LN8@CanSeeDisp@3

; 578  : 			{
; 579  : 				if (!straightThrough)	// If going along a single axis, we are looking directly down the middle of a hex so there is nothing to look around.

	movzx	ecx, BYTE PTR _straightThrough$[ebp]
	test	ecx, ecx
	jne	SHORT $LN7@CanSeeDisp@3

; 580  : 				{
; 581  : 					CvPlot* passThroughPlot = PlotFromHex(kMap, startX + currentDX + ms_LookBackX[blockedDirection], startY + currentDY + ms_LookBackY[blockedDirection]);

	mov	edx, DWORD PTR _startY$[ebp]
	add	edx, DWORD PTR _currentDY$[ebp]
	mov	eax, DWORD PTR _blockedDirection$[ebp]
	add	edx, DWORD PTR _ms_LookBackY[eax*4]
	push	edx
	mov	ecx, DWORD PTR _startX$[ebp]
	add	ecx, DWORD PTR _currentDX$[ebp]
	mov	edx, DWORD PTR _blockedDirection$[ebp]
	add	ecx, DWORD PTR _ms_LookBackX[edx*4]
	push	ecx
	mov	eax, DWORD PTR _kMap$[ebp]
	push	eax
	call	?PlotFromHex@@YAPAVCvPlot@@AAVCvMap@@HH@Z ; PlotFromHex
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _passThroughPlot$217267[ebp], eax

; 582  : 					if(passThroughPlot)

	cmp	DWORD PTR _passThroughPlot$217267[ebp], 0
	je	SHORT $LN6@CanSeeDisp@3

; 583  : 					{
; 584  : 						TRACK_LAST_TARGET_PATH_ENTRY(passThroughPlot);
; 585  : 						bBlocked = (fromLevel < passThroughPlot->seeThroughLevel());

	push	1
	mov	ecx, DWORD PTR _passThroughPlot$217267[ebp]
	call	?seeThroughLevel@CvPlot@@QBEH_N@Z	; CvPlot::seeThroughLevel
	xor	ecx, ecx
	cmp	DWORD PTR _fromLevel$[ebp], eax
	setl	cl
	mov	BYTE PTR _bBlocked$[ebp], cl
$LN6@CanSeeDisp@3:

; 586  : 					}
; 587  : 
; 588  : 					if (bBlocked)

	movzx	edx, BYTE PTR _bBlocked$[ebp]
	test	edx, edx
	je	SHORT $LN5@CanSeeDisp@3

; 589  : 						return false;

	xor	al, al
	jmp	SHORT $LN51@CanSeeDisp@3
$LN5@CanSeeDisp@3:

; 590  : 				}
; 591  : 				else

	jmp	SHORT $LN8@CanSeeDisp@3
$LN7@CanSeeDisp@3:

; 592  : 					return false;

	xor	al, al
	jmp	SHORT $LN51@CanSeeDisp@3
$LN8@CanSeeDisp@3:

; 593  : 			}
; 594  : 
; 595  : 			// Don't test the destination, we only want to test the plots between the start and the destination
; 596  : 			if (currentDX == originalDX && currentDY == originalDY)

	mov	eax, DWORD PTR _currentDX$[ebp]
	cmp	eax, DWORD PTR _originalDX$[ebp]
	jne	SHORT $LN3@CanSeeDisp@3
	mov	ecx, DWORD PTR _currentDY$[ebp]
	cmp	ecx, DWORD PTR _originalDY$[ebp]
	jne	SHORT $LN3@CanSeeDisp@3

; 597  : 				break;	

	jmp	SHORT $LN23@CanSeeDisp@3
$LN3@CanSeeDisp@3:

; 598  : 
; 599  : 			CvPlot* passThroughPlot = PlotFromHex(kMap, startX + currentDX, startY + currentDY);

	mov	edx, DWORD PTR _startY$[ebp]
	add	edx, DWORD PTR _currentDY$[ebp]
	push	edx
	mov	eax, DWORD PTR _startX$[ebp]
	add	eax, DWORD PTR _currentDX$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kMap$[ebp]
	push	ecx
	call	?PlotFromHex@@YAPAVCvPlot@@AAVCvMap@@HH@Z ; PlotFromHex
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _passThroughPlot$217272[ebp], eax

; 600  : 			TRACK_LAST_TARGET_PATH_ENTRY(passThroughPlot);
; 601  : 			if(!passThroughPlot || fromLevel < passThroughPlot->seeThroughLevel())

	cmp	DWORD PTR _passThroughPlot$217272[ebp], 0
	je	SHORT $LN1@CanSeeDisp@3
	push	1
	mov	ecx, DWORD PTR _passThroughPlot$217272[ebp]
	call	?seeThroughLevel@CvPlot@@QBEH_N@Z	; CvPlot::seeThroughLevel
	cmp	DWORD PTR _fromLevel$[ebp], eax
	jge	SHORT $LN2@CanSeeDisp@3
$LN1@CanSeeDisp@3:

; 602  : 			{
; 603  : 				bBlocked = true;

	mov	BYTE PTR _bBlocked$[ebp], 1

; 604  : 				blockedDirection = ms_HexDirection[(currentDX - lastDX) + 1][(currentDY - lastDY) + 1];

	mov	edx, DWORD PTR _currentDX$[ebp]
	sub	edx, DWORD PTR _lastDX$[ebp]
	add	edx, 1
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _currentDY$[ebp]
	sub	eax, DWORD PTR _lastDY$[ebp]
	mov	ecx, DWORD PTR _ms_HexDirection[edx+eax*4+4]
	mov	DWORD PTR _blockedDirection$[ebp], ecx
$LN2@CanSeeDisp@3:

; 605  : 			}
; 606  : 
; 607  : 			lastDX = currentDX; lastDY = currentDY;

	mov	edx, DWORD PTR _currentDX$[ebp]
	mov	DWORD PTR _lastDX$[ebp], edx
	mov	eax, DWORD PTR _currentDY$[ebp]
	mov	DWORD PTR _lastDY$[ebp], eax

; 608  : 		}

	jmp	$LN22@CanSeeDisp@3
$LN23@CanSeeDisp@3:

; 609  : 	}
; 610  : 
; 611  : 	return true;

	mov	al, 1
$LN51@CanSeeDisp@3:

; 612  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CanSeeDisplacementPlot_Loose@@YA_NHHHHH@Z ENDP		; CanSeeDisplacementPlot_Loose
_TEXT	ENDS
END
