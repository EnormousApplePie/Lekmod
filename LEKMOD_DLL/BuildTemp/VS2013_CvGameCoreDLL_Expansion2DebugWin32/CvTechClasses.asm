; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvTechClasses.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BB@FFPEIGMF@TECH_FUTURE_TECH?$AA@	; `string'
PUBLIC	??_C@_0BE@PFFFIOCE@TECH_NUCLEAR_FUSION?$AA@	; `string'
PUBLIC	??_C@_0BE@EMEGLPJH@TECH_NANOTECHNOLOGY?$AA@	; `string'
PUBLIC	??_C@_0BG@HIHFFJIG@TECH_PARTICLE_PHYSICS?$AA@	; `string'
PUBLIC	??_C@_0BJ@IOAIODDB@TECH_ADVANCED_BALLISTICS?$AA@ ; `string'
PUBLIC	??_C@_0M@OKPBDOAB@TECH_LASERS?$AA@		; `string'
PUBLIC	??_C@_0BE@JPGFFPKB@TECH_MOBILE_TACTICS?$AA@	; `string'
PUBLIC	??_C@_0N@EKLGOFCE@TECH_STEALTH?$AA@		; `string'
PUBLIC	??_C@_0BA@LBHEJNAN@TECH_SATELLITES?$AA@		; `string'
PUBLIC	??_C@_0O@JKGOIGID@TECH_ROBOTICS?$AA@		; `string'
PUBLIC	??_C@_0BD@IIIMIMMC@TECH_GLOBALIZATION?$AA@	; `string'
PUBLIC	??_C@_0BF@PMILJPKG@TECH_NUCLEAR_FISSION?$AA@	; `string'
PUBLIC	??_C@_0O@LPHANPJM@TECH_ROCKETRY?$AA@		; `string'
PUBLIC	??_C@_0N@GGDCCEMN@TECH_TELECOM?$AA@		; `string'
PUBLIC	??_C@_0P@BCOCBDKL@TECH_COMPUTERS?$AA@		; `string'
PUBLIC	??_C@_0N@FEBMAJMI@TECH_ECOLOGY?$AA@		; `string'
PUBLIC	??_C@_0BD@GFKOIOEC@TECH_ATOMIC_THEORY?$AA@	; `string'
PUBLIC	??_C@_0BD@HHJCHIND@TECH_COMBINED_ARMS?$AA@	; `string'
PUBLIC	??_C@_0L@CFAAJMNL@TECH_RADAR?$AA@		; `string'
PUBLIC	??_C@_0BB@EOBHCNAL@TECH_ELECTRONICS?$AA@	; `string'
PUBLIC	??_C@_0P@OIHEKAJC@TECH_PENICILIN?$AA@		; `string'
PUBLIC	??_C@_0N@HDBOCAAC@TECH_PLASTIC?$AA@		; `string'
PUBLIC	??_C@_0BA@MDNDMIKO@TECH_COMBUSTION?$AA@		; `string'
PUBLIC	??_C@_0BA@EIGNECGO@TECH_BALLISTICS?$AA@		; `string'
PUBLIC	??_C@_0M@CMLGIFFI@TECH_FLIGHT?$AA@		; `string'
PUBLIC	??_C@_0L@NEHPKBHP@TECH_RADIO?$AA@		; `string'
PUBLIC	??_C@_0BE@FFEPPPHF@TECH_HYDROELECTRICS?$AA@	; `string'
PUBLIC	??_C@_0BD@CLJFKPHA@TECH_REFRIGERATION?$AA@	; `string'
PUBLIC	??_C@_0O@KHFLEIGB@TECH_RAILROAD?$AA@		; `string'
PUBLIC	??_C@_0BH@MKPELENP@TECH_REPLACEABLE_PARTS?$AA@	; `string'
PUBLIC	??_C@_0BB@IDFIFHNI@TECH_ELECTRICITY?$AA@	; `string'
PUBLIC	??_C@_0O@GKMLHLAB@TECH_DYNAMITE?$AA@		; `string'
PUBLIC	??_C@_0BB@PHGCNHHO@TECH_STEAM_POWER?$AA@	; `string'
PUBLIC	??_C@_0N@PKKJFPJP@TECH_BIOLOGY?$AA@		; `string'
PUBLIC	??_C@_0BA@PMJHEBE@TECH_FERTILIZER?$AA@		; `string'
PUBLIC	??_C@_0N@FPOGGEPA@TECH_RIFLING?$AA@		; `string'
PUBLIC	??_C@_0BG@EJGDFPPF@TECH_MILITARY_SCIENCE?$AA@	; `string'
PUBLIC	??_C@_0BH@MGMKHAML@TECH_INDUSTRIALIZATION?$AA@	; `string'
PUBLIC	??_C@_0BH@PCFMKOBM@TECH_SCIENTIFIC_THEORY?$AA@	; `string'
PUBLIC	??_C@_0BB@KLFMGMG@TECH_ARCHAEOLOGY?$AA@		; `string'
PUBLIC	??_C@_0P@HHBBFOFJ@TECH_CHEMISTRY?$AA@		; `string'
PUBLIC	??_C@_0BA@LJEFMFPL@TECH_METALLURGY?$AA@		; `string'
PUBLIC	??_C@_0P@BEIDNCOH@TECH_ECONOMICS?$AA@		; `string'
PUBLIC	??_C@_0BC@EAJJMBFD@TECH_ARCHITECTURE?$AA@	; `string'
PUBLIC	??_C@_0BA@NLCOFLJH@TECH_NAVIGATION?$AA@		; `string'
PUBLIC	??_C@_0P@PBELMECB@TECH_GUNPOWDER?$AA@		; `string'
PUBLIC	??_C@_0BE@EJIFHDMN@TECH_PRINTING_PRESS?$AA@	; `string'
PUBLIC	??_C@_0N@EOMBEFMB@TECH_BANKING?$AA@		; `string'
PUBLIC	??_C@_0P@GBFFINLK@TECH_ACOUSTICS?$AA@		; `string'
PUBLIC	??_C@_0P@KCLNALKH@TECH_ASTRONOMY?$AA@		; `string'
PUBLIC	??_C@_0L@CNKIKHOK@TECH_STEEL?$AA@		; `string'
PUBLIC	??_C@_0N@INPCJMCC@TECH_PHYSICS?$AA@		; `string'
PUBLIC	??_C@_0P@CBPJJNFI@TECH_MACHINERY?$AA@		; `string'
PUBLIC	??_C@_0O@HFBLBHAM@TECH_CHIVALRY?$AA@		; `string'
PUBLIC	??_C@_0P@FNMCPCPG@TECH_EDUCATION?$AA@		; `string'
PUBLIC	??_C@_0N@LMBECFKG@TECH_COMPASS?$AA@		; `string'
PUBLIC	??_C@_0BD@DDPCCAFE@TECH_METAL_CASTING?$AA@	; `string'
PUBLIC	??_C@_0M@DPECDFBN@TECH_GUILDS?$AA@		; `string'
PUBLIC	??_C@_0BD@DHKNNHNJ@TECH_CIVIL_SERVICE?$AA@	; `string'
PUBLIC	??_C@_0O@KOALALFH@TECH_THEOLOGY?$AA@		; `string'
PUBLIC	??_C@_0BC@PPEEJCDE@TECH_IRON_WORKING?$AA@	; `string'
PUBLIC	??_C@_0BB@OKFPFMCJ@TECH_ENGINEERING?$AA@	; `string'
PUBLIC	??_C@_0O@COIABONI@TECH_CURRENCY?$AA@		; `string'
PUBLIC	??_C@_0L@IIOENIML@TECH_DRAMA?$AA@		; `string'
PUBLIC	??_C@_0BA@KHDONNDG@TECH_PHILOSOPHY?$AA@		; `string'
PUBLIC	??_C@_0BC@LHFDJOLC@TECH_CONSTRUCTION?$AA@	; `string'
PUBLIC	??_C@_0BB@PIGLFBDI@TECH_MATHEMATICS?$AA@	; `string'
PUBLIC	??_C@_0BG@BHCMNEIE@TECH_HORSEBACK_RIDING?$AA@	; `string'
PUBLIC	??_C@_0M@PGIBFPEN@TECH_OPTICS?$AA@		; `string'
PUBLIC	??_C@_0BE@LNKOLOKH@TECH_BRONZE_WORKING?$AA@	; `string'
PUBLIC	??_C@_0N@IBIDLNJK@TECH_MASONRY?$AA@		; `string'
PUBLIC	??_C@_0P@KKLHOPEM@TECH_THE_WHEEL?$AA@		; `string'
PUBLIC	??_C@_0O@BOFEJDOG@TECH_TRAPPING?$AA@		; `string'
PUBLIC	??_C@_0N@NDBJMMDG@TECH_WRITING?$AA@		; `string'
PUBLIC	??_C@_0O@HFOCIGJ@TECH_CALENDAR?$AA@		; `string'
PUBLIC	??_C@_0N@FBPFJINM@TECH_SAILING?$AA@		; `string'
PUBLIC	??_C@_0M@EJOBNGBC@TECH_MINING?$AA@		; `string'
PUBLIC	??_C@_0N@OGONHHAM@TECH_ARCHERY?$AA@		; `string'
PUBLIC	??_C@_0BG@DCCALJP@TECH_ANIMAL_HUSBANDRY?$AA@	; `string'
PUBLIC	??_C@_0N@OLDGPDBH@TECH_POTTERY?$AA@		; `string'
PUBLIC	??_C@_0BB@DKMCOOLJ@TECH_AGRICULTURE?$AA@	; `string'
PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
PUBLIC	?ms_V0ExpansionTechTags@@3PAPBDA		; ms_V0ExpansionTechTags
_DATA	SEGMENT
?ms_V0ExpansionTechTags@@3PAPBDA DD FLAT:??_C@_0BB@DKMCOOLJ@TECH_AGRICULTURE?$AA@ ; ms_V0ExpansionTechTags
	DD	FLAT:??_C@_0N@OLDGPDBH@TECH_POTTERY?$AA@
	DD	FLAT:??_C@_0BG@DCCALJP@TECH_ANIMAL_HUSBANDRY?$AA@
	DD	FLAT:??_C@_0N@OGONHHAM@TECH_ARCHERY?$AA@
	DD	FLAT:??_C@_0M@EJOBNGBC@TECH_MINING?$AA@
	DD	FLAT:??_C@_0N@FBPFJINM@TECH_SAILING?$AA@
	DD	FLAT:??_C@_0O@HFOCIGJ@TECH_CALENDAR?$AA@
	DD	FLAT:??_C@_0N@NDBJMMDG@TECH_WRITING?$AA@
	DD	FLAT:??_C@_0O@BOFEJDOG@TECH_TRAPPING?$AA@
	DD	FLAT:??_C@_0P@KKLHOPEM@TECH_THE_WHEEL?$AA@
	DD	FLAT:??_C@_0N@IBIDLNJK@TECH_MASONRY?$AA@
	DD	FLAT:??_C@_0BE@LNKOLOKH@TECH_BRONZE_WORKING?$AA@
	DD	FLAT:??_C@_0M@PGIBFPEN@TECH_OPTICS?$AA@
	DD	FLAT:??_C@_0BG@BHCMNEIE@TECH_HORSEBACK_RIDING?$AA@
	DD	FLAT:??_C@_0BB@PIGLFBDI@TECH_MATHEMATICS?$AA@
	DD	FLAT:??_C@_0BC@LHFDJOLC@TECH_CONSTRUCTION?$AA@
	DD	FLAT:??_C@_0BA@KHDONNDG@TECH_PHILOSOPHY?$AA@
	DD	FLAT:??_C@_0L@IIOENIML@TECH_DRAMA?$AA@
	DD	FLAT:??_C@_0O@COIABONI@TECH_CURRENCY?$AA@
	DD	FLAT:??_C@_0BB@OKFPFMCJ@TECH_ENGINEERING?$AA@
	DD	FLAT:??_C@_0BC@PPEEJCDE@TECH_IRON_WORKING?$AA@
	DD	FLAT:??_C@_0O@KOALALFH@TECH_THEOLOGY?$AA@
	DD	FLAT:??_C@_0BD@DHKNNHNJ@TECH_CIVIL_SERVICE?$AA@
	DD	FLAT:??_C@_0M@DPECDFBN@TECH_GUILDS?$AA@
	DD	FLAT:??_C@_0BD@DDPCCAFE@TECH_METAL_CASTING?$AA@
	DD	FLAT:??_C@_0N@LMBECFKG@TECH_COMPASS?$AA@
	DD	FLAT:??_C@_0P@FNMCPCPG@TECH_EDUCATION?$AA@
	DD	FLAT:??_C@_0O@HFBLBHAM@TECH_CHIVALRY?$AA@
	DD	FLAT:??_C@_0P@CBPJJNFI@TECH_MACHINERY?$AA@
	DD	FLAT:??_C@_0N@INPCJMCC@TECH_PHYSICS?$AA@
	DD	FLAT:??_C@_0L@CNKIKHOK@TECH_STEEL?$AA@
	DD	FLAT:??_C@_0P@KCLNALKH@TECH_ASTRONOMY?$AA@
	DD	FLAT:??_C@_0P@GBFFINLK@TECH_ACOUSTICS?$AA@
	DD	FLAT:??_C@_0N@EOMBEFMB@TECH_BANKING?$AA@
	DD	FLAT:??_C@_0BE@EJIFHDMN@TECH_PRINTING_PRESS?$AA@
	DD	FLAT:??_C@_0P@PBELMECB@TECH_GUNPOWDER?$AA@
	DD	FLAT:??_C@_0BA@NLCOFLJH@TECH_NAVIGATION?$AA@
	DD	FLAT:??_C@_0BC@EAJJMBFD@TECH_ARCHITECTURE?$AA@
	DD	FLAT:??_C@_0P@BEIDNCOH@TECH_ECONOMICS?$AA@
	DD	FLAT:??_C@_0BA@LJEFMFPL@TECH_METALLURGY?$AA@
	DD	FLAT:??_C@_0P@HHBBFOFJ@TECH_CHEMISTRY?$AA@
	DD	FLAT:??_C@_0BB@KLFMGMG@TECH_ARCHAEOLOGY?$AA@
	DD	FLAT:??_C@_0BH@PCFMKOBM@TECH_SCIENTIFIC_THEORY?$AA@
	DD	FLAT:??_C@_0BH@MGMKHAML@TECH_INDUSTRIALIZATION?$AA@
	DD	FLAT:??_C@_0BG@EJGDFPPF@TECH_MILITARY_SCIENCE?$AA@
	DD	FLAT:??_C@_0N@FPOGGEPA@TECH_RIFLING?$AA@
	DD	FLAT:??_C@_0BA@PMJHEBE@TECH_FERTILIZER?$AA@
	DD	FLAT:??_C@_0N@PKKJFPJP@TECH_BIOLOGY?$AA@
	DD	FLAT:??_C@_0BB@PHGCNHHO@TECH_STEAM_POWER?$AA@
	DD	FLAT:??_C@_0O@GKMLHLAB@TECH_DYNAMITE?$AA@
	DD	FLAT:??_C@_0BB@IDFIFHNI@TECH_ELECTRICITY?$AA@
	DD	FLAT:??_C@_0BH@MKPELENP@TECH_REPLACEABLE_PARTS?$AA@
	DD	FLAT:??_C@_0O@KHFLEIGB@TECH_RAILROAD?$AA@
	DD	FLAT:??_C@_0BD@CLJFKPHA@TECH_REFRIGERATION?$AA@
	DD	FLAT:??_C@_0BE@FFEPPPHF@TECH_HYDROELECTRICS?$AA@
	DD	FLAT:??_C@_0L@NEHPKBHP@TECH_RADIO?$AA@
	DD	FLAT:??_C@_0M@CMLGIFFI@TECH_FLIGHT?$AA@
	DD	FLAT:??_C@_0BA@EIGNECGO@TECH_BALLISTICS?$AA@
	DD	FLAT:??_C@_0BA@MDNDMIKO@TECH_COMBUSTION?$AA@
	DD	FLAT:??_C@_0N@HDBOCAAC@TECH_PLASTIC?$AA@
	DD	FLAT:??_C@_0P@OIHEKAJC@TECH_PENICILIN?$AA@
	DD	FLAT:??_C@_0BB@EOBHCNAL@TECH_ELECTRONICS?$AA@
	DD	FLAT:??_C@_0L@CFAAJMNL@TECH_RADAR?$AA@
	DD	FLAT:??_C@_0BD@HHJCHIND@TECH_COMBINED_ARMS?$AA@
	DD	FLAT:??_C@_0BD@GFKOIOEC@TECH_ATOMIC_THEORY?$AA@
	DD	FLAT:??_C@_0N@FEBMAJMI@TECH_ECOLOGY?$AA@
	DD	FLAT:??_C@_0P@BCOCBDKL@TECH_COMPUTERS?$AA@
	DD	FLAT:??_C@_0N@GGDCCEMN@TECH_TELECOM?$AA@
	DD	FLAT:??_C@_0O@LPHANPJM@TECH_ROCKETRY?$AA@
	DD	FLAT:??_C@_0BF@PMILJPKG@TECH_NUCLEAR_FISSION?$AA@
	DD	FLAT:??_C@_0BD@IIIMIMMC@TECH_GLOBALIZATION?$AA@
	DD	FLAT:??_C@_0O@JKGOIGID@TECH_ROBOTICS?$AA@
	DD	FLAT:??_C@_0BA@LBHEJNAN@TECH_SATELLITES?$AA@
	DD	FLAT:??_C@_0N@EKLGOFCE@TECH_STEALTH?$AA@
	DD	FLAT:??_C@_0BE@JPGFFPKB@TECH_MOBILE_TACTICS?$AA@
	DD	FLAT:??_C@_0M@OKPBDOAB@TECH_LASERS?$AA@
	DD	FLAT:??_C@_0BJ@IOAIODDB@TECH_ADVANCED_BALLISTICS?$AA@
	DD	FLAT:??_C@_0BG@HIHFFJIG@TECH_PARTICLE_PHYSICS?$AA@
	DD	FLAT:??_C@_0BE@EMEGLPJH@TECH_NANOTECHNOLOGY?$AA@
	DD	FLAT:??_C@_0BE@PFFFIOCE@TECH_NUCLEAR_FUSION?$AA@
	DD	FLAT:??_C@_0BB@FFPEIGMF@TECH_FUTURE_TECH?$AA@
_DATA	ENDS
;	COMDAT ??_C@_0BB@FFPEIGMF@TECH_FUTURE_TECH?$AA@
CONST	SEGMENT
??_C@_0BB@FFPEIGMF@TECH_FUTURE_TECH?$AA@ DB 'TECH_FUTURE_TECH', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PFFFIOCE@TECH_NUCLEAR_FUSION?$AA@
CONST	SEGMENT
??_C@_0BE@PFFFIOCE@TECH_NUCLEAR_FUSION?$AA@ DB 'TECH_NUCLEAR_FUSION', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EMEGLPJH@TECH_NANOTECHNOLOGY?$AA@
CONST	SEGMENT
??_C@_0BE@EMEGLPJH@TECH_NANOTECHNOLOGY?$AA@ DB 'TECH_NANOTECHNOLOGY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HIHFFJIG@TECH_PARTICLE_PHYSICS?$AA@
CONST	SEGMENT
??_C@_0BG@HIHFFJIG@TECH_PARTICLE_PHYSICS?$AA@ DB 'TECH_PARTICLE_PHYSICS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@IOAIODDB@TECH_ADVANCED_BALLISTICS?$AA@
CONST	SEGMENT
??_C@_0BJ@IOAIODDB@TECH_ADVANCED_BALLISTICS?$AA@ DB 'TECH_ADVANCED_BALLIS'
	DB	'TICS', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OKPBDOAB@TECH_LASERS?$AA@
CONST	SEGMENT
??_C@_0M@OKPBDOAB@TECH_LASERS?$AA@ DB 'TECH_LASERS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JPGFFPKB@TECH_MOBILE_TACTICS?$AA@
CONST	SEGMENT
??_C@_0BE@JPGFFPKB@TECH_MOBILE_TACTICS?$AA@ DB 'TECH_MOBILE_TACTICS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EKLGOFCE@TECH_STEALTH?$AA@
CONST	SEGMENT
??_C@_0N@EKLGOFCE@TECH_STEALTH?$AA@ DB 'TECH_STEALTH', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LBHEJNAN@TECH_SATELLITES?$AA@
CONST	SEGMENT
??_C@_0BA@LBHEJNAN@TECH_SATELLITES?$AA@ DB 'TECH_SATELLITES', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JKGOIGID@TECH_ROBOTICS?$AA@
CONST	SEGMENT
??_C@_0O@JKGOIGID@TECH_ROBOTICS?$AA@ DB 'TECH_ROBOTICS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IIIMIMMC@TECH_GLOBALIZATION?$AA@
CONST	SEGMENT
??_C@_0BD@IIIMIMMC@TECH_GLOBALIZATION?$AA@ DB 'TECH_GLOBALIZATION', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PMILJPKG@TECH_NUCLEAR_FISSION?$AA@
CONST	SEGMENT
??_C@_0BF@PMILJPKG@TECH_NUCLEAR_FISSION?$AA@ DB 'TECH_NUCLEAR_FISSION', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LPHANPJM@TECH_ROCKETRY?$AA@
CONST	SEGMENT
??_C@_0O@LPHANPJM@TECH_ROCKETRY?$AA@ DB 'TECH_ROCKETRY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GGDCCEMN@TECH_TELECOM?$AA@
CONST	SEGMENT
??_C@_0N@GGDCCEMN@TECH_TELECOM?$AA@ DB 'TECH_TELECOM', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BCOCBDKL@TECH_COMPUTERS?$AA@
CONST	SEGMENT
??_C@_0P@BCOCBDKL@TECH_COMPUTERS?$AA@ DB 'TECH_COMPUTERS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FEBMAJMI@TECH_ECOLOGY?$AA@
CONST	SEGMENT
??_C@_0N@FEBMAJMI@TECH_ECOLOGY?$AA@ DB 'TECH_ECOLOGY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GFKOIOEC@TECH_ATOMIC_THEORY?$AA@
CONST	SEGMENT
??_C@_0BD@GFKOIOEC@TECH_ATOMIC_THEORY?$AA@ DB 'TECH_ATOMIC_THEORY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HHJCHIND@TECH_COMBINED_ARMS?$AA@
CONST	SEGMENT
??_C@_0BD@HHJCHIND@TECH_COMBINED_ARMS?$AA@ DB 'TECH_COMBINED_ARMS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CFAAJMNL@TECH_RADAR?$AA@
CONST	SEGMENT
??_C@_0L@CFAAJMNL@TECH_RADAR?$AA@ DB 'TECH_RADAR', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EOBHCNAL@TECH_ELECTRONICS?$AA@
CONST	SEGMENT
??_C@_0BB@EOBHCNAL@TECH_ELECTRONICS?$AA@ DB 'TECH_ELECTRONICS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OIHEKAJC@TECH_PENICILIN?$AA@
CONST	SEGMENT
??_C@_0P@OIHEKAJC@TECH_PENICILIN?$AA@ DB 'TECH_PENICILIN', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HDBOCAAC@TECH_PLASTIC?$AA@
CONST	SEGMENT
??_C@_0N@HDBOCAAC@TECH_PLASTIC?$AA@ DB 'TECH_PLASTIC', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MDNDMIKO@TECH_COMBUSTION?$AA@
CONST	SEGMENT
??_C@_0BA@MDNDMIKO@TECH_COMBUSTION?$AA@ DB 'TECH_COMBUSTION', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@EIGNECGO@TECH_BALLISTICS?$AA@
CONST	SEGMENT
??_C@_0BA@EIGNECGO@TECH_BALLISTICS?$AA@ DB 'TECH_BALLISTICS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CMLGIFFI@TECH_FLIGHT?$AA@
CONST	SEGMENT
??_C@_0M@CMLGIFFI@TECH_FLIGHT?$AA@ DB 'TECH_FLIGHT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NEHPKBHP@TECH_RADIO?$AA@
CONST	SEGMENT
??_C@_0L@NEHPKBHP@TECH_RADIO?$AA@ DB 'TECH_RADIO', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FFEPPPHF@TECH_HYDROELECTRICS?$AA@
CONST	SEGMENT
??_C@_0BE@FFEPPPHF@TECH_HYDROELECTRICS?$AA@ DB 'TECH_HYDROELECTRICS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CLJFKPHA@TECH_REFRIGERATION?$AA@
CONST	SEGMENT
??_C@_0BD@CLJFKPHA@TECH_REFRIGERATION?$AA@ DB 'TECH_REFRIGERATION', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KHFLEIGB@TECH_RAILROAD?$AA@
CONST	SEGMENT
??_C@_0O@KHFLEIGB@TECH_RAILROAD?$AA@ DB 'TECH_RAILROAD', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MKPELENP@TECH_REPLACEABLE_PARTS?$AA@
CONST	SEGMENT
??_C@_0BH@MKPELENP@TECH_REPLACEABLE_PARTS?$AA@ DB 'TECH_REPLACEABLE_PARTS'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IDFIFHNI@TECH_ELECTRICITY?$AA@
CONST	SEGMENT
??_C@_0BB@IDFIFHNI@TECH_ELECTRICITY?$AA@ DB 'TECH_ELECTRICITY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GKMLHLAB@TECH_DYNAMITE?$AA@
CONST	SEGMENT
??_C@_0O@GKMLHLAB@TECH_DYNAMITE?$AA@ DB 'TECH_DYNAMITE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PHGCNHHO@TECH_STEAM_POWER?$AA@
CONST	SEGMENT
??_C@_0BB@PHGCNHHO@TECH_STEAM_POWER?$AA@ DB 'TECH_STEAM_POWER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PKKJFPJP@TECH_BIOLOGY?$AA@
CONST	SEGMENT
??_C@_0N@PKKJFPJP@TECH_BIOLOGY?$AA@ DB 'TECH_BIOLOGY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PMJHEBE@TECH_FERTILIZER?$AA@
CONST	SEGMENT
??_C@_0BA@PMJHEBE@TECH_FERTILIZER?$AA@ DB 'TECH_FERTILIZER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FPOGGEPA@TECH_RIFLING?$AA@
CONST	SEGMENT
??_C@_0N@FPOGGEPA@TECH_RIFLING?$AA@ DB 'TECH_RIFLING', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@EJGDFPPF@TECH_MILITARY_SCIENCE?$AA@
CONST	SEGMENT
??_C@_0BG@EJGDFPPF@TECH_MILITARY_SCIENCE?$AA@ DB 'TECH_MILITARY_SCIENCE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MGMKHAML@TECH_INDUSTRIALIZATION?$AA@
CONST	SEGMENT
??_C@_0BH@MGMKHAML@TECH_INDUSTRIALIZATION?$AA@ DB 'TECH_INDUSTRIALIZATION'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PCFMKOBM@TECH_SCIENTIFIC_THEORY?$AA@
CONST	SEGMENT
??_C@_0BH@PCFMKOBM@TECH_SCIENTIFIC_THEORY?$AA@ DB 'TECH_SCIENTIFIC_THEORY'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KLFMGMG@TECH_ARCHAEOLOGY?$AA@
CONST	SEGMENT
??_C@_0BB@KLFMGMG@TECH_ARCHAEOLOGY?$AA@ DB 'TECH_ARCHAEOLOGY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HHBBFOFJ@TECH_CHEMISTRY?$AA@
CONST	SEGMENT
??_C@_0P@HHBBFOFJ@TECH_CHEMISTRY?$AA@ DB 'TECH_CHEMISTRY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LJEFMFPL@TECH_METALLURGY?$AA@
CONST	SEGMENT
??_C@_0BA@LJEFMFPL@TECH_METALLURGY?$AA@ DB 'TECH_METALLURGY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BEIDNCOH@TECH_ECONOMICS?$AA@
CONST	SEGMENT
??_C@_0P@BEIDNCOH@TECH_ECONOMICS?$AA@ DB 'TECH_ECONOMICS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EAJJMBFD@TECH_ARCHITECTURE?$AA@
CONST	SEGMENT
??_C@_0BC@EAJJMBFD@TECH_ARCHITECTURE?$AA@ DB 'TECH_ARCHITECTURE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NLCOFLJH@TECH_NAVIGATION?$AA@
CONST	SEGMENT
??_C@_0BA@NLCOFLJH@TECH_NAVIGATION?$AA@ DB 'TECH_NAVIGATION', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PBELMECB@TECH_GUNPOWDER?$AA@
CONST	SEGMENT
??_C@_0P@PBELMECB@TECH_GUNPOWDER?$AA@ DB 'TECH_GUNPOWDER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EJIFHDMN@TECH_PRINTING_PRESS?$AA@
CONST	SEGMENT
??_C@_0BE@EJIFHDMN@TECH_PRINTING_PRESS?$AA@ DB 'TECH_PRINTING_PRESS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EOMBEFMB@TECH_BANKING?$AA@
CONST	SEGMENT
??_C@_0N@EOMBEFMB@TECH_BANKING?$AA@ DB 'TECH_BANKING', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GBFFINLK@TECH_ACOUSTICS?$AA@
CONST	SEGMENT
??_C@_0P@GBFFINLK@TECH_ACOUSTICS?$AA@ DB 'TECH_ACOUSTICS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KCLNALKH@TECH_ASTRONOMY?$AA@
CONST	SEGMENT
??_C@_0P@KCLNALKH@TECH_ASTRONOMY?$AA@ DB 'TECH_ASTRONOMY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CNKIKHOK@TECH_STEEL?$AA@
CONST	SEGMENT
??_C@_0L@CNKIKHOK@TECH_STEEL?$AA@ DB 'TECH_STEEL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@INPCJMCC@TECH_PHYSICS?$AA@
CONST	SEGMENT
??_C@_0N@INPCJMCC@TECH_PHYSICS?$AA@ DB 'TECH_PHYSICS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CBPJJNFI@TECH_MACHINERY?$AA@
CONST	SEGMENT
??_C@_0P@CBPJJNFI@TECH_MACHINERY?$AA@ DB 'TECH_MACHINERY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HFBLBHAM@TECH_CHIVALRY?$AA@
CONST	SEGMENT
??_C@_0O@HFBLBHAM@TECH_CHIVALRY?$AA@ DB 'TECH_CHIVALRY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FNMCPCPG@TECH_EDUCATION?$AA@
CONST	SEGMENT
??_C@_0P@FNMCPCPG@TECH_EDUCATION?$AA@ DB 'TECH_EDUCATION', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LMBECFKG@TECH_COMPASS?$AA@
CONST	SEGMENT
??_C@_0N@LMBECFKG@TECH_COMPASS?$AA@ DB 'TECH_COMPASS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DDPCCAFE@TECH_METAL_CASTING?$AA@
CONST	SEGMENT
??_C@_0BD@DDPCCAFE@TECH_METAL_CASTING?$AA@ DB 'TECH_METAL_CASTING', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DPECDFBN@TECH_GUILDS?$AA@
CONST	SEGMENT
??_C@_0M@DPECDFBN@TECH_GUILDS?$AA@ DB 'TECH_GUILDS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DHKNNHNJ@TECH_CIVIL_SERVICE?$AA@
CONST	SEGMENT
??_C@_0BD@DHKNNHNJ@TECH_CIVIL_SERVICE?$AA@ DB 'TECH_CIVIL_SERVICE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KOALALFH@TECH_THEOLOGY?$AA@
CONST	SEGMENT
??_C@_0O@KOALALFH@TECH_THEOLOGY?$AA@ DB 'TECH_THEOLOGY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PPEEJCDE@TECH_IRON_WORKING?$AA@
CONST	SEGMENT
??_C@_0BC@PPEEJCDE@TECH_IRON_WORKING?$AA@ DB 'TECH_IRON_WORKING', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OKFPFMCJ@TECH_ENGINEERING?$AA@
CONST	SEGMENT
??_C@_0BB@OKFPFMCJ@TECH_ENGINEERING?$AA@ DB 'TECH_ENGINEERING', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@COIABONI@TECH_CURRENCY?$AA@
CONST	SEGMENT
??_C@_0O@COIABONI@TECH_CURRENCY?$AA@ DB 'TECH_CURRENCY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IIOENIML@TECH_DRAMA?$AA@
CONST	SEGMENT
??_C@_0L@IIOENIML@TECH_DRAMA?$AA@ DB 'TECH_DRAMA', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KHDONNDG@TECH_PHILOSOPHY?$AA@
CONST	SEGMENT
??_C@_0BA@KHDONNDG@TECH_PHILOSOPHY?$AA@ DB 'TECH_PHILOSOPHY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LHFDJOLC@TECH_CONSTRUCTION?$AA@
CONST	SEGMENT
??_C@_0BC@LHFDJOLC@TECH_CONSTRUCTION?$AA@ DB 'TECH_CONSTRUCTION', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PIGLFBDI@TECH_MATHEMATICS?$AA@
CONST	SEGMENT
??_C@_0BB@PIGLFBDI@TECH_MATHEMATICS?$AA@ DB 'TECH_MATHEMATICS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BHCMNEIE@TECH_HORSEBACK_RIDING?$AA@
CONST	SEGMENT
??_C@_0BG@BHCMNEIE@TECH_HORSEBACK_RIDING?$AA@ DB 'TECH_HORSEBACK_RIDING', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PGIBFPEN@TECH_OPTICS?$AA@
CONST	SEGMENT
??_C@_0M@PGIBFPEN@TECH_OPTICS?$AA@ DB 'TECH_OPTICS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LNKOLOKH@TECH_BRONZE_WORKING?$AA@
CONST	SEGMENT
??_C@_0BE@LNKOLOKH@TECH_BRONZE_WORKING?$AA@ DB 'TECH_BRONZE_WORKING', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IBIDLNJK@TECH_MASONRY?$AA@
CONST	SEGMENT
??_C@_0N@IBIDLNJK@TECH_MASONRY?$AA@ DB 'TECH_MASONRY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KKLHOPEM@TECH_THE_WHEEL?$AA@
CONST	SEGMENT
??_C@_0P@KKLHOPEM@TECH_THE_WHEEL?$AA@ DB 'TECH_THE_WHEEL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BOFEJDOG@TECH_TRAPPING?$AA@
CONST	SEGMENT
??_C@_0O@BOFEJDOG@TECH_TRAPPING?$AA@ DB 'TECH_TRAPPING', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NDBJMMDG@TECH_WRITING?$AA@
CONST	SEGMENT
??_C@_0N@NDBJMMDG@TECH_WRITING?$AA@ DB 'TECH_WRITING', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HFOCIGJ@TECH_CALENDAR?$AA@
CONST	SEGMENT
??_C@_0O@HFOCIGJ@TECH_CALENDAR?$AA@ DB 'TECH_CALENDAR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FBPFJINM@TECH_SAILING?$AA@
CONST	SEGMENT
??_C@_0N@FBPFJINM@TECH_SAILING?$AA@ DB 'TECH_SAILING', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EJOBNGBC@TECH_MINING?$AA@
CONST	SEGMENT
??_C@_0M@EJOBNGBC@TECH_MINING?$AA@ DB 'TECH_MINING', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OGONHHAM@TECH_ARCHERY?$AA@
CONST	SEGMENT
??_C@_0N@OGONHHAM@TECH_ARCHERY?$AA@ DB 'TECH_ARCHERY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DCCALJP@TECH_ANIMAL_HUSBANDRY?$AA@
CONST	SEGMENT
??_C@_0BG@DCCALJP@TECH_ANIMAL_HUSBANDRY?$AA@ DB 'TECH_ANIMAL_HUSBANDRY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OLDGPDBH@TECH_POTTERY?$AA@
CONST	SEGMENT
??_C@_0N@OLDGPDBH@TECH_POTTERY?$AA@ DB 'TECH_POTTERY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DKMCOOLJ@TECH_AGRICULTURE?$AA@
CONST	SEGMENT
??_C@_0BB@DKMCOOLJ@TECH_AGRICULTURE?$AA@ DB 'TECH_AGRICULTURE', 00H ; `string'
CONST	ENDS
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
PUBLIC	??1CvBaseInfo@@QAE@XZ				; CvBaseInfo::~CvBaseInfo
PUBLIC	??_7CvTechEntry@@6B@				; CvTechEntry::`vftable'
PUBLIC	??0CvTechEntry@@QAE@XZ				; CvTechEntry::CvTechEntry
PUBLIC	?CacheResults@CvTechEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvTechEntry::CacheResults
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	??0CvBaseInfo@@QAE@XZ:PROC			; CvBaseInfo::CvBaseInfo
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	??8CvBaseInfo@@UBE_NABV0@@Z:PROC		; CvBaseInfo::operator==
EXTRN	?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::readFrom
EXTRN	?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::writeTo
;	COMDAT ??_7CvTechEntry@@6B@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_7CvTechEntry@@6B@ DD FLAT:?CacheResults@CvTechEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvTechEntry::`vftable'
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CvTechEntry@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvTechEntry@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvTechEntry@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CvTechEntry@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CvTechEntry@@QAE@XZ$3
__ehfuncinfo$??0CvTechEntry@@QAE@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0CvTechEntry@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtechclasses.cpp
xdata$x	ENDS
;	COMDAT ??0CvTechEntry@@QAE@XZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T226102 = -28						; size = 4
$T226097 = -24						; size = 4
$T226092 = -20						; size = 4
$T226087 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvTechEntry@@QAE@XZ PROC				; CvTechEntry::CvTechEntry, COMDAT
; _this$ = ecx

; 78   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvTechEntry@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvTechEntry@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+260], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+264], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+268], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+272], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+276], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+280], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+284], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+288], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+292], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+296], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+300], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+304], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+308], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+312], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+316], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+320], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+324], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+328], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+332], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+333], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+334], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+335], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+336], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+337], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+338], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+339], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+340], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+341], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+342], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+343], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+344], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+345], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+346], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+347], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+348], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+349], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+350], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+351], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+352], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+353], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+354], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+355], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+356], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+357], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+358], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 360				; 00000168H
	mov	DWORD PTR $T226087[ebp], ecx
	mov	ecx, DWORD PTR $T226087[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 388				; 00000184H
	mov	DWORD PTR $T226092[ebp], edx
	mov	ecx, DWORD PTR $T226092[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 416				; 000001a0H
	mov	DWORD PTR $T226097[ebp], eax
	mov	ecx, DWORD PTR $T226097[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 444				; 000001bcH
	mov	DWORD PTR $T226102[ebp], ecx
	mov	ecx, DWORD PTR $T226102[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+472], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+476], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+480], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+484], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+488], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+492], 0

; 79   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvTechEntry@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??0CvTechEntry@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 360				; 00000168H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvTechEntry@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 388				; 00000184H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvTechEntry@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 416				; 000001a0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??0CvTechEntry@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvTechEntry@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvTechEntry@@QAE@XZ ENDP				; CvTechEntry::CvTechEntry
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CvBaseInfo@@QAE@XZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??1CvBaseInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvBaseInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1CvBaseInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T226169 = -48						; size = 4
$T226164 = -44						; size = 4
$T226159 = -40						; size = 4
$T226154 = -36						; size = 4
$T226149 = -32						; size = 4
$T226144 = -28						; size = 4
$T226139 = -24						; size = 4
$T226134 = -20						; size = 4
$T226129 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvBaseInfo@@QAE@XZ PROC				; CvBaseInfo::~CvBaseInfo, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvBaseInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 7
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 232				; 000000e8H
	mov	DWORD PTR $T226129[ebp], eax
	mov	ecx, DWORD PTR $T226129[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	mov	DWORD PTR $T226134[ebp], ecx
	mov	ecx, DWORD PTR $T226134[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 176				; 000000b0H
	mov	DWORD PTR $T226139[ebp], edx
	mov	ecx, DWORD PTR $T226139[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 148				; 00000094H
	mov	DWORD PTR $T226144[ebp], eax
	mov	ecx, DWORD PTR $T226144[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	mov	DWORD PTR $T226149[ebp], ecx
	mov	ecx, DWORD PTR $T226149[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 92					; 0000005cH
	mov	DWORD PTR $T226154[ebp], edx
	mov	ecx, DWORD PTR $T226154[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 64					; 00000040H
	mov	DWORD PTR $T226159[ebp], eax
	mov	ecx, DWORD PTR $T226159[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	mov	DWORD PTR $T226164[ebp], ecx
	mov	ecx, DWORD PTR $T226164[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	mov	DWORD PTR $T226169[ebp], edx
	mov	ecx, DWORD PTR $T226169[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvBaseInfo@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvBaseInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvBaseInfo@@QAE@XZ ENDP				; CvBaseInfo::~CvBaseInfo
PUBLIC	??1CvTechEntry@@QAE@XZ				; CvTechEntry::~CvTechEntry
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??1CvTechEntry@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvTechEntry@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvTechEntry@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvTechEntry@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvTechEntry@@QAE@XZ$3
__ehfuncinfo$??1CvTechEntry@@QAE@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??1CvTechEntry@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtechclasses.cpp
xdata$x	ENDS
;	COMDAT ??1CvTechEntry@@QAE@XZ
_TEXT	SEGMENT
_this$ = -116						; size = 4
$T226238 = -76						; size = 4
$T226233 = -72						; size = 4
$T226228 = -68						; size = 4
$T226223 = -64						; size = 4
$T226218 = -60						; size = 4
$T226217 = -56						; size = 4
$T226212 = -52						; size = 4
$T226211 = -48						; size = 4
$T226206 = -44						; size = 4
$T226205 = -40						; size = 4
$T226200 = -36						; size = 4
$T226199 = -32						; size = 4
$T226194 = -28						; size = 4
$T226193 = -24						; size = 4
$T226188 = -20						; size = 4
$T226187 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvTechEntry@@QAE@XZ PROC				; CvTechEntry::~CvTechEntry, COMDAT
; _this$ = ecx

; 83   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvTechEntry@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvTechEntry@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 3

; 84   : 	SAFE_DELETE_ARRAY(m_piDomainExtraMoves);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 472				; 000001d8H
	mov	DWORD PTR $T226188[ebp], ecx
	mov	edx, DWORD PTR $T226188[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T226187[ebp], eax
	mov	ecx, DWORD PTR $T226187[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T226188[ebp]
	mov	DWORD PTR [edx], 0

; 85   : 	SAFE_DELETE_ARRAY(m_piTradeRouteDomainExtraRange);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 476				; 000001dcH
	mov	DWORD PTR $T226194[ebp], eax
	mov	ecx, DWORD PTR $T226194[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T226193[ebp], edx
	mov	eax, DWORD PTR $T226193[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T226194[ebp]
	mov	DWORD PTR [ecx], 0

; 86   : 	SAFE_DELETE_ARRAY(m_piFlavorValue);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 480				; 000001e0H
	mov	DWORD PTR $T226200[ebp], edx
	mov	eax, DWORD PTR $T226200[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T226199[ebp], ecx
	mov	edx, DWORD PTR $T226199[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, DWORD PTR $T226200[ebp]
	mov	DWORD PTR [eax], 0

; 87   : 	SAFE_DELETE_ARRAY(m_piPrereqOrTechs);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 484				; 000001e4H
	mov	DWORD PTR $T226206[ebp], ecx
	mov	edx, DWORD PTR $T226206[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T226205[ebp], eax
	mov	ecx, DWORD PTR $T226205[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T226206[ebp]
	mov	DWORD PTR [edx], 0

; 88   : 	SAFE_DELETE_ARRAY(m_piPrereqAndTechs);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 488				; 000001e8H
	mov	DWORD PTR $T226212[ebp], eax
	mov	ecx, DWORD PTR $T226212[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T226211[ebp], edx
	mov	eax, DWORD PTR $T226211[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T226212[ebp]
	mov	DWORD PTR [ecx], 0

; 89   : 	SAFE_DELETE_ARRAY(m_pabFreePromotion);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 492				; 000001ecH
	mov	DWORD PTR $T226218[ebp], edx
	mov	eax, DWORD PTR $T226218[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T226217[ebp], ecx
	mov	edx, DWORD PTR $T226217[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, DWORD PTR $T226218[ebp]
	mov	DWORD PTR [eax], 0

; 90   : }

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 444				; 000001bcH
	mov	DWORD PTR $T226223[ebp], ecx
	mov	ecx, DWORD PTR $T226223[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 416				; 000001a0H
	mov	DWORD PTR $T226228[ebp], edx
	mov	ecx, DWORD PTR $T226228[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 388				; 00000184H
	mov	DWORD PTR $T226233[ebp], eax
	mov	ecx, DWORD PTR $T226233[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 360				; 00000168H
	mov	DWORD PTR $T226238[ebp], ecx
	mov	ecx, DWORD PTR $T226238[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvBaseInfo@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvTechEntry@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??1CvTechEntry@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 360				; 00000168H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvTechEntry@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 388				; 00000184H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvTechEntry@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 416				; 000001a0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvTechEntry@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-108]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvTechEntry@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvTechEntry@@QAE@XZ ENDP				; CvTechEntry::~CvTechEntry
PUBLIC	??_C@_0IB@LKAKDCEK@select?5Technologies?4ID?5from?5Tech@ ; `string'
PUBLIC	??_C@_0CG@IGEMGBE@Technologies?5?9?5Technology_Prereq@ ; `string'
PUBLIC	??_C@_0ID@JDHEGGPJ@select?5Technologies?4ID?5from?5Tech@ ; `string'
PUBLIC	??_C@_0CI@EDCAPJKC@Technologies?5?9?5Technology_ORPrer@ ; `string'
PUBLIC	?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z ; CvDatabaseUtility::InitializeArray
PUBLIC	??_C@_0N@INKDAICK@Technologies?$AA@		; `string'
PUBLIC	??_C@_0BD@LIOGFLEL@Technology_Flavors?$AA@	; `string'
PUBLIC	??_C@_0P@GCBJCIAG@UnitPromotions?$AA@		; `string'
PUBLIC	??_C@_0BK@KPPIEHLD@Technology_FreePromotions?$AA@ ; `string'
PUBLIC	??_C@_0O@IILJPJBB@PromotionType?$AA@		; `string'
PUBLIC	??_C@_0CG@INDDLKBJ@Technology_TradeRouteDomainExtra@ ; `string'
PUBLIC	??_C@_05CFMCGLCK@Range?$AA@			; `string'
PUBLIC	??_C@_07FKLJOGGC@Domains?$AA@			; `string'
PUBLIC	??_C@_0BM@DHKPDGGE@Technology_DomainExtraMoves?$AA@ ; `string'
PUBLIC	??_C@_0L@NIGHKLOG@DomainType?$AA@		; `string'
PUBLIC	??_C@_08GHGFPPBE@TechType?$AA@			; `string'
PUBLIC	??_C@_05OCMDHLMM@Moves?$AA@			; `string'
PUBLIC	?SetSoundMP@CvTechEntry@@QAEXPBD@Z		; CvTechEntry::SetSoundMP
PUBLIC	??_C@_0BB@GBAPFEGA@AudioIntroHeader?$AA@	; `string'
PUBLIC	?SetSound@CvTechEntry@@QAEXPBD@Z		; CvTechEntry::SetSound
PUBLIC	??_C@_0L@HPBDPPMB@AudioIntro?$AA@		; `string'
PUBLIC	?SetQuoteKey@CvTechEntry@@QAEXPBD@Z		; CvTechEntry::SetQuoteKey
PUBLIC	??_C@_05JAOKFCIK@Quote?$AA@			; `string'
PUBLIC	??_C@_0BD@MKGCGFCK@FirstFreeUnitClass?$AA@	; `string'
PUBLIC	??_C@_03FJOCGODE@Era?$AA@			; `string'
PUBLIC	??_C@_05LNPLOKEP@GridY?$AA@			; `string'
PUBLIC	??_C@_05KEOANLAO@GridX?$AA@			; `string'
PUBLIC	??_C@_09IDNBDFGB@WaterWork?$AA@			; `string'
PUBLIC	??_C@_0P@JKOGIKHO@BridgeBuilding?$AA@		; `string'
PUBLIC	??_C@_0CA@ICKMEKKP@PermanentAllianceTradingAllowed?$AA@ ; `string'
PUBLIC	??_C@_0BN@JEMNLGEL@TradeAgreementTradingAllowed?$AA@ ; `string'
PUBLIC	??_C@_0CA@ELGCCMJG@ResearchAgreementTradingAllowed?$AA@ ; `string'
PUBLIC	??_C@_0BM@PKIJKDME@DefensivePactTradingAllowed?$AA@ ; `string'
PUBLIC	??_C@_0BK@MGOPDIKK@OpenBordersTradingAllowed?$AA@ ; `string'
PUBLIC	??_C@_0BL@NAGAJAEL@AllowEmbassyTradingAllowed?$AA@ ; `string'
PUBLIC	??_C@_0M@OCPDKDMI@GoldTrading?$AA@		; `string'
PUBLIC	??_C@_0M@GMOFGMNJ@TechTrading?$AA@		; `string'
PUBLIC	??_C@_0L@GMHICEOP@MapTrading?$AA@		; `string'
PUBLIC	??_C@_0L@BLLJLNGK@MapVisible?$AA@		; `string'
PUBLIC	??_C@_0N@MDAIKEA@MapCentering?$AA@		; `string'
PUBLIC	??_C@_0BC@EPEFBLPL@ExtraWaterSeeFrom?$AA@	; `string'
PUBLIC	??_C@_0BE@IMAOEHME@AllowsWorldCongress?$AA@	; `string'
PUBLIC	??_C@_0BM@KKEFMJNG@TriggersArchaeologicalSites?$AA@ ; `string'
PUBLIC	??_C@_09JPAILJCB@GoodyTech?$AA@			; `string'
PUBLIC	??_C@_0BB@NCDIJMJE@DisableTechSteal?$AA@	; `string'
PUBLIC	??_C@_07MIKIFGAL@Disable?$AA@			; `string'
PUBLIC	??_C@_05IOPOMLGK@Trade?$AA@			; `string'
PUBLIC	??_C@_06HJIMLMON@Repeat?$AA@			; `string'
PUBLIC	??_C@_0BF@LFIJHIKN@AllowsBarbarianBoats?$AA@	; `string'
PUBLIC	??_C@_0BI@IFJBENMM@EmbarkedAllWaterPassage?$AA@	; `string'
PUBLIC	??_C@_0BJ@FFHNBGHA@AllowsDefensiveEmbarking?$AA@ ; `string'
PUBLIC	??_C@_0BI@LNDCKLIC@AllowsEmbarkingCivilian?$AA@	; `string'
PUBLIC	??_C@_0BA@MAEDHBPF@AllowsEmbarking?$AA@		; `string'
PUBLIC	??_C@_08ILBBNLKH@EndsGame?$AA@			; `string'
PUBLIC	??_C@_0BG@GHKCHOKE@ExtraVotesPerDiplomat?$AA@	; `string'
PUBLIC	??_C@_0BI@KIICGMNH@InfluenceSpreadModifier?$AA@	; `string'
PUBLIC	??_C@_0BP@JOBLBGFG@InternationalTradeRoutesChange?$AA@ ; `string'
PUBLIC	??_C@_0BE@IBIAPIMK@EmbarkedSightChange?$AA@	; `string'
PUBLIC	??_C@_0BD@LKCNALGJ@EmbarkedMoveChange?$AA@	; `string'
PUBLIC	??_C@_0P@IENNJDPB@FirstFreeTechs?$AA@		; `string'
PUBLIC	??_C@_0BE@NGOPBNAB@WorkerSpeedModifier?$AA@	; `string'
PUBLIC	??_C@_0BF@LEIBBJAN@UnitBaseHealModifier?$AA@	; `string'
PUBLIC	??_C@_0BK@OKJALLID@UnitFortificationModifier?$AA@ ; `string'
PUBLIC	??_C@_0BK@HAELONIG@FeatureProductionModifier?$AA@ ; `string'
PUBLIC	??_C@_0BC@HHPMHOMK@AdvancedStartCost?$AA@	; `string'
PUBLIC	??_C@_04FICPKHNF@Cost?$AA@			; `string'
PUBLIC	??_C@_0BA@NKLNHAIL@AITradeModifier?$AA@		; `string'
PUBLIC	??_C@_08GHMCJAOP@AIWeight?$AA@			; `string'
PUBLIC	__$ArrayPad$
EXTRN	__imp_?Reset@Results@Database@@QAE_NXZ:PROC
EXTRN	__imp_?GetInt@Results@Database@@QAEHH@Z:PROC
EXTRN	__imp_?Step@Results@Database@@QAE_NXZ:PROC
EXTRN	__imp_?Bind@Results@Database@@QAE_NHPBDH_N@Z:PROC
EXTRN	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z:PROC ; CvDatabaseUtility::PrepareResults
EXTRN	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; CvDatabaseUtility::GetResults
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z:PROC	; CvDatabaseUtility::MaxRows
EXTRN	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z:PROC ; CvDatabaseUtility::SetFlavors
EXTRN	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z:PROC ; CvDatabaseUtility::PopulateArrayByExistence
EXTRN	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z:PROC ; CvDatabaseUtility::PopulateArrayByValue
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
EXTRN	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z:PROC ; CvGlobals::getInfoTypeForString
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
EXTRN	__imp_?GetText@Results@Database@@QAEPBDPBD@Z:PROC
EXTRN	__imp_?GetBool@Results@Database@@QAE_NPBD@Z:PROC
EXTRN	__imp_?GetInt@Results@Database@@QAEHPBD@Z:PROC
EXTRN	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:PROC ; CvBaseInfo::CacheResults
;	COMDAT ??_C@_0IB@LKAKDCEK@select?5Technologies?4ID?5from?5Tech@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdatabaseutility.h
CONST	SEGMENT
??_C@_0IB@LKAKDCEK@select?5Technologies?4ID?5from?5Tech@ DB 'select Techn'
	DB	'ologies.ID from Technology_PrereqTechs inner join Technologie'
	DB	's on Technologies.Type = PrereqTech where TechType = ?;', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@IGEMGBE@Technologies?5?9?5Technology_Prereq@
CONST	SEGMENT
??_C@_0CG@IGEMGBE@Technologies?5?9?5Technology_Prereq@ DB 'Technologies -'
	DB	' Technology_PrereqTechs', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0ID@JDHEGGPJ@select?5Technologies?4ID?5from?5Tech@
CONST	SEGMENT
??_C@_0ID@JDHEGGPJ@select?5Technologies?4ID?5from?5Tech@ DB 'select Techn'
	DB	'ologies.ID from Technology_ORPrereqTechs inner join Technolog'
	DB	'ies on Technologies.Type = PrereqTech where TechType = ?;', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@EDCAPJKC@Technologies?5?9?5Technology_ORPrer@
CONST	SEGMENT
??_C@_0CI@EDCAPJKC@Technologies?5?9?5Technology_ORPrer@ DB 'Technologies '
	DB	'- Technology_ORPrereqTechs', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@INKDAICK@Technologies?$AA@
CONST	SEGMENT
??_C@_0N@INKDAICK@Technologies?$AA@ DB 'Technologies', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LIOGFLEL@Technology_Flavors?$AA@
CONST	SEGMENT
??_C@_0BD@LIOGFLEL@Technology_Flavors?$AA@ DB 'Technology_Flavors', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GCBJCIAG@UnitPromotions?$AA@
CONST	SEGMENT
??_C@_0P@GCBJCIAG@UnitPromotions?$AA@ DB 'UnitPromotions', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@KPPIEHLD@Technology_FreePromotions?$AA@
CONST	SEGMENT
??_C@_0BK@KPPIEHLD@Technology_FreePromotions?$AA@ DB 'Technology_FreeProm'
	DB	'otions', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IILJPJBB@PromotionType?$AA@
CONST	SEGMENT
??_C@_0O@IILJPJBB@PromotionType?$AA@ DB 'PromotionType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@INDDLKBJ@Technology_TradeRouteDomainExtra@
CONST	SEGMENT
??_C@_0CG@INDDLKBJ@Technology_TradeRouteDomainExtra@ DB 'Technology_Trade'
	DB	'RouteDomainExtraRange', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05CFMCGLCK@Range?$AA@
CONST	SEGMENT
??_C@_05CFMCGLCK@Range?$AA@ DB 'Range', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07FKLJOGGC@Domains?$AA@
CONST	SEGMENT
??_C@_07FKLJOGGC@Domains?$AA@ DB 'Domains', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@DHKPDGGE@Technology_DomainExtraMoves?$AA@
CONST	SEGMENT
??_C@_0BM@DHKPDGGE@Technology_DomainExtraMoves?$AA@ DB 'Technology_Domain'
	DB	'ExtraMoves', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NIGHKLOG@DomainType?$AA@
CONST	SEGMENT
??_C@_0L@NIGHKLOG@DomainType?$AA@ DB 'DomainType', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08GHGFPPBE@TechType?$AA@
CONST	SEGMENT
??_C@_08GHGFPPBE@TechType?$AA@ DB 'TechType', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05OCMDHLMM@Moves?$AA@
CONST	SEGMENT
??_C@_05OCMDHLMM@Moves?$AA@ DB 'Moves', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GBAPFEGA@AudioIntroHeader?$AA@
CONST	SEGMENT
??_C@_0BB@GBAPFEGA@AudioIntroHeader?$AA@ DB 'AudioIntroHeader', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HPBDPPMB@AudioIntro?$AA@
CONST	SEGMENT
??_C@_0L@HPBDPPMB@AudioIntro?$AA@ DB 'AudioIntro', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05JAOKFCIK@Quote?$AA@
CONST	SEGMENT
??_C@_05JAOKFCIK@Quote?$AA@ DB 'Quote', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MKGCGFCK@FirstFreeUnitClass?$AA@
CONST	SEGMENT
??_C@_0BD@MKGCGFCK@FirstFreeUnitClass?$AA@ DB 'FirstFreeUnitClass', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03FJOCGODE@Era?$AA@
CONST	SEGMENT
??_C@_03FJOCGODE@Era?$AA@ DB 'Era', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05LNPLOKEP@GridY?$AA@
CONST	SEGMENT
??_C@_05LNPLOKEP@GridY?$AA@ DB 'GridY', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05KEOANLAO@GridX?$AA@
CONST	SEGMENT
??_C@_05KEOANLAO@GridX?$AA@ DB 'GridX', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09IDNBDFGB@WaterWork?$AA@
CONST	SEGMENT
??_C@_09IDNBDFGB@WaterWork?$AA@ DB 'WaterWork', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JKOGIKHO@BridgeBuilding?$AA@
CONST	SEGMENT
??_C@_0P@JKOGIKHO@BridgeBuilding?$AA@ DB 'BridgeBuilding', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@ICKMEKKP@PermanentAllianceTradingAllowed?$AA@
CONST	SEGMENT
??_C@_0CA@ICKMEKKP@PermanentAllianceTradingAllowed?$AA@ DB 'PermanentAlli'
	DB	'anceTradingAllowed', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JEMNLGEL@TradeAgreementTradingAllowed?$AA@
CONST	SEGMENT
??_C@_0BN@JEMNLGEL@TradeAgreementTradingAllowed?$AA@ DB 'TradeAgreementTr'
	DB	'adingAllowed', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@ELGCCMJG@ResearchAgreementTradingAllowed?$AA@
CONST	SEGMENT
??_C@_0CA@ELGCCMJG@ResearchAgreementTradingAllowed?$AA@ DB 'ResearchAgree'
	DB	'mentTradingAllowed', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@PKIJKDME@DefensivePactTradingAllowed?$AA@
CONST	SEGMENT
??_C@_0BM@PKIJKDME@DefensivePactTradingAllowed?$AA@ DB 'DefensivePactTrad'
	DB	'ingAllowed', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@MGOPDIKK@OpenBordersTradingAllowed?$AA@
CONST	SEGMENT
??_C@_0BK@MGOPDIKK@OpenBordersTradingAllowed?$AA@ DB 'OpenBordersTradingA'
	DB	'llowed', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@NAGAJAEL@AllowEmbassyTradingAllowed?$AA@
CONST	SEGMENT
??_C@_0BL@NAGAJAEL@AllowEmbassyTradingAllowed?$AA@ DB 'AllowEmbassyTradin'
	DB	'gAllowed', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OCPDKDMI@GoldTrading?$AA@
CONST	SEGMENT
??_C@_0M@OCPDKDMI@GoldTrading?$AA@ DB 'GoldTrading', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GMOFGMNJ@TechTrading?$AA@
CONST	SEGMENT
??_C@_0M@GMOFGMNJ@TechTrading?$AA@ DB 'TechTrading', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GMHICEOP@MapTrading?$AA@
CONST	SEGMENT
??_C@_0L@GMHICEOP@MapTrading?$AA@ DB 'MapTrading', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BLLJLNGK@MapVisible?$AA@
CONST	SEGMENT
??_C@_0L@BLLJLNGK@MapVisible?$AA@ DB 'MapVisible', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MDAIKEA@MapCentering?$AA@
CONST	SEGMENT
??_C@_0N@MDAIKEA@MapCentering?$AA@ DB 'MapCentering', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EPEFBLPL@ExtraWaterSeeFrom?$AA@
CONST	SEGMENT
??_C@_0BC@EPEFBLPL@ExtraWaterSeeFrom?$AA@ DB 'ExtraWaterSeeFrom', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IMAOEHME@AllowsWorldCongress?$AA@
CONST	SEGMENT
??_C@_0BE@IMAOEHME@AllowsWorldCongress?$AA@ DB 'AllowsWorldCongress', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@KKEFMJNG@TriggersArchaeologicalSites?$AA@
CONST	SEGMENT
??_C@_0BM@KKEFMJNG@TriggersArchaeologicalSites?$AA@ DB 'TriggersArchaeolo'
	DB	'gicalSites', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09JPAILJCB@GoodyTech?$AA@
CONST	SEGMENT
??_C@_09JPAILJCB@GoodyTech?$AA@ DB 'GoodyTech', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NCDIJMJE@DisableTechSteal?$AA@
CONST	SEGMENT
??_C@_0BB@NCDIJMJE@DisableTechSteal?$AA@ DB 'DisableTechSteal', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07MIKIFGAL@Disable?$AA@
CONST	SEGMENT
??_C@_07MIKIFGAL@Disable?$AA@ DB 'Disable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IOPOMLGK@Trade?$AA@
CONST	SEGMENT
??_C@_05IOPOMLGK@Trade?$AA@ DB 'Trade', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HJIMLMON@Repeat?$AA@
CONST	SEGMENT
??_C@_06HJIMLMON@Repeat?$AA@ DB 'Repeat', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@LFIJHIKN@AllowsBarbarianBoats?$AA@
CONST	SEGMENT
??_C@_0BF@LFIJHIKN@AllowsBarbarianBoats?$AA@ DB 'AllowsBarbarianBoats', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@IFJBENMM@EmbarkedAllWaterPassage?$AA@
CONST	SEGMENT
??_C@_0BI@IFJBENMM@EmbarkedAllWaterPassage?$AA@ DB 'EmbarkedAllWaterPassa'
	DB	'ge', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@FFHNBGHA@AllowsDefensiveEmbarking?$AA@
CONST	SEGMENT
??_C@_0BJ@FFHNBGHA@AllowsDefensiveEmbarking?$AA@ DB 'AllowsDefensiveEmbar'
	DB	'king', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LNDCKLIC@AllowsEmbarkingCivilian?$AA@
CONST	SEGMENT
??_C@_0BI@LNDCKLIC@AllowsEmbarkingCivilian?$AA@ DB 'AllowsEmbarkingCivili'
	DB	'an', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MAEDHBPF@AllowsEmbarking?$AA@
CONST	SEGMENT
??_C@_0BA@MAEDHBPF@AllowsEmbarking?$AA@ DB 'AllowsEmbarking', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08ILBBNLKH@EndsGame?$AA@
CONST	SEGMENT
??_C@_08ILBBNLKH@EndsGame?$AA@ DB 'EndsGame', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GHKCHOKE@ExtraVotesPerDiplomat?$AA@
CONST	SEGMENT
??_C@_0BG@GHKCHOKE@ExtraVotesPerDiplomat?$AA@ DB 'ExtraVotesPerDiplomat', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KIICGMNH@InfluenceSpreadModifier?$AA@
CONST	SEGMENT
??_C@_0BI@KIICGMNH@InfluenceSpreadModifier?$AA@ DB 'InfluenceSpreadModifi'
	DB	'er', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@JOBLBGFG@InternationalTradeRoutesChange?$AA@
CONST	SEGMENT
??_C@_0BP@JOBLBGFG@InternationalTradeRoutesChange?$AA@ DB 'InternationalT'
	DB	'radeRoutesChange', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IBIAPIMK@EmbarkedSightChange?$AA@
CONST	SEGMENT
??_C@_0BE@IBIAPIMK@EmbarkedSightChange?$AA@ DB 'EmbarkedSightChange', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LKCNALGJ@EmbarkedMoveChange?$AA@
CONST	SEGMENT
??_C@_0BD@LKCNALGJ@EmbarkedMoveChange?$AA@ DB 'EmbarkedMoveChange', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IENNJDPB@FirstFreeTechs?$AA@
CONST	SEGMENT
??_C@_0P@IENNJDPB@FirstFreeTechs?$AA@ DB 'FirstFreeTechs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NGOPBNAB@WorkerSpeedModifier?$AA@
CONST	SEGMENT
??_C@_0BE@NGOPBNAB@WorkerSpeedModifier?$AA@ DB 'WorkerSpeedModifier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@LEIBBJAN@UnitBaseHealModifier?$AA@
CONST	SEGMENT
??_C@_0BF@LEIBBJAN@UnitBaseHealModifier?$AA@ DB 'UnitBaseHealModifier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@OKJALLID@UnitFortificationModifier?$AA@
CONST	SEGMENT
??_C@_0BK@OKJALLID@UnitFortificationModifier?$AA@ DB 'UnitFortificationMo'
	DB	'difier', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@HAELONIG@FeatureProductionModifier?$AA@
CONST	SEGMENT
??_C@_0BK@HAELONIG@FeatureProductionModifier?$AA@ DB 'FeatureProductionMo'
	DB	'difier', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HHPMHOMK@AdvancedStartCost?$AA@
CONST	SEGMENT
??_C@_0BC@HHPMHOMK@AdvancedStartCost?$AA@ DB 'AdvancedStartCost', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04FICPKHNF@Cost?$AA@
CONST	SEGMENT
??_C@_04FICPKHNF@Cost?$AA@ DB 'Cost', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NKLNHAIL@AITradeModifier?$AA@
CONST	SEGMENT
??_C@_0BA@NKLNHAIL@AITradeModifier?$AA@ DB 'AITradeModifier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08GHMCJAOP@AIWeight?$AA@
CONST	SEGMENT
??_C@_08GHMCJAOP@AIWeight?$AA@ DB 'AIWeight', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?CacheResults@CvTechEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvTechEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvTechEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$1
__ehfuncinfo$?CacheResults@CvTechEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?CacheResults@CvTechEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtechclasses.cpp
xdata$x	ENDS
;	COMDAT ?CacheResults@CvTechEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_this$ = -120						; size = 4
_pResults$222988 = -100					; size = 4
_strKey$222986 = -96					; size = 28
_i$222991 = -68						; size = 4
_pResults$222979 = -64					; size = 4
_strKey$222977 = -60					; size = 28
__$ArrayPad$ = -32					; size = 4
_i$222982 = -28						; size = 4
_szTechType$ = -24					; size = 4
_szTextVal$ = -20					; size = 4
_TechnologiesCount$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvTechEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvTechEntry::CacheResults, COMDAT
; _this$ = ecx

; 93   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CacheResults@CvTechEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 108				; 0000006cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 94   : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kResults$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN7@CacheResul

; 95   : 		return false;

	xor	al, al
	jmp	$LN8@CacheResul
$LN7@CacheResul:

; 96   : 
; 97   : 	//Basic Properties
; 98   : 	m_iAIWeight = kResults.GetInt("AIWeight");

	push	OFFSET ??_C@_08GHMCJAOP@AIWeight?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+260], eax

; 99   : 	m_iAITradeModifier = kResults.GetInt("AITradeModifier");

	push	OFFSET ??_C@_0BA@NKLNHAIL@AITradeModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+264], eax

; 100  : 	m_iResearchCost = kResults.GetInt("Cost");

	push	OFFSET ??_C@_04FICPKHNF@Cost?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+268], eax

; 101  : 	m_iAdvancedStartCost = kResults.GetInt("AdvancedStartCost");

	push	OFFSET ??_C@_0BC@HHPMHOMK@AdvancedStartCost?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+272], eax

; 102  : 	m_iFeatureProductionModifier = kResults.GetInt("FeatureProductionModifier");

	push	OFFSET ??_C@_0BK@HAELONIG@FeatureProductionModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+280], eax

; 103  : 	m_iUnitFortificationModifier = kResults.GetInt("UnitFortificationModifier");

	push	OFFSET ??_C@_0BK@OKJALLID@UnitFortificationModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+284], eax

; 104  : 	m_iUnitBaseHealModifier = kResults.GetInt("UnitBaseHealModifier");

	push	OFFSET ??_C@_0BF@LEIBBJAN@UnitBaseHealModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+288], eax

; 105  : 	m_iWorkerSpeedModifier = kResults.GetInt("WorkerSpeedModifier");

	push	OFFSET ??_C@_0BE@NGOPBNAB@WorkerSpeedModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+292], eax

; 106  : 	m_iFirstFreeTechs = kResults.GetInt("FirstFreeTechs");

	push	OFFSET ??_C@_0P@IENNJDPB@FirstFreeTechs?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+300], eax

; 107  : 	m_iEmbarkedMoveChange = kResults.GetInt("EmbarkedMoveChange");

	push	OFFSET ??_C@_0BD@LKCNALGJ@EmbarkedMoveChange?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+304], eax

; 108  : 	//EAP: Extra sight for embarked units on tech
; 109  : 	m_iEmbarkedSightChange = kResults.GetInt("EmbarkedSightChange");

	push	OFFSET ??_C@_0BE@IBIAPIMK@EmbarkedSightChange?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+308], eax

; 110  : 
; 111  : 	m_iInternationalTradeRoutesChange = kResults.GetInt("InternationalTradeRoutesChange");

	push	OFFSET ??_C@_0BP@JOBLBGFG@InternationalTradeRoutesChange?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+312], eax

; 112  : 	m_iInfluenceSpreadModifier = kResults.GetInt("InfluenceSpreadModifier");

	push	OFFSET ??_C@_0BI@KIICGMNH@InfluenceSpreadModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+316], eax

; 113  : 	m_iExtraVotesPerDiplomat = kResults.GetInt("ExtraVotesPerDiplomat");

	push	OFFSET ??_C@_0BG@GHKCHOKE@ExtraVotesPerDiplomat?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+320], eax

; 114  : 	m_bEndsGame = kResults.GetBool("EndsGame");

	push	OFFSET ??_C@_08ILBBNLKH@EndsGame?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+332], al

; 115  : 	m_bAllowsEmbarking = kResults.GetBool("AllowsEmbarking");

	push	OFFSET ??_C@_0BA@MAEDHBPF@AllowsEmbarking?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+333], al

; 116  : 
; 117  : 	//EAP: Civilian Embark
; 118  : 	m_bAllowsEmbarkingCivilian = kResults.GetBool("AllowsEmbarkingCivilian");

	push	OFFSET ??_C@_0BI@LNDCKLIC@AllowsEmbarkingCivilian?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+334], al

; 119  : 
; 120  : 	m_bAllowsDefensiveEmbarking = kResults.GetBool("AllowsDefensiveEmbarking");

	push	OFFSET ??_C@_0BJ@FFHNBGHA@AllowsDefensiveEmbarking?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+335], al

; 121  : 	m_bEmbarkedAllWaterPassage = kResults.GetBool("EmbarkedAllWaterPassage");

	push	OFFSET ??_C@_0BI@IFJBENMM@EmbarkedAllWaterPassage?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+336], al

; 122  : 	m_bAllowsBarbarianBoats = kResults.GetBool("AllowsBarbarianBoats");

	push	OFFSET ??_C@_0BF@LFIJHIKN@AllowsBarbarianBoats?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+337], al

; 123  : 	m_bRepeat = kResults.GetBool("Repeat");

	push	OFFSET ??_C@_06HJIMLMON@Repeat?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+338], al

; 124  : 	m_bTrade = kResults.GetBool("Trade");

	push	OFFSET ??_C@_05IOPOMLGK@Trade?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+339], al

; 125  : 	m_bDisable = kResults.GetBool("Disable");

	push	OFFSET ??_C@_07MIKIFGAL@Disable?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+340], al

; 126  : 	m_bDisableTechSteal = kResults.GetBool("DisableTechSteal");

	push	OFFSET ??_C@_0BB@NCDIJMJE@DisableTechSteal?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+341], al

; 127  : 	m_bGoodyTech = kResults.GetBool("GoodyTech");

	push	OFFSET ??_C@_09JPAILJCB@GoodyTech?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+342], al

; 128  : 	m_bTriggersArchaeologicalSites = kResults.GetBool("TriggersArchaeologicalSites");

	push	OFFSET ??_C@_0BM@KKEFMJNG@TriggersArchaeologicalSites?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+357], al

; 129  : 	m_bAllowsWorldCongress = kResults.GetBool("AllowsWorldCongress");

	push	OFFSET ??_C@_0BE@IMAOEHME@AllowsWorldCongress?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+358], al

; 130  : 	m_bExtraWaterSeeFrom = kResults.GetBool("ExtraWaterSeeFrom");

	push	OFFSET ??_C@_0BC@EPEFBLPL@ExtraWaterSeeFrom?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+343], al

; 131  : 	m_bMapCentering = kResults.GetBool("MapCentering");

	push	OFFSET ??_C@_0N@MDAIKEA@MapCentering?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+344], al

; 132  : 	m_bMapVisible = kResults.GetBool("MapVisible");

	push	OFFSET ??_C@_0L@BLLJLNGK@MapVisible?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+345], al

; 133  : 	m_bMapTrading = kResults.GetBool("MapTrading");

	push	OFFSET ??_C@_0L@GMHICEOP@MapTrading?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+346], al

; 134  : 	m_bTechTrading = kResults.GetBool("TechTrading");

	push	OFFSET ??_C@_0M@GMOFGMNJ@TechTrading?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+347], al

; 135  : 	m_bGoldTrading = kResults.GetBool("GoldTrading");

	push	OFFSET ??_C@_0M@OCPDKDMI@GoldTrading?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+348], al

; 136  : 	m_bAllowEmbassyTradingAllowed = kResults.GetBool("AllowEmbassyTradingAllowed");

	push	OFFSET ??_C@_0BL@NAGAJAEL@AllowEmbassyTradingAllowed?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+349], al

; 137  : 	m_bOpenBordersTradingAllowed = kResults.GetBool("OpenBordersTradingAllowed");

	push	OFFSET ??_C@_0BK@MGOPDIKK@OpenBordersTradingAllowed?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+350], al

; 138  : 	m_bDefensivePactTradingAllowed = kResults.GetBool("DefensivePactTradingAllowed");

	push	OFFSET ??_C@_0BM@PKIJKDME@DefensivePactTradingAllowed?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+351], al

; 139  : 	m_bResearchAgreementTradingAllowed = kResults.GetBool("ResearchAgreementTradingAllowed");

	push	OFFSET ??_C@_0CA@ELGCCMJG@ResearchAgreementTradingAllowed?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+352], al

; 140  : 	m_bTradeAgreementTradingAllowed = kResults.GetBool("TradeAgreementTradingAllowed");

	push	OFFSET ??_C@_0BN@JEMNLGEL@TradeAgreementTradingAllowed?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+353], al

; 141  : 	m_bPermanentAllianceTrading = kResults.GetBool("PermanentAllianceTradingAllowed");

	push	OFFSET ??_C@_0CA@ICKMEKKP@PermanentAllianceTradingAllowed?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+354], al

; 142  : 	m_bBridgeBuilding = kResults.GetBool("BridgeBuilding");

	push	OFFSET ??_C@_0P@JKOGIKHO@BridgeBuilding?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+355], al

; 143  : 	m_bWaterWork = kResults.GetBool("WaterWork");

	push	OFFSET ??_C@_09IDNBDFGB@WaterWork?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+356], al

; 144  : 	m_iGridX = kResults.GetInt("GridX");

	push	OFFSET ??_C@_05KEOANLAO@GridX?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+324], eax

; 145  : 	m_iGridY = kResults.GetInt("GridY");

	push	OFFSET ??_C@_05LNPLOKEP@GridY?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+328], eax

; 146  : 
; 147  : 	//References
; 148  : 	const char* szTextVal = NULL;

	mov	DWORD PTR _szTextVal$[ebp], 0

; 149  : 	szTextVal = kResults.GetText("Era");

	push	OFFSET ??_C@_03FJOCGODE@Era?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTextVal$[ebp], eax

; 150  : 	m_iEra = GC.getInfoTypeForString(szTextVal, true);

	push	1
	mov	edx, DWORD PTR _szTextVal$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+276], eax

; 151  : 
; 152  : 	szTextVal = kResults.GetText("FirstFreeUnitClass");

	push	OFFSET ??_C@_0BD@MKGCGFCK@FirstFreeUnitClass?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTextVal$[ebp], eax

; 153  : 	m_iFirstFreeUnitClass = GC.getInfoTypeForString(szTextVal, true);

	push	1
	mov	edx, DWORD PTR _szTextVal$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+296], eax

; 154  : 
; 155  : 	szTextVal = kResults.GetText("Quote");

	push	OFFSET ??_C@_05JAOKFCIK@Quote?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTextVal$[ebp], eax

; 156  : 	SetQuoteKey(szTextVal);

	mov	edx, DWORD PTR _szTextVal$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetQuoteKey@CvTechEntry@@QAEXPBD@Z	; CvTechEntry::SetQuoteKey

; 157  : 
; 158  : 	szTextVal = kResults.GetText("AudioIntro");

	push	OFFSET ??_C@_0L@HPBDPPMB@AudioIntro?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTextVal$[ebp], eax

; 159  : 	SetSound(szTextVal);

	mov	eax, DWORD PTR _szTextVal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSound@CvTechEntry@@QAEXPBD@Z	; CvTechEntry::SetSound

; 160  : 
; 161  : 	szTextVal = kResults.GetText("AudioIntroHeader");

	push	OFFSET ??_C@_0BB@GBAPFEGA@AudioIntroHeader?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTextVal$[ebp], eax

; 162  : 	SetSoundMP(szTextVal);

	mov	ecx, DWORD PTR _szTextVal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSoundMP@CvTechEntry@@QAEXPBD@Z	; CvTechEntry::SetSoundMP

; 163  : 
; 164  : 	//Arrays
; 165  : 	const char* szTechType = GetType();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR _szTechType$[ebp], eax

; 166  : 	kUtility.PopulateArrayByValue(m_piDomainExtraMoves, "Domains", "Technology_DomainExtraMoves", "DomainType", "TechType", szTechType, "Moves", 0, NUM_DOMAIN_TYPES);

	push	5
	push	0
	push	OFFSET ??_C@_05OCMDHLMM@Moves?$AA@
	mov	edx, DWORD PTR _szTechType$[ebp]
	push	edx
	push	OFFSET ??_C@_08GHGFPPBE@TechType?$AA@
	push	OFFSET ??_C@_0L@NIGHKLOG@DomainType?$AA@
	push	OFFSET ??_C@_0BM@DHKPDGGE@Technology_DomainExtraMoves?$AA@
	push	OFFSET ??_C@_07FKLJOGGC@Domains?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 472				; 000001d8H
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 167  : 	kUtility.PopulateArrayByValue(m_piTradeRouteDomainExtraRange, "Domains", "Technology_TradeRouteDomainExtraRange", "DomainType", "TechType", szTechType, "Range", 0, NUM_DOMAIN_TYPES);

	push	5
	push	0
	push	OFFSET ??_C@_05CFMCGLCK@Range?$AA@
	mov	ecx, DWORD PTR _szTechType$[ebp]
	push	ecx
	push	OFFSET ??_C@_08GHGFPPBE@TechType?$AA@
	push	OFFSET ??_C@_0L@NIGHKLOG@DomainType?$AA@
	push	OFFSET ??_C@_0CG@INDDLKBJ@Technology_TradeRouteDomainExtra@
	push	OFFSET ??_C@_07FKLJOGGC@Domains?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 476				; 000001dcH
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 168  : 	kUtility.PopulateArrayByExistence(m_pabFreePromotion, "UnitPromotions", "Technology_FreePromotions", "PromotionType", "TechType", szTechType);

	mov	eax, DWORD PTR _szTechType$[ebp]
	push	eax
	push	OFFSET ??_C@_08GHGFPPBE@TechType?$AA@
	push	OFFSET ??_C@_0O@IILJPJBB@PromotionType?$AA@
	push	OFFSET ??_C@_0BK@KPPIEHLD@Technology_FreePromotions?$AA@
	push	OFFSET ??_C@_0P@GCBJCIAG@UnitPromotions?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 492				; 000001ecH
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence

; 169  : 	kUtility.SetFlavors(m_piFlavorValue, "Technology_Flavors", "TechType", szTechType);

	push	0
	mov	edx, DWORD PTR _szTechType$[ebp]
	push	edx
	push	OFFSET ??_C@_08GHGFPPBE@TechType?$AA@
	push	OFFSET ??_C@_0BD@LIOGFLEL@Technology_Flavors?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 480				; 000001e0H
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z ; CvDatabaseUtility::SetFlavors

; 170  : 
; 171  : 	const size_t TechnologiesCount = kUtility.MaxRows("Technologies");

	push	OFFSET ??_C@_0N@INKDAICK@Technologies?$AA@
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z	; CvDatabaseUtility::MaxRows
	mov	DWORD PTR _TechnologiesCount$[ebp], eax

; 172  : 
; 173  : 	//ORPrereqTechs
; 174  : 	{
; 175  : 		//PrereqTech array must be initialized to NO_TECH.
; 176  : 
; 177  : 		kUtility.InitializeArray(m_piPrereqOrTechs, TechnologiesCount, NO_TECH);

	push	-1
	mov	ecx, DWORD PTR _TechnologiesCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 484				; 000001e4H
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z ; CvDatabaseUtility::InitializeArray

; 178  : 
; 179  : 		std::string strKey = "Technologies - Technology_ORPrereqTechs";

	push	OFFSET ??_C@_0CI@EDCAPJKC@Technologies?5?9?5Technology_ORPrer@
	lea	ecx, DWORD PTR _strKey$222977[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 180  : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	eax, DWORD PTR _strKey$222977[ebp]
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$222979[ebp], eax

; 181  : 		if(pResults == NULL)

	cmp	DWORD PTR _pResults$222979[ebp], 0
	jne	SHORT $LN6@CacheResul

; 182  : 		{
; 183  : 			pResults = kUtility.PrepareResults(strKey, "select Technologies.ID from Technology_ORPrereqTechs inner join Technologies on Technologies.Type = PrereqTech where TechType = ?;");

	push	OFFSET ??_C@_0ID@JDHEGGPJ@select?5Technologies?4ID?5from?5Tech@
	lea	ecx, DWORD PTR _strKey$222977[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$222979[ebp], eax
$LN6@CacheResul:

; 184  : 		}
; 185  : 
; 186  : 		pResults->Bind(1, szTechType, -1, false);

	push	0
	push	-1
	mov	edx, DWORD PTR _szTechType$[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _pResults$222979[ebp]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBDH_N@Z

; 187  : 
; 188  : 		int i = 0;

	mov	DWORD PTR _i$222982[ebp], 0
$LN5@CacheResul:

; 189  : 		while(pResults->Step())

	mov	ecx, DWORD PTR _pResults$222979[ebp]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@CacheResul

; 190  : 		{
; 191  : 			m_piPrereqOrTechs[i++] = pResults->GetInt(0);

	push	0
	mov	ecx, DWORD PTR _pResults$222979[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+484]
	mov	ecx, DWORD PTR _i$222982[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	edx, DWORD PTR _i$222982[ebp]
	add	edx, 1
	mov	DWORD PTR _i$222982[ebp], edx

; 192  : 		}

	jmp	SHORT $LN5@CacheResul
$LN4@CacheResul:

; 193  : 
; 194  : 		pResults->Reset();

	mov	ecx, DWORD PTR _pResults$222979[ebp]
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 195  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strKey$222977[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 196  : 
; 197  : 	//PrereqTechs
; 198  : 	{
; 199  : 		//PrereqTech array must be initialized to NO_TECH.
; 200  : 		kUtility.InitializeArray(m_piPrereqAndTechs, TechnologiesCount, NO_TECH);

	push	-1
	mov	eax, DWORD PTR _TechnologiesCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 488				; 000001e8H
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z ; CvDatabaseUtility::InitializeArray

; 201  : 
; 202  : 		std::string strKey = "Technologies - Technology_PrereqTechs";

	push	OFFSET ??_C@_0CG@IGEMGBE@Technologies?5?9?5Technology_Prereq@
	lea	ecx, DWORD PTR _strKey$222986[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 203  : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	edx, DWORD PTR _strKey$222986[ebp]
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$222988[ebp], eax

; 204  : 		if(pResults == NULL)

	cmp	DWORD PTR _pResults$222988[ebp], 0
	jne	SHORT $LN3@CacheResul

; 205  : 		{
; 206  : 			pResults = kUtility.PrepareResults(strKey, "select Technologies.ID from Technology_PrereqTechs inner join Technologies on Technologies.Type = PrereqTech where TechType = ?;");

	push	OFFSET ??_C@_0IB@LKAKDCEK@select?5Technologies?4ID?5from?5Tech@
	lea	eax, DWORD PTR _strKey$222986[ebp]
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$222988[ebp], eax
$LN3@CacheResul:

; 207  : 		}
; 208  : 
; 209  : 		pResults->Bind(1, szTechType, -1, false);

	push	0
	push	-1
	mov	ecx, DWORD PTR _szTechType$[ebp]
	push	ecx
	push	1
	mov	ecx, DWORD PTR _pResults$222988[ebp]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBDH_N@Z

; 210  : 
; 211  : 		int i = 0;

	mov	DWORD PTR _i$222991[ebp], 0
$LN2@CacheResul:

; 212  : 		while(pResults->Step())

	mov	ecx, DWORD PTR _pResults$222988[ebp]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@CacheResul

; 213  : 		{
; 214  : 			m_piPrereqAndTechs[i++] = pResults->GetInt(0);

	push	0
	mov	ecx, DWORD PTR _pResults$222988[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+488]
	mov	ecx, DWORD PTR _i$222991[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	edx, DWORD PTR _i$222991[ebp]
	add	edx, 1
	mov	DWORD PTR _i$222991[ebp], edx

; 215  : 		}

	jmp	SHORT $LN2@CacheResul
$LN1@CacheResul:

; 216  : 
; 217  : 		pResults->Reset();

	mov	ecx, DWORD PTR _pResults$222988[ebp]
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 218  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strKey$222986[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 219  : 
; 220  : 	return true;

	mov	al, 1
$LN8@CacheResul:

; 221  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CacheResults@CvTechEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0:
	lea	ecx, DWORD PTR _strKey$222977[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvTechEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$1:
	lea	ecx, DWORD PTR _strKey$222986[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?CacheResults@CvTechEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-112]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?CacheResults@CvTechEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CacheResults@CvTechEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvTechEntry::CacheResults
PUBLIC	?GetAIWeight@CvTechEntry@@QBEHXZ		; CvTechEntry::GetAIWeight
; Function compile flags: /Odtp
;	COMDAT ?GetAIWeight@CvTechEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAIWeight@CvTechEntry@@QBEHXZ PROC			; CvTechEntry::GetAIWeight, COMDAT
; _this$ = ecx

; 225  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 226  : 	return m_iAIWeight;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+260]

; 227  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetAIWeight@CvTechEntry@@QBEHXZ ENDP			; CvTechEntry::GetAIWeight
_TEXT	ENDS
PUBLIC	?GetAITradeModifier@CvTechEntry@@QBEHXZ		; CvTechEntry::GetAITradeModifier
; Function compile flags: /Odtp
;	COMDAT ?GetAITradeModifier@CvTechEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAITradeModifier@CvTechEntry@@QBEHXZ PROC		; CvTechEntry::GetAITradeModifier, COMDAT
; _this$ = ecx

; 231  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 232  : 	return m_iAITradeModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+264]

; 233  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetAITradeModifier@CvTechEntry@@QBEHXZ ENDP		; CvTechEntry::GetAITradeModifier
_TEXT	ENDS
PUBLIC	?GetResearchCost@CvTechEntry@@QBEHXZ		; CvTechEntry::GetResearchCost
; Function compile flags: /Odtp
;	COMDAT ?GetResearchCost@CvTechEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetResearchCost@CvTechEntry@@QBEHXZ PROC		; CvTechEntry::GetResearchCost, COMDAT
; _this$ = ecx

; 237  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 238  : 	return m_iResearchCost;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+268]

; 239  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetResearchCost@CvTechEntry@@QBEHXZ ENDP		; CvTechEntry::GetResearchCost
_TEXT	ENDS
PUBLIC	?GetAdvancedStartCost@CvTechEntry@@QBEHXZ	; CvTechEntry::GetAdvancedStartCost
; Function compile flags: /Odtp
;	COMDAT ?GetAdvancedStartCost@CvTechEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAdvancedStartCost@CvTechEntry@@QBEHXZ PROC		; CvTechEntry::GetAdvancedStartCost, COMDAT
; _this$ = ecx

; 243  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 244  : 	return m_iAdvancedStartCost;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+272]

; 245  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetAdvancedStartCost@CvTechEntry@@QBEHXZ ENDP		; CvTechEntry::GetAdvancedStartCost
_TEXT	ENDS
PUBLIC	?GetEra@CvTechEntry@@QBEHXZ			; CvTechEntry::GetEra
; Function compile flags: /Odtp
;	COMDAT ?GetEra@CvTechEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetEra@CvTechEntry@@QBEHXZ PROC			; CvTechEntry::GetEra, COMDAT
; _this$ = ecx

; 249  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 250  : 	return m_iEra;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+276]

; 251  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetEra@CvTechEntry@@QBEHXZ ENDP			; CvTechEntry::GetEra
_TEXT	ENDS
PUBLIC	?GetFeatureProductionModifier@CvTechEntry@@QBEHXZ ; CvTechEntry::GetFeatureProductionModifier
; Function compile flags: /Odtp
;	COMDAT ?GetFeatureProductionModifier@CvTechEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFeatureProductionModifier@CvTechEntry@@QBEHXZ PROC	; CvTechEntry::GetFeatureProductionModifier, COMDAT
; _this$ = ecx

; 255  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 256  : 	return m_iFeatureProductionModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+280]

; 257  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFeatureProductionModifier@CvTechEntry@@QBEHXZ ENDP	; CvTechEntry::GetFeatureProductionModifier
_TEXT	ENDS
PUBLIC	?GetUnitFortificationModifier@CvTechEntry@@QBEHXZ ; CvTechEntry::GetUnitFortificationModifier
; Function compile flags: /Odtp
;	COMDAT ?GetUnitFortificationModifier@CvTechEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitFortificationModifier@CvTechEntry@@QBEHXZ PROC	; CvTechEntry::GetUnitFortificationModifier, COMDAT
; _this$ = ecx

; 261  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 262  : 	return m_iUnitFortificationModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+284]

; 263  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitFortificationModifier@CvTechEntry@@QBEHXZ ENDP	; CvTechEntry::GetUnitFortificationModifier
_TEXT	ENDS
PUBLIC	?GetUnitBaseHealModifier@CvTechEntry@@QBEHXZ	; CvTechEntry::GetUnitBaseHealModifier
; Function compile flags: /Odtp
;	COMDAT ?GetUnitBaseHealModifier@CvTechEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitBaseHealModifier@CvTechEntry@@QBEHXZ PROC	; CvTechEntry::GetUnitBaseHealModifier, COMDAT
; _this$ = ecx

; 267  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 268  : 	return m_iUnitBaseHealModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+288]

; 269  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitBaseHealModifier@CvTechEntry@@QBEHXZ ENDP	; CvTechEntry::GetUnitBaseHealModifier
_TEXT	ENDS
PUBLIC	?GetWorkerSpeedModifier@CvTechEntry@@QBEHXZ	; CvTechEntry::GetWorkerSpeedModifier
; Function compile flags: /Odtp
;	COMDAT ?GetWorkerSpeedModifier@CvTechEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWorkerSpeedModifier@CvTechEntry@@QBEHXZ PROC	; CvTechEntry::GetWorkerSpeedModifier, COMDAT
; _this$ = ecx

; 273  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 274  : 	return m_iWorkerSpeedModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+292]

; 275  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetWorkerSpeedModifier@CvTechEntry@@QBEHXZ ENDP	; CvTechEntry::GetWorkerSpeedModifier
_TEXT	ENDS
PUBLIC	?GetFirstFreeUnitClass@CvTechEntry@@QBEHXZ	; CvTechEntry::GetFirstFreeUnitClass
; Function compile flags: /Odtp
;	COMDAT ?GetFirstFreeUnitClass@CvTechEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFirstFreeUnitClass@CvTechEntry@@QBEHXZ PROC		; CvTechEntry::GetFirstFreeUnitClass, COMDAT
; _this$ = ecx

; 279  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 280  : 	return m_iFirstFreeUnitClass;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+296]

; 281  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFirstFreeUnitClass@CvTechEntry@@QBEHXZ ENDP		; CvTechEntry::GetFirstFreeUnitClass
_TEXT	ENDS
PUBLIC	?GetFirstFreeTechs@CvTechEntry@@QBEHXZ		; CvTechEntry::GetFirstFreeTechs
; Function compile flags: /Odtp
;	COMDAT ?GetFirstFreeTechs@CvTechEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFirstFreeTechs@CvTechEntry@@QBEHXZ PROC		; CvTechEntry::GetFirstFreeTechs, COMDAT
; _this$ = ecx

; 285  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 286  : 	return m_iFirstFreeTechs;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+300]

; 287  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFirstFreeTechs@CvTechEntry@@QBEHXZ ENDP		; CvTechEntry::GetFirstFreeTechs
_TEXT	ENDS
PUBLIC	?GetEmbarkedMoveChange@CvTechEntry@@QBEHXZ	; CvTechEntry::GetEmbarkedMoveChange
; Function compile flags: /Odtp
;	COMDAT ?GetEmbarkedMoveChange@CvTechEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetEmbarkedMoveChange@CvTechEntry@@QBEHXZ PROC		; CvTechEntry::GetEmbarkedMoveChange, COMDAT
; _this$ = ecx

; 291  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 292  : 	return m_iEmbarkedMoveChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+304]

; 293  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetEmbarkedMoveChange@CvTechEntry@@QBEHXZ ENDP		; CvTechEntry::GetEmbarkedMoveChange
_TEXT	ENDS
PUBLIC	?GetEmbarkedSightChange@CvTechEntry@@QBEHXZ	; CvTechEntry::GetEmbarkedSightChange
; Function compile flags: /Odtp
;	COMDAT ?GetEmbarkedSightChange@CvTechEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetEmbarkedSightChange@CvTechEntry@@QBEHXZ PROC	; CvTechEntry::GetEmbarkedSightChange, COMDAT
; _this$ = ecx

; 297  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 298  : 	return m_iEmbarkedSightChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+308]

; 299  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetEmbarkedSightChange@CvTechEntry@@QBEHXZ ENDP	; CvTechEntry::GetEmbarkedSightChange
_TEXT	ENDS
PUBLIC	?GetNumInternationalTradeRoutesChange@CvTechEntry@@QBEHXZ ; CvTechEntry::GetNumInternationalTradeRoutesChange
; Function compile flags: /Odtp
;	COMDAT ?GetNumInternationalTradeRoutesChange@CvTechEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumInternationalTradeRoutesChange@CvTechEntry@@QBEHXZ PROC ; CvTechEntry::GetNumInternationalTradeRoutesChange, COMDAT
; _this$ = ecx

; 303  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 304  : 	return m_iInternationalTradeRoutesChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+312]

; 305  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumInternationalTradeRoutesChange@CvTechEntry@@QBEHXZ ENDP ; CvTechEntry::GetNumInternationalTradeRoutesChange
_TEXT	ENDS
PUBLIC	?GetInfluenceSpreadModifier@CvTechEntry@@QBEHXZ	; CvTechEntry::GetInfluenceSpreadModifier
; Function compile flags: /Odtp
;	COMDAT ?GetInfluenceSpreadModifier@CvTechEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetInfluenceSpreadModifier@CvTechEntry@@QBEHXZ PROC	; CvTechEntry::GetInfluenceSpreadModifier, COMDAT
; _this$ = ecx

; 309  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 310  : 	return m_iInfluenceSpreadModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+316]

; 311  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetInfluenceSpreadModifier@CvTechEntry@@QBEHXZ ENDP	; CvTechEntry::GetInfluenceSpreadModifier
_TEXT	ENDS
PUBLIC	?GetExtraVotesPerDiplomat@CvTechEntry@@QBEHXZ	; CvTechEntry::GetExtraVotesPerDiplomat
; Function compile flags: /Odtp
;	COMDAT ?GetExtraVotesPerDiplomat@CvTechEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetExtraVotesPerDiplomat@CvTechEntry@@QBEHXZ PROC	; CvTechEntry::GetExtraVotesPerDiplomat, COMDAT
; _this$ = ecx

; 315  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 316  : 	return m_iExtraVotesPerDiplomat;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+320]

; 317  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetExtraVotesPerDiplomat@CvTechEntry@@QBEHXZ ENDP	; CvTechEntry::GetExtraVotesPerDiplomat
_TEXT	ENDS
PUBLIC	?GetGridX@CvTechEntry@@QBEHXZ			; CvTechEntry::GetGridX
; Function compile flags: /Odtp
;	COMDAT ?GetGridX@CvTechEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGridX@CvTechEntry@@QBEHXZ PROC			; CvTechEntry::GetGridX, COMDAT
; _this$ = ecx

; 321  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 322  : 	return m_iGridX;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+324]

; 323  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGridX@CvTechEntry@@QBEHXZ ENDP			; CvTechEntry::GetGridX
_TEXT	ENDS
PUBLIC	?GetGridY@CvTechEntry@@QBEHXZ			; CvTechEntry::GetGridY
; Function compile flags: /Odtp
;	COMDAT ?GetGridY@CvTechEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGridY@CvTechEntry@@QBEHXZ PROC			; CvTechEntry::GetGridY, COMDAT
; _this$ = ecx

; 327  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 328  : 	return m_iGridY;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+328]

; 329  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGridY@CvTechEntry@@QBEHXZ ENDP			; CvTechEntry::GetGridY
_TEXT	ENDS
PUBLIC	?IsEndsGame@CvTechEntry@@QBE_NXZ		; CvTechEntry::IsEndsGame
; Function compile flags: /Odtp
;	COMDAT ?IsEndsGame@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsEndsGame@CvTechEntry@@QBE_NXZ PROC			; CvTechEntry::IsEndsGame, COMDAT
; _this$ = ecx

; 333  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 334  : 	return m_bEndsGame;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+332]

; 335  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsEndsGame@CvTechEntry@@QBE_NXZ ENDP			; CvTechEntry::IsEndsGame
_TEXT	ENDS
PUBLIC	?IsAllowsEmbarking@CvTechEntry@@QBE_NXZ		; CvTechEntry::IsAllowsEmbarking
; Function compile flags: /Odtp
;	COMDAT ?IsAllowsEmbarking@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAllowsEmbarking@CvTechEntry@@QBE_NXZ PROC		; CvTechEntry::IsAllowsEmbarking, COMDAT
; _this$ = ecx

; 339  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 340  : 	return m_bAllowsEmbarking;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+333]

; 341  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsAllowsEmbarking@CvTechEntry@@QBE_NXZ ENDP		; CvTechEntry::IsAllowsEmbarking
_TEXT	ENDS
PUBLIC	?IsAllowsEmbarkingCivilian@CvTechEntry@@QBE_NXZ	; CvTechEntry::IsAllowsEmbarkingCivilian
; Function compile flags: /Odtp
;	COMDAT ?IsAllowsEmbarkingCivilian@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAllowsEmbarkingCivilian@CvTechEntry@@QBE_NXZ PROC	; CvTechEntry::IsAllowsEmbarkingCivilian, COMDAT
; _this$ = ecx

; 345  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 346  : 	return m_bAllowsEmbarkingCivilian;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+334]

; 347  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsAllowsEmbarkingCivilian@CvTechEntry@@QBE_NXZ ENDP	; CvTechEntry::IsAllowsEmbarkingCivilian
_TEXT	ENDS
PUBLIC	?IsAllowsDefensiveEmbarking@CvTechEntry@@QBE_NXZ ; CvTechEntry::IsAllowsDefensiveEmbarking
; Function compile flags: /Odtp
;	COMDAT ?IsAllowsDefensiveEmbarking@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAllowsDefensiveEmbarking@CvTechEntry@@QBE_NXZ PROC	; CvTechEntry::IsAllowsDefensiveEmbarking, COMDAT
; _this$ = ecx

; 351  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 352  : 	return m_bAllowsDefensiveEmbarking;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+335]

; 353  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsAllowsDefensiveEmbarking@CvTechEntry@@QBE_NXZ ENDP	; CvTechEntry::IsAllowsDefensiveEmbarking
_TEXT	ENDS
PUBLIC	?IsEmbarkedAllWaterPassage@CvTechEntry@@QBE_NXZ	; CvTechEntry::IsEmbarkedAllWaterPassage
; Function compile flags: /Odtp
;	COMDAT ?IsEmbarkedAllWaterPassage@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsEmbarkedAllWaterPassage@CvTechEntry@@QBE_NXZ PROC	; CvTechEntry::IsEmbarkedAllWaterPassage, COMDAT
; _this$ = ecx

; 357  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 358  : 	return m_bEmbarkedAllWaterPassage;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+336]

; 359  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsEmbarkedAllWaterPassage@CvTechEntry@@QBE_NXZ ENDP	; CvTechEntry::IsEmbarkedAllWaterPassage
_TEXT	ENDS
PUBLIC	?IsAllowsBarbarianBoats@CvTechEntry@@QBE_NXZ	; CvTechEntry::IsAllowsBarbarianBoats
; Function compile flags: /Odtp
;	COMDAT ?IsAllowsBarbarianBoats@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAllowsBarbarianBoats@CvTechEntry@@QBE_NXZ PROC	; CvTechEntry::IsAllowsBarbarianBoats, COMDAT
; _this$ = ecx

; 363  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 364  : 	return m_bAllowsBarbarianBoats;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+337]

; 365  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsAllowsBarbarianBoats@CvTechEntry@@QBE_NXZ ENDP	; CvTechEntry::IsAllowsBarbarianBoats
_TEXT	ENDS
PUBLIC	?IsRepeat@CvTechEntry@@QBE_NXZ			; CvTechEntry::IsRepeat
; Function compile flags: /Odtp
;	COMDAT ?IsRepeat@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsRepeat@CvTechEntry@@QBE_NXZ PROC			; CvTechEntry::IsRepeat, COMDAT
; _this$ = ecx

; 369  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 370  : 	return m_bRepeat;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+338]

; 371  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsRepeat@CvTechEntry@@QBE_NXZ ENDP			; CvTechEntry::IsRepeat
_TEXT	ENDS
PUBLIC	?IsTrade@CvTechEntry@@QBE_NXZ			; CvTechEntry::IsTrade
; Function compile flags: /Odtp
;	COMDAT ?IsTrade@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsTrade@CvTechEntry@@QBE_NXZ PROC			; CvTechEntry::IsTrade, COMDAT
; _this$ = ecx

; 375  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 376  : 	return m_bTrade;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+339]

; 377  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTrade@CvTechEntry@@QBE_NXZ ENDP			; CvTechEntry::IsTrade
_TEXT	ENDS
PUBLIC	?IsDisable@CvTechEntry@@QBE_NXZ			; CvTechEntry::IsDisable
; Function compile flags: /Odtp
;	COMDAT ?IsDisable@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsDisable@CvTechEntry@@QBE_NXZ PROC			; CvTechEntry::IsDisable, COMDAT
; _this$ = ecx

; 381  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 382  : 	return m_bDisable;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+340]

; 383  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsDisable@CvTechEntry@@QBE_NXZ ENDP			; CvTechEntry::IsDisable
_TEXT	ENDS
PUBLIC	?IsGoodyTech@CvTechEntry@@QBE_NXZ		; CvTechEntry::IsGoodyTech
; Function compile flags: /Odtp
;	COMDAT ?IsGoodyTech@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsGoodyTech@CvTechEntry@@QBE_NXZ PROC			; CvTechEntry::IsGoodyTech, COMDAT
; _this$ = ecx

; 388  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 389  : 	return m_bGoodyTech;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+342]

; 390  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsGoodyTech@CvTechEntry@@QBE_NXZ ENDP			; CvTechEntry::IsGoodyTech
_TEXT	ENDS
PUBLIC	?IsTriggersArchaeologicalSites@CvTechEntry@@QBE_NXZ ; CvTechEntry::IsTriggersArchaeologicalSites
; Function compile flags: /Odtp
;	COMDAT ?IsTriggersArchaeologicalSites@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsTriggersArchaeologicalSites@CvTechEntry@@QBE_NXZ PROC ; CvTechEntry::IsTriggersArchaeologicalSites, COMDAT
; _this$ = ecx

; 394  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 395  : 	return m_bTriggersArchaeologicalSites;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+357]

; 396  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTriggersArchaeologicalSites@CvTechEntry@@QBE_NXZ ENDP ; CvTechEntry::IsTriggersArchaeologicalSites
_TEXT	ENDS
PUBLIC	?IsAllowsWorldCongress@CvTechEntry@@QBE_NXZ	; CvTechEntry::IsAllowsWorldCongress
; Function compile flags: /Odtp
;	COMDAT ?IsAllowsWorldCongress@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAllowsWorldCongress@CvTechEntry@@QBE_NXZ PROC	; CvTechEntry::IsAllowsWorldCongress, COMDAT
; _this$ = ecx

; 400  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 401  : 	return m_bAllowsWorldCongress;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+358]

; 402  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsAllowsWorldCongress@CvTechEntry@@QBE_NXZ ENDP	; CvTechEntry::IsAllowsWorldCongress
_TEXT	ENDS
PUBLIC	?IsExtraWaterSeeFrom@CvTechEntry@@QBE_NXZ	; CvTechEntry::IsExtraWaterSeeFrom
; Function compile flags: /Odtp
;	COMDAT ?IsExtraWaterSeeFrom@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsExtraWaterSeeFrom@CvTechEntry@@QBE_NXZ PROC		; CvTechEntry::IsExtraWaterSeeFrom, COMDAT
; _this$ = ecx

; 406  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 407  : 	return m_bExtraWaterSeeFrom;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+343]

; 408  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsExtraWaterSeeFrom@CvTechEntry@@QBE_NXZ ENDP		; CvTechEntry::IsExtraWaterSeeFrom
_TEXT	ENDS
PUBLIC	?IsMapCentering@CvTechEntry@@QBE_NXZ		; CvTechEntry::IsMapCentering
; Function compile flags: /Odtp
;	COMDAT ?IsMapCentering@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsMapCentering@CvTechEntry@@QBE_NXZ PROC		; CvTechEntry::IsMapCentering, COMDAT
; _this$ = ecx

; 412  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 413  : 	return m_bMapCentering;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+344]

; 414  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsMapCentering@CvTechEntry@@QBE_NXZ ENDP		; CvTechEntry::IsMapCentering
_TEXT	ENDS
PUBLIC	?IsMapVisible@CvTechEntry@@QBE_NXZ		; CvTechEntry::IsMapVisible
; Function compile flags: /Odtp
;	COMDAT ?IsMapVisible@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsMapVisible@CvTechEntry@@QBE_NXZ PROC			; CvTechEntry::IsMapVisible, COMDAT
; _this$ = ecx

; 418  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 419  : 	return m_bMapVisible;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+345]

; 420  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsMapVisible@CvTechEntry@@QBE_NXZ ENDP			; CvTechEntry::IsMapVisible
_TEXT	ENDS
PUBLIC	?IsMapTrading@CvTechEntry@@QBE_NXZ		; CvTechEntry::IsMapTrading
; Function compile flags: /Odtp
;	COMDAT ?IsMapTrading@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsMapTrading@CvTechEntry@@QBE_NXZ PROC			; CvTechEntry::IsMapTrading, COMDAT
; _this$ = ecx

; 424  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 425  : 	return m_bMapTrading;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+346]

; 426  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsMapTrading@CvTechEntry@@QBE_NXZ ENDP			; CvTechEntry::IsMapTrading
_TEXT	ENDS
PUBLIC	?IsTechTrading@CvTechEntry@@QBE_NXZ		; CvTechEntry::IsTechTrading
; Function compile flags: /Odtp
;	COMDAT ?IsTechTrading@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsTechTrading@CvTechEntry@@QBE_NXZ PROC		; CvTechEntry::IsTechTrading, COMDAT
; _this$ = ecx

; 430  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 431  : 	return m_bTechTrading;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+347]

; 432  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTechTrading@CvTechEntry@@QBE_NXZ ENDP		; CvTechEntry::IsTechTrading
_TEXT	ENDS
PUBLIC	?IsGoldTrading@CvTechEntry@@QBE_NXZ		; CvTechEntry::IsGoldTrading
; Function compile flags: /Odtp
;	COMDAT ?IsGoldTrading@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsGoldTrading@CvTechEntry@@QBE_NXZ PROC		; CvTechEntry::IsGoldTrading, COMDAT
; _this$ = ecx

; 436  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 437  : 	return m_bGoldTrading;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+348]

; 438  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsGoldTrading@CvTechEntry@@QBE_NXZ ENDP		; CvTechEntry::IsGoldTrading
_TEXT	ENDS
PUBLIC	?IsAllowEmbassyTradingAllowed@CvTechEntry@@QBE_NXZ ; CvTechEntry::IsAllowEmbassyTradingAllowed
; Function compile flags: /Odtp
;	COMDAT ?IsAllowEmbassyTradingAllowed@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAllowEmbassyTradingAllowed@CvTechEntry@@QBE_NXZ PROC	; CvTechEntry::IsAllowEmbassyTradingAllowed, COMDAT
; _this$ = ecx

; 442  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 443  : 	return m_bAllowEmbassyTradingAllowed;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+349]

; 444  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsAllowEmbassyTradingAllowed@CvTechEntry@@QBE_NXZ ENDP	; CvTechEntry::IsAllowEmbassyTradingAllowed
_TEXT	ENDS
PUBLIC	?IsOpenBordersTradingAllowed@CvTechEntry@@QBE_NXZ ; CvTechEntry::IsOpenBordersTradingAllowed
; Function compile flags: /Odtp
;	COMDAT ?IsOpenBordersTradingAllowed@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsOpenBordersTradingAllowed@CvTechEntry@@QBE_NXZ PROC	; CvTechEntry::IsOpenBordersTradingAllowed, COMDAT
; _this$ = ecx

; 448  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 449  : 	return m_bOpenBordersTradingAllowed;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+350]

; 450  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsOpenBordersTradingAllowed@CvTechEntry@@QBE_NXZ ENDP	; CvTechEntry::IsOpenBordersTradingAllowed
_TEXT	ENDS
PUBLIC	?IsDefensivePactTradingAllowed@CvTechEntry@@QBE_NXZ ; CvTechEntry::IsDefensivePactTradingAllowed
; Function compile flags: /Odtp
;	COMDAT ?IsDefensivePactTradingAllowed@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsDefensivePactTradingAllowed@CvTechEntry@@QBE_NXZ PROC ; CvTechEntry::IsDefensivePactTradingAllowed, COMDAT
; _this$ = ecx

; 454  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 455  : 	return m_bDefensivePactTradingAllowed;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+351]

; 456  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsDefensivePactTradingAllowed@CvTechEntry@@QBE_NXZ ENDP ; CvTechEntry::IsDefensivePactTradingAllowed
_TEXT	ENDS
PUBLIC	?IsResearchAgreementTradingAllowed@CvTechEntry@@QBE_NXZ ; CvTechEntry::IsResearchAgreementTradingAllowed
; Function compile flags: /Odtp
;	COMDAT ?IsResearchAgreementTradingAllowed@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsResearchAgreementTradingAllowed@CvTechEntry@@QBE_NXZ PROC ; CvTechEntry::IsResearchAgreementTradingAllowed, COMDAT
; _this$ = ecx

; 460  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 461  : 	return m_bResearchAgreementTradingAllowed;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+352]

; 462  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsResearchAgreementTradingAllowed@CvTechEntry@@QBE_NXZ ENDP ; CvTechEntry::IsResearchAgreementTradingAllowed
_TEXT	ENDS
PUBLIC	?IsTradeAgreementTradingAllowed@CvTechEntry@@QBE_NXZ ; CvTechEntry::IsTradeAgreementTradingAllowed
; Function compile flags: /Odtp
;	COMDAT ?IsTradeAgreementTradingAllowed@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsTradeAgreementTradingAllowed@CvTechEntry@@QBE_NXZ PROC ; CvTechEntry::IsTradeAgreementTradingAllowed, COMDAT
; _this$ = ecx

; 466  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 467  : 	return m_bTradeAgreementTradingAllowed;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+353]

; 468  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTradeAgreementTradingAllowed@CvTechEntry@@QBE_NXZ ENDP ; CvTechEntry::IsTradeAgreementTradingAllowed
_TEXT	ENDS
PUBLIC	?IsPermanentAllianceTrading@CvTechEntry@@QBE_NXZ ; CvTechEntry::IsPermanentAllianceTrading
; Function compile flags: /Odtp
;	COMDAT ?IsPermanentAllianceTrading@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsPermanentAllianceTrading@CvTechEntry@@QBE_NXZ PROC	; CvTechEntry::IsPermanentAllianceTrading, COMDAT
; _this$ = ecx

; 472  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 473  : 	return m_bPermanentAllianceTrading;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+354]

; 474  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsPermanentAllianceTrading@CvTechEntry@@QBE_NXZ ENDP	; CvTechEntry::IsPermanentAllianceTrading
_TEXT	ENDS
PUBLIC	?IsBridgeBuilding@CvTechEntry@@QBE_NXZ		; CvTechEntry::IsBridgeBuilding
; Function compile flags: /Odtp
;	COMDAT ?IsBridgeBuilding@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsBridgeBuilding@CvTechEntry@@QBE_NXZ PROC		; CvTechEntry::IsBridgeBuilding, COMDAT
; _this$ = ecx

; 478  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 479  : 	return m_bBridgeBuilding;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+355]

; 480  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsBridgeBuilding@CvTechEntry@@QBE_NXZ ENDP		; CvTechEntry::IsBridgeBuilding
_TEXT	ENDS
PUBLIC	?IsWaterWork@CvTechEntry@@QBE_NXZ		; CvTechEntry::IsWaterWork
; Function compile flags: /Odtp
;	COMDAT ?IsWaterWork@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsWaterWork@CvTechEntry@@QBE_NXZ PROC			; CvTechEntry::IsWaterWork, COMDAT
; _this$ = ecx

; 484  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 485  : 	return m_bWaterWork;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+356]

; 486  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsWaterWork@CvTechEntry@@QBE_NXZ ENDP			; CvTechEntry::IsWaterWork
_TEXT	ENDS
PUBLIC	?IsFreePromotion@CvTechEntry@@QBEHH@Z		; CvTechEntry::IsFreePromotion
; Function compile flags: /Odtp
;	COMDAT ?IsFreePromotion@CvTechEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?IsFreePromotion@CvTechEntry@@QBEHH@Z PROC		; CvTechEntry::IsFreePromotion, COMDAT
; _this$ = ecx

; 490  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 491  : 	return m_pabFreePromotion ? m_pabFreePromotion[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+492], 0
	je	SHORT $LN3@IsFreeProm
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+492]
	mov	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [edx+eax]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@IsFreeProm
$LN3@IsFreeProm:
	mov	DWORD PTR tv69[ebp], -1
$LN4@IsFreeProm:
	mov	eax, DWORD PTR tv69[ebp]

; 492  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsFreePromotion@CvTechEntry@@QBEHH@Z ENDP		; CvTechEntry::IsFreePromotion
_TEXT	ENDS
PUBLIC	?GetQuote@CvTechEntry@@QAEPBDXZ			; CvTechEntry::GetQuote
; Function compile flags: /Odtp
;	COMDAT ?GetQuote@CvTechEntry@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetQuote@CvTechEntry@@QAEPBDXZ PROC			; CvTechEntry::GetQuote, COMDAT
; _this$ = ecx

; 496  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 	return m_wstrQuote.c_str();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 388				; 00000184H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 498  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetQuote@CvTechEntry@@QAEPBDXZ ENDP			; CvTechEntry::GetQuote
_TEXT	ENDS
PUBLIC	?GetLocalizedText@@YA?AVCvString@@PBD@Z		; GetLocalizedText
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?SetQuoteKey@CvTechEntry@@QAEXPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetQuoteKey@CvTechEntry@@QAEXPBD@Z$0
__ehfuncinfo$?SetQuoteKey@CvTechEntry@@QAEXPBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SetQuoteKey@CvTechEntry@@QAEXPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtechclasses.cpp
xdata$x	ENDS
;	COMDAT ?SetQuoteKey@CvTechEntry@@QAEXPBD@Z
_TEXT	SEGMENT
tv76 = -64						; size = 4
_this$ = -60						; size = 4
$T226430 = -56						; size = 4
$T226429 = -52						; size = 4
$T226425 = -48						; size = 4
$T226421 = -44						; size = 4
$T226414 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_szVal$ = 8						; size = 4
?SetQuoteKey@CvTechEntry@@QAEXPBD@Z PROC		; CvTechEntry::SetQuoteKey, COMDAT
; _this$ = ecx

; 502  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetQuoteKey@CvTechEntry@@QAEXPBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 503  : 	m_strQuoteKey = szVal;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 360				; 00000168H
	mov	DWORD PTR $T226421[ebp], eax
	cmp	DWORD PTR _szVal$[ebp], 0
	je	SHORT $LN5@SetQuoteKe
	mov	ecx, DWORD PTR _szVal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T226421[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN6@SetQuoteKe
$LN5@SetQuoteKe:
	mov	ecx, DWORD PTR $T226421[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN6@SetQuoteKe:

; 504  : 	m_wstrQuote = GetLocalizedText(m_strQuoteKey);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 360				; 00000168H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T226425[ebp], eax
	mov	edx, DWORD PTR $T226425[ebp]
	push	edx
	lea	eax, DWORD PTR $T226414[ebp]
	push	eax
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	mov	DWORD PTR tv76[ebp], eax
	mov	ecx, DWORD PTR tv76[ebp]
	mov	DWORD PTR $T226430[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 388				; 00000184H
	mov	DWORD PTR $T226429[ebp], edx
	mov	eax, DWORD PTR $T226430[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226429[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T226414[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 505  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetQuoteKey@CvTechEntry@@QAEXPBD@Z$0:
	lea	ecx, DWORD PTR $T226414[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?SetQuoteKey@CvTechEntry@@QAEXPBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetQuoteKey@CvTechEntry@@QAEXPBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetQuoteKey@CvTechEntry@@QAEXPBD@Z ENDP		; CvTechEntry::SetQuoteKey
PUBLIC	__$ArrayPad$
EXTRN	__imp_??1String@Localization@@UAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z:PROC
EXTRN	__imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z:PROC
EXTRN	__imp_?Lookup@Localization@@YA?AVString@1@PBD@Z:PROC
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?GetLocalizedText@@YA?AVCvString@@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$1
__ehfuncinfo$?GetLocalizedText@@YA?AVCvString@@PBD@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ?GetLocalizedText@@YA?AVCvString@@PBD@Z
_TEXT	SEGMENT
$T226447 = -140						; size = 4
_str$ = -136						; size = 28
__$ArrayPad$ = -108					; size = 4
_bytes$ = -104						; size = 4
_text$ = -100						; size = 80
_szComposedString$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
?GetLocalizedText@@YA?AVCvString@@PBD@Z PROC		; GetLocalizedText, COMDAT

; 489  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 128				; 00000080H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T226447[ebp], 0

; 490  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[ebp]
	push	eax
	lea	ecx, DWORD PTR _text$[ebp]
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 491  : 
; 492  : 	size_t bytes = 0;

	mov	DWORD PTR _bytes$[ebp], 0

; 493  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	edx, DWORD PTR _bytes$[ebp]
	push	edx
	lea	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z
	mov	DWORD PTR _szComposedString$[ebp], eax

; 494  : 	CvString str;

	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 495  : 	str.assign(szComposedString, bytes);

	mov	eax, DWORD PTR _bytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szComposedString$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z

; 496  : 	return str;

	lea	edx, DWORD PTR _str$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T226447[ebp]
	or	eax, 1
	mov	DWORD PTR $T226447[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 497  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$1:
	lea	ecx, DWORD PTR _str$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$2:
	mov	eax, DWORD PTR $T226447[ebp]
	and	eax, 1
	je	$LN6@GetLocaliz
	and	DWORD PTR $T226447[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN6@GetLocaliz:
	ret	0
__ehhandler$?GetLocalizedText@@YA?AVCvString@@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-132]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetLocalizedText@@YA?AVCvString@@PBD@Z ENDP		; GetLocalizedText
PUBLIC	?GetSound@CvTechEntry@@QBEPBDXZ			; CvTechEntry::GetSound
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtechclasses.cpp
;	COMDAT ?GetSound@CvTechEntry@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSound@CvTechEntry@@QBEPBDXZ PROC			; CvTechEntry::GetSound, COMDAT
; _this$ = ecx

; 509  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 510  : 	return m_strSound;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 416				; 000001a0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 511  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetSound@CvTechEntry@@QBEPBDXZ ENDP			; CvTechEntry::GetSound
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?SetSound@CvTechEntry@@QAEXPBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T226479 = -4						; size = 4
_szVal$ = 8						; size = 4
?SetSound@CvTechEntry@@QAEXPBD@Z PROC			; CvTechEntry::SetSound, COMDAT
; _this$ = ecx

; 515  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 516  : 	m_strSound = szVal;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 416				; 000001a0H
	mov	DWORD PTR $T226479[ebp], eax
	cmp	DWORD PTR _szVal$[ebp], 0
	je	SHORT $LN4@SetSound
	mov	ecx, DWORD PTR _szVal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T226479[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN1@SetSound
$LN4@SetSound:
	mov	ecx, DWORD PTR $T226479[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN1@SetSound:

; 517  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetSound@CvTechEntry@@QAEXPBD@Z ENDP			; CvTechEntry::SetSound
_TEXT	ENDS
PUBLIC	?GetSoundMP@CvTechEntry@@QBEPBDXZ		; CvTechEntry::GetSoundMP
; Function compile flags: /Odtp
;	COMDAT ?GetSoundMP@CvTechEntry@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSoundMP@CvTechEntry@@QBEPBDXZ PROC			; CvTechEntry::GetSoundMP, COMDAT
; _this$ = ecx

; 521  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 	return m_strSoundMP;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 444				; 000001bcH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 523  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetSoundMP@CvTechEntry@@QBEPBDXZ ENDP			; CvTechEntry::GetSoundMP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?SetSoundMP@CvTechEntry@@QAEXPBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T226492 = -4						; size = 4
_szVal$ = 8						; size = 4
?SetSoundMP@CvTechEntry@@QAEXPBD@Z PROC			; CvTechEntry::SetSoundMP, COMDAT
; _this$ = ecx

; 527  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 528  : 	m_strSoundMP = szVal;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 444				; 000001bcH
	mov	DWORD PTR $T226492[ebp], eax
	cmp	DWORD PTR _szVal$[ebp], 0
	je	SHORT $LN4@SetSoundMP
	mov	ecx, DWORD PTR _szVal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T226492[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN1@SetSoundMP
$LN4@SetSoundMP:
	mov	ecx, DWORD PTR $T226492[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN1@SetSoundMP:

; 529  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetSoundMP@CvTechEntry@@QAEXPBD@Z ENDP			; CvTechEntry::SetSoundMP
_TEXT	ENDS
PUBLIC	?GetDomainExtraMoves@CvTechEntry@@QBEHH@Z	; CvTechEntry::GetDomainExtraMoves
; Function compile flags: /Odtp
;	COMDAT ?GetDomainExtraMoves@CvTechEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetDomainExtraMoves@CvTechEntry@@QBEHH@Z PROC		; CvTechEntry::GetDomainExtraMoves, COMDAT
; _this$ = ecx

; 535  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 536  : 	return m_piDomainExtraMoves ? m_piDomainExtraMoves[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+472], 0
	je	SHORT $LN3@GetDomainE
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+472]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetDomainE
$LN3@GetDomainE:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetDomainE:
	mov	eax, DWORD PTR tv69[ebp]

; 537  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetDomainExtraMoves@CvTechEntry@@QBEHH@Z ENDP		; CvTechEntry::GetDomainExtraMoves
_TEXT	ENDS
PUBLIC	?GetTradeRouteDomainExtraRange@CvTechEntry@@QBEHH@Z ; CvTechEntry::GetTradeRouteDomainExtraRange
; Function compile flags: /Odtp
;	COMDAT ?GetTradeRouteDomainExtraRange@CvTechEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetTradeRouteDomainExtraRange@CvTechEntry@@QBEHH@Z PROC ; CvTechEntry::GetTradeRouteDomainExtraRange, COMDAT
; _this$ = ecx

; 541  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 542  : 	return m_piTradeRouteDomainExtraRange ? m_piTradeRouteDomainExtraRange[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+476], 0
	je	SHORT $LN3@GetTradeRo
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+476]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetTradeRo
$LN3@GetTradeRo:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetTradeRo:
	mov	eax, DWORD PTR tv69[ebp]

; 543  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetTradeRouteDomainExtraRange@CvTechEntry@@QBEHH@Z ENDP ; CvTechEntry::GetTradeRouteDomainExtraRange
_TEXT	ENDS
PUBLIC	?GetFlavorValue@CvTechEntry@@QBEHH@Z		; CvTechEntry::GetFlavorValue
; Function compile flags: /Odtp
;	COMDAT ?GetFlavorValue@CvTechEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetFlavorValue@CvTechEntry@@QBEHH@Z PROC		; CvTechEntry::GetFlavorValue, COMDAT
; _this$ = ecx

; 548  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 549  : 	CvAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 550  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 551  : 	return m_piFlavorValue ? m_piFlavorValue[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+480], 0
	je	SHORT $LN3@GetFlavorV
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+480]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetFlavorV
$LN3@GetFlavorV:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetFlavorV:
	mov	eax, DWORD PTR tv69[ebp]

; 552  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetFlavorValue@CvTechEntry@@QBEHH@Z ENDP		; CvTechEntry::GetFlavorValue
_TEXT	ENDS
PUBLIC	?GetPrereqOrTechs@CvTechEntry@@QBEHH@Z		; CvTechEntry::GetPrereqOrTechs
; Function compile flags: /Odtp
;	COMDAT ?GetPrereqOrTechs@CvTechEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetPrereqOrTechs@CvTechEntry@@QBEHH@Z PROC		; CvTechEntry::GetPrereqOrTechs, COMDAT
; _this$ = ecx

; 556  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 557  : 	return m_piPrereqOrTechs ? m_piPrereqOrTechs[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+484], 0
	je	SHORT $LN3@GetPrereqO
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+484]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetPrereqO
$LN3@GetPrereqO:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetPrereqO:
	mov	eax, DWORD PTR tv69[ebp]

; 558  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetPrereqOrTechs@CvTechEntry@@QBEHH@Z ENDP		; CvTechEntry::GetPrereqOrTechs
_TEXT	ENDS
PUBLIC	?GetPrereqAndTechs@CvTechEntry@@QBEHH@Z		; CvTechEntry::GetPrereqAndTechs
; Function compile flags: /Odtp
;	COMDAT ?GetPrereqAndTechs@CvTechEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetPrereqAndTechs@CvTechEntry@@QBEHH@Z PROC		; CvTechEntry::GetPrereqAndTechs, COMDAT
; _this$ = ecx

; 562  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 563  : 	return m_piPrereqAndTechs ? m_piPrereqAndTechs[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+488], 0
	je	SHORT $LN3@GetPrereqA
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+488]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetPrereqA
$LN3@GetPrereqA:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetPrereqA:
	mov	eax, DWORD PTR tv69[ebp]

; 564  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetPrereqAndTechs@CvTechEntry@@QBEHH@Z ENDP		; CvTechEntry::GetPrereqAndTechs
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvTechEntry *,std::allocator<CvTechEntry *> >::~_Vector_val<CvTechEntry *,std::allocator<CvTechEntry *> >
PUBLIC	?_Buy@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::_Buy
PUBLIC	??0CvTechXMLEntries@@QAE@XZ			; CvTechXMLEntries::CvTechXMLEntries
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0CvTechXMLEntries@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvTechXMLEntries@@QAE@XZ$1
__ehfuncinfo$??0CvTechXMLEntries@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvTechXMLEntries@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtechclasses.cpp
xdata$x	ENDS
;	COMDAT ??0CvTechXMLEntries@@QAE@XZ
_TEXT	SEGMENT
tv92 = -132						; size = 4
tv149 = -128						; size = 4
_this$ = -124						; size = 4
$T226546 = -30						; size = 1
$T226533 = -29						; size = 1
$T226529 = -28						; size = 4
$T226522 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0CvTechXMLEntries@@QAE@XZ PROC			; CvTechXMLEntries::CvTechXMLEntries, COMDAT
; _this$ = ecx

; 571  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvTechXMLEntries@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T226546[ebp]
	mov	DWORD PTR $T226522[ebp], eax
	lea	ecx, DWORD PTR $T226533[ebp]
	mov	DWORD PTR $T226529[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv149[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv92[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::_Buy
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 572  : 
; 573  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvTechXMLEntries@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE@XZ
__ehhandler$??0CvTechXMLEntries@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvTechXMLEntries@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvTechXMLEntries@@QAE@XZ ENDP			; CvTechXMLEntries::CvTechXMLEntries
PUBLIC	??1?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE@XZ ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::~vector<CvTechEntry *,std::allocator<CvTechEntry *> >
PUBLIC	?_Tidy@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@IAEXXZ ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::_Tidy
PUBLIC	?DeleteArray@CvTechXMLEntries@@QAEXXZ		; CvTechXMLEntries::DeleteArray
PUBLIC	??1CvTechXMLEntries@@QAE@XZ			; CvTechXMLEntries::~CvTechXMLEntries
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1CvTechXMLEntries@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvTechXMLEntries@@QAE@XZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvTechXMLEntries@@QAE@XZ$1
__ehfuncinfo$??1CvTechXMLEntries@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1CvTechXMLEntries@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtechclasses.cpp
xdata$x	ENDS
;	COMDAT ??1CvTechXMLEntries@@QAE@XZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
__$EHRec$ = -12						; size = 12
??1CvTechXMLEntries@@QAE@XZ PROC			; CvTechXMLEntries::~CvTechXMLEntries, COMDAT
; _this$ = ecx

; 577  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvTechXMLEntries@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 578  : 	DeleteArray();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DeleteArray@CvTechXMLEntries@@QAEXXZ	; CvTechXMLEntries::DeleteArray

; 579  : }

	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@IAEXXZ ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvTechXMLEntries@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE@XZ ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::~vector<CvTechEntry *,std::allocator<CvTechEntry *> >
__unwindfunclet$??1CvTechXMLEntries@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE@XZ
__ehhandler$??1CvTechXMLEntries@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvTechXMLEntries@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvTechXMLEntries@@QAE@XZ ENDP			; CvTechXMLEntries::~CvTechXMLEntries
PUBLIC	?GetTechEntries@CvTechXMLEntries@@QAEAAV?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@XZ ; CvTechXMLEntries::GetTechEntries
; Function compile flags: /Odtp
;	COMDAT ?GetTechEntries@CvTechXMLEntries@@QAEAAV?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTechEntries@CvTechXMLEntries@@QAEAAV?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@XZ PROC ; CvTechXMLEntries::GetTechEntries, COMDAT
; _this$ = ecx

; 583  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 584  : 	return m_paTechEntries;

	mov	eax, DWORD PTR _this$[ebp]

; 585  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTechEntries@CvTechXMLEntries@@QAEAAV?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@XZ ENDP ; CvTechXMLEntries::GetTechEntries
_TEXT	ENDS
PUBLIC	?GetNumTechs@CvTechXMLEntries@@QAEHXZ		; CvTechXMLEntries::GetNumTechs
; Function compile flags: /Odtp
;	COMDAT ?GetNumTechs@CvTechXMLEntries@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumTechs@CvTechXMLEntries@@QAEHXZ PROC		; CvTechXMLEntries::GetNumTechs, COMDAT
; _this$ = ecx

; 593  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 594  : 	return m_paTechEntries.size();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 595  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumTechs@CvTechXMLEntries@@QAEHXZ ENDP		; CvTechXMLEntries::GetNumTechs
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@2@0@Z ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::erase
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp
;	COMDAT ?DeleteArray@CvTechXMLEntries@@QAEXXZ
_TEXT	SEGMENT
tv143 = -116						; size = 4
_this$ = -112						; size = 4
$T226789 = -56						; size = 4
$T226773 = -52						; size = 4
$T226894 = -48						; size = 4
$T226893 = -44						; size = 4
$T226892 = -40						; size = 4
$T226891 = -36						; size = 4
$T226890 = -32						; size = 4
$T226757 = -28						; size = 4
$T226751 = -24						; size = 4
$T226750 = -20						; size = 4
$T226716 = -16						; size = 4
$T226692 = -12						; size = 4
$T226682 = -8						; size = 4
_it$223346 = -4						; size = 4
?DeleteArray@CvTechXMLEntries@@QAEXXZ PROC		; CvTechXMLEntries::DeleteArray, COMDAT
; _this$ = ecx

; 599  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	DWORD PTR _this$[ebp], ecx

; 600  : 	for(std::vector<CvTechEntry*>::iterator it = m_paTechEntries.begin(); it != m_paTechEntries.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T226692[ebp], ecx
	mov	edx, DWORD PTR $T226692[ebp]
	mov	DWORD PTR _it$223346[ebp], edx
	jmp	SHORT $LN3@DeleteArra
$LN2@DeleteArra:
	mov	eax, DWORD PTR _it$223346[ebp]
	add	eax, 4
	mov	DWORD PTR _it$223346[ebp], eax
$LN3@DeleteArra:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T226716[ebp], edx
	mov	eax, DWORD PTR $T226716[ebp]
	mov	DWORD PTR $T226682[ebp], eax
	mov	ecx, DWORD PTR _it$223346[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T226682[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@DeleteArra

; 601  : 	{
; 602  : 		SAFE_DELETE(*it);

	mov	edx, DWORD PTR _it$223346[ebp]
	mov	DWORD PTR $T226757[ebp], edx
	mov	eax, DWORD PTR $T226757[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T226751[ebp], ecx
	mov	edx, DWORD PTR $T226751[ebp]
	mov	DWORD PTR $T226750[ebp], edx
	cmp	DWORD PTR $T226750[ebp], 0
	je	SHORT $LN32@DeleteArra
	mov	ecx, DWORD PTR $T226750[ebp]
	call	??1CvTechEntry@@QAE@XZ			; CvTechEntry::~CvTechEntry
	mov	eax, 1
	and	eax, 1
	je	SHORT $LN35@DeleteArra
	mov	ecx, DWORD PTR $T226750[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN35@DeleteArra:
	mov	edx, DWORD PTR $T226750[ebp]
	mov	DWORD PTR tv143[ebp], edx
	jmp	SHORT $LN33@DeleteArra
$LN32@DeleteArra:
	mov	DWORD PTR tv143[ebp], 0
$LN33@DeleteArra:
	mov	eax, DWORD PTR $T226757[ebp]
	mov	DWORD PTR [eax], 0

; 603  : 	}

	jmp	$LN2@DeleteArra
$LN1@DeleteArra:

; 604  : 
; 605  : 	m_paTechEntries.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T226773[ebp], edx
	mov	eax, DWORD PTR $T226773[ebp]
	mov	DWORD PTR $T226891[ebp], eax
	mov	ecx, DWORD PTR $T226891[ebp]
	mov	DWORD PTR $T226890[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T226789[ebp], eax
	mov	ecx, DWORD PTR $T226789[ebp]
	mov	DWORD PTR $T226893[ebp], ecx
	mov	edx, DWORD PTR $T226893[ebp]
	mov	DWORD PTR $T226892[ebp], edx
	mov	eax, DWORD PTR $T226890[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226892[ebp]
	push	ecx
	lea	edx, DWORD PTR $T226894[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@2@0@Z ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::erase

; 606  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DeleteArray@CvTechXMLEntries@@QAEXXZ ENDP		; CvTechXMLEntries::DeleteArray
_TEXT	ENDS
PUBLIC	?GetEntry@CvTechXMLEntries@@QAEPAVCvTechEntry@@H@Z ; CvTechXMLEntries::GetEntry
; Function compile flags: /Odtp
;	COMDAT ?GetEntry@CvTechXMLEntries@@QAEPAVCvTechEntry@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?GetEntry@CvTechXMLEntries@@QAEPAVCvTechEntry@@H@Z PROC	; CvTechXMLEntries::GetEntry, COMDAT
; _this$ = ecx

; 614  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 615  : 	return m_paTechEntries[index];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 616  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetEntry@CvTechXMLEntries@@QAEPAVCvTechEntry@@H@Z ENDP	; CvTechXMLEntries::GetEntry
_TEXT	ENDS
PUBLIC	??_7CvPlayerTechs@@6B@				; CvPlayerTechs::`vftable'
PUBLIC	??0CvPlayerTechs@@QAE@XZ			; CvPlayerTechs::CvPlayerTechs
PUBLIC	?Uninit@CvPlayerTechs@@UAEXXZ			; CvPlayerTechs::Uninit
PUBLIC	?FlavorUpdate@CvPlayerTechs@@UAEXXZ		; CvPlayerTechs::FlavorUpdate
PUBLIC	?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z ; CvPlayerTechs::LogFlavors
EXTRN	??0CvFlavorRecipient@@QAE@XZ:PROC		; CvFlavorRecipient::CvFlavorRecipient
EXTRN	?Init@CvFlavorRecipient@@UAEXXZ:PROC		; CvFlavorRecipient::Init
;	COMDAT ??_7CvPlayerTechs@@6B@
CONST	SEGMENT
??_7CvPlayerTechs@@6B@ DD FLAT:?Init@CvFlavorRecipient@@UAEXXZ ; CvPlayerTechs::`vftable'
	DD	FLAT:?Uninit@CvPlayerTechs@@UAEXXZ
	DD	FLAT:?FlavorUpdate@CvPlayerTechs@@UAEXXZ
	DD	FLAT:?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0CvPlayerTechs@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvPlayerTechs@@QAE@XZ PROC				; CvPlayerTechs::CvPlayerTechs, COMDAT
; _this$ = ecx

; 634  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CvFlavorRecipient@@QAE@XZ		; CvFlavorRecipient::CvFlavorRecipient
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvPlayerTechs@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+36], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+40], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+44], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+48], 0

; 635  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvPlayerTechs@@QAE@XZ ENDP				; CvPlayerTechs::CvPlayerTechs
_TEXT	ENDS
PUBLIC	??1CvPlayerTechs@@QAE@XZ			; CvPlayerTechs::~CvPlayerTechs
EXTRN	??1CvFlavorRecipient@@QAE@XZ:PROC		; CvFlavorRecipient::~CvFlavorRecipient
; Function compile flags: /Odtp
;	COMDAT ??1CvPlayerTechs@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvPlayerTechs@@QAE@XZ PROC				; CvPlayerTechs::~CvPlayerTechs, COMDAT
; _this$ = ecx

; 639  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvPlayerTechs@@6B@

; 640  : }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvFlavorRecipient@@QAE@XZ		; CvFlavorRecipient::~CvFlavorRecipient
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvPlayerTechs@@QAE@XZ ENDP				; CvPlayerTechs::~CvPlayerTechs
_TEXT	ENDS
PUBLIC	?Reset@CvPlayerTechs@@QAEXXZ			; CvPlayerTechs::Reset
PUBLIC	?Init@CvPlayerTechs@@QAEXPAVCvTechXMLEntries@@PAVCvPlayer@@_N@Z ; CvPlayerTechs::Init
EXTRN	??0CvTechAI@@QAE@PAVCvPlayerTechs@@@Z:PROC	; CvTechAI::CvTechAI
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Init@CvPlayerTechs@@QAEXPAVCvTechXMLEntries@@PAVCvPlayer@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@CvPlayerTechs@@QAEXPAVCvTechXMLEntries@@PAVCvPlayer@@_N@Z$0
__ehfuncinfo$?Init@CvPlayerTechs@@QAEXPAVCvTechXMLEntries@@PAVCvPlayer@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Init@CvPlayerTechs@@QAEXPAVCvTechXMLEntries@@PAVCvPlayer@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?Init@CvPlayerTechs@@QAEXPAVCvTechXMLEntries@@PAVCvPlayer@@_N@Z
_TEXT	SEGMENT
tv171 = -60						; size = 4
_this$ = -56						; size = 4
$T226928 = -52						; size = 4
$T226927 = -48						; size = 4
$T226926 = -44						; size = 4
$T226925 = -40						; size = 4
$T226924 = -36						; size = 4
$T226923 = -32						; size = 4
$T226922 = -28						; size = 4
$T226921 = -24						; size = 4
$T226920 = -20						; size = 4
_iNumTechs$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pTechs$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
_bIsCity$ = 16						; size = 1
?Init@CvPlayerTechs@@QAEXPAVCvTechXMLEntries@@PAVCvPlayer@@_N@Z PROC ; CvPlayerTechs::Init, COMDAT
; _this$ = ecx

; 644  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Init@CvPlayerTechs@@QAEXPAVCvTechXMLEntries@@PAVCvPlayer@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 645  : 	// Init base class
; 646  : 	CvFlavorRecipient::Init();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Init@CvFlavorRecipient@@UAEXXZ		; CvFlavorRecipient::Init

; 647  : 
; 648  : 	// Store off the pointers to objects we'll need later
; 649  : 	m_bIsCity = bIsCity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _bIsCity$[ebp]
	mov	BYTE PTR [eax+4], cl

; 650  : 	m_pTechs = pTechs;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pTechs$[ebp]
	mov	DWORD PTR [edx+40], eax

; 651  : 	m_pPlayer = pPlayer;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pPlayer$[ebp]
	mov	DWORD PTR [ecx+44], edx

; 652  : 
; 653  : 	// Initialize arrays
; 654  : 	const int iNumTechs = m_pTechs->GetNumTechs();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	mov	DWORD PTR _iNumTechs$[ebp], eax

; 655  : 
; 656  : 	CvAssertMsg(m_pabResearchingTech==NULL, "about to leak memory, CvPlayerTechs::m_pabResearchingTech");
; 657  : 	m_pabResearchingTech = FNEW(bool[iNumTechs], c_eCiv5GameplayDLL, 0);

	mov	ecx, DWORD PTR _iNumTechs$[ebp]
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T226920[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T226920[ebp]
	mov	DWORD PTR [edx+12], eax

; 658  : 	CvAssertMsg(m_piCivTechPriority==NULL, "about to leak memory, CvPlayerTechs::m_piCivTechPriority");
; 659  : 	m_piCivTechPriority = FNEW(int[iNumTechs], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	eax, DWORD PTR _iNumTechs$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T226921[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T226921[ebp]
	mov	DWORD PTR [eax+16], ecx

; 660  : 	CvAssertMsg(m_piLocaleTechPriority==NULL, "about to leak memory, CvPlayerTechs::m_piLocaleTechPriority");
; 661  : 	m_piLocaleTechPriority = FNEW(int[iNumTechs], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	eax, DWORD PTR _iNumTechs$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T226922[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T226922[ebp]
	mov	DWORD PTR [eax+20], ecx

; 662  : 	CvAssertMsg(m_peLocaleTechResources==NULL, "about to leak memory, CvPlayerTechs::m_peLocaleTechResources");
; 663  : 	m_peLocaleTechResources = FNEW(ResourceTypes[iNumTechs], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	eax, DWORD PTR _iNumTechs$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T226923[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T226923[ebp]
	mov	DWORD PTR [eax+24], ecx

; 664  : 	CvAssertMsg(m_peCivTechUniqueUnits==NULL, "about to leak memory, CvPlayerTechs::m_peCivTechUniqueUnits");
; 665  : 	m_peCivTechUniqueUnits = FNEW(UnitTypes[iNumTechs], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	eax, DWORD PTR _iNumTechs$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T226924[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T226924[ebp]
	mov	DWORD PTR [eax+28], ecx

; 666  : 	CvAssertMsg(m_peCivTechUniqueBuildings==NULL, "about to leak memory, CvPlayerTechs::m_peCivTechUniqueBuildings");
; 667  : 	m_peCivTechUniqueBuildings = FNEW(BuildingTypes[iNumTechs], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	eax, DWORD PTR _iNumTechs$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T226925[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T226925[ebp]
	mov	DWORD PTR [eax+32], ecx

; 668  : 	CvAssertMsg(m_peCivTechUniqueImprovements==NULL, "about to leak memory, CvPlayerTechs::m_peCivTechUniqueImprovements");
; 669  : 	m_peCivTechUniqueImprovements = FNEW(ImprovementTypes[iNumTechs], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	eax, DWORD PTR _iNumTechs$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T226926[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T226926[ebp]
	mov	DWORD PTR [eax+36], ecx

; 670  : 
; 671  : 	// Create AI object
; 672  : 	m_pTechAI = FNEW(CvTechAI(this), c_eCiv5GameplayDLL, 0);

	push	1316					; 00000524H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T226928[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T226928[ebp], 0
	je	SHORT $LN3@Init
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T226928[ebp]
	call	??0CvTechAI@@QAE@PAVCvPlayerTechs@@@Z	; CvTechAI::CvTechAI
	mov	DWORD PTR tv171[ebp], eax
	jmp	SHORT $LN4@Init
$LN3@Init:
	mov	DWORD PTR tv171[ebp], 0
$LN4@Init:
	mov	eax, DWORD PTR tv171[ebp]
	mov	DWORD PTR $T226927[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T226927[ebp]
	mov	DWORD PTR [ecx+48], edx

; 673  : 
; 674  : 	Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Reset@CvPlayerTechs@@QAEXXZ		; CvPlayerTechs::Reset

; 675  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Init@CvPlayerTechs@@QAEXPAVCvTechXMLEntries@@PAVCvPlayer@@_N@Z$0:
	mov	eax, DWORD PTR $T226928[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?Init@CvPlayerTechs@@QAEXPAVCvTechXMLEntries@@PAVCvPlayer@@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Init@CvPlayerTechs@@QAEXPAVCvTechXMLEntries@@PAVCvPlayer@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Init@CvPlayerTechs@@QAEXPAVCvTechXMLEntries@@PAVCvPlayer@@_N@Z ENDP ; CvPlayerTechs::Init
EXTRN	??1CvTechAI@@QAE@XZ:PROC			; CvTechAI::~CvTechAI
EXTRN	?Uninit@CvFlavorRecipient@@UAEXXZ:PROC		; CvFlavorRecipient::Uninit
; Function compile flags: /Odtp
;	COMDAT ?Uninit@CvPlayerTechs@@UAEXXZ
_TEXT	SEGMENT
tv89 = -76						; size = 4
_this$ = -72						; size = 4
$T227000 = -68						; size = 4
$T226994 = -64						; size = 4
$T226993 = -60						; size = 4
$T226981 = -56						; size = 4
$T226980 = -52						; size = 4
$T226975 = -48						; size = 4
$T226974 = -44						; size = 4
$T226969 = -40						; size = 4
$T226968 = -36						; size = 4
$T226963 = -32						; size = 4
$T226962 = -28						; size = 4
$T226957 = -24						; size = 4
$T226956 = -20						; size = 4
$T226951 = -16						; size = 4
$T226950 = -12						; size = 4
$T226945 = -8						; size = 4
$T226944 = -4						; size = 4
?Uninit@CvPlayerTechs@@UAEXXZ PROC			; CvPlayerTechs::Uninit, COMDAT
; _this$ = ecx

; 679  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	DWORD PTR _this$[ebp], ecx

; 680  : 	// Uninit base class
; 681  : 	CvFlavorRecipient::Uninit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Uninit@CvFlavorRecipient@@UAEXXZ	; CvFlavorRecipient::Uninit

; 682  : 
; 683  : 	SAFE_DELETE_ARRAY(m_pabResearchingTech);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T226945[ebp], eax
	mov	ecx, DWORD PTR $T226945[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T226944[ebp], edx
	mov	eax, DWORD PTR $T226944[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T226945[ebp]
	mov	DWORD PTR [ecx], 0

; 684  : 	SAFE_DELETE_ARRAY(m_piCivTechPriority);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR $T226951[ebp], edx
	mov	eax, DWORD PTR $T226951[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T226950[ebp], ecx
	mov	edx, DWORD PTR $T226950[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, DWORD PTR $T226951[ebp]
	mov	DWORD PTR [eax], 0

; 685  : 	SAFE_DELETE_ARRAY(m_piLocaleTechPriority);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR $T226957[ebp], ecx
	mov	edx, DWORD PTR $T226957[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T226956[ebp], eax
	mov	ecx, DWORD PTR $T226956[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T226957[ebp]
	mov	DWORD PTR [edx], 0

; 686  : 	SAFE_DELETE_ARRAY(m_peLocaleTechResources);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR $T226963[ebp], eax
	mov	ecx, DWORD PTR $T226963[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T226962[ebp], edx
	mov	eax, DWORD PTR $T226962[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T226963[ebp]
	mov	DWORD PTR [ecx], 0

; 687  : 	SAFE_DELETE_ARRAY(m_peCivTechUniqueBuildings);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 32					; 00000020H
	mov	DWORD PTR $T226969[ebp], edx
	mov	eax, DWORD PTR $T226969[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T226968[ebp], ecx
	mov	edx, DWORD PTR $T226968[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, DWORD PTR $T226969[ebp]
	mov	DWORD PTR [eax], 0

; 688  : 	SAFE_DELETE_ARRAY(m_peCivTechUniqueUnits);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR $T226975[ebp], ecx
	mov	edx, DWORD PTR $T226975[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T226974[ebp], eax
	mov	ecx, DWORD PTR $T226974[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T226975[ebp]
	mov	DWORD PTR [edx], 0

; 689  : 	SAFE_DELETE_ARRAY(m_peCivTechUniqueImprovements);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 36					; 00000024H
	mov	DWORD PTR $T226981[ebp], eax
	mov	ecx, DWORD PTR $T226981[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T226980[ebp], edx
	mov	eax, DWORD PTR $T226980[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T226981[ebp]
	mov	DWORD PTR [ecx], 0

; 690  : 	SAFE_DELETE(m_pTechAI);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 48					; 00000030H
	mov	DWORD PTR $T227000[ebp], edx
	mov	eax, DWORD PTR $T227000[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T226994[ebp], ecx
	mov	edx, DWORD PTR $T226994[ebp]
	mov	DWORD PTR $T226993[ebp], edx
	cmp	DWORD PTR $T226993[ebp], 0
	je	SHORT $LN19@Uninit
	mov	ecx, DWORD PTR $T226993[ebp]
	call	??1CvTechAI@@QAE@XZ			; CvTechAI::~CvTechAI
	mov	eax, 1
	and	eax, 1
	je	SHORT $LN22@Uninit
	mov	ecx, DWORD PTR $T226993[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN22@Uninit:
	mov	edx, DWORD PTR $T226993[ebp]
	mov	DWORD PTR tv89[ebp], edx
	jmp	SHORT $LN20@Uninit
$LN19@Uninit:
	mov	DWORD PTR tv89[ebp], 0
$LN20@Uninit:
	mov	eax, DWORD PTR $T227000[ebp]
	mov	DWORD PTR [eax], 0

; 691  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Uninit@CvPlayerTechs@@UAEXXZ ENDP			; CvPlayerTechs::Uninit
_TEXT	ENDS
EXTRN	?Reset@CvTechAI@@QAEXXZ:PROC			; CvTechAI::Reset
EXTRN	?GetFreeBuildingPrereqTech@CvTraitEntry@@QBE?AW4TechTypes@@XZ:PROC ; CvTraitEntry::GetFreeBuildingPrereqTech
EXTRN	?GetCapitalFreeBuildingPrereqTech@CvTraitEntry@@QBE?AW4TechTypes@@XZ:PROC ; CvTraitEntry::GetCapitalFreeBuildingPrereqTech
EXTRN	?GetFreeUnitPrereqTech@CvTraitEntry@@QBE?AW4TechTypes@@XZ:PROC ; CvTraitEntry::GetFreeUnitPrereqTech
EXTRN	?GetPrereqTech@CvTraitEntry@@QBEHXZ:PROC	; CvTraitEntry::GetPrereqTech
EXTRN	?IsMayaCalendarBonuses@CvTraitEntry@@QBE_NXZ:PROC ; CvTraitEntry::IsMayaCalendarBonuses
EXTRN	?getTraitInfo@CvGlobals@@QAEPAVCvTraitEntry@@W4TraitTypes@@@Z:PROC ; CvGlobals::getTraitInfo
EXTRN	?hasTrait@CvLeaderHeadInfo@@QBE_NH@Z:PROC	; CvLeaderHeadInfo::hasTrait
EXTRN	?getLeaderInfo@CvPlayer@@QBEAAVCvLeaderHeadInfo@@XZ:PROC ; CvPlayer::getLeaderInfo
EXTRN	?getNumTraitInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumTraitInfos
EXTRN	?getTechPrereq@CvBuildInfo@@QBEHXZ:PROC		; CvBuildInfo::getTechPrereq
EXTRN	?getImprovement@CvBuildInfo@@QBEHXZ:PROC	; CvBuildInfo::getImprovement
EXTRN	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z:PROC ; CvGlobals::getBuildInfo
EXTRN	?getNumBuildInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumBuildInfos
EXTRN	?GetRequiredCivilization@CvImprovementEntry@@QBE?AW4CivilizationTypes@@XZ:PROC ; CvImprovementEntry::GetRequiredCivilization
EXTRN	?IsSpecificCivRequired@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsSpecificCivRequired
EXTRN	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z:PROC ; CvGlobals::getImprovementInfo
EXTRN	?getNumImprovementInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumImprovementInfos
EXTRN	?GetPrereqAndTech@CvUnitEntry@@QBEHXZ:PROC	; CvUnitEntry::GetPrereqAndTech
EXTRN	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z:PROC ; CvGlobals::getUnitInfo
EXTRN	?getCivilizationUnits@CvCivilizationInfo@@QBEHH@Z:PROC ; CvCivilizationInfo::getCivilizationUnits
EXTRN	?isCivilizationUnitOverridden@CvCivilizationInfo@@QBE_NH@Z:PROC ; CvCivilizationInfo::isCivilizationUnitOverridden
EXTRN	?getNumUnitClassInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumUnitClassInfos
EXTRN	?GetPrereqAndTech@CvBuildingEntry@@QBEHXZ:PROC	; CvBuildingEntry::GetPrereqAndTech
EXTRN	?isCivilizationBuildingOverridden@CvCivilizationInfo@@QBE_NH@Z:PROC ; CvCivilizationInfo::isCivilizationBuildingOverridden
EXTRN	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z:PROC ; CvBuildingXMLEntries::GetEntry
EXTRN	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z:PROC ; CvCivilizationInfo::getCivilizationBuildings
EXTRN	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ:PROC ; CvGlobals::getNumBuildingClassInfos
EXTRN	?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z:PROC ; CvGlobals::getCivilizationInfo
EXTRN	?getCivilizationType@CvPlayer@@QBE?AW4CivilizationTypes@@XZ:PROC ; CvPlayer::getCivilizationType
EXTRN	?isBarbarian@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isBarbarian
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
EXTRN	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ:PROC ; CvGlobals::GetGameBuildings
; Function compile flags: /Odtp
;	COMDAT ?Reset@CvPlayerTechs@@QAEXXZ
_TEXT	SEGMENT
_this$ = -112						; size = 4
$T227030 = -108						; size = 4
$T227026 = -104						; size = 4
$T227022 = -100						; size = 4
$T227018 = -96						; size = 4
$T227014 = -92						; size = 4
$T227010 = -88						; size = 4
$T227006 = -84						; size = 4
_iPrereqTech$223479 = -80				; size = 4
_iPrereqTech$223481 = -76				; size = 4
_pkTraitInfo$223476 = -72				; size = 4
_pkLeaderInfo$223473 = -68				; size = 4
_eTraitLoop$223471 = -64				; size = 4
_iTraitLoop$223467 = -60				; size = 4
_iTech$223463 = -56					; size = 4
_pkBuildEntry$223460 = -52				; size = 4
_jJ$223456 = -48					; size = 4
_pkImprovementEntry$223452 = -44			; size = 4
_iTech$223446 = -40					; size = 4
_pkUnitEntry$223444 = -36				; size = 4
_eCivilizationUnit$223441 = -32				; size = 4
_iTech$223435 = -28					; size = 4
_eBuilding$223429 = -24					; size = 4
_pkBuildingInfo$223431 = -20				; size = 4
_pkInfo$223424 = -16					; size = 4
_iNumTraits$223466 = -12				; size = 4
_iI$ = -8						; size = 4
_pkGameBuildings$ = -4					; size = 4
?Reset@CvPlayerTechs@@QAEXXZ PROC			; CvPlayerTechs::Reset, COMDAT
; _this$ = ecx

; 695  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 696  : #ifdef AUI_WARNING_FIXES
; 697  : 	uint iI;
; 698  : #else
; 699  : 	int iI;
; 700  : #endif
; 701  : 	CvBuildingXMLEntries* pkGameBuildings = GC.GetGameBuildings();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ ; CvGlobals::GetGameBuildings
	mov	DWORD PTR _pkGameBuildings$[ebp], eax

; 702  : 
; 703  : 	for(iI = 0; iI < m_pTechs->GetNumTechs(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN40@Reset
$LN39@Reset:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN40@Reset:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+40]
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	cmp	DWORD PTR _iI$[ebp], eax
	jge	SHORT $LN38@Reset

; 704  : 	{
; 705  : 		m_pabResearchingTech[iI] = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	BYTE PTR [eax+ecx], 0

; 706  : 		m_piCivTechPriority[iI] = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [eax+ecx*4], 1

; 707  : 		m_piLocaleTechPriority[iI] = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [eax+ecx*4], 1

; 708  : 		m_peLocaleTechResources[iI] = NO_RESOURCE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [eax+ecx*4], -1

; 709  : 		m_peCivTechUniqueUnits[iI] = NO_UNIT;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [eax+ecx*4], -1

; 710  : 		m_peCivTechUniqueBuildings[iI] = NO_BUILDING;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [eax+ecx*4], -1

; 711  : 		m_peCivTechUniqueImprovements[iI] = NO_IMPROVEMENT;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [eax+ecx*4], -1

; 712  : 	}

	jmp	$LN39@Reset
$LN38@Reset:

; 713  : 
; 714  : 	// Tweak tech priorities to recognize unique properties of this civ
; 715  : 	if(!m_pPlayer->isMinorCiv() && !m_pPlayer->isBarbarian() && m_pPlayer->getCivilizationType() != NO_CIVILIZATION)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+44]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	eax, al
	test	eax, eax
	jne	$LN37@Reset
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+44]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	movzx	edx, al
	test	edx, edx
	jne	$LN37@Reset
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	call	?getCivilizationType@CvPlayer@@QBE?AW4CivilizationTypes@@XZ ; CvPlayer::getCivilizationType
	cmp	eax, -1
	je	$LN37@Reset

; 716  : 	{
; 717  : 		CvCivilizationInfo* pkInfo = GC.getCivilizationInfo(m_pPlayer->getCivilizationType());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+44]
	call	?getCivilizationType@CvPlayer@@QBE?AW4CivilizationTypes@@XZ ; CvPlayer::getCivilizationType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z ; CvGlobals::getCivilizationInfo
	mov	DWORD PTR _pkInfo$223424[ebp], eax

; 718  : 		if(pkInfo)

	cmp	DWORD PTR _pkInfo$223424[ebp], 0
	je	$LN36@Reset

; 719  : 		{
; 720  : 			// Loop through all building classes
; 721  : 			for(iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN35@Reset
$LN34@Reset:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN35@Reset:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	DWORD PTR _iI$[ebp], eax
	jge	$LN33@Reset

; 722  : 			{
; 723  : 				const BuildingTypes eBuilding = static_cast<BuildingTypes>(pkInfo->getCivilizationBuildings(iI));

	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkInfo$223424[ebp]
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	mov	DWORD PTR _eBuilding$223429[ebp], eax

; 724  : 				CvBuildingEntry* pkBuildingInfo = NULL;

	mov	DWORD PTR _pkBuildingInfo$223431[ebp], 0

; 725  : 
; 726  : 				if(eBuilding != -1)

	cmp	DWORD PTR _eBuilding$223429[ebp], -1
	je	SHORT $LN32@Reset

; 727  : 					pkBuildingInfo = pkGameBuildings->GetEntry(eBuilding);

	mov	ecx, DWORD PTR _eBuilding$223429[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkGameBuildings$[ebp]
	call	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z ; CvBuildingXMLEntries::GetEntry
	mov	DWORD PTR _pkBuildingInfo$223431[ebp], eax
$LN32@Reset:

; 728  : 
; 729  : 				if(pkBuildingInfo)

	cmp	DWORD PTR _pkBuildingInfo$223431[ebp], 0
	je	SHORT $LN31@Reset

; 730  : 				{
; 731  : 					// Is this one overridden for our civ?
; 732  : 					if(pkInfo->isCivilizationBuildingOverridden(iI))

	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkInfo$223424[ebp]
	call	?isCivilizationBuildingOverridden@CvCivilizationInfo@@QBE_NH@Z ; CvCivilizationInfo::isCivilizationBuildingOverridden
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN31@Reset

; 733  : 					{
; 734  : 						int iTech = pkBuildingInfo->GetPrereqAndTech();

	mov	ecx, DWORD PTR _pkBuildingInfo$223431[ebp]
	call	?GetPrereqAndTech@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetPrereqAndTech
	mov	DWORD PTR _iTech$223435[ebp], eax

; 735  : 						if(iTech != NO_TECH)

	cmp	DWORD PTR _iTech$223435[ebp], -1
	je	SHORT $LN31@Reset

; 736  : 						{
; 737  : 							m_piCivTechPriority[iTech] *= GC.getTECH_PRIORITY_UNIQUE_ITEM();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1844
	mov	DWORD PTR $T227006[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _iTech$223435[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	imul	edx, DWORD PTR $T227006[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR _iTech$223435[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 738  : 							m_peCivTechUniqueBuildings[iTech] = eBuilding;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _iTech$223435[ebp]
	mov	ecx, DWORD PTR _eBuilding$223429[ebp]
	mov	DWORD PTR [edx+eax*4], ecx
$LN31@Reset:

; 739  : 						}
; 740  : 					}
; 741  : 				}
; 742  : 			}

	jmp	$LN34@Reset
$LN33@Reset:

; 743  : 
; 744  : 			// Loop through all units
; 745  : 			for(iI = 0; iI < GC.getNumUnitClassInfos(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN28@Reset
$LN27@Reset:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN28@Reset:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumUnitClassInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitClassInfos
	cmp	DWORD PTR _iI$[ebp], eax
	jge	$LN26@Reset

; 746  : 			{
; 747  : 				// Is this one overridden for our civ?
; 748  : 				if(pkInfo->isCivilizationUnitOverridden(iI))

	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkInfo$223424[ebp]
	call	?isCivilizationUnitOverridden@CvCivilizationInfo@@QBE_NH@Z ; CvCivilizationInfo::isCivilizationUnitOverridden
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN25@Reset

; 749  : 				{
; 750  : 					UnitTypes eCivilizationUnit = static_cast<UnitTypes>(pkInfo->getCivilizationUnits(iI));

	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkInfo$223424[ebp]
	call	?getCivilizationUnits@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationUnits
	mov	DWORD PTR _eCivilizationUnit$223441[ebp], eax

; 751  : 					if(eCivilizationUnit != NO_UNIT)

	cmp	DWORD PTR _eCivilizationUnit$223441[ebp], -1
	je	SHORT $LN25@Reset

; 752  : 					{
; 753  : 						CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eCivilizationUnit);

	mov	eax, DWORD PTR _eCivilizationUnit$223441[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	DWORD PTR _pkUnitEntry$223444[ebp], eax

; 754  : 						if(pkUnitEntry)

	cmp	DWORD PTR _pkUnitEntry$223444[ebp], 0
	je	SHORT $LN25@Reset

; 755  : 						{
; 756  : 							int iTech = pkUnitEntry->GetPrereqAndTech();

	mov	ecx, DWORD PTR _pkUnitEntry$223444[ebp]
	call	?GetPrereqAndTech@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetPrereqAndTech
	mov	DWORD PTR _iTech$223446[ebp], eax

; 757  : 							if(iTech != NO_TECH)

	cmp	DWORD PTR _iTech$223446[ebp], -1
	je	SHORT $LN25@Reset

; 758  : 							{
; 759  : 								m_piCivTechPriority[iTech] *= GC.getTECH_PRIORITY_UNIQUE_ITEM();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1844
	mov	DWORD PTR $T227010[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _iTech$223446[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	imul	edx, DWORD PTR $T227010[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR _iTech$223446[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 760  : 								m_peCivTechUniqueUnits[iTech] = (UnitTypes)pkInfo->getCivilizationUnits(iI);

	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkInfo$223424[ebp]
	call	?getCivilizationUnits@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationUnits
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR _iTech$223446[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN25@Reset:

; 761  : 							}
; 762  : 						}
; 763  : 					}
; 764  : 				}
; 765  : 			}

	jmp	$LN27@Reset
$LN26@Reset:

; 766  : 
; 767  : 			// Loop through all improvements
; 768  : 			for(iI = 0; iI < GC.getNumImprovementInfos(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN21@Reset
$LN20@Reset:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN21@Reset:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumImprovementInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumImprovementInfos
	cmp	DWORD PTR _iI$[ebp], eax
	jge	$LN36@Reset

; 769  : 			{
; 770  : 				CvImprovementEntry* pkImprovementEntry = GC.getImprovementInfo((ImprovementTypes)iI);

	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	DWORD PTR _pkImprovementEntry$223452[ebp], eax

; 771  : 				if(pkImprovementEntry)

	cmp	DWORD PTR _pkImprovementEntry$223452[ebp], 0
	je	$LN18@Reset

; 772  : 				{
; 773  : 					if(pkImprovementEntry->IsSpecificCivRequired() && pkImprovementEntry->GetRequiredCivilization() == m_pPlayer->getCivilizationType())

	mov	ecx, DWORD PTR _pkImprovementEntry$223452[ebp]
	call	?IsSpecificCivRequired@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsSpecificCivRequired
	movzx	edx, al
	test	edx, edx
	je	$LN18@Reset
	mov	ecx, DWORD PTR _pkImprovementEntry$223452[ebp]
	call	?GetRequiredCivilization@CvImprovementEntry@@QBE?AW4CivilizationTypes@@XZ ; CvImprovementEntry::GetRequiredCivilization
	mov	esi, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	call	?getCivilizationType@CvPlayer@@QBE?AW4CivilizationTypes@@XZ ; CvPlayer::getCivilizationType
	cmp	esi, eax
	jne	$LN18@Reset

; 774  : 					{
; 775  : 						// Find corresponding build
; 776  : #ifdef AUI_WARNING_FIXES
; 777  : 						for (uint jJ = 0; jJ < GC.getNumBuildInfos(); jJ++)
; 778  : #else
; 779  : 						for(int jJ = 0; jJ < GC.getNumBuildInfos(); jJ++)

	mov	DWORD PTR _jJ$223456[ebp], 0
	jmp	SHORT $LN16@Reset
$LN15@Reset:
	mov	ecx, DWORD PTR _jJ$223456[ebp]
	add	ecx, 1
	mov	DWORD PTR _jJ$223456[ebp], ecx
$LN16@Reset:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	DWORD PTR _jJ$223456[ebp], eax
	jge	SHORT $LN18@Reset

; 780  : #endif
; 781  : 						{
; 782  : 							CvBuildInfo* pkBuildEntry = GC.getBuildInfo((BuildTypes)jJ);

	mov	edx, DWORD PTR _jJ$223456[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	DWORD PTR _pkBuildEntry$223460[ebp], eax

; 783  : #ifdef AUI_WARNING_FIXES
; 784  : 							if (pkBuildEntry && (uint)pkBuildEntry->getImprovement() == iI)
; 785  : #else
; 786  : 							if(pkBuildEntry && pkBuildEntry->getImprovement() == iI)

	cmp	DWORD PTR _pkBuildEntry$223460[ebp], 0
	je	SHORT $LN13@Reset
	mov	ecx, DWORD PTR _pkBuildEntry$223460[ebp]
	call	?getImprovement@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getImprovement
	cmp	eax, DWORD PTR _iI$[ebp]
	jne	SHORT $LN13@Reset

; 787  : #endif
; 788  : 							{
; 789  : 								int iTech = pkBuildEntry->getTechPrereq();

	mov	ecx, DWORD PTR _pkBuildEntry$223460[ebp]
	call	?getTechPrereq@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getTechPrereq
	mov	DWORD PTR _iTech$223463[ebp], eax

; 790  : 								if(iTech != NO_TECH)

	cmp	DWORD PTR _iTech$223463[ebp], -1
	je	SHORT $LN13@Reset

; 791  : 								{
; 792  : 									m_piCivTechPriority[iTech] *= GC.getTECH_PRIORITY_UNIQUE_ITEM();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1844
	mov	DWORD PTR $T227014[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _iTech$223463[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	imul	ecx, DWORD PTR $T227014[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	edx, DWORD PTR _iTech$223463[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 793  : 									m_peCivTechUniqueImprovements[iTech] = static_cast<ImprovementTypes>(iI);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _iTech$223463[ebp]
	mov	eax, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN13@Reset:

; 794  : 								}
; 795  : 							}
; 796  : 						}

	jmp	$LN15@Reset
$LN18@Reset:

; 797  : 					}
; 798  : 				}
; 799  : 			}

	jmp	$LN20@Reset
$LN36@Reset:

; 800  : 		}
; 801  : 
; 802  : 		// Player Traits
; 803  : #ifdef AUI_WARNING_FIXES
; 804  : 		for (uint iTraitLoop = 0; iTraitLoop < GC.getNumTraitInfos(); iTraitLoop++)
; 805  : #else
; 806  : 		int iNumTraits = GC.getNumTraitInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTraitInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTraitInfos
	mov	DWORD PTR _iNumTraits$223466[ebp], eax

; 807  : 		for(int iTraitLoop = 0; iTraitLoop < iNumTraits; iTraitLoop++)

	mov	DWORD PTR _iTraitLoop$223467[ebp], 0
	jmp	SHORT $LN11@Reset
$LN10@Reset:
	mov	ecx, DWORD PTR _iTraitLoop$223467[ebp]
	add	ecx, 1
	mov	DWORD PTR _iTraitLoop$223467[ebp], ecx
$LN11@Reset:
	mov	edx, DWORD PTR _iTraitLoop$223467[ebp]
	cmp	edx, DWORD PTR _iNumTraits$223466[ebp]
	jge	$LN37@Reset

; 808  : #endif
; 809  : 		{
; 810  : 			TraitTypes eTraitLoop = (TraitTypes) iTraitLoop;

	mov	eax, DWORD PTR _iTraitLoop$223467[ebp]
	mov	DWORD PTR _eTraitLoop$223471[ebp], eax

; 811  : 			// Do we have this trait?
; 812  : 			CvLeaderHeadInfo* pkLeaderInfo = &m_pPlayer->getLeaderInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+44]
	call	?getLeaderInfo@CvPlayer@@QBEAAVCvLeaderHeadInfo@@XZ ; CvPlayer::getLeaderInfo
	mov	DWORD PTR _pkLeaderInfo$223473[ebp], eax

; 813  : 			if(pkLeaderInfo)

	cmp	DWORD PTR _pkLeaderInfo$223473[ebp], 0
	je	$LN8@Reset

; 814  : 			{
; 815  : 				if(!pkLeaderInfo->hasTrait(iTraitLoop))  // This trait check disregards tech prereqs and obsoletes

	mov	edx, DWORD PTR _iTraitLoop$223467[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkLeaderInfo$223473[ebp]
	call	?hasTrait@CvLeaderHeadInfo@@QBE_NH@Z	; CvLeaderHeadInfo::hasTrait
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN7@Reset

; 816  : 					continue;

	jmp	SHORT $LN10@Reset
$LN7@Reset:

; 817  : 
; 818  : 				CvTraitEntry* pkTraitInfo = GC.getTraitInfo(eTraitLoop);

	mov	ecx, DWORD PTR _eTraitLoop$223471[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTraitInfo@CvGlobals@@QAEPAVCvTraitEntry@@W4TraitTypes@@@Z ; CvGlobals::getTraitInfo
	mov	DWORD PTR _pkTraitInfo$223476[ebp], eax

; 819  : 				if(pkTraitInfo)

	cmp	DWORD PTR _pkTraitInfo$223476[ebp], 0
	je	$LN8@Reset

; 820  : 				{
; 821  : 					// Maya Calendar trait - We want to heavily weight the unlock tech
; 822  : 					if(pkTraitInfo->IsMayaCalendarBonuses())

	mov	ecx, DWORD PTR _pkTraitInfo$223476[ebp]
	call	?IsMayaCalendarBonuses@CvTraitEntry@@QBE_NXZ ; CvTraitEntry::IsMayaCalendarBonuses
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN5@Reset

; 823  : 					{
; 824  : 						int iPrereqTech = pkTraitInfo->GetPrereqTech();

	mov	ecx, DWORD PTR _pkTraitInfo$223476[ebp]
	call	?GetPrereqTech@CvTraitEntry@@QBEHXZ	; CvTraitEntry::GetPrereqTech
	mov	DWORD PTR _iPrereqTech$223479[ebp], eax

; 825  : 						if(iPrereqTech != NO_TECH)

	cmp	DWORD PTR _iPrereqTech$223479[ebp], -1
	je	SHORT $LN5@Reset

; 826  : 						{
; 827  : 							m_piCivTechPriority[iPrereqTech] *= GC.getTECH_PRIORITY_MAYA_CALENDAR_BONUS();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1848
	mov	DWORD PTR $T227018[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _iPrereqTech$223479[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	imul	ecx, DWORD PTR $T227018[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	edx, DWORD PTR _iPrereqTech$223479[ebp]
	mov	DWORD PTR [eax+edx*4], ecx
$LN5@Reset:

; 828  : 						}
; 829  : 					}
; 830  : 
; 831  : 					// Other traits that unlock by tech? -- Yep. ~EAP
; 832  : 					int iPrereqTech = pkTraitInfo->GetFreeUnitPrereqTech();

	mov	ecx, DWORD PTR _pkTraitInfo$223476[ebp]
	call	?GetFreeUnitPrereqTech@CvTraitEntry@@QBE?AW4TechTypes@@XZ ; CvTraitEntry::GetFreeUnitPrereqTech
	mov	DWORD PTR _iPrereqTech$223481[ebp], eax

; 833  : 					if (iPrereqTech != NO_TECH)

	cmp	DWORD PTR _iPrereqTech$223481[ebp], -1
	je	SHORT $LN3@Reset

; 834  : 					{
; 835  : 						m_piCivTechPriority[iPrereqTech] += GC.getTECH_PRIORITY_MAYA_CALENDAR_BONUS();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1848
	mov	DWORD PTR $T227022[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _iPrereqTech$223481[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	add	ecx, DWORD PTR $T227022[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	edx, DWORD PTR _iPrereqTech$223481[ebp]
	mov	DWORD PTR [eax+edx*4], ecx
$LN3@Reset:

; 836  : 					}
; 837  : 
; 838  : 					iPrereqTech = pkTraitInfo->GetCapitalFreeBuildingPrereqTech();

	mov	ecx, DWORD PTR _pkTraitInfo$223476[ebp]
	call	?GetCapitalFreeBuildingPrereqTech@CvTraitEntry@@QBE?AW4TechTypes@@XZ ; CvTraitEntry::GetCapitalFreeBuildingPrereqTech
	mov	DWORD PTR _iPrereqTech$223481[ebp], eax

; 839  : 					if (iPrereqTech != NO_TECH)

	cmp	DWORD PTR _iPrereqTech$223481[ebp], -1
	je	SHORT $LN2@Reset

; 840  : 					{
; 841  : 						m_piCivTechPriority[iPrereqTech] += GC.getTECH_PRIORITY_MAYA_CALENDAR_BONUS();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1848
	mov	DWORD PTR $T227026[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _iPrereqTech$223481[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	add	ecx, DWORD PTR $T227026[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	edx, DWORD PTR _iPrereqTech$223481[ebp]
	mov	DWORD PTR [eax+edx*4], ecx
$LN2@Reset:

; 842  : 					}
; 843  : 
; 844  : 
; 845  : 					iPrereqTech = pkTraitInfo->GetFreeBuildingPrereqTech();

	mov	ecx, DWORD PTR _pkTraitInfo$223476[ebp]
	call	?GetFreeBuildingPrereqTech@CvTraitEntry@@QBE?AW4TechTypes@@XZ ; CvTraitEntry::GetFreeBuildingPrereqTech
	mov	DWORD PTR _iPrereqTech$223481[ebp], eax

; 846  : 					if (iPrereqTech != NO_TECH)

	cmp	DWORD PTR _iPrereqTech$223481[ebp], -1
	je	SHORT $LN8@Reset

; 847  : 					{
; 848  : 						m_piCivTechPriority[iPrereqTech] += GC.getTECH_PRIORITY_MAYA_CALENDAR_BONUS();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1848
	mov	DWORD PTR $T227030[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _iPrereqTech$223481[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	add	ecx, DWORD PTR $T227030[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	edx, DWORD PTR _iPrereqTech$223481[ebp]
	mov	DWORD PTR [eax+edx*4], ecx
$LN8@Reset:

; 849  : 					}
; 850  : 				}
; 851  : 			}
; 852  : 		}

	jmp	$LN10@Reset
$LN37@Reset:

; 853  : 	}
; 854  : 
; 855  : 	// Reset AI too
; 856  : 	m_pTechAI->Reset();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	call	?Reset@CvTechAI@@QAEXXZ			; CvTechAI::Reset

; 857  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?Reset@CvPlayerTechs@@QAEXXZ ENDP			; CvPlayerTechs::Reset
_TEXT	ENDS
PUBLIC	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ; operator>><int>
PUBLIC	??$ReadHashedDataArray@W4ImprovementTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4ImprovementTypes@@H@Z ; CvInfosSerializationHelper::ReadHashedDataArray<enum ImprovementTypes>
PUBLIC	??$ReadHashedDataArray@W4BuildingTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4BuildingTypes@@H@Z ; CvInfosSerializationHelper::ReadHashedDataArray<enum BuildingTypes>
PUBLIC	??$ReadHashedDataArray@W4UnitTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4UnitTypes@@H@Z ; CvInfosSerializationHelper::ReadHashedDataArray<enum UnitTypes>
PUBLIC	??$ReadHashedDataArray@W4ResourceTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4ResourceTypes@@H@Z ; CvInfosSerializationHelper::ReadHashedDataArray<enum ResourceTypes>
PUBLIC	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
PUBLIC	??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<bool>
PUBLIC	?Read@CvPlayerTechs@@QAEXAAVFDataStream@@@Z	; CvPlayerTechs::Read
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
EXTRN	?Read@CvTechAI@@QAEXAAVFDataStream@@@Z:PROC	; CvTechAI::Read
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Odtp
;	COMDAT ?Read@CvPlayerTechs@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T227043 = -28						; size = 4
$T227042 = -24						; size = 4
_iNumTechs$223491 = -20					; size = 4
_uiVersion$ = -16					; size = 4
_kLatestFlavorWrapper$ = -12				; size = 8
_iNumFlavors$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Read@CvPlayerTechs@@QAEXAAVFDataStream@@@Z PROC	; CvPlayerTechs::Read, COMDAT
; _this$ = ecx

; 861  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 862  : 	// Version number to maintain backwards compatibility
; 863  : 	uint uiVersion;
; 864  : 	kStream >> uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 865  : 
; 866  : 	// TODO: If m_pTechs is NULL then the stream will not be advanced causing errors to occur.
; 867  : 	CvAssertMsg(m_pTechs != NULL && m_pTechs->GetNumTechs() > 0, "Number of techs to serialize is expected to greater than 0");
; 868  : 	if(m_pTechs != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+40], 0
	je	$LN1@Read

; 869  : 	{
; 870  : 		const int iNumTechs = m_pTechs->GetNumTechs();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+40]
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	mov	DWORD PTR _iNumTechs$223491[ebp], eax

; 871  : 
; 872  : 		CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_pabResearchingTech, iNumTechs);

	mov	eax, DWORD PTR _iNumTechs$223491[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<bool>
	add	esp, 12					; 0000000cH

; 873  : 		CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_piCivTechPriority, iNumTechs);

	mov	ecx, DWORD PTR _iNumTechs$223491[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
	add	esp, 12					; 0000000cH

; 874  : 		CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_piLocaleTechPriority, iNumTechs);

	mov	edx, DWORD PTR _iNumTechs$223491[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
	add	esp, 12					; 0000000cH

; 875  : 		CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_peLocaleTechResources, iNumTechs);

	mov	eax, DWORD PTR _iNumTechs$223491[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$ReadHashedDataArray@W4ResourceTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4ResourceTypes@@H@Z ; CvInfosSerializationHelper::ReadHashedDataArray<enum ResourceTypes>
	add	esp, 12					; 0000000cH

; 876  : 		CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_peCivTechUniqueUnits, iNumTechs);

	mov	ecx, DWORD PTR _iNumTechs$223491[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$ReadHashedDataArray@W4UnitTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4UnitTypes@@H@Z ; CvInfosSerializationHelper::ReadHashedDataArray<enum UnitTypes>
	add	esp, 12					; 0000000cH

; 877  : 		CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_peCivTechUniqueBuildings, iNumTechs);

	mov	edx, DWORD PTR _iNumTechs$223491[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$ReadHashedDataArray@W4BuildingTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4BuildingTypes@@H@Z ; CvInfosSerializationHelper::ReadHashedDataArray<enum BuildingTypes>
	add	esp, 12					; 0000000cH

; 878  : 		CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_peCivTechUniqueImprovements, iNumTechs);

	mov	eax, DWORD PTR _iNumTechs$223491[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$ReadHashedDataArray@W4ImprovementTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4ImprovementTypes@@H@Z ; CvInfosSerializationHelper::ReadHashedDataArray<enum ImprovementTypes>
	add	esp, 12					; 0000000cH
$LN1@Read:

; 879  : 	}
; 880  : 
; 881  : 	// Now for AI
; 882  : 	m_pTechAI->Read(kStream);

	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+48]
	call	?Read@CvTechAI@@QAEXAAVFDataStream@@@Z	; CvTechAI::Read

; 883  : 
; 884  : 	CvAssertMsg(m_piLatestFlavorValues != NULL && GC.getNumFlavorTypes() > 0, "Number of flavor values to serialize is expected to greater than 0");
; 885  : 
; 886  : 	int iNumFlavors;
; 887  : 	kStream >> iNumFlavors;

	lea	eax, DWORD PTR _iNumFlavors$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 888  : 
; 889  : 	ArrayWrapper<int> kLatestFlavorWrapper(iNumFlavors, m_piLatestFlavorValues);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T227043[ebp], edx
	mov	eax, DWORD PTR _iNumFlavors$[ebp]
	mov	DWORD PTR $T227042[ebp], eax
	mov	ecx, DWORD PTR $T227043[ebp]
	mov	DWORD PTR _kLatestFlavorWrapper$[ebp], ecx
	mov	edx, DWORD PTR $T227042[ebp]
	mov	DWORD PTR _kLatestFlavorWrapper$[ebp+4], edx

; 890  : 	kStream >> kLatestFlavorWrapper;

	lea	eax, DWORD PTR _kLatestFlavorWrapper$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ; operator>><int>
	add	esp, 8

; 891  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Read@CvPlayerTechs@@QAEXAAVFDataStream@@@Z ENDP	; CvPlayerTechs::Read
_TEXT	ENDS
PUBLIC	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ; operator<<<int>
PUBLIC	??$WriteHashedDataArray@W4TechTypes@@W4ImprovementTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4ImprovementTypes@@I@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,enum ImprovementTypes>
PUBLIC	??$WriteHashedDataArray@W4TechTypes@@W4BuildingTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4BuildingTypes@@I@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,enum BuildingTypes>
PUBLIC	??$WriteHashedDataArray@W4TechTypes@@W4UnitTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4UnitTypes@@I@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,enum UnitTypes>
PUBLIC	??$WriteHashedDataArray@W4TechTypes@@W4ResourceTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4ResourceTypes@@I@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,enum ResourceTypes>
PUBLIC	??$WriteHashedDataArray@W4TechTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,int>
PUBLIC	??$WriteHashedDataArray@W4TechTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,bool>
PUBLIC	?Write@CvPlayerTechs@@QAEXAAVFDataStream@@@Z	; CvPlayerTechs::Write
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
EXTRN	?Write@CvTechAI@@QBEXAAVFDataStream@@@Z:PROC	; CvTechAI::Write
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Odtp
;	COMDAT ?Write@CvPlayerTechs@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T227065 = -32						; size = 4
$T227061 = -28						; size = 4
$T227054 = -24						; size = 4
$T227047 = -20						; size = 8
$T227046 = -12						; size = 4
_iNumTechs$223568 = -8					; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Write@CvPlayerTechs@@QAEXAAVFDataStream@@@Z PROC	; CvPlayerTechs::Write, COMDAT
; _this$ = ecx

; 895  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 896  : 	// Current version number
; 897  : 	uint uiVersion = 1;

	mov	DWORD PTR _uiVersion$[ebp], 1

; 898  : 	kStream << uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 899  : 
; 900  : 	// TODO: If m_pTechs is NULL then the stream will not advance
; 901  : 	CvAssertMsg(m_pTechs != NULL && m_pTechs->GetNumTechs() > 0, "Number of techs to serialize is expected to greater than 0");
; 902  : 	if(m_pTechs != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+40], 0
	je	$LN1@Write

; 903  : 	{
; 904  : 		const int iNumTechs = m_pTechs->GetNumTechs();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+40]
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	mov	DWORD PTR _iNumTechs$223568[ebp], eax

; 905  : 
; 906  : 		CvInfosSerializationHelper::WriteHashedDataArray<TechTypes, bool>(kStream, m_pabResearchingTech, iNumTechs);

	mov	eax, DWORD PTR _iNumTechs$223568[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$WriteHashedDataArray@W4TechTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,bool>
	add	esp, 12					; 0000000cH

; 907  : 		CvInfosSerializationHelper::WriteHashedDataArray<TechTypes, int>(kStream, m_piCivTechPriority, iNumTechs);

	mov	ecx, DWORD PTR _iNumTechs$223568[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$WriteHashedDataArray@W4TechTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,int>
	add	esp, 12					; 0000000cH

; 908  : 		CvInfosSerializationHelper::WriteHashedDataArray<TechTypes, int>(kStream, m_piLocaleTechPriority, iNumTechs);

	mov	edx, DWORD PTR _iNumTechs$223568[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$WriteHashedDataArray@W4TechTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,int>
	add	esp, 12					; 0000000cH

; 909  : 		CvInfosSerializationHelper::WriteHashedDataArray<TechTypes, ResourceTypes>(kStream, m_peLocaleTechResources, iNumTechs);

	mov	eax, DWORD PTR _iNumTechs$223568[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$WriteHashedDataArray@W4TechTypes@@W4ResourceTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4ResourceTypes@@I@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,enum ResourceTypes>
	add	esp, 12					; 0000000cH

; 910  : 		CvInfosSerializationHelper::WriteHashedDataArray<TechTypes, UnitTypes>(kStream, m_peCivTechUniqueUnits, iNumTechs);

	mov	ecx, DWORD PTR _iNumTechs$223568[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$WriteHashedDataArray@W4TechTypes@@W4UnitTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4UnitTypes@@I@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,enum UnitTypes>
	add	esp, 12					; 0000000cH

; 911  : 		CvInfosSerializationHelper::WriteHashedDataArray<TechTypes, BuildingTypes>(kStream, m_peCivTechUniqueBuildings, iNumTechs);

	mov	edx, DWORD PTR _iNumTechs$223568[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$WriteHashedDataArray@W4TechTypes@@W4BuildingTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4BuildingTypes@@I@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,enum BuildingTypes>
	add	esp, 12					; 0000000cH

; 912  : 		CvInfosSerializationHelper::WriteHashedDataArray<TechTypes, ImprovementTypes>(kStream, m_peCivTechUniqueImprovements, iNumTechs);

	mov	eax, DWORD PTR _iNumTechs$223568[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$WriteHashedDataArray@W4TechTypes@@W4ImprovementTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4ImprovementTypes@@I@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,enum ImprovementTypes>
	add	esp, 12					; 0000000cH
$LN1@Write:

; 913  : 	}
; 914  : 
; 915  : 	// Now for AI
; 916  : 	m_pTechAI->Write(kStream);

	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+48]
	call	?Write@CvTechAI@@QBEXAAVFDataStream@@@Z	; CvTechAI::Write

; 917  : 
; 918  : 	CvAssertMsg(m_piLatestFlavorValues != NULL && GC.getNumFlavorTypes() > 0, "Number of flavor values to serialize is expected to greater than 0");
; 919  : 	kStream << GC.getNumFlavorTypes();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T227054[ebp], eax
	mov	ecx, DWORD PTR $T227054[ebp]
	mov	DWORD PTR $T227046[ebp], ecx
	lea	edx, DWORD PTR $T227046[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 920  : 	kStream << ArrayWrapper<int>(GC.getNumFlavorTypes(), m_piLatestFlavorValues);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T227061[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T227065[ebp], edx
	mov	eax, DWORD PTR $T227065[ebp]
	mov	DWORD PTR $T227047[ebp], eax
	mov	ecx, DWORD PTR $T227061[ebp]
	mov	DWORD PTR $T227047[ebp+4], ecx
	lea	edx, DWORD PTR $T227047[ebp]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ; operator<<<int>
	add	esp, 8

; 921  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Write@CvPlayerTechs@@QAEXAAVFDataStream@@@Z ENDP	; CvPlayerTechs::Write
_TEXT	ENDS
PUBLIC	?AddFlavorAsStrategies@CvPlayerTechs@@AAEXH@Z	; CvPlayerTechs::AddFlavorAsStrategies
PUBLIC	?SetLocalePriorities@CvPlayerTechs@@QAEXXZ	; CvPlayerTechs::SetLocalePriorities
; Function compile flags: /Odtp
;	COMDAT ?FlavorUpdate@CvPlayerTechs@@UAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T227071 = -4						; size = 4
?FlavorUpdate@CvPlayerTechs@@UAEXXZ PROC		; CvPlayerTechs::FlavorUpdate, COMDAT
; _this$ = ecx

; 925  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 926  : 	SetLocalePriorities();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalePriorities@CvPlayerTechs@@QAEXXZ ; CvPlayerTechs::SetLocalePriorities

; 927  : 	AddFlavorAsStrategies(GC.getTECH_WEIGHT_PROPAGATION_PERCENT());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1836
	mov	DWORD PTR $T227071[ebp], eax
	mov	ecx, DWORD PTR $T227071[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddFlavorAsStrategies@CvPlayerTechs@@AAEXH@Z ; CvPlayerTechs::AddFlavorAsStrategies

; 928  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FlavorUpdate@CvPlayerTechs@@UAEXXZ ENDP		; CvPlayerTechs::FlavorUpdate
_TEXT	ENDS
PUBLIC	?GetPlayer@CvPlayerTechs@@QAEPAVCvPlayer@@XZ	; CvPlayerTechs::GetPlayer
; Function compile flags: /Odtp
;	COMDAT ?GetPlayer@CvPlayerTechs@@QAEPAVCvPlayer@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPlayer@CvPlayerTechs@@QAEPAVCvPlayer@@XZ PROC	; CvPlayerTechs::GetPlayer, COMDAT
; _this$ = ecx

; 932  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 933  : 	return m_pPlayer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+44]

; 934  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPlayer@CvPlayerTechs@@QAEPAVCvPlayer@@XZ ENDP	; CvPlayerTechs::GetPlayer
_TEXT	ENDS
PUBLIC	?GetTechAI@CvPlayerTechs@@QAEPAVCvTechAI@@XZ	; CvPlayerTechs::GetTechAI
; Function compile flags: /Odtp
;	COMDAT ?GetTechAI@CvPlayerTechs@@QAEPAVCvTechAI@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTechAI@CvPlayerTechs@@QAEPAVCvTechAI@@XZ PROC	; CvPlayerTechs::GetTechAI, COMDAT
; _this$ = ecx

; 938  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 939  : 	return m_pTechAI;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+48]

; 940  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTechAI@CvPlayerTechs@@QAEPAVCvTechAI@@XZ ENDP	; CvPlayerTechs::GetTechAI
_TEXT	ENDS
PUBLIC	?IsResearchingTech@CvPlayerTechs@@QBE_NW4TechTypes@@@Z ; CvPlayerTechs::IsResearchingTech
; Function compile flags: /Odtp
;	COMDAT ?IsResearchingTech@CvPlayerTechs@@QBE_NW4TechTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?IsResearchingTech@CvPlayerTechs@@QBE_NW4TechTypes@@@Z PROC ; CvPlayerTechs::IsResearchingTech, COMDAT
; _this$ = ecx

; 944  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 945  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 946  : 	CvAssertMsg(eIndex < GC.getNumTechInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 947  : 	return m_pabResearchingTech[eIndex];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	al, BYTE PTR [ecx+edx]

; 948  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsResearchingTech@CvPlayerTechs@@QBE_NW4TechTypes@@@Z ENDP ; CvPlayerTechs::IsResearchingTech
_TEXT	ENDS
PUBLIC	?SetResearchingTech@CvPlayerTechs@@QAEXW4TechTypes@@_N@Z ; CvPlayerTechs::SetResearchingTech
; Function compile flags: /Odtp
;	COMDAT ?SetResearchingTech@CvPlayerTechs@@QAEXW4TechTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
_bNewValue$ = 12					; size = 1
?SetResearchingTech@CvPlayerTechs@@QAEXW4TechTypes@@_N@Z PROC ; CvPlayerTechs::SetResearchingTech, COMDAT
; _this$ = ecx

; 952  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 953  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 954  : 	CvAssertMsg(eIndex < GC.getNumTechInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 955  : 
; 956  : 	if(m_pabResearchingTech[eIndex] != bNewValue)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _eIndex$[ebp]
	movzx	eax, BYTE PTR [ecx+edx]
	movzx	ecx, BYTE PTR _bNewValue$[ebp]
	cmp	eax, ecx
	je	SHORT $LN2@SetResearc

; 957  : 	{
; 958  : 		m_pabResearchingTech[eIndex] = bNewValue;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _eIndex$[ebp]
	mov	dl, BYTE PTR _bNewValue$[ebp]
	mov	BYTE PTR [eax+ecx], dl
$LN2@SetResearc:

; 959  : 	}
; 960  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetResearchingTech@CvPlayerTechs@@QAEXW4TechTypes@@_N@Z ENDP ; CvPlayerTechs::SetResearchingTech
_TEXT	ENDS
PUBLIC	?SetCivTechPriority@CvPlayerTechs@@QAEXW4TechTypes@@H@Z ; CvPlayerTechs::SetCivTechPriority
; Function compile flags: /Odtp
;	COMDAT ?SetCivTechPriority@CvPlayerTechs@@QAEXW4TechTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
_iNewValue$ = 12					; size = 4
?SetCivTechPriority@CvPlayerTechs@@QAEXW4TechTypes@@H@Z PROC ; CvPlayerTechs::SetCivTechPriority, COMDAT
; _this$ = ecx

; 964  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 965  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 966  : 	CvAssertMsg(eIndex < GC.getNumTechInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 967  : 
; 968  : 	m_piCivTechPriority[eIndex] = iNewValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR _iNewValue$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 969  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetCivTechPriority@CvPlayerTechs@@QAEXW4TechTypes@@H@Z ENDP ; CvPlayerTechs::SetCivTechPriority
_TEXT	ENDS
PUBLIC	?GetCivTechPriority@CvPlayerTechs@@QBEHW4TechTypes@@@Z ; CvPlayerTechs::GetCivTechPriority
; Function compile flags: /Odtp
;	COMDAT ?GetCivTechPriority@CvPlayerTechs@@QBEHW4TechTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?GetCivTechPriority@CvPlayerTechs@@QBEHW4TechTypes@@@Z PROC ; CvPlayerTechs::GetCivTechPriority, COMDAT
; _this$ = ecx

; 973  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 974  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 975  : 	CvAssertMsg(eIndex < GC.getNumTechInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 976  : 	return m_piCivTechPriority[eIndex];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 977  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetCivTechPriority@CvPlayerTechs@@QBEHW4TechTypes@@@Z ENDP ; CvPlayerTechs::GetCivTechPriority
_TEXT	ENDS
PUBLIC	?SetLocaleTechPriority@CvPlayerTechs@@QAEXW4TechTypes@@H@Z ; CvPlayerTechs::SetLocaleTechPriority
; Function compile flags: /Odtp
;	COMDAT ?SetLocaleTechPriority@CvPlayerTechs@@QAEXW4TechTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
_iNewValue$ = 12					; size = 4
?SetLocaleTechPriority@CvPlayerTechs@@QAEXW4TechTypes@@H@Z PROC ; CvPlayerTechs::SetLocaleTechPriority, COMDAT
; _this$ = ecx

; 981  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 982  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 983  : 	CvAssertMsg(eIndex < GC.getNumTechInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 984  : 
; 985  : 	m_piLocaleTechPriority[eIndex] = iNewValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR _iNewValue$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 986  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetLocaleTechPriority@CvPlayerTechs@@QAEXW4TechTypes@@H@Z ENDP ; CvPlayerTechs::SetLocaleTechPriority
_TEXT	ENDS
PUBLIC	?GetLocaleTechPriority@CvPlayerTechs@@QBEHW4TechTypes@@@Z ; CvPlayerTechs::GetLocaleTechPriority
; Function compile flags: /Odtp
;	COMDAT ?GetLocaleTechPriority@CvPlayerTechs@@QBEHW4TechTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?GetLocaleTechPriority@CvPlayerTechs@@QBEHW4TechTypes@@@Z PROC ; CvPlayerTechs::GetLocaleTechPriority, COMDAT
; _this$ = ecx

; 990  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 991  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 992  : 	CvAssertMsg(eIndex < GC.getNumTechInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 993  : 	return m_piLocaleTechPriority[eIndex];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 994  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetLocaleTechPriority@CvPlayerTechs@@QBEHW4TechTypes@@@Z ENDP ; CvPlayerTechs::GetLocaleTechPriority
_TEXT	ENDS
PUBLIC	?GetLocaleTechResource@CvPlayerTechs@@QBE?AW4ResourceTypes@@W4TechTypes@@@Z ; CvPlayerTechs::GetLocaleTechResource
; Function compile flags: /Odtp
;	COMDAT ?GetLocaleTechResource@CvPlayerTechs@@QBE?AW4ResourceTypes@@W4TechTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?GetLocaleTechResource@CvPlayerTechs@@QBE?AW4ResourceTypes@@W4TechTypes@@@Z PROC ; CvPlayerTechs::GetLocaleTechResource, COMDAT
; _this$ = ecx

; 997  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 998  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 999  : 	CvAssertMsg(eIndex < GC.getNumTechInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 1000 : 
; 1001 : 	return m_peLocaleTechResources[eIndex];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 1002 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetLocaleTechResource@CvPlayerTechs@@QBE?AW4ResourceTypes@@W4TechTypes@@@Z ENDP ; CvPlayerTechs::GetLocaleTechResource
_TEXT	ENDS
PUBLIC	?GetCivTechUniqueUnit@CvPlayerTechs@@QBE?AW4UnitTypes@@W4TechTypes@@@Z ; CvPlayerTechs::GetCivTechUniqueUnit
; Function compile flags: /Odtp
;	COMDAT ?GetCivTechUniqueUnit@CvPlayerTechs@@QBE?AW4UnitTypes@@W4TechTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?GetCivTechUniqueUnit@CvPlayerTechs@@QBE?AW4UnitTypes@@W4TechTypes@@@Z PROC ; CvPlayerTechs::GetCivTechUniqueUnit, COMDAT
; _this$ = ecx

; 1005 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1006 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 1007 : 	CvAssertMsg(eIndex < GC.getNumTechInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 1008 : 
; 1009 : 	return m_peCivTechUniqueUnits[eIndex];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 1010 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetCivTechUniqueUnit@CvPlayerTechs@@QBE?AW4UnitTypes@@W4TechTypes@@@Z ENDP ; CvPlayerTechs::GetCivTechUniqueUnit
_TEXT	ENDS
PUBLIC	?GetCivTechUniqueBuilding@CvPlayerTechs@@QBE?AW4BuildingTypes@@W4TechTypes@@@Z ; CvPlayerTechs::GetCivTechUniqueBuilding
; Function compile flags: /Odtp
;	COMDAT ?GetCivTechUniqueBuilding@CvPlayerTechs@@QBE?AW4BuildingTypes@@W4TechTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?GetCivTechUniqueBuilding@CvPlayerTechs@@QBE?AW4BuildingTypes@@W4TechTypes@@@Z PROC ; CvPlayerTechs::GetCivTechUniqueBuilding, COMDAT
; _this$ = ecx

; 1013 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1014 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 1015 : 	CvAssertMsg(eIndex < GC.getNumTechInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 1016 : 
; 1017 : 	return m_peCivTechUniqueBuildings[eIndex];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 1018 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetCivTechUniqueBuilding@CvPlayerTechs@@QBE?AW4BuildingTypes@@W4TechTypes@@@Z ENDP ; CvPlayerTechs::GetCivTechUniqueBuilding
_TEXT	ENDS
PUBLIC	?GetCivTechUniqueImprovement@CvPlayerTechs@@QBE?AW4ImprovementTypes@@W4TechTypes@@@Z ; CvPlayerTechs::GetCivTechUniqueImprovement
; Function compile flags: /Odtp
;	COMDAT ?GetCivTechUniqueImprovement@CvPlayerTechs@@QBE?AW4ImprovementTypes@@W4TechTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?GetCivTechUniqueImprovement@CvPlayerTechs@@QBE?AW4ImprovementTypes@@W4TechTypes@@@Z PROC ; CvPlayerTechs::GetCivTechUniqueImprovement, COMDAT
; _this$ = ecx

; 1021 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1022 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 1023 : 	CvAssertMsg(eIndex < GC.getNumTechInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 1024 : 
; 1025 : 	return m_peCivTechUniqueImprovements[eIndex];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 1026 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetCivTechUniqueImprovement@CvPlayerTechs@@QBE?AW4ImprovementTypes@@W4TechTypes@@@Z ENDP ; CvPlayerTechs::GetCivTechUniqueImprovement
_TEXT	ENDS
PUBLIC	?plotDistance@@YAHHHHH@Z			; plotDistance
EXTRN	?canBuild@CvPlayer@@QBE_NPBVCvPlot@@W4BuildTypes@@_N222@Z:PROC ; CvPlayer::canBuild
EXTRN	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z:PROC ; CvImprovementEntry::IsImprovementResourceTrade
EXTRN	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::getResourceType
EXTRN	?plotCity@@YAPAVCvPlot@@HHH@Z:PROC		; plotCity
EXTRN	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::nextCity
EXTRN	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::firstCity
; Function compile flags: /Odtp
;	COMDAT ?SetLocalePriorities@CvPlayerTechs@@QAEXXZ
_TEXT	SEGMENT
_this$ = -172						; size = 4
$T227231 = -168						; size = 4
$T227230 = -164						; size = 4
$T227215 = -160						; size = 4
$T227206 = -156						; size = 4
$T227141 = -84						; size = 4
$T227137 = -80						; size = 4
$T227133 = -76						; size = 4
$T227124 = -72						; size = 4
$T227115 = -68						; size = 4
$T227106 = -64						; size = 4
_iTech$223738 = -60					; size = 4
_pkImprovementInfo$223733 = -56				; size = 4
_eImprovement$223730 = -52				; size = 4
_eBuild$223726 = -48					; size = 4
_pkBuildInfo$223728 = -44				; size = 4
_eCorrectImprovement$223720 = -40			; size = 4
_eCorrectBuild$223721 = -36				; size = 4
_eResource$223718 = -32					; size = 4
_iBuildIndex$223722 = -28				; size = 4
_iDistance$223714 = -24					; size = 4
_pLoopPlot$223712 = -20					; size = 4
_iPlotLoop$223708 = -16					; size = 4
_pCity$ = -12						; size = 4
_iI$ = -8						; size = 4
_iLoop$ = -4						; size = 4
?SetLocalePriorities@CvPlayerTechs@@QAEXXZ PROC		; CvPlayerTechs::SetLocalePriorities, COMDAT
; _this$ = ecx

; 1030 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 172				; 000000acH
	mov	DWORD PTR _this$[ebp], ecx

; 1031 : 	int iLoop;
; 1032 : 	CvCity* pCity;
; 1033 : #ifdef AUI_WARNING_FIXES
; 1034 : 	uint iI;
; 1035 : #else
; 1036 : 	int iI;
; 1037 : #endif
; 1038 : 
; 1039 : 	for(iI = 0; iI < m_pTechs->GetNumTechs(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN24@SetLocaleP
$LN23@SetLocaleP:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN24@SetLocaleP:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+40]
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	cmp	DWORD PTR _iI$[ebp], eax
	jge	SHORT $LN22@SetLocaleP

; 1040 : 	{
; 1041 : 		m_piLocaleTechPriority[iI] = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [eax+ecx*4], 1

; 1042 : 		m_peLocaleTechResources[iI] = NO_RESOURCE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [eax+ecx*4], -1

; 1043 : 	}

	jmp	SHORT $LN23@SetLocaleP
$LN22@SetLocaleP:

; 1044 : 
; 1045 : 	// Loop through all our cities
; 1046 : 	for(pCity = m_pPlayer->firstCity(&iLoop); pCity != NULL; pCity = m_pPlayer->nextCity(&iLoop))

	push	0
	lea	edx, DWORD PTR _iLoop$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pCity$[ebp], eax
	jmp	SHORT $LN21@SetLocaleP
$LN20@SetLocaleP:
	push	0
	lea	ecx, DWORD PTR _iLoop$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+44]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pCity$[ebp], eax
$LN21@SetLocaleP:
	cmp	DWORD PTR _pCity$[ebp], 0
	je	$LN25@SetLocaleP

; 1047 : 	{
; 1048 : 		// Look at all Tiles this City could potentially work to see if there are any non-water resources that could be improved
; 1049 : 		for(int iPlotLoop = 0; iPlotLoop < NUM_CITY_PLOTS; iPlotLoop++)

	mov	DWORD PTR _iPlotLoop$223708[ebp], 0
	jmp	SHORT $LN18@SetLocaleP
$LN17@SetLocaleP:
	mov	eax, DWORD PTR _iPlotLoop$223708[ebp]
	add	eax, 1
	mov	DWORD PTR _iPlotLoop$223708[ebp], eax
$LN18@SetLocaleP:
	cmp	DWORD PTR _iPlotLoop$223708[ebp], 37	; 00000025H
	jge	$LN16@SetLocaleP

; 1050 : 		{
; 1051 : 			CvPlot* pLoopPlot = plotCity(pCity->getX(), pCity->getY(), iPlotLoop);

	mov	ecx, DWORD PTR _pCity$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR $T227106[ebp], edx
	mov	eax, DWORD PTR _pCity$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR $T227115[ebp], ecx
	mov	edx, DWORD PTR _iPlotLoop$223708[ebp]
	push	edx
	mov	eax, DWORD PTR $T227106[ebp]
	push	eax
	mov	ecx, DWORD PTR $T227115[ebp]
	push	ecx
	call	?plotCity@@YAPAVCvPlot@@HHH@Z		; plotCity
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pLoopPlot$223712[ebp], eax

; 1052 : 
; 1053 : 			if(pLoopPlot != NULL)

	cmp	DWORD PTR _pLoopPlot$223712[ebp], 0
	je	$LN15@SetLocaleP

; 1054 : 			{
; 1055 : 				int iDistance = plotDistance(pLoopPlot->getX(), pLoopPlot->getY(), pCity->getX(), pCity->getY());

	mov	edx, DWORD PTR _pCity$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR $T227124[ebp], eax
	mov	ecx, DWORD PTR _pCity$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR $T227133[ebp], edx
	mov	eax, DWORD PTR _pLoopPlot$223712[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T227137[ebp], ecx
	mov	edx, DWORD PTR _pLoopPlot$223712[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T227141[ebp], eax
	mov	ecx, DWORD PTR $T227124[ebp]
	push	ecx
	mov	edx, DWORD PTR $T227133[ebp]
	push	edx
	mov	eax, DWORD PTR $T227137[ebp]
	push	eax
	mov	ecx, DWORD PTR $T227141[ebp]
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iDistance$223714[ebp], eax

; 1056 : 
; 1057 : 				if(pLoopPlot->getOwner() == pCity->getOwner() || (iDistance <= 2 && pLoopPlot->getOwner() == NO_PLAYER))

	mov	edx, DWORD PTR _pLoopPlot$223712[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR $T227206[ebp], eax
	mov	ecx, DWORD PTR _pCity$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR $T227215[ebp], edx
	mov	eax, DWORD PTR $T227206[ebp]
	cmp	eax, DWORD PTR $T227215[ebp]
	je	SHORT $LN95@SetLocaleP
	cmp	DWORD PTR _iDistance$223714[ebp], 2
	jg	$LN15@SetLocaleP
	mov	ecx, DWORD PTR _pLoopPlot$223712[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	cmp	edx, -1
	jne	$LN15@SetLocaleP

; 1058 : 				{
; 1059 : 					if(!pLoopPlot->isWater())

$LN95@SetLocaleP:
	mov	eax, DWORD PTR _pLoopPlot$223712[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	movzx	eax, dl
	test	eax, eax
	jne	$LN15@SetLocaleP

; 1060 : 					{
; 1061 : 						ResourceTypes eResource = pLoopPlot->getResourceType(m_pPlayer->getTeam());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T227230[ebp], edx
	mov	eax, DWORD PTR $T227230[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T227231[ebp], eax
	mov	edx, DWORD PTR $T227231[ebp]
	push	edx
	mov	ecx, DWORD PTR _pLoopPlot$223712[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _eResource$223718[ebp], eax

; 1062 : 						if(eResource == NO_RESOURCE)

	cmp	DWORD PTR _eResource$223718[ebp], -1
	jne	SHORT $LN11@SetLocaleP

; 1063 : 						{
; 1064 : 							continue;

	jmp	$LN17@SetLocaleP
$LN11@SetLocaleP:

; 1065 : 						}
; 1066 : 
; 1067 : 						// Loop through the build types to find one that we can use
; 1068 : 						ImprovementTypes eCorrectImprovement = NO_IMPROVEMENT;

	mov	DWORD PTR _eCorrectImprovement$223720[ebp], -1

; 1069 : 						BuildTypes eCorrectBuild = NO_BUILD;

	mov	DWORD PTR _eCorrectBuild$223721[ebp], -1

; 1070 : #ifdef AUI_WARNING_FIXES
; 1071 : 						uint iBuildIndex;
; 1072 : #else
; 1073 : 						int iBuildIndex;
; 1074 : #endif
; 1075 : 						for(iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)

	mov	DWORD PTR _iBuildIndex$223722[ebp], 0
	jmp	SHORT $LN10@SetLocaleP
$LN9@SetLocaleP:
	mov	eax, DWORD PTR _iBuildIndex$223722[ebp]
	add	eax, 1
	mov	DWORD PTR _iBuildIndex$223722[ebp], eax
$LN10@SetLocaleP:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	DWORD PTR _iBuildIndex$223722[ebp], eax
	jge	SHORT $LN8@SetLocaleP

; 1076 : 						{
; 1077 : 							const BuildTypes eBuild = static_cast<BuildTypes>(iBuildIndex);

	mov	ecx, DWORD PTR _iBuildIndex$223722[ebp]
	mov	DWORD PTR _eBuild$223726[ebp], ecx

; 1078 : 							CvBuildInfo* pkBuildInfo = GC.getBuildInfo(eBuild);

	mov	edx, DWORD PTR _eBuild$223726[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	DWORD PTR _pkBuildInfo$223728[ebp], eax

; 1079 : 							if(pkBuildInfo)

	cmp	DWORD PTR _pkBuildInfo$223728[ebp], 0
	je	SHORT $LN7@SetLocaleP

; 1080 : 							{
; 1081 : 								// If this is the improvement we're looking for
; 1082 : 								const ImprovementTypes eImprovement = (ImprovementTypes)pkBuildInfo->getImprovement();

	mov	ecx, DWORD PTR _pkBuildInfo$223728[ebp]
	call	?getImprovement@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getImprovement
	mov	DWORD PTR _eImprovement$223730[ebp], eax

; 1083 : 								if(eImprovement != NO_IMPROVEMENT)

	cmp	DWORD PTR _eImprovement$223730[ebp], -1
	je	SHORT $LN7@SetLocaleP

; 1084 : 								{
; 1085 : 									CvImprovementEntry* pkImprovementInfo = GC.getImprovementInfo(eImprovement);

	mov	eax, DWORD PTR _eImprovement$223730[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	DWORD PTR _pkImprovementInfo$223733[ebp], eax

; 1086 : 									if(pkImprovementInfo && pkImprovementInfo->IsImprovementResourceTrade(eResource))

	cmp	DWORD PTR _pkImprovementInfo$223733[ebp], 0
	je	SHORT $LN7@SetLocaleP
	mov	ecx, DWORD PTR _eResource$223718[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkImprovementInfo$223733[ebp]
	call	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::IsImprovementResourceTrade
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN7@SetLocaleP

; 1087 : 									{
; 1088 : 										eCorrectBuild = eBuild;

	mov	eax, DWORD PTR _eBuild$223726[ebp]
	mov	DWORD PTR _eCorrectBuild$223721[ebp], eax

; 1089 : 										eCorrectImprovement = eImprovement;

	mov	ecx, DWORD PTR _eImprovement$223730[ebp]
	mov	DWORD PTR _eCorrectImprovement$223720[ebp], ecx

; 1090 : 										break;

	jmp	SHORT $LN8@SetLocaleP
$LN7@SetLocaleP:

; 1091 : 									}
; 1092 : 								}
; 1093 : 							}
; 1094 : 						}

	jmp	SHORT $LN9@SetLocaleP
$LN8@SetLocaleP:

; 1095 : 
; 1096 : 						// No valid build found
; 1097 : 						if(eCorrectBuild == NO_BUILD || eCorrectImprovement == NO_IMPROVEMENT)

	cmp	DWORD PTR _eCorrectBuild$223721[ebp], -1
	je	SHORT $LN3@SetLocaleP
	cmp	DWORD PTR _eCorrectImprovement$223720[ebp], -1
	jne	SHORT $LN4@SetLocaleP
$LN3@SetLocaleP:

; 1098 : 						{
; 1099 : 							continue;

	jmp	$LN17@SetLocaleP
$LN4@SetLocaleP:

; 1100 : 						}
; 1101 : 
; 1102 : 
; 1103 : 						// Looking for cases where we can't build the improvement for the resource
; 1104 : 						if(!m_pPlayer->canBuild(pLoopPlot, eCorrectBuild, false, false))

	push	1
	push	1
	push	0
	push	0
	mov	edx, DWORD PTR _eCorrectBuild$223721[ebp]
	push	edx
	mov	eax, DWORD PTR _pLoopPlot$223712[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+44]
	call	?canBuild@CvPlayer@@QBE_NPBVCvPlot@@W4BuildTypes@@_N222@Z ; CvPlayer::canBuild
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN15@SetLocaleP

; 1105 : 						{
; 1106 : 							// Find the tech associated with this build and increment its multiplier
; 1107 : #ifdef AUI_WARNING_FIXES
; 1108 : 							uint iTech = (uint)GC.getBuildInfo(eCorrectBuild)->getTechPrereq();
; 1109 : 							CvAssert(iTech < m_pTechs->GetNumTechs());		// Just assert on a value off the top end, a -1 is ok to just skip silently
; 1110 : 							if (iTech < m_pTechs->GetNumTechs())
; 1111 : #else
; 1112 : 							int iTech = GC.getBuildInfo(eCorrectBuild)->getTechPrereq();

	mov	eax, DWORD PTR _eCorrectBuild$223721[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, eax
	call	?getTechPrereq@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getTechPrereq
	mov	DWORD PTR _iTech$223738[ebp], eax

; 1113 : 							CvAssert(iTech < m_pTechs->GetNumTechs());		// Just assert on a value off the top end, a -1 is ok to just skip silently
; 1114 : 							if (iTech >= 0 && iTech < m_pTechs->GetNumTechs())

	cmp	DWORD PTR _iTech$223738[ebp], 0
	jl	SHORT $LN15@SetLocaleP
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+40]
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	cmp	DWORD PTR _iTech$223738[ebp], eax
	jge	SHORT $LN15@SetLocaleP

; 1115 : #endif
; 1116 : 							{
; 1117 : 								m_piLocaleTechPriority[iTech]++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _iTech$223738[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR _iTech$223738[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 1118 : 								m_peLocaleTechResources[iTech] = eResource;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _iTech$223738[ebp]
	mov	ecx, DWORD PTR _eResource$223718[ebp]
	mov	DWORD PTR [edx+eax*4], ecx
$LN15@SetLocaleP:

; 1119 : 							}
; 1120 : 						}
; 1121 : 					}
; 1122 : 				}
; 1123 : 			}
; 1124 : 		}

	jmp	$LN17@SetLocaleP
$LN16@SetLocaleP:

; 1125 : 	}

	jmp	$LN20@SetLocaleP
$LN25@SetLocaleP:

; 1126 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetLocalePriorities@CvPlayerTechs@@QAEXXZ ENDP		; CvPlayerTechs::SetLocalePriorities
_TEXT	ENDS
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDistance@@YAHHHHH@Z
_TEXT	SEGMENT
tv157 = -92						; size = 4
tv138 = -88						; size = 4
tv135 = -84						; size = 4
$T227315 = -80						; size = 4
$T227288 = -60						; size = 4
_iDY$ = -24						; size = 4
_iDX$ = -20						; size = 4
_iWrappedDX$ = -16					; size = 4
_iHX1$ = -12						; size = 4
_iHX2$ = -8						; size = 4
_iWrappedDY$ = -4					; size = 4
_iX1$ = 8						; size = 4
_iY1$ = 12						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?plotDistance@@YAHHHHH@Z PROC				; plotDistance, COMDAT

; 144  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH

; 145  : 	int iDX;
; 146  : 	int iWrappedDX = dxWrap(iX2 - iX1);

	mov	eax, DWORD PTR _iX2$[ebp]
	sub	eax, DWORD PTR _iX1$[ebp]
	push	eax
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedDX$[ebp], eax

; 147  : 	int iWrappedDY = dyWrap(iY2 - iY1);

	mov	ecx, DWORD PTR _iY2$[ebp]
	sub	ecx, DWORD PTR _iY1$[ebp]
	push	ecx
	call	?dyWrap@@YAHH@Z				; dyWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedDY$[ebp], eax

; 148  : 	int iDY = abs(iWrappedDY);

	mov	eax, DWORD PTR _iWrappedDY$[ebp]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDY$[ebp], eax

; 149  : 
; 150  : 	// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 151  : 	int iHX1 = xToHexspaceX(iX1, iY1);

	cmp	DWORD PTR _iY1$[ebp], 0
	jl	SHORT $LN35@plotDistan
	mov	edx, DWORD PTR _iY1$[ebp]
	sar	edx, 1
	mov	DWORD PTR tv135[ebp], edx
	jmp	SHORT $LN33@plotDistan
$LN35@plotDistan:
	mov	eax, DWORD PTR _iY1$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv135[ebp], eax
$LN33@plotDistan:
	mov	eax, DWORD PTR _iX1$[ebp]
	sub	eax, DWORD PTR tv135[ebp]
	mov	DWORD PTR _iHX1$[ebp], eax

; 152  : 	int iHX2 = xToHexspaceX(iX1 + iWrappedDX, iY1 + iWrappedDY);

	mov	ecx, DWORD PTR _iY1$[ebp]
	add	ecx, DWORD PTR _iWrappedDY$[ebp]
	mov	DWORD PTR $T227288[ebp], ecx
	js	SHORT $LN39@plotDistan
	mov	edx, DWORD PTR $T227288[ebp]
	sar	edx, 1
	mov	DWORD PTR tv138[ebp], edx
	jmp	SHORT $LN37@plotDistan
$LN39@plotDistan:
	mov	eax, DWORD PTR $T227288[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv138[ebp], eax
$LN37@plotDistan:
	mov	eax, DWORD PTR _iX1$[ebp]
	add	eax, DWORD PTR _iWrappedDX$[ebp]
	sub	eax, DWORD PTR tv138[ebp]
	mov	DWORD PTR _iHX2$[ebp], eax

; 153  : 
; 154  : 	iDX = abs(dxWrap(iHX2 - iHX1));

	mov	ecx, DWORD PTR _iHX2$[ebp]
	sub	ecx, DWORD PTR _iHX1$[ebp]
	push	ecx
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDX$[ebp], eax

; 155  : 
; 156  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 157  : 	if (((iHX2 - iHX1) ^ (iWrappedDY)) >= 0)  // the signs match
; 158  : #else
; 159  : 	if((iHX2 - iHX1 >= 0) == (iWrappedDY >= 0))  // the signs match

	mov	edx, DWORD PTR _iHX2$[ebp]
	sub	edx, DWORD PTR _iHX1$[ebp]
	xor	eax, eax
	test	edx, edx
	setge	al
	xor	ecx, ecx
	cmp	DWORD PTR _iWrappedDY$[ebp], 0
	setge	cl
	cmp	eax, ecx
	jne	SHORT $LN2@plotDistan

; 160  : #endif
; 161  : 	{
; 162  : 		return iDX + iDY;

	mov	eax, DWORD PTR _iDX$[ebp]
	add	eax, DWORD PTR _iDY$[ebp]
	jmp	SHORT $LN3@plotDistan

; 163  : 	}
; 164  : 	else

	jmp	SHORT $LN3@plotDistan
$LN2@plotDistan:

; 165  : 	{
; 166  : #ifdef NQM_FAST_COMP
; 167  : 		return (MAX(iDX, iDY));
; 168  : #else
; 169  : 		return (std::max(iDX, iDY));

	mov	edx, DWORD PTR _iDX$[ebp]
	cmp	edx, DWORD PTR _iDY$[ebp]
	jge	SHORT $LN57@plotDistan
	lea	eax, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv157[ebp], eax
	jmp	SHORT $LN58@plotDistan
$LN57@plotDistan:
	lea	ecx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv157[ebp], ecx
$LN58@plotDistan:
	mov	edx, DWORD PTR tv157[ebp]
	mov	DWORD PTR $T227315[ebp], edx
	mov	eax, DWORD PTR $T227315[ebp]
	mov	eax, DWORD PTR [eax]
$LN3@plotDistan:

; 170  : #endif
; 171  : 	}
; 172  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotDistance@@YAHHHHH@Z ENDP				; plotDistance
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
$T227338 = -16						; size = 4
$T227330 = -12						; size = 4
$T227326 = -5						; size = 1
_kMap$ = -4						; size = 4
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T227326[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T227330[ebp], ecx
	movzx	edx, BYTE PTR $T227326[ebp]
	test	edx, edx
	je	SHORT $LN12@dxWrap
	mov	eax, DWORD PTR $T227330[ebp]
	shr	eax, 1
	cmp	DWORD PTR _iDX$[ebp], eax
	jle	SHORT $LN11@dxWrap
	mov	ecx, DWORD PTR _iDX$[ebp]
	sub	ecx, DWORD PTR $T227330[ebp]
	mov	DWORD PTR $T227338[ebp], ecx
	jmp	SHORT $LN13@dxWrap
	jmp	SHORT $LN12@dxWrap
$LN11@dxWrap:
	mov	edx, DWORD PTR $T227330[ebp]
	shr	edx, 1
	neg	edx
	cmp	DWORD PTR _iDX$[ebp], edx
	jge	SHORT $LN12@dxWrap
	mov	eax, DWORD PTR _iDX$[ebp]
	add	eax, DWORD PTR $T227330[ebp]
	mov	DWORD PTR $T227338[ebp], eax
	jmp	SHORT $LN13@dxWrap
$LN12@dxWrap:
	mov	ecx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR $T227338[ebp], ecx
$LN13@dxWrap:
	mov	eax, DWORD PTR $T227338[ebp]

; 76   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
$T227359 = -16						; size = 4
$T227351 = -12						; size = 4
$T227347 = -5						; size = 1
_kMap$ = -4						; size = 4
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 79   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T227347[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T227351[ebp], ecx
	movzx	edx, BYTE PTR $T227347[ebp]
	test	edx, edx
	je	SHORT $LN12@dyWrap
	mov	eax, DWORD PTR $T227351[ebp]
	shr	eax, 1
	cmp	DWORD PTR _iDY$[ebp], eax
	jle	SHORT $LN11@dyWrap
	mov	ecx, DWORD PTR _iDY$[ebp]
	sub	ecx, DWORD PTR $T227351[ebp]
	mov	DWORD PTR $T227359[ebp], ecx
	jmp	SHORT $LN13@dyWrap
	jmp	SHORT $LN12@dyWrap
$LN11@dyWrap:
	mov	edx, DWORD PTR $T227351[ebp]
	shr	edx, 1
	neg	edx
	cmp	DWORD PTR _iDY$[ebp], edx
	jge	SHORT $LN12@dyWrap
	mov	eax, DWORD PTR _iDY$[ebp]
	add	eax, DWORD PTR $T227351[ebp]
	mov	DWORD PTR $T227359[ebp], eax
	jmp	SHORT $LN13@dyWrap
$LN12@dyWrap:
	mov	ecx, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR $T227359[ebp], ecx
$LN13@dyWrap:
	mov	eax, DWORD PTR $T227359[ebp]

; 82   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
_TEXT	ENDS
PUBLIC	?IsResearch@CvPlayerTechs@@QBE_NXZ		; CvPlayerTechs::IsResearch
EXTRN	?isFoundedFirstCity@CvPlayer@@QBE_NXZ:PROC	; CvPlayer::isFoundedFirstCity
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtechclasses.cpp
;	COMDAT ?IsResearch@CvPlayerTechs@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsResearch@CvPlayerTechs@@QBE_NXZ PROC			; CvPlayerTechs::IsResearch, COMDAT
; _this$ = ecx

; 1132 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1133 : #ifdef AUI_PLAYERTECH_FIX_CAN_RESEARCH_WITH_NO_FOUNDED_CITY
; 1134 : 	return (m_pPlayer->getNumCities() > 0);
; 1135 : #else
; 1136 : 	// Have we founded a city?
; 1137 : 	if(!m_pPlayer->isFoundedFirstCity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	call	?isFoundedFirstCity@CvPlayer@@QBE_NXZ	; CvPlayer::isFoundedFirstCity
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@IsResearch

; 1138 : 	{
; 1139 : 		return false;

	xor	al, al
	jmp	SHORT $LN2@IsResearch
$LN1@IsResearch:

; 1140 : 	}
; 1141 : 
; 1142 : 	return true;

	mov	al, 1
$LN2@IsResearch:

; 1143 : #endif
; 1144 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsResearch@CvPlayerTechs@@QBE_NXZ ENDP			; CvPlayerTechs::IsResearch
_TEXT	ENDS
PUBLIC	??_C@_0BG@PPACBMFL@PlayerCanEverResearch?$AA@	; `string'
PUBLIC	?CanEverResearch@CvPlayerTechs@@QBE_NW4TechTypes@@@Z ; CvPlayerTechs::CanEverResearch
EXTRN	??1CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::~CvLuaArgsHandle
EXTRN	?CallTestAll@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z:PROC ; LuaSupport::CallTestAll
EXTRN	??0CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::CvLuaArgsHandle
EXTRN	?isCivilizationDisableTechs@CvCivilizationInfo@@QBE_NH@Z:PROC ; CvCivilizationInfo::isCivilizationDisableTechs
EXTRN	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ:PROC ; CvPlayer::getCivilizationInfo
EXTRN	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z:PROC ; CvGlobals::getTechInfo
;	COMDAT ??_C@_0BG@PPACBMFL@PlayerCanEverResearch?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaargshandle.h
CONST	SEGMENT
??_C@_0BG@PPACBMFL@PlayerCanEverResearch?$AA@ DB 'PlayerCanEverResearch', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?CanEverResearch@CvPlayerTechs@@QBE_NW4TechTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CanEverResearch@CvPlayerTechs@@QBE_NW4TechTypes@@@Z$0
__ehfuncinfo$?CanEverResearch@CvPlayerTechs@@QBE_NW4TechTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CanEverResearch@CvPlayerTechs@@QBE_NW4TechTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtechclasses.cpp
xdata$x	ENDS
;	COMDAT ?CanEverResearch@CvPlayerTechs@@QBE_NW4TechTypes@@@Z
_TEXT	SEGMENT
tv140 = -56						; size = 4
tv130 = -52						; size = 4
tv87 = -48						; size = 4
_this$ = -44						; size = 4
$T227388 = -40						; size = 4
$T227381 = -36						; size = 4
$T227369 = -32						; size = 4
$T227364 = -26						; size = 1
_bResult$223755 = -25					; size = 1
_args$223754 = -24					; size = 4
_pkTechInfo$ = -20					; size = 4
_pkScriptSystem$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_eTech$ = 8						; size = 4
?CanEverResearch@CvPlayerTechs@@QBE_NW4TechTypes@@@Z PROC ; CvPlayerTechs::CanEverResearch, COMDAT
; _this$ = ecx

; 1148 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CanEverResearch@CvPlayerTechs@@QBE_NW4TechTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1149 : 	CvTechEntry* pkTechInfo = GC.getTechInfo(eTech);

	mov	eax, DWORD PTR _eTech$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo
	mov	DWORD PTR _pkTechInfo$[ebp], eax

; 1150 : 	if(pkTechInfo == NULL)

	cmp	DWORD PTR _pkTechInfo$[ebp], 0
	jne	SHORT $LN6@CanEverRes

; 1151 : 	{
; 1152 : 		return false;

	xor	al, al
	jmp	$LN7@CanEverRes
$LN6@CanEverRes:

; 1153 : 	}
; 1154 : 
; 1155 : 	if(pkTechInfo->IsDisable())

	mov	ecx, DWORD PTR _pkTechInfo$[ebp]
	call	?IsDisable@CvTechEntry@@QBE_NXZ		; CvTechEntry::IsDisable
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@CanEverRes

; 1156 : 	{
; 1157 : 		return false;

	xor	al, al
	jmp	$LN7@CanEverRes
$LN5@CanEverRes:

; 1158 : 	}
; 1159 : 
; 1160 : 	if(m_pPlayer->getCivilizationInfo().isCivilizationDisableTechs(eTech))

	mov	edx, DWORD PTR _eTech$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?isCivilizationDisableTechs@CvCivilizationInfo@@QBE_NH@Z ; CvCivilizationInfo::isCivilizationDisableTechs
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@CanEverRes

; 1161 : 	{
; 1162 : 		return false;

	xor	al, al
	jmp	$LN7@CanEverRes
$LN4@CanEverRes:

; 1163 : 	}
; 1164 : 
; 1165 : 	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	edx, DWORD PTR $T227369[ebp]
	mov	DWORD PTR tv87[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv87[ebp], eax
	mov	ecx, DWORD PTR tv87[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv87[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pkScriptSystem$[ebp], eax

; 1166 : 	if(pkScriptSystem)

	cmp	DWORD PTR _pkScriptSystem$[ebp], 0
	je	$LN3@CanEverRes

; 1167 : 	{
; 1168 : 		CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$223754[ebp]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1169 : 		args->Push(m_pPlayer->GetID());

	mov	ecx, DWORD PTR _args$223754[ebp]
	mov	DWORD PTR tv130[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T227381[ebp], ecx
	mov	edx, DWORD PTR $T227381[ebp]
	push	edx
	mov	eax, DWORD PTR tv130[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv130[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 1170 : 		args->Push(eTech);

	mov	ecx, DWORD PTR _args$223754[ebp]
	mov	DWORD PTR tv140[ebp], ecx
	mov	edx, DWORD PTR _eTech$[ebp]
	push	edx
	mov	eax, DWORD PTR tv140[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv140[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 1171 : 
; 1172 : 		// Attempt to execute the game events.
; 1173 : 		// Will return false if there are no registered listeners.
; 1174 : 		bool bResult = false;

	mov	BYTE PTR _bResult$223755[ebp], 0

; 1175 : 		if(LuaSupport::CallTestAll(pkScriptSystem, "PlayerCanEverResearch", args.get(), bResult))

	mov	ecx, DWORD PTR _args$223754[ebp]
	mov	DWORD PTR $T227388[ebp], ecx
	lea	edx, DWORD PTR _bResult$223755[ebp]
	push	edx
	mov	eax, DWORD PTR $T227388[ebp]
	push	eax
	push	OFFSET ??_C@_0BG@PPACBMFL@PlayerCanEverResearch?$AA@
	mov	ecx, DWORD PTR _pkScriptSystem$[ebp]
	push	ecx
	call	?CallTestAll@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallTestAll
	add	esp, 16					; 00000010H
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@CanEverRes

; 1176 : 		{
; 1177 : 			// Check the result.
; 1178 : 			if(bResult == false)

	movzx	eax, BYTE PTR _bResult$223755[ebp]
	test	eax, eax
	jne	SHORT $LN2@CanEverRes

; 1179 : 			{
; 1180 : 				return false;

	mov	BYTE PTR $T227364[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _args$223754[ebp]
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
	mov	al, BYTE PTR $T227364[ebp]
	jmp	SHORT $LN7@CanEverRes
$LN2@CanEverRes:

; 1181 : 			}
; 1182 : 		}
; 1183 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _args$223754[ebp]
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN3@CanEverRes:

; 1184 : 
; 1185 : 
; 1186 : 	return true;

	mov	al, 1
$LN7@CanEverRes:

; 1187 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CanEverResearch@CvPlayerTechs@@QBE_NW4TechTypes@@@Z$0:
	lea	ecx, DWORD PTR _args$223754[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__ehhandler$?CanEverResearch@CvPlayerTechs@@QBE_NW4TechTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?CanEverResearch@CvPlayerTechs@@QBE_NW4TechTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CanEverResearch@CvPlayerTechs@@QBE_NW4TechTypes@@@Z ENDP ; CvPlayerTechs::CanEverResearch
PUBLIC	??_C@_0BC@FKIPDLM@PlayerCanResearch?$AA@	; `string'
PUBLIC	?IsNoTradeTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::IsNoTradeTech
PUBLIC	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z	; CvTeamTechs::HasTech
PUBLIC	?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z ; CvPlayerTechs::CanResearch
EXTRN	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ:PROC ; CvTeam::GetTeamTechs
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
EXTRN	?getAdvancedStartPoints@CvPlayer@@QBEHXZ:PROC	; CvPlayer::getAdvancedStartPoints
;	COMDAT ??_C@_0BC@FKIPDLM@PlayerCanResearch?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaargshandle.h
CONST	SEGMENT
??_C@_0BC@FKIPDLM@PlayerCanResearch?$AA@ DB 'PlayerCanResearch', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z$0
__ehfuncinfo$?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtechclasses.cpp
xdata$x	ENDS
;	COMDAT ?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z
_TEXT	SEGMENT
tv225 = -144						; size = 4
tv215 = -140						; size = 4
tv204 = -136						; size = 4
_this$ = -132						; size = 4
$T227499 = -128						; size = 4
$T227492 = -124						; size = 4
$T227480 = -120						; size = 4
$T227476 = -116						; size = 4
$T227472 = -112						; size = 4
$T227471 = -108						; size = 4
$T227462 = -104						; size = 4
$T227458 = -100						; size = 4
$T227457 = -96						; size = 4
$T227448 = -92						; size = 4
$T227444 = -88						; size = 4
$T227440 = -84						; size = 4
$T227439 = -80						; size = 4
$T227430 = -76						; size = 4
$T227426 = -72						; size = 4
$T227425 = -68						; size = 4
$T227416 = -64						; size = 4
$T227412 = -60						; size = 4
$T227408 = -56						; size = 4
$T227407 = -52						; size = 4
$T227397 = -46						; size = 1
_bResult$223794 = -45					; size = 1
_args$223793 = -44					; size = 4
_ePrereq$223785 = -40					; size = 4
_ePrereq$223775 = -36					; size = 4
_bFoundValid$ = -29					; size = 1
_iI$ = -28						; size = 4
_bFoundPossible$ = -21					; size = 1
_pkScriptSystem$ = -20					; size = 4
_pkTechEntry$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_eTech$ = 8						; size = 4
_bTrade$ = 12						; size = 1
?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z PROC	; CvPlayerTechs::CanResearch, COMDAT
; _this$ = ecx

; 1191 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 132				; 00000084H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1192 : 	bool bFoundPossible;
; 1193 : 	bool bFoundValid;
; 1194 : 	int iI;
; 1195 : 
; 1196 : 	CvTechEntry* pkTechEntry = GC.getTechInfo(eTech);

	mov	eax, DWORD PTR _eTech$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo
	mov	DWORD PTR _pkTechEntry$[ebp], eax

; 1197 : 	if(pkTechEntry == NULL)

	cmp	DWORD PTR _pkTechEntry$[ebp], 0
	jne	SHORT $LN21@CanResearc

; 1198 : 		return false;

	xor	al, al
	jmp	$LN22@CanResearc
$LN21@CanResearc:

; 1199 : 
; 1200 : 	if(!IsResearch() && m_pPlayer->getAdvancedStartPoints() < 0)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsResearch@CvPlayerTechs@@QBE_NXZ	; CvPlayerTechs::IsResearch
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN20@CanResearc
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+44]
	call	?getAdvancedStartPoints@CvPlayer@@QBEHXZ ; CvPlayer::getAdvancedStartPoints
	test	eax, eax
	jge	SHORT $LN20@CanResearc

; 1201 : 	{
; 1202 : 		return false;

	xor	al, al
	jmp	$LN22@CanResearc
$LN20@CanResearc:

; 1203 : 	}
; 1204 : 
; 1205 : 	// Do we already have this tech?
; 1206 : 	if(GET_TEAM(m_pPlayer->getTeam()).GetTeamTechs()->HasTech(eTech))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T227407[ebp], ecx
	mov	edx, DWORD PTR $T227407[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T227408[ebp], eax
	mov	ecx, DWORD PTR $T227408[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T227412[ebp], ecx
	mov	edx, DWORD PTR _eTech$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T227412[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN19@CanResearc

; 1207 : 	{
; 1208 : 		return false;

	xor	al, al
	jmp	$LN22@CanResearc
$LN19@CanResearc:

; 1209 : 	}
; 1210 : 
; 1211 : 	bFoundPossible = false;

	mov	BYTE PTR _bFoundPossible$[ebp], 0

; 1212 : 	bFoundValid = false;

	mov	BYTE PTR _bFoundValid$[ebp], 0

; 1213 : 
; 1214 : 	// See if it is possible based on OR prereqs
; 1215 : 	for(iI = 0; iI < GC.getNUM_OR_TECH_PREREQS(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN18@CanResearc
$LN17@CanResearc:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN18@CanResearc:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6268
	mov	DWORD PTR $T227416[ebp], edx
	mov	eax, DWORD PTR _iI$[ebp]
	cmp	eax, DWORD PTR $T227416[ebp]
	jge	$LN16@CanResearc

; 1216 : 	{
; 1217 : 		TechTypes ePrereq = (TechTypes)pkTechEntry->GetPrereqOrTechs(iI);

	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkTechEntry$[ebp]
	call	?GetPrereqOrTechs@CvTechEntry@@QBEHH@Z	; CvTechEntry::GetPrereqOrTechs
	mov	DWORD PTR _ePrereq$223775[ebp], eax

; 1218 : 		if(ePrereq != NO_TECH)

	cmp	DWORD PTR _ePrereq$223775[ebp], -1
	je	$LN15@CanResearc

; 1219 : 		{
; 1220 : 			bFoundPossible = true;

	mov	BYTE PTR _bFoundPossible$[ebp], 1

; 1221 : 
; 1222 : 			if(GET_TEAM(m_pPlayer->getTeam()).GetTeamTechs()->HasTech(ePrereq))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T227425[ebp], eax
	mov	ecx, DWORD PTR $T227425[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T227426[ebp], eax
	mov	eax, DWORD PTR $T227426[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T227430[ebp], eax
	mov	ecx, DWORD PTR _ePrereq$223775[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T227430[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN15@CanResearc

; 1223 : 			{
; 1224 : 				if(!bTrade || !GET_TEAM(m_pPlayer->getTeam()).GetTeamTechs()->IsNoTradeTech(ePrereq))

	movzx	eax, BYTE PTR _bTrade$[ebp]
	test	eax, eax
	je	SHORT $LN12@CanResearc
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T227439[ebp], edx
	mov	eax, DWORD PTR $T227439[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T227440[ebp], eax
	mov	edx, DWORD PTR $T227440[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T227444[ebp], edx
	mov	eax, DWORD PTR _ePrereq$223775[ebp]
	push	eax
	mov	ecx, DWORD PTR $T227444[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?IsNoTradeTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::IsNoTradeTech
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN15@CanResearc
$LN12@CanResearc:

; 1225 : 				{
; 1226 : 					bFoundValid = true;

	mov	BYTE PTR _bFoundValid$[ebp], 1

; 1227 : 					break;

	jmp	SHORT $LN16@CanResearc
$LN15@CanResearc:

; 1228 : 				}
; 1229 : 			}
; 1230 : 		}
; 1231 : 	}

	jmp	$LN17@CanResearc
$LN16@CanResearc:

; 1232 : 
; 1233 : 	if(bFoundPossible && !bFoundValid)

	movzx	edx, BYTE PTR _bFoundPossible$[ebp]
	test	edx, edx
	je	SHORT $LN11@CanResearc
	movzx	eax, BYTE PTR _bFoundValid$[ebp]
	test	eax, eax
	jne	SHORT $LN11@CanResearc

; 1234 : 	{
; 1235 : 		return false;

	xor	al, al
	jmp	$LN22@CanResearc
$LN11@CanResearc:

; 1236 : 	}
; 1237 : 
; 1238 : 	// See if it is possible based on AND prereqs
; 1239 : 	for(iI = 0; iI < GC.getNUM_AND_TECH_PREREQS(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN10@CanResearc
$LN9@CanResearc:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN10@CanResearc:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6272
	mov	DWORD PTR $T227448[ebp], edx
	mov	eax, DWORD PTR _iI$[ebp]
	cmp	eax, DWORD PTR $T227448[ebp]
	jge	$LN8@CanResearc

; 1240 : 	{
; 1241 : 		TechTypes ePrereq = (TechTypes)pkTechEntry->GetPrereqAndTechs(iI);

	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkTechEntry$[ebp]
	call	?GetPrereqAndTechs@CvTechEntry@@QBEHH@Z	; CvTechEntry::GetPrereqAndTechs
	mov	DWORD PTR _ePrereq$223785[ebp], eax

; 1242 : 		if(ePrereq != NO_TECH)

	cmp	DWORD PTR _ePrereq$223785[ebp], -1
	je	$LN7@CanResearc

; 1243 : 		{
; 1244 : 			if(!GET_TEAM(m_pPlayer->getTeam()).GetTeamTechs()->HasTech(ePrereq))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T227457[ebp], eax
	mov	ecx, DWORD PTR $T227457[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T227458[ebp], eax
	mov	eax, DWORD PTR $T227458[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T227462[ebp], eax
	mov	ecx, DWORD PTR _ePrereq$223785[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T227462[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN6@CanResearc

; 1245 : 			{
; 1246 : 				return false;

	xor	al, al
	jmp	$LN22@CanResearc
$LN6@CanResearc:

; 1247 : 			}
; 1248 : 
; 1249 : 			if(bTrade && GET_TEAM(m_pPlayer->getTeam()).GetTeamTechs()->IsNoTradeTech(ePrereq))

	movzx	eax, BYTE PTR _bTrade$[ebp]
	test	eax, eax
	je	SHORT $LN7@CanResearc
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T227471[ebp], edx
	mov	eax, DWORD PTR $T227471[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T227472[ebp], eax
	mov	edx, DWORD PTR $T227472[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T227476[ebp], edx
	mov	eax, DWORD PTR _ePrereq$223785[ebp]
	push	eax
	mov	ecx, DWORD PTR $T227476[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?IsNoTradeTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::IsNoTradeTech
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN7@CanResearc

; 1250 : 			{
; 1251 : 				return false;

	xor	al, al
	jmp	$LN22@CanResearc
$LN7@CanResearc:

; 1252 : 			}
; 1253 : 		}
; 1254 : 	}

	jmp	$LN9@CanResearc
$LN8@CanResearc:

; 1255 : 
; 1256 : 	// Is it disabled for some reason?
; 1257 : 	if(!CanEverResearch(eTech))

	mov	edx, DWORD PTR _eTech$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CanEverResearch@CvPlayerTechs@@QBE_NW4TechTypes@@@Z ; CvPlayerTechs::CanEverResearch
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@CanResearc

; 1258 : 	{
; 1259 : 		return false;

	xor	al, al
	jmp	$LN22@CanResearc
$LN4@CanResearc:

; 1260 : 	}
; 1261 : 
; 1262 : 	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR $T227480[ebp]
	mov	DWORD PTR tv204[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv204[ebp], edx
	mov	eax, DWORD PTR tv204[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv204[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pkScriptSystem$[ebp], eax

; 1263 : 	if(pkScriptSystem)

	cmp	DWORD PTR _pkScriptSystem$[ebp], 0
	je	$LN3@CanResearc

; 1264 : 	{
; 1265 : 		CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$223793[ebp]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1266 : 		args->Push(m_pPlayer->GetID());

	mov	ecx, DWORD PTR _args$223793[ebp]
	mov	DWORD PTR tv215[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T227492[ebp], ecx
	mov	edx, DWORD PTR $T227492[ebp]
	push	edx
	mov	eax, DWORD PTR tv215[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv215[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 1267 : 		args->Push(eTech);

	mov	ecx, DWORD PTR _args$223793[ebp]
	mov	DWORD PTR tv225[ebp], ecx
	mov	edx, DWORD PTR _eTech$[ebp]
	push	edx
	mov	eax, DWORD PTR tv225[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv225[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 1268 : 
; 1269 : 		// Attempt to execute the game events.
; 1270 : 		// Will return false if there are no registered listeners.
; 1271 : 		bool bResult = false;

	mov	BYTE PTR _bResult$223794[ebp], 0

; 1272 : 		if(LuaSupport::CallTestAll(pkScriptSystem, "PlayerCanResearch", args.get(), bResult))

	mov	ecx, DWORD PTR _args$223793[ebp]
	mov	DWORD PTR $T227499[ebp], ecx
	lea	edx, DWORD PTR _bResult$223794[ebp]
	push	edx
	mov	eax, DWORD PTR $T227499[ebp]
	push	eax
	push	OFFSET ??_C@_0BC@FKIPDLM@PlayerCanResearch?$AA@
	mov	ecx, DWORD PTR _pkScriptSystem$[ebp]
	push	ecx
	call	?CallTestAll@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallTestAll
	add	esp, 16					; 00000010H
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@CanResearc

; 1273 : 		{
; 1274 : 			// Check the result.
; 1275 : 			if(bResult == false)

	movzx	eax, BYTE PTR _bResult$223794[ebp]
	test	eax, eax
	jne	SHORT $LN2@CanResearc

; 1276 : 			{
; 1277 : 				return false;

	mov	BYTE PTR $T227397[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _args$223793[ebp]
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
	mov	al, BYTE PTR $T227397[ebp]
	jmp	SHORT $LN22@CanResearc
$LN2@CanResearc:

; 1278 : 			}
; 1279 : 		}
; 1280 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _args$223793[ebp]
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN3@CanResearc:

; 1281 : 
; 1282 : 	return true;

	mov	al, 1
$LN22@CanResearc:

; 1283 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z$0:
	lea	ecx, DWORD PTR _args$223793[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__ehhandler$?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-136]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z ENDP	; CvPlayerTechs::CanResearch
PUBLIC	?CanResearchForFree@CvPlayerTechs@@QBE_NW4TechTypes@@@Z ; CvPlayerTechs::CanResearchForFree
EXTRN	?getNumTechInfos@CvGlobals@@QAEHXZ:PROC		; CvGlobals::getNumTechInfos
; Function compile flags: /Odtp
;	COMDAT ?CanResearchForFree@CvPlayerTechs@@QBE_NW4TechTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eTech$ = 8						; size = 4
?CanResearchForFree@CvPlayerTechs@@QBE_NW4TechTypes@@@Z PROC ; CvPlayerTechs::CanResearchForFree, COMDAT
; _this$ = ecx

; 1287 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1288 : #ifdef AUI_WARNING_FIXES
; 1289 : 	CvAssertMsg(uint(eTech) < GC.getNumTechInfos(), "eTech is expected to be within maximum bounds (invalid Index)");
; 1290 : 	if (uint(eTech) >= GC.getNumTechInfos()) return false;
; 1291 : #else
; 1292 : 	CvAssertMsg(eTech >= 0, "eTech is expected to be non-negative (invalid Index)");
; 1293 : 	CvAssertMsg(eTech < GC.getNumTechInfos(), "eTech is expected to be within maximum bounds (invalid Index)");
; 1294 : 	if(eTech < 0 || eTech >= GC.getNumTechInfos()) return false;

	cmp	DWORD PTR _eTech$[ebp], 0
	jl	SHORT $LN1@CanResearc@2
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	cmp	DWORD PTR _eTech$[ebp], eax
	jl	SHORT $LN2@CanResearc@2
$LN1@CanResearc@2:
	xor	al, al
	jmp	SHORT $LN3@CanResearc@2
$LN2@CanResearc@2:

; 1295 : #endif
; 1296 : 
; 1297 : 	// We can pick any tech that we are able to research
; 1298 : 	return CanResearch(eTech);

	push	0
	mov	eax, DWORD PTR _eTech$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z ; CvPlayerTechs::CanResearch
$LN3@CanResearc@2:

; 1299 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?CanResearchForFree@CvPlayerTechs@@QBE_NW4TechTypes@@@Z ENDP ; CvPlayerTechs::CanResearchForFree
_TEXT	ENDS
PUBLIC	?GetCurrentResearch@CvPlayerTechs@@QBE?AW4TechTypes@@XZ ; CvPlayerTechs::GetCurrentResearch
EXTRN	?headResearchQueueNode@CvPlayer@@QAEPAV?$CLLNode@W4TechTypes@@@@XZ:PROC ; CvPlayer::headResearchQueueNode
; Function compile flags: /Odtp
;	COMDAT ?GetCurrentResearch@CvPlayerTechs@@QBE?AW4TechTypes@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pResearchNode$ = -4					; size = 4
?GetCurrentResearch@CvPlayerTechs@@QBE?AW4TechTypes@@XZ PROC ; CvPlayerTechs::GetCurrentResearch, COMDAT
; _this$ = ecx

; 1303 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1304 : 	CLLNode<TechTypes>* pResearchNode;
; 1305 : 
; 1306 : 	pResearchNode = m_pPlayer->headResearchQueueNode();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	call	?headResearchQueueNode@CvPlayer@@QAEPAV?$CLLNode@W4TechTypes@@@@XZ ; CvPlayer::headResearchQueueNode
	mov	DWORD PTR _pResearchNode$[ebp], eax

; 1307 : 
; 1308 : 	if(pResearchNode != NULL)

	cmp	DWORD PTR _pResearchNode$[ebp], 0
	je	SHORT $LN2@GetCurrent

; 1309 : 	{
; 1310 : 		return pResearchNode->m_data;

	mov	ecx, DWORD PTR _pResearchNode$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	jmp	SHORT $LN3@GetCurrent

; 1311 : 	}
; 1312 : 	else

	jmp	SHORT $LN3@GetCurrent
$LN2@GetCurrent:

; 1313 : 	{
; 1314 : 		return NO_TECH;

	or	eax, -1
$LN3@GetCurrent:

; 1315 : 	}
; 1316 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCurrentResearch@CvPlayerTechs@@QBE?AW4TechTypes@@XZ ENDP ; CvPlayerTechs::GetCurrentResearch
_TEXT	ENDS
PUBLIC	?IsCurrentResearchRepeat@CvPlayerTechs@@QBE_NXZ	; CvPlayerTechs::IsCurrentResearchRepeat
; Function compile flags: /Odtp
;	COMDAT ?IsCurrentResearchRepeat@CvPlayerTechs@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_pkTechInfo$ = -8					; size = 4
_eCurrentResearch$ = -4					; size = 4
?IsCurrentResearchRepeat@CvPlayerTechs@@QBE_NXZ PROC	; CvPlayerTechs::IsCurrentResearchRepeat, COMDAT
; _this$ = ecx

; 1320 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1321 : 	const TechTypes eCurrentResearch = GetCurrentResearch();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCurrentResearch@CvPlayerTechs@@QBE?AW4TechTypes@@XZ ; CvPlayerTechs::GetCurrentResearch
	mov	DWORD PTR _eCurrentResearch$[ebp], eax

; 1322 : 	if(eCurrentResearch == NO_TECH)

	cmp	DWORD PTR _eCurrentResearch$[ebp], -1
	jne	SHORT $LN2@IsCurrentR

; 1323 : 	{
; 1324 : 		return false;

	xor	al, al
	jmp	SHORT $LN3@IsCurrentR
$LN2@IsCurrentR:

; 1325 : 	}
; 1326 : 
; 1327 : 	CvTechEntry* pkTechInfo = GC.getTechInfo(eCurrentResearch);

	mov	eax, DWORD PTR _eCurrentResearch$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo
	mov	DWORD PTR _pkTechInfo$[ebp], eax

; 1328 : 	if(pkTechInfo == NULL)

	cmp	DWORD PTR _pkTechInfo$[ebp], 0
	jne	SHORT $LN1@IsCurrentR

; 1329 : 	{
; 1330 : 		return false;

	xor	al, al
	jmp	SHORT $LN3@IsCurrentR
$LN1@IsCurrentR:

; 1331 : 	}
; 1332 : 
; 1333 : 	return pkTechInfo->IsRepeat();

	mov	ecx, DWORD PTR _pkTechInfo$[ebp]
	call	?IsRepeat@CvTechEntry@@QBE_NXZ		; CvTechEntry::IsRepeat
$LN3@IsCurrentR:

; 1334 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsCurrentResearchRepeat@CvPlayerTechs@@QBE_NXZ ENDP	; CvPlayerTechs::IsCurrentResearchRepeat
_TEXT	ENDS
PUBLIC	?IsNoResearchAvailable@CvPlayerTechs@@QBE_NXZ	; CvPlayerTechs::IsNoResearchAvailable
; Function compile flags: /Odtp
;	COMDAT ?IsNoResearchAvailable@CvPlayerTechs@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_iI$ = -4						; size = 4
?IsNoResearchAvailable@CvPlayerTechs@@QBE_NXZ PROC	; CvPlayerTechs::IsNoResearchAvailable, COMDAT
; _this$ = ecx

; 1338 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1339 : #ifdef AUI_WARNING_FIXES
; 1340 : 	uint iI;
; 1341 : #else
; 1342 : 	int iI;
; 1343 : #endif
; 1344 : 
; 1345 : 	if(GetCurrentResearch() != NO_TECH)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCurrentResearch@CvPlayerTechs@@QBE?AW4TechTypes@@XZ ; CvPlayerTechs::GetCurrentResearch
	cmp	eax, -1
	je	SHORT $LN5@IsNoResear

; 1346 : 	{
; 1347 : 		return false;

	xor	al, al
	jmp	SHORT $LN6@IsNoResear
$LN5@IsNoResear:

; 1348 : 	}
; 1349 : 
; 1350 : 	for(iI = 0; iI < GC.getNumTechInfos(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN4@IsNoResear
$LN3@IsNoResear:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN4@IsNoResear:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	cmp	DWORD PTR _iI$[ebp], eax
	jge	SHORT $LN2@IsNoResear

; 1351 : 	{
; 1352 : 		if(CanResearch((TechTypes)iI))

	push	0
	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z ; CvPlayerTechs::CanResearch
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@IsNoResear

; 1353 : 		{
; 1354 : 			return false;

	xor	al, al
	jmp	SHORT $LN6@IsNoResear
$LN1@IsNoResear:

; 1355 : 		}
; 1356 : 	}

	jmp	SHORT $LN3@IsNoResear
$LN2@IsNoResear:

; 1357 : 	return true;

	mov	al, 1
$LN6@IsNoResear:

; 1358 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsNoResearchAvailable@CvPlayerTechs@@QBE_NXZ ENDP	; CvPlayerTechs::IsNoResearchAvailable
_TEXT	ENDS
PUBLIC	?GetTechCount@CvTeamTechs@@QBEHW4TechTypes@@@Z	; CvTeamTechs::GetTechCount
PUBLIC	??_C@_0BB@MGEFJDB@LEADER_CATHERINE?$AA@		; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?CheckForTechAchievement@CvPlayerTechs@@QBEXXZ	; CvPlayerTechs::CheckForTechAchievement
EXTRN	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ:PROC ; CvPlayer::GetPlayerTechs
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
EXTRN	__imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z:PROC
EXTRN	?getLeaderTypeKey@CvPlayer@@QBEPBDXZ:PROC	; CvPlayer::getLeaderTypeKey
EXTRN	?isGameMultiPlayer@CvGame@@QBE_NXZ:PROC		; CvGame::isGameMultiPlayer
EXTRN	?isHuman@CvPlayer@@QBE_NXZ:PROC			; CvPlayer::isHuman
;	COMDAT ??_C@_0BB@MGEFJDB@LEADER_CATHERINE?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
CONST	SEGMENT
??_C@_0BB@MGEFJDB@LEADER_CATHERINE?$AA@ DB 'LEADER_CATHERINE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?CheckForTechAchievement@CvPlayerTechs@@QBEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CheckForTechAchievement@CvPlayerTechs@@QBEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CheckForTechAchievement@CvPlayerTechs@@QBEXXZ$1
__ehfuncinfo$?CheckForTechAchievement@CvPlayerTechs@@QBEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?CheckForTechAchievement@CvPlayerTechs@@QBEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtechclasses.cpp
xdata$x	ENDS
;	COMDAT ?CheckForTechAchievement@CvPlayerTechs@@QBEXXZ
_TEXT	SEGMENT
tv266 = -208						; size = 4
tv211 = -204						; size = 4
tv304 = -200						; size = 4
tv271 = -196						; size = 4
tv280 = -192						; size = 4
_this$ = -188						; size = 4
$T227628 = -184						; size = 4
$T227624 = -180						; size = 4
$T227620 = -176						; size = 4
$T227619 = -172						; size = 4
$T227610 = -168						; size = 4
$T227606 = -164						; size = 4
$T227605 = -160						; size = 4
$T227592 = -156						; size = 4
$T227588 = -152						; size = 4
$T227584 = -148						; size = 4
$T227575 = -144						; size = 4
$T227571 = -140						; size = 4
$T227567 = -136						; size = 4
$T227563 = -132						; size = 4
$T227559 = -128						; size = 4
$T227558 = -124						; size = 4
$T227541 = -120						; size = 4
$T227533 = -116						; size = 4
$T227524 = -112						; size = 4
$T227518 = -108						; size = 28
$T227517 = -77						; size = 1
_eTech$223868 = -76					; size = 4
_pkTechInfo$223870 = -72				; size = 4
_iI$223864 = -68					; size = 4
_iNumPlayersWith$223853 = -64				; size = 4
_iJ$223852 = -60					; size = 4
_szCurrentTech$223846 = -56				; size = 28
__$ArrayPad$ = -28					; size = 4
_eTech$223842 = -24					; size = 4
_pkTechInfo$223844 = -20				; size = 4
_iI$223838 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?CheckForTechAchievement@CvPlayerTechs@@QBEXXZ PROC	; CvPlayerTechs::CheckForTechAchievement, COMDAT
; _this$ = ecx

; 1363 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CheckForTechAchievement@CvPlayerTechs@@QBEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 196				; 000000c4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1364 : 	if(m_pPlayer->isHuman() && !GC.getGame().isGameMultiPlayer())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	ecx, al
	test	ecx, ecx
	je	$LN22@CheckForTe
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T227524[ebp], edx
	mov	ecx, DWORD PTR $T227524[ebp]
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	movzx	eax, al
	test	eax, eax
	jne	$LN22@CheckForTe

; 1365 : 	{
; 1366 : 		//Check for Catherine Achievement
; 1367 : 		if((CvString)m_pPlayer->getLeaderTypeKey() == "LEADER_CATHERINE")

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+44]
	call	?getLeaderTypeKey@CvPlayer@@QBEPBDXZ	; CvPlayer::getLeaderTypeKey
	mov	DWORD PTR $T227533[ebp], eax
	cmp	DWORD PTR $T227533[ebp], 0
	je	SHORT $LN30@CheckForTe
	mov	edx, DWORD PTR $T227533[ebp]
	mov	DWORD PTR tv280[ebp], edx
	jmp	SHORT $LN31@CheckForTe
$LN30@CheckForTe:
	mov	DWORD PTR tv280[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN31@CheckForTe:
	mov	eax, DWORD PTR tv280[ebp]
	push	eax
	lea	ecx, DWORD PTR $T227518[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T227518[ebp]
	mov	DWORD PTR tv271[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	OFFSET ??_C@_0BB@MGEFJDB@LEADER_CATHERINE?$AA@
	mov	edx, DWORD PTR tv271[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	mov	BYTE PTR $T227517[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T227518[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	movzx	eax, BYTE PTR $T227517[ebp]
	test	eax, eax
	je	$LN20@CheckForTe

; 1368 : 		{
; 1369 : #ifdef AUI_WARNING_FIXES
; 1370 : 			for (uint iI = 0; iI < GC.getNumTechInfos(); iI++)
; 1371 : #else
; 1372 : 			for(int iI = 0; iI < GC.getNumTechInfos(); iI++)

	mov	DWORD PTR _iI$223838[ebp], 0
	jmp	SHORT $LN19@CheckForTe
$LN18@CheckForTe:
	mov	ecx, DWORD PTR _iI$223838[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$223838[ebp], ecx
$LN19@CheckForTe:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	cmp	DWORD PTR _iI$223838[ebp], eax
	jge	$LN20@CheckForTe

; 1373 : #endif
; 1374 : 			{
; 1375 : 				const TechTypes eTech = static_cast<TechTypes>(iI);

	mov	edx, DWORD PTR _iI$223838[ebp]
	mov	DWORD PTR _eTech$223842[ebp], edx

; 1376 : 				CvTechEntry* pkTechInfo = GC.getTechInfo(eTech);

	mov	eax, DWORD PTR _eTech$223842[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo
	mov	DWORD PTR _pkTechInfo$223844[ebp], eax

; 1377 : 				if(pkTechInfo)

	cmp	DWORD PTR _pkTechInfo$223844[ebp], 0
	je	$LN16@CheckForTe

; 1378 : 				{
; 1379 : 					CvString szCurrentTech = (CvString) pkTechInfo->GetType();

	mov	ecx, DWORD PTR _pkTechInfo$223844[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T227541[ebp], eax
	cmp	DWORD PTR $T227541[ebp], 0
	je	SHORT $LN40@CheckForTe
	mov	ecx, DWORD PTR $T227541[ebp]
	mov	DWORD PTR tv304[ebp], ecx
	jmp	SHORT $LN41@CheckForTe
$LN40@CheckForTe:
	mov	DWORD PTR tv304[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN41@CheckForTe:
	mov	edx, DWORD PTR tv304[ebp]
	push	edx
	lea	ecx, DWORD PTR _szCurrentTech$223846[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1380 : 					if(szCurrentTech == "TECH_HORSEBACK_RIDING")

	push	OFFSET ??_C@_0BG@BHCMNEIE@TECH_HORSEBACK_RIDING?$AA@
	lea	eax, DWORD PTR _szCurrentTech$223846[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$LN15@CheckForTe

; 1381 : 					{
; 1382 : 						if(GET_TEAM(m_pPlayer->getTeam()).GetTeamTechs()->HasTech(eTech))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T227558[ebp], eax
	mov	ecx, DWORD PTR $T227558[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T227559[ebp], eax
	mov	eax, DWORD PTR $T227559[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T227563[ebp], eax
	mov	ecx, DWORD PTR _eTech$223842[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T227563[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	edx, al
	test	edx, edx
	je	$LN15@CheckForTe

; 1383 : 						{
; 1384 : 							int iJ;
; 1385 : 							int iNumPlayersWith = 0;

	mov	DWORD PTR _iNumPlayersWith$223853[ebp], 0

; 1386 : 							for(iJ = 0; iJ < MAX_MAJOR_CIVS; iJ++)

	mov	DWORD PTR _iJ$223852[ebp], 0
	jmp	SHORT $LN13@CheckForTe
$LN12@CheckForTe:
	mov	eax, DWORD PTR _iJ$223852[ebp]
	add	eax, 1
	mov	DWORD PTR _iJ$223852[ebp], eax
$LN13@CheckForTe:
	cmp	DWORD PTR _iJ$223852[ebp], 22		; 00000016H
	jge	$LN11@CheckForTe

; 1387 : 							{
; 1388 : 								if(!GET_PLAYER((PlayerTypes)iJ).isBarbarian() && !GET_PLAYER((PlayerTypes)iJ).isMinorCiv())

	mov	ecx, DWORD PTR _iJ$223852[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T227567[ebp], ecx
	mov	ecx, DWORD PTR $T227567[ebp]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	movzx	edx, al
	test	edx, edx
	jne	$LN10@CheckForTe
	mov	eax, DWORD PTR _iJ$223852[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T227571[ebp], eax
	mov	ecx, DWORD PTR $T227571[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN10@CheckForTe

; 1389 : 								{
; 1390 : 									if(GET_TEAM(GET_PLAYER((PlayerTypes)iJ).getTeam()).GetTeamTechs()->HasTech(eTech))

	mov	edx, DWORD PTR _iJ$223852[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T227575[ebp], edx
	mov	eax, DWORD PTR $T227575[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T227584[ebp], eax
	mov	edx, DWORD PTR $T227584[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T227588[ebp], edx
	mov	eax, DWORD PTR _eTech$223842[ebp]
	push	eax
	mov	ecx, DWORD PTR $T227588[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN10@CheckForTe

; 1391 : 									{
; 1392 : 										iNumPlayersWith++;

	mov	edx, DWORD PTR _iNumPlayersWith$223853[ebp]
	add	edx, 1
	mov	DWORD PTR _iNumPlayersWith$223853[ebp], edx
$LN10@CheckForTe:

; 1393 : 									}
; 1394 : 								}
; 1395 : 							}

	jmp	$LN12@CheckForTe
$LN11@CheckForTe:

; 1396 : 							if(iNumPlayersWith <= 1)  //For only the human player

	cmp	DWORD PTR _iNumPlayersWith$223853[ebp], 1
	jg	SHORT $LN15@CheckForTe

; 1397 : 							{
; 1398 : 								gDLL->UnlockAchievement(ACHIEVEMENT_SPECIAL_PONY);

	mov	eax, DWORD PTR $T227592[ebp]
	mov	DWORD PTR tv211[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv211[ebp], ecx
	push	114					; 00000072H
	mov	edx, DWORD PTR tv211[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv211[ebp]
	mov	edx, DWORD PTR [eax+828]
	call	edx
$LN15@CheckForTe:

; 1399 : 							}
; 1400 : 						}
; 1401 : 					}
; 1402 : 				}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _szCurrentTech$223846[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN16@CheckForTe:

; 1403 : 			}

	jmp	$LN18@CheckForTe
$LN20@CheckForTe:

; 1404 : 		}
; 1405 : 		//Check for all achievements
; 1406 : 		if(m_pPlayer->GetPlayerTechs()->IsCurrentResearchRepeat())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?IsCurrentResearchRepeat@CvPlayerTechs@@QBE_NXZ ; CvPlayerTechs::IsCurrentResearchRepeat
	movzx	ecx, al
	test	ecx, ecx
	je	$LN22@CheckForTe

; 1407 : 		{
; 1408 : #ifdef AUI_WARNING_FIXES
; 1409 : 			for (uint iI = 0; iI < GC.getNumTechInfos() - 1; iI++)
; 1410 : #else
; 1411 : 			for(int iI = 0; iI < GC.getNumTechInfos() - 1; iI++)

	mov	DWORD PTR _iI$223864[ebp], 0
	jmp	SHORT $LN6@CheckForTe
$LN5@CheckForTe:
	mov	edx, DWORD PTR _iI$223864[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$223864[ebp], edx
$LN6@CheckForTe:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	sub	eax, 1
	cmp	DWORD PTR _iI$223864[ebp], eax
	jge	$LN4@CheckForTe

; 1412 : #endif
; 1413 : 			{
; 1414 : 				const TechTypes eTech = static_cast<TechTypes>(iI);

	mov	eax, DWORD PTR _iI$223864[ebp]
	mov	DWORD PTR _eTech$223868[ebp], eax

; 1415 : 				CvTechEntry* pkTechInfo = GC.getTechInfo(eTech);

	mov	ecx, DWORD PTR _eTech$223868[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo
	mov	DWORD PTR _pkTechInfo$223870[ebp], eax

; 1416 : 				if(pkTechInfo)

	cmp	DWORD PTR _pkTechInfo$223870[ebp], 0
	je	SHORT $LN3@CheckForTe

; 1417 : 				{
; 1418 : 					if(!GET_TEAM(m_pPlayer->getTeam()).GetTeamTechs()->HasTech(eTech))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T227605[ebp], eax
	mov	ecx, DWORD PTR $T227605[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T227606[ebp], eax
	mov	eax, DWORD PTR $T227606[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T227610[ebp], eax
	mov	ecx, DWORD PTR _eTech$223868[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T227610[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN3@CheckForTe

; 1419 : 					{
; 1420 : 						return;

	jmp	$LN22@CheckForTe
$LN3@CheckForTe:

; 1421 : 					}
; 1422 : 				}
; 1423 : 
; 1424 : 			}

	jmp	$LN5@CheckForTe
$LN4@CheckForTe:

; 1425 : 
; 1426 : 			if(GET_TEAM(m_pPlayer->getTeam()).GetTeamTechs()->GetTechCount((TechTypes)m_pPlayer->GetPlayerTechs()->GetCurrentResearch()) < 1)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T227619[ebp], ecx
	mov	edx, DWORD PTR $T227619[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T227620[ebp], eax
	mov	ecx, DWORD PTR $T227620[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T227624[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+44]
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?GetCurrentResearch@CvPlayerTechs@@QBE?AW4TechTypes@@XZ ; CvPlayerTechs::GetCurrentResearch
	push	eax
	mov	ecx, DWORD PTR $T227624[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?GetTechCount@CvTeamTechs@@QBEHW4TechTypes@@@Z ; CvTeamTechs::GetTechCount
	cmp	eax, 1
	jge	SHORT $LN1@CheckForTe

; 1427 : 			{
; 1428 : 				return;

	jmp	SHORT $LN22@CheckForTe
$LN1@CheckForTe:

; 1429 : 			}
; 1430 : 			gDLL->UnlockAchievement(ACHIEVEMENT_ALL_TECHS);

	mov	eax, DWORD PTR $T227628[ebp]
	mov	DWORD PTR tv266[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv266[ebp], ecx
	push	51					; 00000033H
	mov	edx, DWORD PTR tv266[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv266[ebp]
	mov	edx, DWORD PTR [eax+828]
	call	edx
$LN22@CheckForTe:

; 1431 : 		}
; 1432 : 	}
; 1433 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CheckForTechAchievement@CvPlayerTechs@@QBEXXZ$0:
	lea	ecx, DWORD PTR $T227518[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?CheckForTechAchievement@CvPlayerTechs@@QBEXXZ$1:
	lea	ecx, DWORD PTR _szCurrentTech$223846[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?CheckForTechAchievement@CvPlayerTechs@@QBEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-200]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?CheckForTechAchievement@CvPlayerTechs@@QBEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?CheckForTechAchievement@CvPlayerTechs@@QBEXXZ ENDP	; CvPlayerTechs::CheckForTechAchievement
PUBLIC	?GetResearchTurnsLeftTimes100@CvPlayerTechs@@QBEHW4TechTypes@@_N@Z ; CvPlayerTechs::GetResearchTurnsLeftTimes100
PUBLIC	?GetResearchTurnsLeft@CvPlayerTechs@@QBEHW4TechTypes@@_N@Z ; CvPlayerTechs::GetResearchTurnsLeft
; Function compile flags: /Odtp
;	COMDAT ?GetResearchTurnsLeft@CvPlayerTechs@@QBEHW4TechTypes@@_N@Z
_TEXT	SEGMENT
tv75 = -20						; size = 4
_this$ = -16						; size = 4
$T227644 = -12						; size = 4
$T227637 = -8						; size = 4
_iTurnsLeft$ = -4					; size = 4
_eTech$ = 8						; size = 4
_bOverflow$ = 12					; size = 1
?GetResearchTurnsLeft@CvPlayerTechs@@QBEHW4TechTypes@@_N@Z PROC ; CvPlayerTechs::GetResearchTurnsLeft, COMDAT
; _this$ = ecx

; 1437 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 1438 : 	int iTurnsLeft = GetResearchTurnsLeftTimes100(eTech, bOverflow);

	movzx	eax, BYTE PTR _bOverflow$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eTech$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetResearchTurnsLeftTimes100@CvPlayerTechs@@QBEHW4TechTypes@@_N@Z ; CvPlayerTechs::GetResearchTurnsLeftTimes100
	mov	DWORD PTR _iTurnsLeft$[ebp], eax

; 1439 : 
; 1440 : 	if(iTurnsLeft == INT_MAX)

	cmp	DWORD PTR _iTurnsLeft$[ebp], 2147483647	; 7fffffffH
	jne	SHORT $LN1@GetResearc

; 1441 : 	{
; 1442 : 		return INT_MAX;

	mov	eax, 2147483647				; 7fffffffH
	jmp	SHORT $LN2@GetResearc
$LN1@GetResearc:

; 1443 : 	}
; 1444 : 
; 1445 : 	iTurnsLeft = (iTurnsLeft + 99) / 100; // round up

	mov	eax, DWORD PTR _iTurnsLeft$[ebp]
	add	eax, 99					; 00000063H
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iTurnsLeft$[ebp], eax

; 1446 : 
; 1447 : 	return std::max(1, iTurnsLeft);

	mov	DWORD PTR $T227637[ebp], 1
	mov	edx, DWORD PTR $T227637[ebp]
	cmp	edx, DWORD PTR _iTurnsLeft$[ebp]
	jge	SHORT $LN6@GetResearc
	lea	eax, DWORD PTR _iTurnsLeft$[ebp]
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN7@GetResearc
$LN6@GetResearc:
	lea	ecx, DWORD PTR $T227637[ebp]
	mov	DWORD PTR tv75[ebp], ecx
$LN7@GetResearc:
	mov	edx, DWORD PTR tv75[ebp]
	mov	DWORD PTR $T227644[ebp], edx
	mov	eax, DWORD PTR $T227644[ebp]
	mov	eax, DWORD PTR [eax]
$LN2@GetResearc:

; 1448 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetResearchTurnsLeft@CvPlayerTechs@@QBEHW4TechTypes@@_N@Z ENDP ; CvPlayerTechs::GetResearchTurnsLeft
_TEXT	ENDS
PUBLIC	?GetResearchProgress@CvTeamTechs@@QBEHW4TechTypes@@@Z ; CvTeamTechs::GetResearchProgress
PUBLIC	?GetResearchCost@CvPlayerTechs@@QBEHW4TechTypes@@@Z ; CvPlayerTechs::GetResearchCost
EXTRN	?getOverflowResearch@CvPlayer@@QBEHXZ:PROC	; CvPlayer::getOverflowResearch
EXTRN	?GetScienceTimes100@CvPlayer@@QBEHXZ:PROC	; CvPlayer::GetScienceTimes100
; Function compile flags: /Odtp
;	COMDAT ?GetResearchTurnsLeftTimes100@CvPlayerTechs@@QBEHW4TechTypes@@_N@Z
_TEXT	SEGMENT
tv162 = -92						; size = 4
tv193 = -88						; size = 4
_this$ = -84						; size = 4
$T227720 = -80						; size = 4
$T227711 = -76						; size = 4
$T227704 = -72						; size = 4
$T227700 = -68						; size = 4
$T227699 = -64						; size = 4
$T227690 = -60						; size = 4
$T227681 = -56						; size = 4
$T227672 = -52						; size = 4
$T227663 = -45						; size = 1
$T227651 = -44						; size = 4
$T227650 = -40						; size = 4
$T227649 = -36						; size = 4
_kPlayer$223895 = -32					; size = 4
_iTurnsLeft$ = -28					; size = 4
_iResearchLeft$ = -24					; size = 4
_iResearchCost$ = -20					; size = 4
_iI$ = -16						; size = 4
_iResearchProgress$ = -12				; size = 4
_iOverflow$ = -8					; size = 4
_iResearchRate$ = -4					; size = 4
_eTech$ = 8						; size = 4
_bOverflow$ = 12					; size = 1
?GetResearchTurnsLeftTimes100@CvPlayerTechs@@QBEHW4TechTypes@@_N@Z PROC ; CvPlayerTechs::GetResearchTurnsLeftTimes100, COMDAT
; _this$ = ecx

; 1452 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	DWORD PTR _this$[ebp], ecx

; 1453 : 	int iResearchRate;
; 1454 : 	int iOverflow;
; 1455 : 	int iTurnsLeft;
; 1456 : 	int iI;
; 1457 : 
; 1458 : 	iResearchRate = 0;

	mov	DWORD PTR _iResearchRate$[ebp], 0

; 1459 : 	iOverflow = 0;

	mov	DWORD PTR _iOverflow$[ebp], 0

; 1460 : 
; 1461 : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN10@GetResearc@2
$LN9@GetResearc@2:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN10@GetResearc@2:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	$LN8@GetResearc@2

; 1462 : 	{
; 1463 : 		CvPlayerAI& kPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$223895[ebp], ecx

; 1464 : 		if(kPlayer.isAlive())

	mov	edx, DWORD PTR _kPlayer$223895[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T227663[ebp], al
	movzx	ecx, BYTE PTR $T227663[ebp]
	test	ecx, ecx
	je	SHORT $LN7@GetResearc@2

; 1465 : 		{
; 1466 : 			// Find everyone on our team
; 1467 : 			if(kPlayer.getTeam() == m_pPlayer->getTeam())

	mov	edx, DWORD PTR _kPlayer$223895[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T227672[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T227681[ebp], edx
	mov	eax, DWORD PTR $T227681[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	DWORD PTR $T227672[ebp], eax
	jne	SHORT $LN7@GetResearc@2

; 1468 : 			{
; 1469 : 				// If this is us or if the tech matches, then increment totals
; 1470 : 				if((iI == m_pPlayer->GetID()) || kPlayer.GetPlayerTechs()->GetCurrentResearch() == eTech)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T227690[ebp], ecx
	mov	edx, DWORD PTR _iI$[ebp]
	cmp	edx, DWORD PTR $T227690[ebp]
	je	SHORT $LN4@GetResearc@2
	mov	ecx, DWORD PTR _kPlayer$223895[ebp]
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?GetCurrentResearch@CvPlayerTechs@@QBE?AW4TechTypes@@XZ ; CvPlayerTechs::GetCurrentResearch
	cmp	eax, DWORD PTR _eTech$[ebp]
	jne	SHORT $LN7@GetResearc@2
$LN4@GetResearc@2:

; 1471 : 				{
; 1472 : 					iResearchRate += kPlayer.GetScienceTimes100();

	mov	ecx, DWORD PTR _kPlayer$223895[ebp]
	call	?GetScienceTimes100@CvPlayer@@QBEHXZ	; CvPlayer::GetScienceTimes100
	add	eax, DWORD PTR _iResearchRate$[ebp]
	mov	DWORD PTR _iResearchRate$[ebp], eax

; 1473 : #ifdef AUI_PLAYER_FIX_NO_RESEARCH_OVERFLOW_DOUBLE_DIP
; 1474 : 					iOverflow += kPlayer.getOverflowResearch();

	mov	ecx, DWORD PTR _kPlayer$223895[ebp]
	call	?getOverflowResearch@CvPlayer@@QBEHXZ	; CvPlayer::getOverflowResearch
	add	eax, DWORD PTR _iOverflow$[ebp]
	mov	DWORD PTR _iOverflow$[ebp], eax
$LN7@GetResearc@2:

; 1475 : #else
; 1476 : 					iOverflow += (kPlayer.getOverflowResearch() * m_pPlayer->calculateResearchModifier(eTech)) / 100;
; 1477 : #endif
; 1478 : 				}
; 1479 : 			}
; 1480 : 		}
; 1481 : 	}

	jmp	$LN9@GetResearc@2
$LN8@GetResearc@2:

; 1482 : 
; 1483 : 	if(iResearchRate == 0)

	cmp	DWORD PTR _iResearchRate$[ebp], 0
	jne	SHORT $LN3@GetResearc@2

; 1484 : 	{
; 1485 : 		return INT_MAX;

	mov	eax, 2147483647				; 7fffffffH
	jmp	$LN11@GetResearc@2
$LN3@GetResearc@2:

; 1486 : 	}
; 1487 : 
; 1488 : 	int iResearchCost = GetResearchCost(eTech);				// Get our research cost (not the 'team' one which doesn't use our player modifier)

	mov	eax, DWORD PTR _eTech$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetResearchCost@CvPlayerTechs@@QBEHW4TechTypes@@@Z ; CvPlayerTechs::GetResearchCost
	mov	DWORD PTR _iResearchCost$[ebp], eax

; 1489 : 	// Get the team progress
; 1490 : 	int iResearchProgress = GET_TEAM(m_pPlayer->getTeam()).GetTeamTechs()->GetResearchProgress(eTech);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T227699[ebp], edx
	mov	eax, DWORD PTR $T227699[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T227700[ebp], eax
	mov	edx, DWORD PTR $T227700[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T227704[ebp], edx
	mov	eax, DWORD PTR _eTech$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T227704[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?GetResearchProgress@CvTeamTechs@@QBEHW4TechTypes@@@Z ; CvTeamTechs::GetResearchProgress
	mov	DWORD PTR _iResearchProgress$[ebp], eax

; 1491 : 	// Get the raw amount left
; 1492 : 	int iResearchLeft = std::max(0, (iResearchCost - iResearchProgress));

	mov	ecx, DWORD PTR _iResearchCost$[ebp]
	sub	ecx, DWORD PTR _iResearchProgress$[ebp]
	mov	DWORD PTR $T227649[ebp], ecx
	mov	DWORD PTR $T227650[ebp], 0
	mov	edx, DWORD PTR $T227650[ebp]
	cmp	edx, DWORD PTR $T227649[ebp]
	jge	SHORT $LN39@GetResearc@2
	lea	eax, DWORD PTR $T227649[ebp]
	mov	DWORD PTR tv193[ebp], eax
	jmp	SHORT $LN40@GetResearc@2
$LN39@GetResearc@2:
	lea	ecx, DWORD PTR $T227650[ebp]
	mov	DWORD PTR tv193[ebp], ecx
$LN40@GetResearc@2:
	mov	edx, DWORD PTR tv193[ebp]
	mov	DWORD PTR $T227711[ebp], edx
	mov	eax, DWORD PTR $T227711[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iResearchLeft$[ebp], ecx

; 1493 : 
; 1494 : 	// Removed any current overflow if requested.
; 1495 : 	if(bOverflow)

	movzx	edx, BYTE PTR _bOverflow$[ebp]
	test	edx, edx
	je	SHORT $LN2@GetResearc@2

; 1496 : 	{
; 1497 : 		iResearchLeft -= iOverflow;

	mov	eax, DWORD PTR _iResearchLeft$[ebp]
	sub	eax, DWORD PTR _iOverflow$[ebp]
	mov	DWORD PTR _iResearchLeft$[ebp], eax
$LN2@GetResearc@2:

; 1498 : 	}
; 1499 : 
; 1500 : 	iResearchLeft *= 10000;

	mov	ecx, DWORD PTR _iResearchLeft$[ebp]
	imul	ecx, 10000				; 00002710H
	mov	DWORD PTR _iResearchLeft$[ebp], ecx

; 1501 : 
; 1502 : 	iTurnsLeft = (iResearchLeft / iResearchRate);

	mov	eax, DWORD PTR _iResearchLeft$[ebp]
	cdq
	idiv	DWORD PTR _iResearchRate$[ebp]
	mov	DWORD PTR _iTurnsLeft$[ebp], eax

; 1503 : 
; 1504 : 	if(iTurnsLeft * iResearchRate < iResearchLeft)

	mov	edx, DWORD PTR _iTurnsLeft$[ebp]
	imul	edx, DWORD PTR _iResearchRate$[ebp]
	cmp	edx, DWORD PTR _iResearchLeft$[ebp]
	jge	SHORT $LN1@GetResearc@2

; 1505 : 	{
; 1506 : 		++iTurnsLeft;

	mov	eax, DWORD PTR _iTurnsLeft$[ebp]
	add	eax, 1
	mov	DWORD PTR _iTurnsLeft$[ebp], eax
$LN1@GetResearc@2:

; 1507 : 	}
; 1508 : 
; 1509 : 	return std::max(1, iTurnsLeft);

	mov	DWORD PTR $T227651[ebp], 1
	mov	ecx, DWORD PTR $T227651[ebp]
	cmp	ecx, DWORD PTR _iTurnsLeft$[ebp]
	jge	SHORT $LN43@GetResearc@2
	lea	edx, DWORD PTR _iTurnsLeft$[ebp]
	mov	DWORD PTR tv162[ebp], edx
	jmp	SHORT $LN44@GetResearc@2
$LN43@GetResearc@2:
	lea	eax, DWORD PTR $T227651[ebp]
	mov	DWORD PTR tv162[ebp], eax
$LN44@GetResearc@2:
	mov	ecx, DWORD PTR tv162[ebp]
	mov	DWORD PTR $T227720[ebp], ecx
	mov	edx, DWORD PTR $T227720[ebp]
	mov	eax, DWORD PTR [edx]
$LN11@GetResearc@2:

; 1510 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetResearchTurnsLeftTimes100@CvPlayerTechs@@QBEHW4TechTypes@@_N@Z ENDP ; CvPlayerTechs::GetResearchTurnsLeftTimes100
_TEXT	ENDS
PUBLIC	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
PUBLIC	?GetNumTechsCanBeResearched@CvPlayerTechs@@QBEHXZ ; CvPlayerTechs::GetNumTechsCanBeResearched
; Function compile flags: /Odtp
;	COMDAT ?GetNumTechsCanBeResearched@CvPlayerTechs@@QBEHXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_iTechLoop$223914 = -8					; size = 4
_rtnValue$ = -4						; size = 4
?GetNumTechsCanBeResearched@CvPlayerTechs@@QBEHXZ PROC	; CvPlayerTechs::GetNumTechsCanBeResearched, COMDAT
; _this$ = ecx

; 1514 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1515 : 	int rtnValue = 0;

	mov	DWORD PTR _rtnValue$[ebp], 0

; 1516 : 
; 1517 : #ifdef AUI_WARNING_FIXES
; 1518 : 	for (uint iTechLoop = 0; iTechLoop < GetTechs()->GetNumTechs(); iTechLoop++)
; 1519 : #else
; 1520 : 	for(int iTechLoop = 0; iTechLoop < GetTechs()->GetNumTechs(); iTechLoop++)

	mov	DWORD PTR _iTechLoop$223914[ebp], 0
	jmp	SHORT $LN4@GetNumTech
$LN3@GetNumTech:
	mov	eax, DWORD PTR _iTechLoop$223914[ebp]
	add	eax, 1
	mov	DWORD PTR _iTechLoop$223914[ebp], eax
$LN4@GetNumTech:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
	mov	ecx, eax
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	cmp	DWORD PTR _iTechLoop$223914[ebp], eax
	jge	SHORT $LN2@GetNumTech

; 1521 : #endif
; 1522 : 	{
; 1523 : 		if(CanResearch((TechTypes)iTechLoop))

	push	0
	mov	ecx, DWORD PTR _iTechLoop$223914[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z ; CvPlayerTechs::CanResearch
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@GetNumTech

; 1524 : 		{
; 1525 : 			rtnValue++;

	mov	eax, DWORD PTR _rtnValue$[ebp]
	add	eax, 1
	mov	DWORD PTR _rtnValue$[ebp], eax
$LN1@GetNumTech:

; 1526 : 		}
; 1527 : 	}

	jmp	SHORT $LN3@GetNumTech
$LN2@GetNumTech:

; 1528 : 
; 1529 : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[ebp]

; 1530 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumTechsCanBeResearched@CvPlayerTechs@@QBEHXZ ENDP	; CvPlayerTechs::GetNumTechsCanBeResearched
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ PROC ; CvPlayerTechs::GetTechs, COMDAT
; _this$ = ecx

; 1534 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1535 : 	return m_pTechs;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+40]

; 1536 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ENDP ; CvPlayerTechs::GetTechs
_TEXT	ENDS
PUBLIC	?GetResearchCost@CvTeamTechs@@QBEHW4TechTypes@@@Z ; CvTeamTechs::GetResearchCost
EXTRN	?GetMaxEffectiveCities@CvPlayer@@QAEH_N@Z:PROC	; CvPlayer::GetMaxEffectiveCities
EXTRN	?GetNumCitiesResearchCostDiscount@CvPlayer@@QBEHXZ:PROC ; CvPlayer::GetNumCitiesResearchCostDiscount
EXTRN	?GetNumCitiesTechCostMod@CvWorldInfo@@QBEHXZ:PROC ; CvWorldInfo::GetNumCitiesTechCostMod
EXTRN	?getWorldInfo@CvMap@@QBEABVCvWorldInfo@@XZ:PROC	; CvMap::getWorldInfo
EXTRN	?calculateResearchModifier@CvPlayer@@QAEHW4TechTypes@@@Z:PROC ; CvPlayer::calculateResearchModifier
; Function compile flags: /Odtp
;	COMDAT ?GetResearchCost@CvPlayerTechs@@QBEHW4TechTypes@@@Z
_TEXT	SEGMENT
tv147 = -52						; size = 4
_this$ = -48						; size = 4
$T227757 = -44						; size = 4
$T227751 = -40						; size = 4
$T227744 = -36						; size = 4
$T227740 = -32						; size = 4
$T227739 = -28						; size = 4
$T227730 = -24						; size = 4
$T227729 = -20						; size = 4
_iResearchCost$ = -16					; size = 4
_iResearchMod$ = -12					; size = 4
_iMod$ = -8						; size = 4
_iResearchModDiscount$ = -4				; size = 4
_eTech$ = 8						; size = 4
?GetResearchCost@CvPlayerTechs@@QBEHW4TechTypes@@@Z PROC ; CvPlayerTechs::GetResearchCost, COMDAT
; _this$ = ecx

; 1542 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 1543 : #ifdef AUI_TECH_FIX_TEAMER_RESEARCH_COSTS
; 1544 : 	return GET_TEAM(m_pPlayer->getTeam()).GetTeamTechs()->GetResearchCost(eTech);
; 1545 : #else
; 1546 : 	// Get the research cost for the team
; 1547 : 	int iResearchCost = GET_TEAM(m_pPlayer->getTeam()).GetTeamTechs()->GetResearchCost(eTech);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T227739[ebp], ecx
	mov	edx, DWORD PTR $T227739[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T227740[ebp], eax
	mov	ecx, DWORD PTR $T227740[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T227744[ebp], ecx
	mov	edx, DWORD PTR _eTech$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T227744[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?GetResearchCost@CvTeamTechs@@QBEHW4TechTypes@@@Z ; CvTeamTechs::GetResearchCost
	mov	DWORD PTR _iResearchCost$[ebp], eax

; 1548 : 	
; 1549 : 	// Adjust to the player's research modifier
; 1550 : 	int iResearchMod = std::max(1, m_pPlayer->calculateResearchModifier(eTech));

	mov	eax, DWORD PTR _eTech$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+44]
	call	?calculateResearchModifier@CvPlayer@@QAEHW4TechTypes@@@Z ; CvPlayer::calculateResearchModifier
	mov	DWORD PTR $T227729[ebp], eax
	mov	DWORD PTR $T227730[ebp], 1
	mov	edx, DWORD PTR $T227730[ebp]
	cmp	edx, DWORD PTR $T227729[ebp]
	jge	SHORT $LN14@GetResearc@3
	lea	eax, DWORD PTR $T227729[ebp]
	mov	DWORD PTR tv147[ebp], eax
	jmp	SHORT $LN15@GetResearc@3
$LN14@GetResearc@3:
	lea	ecx, DWORD PTR $T227730[ebp]
	mov	DWORD PTR tv147[ebp], ecx
$LN15@GetResearc@3:
	mov	edx, DWORD PTR tv147[ebp]
	mov	DWORD PTR $T227751[ebp], edx
	mov	eax, DWORD PTR $T227751[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iResearchMod$[ebp], ecx

; 1551 : 	iResearchCost = ((iResearchCost * 10000) / iResearchMod);

	mov	eax, DWORD PTR _iResearchCost$[ebp]
	imul	eax, 10000				; 00002710H
	cdq
	idiv	DWORD PTR _iResearchMod$[ebp]
	mov	DWORD PTR _iResearchCost$[ebp], eax

; 1552 : 
; 1553 : 	// Mod for City Count
; 1554 : 	int iMod = GC.getMap().getWorldInfo().GetNumCitiesTechCostMod();	// Default is 40, gets smaller on larger maps

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T227757[ebp], edx
	mov	ecx, DWORD PTR $T227757[ebp]
	call	?getWorldInfo@CvMap@@QBEABVCvWorldInfo@@XZ ; CvMap::getWorldInfo
	mov	ecx, eax
	call	?GetNumCitiesTechCostMod@CvWorldInfo@@QBEHXZ ; CvWorldInfo::GetNumCitiesTechCostMod
	mov	DWORD PTR _iMod$[ebp], eax

; 1555 : 
; 1556 : 	// NQMP GJS - new Dictatorship of the Proletariat i.e. Communism BEGIN
; 1557 : 	int iResearchModDiscount = m_pPlayer->GetNumCitiesResearchCostDiscount();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	call	?GetNumCitiesResearchCostDiscount@CvPlayer@@QBEHXZ ; CvPlayer::GetNumCitiesResearchCostDiscount
	mov	DWORD PTR _iResearchModDiscount$[ebp], eax

; 1558 : 	if (iResearchModDiscount != 0)

	cmp	DWORD PTR _iResearchModDiscount$[ebp], 0
	je	SHORT $LN3@GetResearc@3

; 1559 : 	{
; 1560 : 		iMod = iMod * (100 + iResearchModDiscount);

	mov	ecx, DWORD PTR _iResearchModDiscount$[ebp]
	add	ecx, 100				; 00000064H
	imul	ecx, DWORD PTR _iMod$[ebp]
	mov	DWORD PTR _iMod$[ebp], ecx

; 1561 : 		iMod /= 100;

	mov	eax, DWORD PTR _iMod$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iMod$[ebp], eax
$LN3@GetResearc@3:

; 1562 : 	}
; 1563 : 	// NQMP GJS - new Dictatorship of the Proletariat i.e. Communism END
; 1564 : 
; 1565 : #ifdef NQ_IGNORE_PUPPETS_FOR_RESEARCH_COSTS_FROM_POLICIES
; 1566 : 	bool bIncludePuppets = (GC.getGame().isOption("GAMEOPTION_FAST_HAND"));
; 1567 : 	iMod = iMod * m_pPlayer->GetMaxEffectiveCities(bIncludePuppets);
; 1568 : #else
; 1569 : 	iMod = iMod * m_pPlayer->GetMaxEffectiveCities(/*bIncludePuppets*/ true);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+44]
	call	?GetMaxEffectiveCities@CvPlayer@@QAEH_N@Z ; CvPlayer::GetMaxEffectiveCities
	imul	eax, DWORD PTR _iMod$[ebp]
	mov	DWORD PTR _iMod$[ebp], eax

; 1570 : #endif
; 1571 : 	iResearchCost = iResearchCost * (100 + iMod) / 100;

	mov	eax, DWORD PTR _iMod$[ebp]
	add	eax, 100				; 00000064H
	imul	eax, DWORD PTR _iResearchCost$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iResearchCost$[ebp], eax

; 1572 : 
; 1573 : 	// We're going to round up so that the user wont get confused when the research progress seems to be equal to the research cost, but it is not acutally done.
; 1574 : 	// This is because the 'real' calculations use the GameCore's fixed point math where things are multiplied by 100
; 1575 : 	if((iResearchCost % 100) != 0)

	mov	eax, DWORD PTR _iResearchCost$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	test	edx, edx
	je	SHORT $LN2@GetResearc@3

; 1576 : 		iResearchCost = (iResearchCost / 100) + 1;

	mov	eax, DWORD PTR _iResearchCost$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	add	eax, 1
	mov	DWORD PTR _iResearchCost$[ebp], eax

; 1577 : 	else

	jmp	SHORT $LN1@GetResearc@3
$LN2@GetResearc@3:

; 1578 : 		iResearchCost = (iResearchCost / 100);

	mov	eax, DWORD PTR _iResearchCost$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iResearchCost$[ebp], eax
$LN1@GetResearc@3:

; 1579 : 
; 1580 : 	return iResearchCost;

	mov	eax, DWORD PTR _iResearchCost$[ebp]

; 1581 : #endif
; 1582 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetResearchCost@CvPlayerTechs@@QBEHW4TechTypes@@@Z ENDP ; CvPlayerTechs::GetResearchCost
_TEXT	ENDS
PUBLIC	?GetResearchProgress@CvPlayerTechs@@QBEHW4TechTypes@@@Z ; CvPlayerTechs::GetResearchProgress
; Function compile flags: /Odtp
;	COMDAT ?GetResearchProgress@CvPlayerTechs@@QBEHW4TechTypes@@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T227773 = -16						; size = 4
$T227769 = -12						; size = 4
$T227768 = -8						; size = 4
_iResearchProgress$ = -4				; size = 4
_eTech$ = 8						; size = 4
?GetResearchProgress@CvPlayerTechs@@QBEHW4TechTypes@@@Z PROC ; CvPlayerTechs::GetResearchProgress, COMDAT
; _this$ = ecx

; 1587 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 1588 : 	// Get the research progress for the team
; 1589 : 	int iResearchProgress = GET_TEAM(m_pPlayer->getTeam()).GetTeamTechs()->GetResearchProgress(eTech);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T227768[ebp], ecx
	mov	edx, DWORD PTR $T227768[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T227769[ebp], eax
	mov	ecx, DWORD PTR $T227769[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T227773[ebp], ecx
	mov	edx, DWORD PTR _eTech$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T227773[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?GetResearchProgress@CvTeamTechs@@QBEHW4TechTypes@@@Z ; CvTeamTechs::GetResearchProgress
	mov	DWORD PTR _iResearchProgress$[ebp], eax

; 1590 : 	// Add in any overflow we have yet to accumulate into the research progress.
; 1591 : 	// Overflow is the leftover research from the previous research.  It is automatically rolled into the main progress value
; 1592 : 	// the next time research is 'updated'.
; 1593 : 	iResearchProgress += m_pPlayer->getOverflowResearch();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	call	?getOverflowResearch@CvPlayer@@QBEHXZ	; CvPlayer::getOverflowResearch
	add	eax, DWORD PTR _iResearchProgress$[ebp]
	mov	DWORD PTR _iResearchProgress$[ebp], eax

; 1594 : 
; 1595 : 	return iResearchProgress;

	mov	eax, DWORD PTR _iResearchProgress$[ebp]

; 1596 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetResearchProgress@CvPlayerTechs@@QBEHW4TechTypes@@@Z ENDP ; CvPlayerTechs::GetResearchProgress
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
PUBLIC	??$_Sort@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<int,std::allocator<int> >,int>
PUBLIC	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	?GetMedianTechResearch@CvPlayerTechs@@QBEHXZ	; CvPlayerTechs::GetMedianTechResearch
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?GetMedianTechResearch@CvPlayerTechs@@QBEHXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetMedianTechResearch@CvPlayerTechs@@QBEHXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetMedianTechResearch@CvPlayerTechs@@QBEHXZ$3
__ehfuncinfo$?GetMedianTechResearch@CvPlayerTechs@@QBEHXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetMedianTechResearch@CvPlayerTechs@@QBEHXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtechclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetMedianTechResearch@CvPlayerTechs@@QBEHXZ
_TEXT	SEGMENT
_this$ = -156						; size = 4
$T227905 = -124						; size = 4
$T227898 = -120						; size = 4
$T227897 = -116						; size = 4
$T227875 = -112						; size = 4
$T227859 = -108						; size = 4
$T227779 = -60						; size = 4
$T227778 = -56						; size = 4
$T227777 = -52						; size = 4
$T227776 = -48						; size = 4
_eTech$223954 = -44					; size = 4
_iTechLoop$223950 = -40					; size = 4
_iRtnValue$ = -36					; size = 4
_aiTechCosts$ = -32					; size = 16
_iNumEntries$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?GetMedianTechResearch@CvPlayerTechs@@QBEHXZ PROC	; CvPlayerTechs::GetMedianTechResearch, COMDAT
; _this$ = ecx

; 1600 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetMedianTechResearch@CvPlayerTechs@@QBEHXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 144				; 00000090H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1601 : 	vector<int> aiTechCosts;

	lea	ecx, DWORD PTR _aiTechCosts$[ebp]
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1602 : 	int iRtnValue = 0;

	mov	DWORD PTR _iRtnValue$[ebp], 0

; 1603 : 
; 1604 : #ifdef AUI_WARNING_FIXES
; 1605 : 	for (uint iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)
; 1606 : #else
; 1607 : 	for(int iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)

	mov	DWORD PTR _iTechLoop$223950[ebp], 0
	jmp	SHORT $LN7@GetMedianT
$LN6@GetMedianT:
	mov	eax, DWORD PTR _iTechLoop$223950[ebp]
	add	eax, 1
	mov	DWORD PTR _iTechLoop$223950[ebp], eax
$LN7@GetMedianT:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	cmp	DWORD PTR _iTechLoop$223950[ebp], eax
	jge	SHORT $LN43@GetMedianT

; 1608 : #endif
; 1609 : 	{
; 1610 : 		TechTypes eTech = (TechTypes)iTechLoop;

	mov	ecx, DWORD PTR _iTechLoop$223950[ebp]
	mov	DWORD PTR _eTech$223954[ebp], ecx

; 1611 : 
; 1612 : 		if(CanResearch(eTech))

	push	0
	mov	edx, DWORD PTR _eTech$223954[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z ; CvPlayerTechs::CanResearch
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@GetMedianT

; 1613 : 		{
; 1614 : 			aiTechCosts.push_back(GetResearchCost(eTech));

	mov	ecx, DWORD PTR _eTech$223954[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetResearchCost@CvPlayerTechs@@QBEHW4TechTypes@@@Z ; CvPlayerTechs::GetResearchCost
	mov	DWORD PTR $T227776[ebp], eax
	lea	edx, DWORD PTR $T227776[ebp]
	push	edx
	lea	ecx, DWORD PTR _aiTechCosts$[ebp]
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
$LN4@GetMedianT:

; 1615 : 		}
; 1616 : 	}

	jmp	SHORT $LN6@GetMedianT

; 1617 : 
; 1618 : 	int iNumEntries = aiTechCosts.size();

$LN43@GetMedianT:
	mov	eax, DWORD PTR _aiTechCosts$[ebp+8]
	sub	eax, DWORD PTR _aiTechCosts$[ebp+4]
	sar	eax, 2
	mov	DWORD PTR _iNumEntries$[ebp], eax

; 1619 : 	if(iNumEntries > 0)

	cmp	DWORD PTR _iNumEntries$[ebp], 0
	jle	$LN3@GetMedianT

; 1620 : 	{
; 1621 : 		std::sort(aiTechCosts.begin(), aiTechCosts.end());

	mov	ecx, DWORD PTR _aiTechCosts$[ebp+8]
	mov	DWORD PTR $T227859[ebp], ecx
	mov	edx, DWORD PTR $T227859[ebp]
	mov	DWORD PTR $T227777[ebp], edx
	mov	eax, DWORD PTR _aiTechCosts$[ebp+4]
	mov	DWORD PTR $T227875[ebp], eax
	mov	ecx, DWORD PTR $T227875[ebp]
	mov	DWORD PTR $T227778[ebp], ecx
	mov	edx, DWORD PTR $T227777[ebp]
	mov	DWORD PTR $T227898[ebp], edx
	mov	eax, DWORD PTR $T227778[ebp]
	mov	DWORD PTR $T227897[ebp], eax
	mov	ecx, DWORD PTR $T227898[ebp]
	sub	ecx, DWORD PTR $T227897[ebp]
	sar	ecx, 2
	push	ecx
	mov	edx, DWORD PTR $T227898[ebp]
	push	edx
	mov	eax, DWORD PTR $T227897[ebp]
	push	eax
	call	??$_Sort@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<int,std::allocator<int> >,int>
	add	esp, 12					; 0000000cH

; 1622 : 
; 1623 : 		// Odd number, take middle?
; 1624 : 		if((iNumEntries / 2) * 2 != iNumEntries)

	mov	eax, DWORD PTR _iNumEntries$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	shl	eax, 1
	cmp	eax, DWORD PTR _iNumEntries$[ebp]
	je	SHORT $LN2@GetMedianT

; 1625 : 		{
; 1626 : 			iRtnValue = aiTechCosts[iNumEntries / 2];

	mov	eax, DWORD PTR _iNumEntries$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _aiTechCosts$[ebp+4]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _iRtnValue$[ebp], edx

; 1627 : 		}
; 1628 : 
; 1629 : 		// Even number, average middle 2
; 1630 : 		else

	jmp	SHORT $LN3@GetMedianT
$LN2@GetMedianT:

; 1631 : 		{
; 1632 : 			iRtnValue = (aiTechCosts[(iNumEntries - 1) / 2] + aiTechCosts[iNumEntries / 2]) / 2;

	mov	eax, DWORD PTR _iNumEntries$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _aiTechCosts$[ebp+4]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T227905[ebp], edx
	mov	eax, DWORD PTR _iNumEntries$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _aiTechCosts$[ebp+4]
	mov	edx, DWORD PTR $T227905[ebp]
	mov	edx, DWORD PTR [edx]
	add	edx, DWORD PTR [ecx+eax*4]
	mov	eax, edx
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _iRtnValue$[ebp], eax
$LN3@GetMedianT:

; 1633 : 		}
; 1634 : 	}
; 1635 : 
; 1636 : 	return iRtnValue;

	mov	eax, DWORD PTR _iRtnValue$[ebp]
	mov	DWORD PTR $T227779[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _aiTechCosts$[ebp]
	call	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T227779[ebp]

; 1637 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetMedianTechResearch@CvPlayerTechs@@QBEHXZ$0:
	lea	ecx, DWORD PTR _aiTechCosts$[ebp]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$?GetMedianTechResearch@CvPlayerTechs@@QBEHXZ$3:
	lea	ecx, DWORD PTR _aiTechCosts$[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__ehhandler$?GetMedianTechResearch@CvPlayerTechs@@QBEHXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-148]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetMedianTechResearch@CvPlayerTechs@@QBEHXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetMedianTechResearch@CvPlayerTechs@@QBEHXZ ENDP	; CvPlayerTechs::GetMedianTechResearch
EXTRN	?AddFlavorWeights@CvTechAI@@QAEXW4FlavorTypes@@HH@Z:PROC ; CvTechAI::AddFlavorWeights
EXTRN	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z:PROC ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
EXTRN	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ:PROC ; CvPlayer::GetGrandStrategyAI
EXTRN	?getDefaultEstimateEndTurn@CvGame@@QBEHXZ:PROC	; CvGame::getDefaultEstimateEndTurn
EXTRN	?getElapsedGameTurns@CvGame@@QBEHXZ:PROC	; CvGame::getElapsedGameTurns
EXTRN	?GetLatestFlavorValue@CvFlavorRecipient@@QAEHW4FlavorTypes@@_N@Z:PROC ; CvFlavorRecipient::GetLatestFlavorValue
; Function compile flags: /Odtp
;	COMDAT ?AddFlavorAsStrategies@CvPlayerTechs@@AAEXH@Z
_TEXT	SEGMENT
tv92 = -76						; size = 4
tv159 = -72						; size = 4
_this$ = -68						; size = 4
$T228007 = -64						; size = 4
$T228001 = -60						; size = 4
$T227992 = -56						; size = 4
$T227985 = -52						; size = 4
$T227981 = -48						; size = 4
$T227977 = -44						; size = 4
$T227973 = -40						; size = 4
$T227972 = -36						; size = 4
_iFlavorValue$223998 = -32				; size = 4
_iPersonalityFlavorValue$223996 = -28			; size = 4
_iCurrentFlavorValue$223994 = -24			; size = 4
_iFlavor$223990 = -20					; size = 4
_iFlavorValue$223979 = -16				; size = 4
_iFlavor$223975 = -12					; size = 4
_iGameProgressFactor$ = -8				; size = 4
_iBiggestFlavor$ = -4					; size = 4
_iPropagatePercent$ = 8					; size = 4
?AddFlavorAsStrategies@CvPlayerTechs@@AAEXH@Z PROC	; CvPlayerTechs::AddFlavorAsStrategies, COMDAT
; _this$ = ecx

; 1643 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1644 : 	// Start by resetting the AI
; 1645 : 	m_pTechAI->Reset();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	call	?Reset@CvTechAI@@QAEXXZ			; CvTechAI::Reset

; 1646 : 
; 1647 : 	int iBiggestFlavor = -1000;

	mov	DWORD PTR _iBiggestFlavor$[ebp], -1000	; fffffc18H

; 1648 : 	for(int iFlavor = 0; iFlavor < GC.getNumFlavorTypes(); iFlavor++)

	mov	DWORD PTR _iFlavor$223975[ebp], 0
	jmp	SHORT $LN8@AddFlavorA
$LN7@AddFlavorA:
	mov	ecx, DWORD PTR _iFlavor$223975[ebp]
	add	ecx, 1
	mov	DWORD PTR _iFlavor$223975[ebp], ecx
$LN8@AddFlavorA:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T227977[ebp], edx
	mov	eax, DWORD PTR _iFlavor$223975[ebp]
	cmp	eax, DWORD PTR $T227977[ebp]
	jge	SHORT $LN6@AddFlavorA

; 1649 : 	{
; 1650 : 		int iFlavorValue = GetLatestFlavorValue((FlavorTypes) iFlavor);

	push	0
	mov	ecx, DWORD PTR _iFlavor$223975[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLatestFlavorValue@CvFlavorRecipient@@QAEHW4FlavorTypes@@_N@Z ; CvFlavorRecipient::GetLatestFlavorValue
	mov	DWORD PTR _iFlavorValue$223979[ebp], eax

; 1651 : 		if(iFlavorValue > iBiggestFlavor)

	mov	edx, DWORD PTR _iFlavorValue$223979[ebp]
	cmp	edx, DWORD PTR _iBiggestFlavor$[ebp]
	jle	SHORT $LN5@AddFlavorA

; 1652 : 		{
; 1653 : 			iBiggestFlavor = iFlavorValue;

	mov	eax, DWORD PTR _iFlavorValue$223979[ebp]
	mov	DWORD PTR _iBiggestFlavor$[ebp], eax
$LN5@AddFlavorA:

; 1654 : 		}
; 1655 : 	}

	jmp	SHORT $LN7@AddFlavorA
$LN6@AddFlavorA:

; 1656 : 
; 1657 : 	// Now populate the AI with the current flavor information
; 1658 : 	int iGameProgressFactor = (GC.getGame().getElapsedGameTurns() * 1000) / GC.getGame().getDefaultEstimateEndTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T227981[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T227985[ebp], edx
	mov	ecx, DWORD PTR $T227981[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	mov	esi, eax
	imul	esi, 1000				; 000003e8H
	mov	ecx, DWORD PTR $T227985[ebp]
	call	?getDefaultEstimateEndTurn@CvGame@@QBEHXZ ; CvGame::getDefaultEstimateEndTurn
	mov	ecx, eax
	mov	eax, esi
	cdq
	idiv	ecx
	mov	DWORD PTR _iGameProgressFactor$[ebp], eax

; 1659 : 	iGameProgressFactor = min(900,max(100,iGameProgressFactor));

	mov	DWORD PTR $T227972[ebp], 100		; 00000064H
	mov	DWORD PTR $T227973[ebp], 900		; 00000384H
	mov	edx, DWORD PTR $T227972[ebp]
	cmp	edx, DWORD PTR _iGameProgressFactor$[ebp]
	jge	SHORT $LN19@AddFlavorA
	lea	eax, DWORD PTR _iGameProgressFactor$[ebp]
	mov	DWORD PTR tv159[ebp], eax
	jmp	SHORT $LN20@AddFlavorA
$LN19@AddFlavorA:
	lea	ecx, DWORD PTR $T227972[ebp]
	mov	DWORD PTR tv159[ebp], ecx
$LN20@AddFlavorA:
	mov	edx, DWORD PTR tv159[ebp]
	mov	DWORD PTR $T227992[ebp], edx
	mov	eax, DWORD PTR $T227992[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR $T227973[ebp]
	jge	SHORT $LN23@AddFlavorA
	mov	edx, DWORD PTR $T227992[ebp]
	mov	DWORD PTR tv92[ebp], edx
	jmp	SHORT $LN24@AddFlavorA
$LN23@AddFlavorA:
	lea	eax, DWORD PTR $T227973[ebp]
	mov	DWORD PTR tv92[ebp], eax
$LN24@AddFlavorA:
	mov	ecx, DWORD PTR tv92[ebp]
	mov	DWORD PTR $T228001[ebp], ecx
	mov	edx, DWORD PTR $T228001[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _iGameProgressFactor$[ebp], eax

; 1660 : 	for(int iFlavor = 0; iFlavor < GC.getNumFlavorTypes(); iFlavor++)

	mov	DWORD PTR _iFlavor$223990[ebp], 0
	jmp	SHORT $LN4@AddFlavorA
$LN3@AddFlavorA:
	mov	ecx, DWORD PTR _iFlavor$223990[ebp]
	add	ecx, 1
	mov	DWORD PTR _iFlavor$223990[ebp], ecx
$LN4@AddFlavorA:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T228007[ebp], edx
	mov	eax, DWORD PTR _iFlavor$223990[ebp]
	cmp	eax, DWORD PTR $T228007[ebp]
	jge	SHORT $LN9@AddFlavorA

; 1661 : 	{
; 1662 : 		int iCurrentFlavorValue = GetLatestFlavorValue((FlavorTypes) iFlavor);

	push	0
	mov	ecx, DWORD PTR _iFlavor$223990[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLatestFlavorValue@CvFlavorRecipient@@QAEHW4FlavorTypes@@_N@Z ; CvFlavorRecipient::GetLatestFlavorValue
	mov	DWORD PTR _iCurrentFlavorValue$223994[ebp], eax

; 1663 : 
; 1664 : 		// Scale the current to the same scale as the personality
; 1665 : 		iCurrentFlavorValue = (iCurrentFlavorValue * 10) / iBiggestFlavor;

	mov	eax, DWORD PTR _iCurrentFlavorValue$223994[ebp]
	imul	eax, 10					; 0000000aH
	cdq
	idiv	DWORD PTR _iBiggestFlavor$[ebp]
	mov	DWORD PTR _iCurrentFlavorValue$223994[ebp], eax

; 1666 : 
; 1667 : 		int iPersonalityFlavorValue = m_pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes) iFlavor);

	mov	edx, DWORD PTR _iFlavor$223990[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
	mov	DWORD PTR _iPersonalityFlavorValue$223996[ebp], eax

; 1668 : 
; 1669 : 		// this should give a more even blend between the personality and long term strategy and the more fickle current needs
; 1670 : 		// in the beginning of the game it will be responsive to current events, but later it should try to go for the goal more strongly
; 1671 : 		int iFlavorValue = ((iCurrentFlavorValue * (1000 - iGameProgressFactor)) + (iPersonalityFlavorValue * iGameProgressFactor)) / 1000;

	mov	ecx, 1000				; 000003e8H
	sub	ecx, DWORD PTR _iGameProgressFactor$[ebp]
	mov	eax, ecx
	imul	eax, DWORD PTR _iCurrentFlavorValue$223994[ebp]
	mov	edx, DWORD PTR _iPersonalityFlavorValue$223996[ebp]
	imul	edx, DWORD PTR _iGameProgressFactor$[ebp]
	add	eax, edx
	cdq
	mov	ecx, 1000				; 000003e8H
	idiv	ecx
	mov	DWORD PTR _iFlavorValue$223998[ebp], eax

; 1672 : 
; 1673 : 		if(iFlavorValue > 0)

	cmp	DWORD PTR _iFlavorValue$223998[ebp], 0
	jle	SHORT $LN1@AddFlavorA

; 1674 : 		{
; 1675 : 			m_pTechAI->AddFlavorWeights((FlavorTypes)iFlavor, iFlavorValue, iPropagatePercent);

	mov	edx, DWORD PTR _iPropagatePercent$[ebp]
	push	edx
	mov	eax, DWORD PTR _iFlavorValue$223998[ebp]
	push	eax
	mov	ecx, DWORD PTR _iFlavor$223990[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+48]
	call	?AddFlavorWeights@CvTechAI@@QAEXW4FlavorTypes@@HH@Z ; CvTechAI::AddFlavorWeights
$LN1@AddFlavorA:

; 1676 : 		}

	jmp	$LN3@AddFlavorA
$LN9@AddFlavorA:

; 1677 : 	}
; 1678 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?AddFlavorAsStrategies@CvPlayerTechs@@AAEXH@Z ENDP	; CvPlayerTechs::AddFlavorAsStrategies
_TEXT	ENDS
PUBLIC	??_C@_0P@FJBDGACB@Flavor?0?5?$CFs?0?5?$CFd?$AA@	; `string'
PUBLIC	??_C@_02KEGNLNML@?0?5?$AA@			; `string'
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
PUBLIC	??_C@_06NHKAIDD@?$CF03d?0?5?$AA@		; `string'
PUBLIC	??_C@_0O@NLCAKOAJ@TechAILog?4csv?$AA@		; `string'
PUBLIC	??_C@_04EBGNMJBD@?4csv?$AA@			; `string'
PUBLIC	??_C@_0L@EJOHMCKE@TechAILog_?$AA@		; `string'
PUBLIC	__$ArrayPad$
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z:PROC
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	?GetInstance@FILogFileMgr@@SAAAV1@XZ:PROC	; FILogFileMgr::GetInstance
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z:PROC
EXTRN	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ:PROC ; CvGlobals::getPlayerAndCityAILogSplit
EXTRN	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationShortDescription
EXTRN	?getAILogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getAILogging
EXTRN	?getLogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getLogging
;	COMDAT ??_C@_0P@FJBDGACB@Flavor?0?5?$CFs?0?5?$CFd?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0P@FJBDGACB@Flavor?0?5?$CFs?0?5?$CFd?$AA@ DB 'Flavor, %s, %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02KEGNLNML@?0?5?$AA@
CONST	SEGMENT
??_C@_02KEGNLNML@?0?5?$AA@ DB ', ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
CONST	SEGMENT
??_C@_06NHKAIDD@?$CF03d?0?5?$AA@ DB '%03d, ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NLCAKOAJ@TechAILog?4csv?$AA@
CONST	SEGMENT
??_C@_0O@NLCAKOAJ@TechAILog?4csv?$AA@ DB 'TechAILog.csv', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04EBGNMJBD@?4csv?$AA@
CONST	SEGMENT
??_C@_04EBGNMJBD@?4csv?$AA@ DB '.csv', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EJOHMCKE@TechAILog_?$AA@
CONST	SEGMENT
??_C@_0L@EJOHMCKE@TechAILog_?$AA@ DB 'TechAILog_', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z DD 019930522H
	DD	0bH
	DD	FLAT:__unwindtable$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z$7
	DD	05H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z$8
	DD	05H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z$9
	DD	05H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z$10
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtechclasses.cpp
xdata$x	ENDS
;	COMDAT ?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z
_TEXT	SEGMENT
tv298 = -420						; size = 4
tv309 = -416						; size = 4
tv277 = -412						; size = 4
tv320 = -408						; size = 4
tv153 = -404						; size = 4
tv331 = -400						; size = 4
tv273 = -396						; size = 4
tv342 = -392						; size = 4
_this$ = -388						; size = 4
$T228109 = -384						; size = 4
$T228105 = -380						; size = 4
$T228101 = -376						; size = 4
$T228097 = -372						; size = 4
$T228093 = -368						; size = 4
$T228089 = -364						; size = 4
$T228085 = -360						; size = 4
$T228081 = -356						; size = 4
$T228077 = -352						; size = 4
$T228073 = -348						; size = 4
$T228069 = -344						; size = 4
$T228060 = -340						; size = 4
$T228056 = -336						; size = 4
$T228015 = -332						; size = 28
$T228014 = -304						; size = 28
$T228013 = -276						; size = 28
$T228012 = -248						; size = 28
$T228011 = -220						; size = 28
_iI$224024 = -192					; size = 4
_strOutBuf$224006 = -188				; size = 28
_playerName$224009 = -160				; size = 28
_strDesc$224010 = -132					; size = 28
_strLogName$224011 = -104				; size = 28
_pLog$224019 = -76					; size = 4
_strTemp$224008 = -72					; size = 28
_strBaseString$224007 = -44				; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_eFlavor$ = 8						; size = 4
?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z PROC	; CvPlayerTechs::LogFlavors, COMDAT
; _this$ = ecx

; 1681 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 408				; 00000198H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1682 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN9@LogFlavors
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN9@LogFlavors

; 1683 : 	{
; 1684 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$224006[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1685 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$224007[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1686 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$224008[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1687 : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$224009[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 1688 : 		CvString strDesc;

	lea	ecx, DWORD PTR _strDesc$224010[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 1689 : 		CvString strLogName;

	lea	ecx, DWORD PTR _strLogName$224011[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5

; 1690 : 
; 1691 : 		// Find the name of this civ
; 1692 : 		playerName = m_pPlayer->getCivilizationShortDescription();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+44]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T228056[ebp], eax
	cmp	DWORD PTR $T228056[ebp], 0
	je	SHORT $LN41@LogFlavors
	mov	eax, DWORD PTR $T228056[ebp]
	push	eax
	lea	ecx, DWORD PTR _playerName$224009[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN42@LogFlavors
$LN41@LogFlavors:
	lea	ecx, DWORD PTR _playerName$224009[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN42@LogFlavors:

; 1693 : 
; 1694 : 		// Open the log file
; 1695 : 		if(GC.getPlayerAndCityAILogSplit())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ ; CvGlobals::getPlayerAndCityAILogSplit
	movzx	ecx, al
	test	ecx, ecx
	je	$LN7@LogFlavors

; 1696 : 		{
; 1697 : 			strLogName = "TechAILog_" + playerName + ".csv";

	lea	edx, DWORD PTR _playerName$224009[ebp]
	push	edx
	push	OFFSET ??_C@_0L@EJOHMCKE@TechAILog_?$AA@
	lea	eax, DWORD PTR $T228011[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv342[ebp], eax
	mov	ecx, DWORD PTR tv342[ebp]
	mov	DWORD PTR tv273[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	push	OFFSET ??_C@_04EBGNMJBD@?4csv?$AA@
	mov	edx, DWORD PTR tv273[ebp]
	push	edx
	lea	eax, DWORD PTR $T228012[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv331[ebp], eax
	mov	ecx, DWORD PTR tv331[ebp]
	mov	DWORD PTR $T228060[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	ecx, DWORD PTR $T228060[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogName$224011[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR $T228012[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T228011[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1698 : 		}
; 1699 : 		else

	jmp	SHORT $LN6@LogFlavors
$LN7@LogFlavors:

; 1700 : 		{
; 1701 : 			strLogName = "TechAILog.csv";

	mov	edx, OFFSET ??_C@_0O@NLCAKOAJ@TechAILog?4csv?$AA@
	test	edx, edx
	je	SHORT $LN47@LogFlavors
	push	OFFSET ??_C@_0O@NLCAKOAJ@TechAILog?4csv?$AA@
	lea	ecx, DWORD PTR _strLogName$224011[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN6@LogFlavors
$LN47@LogFlavors:
	lea	ecx, DWORD PTR _strLogName$224011[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN6@LogFlavors:

; 1702 : 		}
; 1703 : 
; 1704 : 		FILogFile* pLog;
; 1705 : 		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv153[ebp], eax
	lea	ecx, DWORD PTR _strLogName$224011[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T228069[ebp], eax
	push	0
	push	1
	mov	eax, DWORD PTR $T228069[ebp]
	push	eax
	mov	ecx, DWORD PTR tv153[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv153[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pLog$224019[ebp], eax

; 1706 : 
; 1707 : 		// Get the leading info for this line
; 1708 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T228073[ebp], ecx
	mov	ecx, DWORD PTR $T228073[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	push	OFFSET ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
	lea	edx, DWORD PTR _strBaseString$224007[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 1709 : 		strBaseString += playerName + ", ";

	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	eax, DWORD PTR _playerName$224009[ebp]
	push	eax
	lea	ecx, DWORD PTR $T228013[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv320[ebp], eax
	mov	edx, DWORD PTR tv320[ebp]
	mov	DWORD PTR tv277[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	eax, DWORD PTR tv277[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBaseString$224007[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T228013[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1710 : 
; 1711 : 		// Dump out the setting for each flavor
; 1712 : 		if(eFlavor == NO_FLAVOR)

	cmp	DWORD PTR _eFlavor$[ebp], -1
	jne	$LN5@LogFlavors

; 1713 : 		{
; 1714 : 			for(int iI = 0; iI < GC.getNumFlavorTypes(); iI++)

	mov	DWORD PTR _iI$224024[ebp], 0
	jmp	SHORT $LN4@LogFlavors
$LN3@LogFlavors:
	mov	ecx, DWORD PTR _iI$224024[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$224024[ebp], ecx
$LN4@LogFlavors:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T228077[ebp], edx
	mov	eax, DWORD PTR _iI$224024[ebp]
	cmp	eax, DWORD PTR $T228077[ebp]
	jge	$LN2@LogFlavors

; 1715 : 			{
; 1716 : 				strTemp.Format("Flavor, %s, %d", GC.getFlavorTypes((FlavorTypes)iI).GetCString(), m_piLatestFlavorValues[iI]);

	mov	ecx, DWORD PTR _iI$224024[ebp]
	imul	ecx, 28					; 0000001cH
	add	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	mov	DWORD PTR $T228081[ebp], ecx
	mov	ecx, DWORD PTR $T228081[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T228085[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _iI$224024[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR $T228085[ebp]
	push	eax
	push	OFFSET ??_C@_0P@FJBDGACB@Flavor?0?5?$CFs?0?5?$CFd?$AA@
	lea	ecx, DWORD PTR _strTemp$224008[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 1717 : 				strOutBuf = strBaseString + strTemp;

	lea	edx, DWORD PTR _strTemp$224008[ebp]
	push	edx
	lea	eax, DWORD PTR _strBaseString$224007[ebp]
	push	eax
	lea	ecx, DWORD PTR $T228014[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv309[ebp], eax
	mov	edx, DWORD PTR tv309[ebp]
	mov	DWORD PTR $T228089[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	mov	ecx, DWORD PTR $T228089[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$224006[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T228014[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1718 : 				pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$224006[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T228093[ebp], eax
	mov	eax, DWORD PTR $T228093[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLog$224019[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pLog$224019[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx]
	call	ecx
	add	esp, 8

; 1719 : 			}

	jmp	$LN3@LogFlavors
$LN2@LogFlavors:

; 1720 : 		}
; 1721 : 		else

	jmp	$LN1@LogFlavors
$LN5@LogFlavors:

; 1722 : 		{
; 1723 : 			strTemp.Format("Flavor, %s, %d", GC.getFlavorTypes(eFlavor).GetCString(), m_piLatestFlavorValues[eFlavor]);

	mov	edx, DWORD PTR _eFlavor$[ebp]
	imul	edx, 28					; 0000001cH
	add	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	mov	DWORD PTR $T228097[ebp], edx
	mov	ecx, DWORD PTR $T228097[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T228101[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _eFlavor$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	mov	ecx, DWORD PTR $T228101[ebp]
	push	ecx
	push	OFFSET ??_C@_0P@FJBDGACB@Flavor?0?5?$CFs?0?5?$CFd?$AA@
	lea	edx, DWORD PTR _strTemp$224008[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 1724 : 			strOutBuf = strBaseString + strTemp;

	lea	eax, DWORD PTR _strTemp$224008[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBaseString$224007[ebp]
	push	ecx
	lea	edx, DWORD PTR $T228015[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv298[ebp], eax
	mov	eax, DWORD PTR tv298[ebp]
	mov	DWORD PTR $T228105[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	ecx, DWORD PTR $T228105[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$224006[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T228015[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1725 : 			pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$224006[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T228109[ebp], eax
	mov	ecx, DWORD PTR $T228109[ebp]
	push	ecx
	mov	edx, DWORD PTR _pLog$224019[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pLog$224019[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 8
$LN1@LogFlavors:

; 1726 : 		}
; 1727 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR _strLogName$224011[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _strDesc$224010[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _playerName$224009[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strTemp$224008[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strBaseString$224007[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strOutBuf$224006[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN9@LogFlavors:

; 1728 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$224006[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z$1:
	lea	ecx, DWORD PTR _strBaseString$224007[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z$2:
	lea	ecx, DWORD PTR _strTemp$224008[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z$3:
	lea	ecx, DWORD PTR _playerName$224009[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z$4:
	lea	ecx, DWORD PTR _strDesc$224010[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z$5:
	lea	ecx, DWORD PTR _strLogName$224011[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z$6:
	lea	ecx, DWORD PTR $T228011[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z$7:
	lea	ecx, DWORD PTR $T228012[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z$8:
	lea	ecx, DWORD PTR $T228013[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z$9:
	lea	ecx, DWORD PTR $T228014[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z$10:
	lea	ecx, DWORD PTR $T228015[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-412]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z ENDP	; CvPlayerTechs::LogFlavors
PUBLIC	??0CvTeamTechs@@QAE@XZ				; CvTeamTechs::CvTeamTechs
; Function compile flags: /Odtp
;	COMDAT ??0CvTeamTechs@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvTeamTechs@@QAE@XZ PROC				; CvTeamTechs::CvTeamTechs, COMDAT
; _this$ = ecx

; 1744 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 1745 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvTeamTechs@@QAE@XZ ENDP				; CvTeamTechs::CvTeamTechs
_TEXT	ENDS
PUBLIC	??1CvTeamTechs@@QAE@XZ				; CvTeamTechs::~CvTeamTechs
; Function compile flags: /Odtp
;	COMDAT ??1CvTeamTechs@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvTeamTechs@@QAE@XZ PROC				; CvTeamTechs::~CvTeamTechs, COMDAT
; _this$ = ecx

; 1749 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1750 : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1CvTeamTechs@@QAE@XZ ENDP				; CvTeamTechs::~CvTeamTechs
_TEXT	ENDS
PUBLIC	?Reset@CvTeamTechs@@QAEXXZ			; CvTeamTechs::Reset
PUBLIC	?Init@CvTeamTechs@@QAEXPAVCvTechXMLEntries@@PAVCvTeam@@@Z ; CvTeamTechs::Init
; Function compile flags: /Odtp
;	COMDAT ?Init@CvTeamTechs@@QAEXPAVCvTechXMLEntries@@PAVCvTeam@@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T228149 = -16						; size = 4
$T228148 = -12						; size = 4
$T228147 = -8						; size = 4
$T228146 = -4						; size = 4
_pTechs$ = 8						; size = 4
_pTeam$ = 12						; size = 4
?Init@CvTeamTechs@@QAEXPAVCvTechXMLEntries@@PAVCvTeam@@@Z PROC ; CvTeamTechs::Init, COMDAT
; _this$ = ecx

; 1754 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 1755 : 	// Store off the pointer to the techs active for this game and pointer to our team
; 1756 : 	m_pTechs = pTechs;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pTechs$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 1757 : 	m_pTeam = pTeam;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pTeam$[ebp]
	mov	DWORD PTR [edx+24], eax

; 1758 : 
; 1759 : 	// Initialize status arrays
; 1760 : 	CvAssertMsg(m_pabHasTech==NULL, "about to leak memory, CvTeamTechs::m_pabHasTech");
; 1761 : 	m_pabHasTech = FNEW(bool[m_pTechs->GetNumTechs()], c_eCiv5GameplayDLL, 0);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T228146[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T228146[ebp]
	mov	DWORD PTR [edx+4], eax

; 1762 : 	CvAssertMsg(m_pabNoTradeTech==NULL, "about to leak memory, CvTeamTechs::m_pabNoTradeTech");
; 1763 : 	m_pabNoTradeTech = FNEW(bool[m_pTechs->GetNumTechs()], c_eCiv5GameplayDLL, 0);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T228147[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T228147[ebp]
	mov	DWORD PTR [edx+8], eax

; 1764 : 	CvAssertMsg(m_paiResearchProgress==NULL, "about to leak memory, CvTeamTechs::m_paiResearchProgress");
; 1765 : 	m_paiResearchProgress = FNEW(int [m_pTechs->GetNumTechs()], c_eCiv5GameplayDLL, 0);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T228148[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T228148[ebp]
	mov	DWORD PTR [eax+12], ecx

; 1766 : 	CvAssertMsg(m_paiTechCount==NULL, "about to leak memory, CvTeamTechs::m_paiTechCount");
; 1767 : 	m_paiTechCount = FNEW(int [m_pTechs->GetNumTechs()], c_eCiv5GameplayDLL, 0);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T228149[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T228149[ebp]
	mov	DWORD PTR [eax+16], ecx

; 1768 : 
; 1769 : 	Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Reset@CvTeamTechs@@QAEXXZ		; CvTeamTechs::Reset

; 1770 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?Init@CvTeamTechs@@QAEXPAVCvTechXMLEntries@@PAVCvTeam@@@Z ENDP ; CvTeamTechs::Init
_TEXT	ENDS
PUBLIC	?Uninit@CvTeamTechs@@QAEXXZ			; CvTeamTechs::Uninit
; Function compile flags: /Odtp
;	COMDAT ?Uninit@CvTeamTechs@@QAEXXZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T228175 = -32						; size = 4
$T228174 = -28						; size = 4
$T228169 = -24						; size = 4
$T228168 = -20						; size = 4
$T228163 = -16						; size = 4
$T228162 = -12						; size = 4
$T228157 = -8						; size = 4
$T228156 = -4						; size = 4
?Uninit@CvTeamTechs@@QAEXXZ PROC			; CvTeamTechs::Uninit, COMDAT
; _this$ = ecx

; 1774 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 1775 : 	SAFE_DELETE_ARRAY(m_pabHasTech);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR $T228157[ebp], eax
	mov	ecx, DWORD PTR $T228157[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T228156[ebp], edx
	mov	eax, DWORD PTR $T228156[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T228157[ebp]
	mov	DWORD PTR [ecx], 0

; 1776 : 	SAFE_DELETE_ARRAY(m_pabNoTradeTech);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	mov	DWORD PTR $T228163[ebp], edx
	mov	eax, DWORD PTR $T228163[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T228162[ebp], ecx
	mov	edx, DWORD PTR $T228162[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, DWORD PTR $T228163[ebp]
	mov	DWORD PTR [eax], 0

; 1777 : 	SAFE_DELETE_ARRAY(m_paiResearchProgress);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR $T228169[ebp], ecx
	mov	edx, DWORD PTR $T228169[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T228168[ebp], eax
	mov	ecx, DWORD PTR $T228168[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T228169[ebp]
	mov	DWORD PTR [edx], 0

; 1778 : 	SAFE_DELETE_ARRAY(m_paiTechCount);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR $T228175[ebp], eax
	mov	ecx, DWORD PTR $T228175[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T228174[ebp], edx
	mov	eax, DWORD PTR $T228174[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T228175[ebp]
	mov	DWORD PTR [ecx], 0

; 1779 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Uninit@CvTeamTechs@@QAEXXZ ENDP			; CvTeamTechs::Uninit
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Reset@CvTeamTechs@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_iI$ = -4						; size = 4
?Reset@CvTeamTechs@@QAEXXZ PROC				; CvTeamTechs::Reset, COMDAT
; _this$ = ecx

; 1783 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1784 : #ifdef AUI_WARNING_FIXES
; 1785 : 	uint iI;
; 1786 : #else
; 1787 : 	int iI;
; 1788 : #endif
; 1789 : 
; 1790 : 	m_eLastTechAcquired = NO_TECH;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], -1

; 1791 : 
; 1792 : 	for(iI = 0; iI < m_pTechs->GetNumTechs(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN3@Reset@2
$LN2@Reset@2:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN3@Reset@2:
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	cmp	DWORD PTR _iI$[ebp], eax
	jge	SHORT $LN4@Reset@2

; 1793 : 	{
; 1794 : 		m_pabHasTech[iI] = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _iI$[ebp]
	mov	BYTE PTR [ecx+edx], 0

; 1795 : 		m_pabNoTradeTech[iI] = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _iI$[ebp]
	mov	BYTE PTR [ecx+edx], 0

; 1796 : 		m_paiResearchProgress[iI] = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [ecx+edx*4], 0

; 1797 : 		m_paiTechCount[iI] = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [ecx+edx*4], 0
	jmp	SHORT $LN2@Reset@2
$LN4@Reset@2:

; 1798 : 	}
; 1799 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Reset@CvTeamTechs@@QAEXXZ ENDP				; CvTeamTechs::Reset
_TEXT	ENDS
PUBLIC	??$ReadAndRemapDataArray@H@CvInfosSerializationHelper@@YA_NAAVFDataStream@@HPAHHPBH@Z ; CvInfosSerializationHelper::ReadAndRemapDataArray<int>
PUBLIC	??$ReadAndRemapDataArray@_N@CvInfosSerializationHelper@@YA_NAAVFDataStream@@HPA_NHPBH@Z ; CvInfosSerializationHelper::ReadAndRemapDataArray<bool>
PUBLIC	??$ReadHashedTypeArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@IPAHI@Z ; CvInfosSerializationHelper::ReadHashedTypeArray<int>
PUBLIC	__$ArrayPad$
PUBLIC	?Read@CvTeamTechs@@QAEXAAVFDataStream@@@Z	; CvTeamTechs::Read
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4TechTypes@@@Z:PROC ; operator>>
EXTRN	__alloca_probe_16:PROC
; Function compile flags: /Odtp
;	COMDAT ?Read@CvTeamTechs@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
tv92 = -48						; size = 4
tv83 = -44						; size = 4
_this$ = -40						; size = 4
$T228207 = -36						; size = 4
__Marker$228201 = -32					; size = 4
$T228198 = -28						; size = 4
$T228193 = -24						; size = 4
__$ArrayPad$ = -20					; size = 4
_paTechIDs$224155 = -16					; size = 4
_iNumActiveTechs$224154 = -12				; size = 4
_iNumSavedTechs$ = -8					; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Read@CvTeamTechs@@QAEXAAVFDataStream@@@Z PROC		; CvTeamTechs::Read, COMDAT
; _this$ = ecx

; 1890 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1891 : 	// Version number to maintain backwards compatibility
; 1892 : 	uint uiVersion;
; 1893 : 	kStream >> uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 1894 : 
; 1895 : 	kStream >> m_eLastTechAcquired;

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??5@YAAAVFDataStream@@AAV0@AAW4TechTypes@@@Z ; operator>>
	add	esp, 8

; 1896 : 
; 1897 : 	// Read the number of techs
; 1898 : #ifdef AUI_WARNING_FIXES
; 1899 : 	uint iNumSavedTechs;
; 1900 : 	kStream >> iNumSavedTechs;
; 1901 : 
; 1902 : 	if (iNumSavedTechs)
; 1903 : 	{
; 1904 : 		uint iNumActiveTechs = m_pTechs->GetNumTechs();
; 1905 : #else
; 1906 : 	int iNumSavedTechs;
; 1907 : 	kStream >> iNumSavedTechs;

	lea	eax, DWORD PTR _iNumSavedTechs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1908 : 
; 1909 : 	if(iNumSavedTechs)

	cmp	DWORD PTR _iNumSavedTechs$[ebp], 0
	je	$LN2@Read@2

; 1910 : 	{
; 1911 : 		int iNumActiveTechs = m_pTechs->GetNumTechs();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	mov	DWORD PTR _iNumActiveTechs$224154[ebp], eax

; 1912 : #endif
; 1913 : 
; 1914 : 		// Next is an array of the tech IDs that were available when the save was made.
; 1915 : 		CvAssert(m_pTechs == GC.GetGameTechs());	// The hash to indices conversion will convert the hash to the index in the main game techs array, so these better be the same.
; 1916 : 		int* paTechIDs = (int*)_malloca(iNumSavedTechs * sizeof(int));

	mov	edx, DWORD PTR _iNumSavedTechs$[ebp]
	lea	eax, DWORD PTR [edx*4+8]
	cmp	eax, 1024				; 00000400H
	ja	SHORT $LN4@Read@2
	mov	ecx, DWORD PTR _iNumSavedTechs$[ebp]
	lea	eax, DWORD PTR [ecx*4+8]
	call	__alloca_probe_16
	mov	DWORD PTR tv83[ebp], esp
	mov	edx, DWORD PTR tv83[ebp]
	mov	DWORD PTR $T228193[ebp], edx
	cmp	DWORD PTR $T228193[ebp], 0
	je	SHORT $LN11@Read@2
	mov	eax, DWORD PTR $T228193[ebp]
	mov	DWORD PTR [eax], 52428			; 0000ccccH
	mov	ecx, DWORD PTR $T228193[ebp]
	add	ecx, 8
	mov	DWORD PTR $T228193[ebp], ecx
$LN11@Read@2:
	mov	edx, DWORD PTR $T228193[ebp]
	mov	DWORD PTR tv92[ebp], edx
	jmp	SHORT $LN5@Read@2
$LN4@Read@2:
	mov	eax, DWORD PTR _iNumSavedTechs$[ebp]
	lea	ecx, DWORD PTR [eax*4+8]
	push	ecx
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	DWORD PTR $T228198[ebp], eax
	cmp	DWORD PTR $T228198[ebp], 0
	je	SHORT $LN14@Read@2
	mov	edx, DWORD PTR $T228198[ebp]
	mov	DWORD PTR [edx], 56797			; 0000ddddH
	mov	eax, DWORD PTR $T228198[ebp]
	add	eax, 8
	mov	DWORD PTR $T228198[ebp], eax
$LN14@Read@2:
	mov	ecx, DWORD PTR $T228198[ebp]
	mov	DWORD PTR tv92[ebp], ecx
$LN5@Read@2:
	mov	edx, DWORD PTR tv92[ebp]
	mov	DWORD PTR _paTechIDs$224155[ebp], edx

; 1917 : 		CvInfosSerializationHelper::ReadHashedTypeArray(kStream, iNumSavedTechs, paTechIDs, iNumSavedTechs);

	mov	eax, DWORD PTR _iNumSavedTechs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _paTechIDs$224155[ebp]
	push	ecx
	mov	edx, DWORD PTR _iNumSavedTechs$[ebp]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$ReadHashedTypeArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@IPAHI@Z ; CvInfosSerializationHelper::ReadHashedTypeArray<int>
	add	esp, 16					; 00000010H

; 1918 : 
; 1919 : 		CvInfosSerializationHelper::ReadAndRemapDataArray(kStream, iNumSavedTechs, m_pabHasTech, iNumActiveTechs, paTechIDs);

	mov	ecx, DWORD PTR _paTechIDs$224155[ebp]
	push	ecx
	mov	edx, DWORD PTR _iNumActiveTechs$224154[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _iNumSavedTechs$[ebp]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$ReadAndRemapDataArray@_N@CvInfosSerializationHelper@@YA_NAAVFDataStream@@HPA_NHPBH@Z ; CvInfosSerializationHelper::ReadAndRemapDataArray<bool>
	add	esp, 20					; 00000014H

; 1920 : 		CvInfosSerializationHelper::ReadAndRemapDataArray(kStream, iNumSavedTechs, m_pabNoTradeTech, iNumActiveTechs, paTechIDs);

	mov	ecx, DWORD PTR _paTechIDs$224155[ebp]
	push	ecx
	mov	edx, DWORD PTR _iNumActiveTechs$224154[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _iNumSavedTechs$[ebp]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$ReadAndRemapDataArray@_N@CvInfosSerializationHelper@@YA_NAAVFDataStream@@HPA_NHPBH@Z ; CvInfosSerializationHelper::ReadAndRemapDataArray<bool>
	add	esp, 20					; 00000014H

; 1921 : 		CvInfosSerializationHelper::ReadAndRemapDataArray(kStream, iNumSavedTechs, m_paiResearchProgress, iNumActiveTechs, paTechIDs);

	mov	ecx, DWORD PTR _paTechIDs$224155[ebp]
	push	ecx
	mov	edx, DWORD PTR _iNumActiveTechs$224154[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _iNumSavedTechs$[ebp]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$ReadAndRemapDataArray@H@CvInfosSerializationHelper@@YA_NAAVFDataStream@@HPAHHPBH@Z ; CvInfosSerializationHelper::ReadAndRemapDataArray<int>
	add	esp, 20					; 00000014H

; 1922 : 		CvInfosSerializationHelper::ReadAndRemapDataArray(kStream, iNumSavedTechs, m_paiTechCount, iNumActiveTechs, paTechIDs);

	mov	ecx, DWORD PTR _paTechIDs$224155[ebp]
	push	ecx
	mov	edx, DWORD PTR _iNumActiveTechs$224154[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _iNumSavedTechs$[ebp]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$ReadAndRemapDataArray@H@CvInfosSerializationHelper@@YA_NAAVFDataStream@@HPAHHPBH@Z ; CvInfosSerializationHelper::ReadAndRemapDataArray<int>
	add	esp, 20					; 00000014H

; 1923 : 
; 1924 : 		_freea(paTechIDs);

	mov	ecx, DWORD PTR _paTechIDs$224155[ebp]
	mov	DWORD PTR $T228207[ebp], ecx
	cmp	DWORD PTR $T228207[ebp], 0
	je	SHORT $LN2@Read@2
	mov	edx, DWORD PTR $T228207[ebp]
	sub	edx, 8
	mov	DWORD PTR $T228207[ebp], edx
	mov	eax, DWORD PTR $T228207[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Marker$228201[ebp], ecx
	cmp	DWORD PTR __Marker$228201[ebp], 56797	; 0000ddddH
	jne	SHORT $LN2@Read@2
	mov	edx, DWORD PTR $T228207[ebp]
	push	edx
	call	DWORD PTR __imp__free
	add	esp, 4
$LN2@Read@2:

; 1925 : 	}
; 1926 : }

	lea	esp, DWORD PTR [ebp-48]
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?Read@CvTeamTechs@@QAEXAAVFDataStream@@@Z ENDP		; CvTeamTechs::Read
_TEXT	ENDS
PUBLIC	??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@_N@@@Z ; operator<<<bool>
PUBLIC	?Write@CvTeamTechs@@QAEXAAVFDataStream@@@Z	; CvTeamTechs::Write
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@PBVCvBaseInfo@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4TechTypes@@@Z:PROC ; operator<<
; Function compile flags: /Odtp
;	COMDAT ?Write@CvTeamTechs@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -84						; size = 4
$T228241 = -80						; size = 4
$T228240 = -76						; size = 4
$T228236 = -72						; size = 4
$T228235 = -68						; size = 4
$T228231 = -64						; size = 4
$T228230 = -60						; size = 4
$T228226 = -56						; size = 4
$T228225 = -52						; size = 4
$T228215 = -48						; size = 4
$T228214 = -44						; size = 8
$T228213 = -36						; size = 8
$T228212 = -28						; size = 8
$T228211 = -20						; size = 8
_i$224199 = -12						; size = 4
_iNumTechs$224197 = -8					; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Write@CvTeamTechs@@QAEXAAVFDataStream@@@Z PROC		; CvTeamTechs::Write, COMDAT
; _this$ = ecx

; 1931 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	DWORD PTR _this$[ebp], ecx

; 1932 : 	// Current version number
; 1933 : 	uint uiVersion = 1;

	mov	DWORD PTR _uiVersion$[ebp], 1

; 1934 : 	kStream << uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 1935 : 
; 1936 : 	kStream << m_eLastTechAcquired;

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??6@YAAAVFDataStream@@AAV0@ABW4TechTypes@@@Z ; operator<<
	add	esp, 8

; 1937 : 
; 1938 : 	if(m_pTechs != NULL && m_pTechs->GetNumTechs())

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 0
	je	$LN5@Write@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	test	eax, eax
	je	$LN5@Write@2

; 1939 : 	{
; 1940 : 		// Write out an array of all the active tech's hash types so we can re-map on loading if need be.
; 1941 : #ifdef AUI_WARNING_FIXES
; 1942 : 		uint iNumTechs = m_pTechs->GetNumTechs();
; 1943 : 		kStream << iNumTechs;
; 1944 : 
; 1945 : 		for (uint i = 0; i < iNumTechs; ++i)
; 1946 : #else
; 1947 : 		int iNumTechs = m_pTechs->GetNumTechs();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	mov	DWORD PTR _iNumTechs$224197[ebp], eax

; 1948 : 		kStream << (int)iNumTechs;

	lea	eax, DWORD PTR _iNumTechs$224197[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1949 : 
; 1950 : 		for(int i = 0; i < iNumTechs; ++i)

	mov	DWORD PTR _i$224199[ebp], 0
	jmp	SHORT $LN4@Write@2
$LN3@Write@2:
	mov	ecx, DWORD PTR _i$224199[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$224199[ebp], ecx
$LN4@Write@2:
	mov	edx, DWORD PTR _i$224199[ebp]
	cmp	edx, DWORD PTR _iNumTechs$224197[ebp]
	jge	SHORT $LN2@Write@2

; 1951 : #endif
; 1952 : 			CvInfosSerializationHelper::WriteHashed(kStream, m_pTechs->GetEntry(i));

	mov	eax, DWORD PTR _i$224199[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	call	?GetEntry@CvTechXMLEntries@@QAEPAVCvTechEntry@@H@Z ; CvTechXMLEntries::GetEntry
	push	eax
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@PBVCvBaseInfo@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	jmp	SHORT $LN3@Write@2
$LN2@Write@2:

; 1953 : 
; 1954 : 		kStream << ArrayWrapper<bool>(iNumTechs, m_pabHasTech);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T228226[ebp], ecx
	mov	edx, DWORD PTR _iNumTechs$224197[ebp]
	mov	DWORD PTR $T228225[ebp], edx
	mov	eax, DWORD PTR $T228226[ebp]
	mov	DWORD PTR $T228211[ebp], eax
	mov	ecx, DWORD PTR $T228225[ebp]
	mov	DWORD PTR $T228211[ebp+4], ecx
	lea	edx, DWORD PTR $T228211[ebp]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@_N@@@Z ; operator<<<bool>
	add	esp, 8

; 1955 : 		kStream << ArrayWrapper<bool>(iNumTechs, m_pabNoTradeTech);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T228231[ebp], edx
	mov	eax, DWORD PTR _iNumTechs$224197[ebp]
	mov	DWORD PTR $T228230[ebp], eax
	mov	ecx, DWORD PTR $T228231[ebp]
	mov	DWORD PTR $T228212[ebp], ecx
	mov	edx, DWORD PTR $T228230[ebp]
	mov	DWORD PTR $T228212[ebp+4], edx
	lea	eax, DWORD PTR $T228212[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@_N@@@Z ; operator<<<bool>
	add	esp, 8

; 1956 : 		kStream << ArrayWrapper<int>(iNumTechs, m_paiResearchProgress);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR $T228236[ebp], eax
	mov	ecx, DWORD PTR _iNumTechs$224197[ebp]
	mov	DWORD PTR $T228235[ebp], ecx
	mov	edx, DWORD PTR $T228236[ebp]
	mov	DWORD PTR $T228213[ebp], edx
	mov	eax, DWORD PTR $T228235[ebp]
	mov	DWORD PTR $T228213[ebp+4], eax
	lea	ecx, DWORD PTR $T228213[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ; operator<<<int>
	add	esp, 8

; 1957 : 		kStream << ArrayWrapper<int>(iNumTechs, m_paiTechCount);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR $T228241[ebp], ecx
	mov	edx, DWORD PTR _iNumTechs$224197[ebp]
	mov	DWORD PTR $T228240[ebp], edx
	mov	eax, DWORD PTR $T228241[ebp]
	mov	DWORD PTR $T228214[ebp], eax
	mov	ecx, DWORD PTR $T228240[ebp]
	mov	DWORD PTR $T228214[ebp+4], ecx
	lea	edx, DWORD PTR $T228214[ebp]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ; operator<<<int>
	add	esp, 8

; 1958 : 	}
; 1959 : 	else

	jmp	SHORT $LN6@Write@2
$LN5@Write@2:

; 1960 : 	{
; 1961 : 		kStream << (int)0;

	mov	DWORD PTR $T228215[ebp], 0
	lea	ecx, DWORD PTR $T228215[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
$LN6@Write@2:

; 1962 : 	}
; 1963 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Write@CvTeamTechs@@QAEXAAVFDataStream@@@Z ENDP		; CvTeamTechs::Write
_TEXT	ENDS
PUBLIC	??_C@_0P@EGCDAPHC@TeamSetHasTech?$AA@		; `string'
PUBLIC	?SetLastTechAcquired@CvTeamTechs@@QAEXW4TechTypes@@@Z ; CvTeamTechs::SetLastTechAcquired
PUBLIC	?SetHasTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z	; CvTeamTechs::SetHasTech
EXTRN	?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z:PROC ; LuaSupport::CallHook
EXTRN	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ:PROC	; CvTeam::GetID
;	COMDAT ??_C@_0P@EGCDAPHC@TeamSetHasTech?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaargshandle.h
CONST	SEGMENT
??_C@_0P@EGCDAPHC@TeamSetHasTech?$AA@ DB 'TeamSetHasTech', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SetHasTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetHasTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z$0
__ehfuncinfo$?SetHasTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SetHasTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtechclasses.cpp
xdata$x	ENDS
;	COMDAT ?SetHasTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z
_TEXT	SEGMENT
tv142 = -48						; size = 4
tv135 = -44						; size = 4
tv93 = -40						; size = 4
tv82 = -36						; size = 4
_this$ = -32						; size = 4
$T228251 = -28						; size = 4
_bResult$224259 = -21					; size = 1
_args$224258 = -20					; size = 4
_pkScriptSystem$224256 = -16				; size = 4
__$EHRec$ = -12						; size = 12
_eIndex$ = 8						; size = 4
_bNewValue$ = 12					; size = 1
?SetHasTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z PROC	; CvTeamTechs::SetHasTech, COMDAT
; _this$ = ecx

; 1967 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetHasTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1968 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 1969 : 	CvAssertMsg(eIndex < GC.getNumTechInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 1970 : 
; 1971 : 	if(m_pabHasTech[eIndex] != bNewValue)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _eIndex$[ebp]
	movzx	eax, BYTE PTR [ecx+edx]
	movzx	ecx, BYTE PTR _bNewValue$[ebp]
	cmp	eax, ecx
	je	$LN4@SetHasTech

; 1972 : 	{
; 1973 : 		m_pabHasTech[eIndex] = bNewValue;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _eIndex$[ebp]
	mov	dl, BYTE PTR _bNewValue$[ebp]
	mov	BYTE PTR [eax+ecx], dl

; 1974 : 
; 1975 : 		if(bNewValue)

	movzx	eax, BYTE PTR _bNewValue$[ebp]
	test	eax, eax
	je	SHORT $LN2@SetHasTech

; 1976 : 			SetLastTechAcquired(eIndex);

	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLastTechAcquired@CvTeamTechs@@QAEXW4TechTypes@@@Z ; CvTeamTechs::SetLastTechAcquired
$LN2@SetHasTech:

; 1977 : 
; 1978 : 		ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	edx, DWORD PTR $T228251[ebp]
	mov	DWORD PTR tv82[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv82[ebp], eax
	mov	ecx, DWORD PTR tv82[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv82[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pkScriptSystem$224256[ebp], eax

; 1979 : 		if(pkScriptSystem)

	cmp	DWORD PTR _pkScriptSystem$224256[ebp], 0
	je	$LN4@SetHasTech

; 1980 : 		{
; 1981 : 			CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$224258[ebp]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1982 : 			args->Push(m_pTeam->GetID());

	mov	ecx, DWORD PTR _args$224258[ebp]
	mov	DWORD PTR tv93[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+24]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	push	eax
	mov	eax, DWORD PTR tv93[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv93[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 1983 : 			args->Push(eIndex);

	mov	ecx, DWORD PTR _args$224258[ebp]
	mov	DWORD PTR tv135[ebp], ecx
	mov	edx, DWORD PTR _eIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR tv135[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv135[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 1984 : 			args->Push(bNewValue);

	mov	ecx, DWORD PTR _args$224258[ebp]
	mov	DWORD PTR tv142[ebp], ecx
	movzx	edx, BYTE PTR _bNewValue$[ebp]
	push	edx
	mov	eax, DWORD PTR tv142[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv142[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax

; 1985 : 
; 1986 : 			// Attempt to execute the game events.
; 1987 : 			// Will return false if there are no registered listeners.
; 1988 : 			bool bResult = false;

	mov	BYTE PTR _bResult$224259[ebp], 0

; 1989 : 			LuaSupport::CallHook(pkScriptSystem, "TeamSetHasTech", args.get(), bResult);

	lea	ecx, DWORD PTR _bResult$224259[ebp]
	push	ecx
	mov	edx, DWORD PTR _args$224258[ebp]
	push	edx
	push	OFFSET ??_C@_0P@EGCDAPHC@TeamSetHasTech?$AA@
	mov	eax, DWORD PTR _pkScriptSystem$224256[ebp]
	push	eax
	call	?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallHook
	add	esp, 16					; 00000010H

; 1990 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _args$224258[ebp]
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN4@SetHasTech:

; 1991 : 	}
; 1992 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetHasTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z$0:
	lea	ecx, DWORD PTR _args$224258[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__ehhandler$?SetHasTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetHasTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetHasTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z ENDP	; CvTeamTechs::SetHasTech
; Function compile flags: /Odtp
;	COMDAT ?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z PROC		; CvTeamTechs::HasTech, COMDAT
; _this$ = ecx

; 1996 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1997 : 	if(eIndex == NO_TECH)

	cmp	DWORD PTR _eIndex$[ebp], -1
	jne	SHORT $LN3@HasTech

; 1998 : 	{
; 1999 : 		return true;

	mov	al, 1
	jmp	SHORT $LN4@HasTech
$LN3@HasTech:

; 2000 : 	}
; 2001 : 
; 2002 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 2003 : 	CvAssertMsg(eIndex < GC.getNumTechInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 2004 : 	CvAssertMsg(m_pabHasTech != NULL, "m_pabHasTech is not expected to be equal with NULL");
; 2005 : 	if(m_pabHasTech != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN2@HasTech

; 2006 : 		return m_pabHasTech[eIndex];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _eIndex$[ebp]
	mov	al, BYTE PTR [edx+eax]
	jmp	SHORT $LN4@HasTech

; 2007 : 	else

	jmp	SHORT $LN4@HasTech
$LN2@HasTech:

; 2008 : 		return false;

	xor	al, al
$LN4@HasTech:

; 2009 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ENDP		; CvTeamTechs::HasTech
_TEXT	ENDS
PUBLIC	?GetLastTechAcquired@CvTeamTechs@@QBE?AW4TechTypes@@XZ ; CvTeamTechs::GetLastTechAcquired
; Function compile flags: /Odtp
;	COMDAT ?GetLastTechAcquired@CvTeamTechs@@QBE?AW4TechTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLastTechAcquired@CvTeamTechs@@QBE?AW4TechTypes@@XZ PROC ; CvTeamTechs::GetLastTechAcquired, COMDAT
; _this$ = ecx

; 2013 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2014 : 	return m_eLastTechAcquired;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 2015 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetLastTechAcquired@CvTeamTechs@@QBE?AW4TechTypes@@XZ ENDP ; CvTeamTechs::GetLastTechAcquired
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?SetLastTechAcquired@CvTeamTechs@@QAEXW4TechTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eTech$ = 8						; size = 4
?SetLastTechAcquired@CvTeamTechs@@QAEXW4TechTypes@@@Z PROC ; CvTeamTechs::SetLastTechAcquired, COMDAT
; _this$ = ecx

; 2019 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2020 : 	CvAssertMsg(eTech >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 2021 : 	CvAssertMsg(eTech < GC.getNumTechInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 2022 : 
; 2023 : 	m_eLastTechAcquired = eTech;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _eTech$[ebp]
	mov	DWORD PTR [eax], ecx

; 2024 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetLastTechAcquired@CvTeamTechs@@QAEXW4TechTypes@@@Z ENDP ; CvTeamTechs::SetLastTechAcquired
_TEXT	ENDS
PUBLIC	?GetNumTechsKnown@CvTeamTechs@@QBEHXZ		; CvTeamTechs::GetNumTechsKnown
; Function compile flags: /Odtp
;	COMDAT ?GetNumTechsKnown@CvTeamTechs@@QBEHXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_iTechLoop$224279 = -8					; size = 4
_iNumTechs$ = -4					; size = 4
?GetNumTechsKnown@CvTeamTechs@@QBEHXZ PROC		; CvTeamTechs::GetNumTechsKnown, COMDAT
; _this$ = ecx

; 2028 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2029 : 	int iNumTechs = 0;

	mov	DWORD PTR _iNumTechs$[ebp], 0

; 2030 : 
; 2031 : #ifdef AUI_WARNING_FIXES
; 2032 : 	for (uint iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)
; 2033 : #else
; 2034 : 	for(int iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)

	mov	DWORD PTR _iTechLoop$224279[ebp], 0
	jmp	SHORT $LN4@GetNumTech@2
$LN3@GetNumTech@2:
	mov	eax, DWORD PTR _iTechLoop$224279[ebp]
	add	eax, 1
	mov	DWORD PTR _iTechLoop$224279[ebp], eax
$LN4@GetNumTech@2:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	cmp	DWORD PTR _iTechLoop$224279[ebp], eax
	jge	SHORT $LN2@GetNumTech@2

; 2035 : #endif
; 2036 : 	{
; 2037 : 		if(HasTech((TechTypes) iTechLoop))

	mov	ecx, DWORD PTR _iTechLoop$224279[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@GetNumTech@2

; 2038 : 		{
; 2039 : 			iNumTechs++;

	mov	eax, DWORD PTR _iNumTechs$[ebp]
	add	eax, 1
	mov	DWORD PTR _iNumTechs$[ebp], eax
$LN1@GetNumTech@2:

; 2040 : 		}
; 2041 : 	}

	jmp	SHORT $LN3@GetNumTech@2
$LN2@GetNumTech@2:

; 2042 : 
; 2043 : 	return iNumTechs;

	mov	eax, DWORD PTR _iNumTechs$[ebp]

; 2044 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumTechsKnown@CvTeamTechs@@QBEHXZ ENDP		; CvTeamTechs::GetNumTechsKnown
_TEXT	ENDS
PUBLIC	?HasResearchedAllTechs@CvTeamTechs@@QBE_NXZ	; CvTeamTechs::HasResearchedAllTechs
; Function compile flags: /Odtp
;	COMDAT ?HasResearchedAllTechs@CvTeamTechs@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_iTechLoop$224289 = -8					; size = 4
_iNumTechs$ = -4					; size = 4
?HasResearchedAllTechs@CvTeamTechs@@QBE_NXZ PROC	; CvTeamTechs::HasResearchedAllTechs, COMDAT
; _this$ = ecx

; 2048 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2049 : #ifdef AUI_WARNING_FIXES
; 2050 : 	uint iNumTechs = 0;
; 2051 : 	for (uint iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)
; 2052 : #else
; 2053 : 	int iNumTechs = 0;

	mov	DWORD PTR _iNumTechs$[ebp], 0

; 2054 : 
; 2055 : 	for(int iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)

	mov	DWORD PTR _iTechLoop$224289[ebp], 0
	jmp	SHORT $LN5@HasResearc
$LN4@HasResearc:
	mov	eax, DWORD PTR _iTechLoop$224289[ebp]
	add	eax, 1
	mov	DWORD PTR _iTechLoop$224289[ebp], eax
$LN5@HasResearc:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	cmp	DWORD PTR _iTechLoop$224289[ebp], eax
	jge	SHORT $LN3@HasResearc

; 2056 : #endif
; 2057 : 	{
; 2058 : 		if(HasTech((TechTypes) iTechLoop) || GetTechCount((TechTypes)iTechLoop) > 0)

	mov	ecx, DWORD PTR _iTechLoop$224289[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN1@HasResearc
	mov	eax, DWORD PTR _iTechLoop$224289[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTechCount@CvTeamTechs@@QBEHW4TechTypes@@@Z ; CvTeamTechs::GetTechCount
	test	eax, eax
	jle	SHORT $LN2@HasResearc
$LN1@HasResearc:

; 2059 : 		{
; 2060 : 			iNumTechs++;

	mov	ecx, DWORD PTR _iNumTechs$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iNumTechs$[ebp], ecx
$LN2@HasResearc:

; 2061 : 		}
; 2062 : 	}

	jmp	SHORT $LN4@HasResearc
$LN3@HasResearc:

; 2063 : 
; 2064 : 	return (iNumTechs >= m_pTechs->GetNumTechs());

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	xor	ecx, ecx
	cmp	DWORD PTR _iNumTechs$[ebp], eax
	setge	cl
	mov	al, cl

; 2065 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?HasResearchedAllTechs@CvTeamTechs@@QBE_NXZ ENDP	; CvTeamTechs::HasResearchedAllTechs
_TEXT	ENDS
PUBLIC	?SetNoTradeTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z ; CvTeamTechs::SetNoTradeTech
; Function compile flags: /Odtp
;	COMDAT ?SetNoTradeTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
_bNewValue$ = 12					; size = 1
?SetNoTradeTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z PROC	; CvTeamTechs::SetNoTradeTech, COMDAT
; _this$ = ecx

; 2069 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2070 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 2071 : 	CvAssertMsg(eIndex < GC.getNumTechInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 2072 : 
; 2073 : 	if(m_pabNoTradeTech[eIndex] != bNewValue)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _eIndex$[ebp]
	movzx	eax, BYTE PTR [ecx+edx]
	movzx	ecx, BYTE PTR _bNewValue$[ebp]
	cmp	eax, ecx
	je	SHORT $LN2@SetNoTrade

; 2074 : 	{
; 2075 : 		m_pabNoTradeTech[eIndex] = bNewValue;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _eIndex$[ebp]
	mov	dl, BYTE PTR _bNewValue$[ebp]
	mov	BYTE PTR [eax+ecx], dl
$LN2@SetNoTrade:

; 2076 : 	}
; 2077 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetNoTradeTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z ENDP	; CvTeamTechs::SetNoTradeTech
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsNoTradeTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?IsNoTradeTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z PROC	; CvTeamTechs::IsNoTradeTech, COMDAT
; _this$ = ecx

; 2081 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2082 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 2083 : 	CvAssertMsg(eIndex < GC.getNumTechInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 2084 : 	return m_pabNoTradeTech[eIndex];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	al, BYTE PTR [ecx+edx]

; 2085 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsNoTradeTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ENDP	; CvTeamTechs::IsNoTradeTech
_TEXT	ENDS
PUBLIC	?IncrementTechCount@CvTeamTechs@@QAEXW4TechTypes@@@Z ; CvTeamTechs::IncrementTechCount
; Function compile flags: /Odtp
;	COMDAT ?IncrementTechCount@CvTeamTechs@@QAEXW4TechTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?IncrementTechCount@CvTeamTechs@@QAEXW4TechTypes@@@Z PROC ; CvTeamTechs::IncrementTechCount, COMDAT
; _this$ = ecx

; 2089 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2090 : 	m_paiTechCount[eIndex]++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _eIndex$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 2091 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IncrementTechCount@CvTeamTechs@@QAEXW4TechTypes@@@Z ENDP ; CvTeamTechs::IncrementTechCount
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetTechCount@CvTeamTechs@@QBEHW4TechTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?GetTechCount@CvTeamTechs@@QBEHW4TechTypes@@@Z PROC	; CvTeamTechs::GetTechCount, COMDAT
; _this$ = ecx

; 2095 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2096 : 	return m_paiTechCount[eIndex];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 2097 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetTechCount@CvTeamTechs@@QBEHW4TechTypes@@@Z ENDP	; CvTeamTechs::GetTechCount
_TEXT	ENDS
PUBLIC	?SetResearchProgressTimes100@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z ; CvTeamTechs::SetResearchProgressTimes100
PUBLIC	?SetResearchProgress@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z ; CvTeamTechs::SetResearchProgress
; Function compile flags: /Odtp
;	COMDAT ?SetResearchProgress@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
_iNewValue$ = 12					; size = 4
_ePlayer$ = 16						; size = 4
?SetResearchProgress@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z PROC ; CvTeamTechs::SetResearchProgress, COMDAT
; _this$ = ecx

; 2101 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2102 : 	SetResearchProgressTimes100(eIndex, iNewValue * 100, ePlayer);

	mov	eax, DWORD PTR _ePlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iNewValue$[ebp]
	imul	ecx, 100				; 00000064H
	push	ecx
	mov	edx, DWORD PTR _eIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetResearchProgressTimes100@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z ; CvTeamTechs::SetResearchProgressTimes100

; 2103 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetResearchProgress@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z ENDP ; CvTeamTechs::SetResearchProgress
_TEXT	ENDS
PUBLIC	?GetMaxResearchOverflow@CvTeamTechs@@ABEHW4TechTypes@@W4PlayerTypes@@@Z ; CvTeamTechs::GetMaxResearchOverflow
PUBLIC	?GetResearchProgressTimes100@CvTeamTechs@@QBEHW4TechTypes@@@Z ; CvTeamTechs::GetResearchProgressTimes100
EXTRN	?changeJONSCulture@CvPlayer@@QAEXH@Z:PROC	; CvPlayer::changeJONSCulture
EXTRN	?GetCulturePerTechResearched@CvPlayer@@QBEHXZ:PROC ; CvPlayer::GetCulturePerTechResearched
EXTRN	?SetSpecializationsDirty@CvCitySpecializationAI@@QAEXW4CitySpecializationUpdateType@@@Z:PROC ; CvCitySpecializationAI::SetSpecializationsDirty
EXTRN	?GetCitySpecializationAI@CvPlayer@@QBEPAVCvCitySpecializationAI@@XZ:PROC ; CvPlayer::GetCitySpecializationAI
EXTRN	?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z:PROC ; CvTeam::setHasTech
EXTRN	?changeOverflowResearchTimes100@CvPlayer@@QAEXH@Z:PROC ; CvPlayer::changeOverflowResearchTimes100
EXTRN	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ:PROC ; CvGame::getActiveTeam
; Function compile flags: /Odtp
;	COMDAT ?SetResearchProgressTimes100@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z
_TEXT	SEGMENT
tv130 = -68						; size = 4
tv86 = -64						; size = 4
_this$ = -60						; size = 4
$T228314 = -56						; size = 4
$T228307 = -52						; size = 4
$T228303 = -48						; size = 4
$T228299 = -44						; size = 4
$T228295 = -40						; size = 4
_kLoopPlayer$224343 = -36				; size = 4
_iPlayerLoop$224338 = -32				; size = 4
_iCulture$224336 = -28					; size = 4
_eTeamID$224337 = -24					; size = 4
_eLoopPlayer$224335 = -20				; size = 4
_iMaxOverflow$224332 = -16				; size = 4
_iResearchCost$224330 = -12				; size = 4
_iResearchProgress$224329 = -8				; size = 4
_iOverflow$224331 = -4					; size = 4
_eIndex$ = 8						; size = 4
_iNewValue$ = 12					; size = 4
_ePlayer$ = 16						; size = 4
?SetResearchProgressTimes100@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z PROC ; CvTeamTechs::SetResearchProgressTimes100, COMDAT
; _this$ = ecx

; 2107 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2108 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 2109 : 	CvAssertMsg(eIndex < GC.getNumTechInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 2110 : 	CvAssertMsg(ePlayer >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 2111 : 	CvAssertMsg(ePlayer < MAX_PLAYERS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 2112 : 
; 2113 : 	if(GetResearchProgressTimes100(eIndex) != iNewValue)

	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetResearchProgressTimes100@CvTeamTechs@@QBEHW4TechTypes@@@Z ; CvTeamTechs::GetResearchProgressTimes100
	cmp	eax, DWORD PTR _iNewValue$[ebp]
	je	$LN10@SetResearc@2

; 2114 : 	{
; 2115 : 		m_paiResearchProgress[eIndex] = iNewValue;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _eIndex$[ebp]
	mov	ecx, DWORD PTR _iNewValue$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 2116 : 		CvAssert(GetResearchProgressTimes100(eIndex) >= 0);
; 2117 : 
; 2118 : 		if(m_pTeam->GetID() == GC.getGame().getActiveTeam())

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T228295[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	mov	esi, eax
	mov	ecx, DWORD PTR $T228295[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	esi, eax
	jne	SHORT $LN8@SetResearc@2

; 2119 : 		{
; 2120 : 			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	mov	ecx, DWORD PTR $T228299[ebp]
	mov	DWORD PTR tv86[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv86[ebp], edx
	push	1
	push	11					; 0000000bH
	mov	eax, DWORD PTR tv86[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv86[ebp]
	mov	eax, DWORD PTR [edx+260]
	call	eax

; 2121 : 			GC.GetEngineUserInterface()->setDirty(Score_DIRTY_BIT, true);

	mov	ecx, DWORD PTR $T228303[ebp]
	mov	DWORD PTR tv130[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv130[ebp], edx
	push	1
	push	12					; 0000000cH
	mov	eax, DWORD PTR tv130[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv130[ebp]
	mov	eax, DWORD PTR [edx+260]
	call	eax
$LN8@SetResearc@2:

; 2122 : 		}
; 2123 : 
; 2124 : 		int iResearchProgress = GetResearchProgressTimes100(eIndex);

	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetResearchProgressTimes100@CvTeamTechs@@QBEHW4TechTypes@@@Z ; CvTeamTechs::GetResearchProgressTimes100
	mov	DWORD PTR _iResearchProgress$224329[ebp], eax

; 2125 : #ifdef AUI_TECH_FIX_PLAYER_BASED_RESEARCH_COST_ONLY_AESTHETIC
; 2126 : 		int iResearchCost = GET_PLAYER(ePlayer).GetPlayerTechs()->GetResearchCost(eIndex) * 100;

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T228307[ebp], edx
	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T228307[ebp]
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?GetResearchCost@CvPlayerTechs@@QBEHW4TechTypes@@@Z ; CvPlayerTechs::GetResearchCost
	imul	eax, 100				; 00000064H
	mov	DWORD PTR _iResearchCost$224330[ebp], eax

; 2127 : #else
; 2128 : 		int iResearchCost = GetResearchCost(eIndex) * 100;
; 2129 : 
; 2130 : 		// Player modifiers to cost
; 2131 : 		int iResearchMod = std::max(1, GET_PLAYER(ePlayer).calculateResearchModifier(eIndex));
; 2132 : 		iResearchCost = (iResearchCost * 100) / iResearchMod;
; 2133 : 		int iNumCitiesMod = GC.getMap().getWorldInfo().GetNumCitiesTechCostMod();	// Default is 40, gets smaller on larger maps
; 2134 : 		iNumCitiesMod = iNumCitiesMod * GET_PLAYER(ePlayer).GetMaxEffectiveCities(/*bIncludePuppets*/ true);
; 2135 : 		iResearchCost = iResearchCost * (100 + iNumCitiesMod) / 100;
; 2136 : #endif
; 2137 : 		
; 2138 : 		int iOverflow = iResearchProgress - iResearchCost;

	mov	ecx, DWORD PTR _iResearchProgress$224329[ebp]
	sub	ecx, DWORD PTR _iResearchCost$224330[ebp]
	mov	DWORD PTR _iOverflow$224331[ebp], ecx

; 2139 : 
; 2140 : 		// April 2014 Balance Patch change - EFB
; 2141 : 		//    Don't allow the overflow to get out of hand
; 2142 : 		int iMaxOverflow = GetMaxResearchOverflow(eIndex, ePlayer);

	mov	edx, DWORD PTR _ePlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMaxResearchOverflow@CvTeamTechs@@ABEHW4TechTypes@@W4PlayerTypes@@@Z ; CvTeamTechs::GetMaxResearchOverflow
	mov	DWORD PTR _iMaxOverflow$224332[ebp], eax

; 2143 : 		if (iOverflow > iMaxOverflow)

	mov	ecx, DWORD PTR _iOverflow$224331[ebp]
	cmp	ecx, DWORD PTR _iMaxOverflow$224332[ebp]
	jle	SHORT $LN7@SetResearc@2

; 2144 : 		{
; 2145 : 			iOverflow = iMaxOverflow;

	mov	edx, DWORD PTR _iMaxOverflow$224332[ebp]
	mov	DWORD PTR _iOverflow$224331[ebp], edx
$LN7@SetResearc@2:

; 2146 : 		}
; 2147 : 
; 2148 : 		if(iOverflow >= 0)

	cmp	DWORD PTR _iOverflow$224331[ebp], 0
	jl	$LN10@SetResearc@2

; 2149 : 		{
; 2150 : 			GET_PLAYER(ePlayer).changeOverflowResearchTimes100(iOverflow);

	mov	eax, DWORD PTR _iOverflow$224331[ebp]
	push	eax
	mov	ecx, DWORD PTR _ePlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?changeOverflowResearchTimes100@CvPlayer@@QAEXH@Z ; CvPlayer::changeOverflowResearchTimes100

; 2151 : 			m_pTeam->setHasTech(eIndex, true, ePlayer, true, true);

	push	1
	push	1
	mov	ecx, DWORD PTR _ePlayer$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _eIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	call	?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z ; CvTeam::setHasTech

; 2152 : 			SetNoTradeTech(eIndex, true);

	push	1
	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetNoTradeTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z ; CvTeamTechs::SetNoTradeTech

; 2153 : 
; 2154 : 			// Mark city specialization dirty
; 2155 : 			GET_PLAYER(ePlayer).GetCitySpecializationAI()->SetSpecializationsDirty(SPECIALIZATION_UPDATE_RESEARCH_COMPLETE);

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T228314[ebp], edx
	push	7
	mov	ecx, DWORD PTR $T228314[ebp]
	call	?GetCitySpecializationAI@CvPlayer@@QBEPAVCvCitySpecializationAI@@XZ ; CvPlayer::GetCitySpecializationAI
	mov	ecx, eax
	call	?SetSpecializationsDirty@CvCitySpecializationAI@@QAEXW4CitySpecializationUpdateType@@@Z ; CvCitySpecializationAI::SetSpecializationsDirty

; 2156 : 
; 2157 : 			// Culture bonus for Player researching a Tech
; 2158 : 			PlayerTypes eLoopPlayer;
; 2159 : 			int iCulture;
; 2160 : 			TeamTypes eTeamID = m_pTeam->GetID();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	mov	DWORD PTR _eTeamID$224337[ebp], eax

; 2161 : 			for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	mov	DWORD PTR _iPlayerLoop$224338[ebp], 0
	jmp	SHORT $LN5@SetResearc@2
$LN4@SetResearc@2:
	mov	ecx, DWORD PTR _iPlayerLoop$224338[ebp]
	add	ecx, 1
	mov	DWORD PTR _iPlayerLoop$224338[ebp], ecx
$LN5@SetResearc@2:
	cmp	DWORD PTR _iPlayerLoop$224338[ebp], 22	; 00000016H
	jge	SHORT $LN10@SetResearc@2

; 2162 : 			{
; 2163 : 				eLoopPlayer = (PlayerTypes) iPlayerLoop;

	mov	edx, DWORD PTR _iPlayerLoop$224338[ebp]
	mov	DWORD PTR _eLoopPlayer$224335[ebp], edx

; 2164 : 				CvPlayerAI& kLoopPlayer = GET_PLAYER(eLoopPlayer);

	mov	eax, DWORD PTR _eLoopPlayer$224335[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kLoopPlayer$224343[ebp], eax

; 2165 : 
; 2166 : 				if(kLoopPlayer.getTeam() == eTeamID)

	mov	ecx, DWORD PTR _kLoopPlayer$224343[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	eax, DWORD PTR _eTeamID$224337[ebp]
	jne	SHORT $LN2@SetResearc@2

; 2167 : 				{
; 2168 : 					iCulture = kLoopPlayer.GetCulturePerTechResearched();

	mov	ecx, DWORD PTR _kLoopPlayer$224343[ebp]
	call	?GetCulturePerTechResearched@CvPlayer@@QBEHXZ ; CvPlayer::GetCulturePerTechResearched
	mov	DWORD PTR _iCulture$224336[ebp], eax

; 2169 : 					if(iCulture != 0)

	cmp	DWORD PTR _iCulture$224336[ebp], 0
	je	SHORT $LN2@SetResearc@2

; 2170 : 					{
; 2171 : 						kLoopPlayer.changeJONSCulture(iCulture);

	mov	eax, DWORD PTR _iCulture$224336[ebp]
	push	eax
	mov	ecx, DWORD PTR _kLoopPlayer$224343[ebp]
	call	?changeJONSCulture@CvPlayer@@QAEXH@Z	; CvPlayer::changeJONSCulture
$LN2@SetResearc@2:

; 2172 : 					}
; 2173 : 				}
; 2174 : 			}

	jmp	SHORT $LN4@SetResearc@2
$LN10@SetResearc@2:

; 2175 : 		}
; 2176 : 	}
; 2177 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetResearchProgressTimes100@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z ENDP ; CvTeamTechs::SetResearchProgressTimes100
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetResearchProgress@CvTeamTechs@@QBEHW4TechTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?GetResearchProgress@CvTeamTechs@@QBEHW4TechTypes@@@Z PROC ; CvTeamTechs::GetResearchProgress, COMDAT
; _this$ = ecx

; 2181 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2182 : 	if(eIndex != NO_TECH)

	cmp	DWORD PTR _eIndex$[ebp], -1
	je	SHORT $LN2@GetResearc@4

; 2183 : 	{
; 2184 : 		return m_paiResearchProgress[eIndex] / 100;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	jmp	SHORT $LN3@GetResearc@4

; 2185 : 	}
; 2186 : 	else

	jmp	SHORT $LN3@GetResearc@4
$LN2@GetResearc@4:

; 2187 : 	{
; 2188 : 		return 0;

	xor	eax, eax
$LN3@GetResearc@4:

; 2189 : 	}
; 2190 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetResearchProgress@CvTeamTechs@@QBEHW4TechTypes@@@Z ENDP ; CvTeamTechs::GetResearchProgress
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetResearchProgressTimes100@CvTeamTechs@@QBEHW4TechTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?GetResearchProgressTimes100@CvTeamTechs@@QBEHW4TechTypes@@@Z PROC ; CvTeamTechs::GetResearchProgressTimes100, COMDAT
; _this$ = ecx

; 2194 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2195 : 	if(eIndex != NO_TECH)

	cmp	DWORD PTR _eIndex$[ebp], -1
	je	SHORT $LN2@GetResearc@5

; 2196 : 	{
; 2197 : 		return m_paiResearchProgress[eIndex];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN3@GetResearc@5

; 2198 : 	}
; 2199 : 	else

	jmp	SHORT $LN3@GetResearc@5
$LN2@GetResearc@5:

; 2200 : 	{
; 2201 : 		return 0;

	xor	eax, eax
$LN3@GetResearc@5:

; 2202 : 	}
; 2203 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetResearchProgressTimes100@CvTeamTechs@@QBEHW4TechTypes@@@Z ENDP ; CvTeamTechs::GetResearchProgressTimes100
_TEXT	ENDS
EXTRN	?getNumMembers@CvTeam@@QBEHXZ:PROC		; CvTeam::getNumMembers
EXTRN	?getResearchPercent@CvEraInfo@@QBEHXZ:PROC	; CvEraInfo::getResearchPercent
EXTRN	?getStartEraInfo@CvGame@@QBEAAVCvEraInfo@@XZ:PROC ; CvGame::getStartEraInfo
EXTRN	?getResearchPercent@CvGameSpeedInfo@@QBEHXZ:PROC ; CvGameSpeedInfo::getResearchPercent
EXTRN	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ:PROC ; CvGame::getGameSpeedInfo
EXTRN	?getResearchPercent@CvWorldInfo@@QBEHXZ:PROC	; CvWorldInfo::getResearchPercent
EXTRN	?getResearchPercent@CvHandicapInfo@@QBEHXZ:PROC	; CvHandicapInfo::getResearchPercent
EXTRN	?getHandicapInfo@CvGlobals@@QAEPAVCvHandicapInfo@@W4HandicapTypes@@@Z:PROC ; CvGlobals::getHandicapInfo
EXTRN	?getHandicapType@CvTeam@@QBE?AW4HandicapTypes@@XZ:PROC ; CvTeam::getHandicapType
; Function compile flags: /Odtp
;	COMDAT ?GetResearchCost@CvTeamTechs@@QBEHW4TechTypes@@@Z
_TEXT	SEGMENT
tv147 = -60						; size = 4
tv154 = -56						; size = 4
_this$ = -52						; size = 4
$T228365 = -48						; size = 4
$T228355 = -44						; size = 4
$T228350 = -40						; size = 4
$T228346 = -36						; size = 4
$T228342 = -32						; size = 4
$T228338 = -28						; size = 4
$T228334 = -24						; size = 4
$T228333 = -20						; size = 4
$T228332 = -16						; size = 4
_pkTechInfo$ = -12					; size = 4
_pkHandicapInfo$ = -8					; size = 4
_iCost$ = -4						; size = 4
_eTech$ = 8						; size = 4
?GetResearchCost@CvTeamTechs@@QBEHW4TechTypes@@@Z PROC	; CvTeamTechs::GetResearchCost, COMDAT
; _this$ = ecx

; 2207 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	DWORD PTR _this$[ebp], ecx

; 2208 : 	CvAssertMsg(eTech != NO_TECH, "Tech is not assigned a valid value");
; 2209 : 	CvTechEntry* pkTechInfo = GC.getTechInfo(eTech);

	mov	eax, DWORD PTR _eTech$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo
	mov	DWORD PTR _pkTechInfo$[ebp], eax

; 2210 : 	if(pkTechInfo == NULL)

	cmp	DWORD PTR _pkTechInfo$[ebp], 0
	jne	SHORT $LN2@GetResearc@6

; 2211 : 	{
; 2212 : 		return 0;

	xor	eax, eax
	jmp	$LN3@GetResearc@6
$LN2@GetResearc@6:

; 2213 : 	}
; 2214 : 
; 2215 : 	int iCost = pkTechInfo->GetResearchCost();

	mov	ecx, DWORD PTR _pkTechInfo$[ebp]
	call	?GetResearchCost@CvTechEntry@@QBEHXZ	; CvTechEntry::GetResearchCost
	mov	DWORD PTR _iCost$[ebp], eax

; 2216 : 
; 2217 : 	CvHandicapInfo* pkHandicapInfo = GC.getHandicapInfo(m_pTeam->getHandicapType());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+24]
	call	?getHandicapType@CvTeam@@QBE?AW4HandicapTypes@@XZ ; CvTeam::getHandicapType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getHandicapInfo@CvGlobals@@QAEPAVCvHandicapInfo@@W4HandicapTypes@@@Z ; CvGlobals::getHandicapInfo
	mov	DWORD PTR _pkHandicapInfo$[ebp], eax

; 2218 : 	if(pkHandicapInfo)

	cmp	DWORD PTR _pkHandicapInfo$[ebp], 0
	je	SHORT $LN1@GetResearc@6

; 2219 : 	{
; 2220 : 		iCost *= pkHandicapInfo->getResearchPercent();

	mov	ecx, DWORD PTR _pkHandicapInfo$[ebp]
	call	?getResearchPercent@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getResearchPercent
	imul	eax, DWORD PTR _iCost$[ebp]
	mov	DWORD PTR _iCost$[ebp], eax

; 2221 : 		iCost /= 100;

	mov	eax, DWORD PTR _iCost$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iCost$[ebp], eax
$LN1@GetResearc@6:

; 2222 : 	}
; 2223 : 
; 2224 : 	//here
; 2225 : 
; 2226 : 	iCost *= GC.getMap().getWorldInfo().getResearchPercent();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T228338[ebp], edx
	mov	ecx, DWORD PTR $T228338[ebp]
	call	?getWorldInfo@CvMap@@QBEABVCvWorldInfo@@XZ ; CvMap::getWorldInfo
	mov	ecx, eax
	call	?getResearchPercent@CvWorldInfo@@QBEHXZ	; CvWorldInfo::getResearchPercent
	imul	eax, DWORD PTR _iCost$[ebp]
	mov	DWORD PTR _iCost$[ebp], eax

; 2227 : 	iCost /= 100;

	mov	eax, DWORD PTR _iCost$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iCost$[ebp], eax

; 2228 : 
; 2229 : 	iCost *= GC.getGame().getGameSpeedInfo().getResearchPercent();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T228342[ebp], edx
	mov	ecx, DWORD PTR $T228342[ebp]
	call	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ ; CvGame::getGameSpeedInfo
	mov	ecx, eax
	call	?getResearchPercent@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getResearchPercent
	imul	eax, DWORD PTR _iCost$[ebp]
	mov	DWORD PTR _iCost$[ebp], eax

; 2230 : 	iCost /= 100;

	mov	eax, DWORD PTR _iCost$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iCost$[ebp], eax

; 2231 : 
; 2232 : 	iCost *= GC.getGame().getStartEraInfo().getResearchPercent();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T228346[ebp], edx
	mov	ecx, DWORD PTR $T228346[ebp]
	call	?getStartEraInfo@CvGame@@QBEAAVCvEraInfo@@XZ ; CvGame::getStartEraInfo
	mov	ecx, eax
	call	?getResearchPercent@CvEraInfo@@QBEHXZ	; CvEraInfo::getResearchPercent
	imul	eax, DWORD PTR _iCost$[ebp]
	mov	DWORD PTR _iCost$[ebp], eax

; 2233 : 	iCost /= 100;

	mov	eax, DWORD PTR _iCost$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iCost$[ebp], eax

; 2234 : 
; 2235 : 	iCost *= std::max(0, ((GC.getTECH_COST_EXTRA_TEAM_MEMBER_MODIFIER() * (m_pTeam->getNumMembers() - 1)) + 100));

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6676
	mov	DWORD PTR $T228350[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	call	?getNumMembers@CvTeam@@QBEHXZ		; CvTeam::getNumMembers
	sub	eax, 1
	imul	eax, DWORD PTR $T228350[ebp]
	add	eax, 100				; 00000064H
	mov	DWORD PTR $T228332[ebp], eax
	mov	DWORD PTR $T228333[ebp], 0
	mov	ecx, DWORD PTR $T228333[ebp]
	cmp	ecx, DWORD PTR $T228332[ebp]
	jge	SHORT $LN15@GetResearc@6
	lea	edx, DWORD PTR $T228332[ebp]
	mov	DWORD PTR tv154[ebp], edx
	jmp	SHORT $LN16@GetResearc@6
$LN15@GetResearc@6:
	lea	eax, DWORD PTR $T228333[ebp]
	mov	DWORD PTR tv154[ebp], eax
$LN16@GetResearc@6:
	mov	ecx, DWORD PTR tv154[ebp]
	mov	DWORD PTR $T228355[ebp], ecx
	mov	edx, DWORD PTR $T228355[ebp]
	mov	eax, DWORD PTR _iCost$[ebp]
	imul	eax, DWORD PTR [edx]
	mov	DWORD PTR _iCost$[ebp], eax

; 2236 : 	iCost /= 100;

	mov	eax, DWORD PTR _iCost$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iCost$[ebp], eax

; 2237 : 
; 2238 : #ifdef AUI_TECH_FIX_TEAMER_RESEARCH_COSTS
; 2239 : 	// Adjust to the players' research modifier
; 2240 : 	int iResearchMod = MAX(1, m_pTeam->calculateResearchModifier(eTech));
; 2241 : 	iCost = (iCost * 10000) / iResearchMod;
; 2242 : 
; 2243 : 	// Mod for City Count
; 2244 : 	int iCityCountMod = GC.getMap().getWorldInfo().GetNumCitiesTechCostMod();	// Default is 40, gets smaller on larger maps
; 2245 : 
; 2246 : 	// NQMP GJS - new Dictatorship of the Proletariat i.e. Communism BEGIN
; 2247 : 	int iWeightedResearchModDiscount = 0;
; 2248 : 	int iCityCount = 0;
; 2249 : 	int iLoopCityCount = 0;
; 2250 : 	for (int iI = 0; iI < MAX_CIV_PLAYERS; iI++)
; 2251 : 	{
; 2252 : 		CvPlayer& kLoopPlayer = GET_PLAYER((PlayerTypes)iI);
; 2253 : 		if (kLoopPlayer.getTeam() == m_pTeam->GetID())
; 2254 : 		{
; 2255 : 			iLoopCityCount = kLoopPlayer.GetMaxEffectiveCities(/*bIncludePuppets*/ true);
; 2256 : 			iCityCount += iLoopCityCount;
; 2257 : 			iWeightedResearchModDiscount += kLoopPlayer.GetNumCitiesResearchCostDiscount() * iLoopCityCount;
; 2258 : 		}
; 2259 : 	}
; 2260 : 	if (iCityCount > 0)
; 2261 : 	{
; 2262 : 		if (iWeightedResearchModDiscount != 0)
; 2263 : 		{
; 2264 : 			iCityCountMod = iCityCountMod * ((100 * iCityCount) + iWeightedResearchModDiscount) / iCityCount;
; 2265 : 			iCityCountMod /= 100;
; 2266 : 		}
; 2267 : 	}
; 2268 : 	// NQMP GJS - new Dictatorship of the Proletariat i.e. Communism END
; 2269 : 
; 2270 : 	iCityCountMod *= iCityCount;
; 2271 : 	iCost = iCost * (100 + iCityCountMod) / 100;
; 2272 : 
; 2273 : 	// We're going to round up so that the user wont get confused when the research progress seems to be equal to the research cost, but it is not acutally done.
; 2274 : 	// This is because the 'real' calculations use the GameCore's fixed point math where things are multiplied by 100
; 2275 : 	if ((iCost % 100) != 0)
; 2276 : 		iCost = (iCost / 100) + 1;
; 2277 : 	else
; 2278 : 		iCost = (iCost / 100);
; 2279 : #endif
; 2280 : 
; 2281 : 	return std::max(1, iCost);

	mov	DWORD PTR $T228334[ebp], 1
	mov	edx, DWORD PTR $T228334[ebp]
	cmp	edx, DWORD PTR _iCost$[ebp]
	jge	SHORT $LN19@GetResearc@6
	lea	eax, DWORD PTR _iCost$[ebp]
	mov	DWORD PTR tv147[ebp], eax
	jmp	SHORT $LN20@GetResearc@6
$LN19@GetResearc@6:
	lea	ecx, DWORD PTR $T228334[ebp]
	mov	DWORD PTR tv147[ebp], ecx
$LN20@GetResearc@6:
	mov	edx, DWORD PTR tv147[ebp]
	mov	DWORD PTR $T228365[ebp], edx
	mov	eax, DWORD PTR $T228365[ebp]
	mov	eax, DWORD PTR [eax]
$LN3@GetResearc@6:

; 2282 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetResearchCost@CvTeamTechs@@QBEHW4TechTypes@@@Z ENDP	; CvTeamTechs::GetResearchCost
_TEXT	ENDS
PUBLIC	?GetResearchLeft@CvTeamTechs@@QBEHW4TechTypes@@@Z ; CvTeamTechs::GetResearchLeft
; Function compile flags: /Odtp
;	COMDAT ?GetResearchLeft@CvTeamTechs@@QBEHW4TechTypes@@@Z
_TEXT	SEGMENT
tv75 = -20						; size = 4
_this$ = -16						; size = 4
$T228378 = -12						; size = 4
$T228372 = -8						; size = 4
$T228371 = -4						; size = 4
_eTech$ = 8						; size = 4
?GetResearchLeft@CvTeamTechs@@QBEHW4TechTypes@@@Z PROC	; CvTeamTechs::GetResearchLeft, COMDAT
; _this$ = ecx

; 2286 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2287 : 	return std::max(0, (GetResearchCost(eTech) - GetResearchProgress(eTech)));

	mov	eax, DWORD PTR _eTech$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetResearchCost@CvTeamTechs@@QBEHW4TechTypes@@@Z ; CvTeamTechs::GetResearchCost
	mov	esi, eax
	mov	ecx, DWORD PTR _eTech$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetResearchProgress@CvTeamTechs@@QBEHW4TechTypes@@@Z ; CvTeamTechs::GetResearchProgress
	sub	esi, eax
	mov	DWORD PTR $T228371[ebp], esi
	mov	DWORD PTR $T228372[ebp], 0
	mov	edx, DWORD PTR $T228372[ebp]
	cmp	edx, DWORD PTR $T228371[ebp]
	jge	SHORT $LN5@GetResearc@7
	lea	eax, DWORD PTR $T228371[ebp]
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN6@GetResearc@7
$LN5@GetResearc@7:
	lea	ecx, DWORD PTR $T228372[ebp]
	mov	DWORD PTR tv75[ebp], ecx
$LN6@GetResearc@7:
	mov	edx, DWORD PTR tv75[ebp]
	mov	DWORD PTR $T228378[ebp], edx
	mov	eax, DWORD PTR $T228378[ebp]
	mov	eax, DWORD PTR [eax]

; 2288 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?GetResearchLeft@CvTeamTechs@@QBEHW4TechTypes@@@Z ENDP	; CvTeamTechs::GetResearchLeft
_TEXT	ENDS
PUBLIC	?GetTechs@CvTeamTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvTeamTechs::GetTechs
; Function compile flags: /Odtp
;	COMDAT ?GetTechs@CvTeamTechs@@QBEPAVCvTechXMLEntries@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTechs@CvTeamTechs@@QBEPAVCvTechXMLEntries@@XZ PROC	; CvTeamTechs::GetTechs, COMDAT
; _this$ = ecx

; 2292 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2293 : 	return m_pTechs;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]

; 2294 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTechs@CvTeamTechs@@QBEPAVCvTechXMLEntries@@XZ ENDP	; CvTeamTechs::GetTechs
_TEXT	ENDS
PUBLIC	?ChangeResearchProgressTimes100@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z ; CvTeamTechs::ChangeResearchProgressTimes100
PUBLIC	?ChangeResearchProgress@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z ; CvTeamTechs::ChangeResearchProgress
; Function compile flags: /Odtp
;	COMDAT ?ChangeResearchProgress@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
_ePlayer$ = 16						; size = 4
?ChangeResearchProgress@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z PROC ; CvTeamTechs::ChangeResearchProgress, COMDAT
; _this$ = ecx

; 2298 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2299 : 	ChangeResearchProgressTimes100(eIndex, iChange * 100, ePlayer);

	mov	eax, DWORD PTR _ePlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iChange$[ebp]
	imul	ecx, 100				; 00000064H
	push	ecx
	mov	edx, DWORD PTR _eIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChangeResearchProgressTimes100@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z ; CvTeamTechs::ChangeResearchProgressTimes100

; 2300 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?ChangeResearchProgress@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z ENDP ; CvTeamTechs::ChangeResearchProgress
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ChangeResearchProgressTimes100@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
_ePlayer$ = 16						; size = 4
?ChangeResearchProgressTimes100@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z PROC ; CvTeamTechs::ChangeResearchProgressTimes100, COMDAT
; _this$ = ecx

; 2304 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2305 : 	SetResearchProgressTimes100(eIndex, (GetResearchProgressTimes100(eIndex) + iChange), ePlayer);

	mov	eax, DWORD PTR _ePlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetResearchProgressTimes100@CvTeamTechs@@QBEHW4TechTypes@@@Z ; CvTeamTechs::GetResearchProgressTimes100
	add	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	edx, DWORD PTR _eIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetResearchProgressTimes100@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z ; CvTeamTechs::SetResearchProgressTimes100

; 2306 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?ChangeResearchProgressTimes100@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z ENDP ; CvTeamTechs::ChangeResearchProgressTimes100
_TEXT	ENDS
PUBLIC	?ChangeResearchProgressPercent@CvTeamTechs@@QAEHW4TechTypes@@HW4PlayerTypes@@@Z ; CvTeamTechs::ChangeResearchProgressPercent
; Function compile flags: /Odtp
;	COMDAT ?ChangeResearchProgressPercent@CvTeamTechs@@QAEHW4TechTypes@@HW4PlayerTypes@@@Z
_TEXT	SEGMENT
tv161 = -52						; size = 4
tv159 = -48						; size = 4
_this$ = -44						; size = 4
$T228420 = -40						; size = 4
$T228414 = -36						; size = 4
$T228410 = -32						; size = 4
$T228403 = -28						; size = 4
$T228397 = -24						; size = 4
$T228393 = -20						; size = 4
$T228392 = -16						; size = 4
$T228391 = -12						; size = 4
$T228390 = -8						; size = 4
_iBeakers$ = -4						; size = 4
_eIndex$ = 8						; size = 4
_iPercent$ = 12						; size = 4
_ePlayer$ = 16						; size = 4
?ChangeResearchProgressPercent@CvTeamTechs@@QAEHW4TechTypes@@HW4PlayerTypes@@@Z PROC ; CvTeamTechs::ChangeResearchProgressPercent, COMDAT
; _this$ = ecx

; 2310 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2311 : 	int iBeakers = 0;

	mov	DWORD PTR _iBeakers$[ebp], 0

; 2312 : 
; 2313 : 	if(0 != iPercent && !HasTech(eIndex))

	cmp	DWORD PTR _iPercent$[ebp], 0
	je	$LN3@ChangeRese
	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN3@ChangeRese

; 2314 : 	{
; 2315 : 		if(iPercent > 0)

	cmp	DWORD PTR _iPercent$[ebp], 0
	jle	SHORT $LN2@ChangeRese

; 2316 : 		{
; 2317 : #ifdef AUI_TECH_FIX_PLAYER_BASED_RESEARCH_COST_ONLY_AESTHETIC
; 2318 : 			iBeakers = std::min(GetResearchLeft(eIndex), (GET_PLAYER(ePlayer).GetPlayerTechs()->GetResearchCost(eIndex) * iPercent) / 100);

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T228397[ebp], edx
	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T228397[ebp]
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?GetResearchCost@CvPlayerTechs@@QBEHW4TechTypes@@@Z ; CvPlayerTechs::GetResearchCost
	imul	eax, DWORD PTR _iPercent$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR $T228390[ebp], eax
	mov	edx, DWORD PTR _eIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetResearchLeft@CvTeamTechs@@QBEHW4TechTypes@@@Z ; CvTeamTechs::GetResearchLeft
	mov	DWORD PTR $T228391[ebp], eax
	mov	eax, DWORD PTR $T228390[ebp]
	cmp	eax, DWORD PTR $T228391[ebp]
	jge	SHORT $LN10@ChangeRese
	lea	ecx, DWORD PTR $T228390[ebp]
	mov	DWORD PTR tv159[ebp], ecx
	jmp	SHORT $LN11@ChangeRese
$LN10@ChangeRese:
	lea	edx, DWORD PTR $T228391[ebp]
	mov	DWORD PTR tv159[ebp], edx
$LN11@ChangeRese:
	mov	eax, DWORD PTR tv159[ebp]
	mov	DWORD PTR $T228403[ebp], eax
	mov	ecx, DWORD PTR $T228403[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _iBeakers$[ebp], edx

; 2319 : #else
; 2320 : 			iBeakers = std::min(GetResearchLeft(eIndex), (GetResearchCost(eIndex) * iPercent) / 100);
; 2321 : #endif
; 2322 : 		}
; 2323 : 		else

	jmp	$LN1@ChangeRese
$LN2@ChangeRese:

; 2324 : 		{
; 2325 : #ifdef AUI_TECH_FIX_PLAYER_BASED_RESEARCH_COST_ONLY_AESTHETIC
; 2326 : 			iBeakers = std::max(GetResearchLeft(eIndex) - GET_PLAYER(ePlayer).GetPlayerTechs()->GetResearchCost(eIndex), (GET_PLAYER(ePlayer).GetPlayerTechs()->GetResearchCost(eIndex) * iPercent) / 100);

	mov	eax, DWORD PTR _ePlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T228410[ebp], eax
	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T228410[ebp]
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?GetResearchCost@CvPlayerTechs@@QBEHW4TechTypes@@@Z ; CvPlayerTechs::GetResearchCost
	imul	eax, DWORD PTR _iPercent$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR $T228392[ebp], eax
	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T228414[ebp], edx
	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetResearchLeft@CvTeamTechs@@QBEHW4TechTypes@@@Z ; CvTeamTechs::GetResearchLeft
	mov	esi, eax
	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T228414[ebp]
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?GetResearchCost@CvPlayerTechs@@QBEHW4TechTypes@@@Z ; CvPlayerTechs::GetResearchCost
	sub	esi, eax
	mov	DWORD PTR $T228393[ebp], esi
	mov	edx, DWORD PTR $T228393[ebp]
	cmp	edx, DWORD PTR $T228392[ebp]
	jge	SHORT $LN18@ChangeRese
	lea	eax, DWORD PTR $T228392[ebp]
	mov	DWORD PTR tv161[ebp], eax
	jmp	SHORT $LN19@ChangeRese
$LN18@ChangeRese:
	lea	ecx, DWORD PTR $T228393[ebp]
	mov	DWORD PTR tv161[ebp], ecx
$LN19@ChangeRese:
	mov	edx, DWORD PTR tv161[ebp]
	mov	DWORD PTR $T228420[ebp], edx
	mov	eax, DWORD PTR $T228420[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iBeakers$[ebp], ecx
$LN1@ChangeRese:

; 2327 : #else
; 2328 : 			iBeakers = std::max(GetResearchLeft(eIndex) - GetResearchCost(eIndex), (GetResearchCost(eIndex) * iPercent) / 100);
; 2329 : #endif
; 2330 : 		}
; 2331 : 
; 2332 : 		ChangeResearchProgress(eIndex, iBeakers, ePlayer);

	mov	edx, DWORD PTR _ePlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _iBeakers$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChangeResearchProgress@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z ; CvTeamTechs::ChangeResearchProgress
$LN3@ChangeRese:

; 2333 : 	}
; 2334 : 
; 2335 : 	return iBeakers;

	mov	eax, DWORD PTR _iBeakers$[ebp]

; 2336 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?ChangeResearchProgressPercent@CvTeamTechs@@QAEHW4TechTypes@@HW4PlayerTypes@@@Z ENDP ; CvTeamTechs::ChangeResearchProgressPercent
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetMaxResearchOverflow@CvTeamTechs@@ABEHW4TechTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
tv85 = -28						; size = 4
_this$ = -24						; size = 4
$T228434 = -20						; size = 4
_pkTechInfo$ = -16					; size = 4
_iReturnValue$ = -12					; size = 4
_iCost$ = -8						; size = 4
_kPlayer$ = -4						; size = 4
_eTech$ = 8						; size = 4
_ePlayer$ = 12						; size = 4
?GetMaxResearchOverflow@CvTeamTechs@@ABEHW4TechTypes@@W4PlayerTypes@@@Z PROC ; CvTeamTechs::GetMaxResearchOverflow, COMDAT
; _this$ = ecx

; 2341 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 2342 : 	CvPlayer &kPlayer = GET_PLAYER(ePlayer);

	mov	eax, DWORD PTR _ePlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$[ebp], eax

; 2343 : 
; 2344 : 	// 5 turns of science is a reasonable allowance of overflow (about equal to a standard research agreement award)
; 2345 : 	int iReturnValue = kPlayer.GetScienceTimes100() * 5;   

	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?GetScienceTimes100@CvPlayer@@QBEHXZ	; CvPlayer::GetScienceTimes100
	imul	eax, 5
	mov	DWORD PTR _iReturnValue$[ebp], eax

; 2346 : 
; 2347 : 	// Alternatively let it be the raw cost of the tech (times 100)
; 2348 : 	CvTechEntry* pkTechInfo = GC.getTechInfo(eTech);

	mov	ecx, DWORD PTR _eTech$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo
	mov	DWORD PTR _pkTechInfo$[ebp], eax

; 2349 : 	if(pkTechInfo == NULL)

	cmp	DWORD PTR _pkTechInfo$[ebp], 0
	jne	SHORT $LN1@GetMaxRese

; 2350 : 	{
; 2351 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN2@GetMaxRese
$LN1@GetMaxRese:

; 2352 : 	}
; 2353 : 
; 2354 : 	int iCost = pkTechInfo->GetResearchCost() * 100;

	mov	ecx, DWORD PTR _pkTechInfo$[ebp]
	call	?GetResearchCost@CvTechEntry@@QBEHXZ	; CvTechEntry::GetResearchCost
	imul	eax, 100				; 00000064H
	mov	DWORD PTR _iCost$[ebp], eax

; 2355 : 
; 2356 : 	iReturnValue = max(iCost, iReturnValue);

	mov	edx, DWORD PTR _iCost$[ebp]
	cmp	edx, DWORD PTR _iReturnValue$[ebp]
	jge	SHORT $LN8@GetMaxRese
	lea	eax, DWORD PTR _iReturnValue$[ebp]
	mov	DWORD PTR tv85[ebp], eax
	jmp	SHORT $LN9@GetMaxRese
$LN8@GetMaxRese:
	lea	ecx, DWORD PTR _iCost$[ebp]
	mov	DWORD PTR tv85[ebp], ecx
$LN9@GetMaxRese:
	mov	edx, DWORD PTR tv85[ebp]
	mov	DWORD PTR $T228434[ebp], edx
	mov	eax, DWORD PTR $T228434[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iReturnValue$[ebp], ecx

; 2357 : 
; 2358 : 	return iReturnValue;

	mov	eax, DWORD PTR _iReturnValue$[ebp]
$LN2@GetMaxRese:

; 2359 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetMaxResearchOverflow@CvTeamTechs@@ABEHW4TechTypes@@W4PlayerTypes@@@Z ENDP ; CvTeamTechs::GetMaxResearchOverflow
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::~vector<CvTechEntry *,std::allocator<CvTechEntry *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@IAEXXZ ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::~vector<CvTechEntry *,std::allocator<CvTechEntry *> >
; Function compile flags: /Odtp
;	COMDAT ??1?$_Vector_val@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvTechEntry *,std::allocator<CvTechEntry *> >::~_Vector_val<CvTechEntry *,std::allocator<CvTechEntry *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvTechEntry *,std::allocator<CvTechEntry *> >::~_Vector_val<CvTechEntry *,std::allocator<CvTechEntry *> >
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvTechEntry@@PAPAV1@@stdext@@YAPAPAVCvTechEntry@@PAPAV1@00@Z ; stdext::unchecked_copy<CvTechEntry * *,CvTechEntry * *>
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T228592 = -52						; size = 4
$T228581 = -48						; size = 4
$T228580 = -44						; size = 4
__Cat$228587 = -40					; size = 1
$T228584 = -39						; size = 1
__Ptr$224471 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@2@0@Z PROC ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@erase

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$unchecked_copy@PAPAVCvTechEntry@@PAPAV1@@stdext@@YAPAPAVCvTechEntry@@PAPAV1@00@Z ; stdext::unchecked_copy<CvTechEntry * *,CvTechEntry * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$224471[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T228592[ebp], edx
	mov	eax, DWORD PTR $T228592[ebp]
	mov	DWORD PTR $T228581[ebp], eax
	mov	ecx, DWORD PTR __Ptr$224471[ebp]
	mov	DWORD PTR $T228580[ebp], ecx
	mov	dl, BYTE PTR __Cat$228587[ebp]
	mov	BYTE PTR $T228584[ebp], dl

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$224471[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN1@erase:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@2@0@Z ENDP ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::erase
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvTechEntry@@@std@@YAPAPAVCvTechEntry@@IPAPAV1@@Z ; std::_Allocate<CvTechEntry *>
PUBLIC	?_Xlen@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@KAXXZ ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$228609 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy
	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$228609[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$228609[ebp], 0
	jbe	SHORT $LN11@Buy
	mov	eax, DWORD PTR __Count$228609[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy
$LN11@Buy:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@KAXXZ ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@PAVCvTechEntry@@@std@@YAPAPAVCvTechEntry@@IPAPAV1@@Z ; std::_Allocate<CvTechEntry *>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T228673 = -28						; size = 4
$T228672 = -24						; size = 4
$T228668 = -20						; size = 4
$T228667 = -16						; size = 4
$T228656 = -12						; size = 4
$T228655 = -8						; size = 4
__Cat$228663 = -2					; size = 1
$T228660 = -1						; size = 1
?_Tidy@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@IAEXXZ PROC ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T228668[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T228667[ebp], ecx
	mov	edx, DWORD PTR $T228668[ebp]
	mov	DWORD PTR $T228656[ebp], edx
	mov	eax, DWORD PTR $T228667[ebp]
	mov	DWORD PTR $T228655[ebp], eax
	mov	cl, BYTE PTR __Cat$228663[ebp]
	mov	BYTE PTR $T228660[ebp], cl

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR $T228673[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T228672[ebp], eax
	mov	ecx, DWORD PTR $T228672[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::_Tidy
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_Elength_error@std@@UAEPAXI@Z ; std::length_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_Elogic_error@std@@UAEPAXI@Z ; std::logic_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T228677 = -80						; size = 28
$T228676 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@KAXXZ PROC ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T228677[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T228676[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T228676[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T228677[ebp]
	push	eax
	lea	ecx, DWORD PTR $T228676[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T228676[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T228676[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T228677[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T228677[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T228676[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@KAXXZ ENDP ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::_Xlen
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 34   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 36   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@

; 110  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	edx, DWORD PTR ___flags$[ebp]
	and	edx, 1
	je	SHORT $LN1@scalar@2
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	?Read@FDataStream@@IAEXAA_N@Z:PROC		; FDataStream::Read
EXTRN	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z:PROC ; CvInfosSerializationHelper::ReadHashed
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvinfosserializationhelper.h
;	COMDAT ??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z
_TEXT	SEGMENT
_tValue$224578 = -18					; size = 1
_tValue$224573 = -17					; size = 1
_iType$224571 = -16					; size = 4
_bValid$224570 = -9					; size = 1
_iI$224566 = -8						; size = 4
_uiNumEntries$ = -4					; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_iArraySize$ = 16					; size = 4
??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z PROC ; CvInfosSerializationHelper::ReadHashedDataArray<bool>, COMDAT

; 248  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 249  : 	uint uiNumEntries;
; 250  : 
; 251  : 	kStream >> uiNumEntries;

	lea	eax, DWORD PTR _uiNumEntries$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 252  : 
; 253  : 	for(uint iI = 0; iI < uiNumEntries; iI++)

	mov	DWORD PTR _iI$224566[ebp], 0
	jmp	SHORT $LN7@ReadHashed
$LN6@ReadHashed:
	mov	ecx, DWORD PTR _iI$224566[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$224566[ebp], ecx
$LN7@ReadHashed:
	mov	edx, DWORD PTR _iI$224566[ebp]
	cmp	edx, DWORD PTR _uiNumEntries$[ebp]
	jae	SHORT $LN8@ReadHashed

; 254  : 	{
; 255  : 		bool bValid;
; 256  : 		int iType = ReadHashed(kStream, &bValid);

	lea	eax, DWORD PTR _bValid$224570[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	add	esp, 8
	mov	DWORD PTR _iType$224571[ebp], eax

; 257  : 		if(iType != -1)

	cmp	DWORD PTR _iType$224571[ebp], -1
	je	SHORT $LN4@ReadHashed

; 258  : 		{
; 259  : 			TData tValue;
; 260  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$224573[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 261  : 			if((int)iType < iArraySize)

	mov	eax, DWORD PTR _iType$224571[ebp]
	cmp	eax, DWORD PTR _iArraySize$[ebp]
	jge	SHORT $LN3@ReadHashed

; 262  : 				paArray[iType] = tValue;

	mov	ecx, DWORD PTR _paArray$[ebp]
	add	ecx, DWORD PTR _iType$224571[ebp]
	mov	dl, BYTE PTR _tValue$224573[ebp]
	mov	BYTE PTR [ecx], dl
$LN3@ReadHashed:

; 263  : 		}

	jmp	SHORT $LN2@ReadHashed
$LN4@ReadHashed:

; 264  : 		else if(!bValid)

	movzx	eax, BYTE PTR _bValid$224570[ebp]
	test	eax, eax
	jne	SHORT $LN2@ReadHashed

; 265  : 		{
; 266  : 			TData tValue;
; 267  : 			kStream >> tValue;

	lea	ecx, DWORD PTR _tValue$224578[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read
$LN2@ReadHashed:

; 268  : 		}
; 269  : 	}

	jmp	SHORT $LN6@ReadHashed
$LN8@ReadHashed:

; 270  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z ENDP ; CvInfosSerializationHelper::ReadHashedDataArray<bool>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z
_TEXT	SEGMENT
_tValue$224593 = -24					; size = 4
_tValue$224588 = -20					; size = 4
_iType$224586 = -16					; size = 4
_bValid$224585 = -9					; size = 1
_iI$224581 = -8						; size = 4
_uiNumEntries$ = -4					; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_iArraySize$ = 16					; size = 4
??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z PROC ; CvInfosSerializationHelper::ReadHashedDataArray<int>, COMDAT

; 248  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 249  : 	uint uiNumEntries;
; 250  : 
; 251  : 	kStream >> uiNumEntries;

	lea	eax, DWORD PTR _uiNumEntries$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 252  : 
; 253  : 	for(uint iI = 0; iI < uiNumEntries; iI++)

	mov	DWORD PTR _iI$224581[ebp], 0
	jmp	SHORT $LN7@ReadHashed@2
$LN6@ReadHashed@2:
	mov	ecx, DWORD PTR _iI$224581[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$224581[ebp], ecx
$LN7@ReadHashed@2:
	mov	edx, DWORD PTR _iI$224581[ebp]
	cmp	edx, DWORD PTR _uiNumEntries$[ebp]
	jae	SHORT $LN8@ReadHashed@2

; 254  : 	{
; 255  : 		bool bValid;
; 256  : 		int iType = ReadHashed(kStream, &bValid);

	lea	eax, DWORD PTR _bValid$224585[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	add	esp, 8
	mov	DWORD PTR _iType$224586[ebp], eax

; 257  : 		if(iType != -1)

	cmp	DWORD PTR _iType$224586[ebp], -1
	je	SHORT $LN4@ReadHashed@2

; 258  : 		{
; 259  : 			TData tValue;
; 260  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$224588[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 261  : 			if((int)iType < iArraySize)

	mov	eax, DWORD PTR _iType$224586[ebp]
	cmp	eax, DWORD PTR _iArraySize$[ebp]
	jge	SHORT $LN3@ReadHashed@2

; 262  : 				paArray[iType] = tValue;

	mov	ecx, DWORD PTR _iType$224586[ebp]
	mov	edx, DWORD PTR _paArray$[ebp]
	mov	eax, DWORD PTR _tValue$224588[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
$LN3@ReadHashed@2:

; 263  : 		}

	jmp	SHORT $LN2@ReadHashed@2
$LN4@ReadHashed@2:

; 264  : 		else if(!bValid)

	movzx	ecx, BYTE PTR _bValid$224585[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@ReadHashed@2

; 265  : 		{
; 266  : 			TData tValue;
; 267  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$224593[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
$LN2@ReadHashed@2:

; 268  : 		}
; 269  : 	}

	jmp	SHORT $LN6@ReadHashed@2
$LN8@ReadHashed@2:

; 270  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ENDP ; CvInfosSerializationHelper::ReadHashedDataArray<int>
_TEXT	ENDS
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4ResourceTypes@@@Z:PROC ; operator>>
; Function compile flags: /Odtp
;	COMDAT ??$ReadHashedDataArray@W4ResourceTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4ResourceTypes@@H@Z
_TEXT	SEGMENT
_tValue$224611 = -24					; size = 4
_tValue$224603 = -20					; size = 4
_iType$224601 = -16					; size = 4
_bValid$224600 = -9					; size = 1
_iI$224596 = -8						; size = 4
_uiNumEntries$ = -4					; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_iArraySize$ = 16					; size = 4
??$ReadHashedDataArray@W4ResourceTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4ResourceTypes@@H@Z PROC ; CvInfosSerializationHelper::ReadHashedDataArray<enum ResourceTypes>, COMDAT

; 248  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 249  : 	uint uiNumEntries;
; 250  : 
; 251  : 	kStream >> uiNumEntries;

	lea	eax, DWORD PTR _uiNumEntries$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 252  : 
; 253  : 	for(uint iI = 0; iI < uiNumEntries; iI++)

	mov	DWORD PTR _iI$224596[ebp], 0
	jmp	SHORT $LN7@ReadHashed@3
$LN6@ReadHashed@3:
	mov	ecx, DWORD PTR _iI$224596[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$224596[ebp], ecx
$LN7@ReadHashed@3:
	mov	edx, DWORD PTR _iI$224596[ebp]
	cmp	edx, DWORD PTR _uiNumEntries$[ebp]
	jae	SHORT $LN8@ReadHashed@3

; 254  : 	{
; 255  : 		bool bValid;
; 256  : 		int iType = ReadHashed(kStream, &bValid);

	lea	eax, DWORD PTR _bValid$224600[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	add	esp, 8
	mov	DWORD PTR _iType$224601[ebp], eax

; 257  : 		if(iType != -1)

	cmp	DWORD PTR _iType$224601[ebp], -1
	je	SHORT $LN4@ReadHashed@3

; 258  : 		{
; 259  : 			TData tValue;
; 260  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$224603[ebp]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??5@YAAAVFDataStream@@AAV0@AAW4ResourceTypes@@@Z ; operator>>
	add	esp, 8

; 261  : 			if((int)iType < iArraySize)

	mov	ecx, DWORD PTR _iType$224601[ebp]
	cmp	ecx, DWORD PTR _iArraySize$[ebp]
	jge	SHORT $LN3@ReadHashed@3

; 262  : 				paArray[iType] = tValue;

	mov	edx, DWORD PTR _iType$224601[ebp]
	mov	eax, DWORD PTR _paArray$[ebp]
	mov	ecx, DWORD PTR _tValue$224603[ebp]
	mov	DWORD PTR [eax+edx*4], ecx
$LN3@ReadHashed@3:

; 263  : 		}

	jmp	SHORT $LN2@ReadHashed@3
$LN4@ReadHashed@3:

; 264  : 		else if(!bValid)

	movzx	edx, BYTE PTR _bValid$224600[ebp]
	test	edx, edx
	jne	SHORT $LN2@ReadHashed@3

; 265  : 		{
; 266  : 			TData tValue;
; 267  : 			kStream >> tValue;

	lea	eax, DWORD PTR _tValue$224611[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??5@YAAAVFDataStream@@AAV0@AAW4ResourceTypes@@@Z ; operator>>
	add	esp, 8
$LN2@ReadHashed@3:

; 268  : 		}
; 269  : 	}

	jmp	SHORT $LN6@ReadHashed@3
$LN8@ReadHashed@3:

; 270  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$ReadHashedDataArray@W4ResourceTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4ResourceTypes@@H@Z ENDP ; CvInfosSerializationHelper::ReadHashedDataArray<enum ResourceTypes>
_TEXT	ENDS
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4UnitTypes@@@Z:PROC ; operator>>
; Function compile flags: /Odtp
;	COMDAT ??$ReadHashedDataArray@W4UnitTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4UnitTypes@@H@Z
_TEXT	SEGMENT
_tValue$224626 = -24					; size = 4
_tValue$224621 = -20					; size = 4
_iType$224619 = -16					; size = 4
_bValid$224618 = -9					; size = 1
_iI$224614 = -8						; size = 4
_uiNumEntries$ = -4					; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_iArraySize$ = 16					; size = 4
??$ReadHashedDataArray@W4UnitTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4UnitTypes@@H@Z PROC ; CvInfosSerializationHelper::ReadHashedDataArray<enum UnitTypes>, COMDAT

; 248  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 249  : 	uint uiNumEntries;
; 250  : 
; 251  : 	kStream >> uiNumEntries;

	lea	eax, DWORD PTR _uiNumEntries$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 252  : 
; 253  : 	for(uint iI = 0; iI < uiNumEntries; iI++)

	mov	DWORD PTR _iI$224614[ebp], 0
	jmp	SHORT $LN7@ReadHashed@4
$LN6@ReadHashed@4:
	mov	ecx, DWORD PTR _iI$224614[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$224614[ebp], ecx
$LN7@ReadHashed@4:
	mov	edx, DWORD PTR _iI$224614[ebp]
	cmp	edx, DWORD PTR _uiNumEntries$[ebp]
	jae	SHORT $LN8@ReadHashed@4

; 254  : 	{
; 255  : 		bool bValid;
; 256  : 		int iType = ReadHashed(kStream, &bValid);

	lea	eax, DWORD PTR _bValid$224618[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	add	esp, 8
	mov	DWORD PTR _iType$224619[ebp], eax

; 257  : 		if(iType != -1)

	cmp	DWORD PTR _iType$224619[ebp], -1
	je	SHORT $LN4@ReadHashed@4

; 258  : 		{
; 259  : 			TData tValue;
; 260  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$224621[ebp]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??5@YAAAVFDataStream@@AAV0@AAW4UnitTypes@@@Z ; operator>>
	add	esp, 8

; 261  : 			if((int)iType < iArraySize)

	mov	ecx, DWORD PTR _iType$224619[ebp]
	cmp	ecx, DWORD PTR _iArraySize$[ebp]
	jge	SHORT $LN3@ReadHashed@4

; 262  : 				paArray[iType] = tValue;

	mov	edx, DWORD PTR _iType$224619[ebp]
	mov	eax, DWORD PTR _paArray$[ebp]
	mov	ecx, DWORD PTR _tValue$224621[ebp]
	mov	DWORD PTR [eax+edx*4], ecx
$LN3@ReadHashed@4:

; 263  : 		}

	jmp	SHORT $LN2@ReadHashed@4
$LN4@ReadHashed@4:

; 264  : 		else if(!bValid)

	movzx	edx, BYTE PTR _bValid$224618[ebp]
	test	edx, edx
	jne	SHORT $LN2@ReadHashed@4

; 265  : 		{
; 266  : 			TData tValue;
; 267  : 			kStream >> tValue;

	lea	eax, DWORD PTR _tValue$224626[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??5@YAAAVFDataStream@@AAV0@AAW4UnitTypes@@@Z ; operator>>
	add	esp, 8
$LN2@ReadHashed@4:

; 268  : 		}
; 269  : 	}

	jmp	SHORT $LN6@ReadHashed@4
$LN8@ReadHashed@4:

; 270  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$ReadHashedDataArray@W4UnitTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4UnitTypes@@H@Z ENDP ; CvInfosSerializationHelper::ReadHashedDataArray<enum UnitTypes>
_TEXT	ENDS
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4BuildingTypes@@@Z:PROC ; operator>>
; Function compile flags: /Odtp
;	COMDAT ??$ReadHashedDataArray@W4BuildingTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4BuildingTypes@@H@Z
_TEXT	SEGMENT
_tValue$224644 = -24					; size = 4
_tValue$224636 = -20					; size = 4
_iType$224634 = -16					; size = 4
_bValid$224633 = -9					; size = 1
_iI$224629 = -8						; size = 4
_uiNumEntries$ = -4					; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_iArraySize$ = 16					; size = 4
??$ReadHashedDataArray@W4BuildingTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4BuildingTypes@@H@Z PROC ; CvInfosSerializationHelper::ReadHashedDataArray<enum BuildingTypes>, COMDAT

; 248  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 249  : 	uint uiNumEntries;
; 250  : 
; 251  : 	kStream >> uiNumEntries;

	lea	eax, DWORD PTR _uiNumEntries$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 252  : 
; 253  : 	for(uint iI = 0; iI < uiNumEntries; iI++)

	mov	DWORD PTR _iI$224629[ebp], 0
	jmp	SHORT $LN7@ReadHashed@5
$LN6@ReadHashed@5:
	mov	ecx, DWORD PTR _iI$224629[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$224629[ebp], ecx
$LN7@ReadHashed@5:
	mov	edx, DWORD PTR _iI$224629[ebp]
	cmp	edx, DWORD PTR _uiNumEntries$[ebp]
	jae	SHORT $LN8@ReadHashed@5

; 254  : 	{
; 255  : 		bool bValid;
; 256  : 		int iType = ReadHashed(kStream, &bValid);

	lea	eax, DWORD PTR _bValid$224633[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	add	esp, 8
	mov	DWORD PTR _iType$224634[ebp], eax

; 257  : 		if(iType != -1)

	cmp	DWORD PTR _iType$224634[ebp], -1
	je	SHORT $LN4@ReadHashed@5

; 258  : 		{
; 259  : 			TData tValue;
; 260  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$224636[ebp]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??5@YAAAVFDataStream@@AAV0@AAW4BuildingTypes@@@Z ; operator>>
	add	esp, 8

; 261  : 			if((int)iType < iArraySize)

	mov	ecx, DWORD PTR _iType$224634[ebp]
	cmp	ecx, DWORD PTR _iArraySize$[ebp]
	jge	SHORT $LN3@ReadHashed@5

; 262  : 				paArray[iType] = tValue;

	mov	edx, DWORD PTR _iType$224634[ebp]
	mov	eax, DWORD PTR _paArray$[ebp]
	mov	ecx, DWORD PTR _tValue$224636[ebp]
	mov	DWORD PTR [eax+edx*4], ecx
$LN3@ReadHashed@5:

; 263  : 		}

	jmp	SHORT $LN2@ReadHashed@5
$LN4@ReadHashed@5:

; 264  : 		else if(!bValid)

	movzx	edx, BYTE PTR _bValid$224633[ebp]
	test	edx, edx
	jne	SHORT $LN2@ReadHashed@5

; 265  : 		{
; 266  : 			TData tValue;
; 267  : 			kStream >> tValue;

	lea	eax, DWORD PTR _tValue$224644[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??5@YAAAVFDataStream@@AAV0@AAW4BuildingTypes@@@Z ; operator>>
	add	esp, 8
$LN2@ReadHashed@5:

; 268  : 		}
; 269  : 	}

	jmp	SHORT $LN6@ReadHashed@5
$LN8@ReadHashed@5:

; 270  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$ReadHashedDataArray@W4BuildingTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4BuildingTypes@@H@Z ENDP ; CvInfosSerializationHelper::ReadHashedDataArray<enum BuildingTypes>
_TEXT	ENDS
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4ImprovementTypes@@@Z:PROC ; operator>>
; Function compile flags: /Odtp
;	COMDAT ??$ReadHashedDataArray@W4ImprovementTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4ImprovementTypes@@H@Z
_TEXT	SEGMENT
_tValue$224662 = -24					; size = 4
_tValue$224654 = -20					; size = 4
_iType$224652 = -16					; size = 4
_bValid$224651 = -9					; size = 1
_iI$224647 = -8						; size = 4
_uiNumEntries$ = -4					; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_iArraySize$ = 16					; size = 4
??$ReadHashedDataArray@W4ImprovementTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4ImprovementTypes@@H@Z PROC ; CvInfosSerializationHelper::ReadHashedDataArray<enum ImprovementTypes>, COMDAT

; 248  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 249  : 	uint uiNumEntries;
; 250  : 
; 251  : 	kStream >> uiNumEntries;

	lea	eax, DWORD PTR _uiNumEntries$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 252  : 
; 253  : 	for(uint iI = 0; iI < uiNumEntries; iI++)

	mov	DWORD PTR _iI$224647[ebp], 0
	jmp	SHORT $LN7@ReadHashed@6
$LN6@ReadHashed@6:
	mov	ecx, DWORD PTR _iI$224647[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$224647[ebp], ecx
$LN7@ReadHashed@6:
	mov	edx, DWORD PTR _iI$224647[ebp]
	cmp	edx, DWORD PTR _uiNumEntries$[ebp]
	jae	SHORT $LN8@ReadHashed@6

; 254  : 	{
; 255  : 		bool bValid;
; 256  : 		int iType = ReadHashed(kStream, &bValid);

	lea	eax, DWORD PTR _bValid$224651[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	add	esp, 8
	mov	DWORD PTR _iType$224652[ebp], eax

; 257  : 		if(iType != -1)

	cmp	DWORD PTR _iType$224652[ebp], -1
	je	SHORT $LN4@ReadHashed@6

; 258  : 		{
; 259  : 			TData tValue;
; 260  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$224654[ebp]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??5@YAAAVFDataStream@@AAV0@AAW4ImprovementTypes@@@Z ; operator>>
	add	esp, 8

; 261  : 			if((int)iType < iArraySize)

	mov	ecx, DWORD PTR _iType$224652[ebp]
	cmp	ecx, DWORD PTR _iArraySize$[ebp]
	jge	SHORT $LN3@ReadHashed@6

; 262  : 				paArray[iType] = tValue;

	mov	edx, DWORD PTR _iType$224652[ebp]
	mov	eax, DWORD PTR _paArray$[ebp]
	mov	ecx, DWORD PTR _tValue$224654[ebp]
	mov	DWORD PTR [eax+edx*4], ecx
$LN3@ReadHashed@6:

; 263  : 		}

	jmp	SHORT $LN2@ReadHashed@6
$LN4@ReadHashed@6:

; 264  : 		else if(!bValid)

	movzx	edx, BYTE PTR _bValid$224651[ebp]
	test	edx, edx
	jne	SHORT $LN2@ReadHashed@6

; 265  : 		{
; 266  : 			TData tValue;
; 267  : 			kStream >> tValue;

	lea	eax, DWORD PTR _tValue$224662[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??5@YAAAVFDataStream@@AAV0@AAW4ImprovementTypes@@@Z ; operator>>
	add	esp, 8
$LN2@ReadHashed@6:

; 268  : 		}
; 269  : 	}

	jmp	SHORT $LN6@ReadHashed@6
$LN8@ReadHashed@6:

; 270  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$ReadHashedDataArray@W4ImprovementTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4ImprovementTypes@@H@Z ENDP ; CvInfosSerializationHelper::ReadHashedDataArray<enum ImprovementTypes>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fdatastream.h
_TEXT	ENDS
;	COMDAT ??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z
_TEXT	SEGMENT
_i$ = -12						; size = 4
_values$ = -8						; size = 4
_count$ = -4						; size = 4
_loadFrom$ = 8						; size = 4
_v$ = 12						; size = 4
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z PROC ; operator>><int>, COMDAT

; 515  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 516  : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 517  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _count$[ebp], ecx

; 518  : 	ValueType * values = v.getArray();

	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _values$[ebp], eax

; 519  : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@operator
$LN2@operator:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN3@operator:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _count$[ebp]
	jge	SHORT $LN1@operator

; 520  : 	{
; 521  : 		loadFrom >> values[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _values$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 522  : 	}

	jmp	SHORT $LN2@operator
$LN1@operator:

; 523  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 524  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ENDP ; operator>><int>
_TEXT	ENDS
EXTRN	?Write@FDataStream@@IAEXAB_N@Z:PROC		; FDataStream::Write
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4TechTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvinfosserializationhelper.h
;	COMDAT ??$WriteHashedDataArray@W4TechTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z
_TEXT	SEGMENT
_eType$224675 = -8					; size = 4
_iI$224671 = -4						; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4TechTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,bool>, COMDAT

; 559  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 560  : 	kStream << uiArraySize;

	lea	eax, DWORD PTR _uiArraySize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	mov	DWORD PTR _iI$224671[ebp], 0
	jmp	SHORT $LN4@WriteHashe
$LN3@WriteHashe:
	mov	ecx, DWORD PTR _iI$224671[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$224671[ebp], ecx
$LN4@WriteHashe:
	mov	edx, DWORD PTR _iI$224671[ebp]
	cmp	edx, DWORD PTR _uiArraySize$[ebp]
	jae	SHORT $LN5@WriteHashe

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);

	mov	eax, DWORD PTR _iI$224671[ebp]
	mov	DWORD PTR _eType$224675[ebp], eax

; 565  : 		if(WriteHashed(kStream, eType))

	mov	ecx, DWORD PTR _eType$224675[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4TechTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@WriteHashe

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	mov	ecx, DWORD PTR _paArray$[ebp]
	add	ecx, DWORD PTR _iI$224671[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
$LN1@WriteHashe:

; 568  : 		}
; 569  : 	}

	jmp	SHORT $LN3@WriteHashe
$LN5@WriteHashe:

; 570  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$WriteHashedDataArray@W4TechTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,bool>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$WriteHashedDataArray@W4TechTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z
_TEXT	SEGMENT
_eType$224683 = -8					; size = 4
_iI$224679 = -4						; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4TechTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,int>, COMDAT

; 559  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 560  : 	kStream << uiArraySize;

	lea	eax, DWORD PTR _uiArraySize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	mov	DWORD PTR _iI$224679[ebp], 0
	jmp	SHORT $LN4@WriteHashe@2
$LN3@WriteHashe@2:
	mov	ecx, DWORD PTR _iI$224679[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$224679[ebp], ecx
$LN4@WriteHashe@2:
	mov	edx, DWORD PTR _iI$224679[ebp]
	cmp	edx, DWORD PTR _uiArraySize$[ebp]
	jae	SHORT $LN5@WriteHashe@2

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);

	mov	eax, DWORD PTR _iI$224679[ebp]
	mov	DWORD PTR _eType$224683[ebp], eax

; 565  : 		if(WriteHashed(kStream, eType))

	mov	ecx, DWORD PTR _eType$224683[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4TechTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@WriteHashe@2

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	mov	ecx, DWORD PTR _iI$224679[ebp]
	mov	edx, DWORD PTR _paArray$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
$LN1@WriteHashe@2:

; 568  : 		}
; 569  : 	}

	jmp	SHORT $LN3@WriteHashe@2
$LN5@WriteHashe@2:

; 570  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$WriteHashedDataArray@W4TechTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,int>
_TEXT	ENDS
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4ResourceTypes@@@Z:PROC ; operator<<
; Function compile flags: /Odtp
;	COMDAT ??$WriteHashedDataArray@W4TechTypes@@W4ResourceTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4ResourceTypes@@I@Z
_TEXT	SEGMENT
_eType$224691 = -8					; size = 4
_iI$224687 = -4						; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4TechTypes@@W4ResourceTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4ResourceTypes@@I@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,enum ResourceTypes>, COMDAT

; 559  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 560  : 	kStream << uiArraySize;

	lea	eax, DWORD PTR _uiArraySize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	mov	DWORD PTR _iI$224687[ebp], 0
	jmp	SHORT $LN4@WriteHashe@3
$LN3@WriteHashe@3:
	mov	ecx, DWORD PTR _iI$224687[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$224687[ebp], ecx
$LN4@WriteHashe@3:
	mov	edx, DWORD PTR _iI$224687[ebp]
	cmp	edx, DWORD PTR _uiArraySize$[ebp]
	jae	SHORT $LN5@WriteHashe@3

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);

	mov	eax, DWORD PTR _iI$224687[ebp]
	mov	DWORD PTR _eType$224691[ebp], eax

; 565  : 		if(WriteHashed(kStream, eType))

	mov	ecx, DWORD PTR _eType$224691[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4TechTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@WriteHashe@3

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	mov	ecx, DWORD PTR _iI$224687[ebp]
	mov	edx, DWORD PTR _paArray$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??6@YAAAVFDataStream@@AAV0@ABW4ResourceTypes@@@Z ; operator<<
	add	esp, 8
$LN1@WriteHashe@3:

; 568  : 		}
; 569  : 	}

	jmp	SHORT $LN3@WriteHashe@3
$LN5@WriteHashe@3:

; 570  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$WriteHashedDataArray@W4TechTypes@@W4ResourceTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4ResourceTypes@@I@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,enum ResourceTypes>
_TEXT	ENDS
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4UnitTypes@@@Z:PROC ; operator<<
; Function compile flags: /Odtp
;	COMDAT ??$WriteHashedDataArray@W4TechTypes@@W4UnitTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4UnitTypes@@I@Z
_TEXT	SEGMENT
_eType$224707 = -8					; size = 4
_iI$224703 = -4						; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4TechTypes@@W4UnitTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4UnitTypes@@I@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,enum UnitTypes>, COMDAT

; 559  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 560  : 	kStream << uiArraySize;

	lea	eax, DWORD PTR _uiArraySize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	mov	DWORD PTR _iI$224703[ebp], 0
	jmp	SHORT $LN4@WriteHashe@4
$LN3@WriteHashe@4:
	mov	ecx, DWORD PTR _iI$224703[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$224703[ebp], ecx
$LN4@WriteHashe@4:
	mov	edx, DWORD PTR _iI$224703[ebp]
	cmp	edx, DWORD PTR _uiArraySize$[ebp]
	jae	SHORT $LN5@WriteHashe@4

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);

	mov	eax, DWORD PTR _iI$224703[ebp]
	mov	DWORD PTR _eType$224707[ebp], eax

; 565  : 		if(WriteHashed(kStream, eType))

	mov	ecx, DWORD PTR _eType$224707[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4TechTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@WriteHashe@4

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	mov	ecx, DWORD PTR _iI$224703[ebp]
	mov	edx, DWORD PTR _paArray$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??6@YAAAVFDataStream@@AAV0@ABW4UnitTypes@@@Z ; operator<<
	add	esp, 8
$LN1@WriteHashe@4:

; 568  : 		}
; 569  : 	}

	jmp	SHORT $LN3@WriteHashe@4
$LN5@WriteHashe@4:

; 570  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$WriteHashedDataArray@W4TechTypes@@W4UnitTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4UnitTypes@@I@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,enum UnitTypes>
_TEXT	ENDS
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4BuildingTypes@@@Z:PROC ; operator<<
; Function compile flags: /Odtp
;	COMDAT ??$WriteHashedDataArray@W4TechTypes@@W4BuildingTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4BuildingTypes@@I@Z
_TEXT	SEGMENT
_eType$224715 = -8					; size = 4
_iI$224711 = -4						; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4TechTypes@@W4BuildingTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4BuildingTypes@@I@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,enum BuildingTypes>, COMDAT

; 559  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 560  : 	kStream << uiArraySize;

	lea	eax, DWORD PTR _uiArraySize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	mov	DWORD PTR _iI$224711[ebp], 0
	jmp	SHORT $LN4@WriteHashe@5
$LN3@WriteHashe@5:
	mov	ecx, DWORD PTR _iI$224711[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$224711[ebp], ecx
$LN4@WriteHashe@5:
	mov	edx, DWORD PTR _iI$224711[ebp]
	cmp	edx, DWORD PTR _uiArraySize$[ebp]
	jae	SHORT $LN5@WriteHashe@5

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);

	mov	eax, DWORD PTR _iI$224711[ebp]
	mov	DWORD PTR _eType$224715[ebp], eax

; 565  : 		if(WriteHashed(kStream, eType))

	mov	ecx, DWORD PTR _eType$224715[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4TechTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@WriteHashe@5

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	mov	ecx, DWORD PTR _iI$224711[ebp]
	mov	edx, DWORD PTR _paArray$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??6@YAAAVFDataStream@@AAV0@ABW4BuildingTypes@@@Z ; operator<<
	add	esp, 8
$LN1@WriteHashe@5:

; 568  : 		}
; 569  : 	}

	jmp	SHORT $LN3@WriteHashe@5
$LN5@WriteHashe@5:

; 570  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$WriteHashedDataArray@W4TechTypes@@W4BuildingTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4BuildingTypes@@I@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,enum BuildingTypes>
_TEXT	ENDS
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4ImprovementTypes@@@Z:PROC ; operator<<
; Function compile flags: /Odtp
;	COMDAT ??$WriteHashedDataArray@W4TechTypes@@W4ImprovementTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4ImprovementTypes@@I@Z
_TEXT	SEGMENT
_eType$224731 = -8					; size = 4
_iI$224727 = -4						; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4TechTypes@@W4ImprovementTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4ImprovementTypes@@I@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,enum ImprovementTypes>, COMDAT

; 559  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 560  : 	kStream << uiArraySize;

	lea	eax, DWORD PTR _uiArraySize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	mov	DWORD PTR _iI$224727[ebp], 0
	jmp	SHORT $LN4@WriteHashe@6
$LN3@WriteHashe@6:
	mov	ecx, DWORD PTR _iI$224727[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$224727[ebp], ecx
$LN4@WriteHashe@6:
	mov	edx, DWORD PTR _iI$224727[ebp]
	cmp	edx, DWORD PTR _uiArraySize$[ebp]
	jae	SHORT $LN5@WriteHashe@6

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);

	mov	eax, DWORD PTR _iI$224727[ebp]
	mov	DWORD PTR _eType$224731[ebp], eax

; 565  : 		if(WriteHashed(kStream, eType))

	mov	ecx, DWORD PTR _eType$224731[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4TechTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@WriteHashe@6

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	mov	ecx, DWORD PTR _iI$224727[ebp]
	mov	edx, DWORD PTR _paArray$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??6@YAAAVFDataStream@@AAV0@ABW4ImprovementTypes@@@Z ; operator<<
	add	esp, 8
$LN1@WriteHashe@6:

; 568  : 		}
; 569  : 	}

	jmp	SHORT $LN3@WriteHashe@6
$LN5@WriteHashe@6:

; 570  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$WriteHashedDataArray@W4TechTypes@@W4ImprovementTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4ImprovementTypes@@I@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,enum ImprovementTypes>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fdatastream.h
_TEXT	ENDS
;	COMDAT ??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z
_TEXT	SEGMENT
_i$ = -12						; size = 4
_values$ = -8						; size = 4
_count$ = -4						; size = 4
_saveTo$ = 8						; size = 4
_v$ = 12						; size = 4
??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z PROC ; operator<<<int>, COMDAT

; 502  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 503  : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 504  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _count$[ebp], ecx

; 505  : 	const ValueType * values = v.getArray();

	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _values$[ebp], eax

; 506  : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@operator@2
$LN2@operator@2:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN3@operator@2:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _count$[ebp]
	jge	SHORT $LN1@operator@2

; 507  : 	{
; 508  : 		saveTo << values[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _values$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 509  : 	}

	jmp	SHORT $LN2@operator@2
$LN1@operator@2:

; 510  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 511  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ENDP ; operator<<<int>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvinfosserializationhelper.h
_TEXT	ENDS
;	COMDAT ??$ReadHashedTypeArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@IPAHI@Z
_TEXT	SEGMENT
_eType$224765 = -8					; size = 4
_iI$224761 = -4						; size = 4
_kStream$ = 8						; size = 4
_uiInputArraySize$ = 12					; size = 4
_paArray$ = 16						; size = 4
_uiOutputArraySize$ = 20				; size = 4
??$ReadHashedTypeArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@IPAHI@Z PROC ; CvInfosSerializationHelper::ReadHashedTypeArray<int>, COMDAT

; 472  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 473  : 	for(uint iI = 0; iI < uiInputArraySize; iI++)

	mov	DWORD PTR _iI$224761[ebp], 0
	jmp	SHORT $LN4@ReadHashed@7
$LN3@ReadHashed@7:
	mov	eax, DWORD PTR _iI$224761[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$224761[ebp], eax
$LN4@ReadHashed@7:
	mov	ecx, DWORD PTR _iI$224761[ebp]
	cmp	ecx, DWORD PTR _uiInputArraySize$[ebp]
	jae	SHORT $LN5@ReadHashed@7

; 474  : 	{
; 475  : 		TType eType = (TType)ReadHashed(kStream);

	push	0
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	add	esp, 8
	mov	DWORD PTR _eType$224765[ebp], eax

; 476  : 		if(iI < uiOutputArraySize)

	mov	eax, DWORD PTR _iI$224761[ebp]
	cmp	eax, DWORD PTR _uiOutputArraySize$[ebp]
	jae	SHORT $LN1@ReadHashed@7

; 477  : 			paArray[iI] = eType;

	mov	ecx, DWORD PTR _iI$224761[ebp]
	mov	edx, DWORD PTR _paArray$[ebp]
	mov	eax, DWORD PTR _eType$224765[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
$LN1@ReadHashed@7:

; 478  : 	}

	jmp	SHORT $LN3@ReadHashed@7
$LN5@ReadHashed@7:

; 479  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$ReadHashedTypeArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@IPAHI@Z ENDP ; CvInfosSerializationHelper::ReadHashedTypeArray<int>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Odtp
;	COMDAT ??$ReadAndRemapDataArray@_N@CvInfosSerializationHelper@@YA_NAAVFDataStream@@HPA_NHPBH@Z
_TEXT	SEGMENT
tv79 = -44						; size = 4
tv71 = -40						; size = 4
$T228843 = -36						; size = 4
__Marker$228837 = -32					; size = 4
$T228834 = -28						; size = 4
$T228829 = -24						; size = 4
__$ArrayPad$ = -20					; size = 4
_iDestIndex$224781 = -16				; size = 4
_i$224777 = -12						; size = 4
_pvBuffer$ = -8						; size = 4
_bRemapSuccess$ = -1					; size = 1
_kStream$ = 8						; size = 4
_iSrcCount$ = 12					; size = 4
_pvDest$ = 16						; size = 4
_iDestCount$ = 20					; size = 4
_piaRemap$ = 24						; size = 4
??$ReadAndRemapDataArray@_N@CvInfosSerializationHelper@@YA_NAAVFDataStream@@HPA_NHPBH@Z PROC ; CvInfosSerializationHelper::ReadAndRemapDataArray<bool>, COMDAT

; 485  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 486  : 	TType* pvBuffer = (TType*)_malloca(iSrcCount * sizeof(TType));

	mov	eax, DWORD PTR _iSrcCount$[ebp]
	add	eax, 8
	cmp	eax, 1024				; 00000400H
	ja	SHORT $LN8@ReadAndRem
	mov	eax, DWORD PTR _iSrcCount$[ebp]
	add	eax, 8
	call	__alloca_probe_16
	mov	DWORD PTR tv71[ebp], esp
	mov	ecx, DWORD PTR tv71[ebp]
	mov	DWORD PTR $T228829[ebp], ecx
	cmp	DWORD PTR $T228829[ebp], 0
	je	SHORT $LN11@ReadAndRem
	mov	edx, DWORD PTR $T228829[ebp]
	mov	DWORD PTR [edx], 52428			; 0000ccccH
	mov	eax, DWORD PTR $T228829[ebp]
	add	eax, 8
	mov	DWORD PTR $T228829[ebp], eax
$LN11@ReadAndRem:
	mov	ecx, DWORD PTR $T228829[ebp]
	mov	DWORD PTR tv79[ebp], ecx
	jmp	SHORT $LN9@ReadAndRem
$LN8@ReadAndRem:
	mov	edx, DWORD PTR _iSrcCount$[ebp]
	add	edx, 8
	push	edx
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	DWORD PTR $T228834[ebp], eax
	cmp	DWORD PTR $T228834[ebp], 0
	je	SHORT $LN14@ReadAndRem
	mov	eax, DWORD PTR $T228834[ebp]
	mov	DWORD PTR [eax], 56797			; 0000ddddH
	mov	ecx, DWORD PTR $T228834[ebp]
	add	ecx, 8
	mov	DWORD PTR $T228834[ebp], ecx
$LN14@ReadAndRem:
	mov	edx, DWORD PTR $T228834[ebp]
	mov	DWORD PTR tv79[ebp], edx
$LN9@ReadAndRem:
	mov	eax, DWORD PTR tv79[ebp]
	mov	DWORD PTR _pvBuffer$[ebp], eax

; 487  : #ifdef AUI_WARNING_FIXES
; 488  : 	if (!pvBuffer)
; 489  : 		return false;
; 490  : #endif
; 491  : 	kStream.ReadIt(iSrcCount * sizeof(TType), (void*)pvBuffer);

	mov	ecx, DWORD PTR _pvBuffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iSrcCount$[ebp]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _kStream$[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax

; 492  : 
; 493  : 	bool bRemapSuccess = true;

	mov	BYTE PTR _bRemapSuccess$[ebp], 1

; 494  : 	for(int i = 0; i < iSrcCount; ++i)

	mov	DWORD PTR _i$224777[ebp], 0
	jmp	SHORT $LN5@ReadAndRem
$LN4@ReadAndRem:
	mov	ecx, DWORD PTR _i$224777[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$224777[ebp], ecx
$LN5@ReadAndRem:
	mov	edx, DWORD PTR _i$224777[ebp]
	cmp	edx, DWORD PTR _iSrcCount$[ebp]
	jge	SHORT $LN3@ReadAndRem

; 495  : 	{
; 496  : 		int iDestIndex = piaRemap[i];	// The new index

	mov	eax, DWORD PTR _i$224777[ebp]
	mov	ecx, DWORD PTR _piaRemap$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _iDestIndex$224781[ebp], edx

; 497  : 		if(iDestIndex >= 0 && iDestIndex < iDestCount)

	cmp	DWORD PTR _iDestIndex$224781[ebp], 0
	jl	SHORT $LN2@ReadAndRem
	mov	eax, DWORD PTR _iDestIndex$224781[ebp]
	cmp	eax, DWORD PTR _iDestCount$[ebp]
	jge	SHORT $LN2@ReadAndRem

; 498  : 		{
; 499  : 			pvDest[iDestIndex] = pvBuffer[i];

	mov	ecx, DWORD PTR _pvDest$[ebp]
	add	ecx, DWORD PTR _iDestIndex$224781[ebp]
	mov	edx, DWORD PTR _pvBuffer$[ebp]
	add	edx, DWORD PTR _i$224777[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al

; 500  : 		}
; 501  : 		else

	jmp	SHORT $LN1@ReadAndRem
$LN2@ReadAndRem:

; 502  : 			bRemapSuccess = false;

	mov	BYTE PTR _bRemapSuccess$[ebp], 0
$LN1@ReadAndRem:

; 503  : 	}

	jmp	SHORT $LN4@ReadAndRem
$LN3@ReadAndRem:

; 504  : 	_freea(pvBuffer);

	mov	ecx, DWORD PTR _pvBuffer$[ebp]
	mov	DWORD PTR $T228843[ebp], ecx
	cmp	DWORD PTR $T228843[ebp], 0
	je	SHORT $LN20@ReadAndRem
	mov	edx, DWORD PTR $T228843[ebp]
	sub	edx, 8
	mov	DWORD PTR $T228843[ebp], edx
	mov	eax, DWORD PTR $T228843[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Marker$228837[ebp], ecx
	cmp	DWORD PTR __Marker$228837[ebp], 56797	; 0000ddddH
	jne	SHORT $LN20@ReadAndRem
	mov	edx, DWORD PTR $T228843[ebp]
	push	edx
	call	DWORD PTR __imp__free
	add	esp, 4
$LN20@ReadAndRem:

; 505  : 	return bRemapSuccess;

	mov	al, BYTE PTR _bRemapSuccess$[ebp]

; 506  : }

	lea	esp, DWORD PTR [ebp-44]
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
??$ReadAndRemapDataArray@_N@CvInfosSerializationHelper@@YA_NAAVFDataStream@@HPA_NHPBH@Z ENDP ; CvInfosSerializationHelper::ReadAndRemapDataArray<bool>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Odtp
;	COMDAT ??$ReadAndRemapDataArray@H@CvInfosSerializationHelper@@YA_NAAVFDataStream@@HPAHHPBH@Z
_TEXT	SEGMENT
tv82 = -44						; size = 4
tv73 = -40						; size = 4
$T228867 = -36						; size = 4
__Marker$228861 = -32					; size = 4
$T228858 = -28						; size = 4
$T228853 = -24						; size = 4
__$ArrayPad$ = -20					; size = 4
_iDestIndex$224797 = -16				; size = 4
_i$224793 = -12						; size = 4
_pvBuffer$ = -8						; size = 4
_bRemapSuccess$ = -1					; size = 1
_kStream$ = 8						; size = 4
_iSrcCount$ = 12					; size = 4
_pvDest$ = 16						; size = 4
_iDestCount$ = 20					; size = 4
_piaRemap$ = 24						; size = 4
??$ReadAndRemapDataArray@H@CvInfosSerializationHelper@@YA_NAAVFDataStream@@HPAHHPBH@Z PROC ; CvInfosSerializationHelper::ReadAndRemapDataArray<int>, COMDAT

; 485  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 486  : 	TType* pvBuffer = (TType*)_malloca(iSrcCount * sizeof(TType));

	mov	eax, DWORD PTR _iSrcCount$[ebp]
	lea	ecx, DWORD PTR [eax*4+8]
	cmp	ecx, 1024				; 00000400H
	ja	SHORT $LN8@ReadAndRem@2
	mov	edx, DWORD PTR _iSrcCount$[ebp]
	lea	eax, DWORD PTR [edx*4+8]
	call	__alloca_probe_16
	mov	DWORD PTR tv73[ebp], esp
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T228853[ebp], eax
	cmp	DWORD PTR $T228853[ebp], 0
	je	SHORT $LN11@ReadAndRem@2
	mov	ecx, DWORD PTR $T228853[ebp]
	mov	DWORD PTR [ecx], 52428			; 0000ccccH
	mov	edx, DWORD PTR $T228853[ebp]
	add	edx, 8
	mov	DWORD PTR $T228853[ebp], edx
$LN11@ReadAndRem@2:
	mov	eax, DWORD PTR $T228853[ebp]
	mov	DWORD PTR tv82[ebp], eax
	jmp	SHORT $LN9@ReadAndRem@2
$LN8@ReadAndRem@2:
	mov	ecx, DWORD PTR _iSrcCount$[ebp]
	lea	edx, DWORD PTR [ecx*4+8]
	push	edx
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	DWORD PTR $T228858[ebp], eax
	cmp	DWORD PTR $T228858[ebp], 0
	je	SHORT $LN14@ReadAndRem@2
	mov	eax, DWORD PTR $T228858[ebp]
	mov	DWORD PTR [eax], 56797			; 0000ddddH
	mov	ecx, DWORD PTR $T228858[ebp]
	add	ecx, 8
	mov	DWORD PTR $T228858[ebp], ecx
$LN14@ReadAndRem@2:
	mov	edx, DWORD PTR $T228858[ebp]
	mov	DWORD PTR tv82[ebp], edx
$LN9@ReadAndRem@2:
	mov	eax, DWORD PTR tv82[ebp]
	mov	DWORD PTR _pvBuffer$[ebp], eax

; 487  : #ifdef AUI_WARNING_FIXES
; 488  : 	if (!pvBuffer)
; 489  : 		return false;
; 490  : #endif
; 491  : 	kStream.ReadIt(iSrcCount * sizeof(TType), (void*)pvBuffer);

	mov	ecx, DWORD PTR _pvBuffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iSrcCount$[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _kStream$[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax

; 492  : 
; 493  : 	bool bRemapSuccess = true;

	mov	BYTE PTR _bRemapSuccess$[ebp], 1

; 494  : 	for(int i = 0; i < iSrcCount; ++i)

	mov	DWORD PTR _i$224793[ebp], 0
	jmp	SHORT $LN5@ReadAndRem@2
$LN4@ReadAndRem@2:
	mov	ecx, DWORD PTR _i$224793[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$224793[ebp], ecx
$LN5@ReadAndRem@2:
	mov	edx, DWORD PTR _i$224793[ebp]
	cmp	edx, DWORD PTR _iSrcCount$[ebp]
	jge	SHORT $LN3@ReadAndRem@2

; 495  : 	{
; 496  : 		int iDestIndex = piaRemap[i];	// The new index

	mov	eax, DWORD PTR _i$224793[ebp]
	mov	ecx, DWORD PTR _piaRemap$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _iDestIndex$224797[ebp], edx

; 497  : 		if(iDestIndex >= 0 && iDestIndex < iDestCount)

	cmp	DWORD PTR _iDestIndex$224797[ebp], 0
	jl	SHORT $LN2@ReadAndRem@2
	mov	eax, DWORD PTR _iDestIndex$224797[ebp]
	cmp	eax, DWORD PTR _iDestCount$[ebp]
	jge	SHORT $LN2@ReadAndRem@2

; 498  : 		{
; 499  : 			pvDest[iDestIndex] = pvBuffer[i];

	mov	ecx, DWORD PTR _iDestIndex$224797[ebp]
	mov	edx, DWORD PTR _pvDest$[ebp]
	mov	eax, DWORD PTR _i$224793[ebp]
	mov	esi, DWORD PTR _pvBuffer$[ebp]
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [edx+ecx*4], eax

; 500  : 		}
; 501  : 		else

	jmp	SHORT $LN1@ReadAndRem@2
$LN2@ReadAndRem@2:

; 502  : 			bRemapSuccess = false;

	mov	BYTE PTR _bRemapSuccess$[ebp], 0
$LN1@ReadAndRem@2:

; 503  : 	}

	jmp	SHORT $LN4@ReadAndRem@2
$LN3@ReadAndRem@2:

; 504  : 	_freea(pvBuffer);

	mov	ecx, DWORD PTR _pvBuffer$[ebp]
	mov	DWORD PTR $T228867[ebp], ecx
	cmp	DWORD PTR $T228867[ebp], 0
	je	SHORT $LN20@ReadAndRem@2
	mov	edx, DWORD PTR $T228867[ebp]
	sub	edx, 8
	mov	DWORD PTR $T228867[ebp], edx
	mov	eax, DWORD PTR $T228867[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Marker$228861[ebp], ecx
	cmp	DWORD PTR __Marker$228861[ebp], 56797	; 0000ddddH
	jne	SHORT $LN20@ReadAndRem@2
	mov	edx, DWORD PTR $T228867[ebp]
	push	edx
	call	DWORD PTR __imp__free
	add	esp, 4
$LN20@ReadAndRem@2:

; 505  : 	return bRemapSuccess;

	mov	al, BYTE PTR _bRemapSuccess$[ebp]

; 506  : }

	lea	esp, DWORD PTR [ebp-48]
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
??$ReadAndRemapDataArray@H@CvInfosSerializationHelper@@YA_NAAVFDataStream@@HPAHHPBH@Z ENDP ; CvInfosSerializationHelper::ReadAndRemapDataArray<int>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fdatastream.h
_TEXT	ENDS
;	COMDAT ??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@_N@@@Z
_TEXT	SEGMENT
_i$ = -12						; size = 4
_values$ = -8						; size = 4
_count$ = -4						; size = 4
_saveTo$ = 8						; size = 4
_v$ = 12						; size = 4
??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@_N@@@Z PROC ; operator<<<bool>, COMDAT

; 502  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 503  : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 504  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _count$[ebp], ecx

; 505  : 	const ValueType * values = v.getArray();

	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _values$[ebp], eax

; 506  : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@operator@3
$LN2@operator@3:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN3@operator@3:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _count$[ebp]
	jge	SHORT $LN1@operator@3

; 507  : 	{
; 508  : 		saveTo << values[i];

	mov	eax, DWORD PTR _values$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 509  : 	}

	jmp	SHORT $LN2@operator@3
$LN1@operator@3:

; 510  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 511  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@_N@@@Z ENDP ; operator<<<bool>
_TEXT	ENDS
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVCvTechEntry@@PAPAV1@@stdext@@YAPAPAVCvTechEntry@@PAPAV1@00@Z
_TEXT	SEGMENT
$T228901 = -26						; size = 1
$T228900 = -25						; size = 1
$T228899 = -24						; size = 4
$T228898 = -20						; size = 4
__Off$228895 = -16					; size = 4
__Result$228896 = -12					; size = 4
__Cat$228887 = -4					; size = 1
$T228883 = -3						; size = 1
$T228882 = -2						; size = 1
$T228881 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvTechEntry@@PAPAV1@@stdext@@YAPAPAVCvTechEntry@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvTechEntry * *,CvTechEntry * *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T228881[ebp], al
	mov	cl, BYTE PTR __Cat$228887[ebp]
	mov	BYTE PTR $T228882[ebp], cl
	mov	dl, BYTE PTR $T228881[ebp]
	mov	BYTE PTR $T228901[ebp], dl
	mov	al, BYTE PTR $T228883[ebp]
	mov	BYTE PTR $T228900[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T228899[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T228898[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR $T228898[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$228895[ebp], eax
	mov	ecx, DWORD PTR __Off$228895[ebp]
	mov	edx, DWORD PTR $T228899[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$228896[ebp], eax
	cmp	DWORD PTR __Off$228895[ebp], 0
	jle	SHORT $LN8@unchecked_
	mov	ecx, DWORD PTR __Off$228895[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR $T228898[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$228895[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR $T228899[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_:
	mov	eax, DWORD PTR __Result$228896[ebp]

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAPAVCvTechEntry@@PAPAV1@@stdext@@YAPAPAVCvTechEntry@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvTechEntry * *,CvTechEntry * *>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R0?AVbad_alloc@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
xdata$x	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_Ebad_alloc@std@@UAEPAXI@Z ; std::bad_alloc::`vftable'
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
CONST	ENDS
;	COMDAT ??$_Allocate@PAVCvTechEntry@@@std@@YAPAPAVCvTechEntry@@IPAPAV1@@Z
_TEXT	SEGMENT
$T228908 = -16						; size = 4
$T228904 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvTechEntry@@@std@@YAPAPAVCvTechEntry@@IPAPAV1@@Z PROC ; std::_Allocate<CvTechEntry *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T228908[ebp], 0
	lea	eax, DWORD PTR $T228908[ebp]
	push	eax
	lea	ecx, DWORD PTR $T228904[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T228904[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T228904[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVCvTechEntry@@@std@@YAPAPAVCvTechEntry@@IPAPAV1@@Z ENDP ; std::_Allocate<CvTechEntry *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar@3
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAH@Z ; std::_Insertion_sort1<std::_Vector_iterator<int,std::allocator<int> >,int>
PUBLIC	??$pop_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z ; std::pop_heap<std::_Vector_iterator<int,std::allocator<int> > >
PUBLIC	??$_Make_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@HH@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAH1@Z ; std::_Make_heap<std::_Vector_iterator<int,std::allocator<int> >,int,int>
PUBLIC	??$_Unguarded_partition@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YA?AU?$pair@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@V12@@0@V?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z ; std::_Unguarded_partition<std::_Vector_iterator<int,std::allocator<int> > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Sort@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0H@Z
_TEXT	SEGMENT
$T229834 = -328						; size = 4
$T229833 = -324						; size = 4
$T229824 = -320						; size = 4
$T229823 = -316						; size = 4
$T229807 = -312						; size = 4
$T229806 = -308						; size = 4
$T229774 = -304						; size = 4
$T229773 = -300						; size = 4
$T229738 = -296						; size = 4
__Mid$224955 = -12					; size = 8
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
??$_Sort@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0H@Z PROC ; std::_Sort<std::_Vector_iterator<int,std::allocator<int> >,int>, COMDAT

; 3082 : 	{	// order [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 328				; 00000148H

; 3083 : 	_Diff _Count;
; 3084 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

$LN10@Sort:
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax
	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jle	$LN6@Sort
	cmp	DWORD PTR __Ideal$[ebp], 0
	jle	$LN6@Sort

; 3085 : 		{	// divide and conquer by quicksort
; 3086 : 		pair<_RanIt, _RanIt> _Mid =
; 3087 : 			std::_Unguarded_partition(_First, _Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR __Mid$224955[ebp]
	push	eax
	call	??$_Unguarded_partition@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YA?AU?$pair@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@V12@@0@V?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z ; std::_Unguarded_partition<std::_Vector_iterator<int,std::allocator<int> > >
	add	esp, 12					; 0000000cH

; 3088 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions

	mov	eax, DWORD PTR __Ideal$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Ideal$[ebp], eax
	mov	eax, DWORD PTR __Ideal$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR __Ideal$[ebp]
	mov	DWORD PTR __Ideal$[ebp], eax

; 3089 : 
; 3090 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	ecx, DWORD PTR __Mid$224955[ebp]
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 2
	mov	DWORD PTR $T229738[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __Mid$224955[ebp+4]
	sar	edx, 2
	cmp	DWORD PTR $T229738[ebp], edx
	jge	SHORT $LN5@Sort

; 3091 : 			{	// loop on second half
; 3092 : 			std::_Sort(_First, _Mid.first, _Ideal);

	mov	eax, DWORD PTR __Ideal$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$224955[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Sort@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<int,std::allocator<int> >,int>
	add	esp, 12					; 0000000cH

; 3093 : 			_First = _Mid.second;

	mov	eax, DWORD PTR __Mid$224955[ebp+4]
	mov	DWORD PTR __First$[ebp], eax

; 3094 : 			}
; 3095 : 		else

	jmp	SHORT $LN4@Sort
$LN5@Sort:

; 3096 : 			{	// loop on first half
; 3097 : 			std::_Sort(_Mid.second, _Last, _Ideal);

	mov	ecx, DWORD PTR __Ideal$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$224955[ebp+4]
	push	eax
	call	??$_Sort@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<int,std::allocator<int> >,int>
	add	esp, 12					; 0000000cH

; 3098 : 			_Last = _Mid.first;

	mov	ecx, DWORD PTR __Mid$224955[ebp]
	mov	DWORD PTR __Last$[ebp], ecx
$LN4@Sort:

; 3099 : 			}
; 3100 : 		}

	jmp	$LN10@Sort
$LN6@Sort:

; 3101 : 
; 3102 : 	if (_ISORT_MAX < _Count)

	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jle	$LN3@Sort

; 3103 : 		{	// heap sort if too many divisions
; 3104 : 		std::make_heap(_First, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T229774[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T229773[ebp], eax
	mov	ecx, DWORD PTR $T229774[ebp]
	sub	ecx, DWORD PTR $T229773[ebp]
	sar	ecx, 2
	cmp	ecx, 1
	jle	SHORT $LN361@Sort
	push	0
	push	0
	mov	edx, DWORD PTR $T229774[ebp]
	push	edx
	mov	eax, DWORD PTR $T229773[ebp]
	push	eax
	call	??$_Make_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@HH@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAH1@Z ; std::_Make_heap<std::_Vector_iterator<int,std::allocator<int> >,int,int>
	add	esp, 16					; 00000010H
$LN361@Sort:

; 3105 : 		std::sort_heap(_First, _Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T229824[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T229823[ebp], edx
	mov	eax, DWORD PTR $T229824[ebp]
	mov	DWORD PTR $T229807[ebp], eax
	mov	ecx, DWORD PTR $T229823[ebp]
	mov	DWORD PTR $T229806[ebp], ecx
	jmp	SHORT $LN382@Sort
$LN374@Sort:
	mov	edx, DWORD PTR $T229807[ebp]
	sub	edx, 4
	mov	DWORD PTR $T229807[ebp], edx
$LN382@Sort:
	mov	eax, DWORD PTR $T229807[ebp]
	sub	eax, DWORD PTR $T229806[ebp]
	sar	eax, 2
	cmp	eax, 1
	jle	SHORT $LN371@Sort
	mov	ecx, DWORD PTR $T229807[ebp]
	push	ecx
	mov	edx, DWORD PTR $T229806[ebp]
	push	edx
	call	??$pop_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z ; std::pop_heap<std::_Vector_iterator<int,std::allocator<int> > >
	add	esp, 8
	jmp	SHORT $LN374@Sort
$LN371@Sort:

; 3106 : 		}
; 3107 : 	else if (1 < _Count)

	jmp	SHORT $LN8@Sort
$LN3@Sort:
	cmp	DWORD PTR __Count$[ebp], 1
	jle	SHORT $LN8@Sort

; 3108 : 		std::_Insertion_sort(_First, _Last);	// small

	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T229834[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T229833[ebp], ecx
	push	0
	mov	edx, DWORD PTR $T229834[ebp]
	push	edx
	mov	eax, DWORD PTR $T229833[ebp]
	push	eax
	call	??$_Insertion_sort1@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAH@Z ; std::_Insertion_sort1<std::_Vector_iterator<int,std::allocator<int> >,int>
	add	esp, 12					; 0000000cH
$LN8@Sort:

; 3109 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Sort@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0H@Z ENDP ; std::_Sort<std::_Vector_iterator<int,std::allocator<int> >,int>
_TEXT	ENDS
PUBLIC	??$_Median@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@00@Z ; std::_Median<std::_Vector_iterator<int,std::allocator<int> > >
; Function compile flags: /Odtp
;	COMDAT ??$_Unguarded_partition@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YA?AU?$pair@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@V12@@0@V?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z
_TEXT	SEGMENT
$T230828 = -348						; size = 4
$T230827 = -344						; size = 4
$T230812 = -340						; size = 4
__Tmp$230825 = -336					; size = 4
$T230798 = -332						; size = 4
__Tmp$230788 = -328					; size = 4
$T230764 = -324						; size = 4
$T230763 = -320						; size = 4
$T230748 = -316						; size = 4
__Tmp$230761 = -312					; size = 4
$T230734 = -308						; size = 4
$T230716 = -304						; size = 4
$T230715 = -300						; size = 4
$T230700 = -296						; size = 4
__Tmp$230713 = -292					; size = 4
$T230686 = -288						; size = 4
$T230649 = -284						; size = 4
$T230648 = -280						; size = 4
$T230633 = -276						; size = 4
__Tmp$230646 = -272					; size = 4
$T230619 = -268						; size = 4
__Tmp$230609 = -264					; size = 4
__Tmp$230593 = -260					; size = 4
$T230569 = -256						; size = 4
$T230568 = -252						; size = 4
$T230553 = -248						; size = 4
__Tmp$230566 = -244					; size = 4
$T230539 = -240						; size = 4
$T230509 = -236						; size = 4
$T230508 = -232						; size = 4
$T230493 = -228						; size = 4
__Tmp$230506 = -224					; size = 4
$T230479 = -220						; size = 4
__Tmp$230461 = -216					; size = 4
__Tmp$230428 = -212					; size = 4
$T230403 = -208						; size = 4
$T230386 = -204						; size = 4
__Tmp$230370 = -200					; size = 4
$T230341 = -196						; size = 4
$T230340 = -192						; size = 4
$T230325 = -188						; size = 4
__Tmp$230339 = -184					; size = 4
$T230311 = -180						; size = 4
__Tmp$230296 = -176					; size = 4
$T230277 = -172						; size = 4
$T230260 = -168						; size = 4
$T230224 = -164						; size = 4
$T230207 = -160						; size = 4
__Tmp$230179 = -156					; size = 4
$T230154 = -152						; size = 4
$T230137 = -148						; size = 4
__Tmp$230128 = -144					; size = 4
__Tmp$230100 = -140					; size = 4
__Tmp$229895 = -68					; size = 4
__Tmp$229870 = -64					; size = 4
$T229846 = -60						; size = 4
$T229845 = -56						; size = 4
$T229844 = -52						; size = 4
$T229843 = -48						; size = 4
$T229842 = -44						; size = 4
$T229841 = -40						; size = 4
$T229840 = -36						; size = 4
$T229839 = -32						; size = 4
$T229838 = -28						; size = 4
$T229837 = -24						; size = 4
__Plast$ = -20						; size = 4
__Glast$ = -16						; size = 4
__Pfirst$ = -12						; size = 4
__Gfirst$ = -8						; size = 4
__Mid$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Unguarded_partition@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YA?AU?$pair@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@V12@@0@V?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z PROC ; std::_Unguarded_partition<std::_Vector_iterator<int,std::allocator<int> > >, COMDAT

; 3024 : 	{	// partition [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 348				; 0000015cH

; 3025 : 	_RanIt _Mid = _First + (_Last - _First) / 2;	// sort median to _Mid

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$229870[ebp], eax
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR __Tmp$229870[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Tmp$229870[ebp], edx
	mov	eax, DWORD PTR __Tmp$229870[ebp]
	mov	DWORD PTR __Mid$[ebp], eax

; 3026 : 	std::_Median(_First, _Mid, _Last - 1);

	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __Tmp$229895[ebp], ecx
	mov	edx, 1
	neg	edx
	mov	eax, DWORD PTR __Tmp$229895[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR __Tmp$229895[ebp], ecx
	mov	edx, DWORD PTR __Tmp$229895[ebp]
	mov	DWORD PTR $T229837[ebp], edx
	mov	eax, DWORD PTR $T229837[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Median@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@00@Z ; std::_Median<std::_Vector_iterator<int,std::allocator<int> > >
	add	esp, 12					; 0000000cH

; 3027 : 	_RanIt _Pfirst = _Mid;

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Pfirst$[ebp], eax

; 3028 : 	_RanIt _Plast = _Pfirst + 1;

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR __Tmp$230100[ebp], ecx
	mov	edx, 1
	shl	edx, 2
	add	edx, DWORD PTR __Tmp$230100[ebp]
	mov	DWORD PTR __Tmp$230100[ebp], edx
	mov	eax, DWORD PTR __Tmp$230100[ebp]
	mov	DWORD PTR __Plast$[ebp], eax

; 3029 : 
; 3030 : 	while (_First < _Pfirst
; 3031 : 		&& !_DEBUG_LT(*(_Pfirst - 1), *_Pfirst)
; 3032 : 		&& !(*_Pfirst < *(_Pfirst - 1)))

$LN122@Unguarded_:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Pfirst$[ebp]
	sbb	edx, edx
	neg	edx
	movzx	eax, dl
	test	eax, eax
	je	$LN160@Unguarded_
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR __Tmp$230128[ebp], ecx
	mov	edx, 1
	neg	edx
	mov	eax, DWORD PTR __Tmp$230128[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR __Tmp$230128[ebp], ecx
	mov	edx, DWORD PTR __Tmp$230128[ebp]
	mov	DWORD PTR $T229838[ebp], edx
	mov	eax, DWORD PTR $T229838[ebp]
	mov	DWORD PTR $T230137[ebp], eax
	mov	ecx, DWORD PTR $T230137[ebp]
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jl	SHORT $LN160@Unguarded_
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T230154[ebp], ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR __Tmp$230179[ebp], edx
	mov	eax, 1
	neg	eax
	mov	ecx, DWORD PTR __Tmp$230179[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Tmp$230179[ebp], edx
	mov	eax, DWORD PTR __Tmp$230179[ebp]
	mov	DWORD PTR $T229839[ebp], eax
	mov	ecx, DWORD PTR $T230154[ebp]
	mov	edx, DWORD PTR $T229839[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jl	SHORT $LN160@Unguarded_

; 3033 : 		--_Pfirst;

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	sub	ecx, 4
	mov	DWORD PTR __Pfirst$[ebp], ecx
	jmp	$LN122@Unguarded_

; 3034 : 	while (_Plast < _Last
; 3035 : 		&& !_DEBUG_LT(*_Plast, *_Pfirst)
; 3036 : 		&& !(*_Pfirst < *_Plast))

$LN160@Unguarded_:
	mov	edx, DWORD PTR __Plast$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN24@Unguarded_
	mov	edx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T230207[ebp], edx
	mov	eax, DWORD PTR $T230207[ebp]
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jl	SHORT $LN24@Unguarded_
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T230224[ebp], eax
	mov	ecx, DWORD PTR $T230224[ebp]
	mov	edx, DWORD PTR __Plast$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jl	SHORT $LN24@Unguarded_

; 3037 : 		++_Plast;

	mov	ecx, DWORD PTR __Plast$[ebp]
	add	ecx, 4
	mov	DWORD PTR __Plast$[ebp], ecx
	jmp	SHORT $LN160@Unguarded_
$LN24@Unguarded_:

; 3038 : 
; 3039 : 	_RanIt _Gfirst = _Plast;

	mov	edx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR __Gfirst$[ebp], edx

; 3040 : 	_RanIt _Glast = _Pfirst;

	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR __Glast$[ebp], eax
$LN23@Unguarded_:

; 3041 : 
; 3042 : 	for (; ; )
; 3043 : 		{	// partition
; 3044 : 		for (; _Gfirst < _Last; ++_Gfirst)

	jmp	SHORT $LN186@Unguarded_
$LN20@Unguarded_:
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	add	ecx, 4
	mov	DWORD PTR __Gfirst$[ebp], ecx
$LN186@Unguarded_:
	mov	edx, DWORD PTR __Gfirst$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	je	$LN19@Unguarded_

; 3045 : 			if (_DEBUG_LT(*_Pfirst, *_Gfirst))

	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T230260[ebp], edx
	mov	eax, DWORD PTR $T230260[ebp]
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN198@Unguarded_
	jmp	$LN17@Unguarded_

; 3046 : 				;
; 3047 : 			else if (*_Gfirst < *_Pfirst)

$LN198@Unguarded_:
	mov	eax, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR $T230277[ebp], eax
	mov	ecx, DWORD PTR $T230277[ebp]
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jge	SHORT $LN16@Unguarded_

; 3048 : 				break;

	jmp	$LN19@Unguarded_

; 3049 : 			else

	jmp	SHORT $LN17@Unguarded_
$LN16@Unguarded_:

; 3050 : 				std::iter_swap(_Plast++, _Gfirst);

	mov	ecx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR __Tmp$230296[ebp], ecx
	mov	edx, DWORD PTR __Plast$[ebp]
	add	edx, 4
	mov	DWORD PTR __Plast$[ebp], edx
	mov	eax, DWORD PTR __Tmp$230296[ebp]
	mov	DWORD PTR $T229840[ebp], eax
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR $T230341[ebp], ecx
	mov	edx, DWORD PTR $T229840[ebp]
	mov	DWORD PTR $T230340[ebp], edx
	mov	eax, DWORD PTR $T230341[ebp]
	mov	DWORD PTR $T230311[ebp], eax
	mov	ecx, DWORD PTR $T230340[ebp]
	mov	DWORD PTR $T230325[ebp], ecx
	mov	edx, DWORD PTR $T230325[ebp]
	cmp	edx, DWORD PTR $T230311[ebp]
	je	SHORT $LN17@Unguarded_
	mov	eax, DWORD PTR $T230325[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$230339[ebp], ecx
	mov	edx, DWORD PTR $T230325[ebp]
	mov	eax, DWORD PTR $T230311[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T230311[ebp]
	mov	eax, DWORD PTR __Tmp$230339[ebp]
	mov	DWORD PTR [edx], eax
$LN17@Unguarded_:
	jmp	$LN20@Unguarded_
$LN19@Unguarded_:

; 3051 : 		for (; _First < _Glast; --_Glast)

	jmp	SHORT $LN227@Unguarded_
$LN13@Unguarded_:
	mov	ecx, DWORD PTR __Glast$[ebp]
	sub	ecx, 4
	mov	DWORD PTR __Glast$[ebp], ecx
$LN227@Unguarded_:
	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Glast$[ebp]
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	je	$LN286@Unguarded_

; 3052 : 			if (_DEBUG_LT(*(_Glast - 1), *_Pfirst))

	mov	edx, DWORD PTR __Glast$[ebp]
	mov	DWORD PTR __Tmp$230370[ebp], edx
	mov	eax, 1
	neg	eax
	mov	ecx, DWORD PTR __Tmp$230370[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Tmp$230370[ebp], edx
	mov	eax, DWORD PTR __Tmp$230370[ebp]
	mov	DWORD PTR $T229841[ebp], eax
	mov	ecx, DWORD PTR $T229841[ebp]
	mov	DWORD PTR $T230386[ebp], ecx
	mov	edx, DWORD PTR $T230386[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN247@Unguarded_
	jmp	$LN10@Unguarded_

; 3053 : 				;
; 3054 : 			else if (*_Pfirst < *(_Glast - 1))

$LN247@Unguarded_:
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T230403[ebp], edx
	mov	eax, DWORD PTR __Glast$[ebp]
	mov	DWORD PTR __Tmp$230428[ebp], eax
	mov	ecx, 1
	neg	ecx
	mov	edx, DWORD PTR __Tmp$230428[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Tmp$230428[ebp], eax
	mov	ecx, DWORD PTR __Tmp$230428[ebp]
	mov	DWORD PTR $T229842[ebp], ecx
	mov	edx, DWORD PTR $T230403[ebp]
	mov	eax, DWORD PTR $T229842[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN9@Unguarded_

; 3055 : 				break;

	jmp	$LN286@Unguarded_

; 3056 : 			else

	jmp	$LN10@Unguarded_
$LN9@Unguarded_:

; 3057 : 				std::iter_swap(--_Pfirst, _Glast - 1);

	mov	edx, DWORD PTR __Glast$[ebp]
	mov	DWORD PTR __Tmp$230461[ebp], edx
	mov	eax, 1
	neg	eax
	mov	ecx, DWORD PTR __Tmp$230461[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Tmp$230461[ebp], edx
	mov	eax, DWORD PTR __Tmp$230461[ebp]
	mov	DWORD PTR $T229843[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	sub	ecx, 4
	mov	DWORD PTR __Pfirst$[ebp], ecx
	mov	edx, DWORD PTR $T229843[ebp]
	mov	DWORD PTR $T230509[ebp], edx
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T230508[ebp], eax
	mov	ecx, DWORD PTR $T230509[ebp]
	mov	DWORD PTR $T230479[ebp], ecx
	mov	edx, DWORD PTR $T230508[ebp]
	mov	DWORD PTR $T230493[ebp], edx
	mov	eax, DWORD PTR $T230493[ebp]
	cmp	eax, DWORD PTR $T230479[ebp]
	je	SHORT $LN10@Unguarded_
	mov	ecx, DWORD PTR $T230493[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$230506[ebp], edx
	mov	eax, DWORD PTR $T230493[ebp]
	mov	ecx, DWORD PTR $T230479[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR $T230479[ebp]
	mov	ecx, DWORD PTR __Tmp$230506[ebp]
	mov	DWORD PTR [eax], ecx
$LN10@Unguarded_:
	jmp	$LN13@Unguarded_

; 3058 : 		if (_Glast == _First && _Gfirst == _Last)

$LN286@Unguarded_:
	mov	edx, DWORD PTR __Glast$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __First$[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN292@Unguarded_
	mov	edx, DWORD PTR __Gfirst$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN292@Unguarded_

; 3059 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR __Plast$[ebp]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN28@Unguarded_

; 3060 : 
; 3061 : 		if (_Glast == _First)

$LN292@Unguarded_:
	mov	eax, DWORD PTR __Glast$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __First$[ebp]
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	$LN340@Unguarded_

; 3062 : 			{	// no room at bottom, rotate pivot upward
; 3063 : 			if (_Plast != _Gfirst)

	mov	eax, DWORD PTR __Plast$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Gfirst$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN5@Unguarded_

; 3064 : 				std::iter_swap(_Pfirst, _Plast);

	mov	ecx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T230569[ebp], ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T230568[ebp], edx
	mov	eax, DWORD PTR $T230569[ebp]
	mov	DWORD PTR $T230539[ebp], eax
	mov	ecx, DWORD PTR $T230568[ebp]
	mov	DWORD PTR $T230553[ebp], ecx
	mov	edx, DWORD PTR $T230553[ebp]
	cmp	edx, DWORD PTR $T230539[ebp]
	je	SHORT $LN5@Unguarded_
	mov	eax, DWORD PTR $T230553[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$230566[ebp], ecx
	mov	edx, DWORD PTR $T230553[ebp]
	mov	eax, DWORD PTR $T230539[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T230539[ebp]
	mov	eax, DWORD PTR __Tmp$230566[ebp]
	mov	DWORD PTR [edx], eax
$LN5@Unguarded_:

; 3065 : 			++_Plast;

	mov	ecx, DWORD PTR __Plast$[ebp]
	add	ecx, 4
	mov	DWORD PTR __Plast$[ebp], ecx

; 3066 : 			std::iter_swap(_Pfirst++, _Gfirst++);

	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR __Tmp$230593[ebp], edx
	mov	eax, DWORD PTR __Gfirst$[ebp]
	add	eax, 4
	mov	DWORD PTR __Gfirst$[ebp], eax
	mov	ecx, DWORD PTR __Tmp$230593[ebp]
	mov	DWORD PTR $T229844[ebp], ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR __Tmp$230609[ebp], edx
	mov	eax, DWORD PTR __Pfirst$[ebp]
	add	eax, 4
	mov	DWORD PTR __Pfirst$[ebp], eax
	mov	ecx, DWORD PTR __Tmp$230609[ebp]
	mov	DWORD PTR $T229845[ebp], ecx
	mov	edx, DWORD PTR $T229844[ebp]
	mov	DWORD PTR $T230649[ebp], edx
	mov	eax, DWORD PTR $T229845[ebp]
	mov	DWORD PTR $T230648[ebp], eax
	mov	ecx, DWORD PTR $T230649[ebp]
	mov	DWORD PTR $T230619[ebp], ecx
	mov	edx, DWORD PTR $T230648[ebp]
	mov	DWORD PTR $T230633[ebp], edx
	mov	eax, DWORD PTR $T230633[ebp]
	cmp	eax, DWORD PTR $T230619[ebp]
	je	SHORT $LN327@Unguarded_
	mov	ecx, DWORD PTR $T230633[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$230646[ebp], edx
	mov	eax, DWORD PTR $T230633[ebp]
	mov	ecx, DWORD PTR $T230619[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR $T230619[ebp]
	mov	ecx, DWORD PTR __Tmp$230646[ebp]
	mov	DWORD PTR [eax], ecx
$LN327@Unguarded_:

; 3067 : 			}
; 3068 : 		else if (_Gfirst == _Last)

	jmp	$LN4@Unguarded_
$LN340@Unguarded_:
	mov	edx, DWORD PTR __Gfirst$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	$LN3@Unguarded_

; 3069 : 			{	// no room at top, rotate pivot downward
; 3070 : 			if (--_Glast != --_Pfirst)

	mov	edx, DWORD PTR __Pfirst$[ebp]
	sub	edx, 4
	mov	DWORD PTR __Pfirst$[ebp], edx
	mov	eax, DWORD PTR __Glast$[ebp]
	sub	eax, 4
	mov	DWORD PTR __Glast$[ebp], eax
	mov	ecx, DWORD PTR __Glast$[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR __Pfirst$[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Unguarded_

; 3071 : 				std::iter_swap(_Glast, _Pfirst);

	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T230716[ebp], edx
	mov	eax, DWORD PTR __Glast$[ebp]
	mov	DWORD PTR $T230715[ebp], eax
	mov	ecx, DWORD PTR $T230716[ebp]
	mov	DWORD PTR $T230686[ebp], ecx
	mov	edx, DWORD PTR $T230715[ebp]
	mov	DWORD PTR $T230700[ebp], edx
	mov	eax, DWORD PTR $T230700[ebp]
	cmp	eax, DWORD PTR $T230686[ebp]
	je	SHORT $LN2@Unguarded_
	mov	ecx, DWORD PTR $T230700[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$230713[ebp], edx
	mov	eax, DWORD PTR $T230700[ebp]
	mov	ecx, DWORD PTR $T230686[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR $T230686[ebp]
	mov	ecx, DWORD PTR __Tmp$230713[ebp]
	mov	DWORD PTR [eax], ecx
$LN2@Unguarded_:

; 3072 : 			std::iter_swap(_Pfirst, --_Plast);

	mov	edx, DWORD PTR __Plast$[ebp]
	sub	edx, 4
	mov	DWORD PTR __Plast$[ebp], edx
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T230764[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T230763[ebp], ecx
	mov	edx, DWORD PTR $T230764[ebp]
	mov	DWORD PTR $T230734[ebp], edx
	mov	eax, DWORD PTR $T230763[ebp]
	mov	DWORD PTR $T230748[ebp], eax
	mov	ecx, DWORD PTR $T230748[ebp]
	cmp	ecx, DWORD PTR $T230734[ebp]
	je	SHORT $LN371@Unguarded_
	mov	edx, DWORD PTR $T230748[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$230761[ebp], eax
	mov	ecx, DWORD PTR $T230748[ebp]
	mov	edx, DWORD PTR $T230734[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T230734[ebp]
	mov	edx, DWORD PTR __Tmp$230761[ebp]
	mov	DWORD PTR [ecx], edx
$LN371@Unguarded_:

; 3073 : 			}
; 3074 : 		else

	jmp	$LN4@Unguarded_
$LN3@Unguarded_:

; 3075 : 			std::iter_swap(_Gfirst++, --_Glast);

	mov	eax, DWORD PTR __Glast$[ebp]
	sub	eax, 4
	mov	DWORD PTR __Glast$[ebp], eax
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR __Tmp$230788[ebp], ecx
	mov	edx, DWORD PTR __Gfirst$[ebp]
	add	edx, 4
	mov	DWORD PTR __Gfirst$[ebp], edx
	mov	eax, DWORD PTR __Tmp$230788[ebp]
	mov	DWORD PTR $T229846[ebp], eax
	mov	ecx, DWORD PTR __Glast$[ebp]
	mov	DWORD PTR $T230828[ebp], ecx
	mov	edx, DWORD PTR $T229846[ebp]
	mov	DWORD PTR $T230827[ebp], edx
	mov	eax, DWORD PTR $T230828[ebp]
	mov	DWORD PTR $T230798[ebp], eax
	mov	ecx, DWORD PTR $T230827[ebp]
	mov	DWORD PTR $T230812[ebp], ecx
	mov	edx, DWORD PTR $T230812[ebp]
	cmp	edx, DWORD PTR $T230798[ebp]
	je	SHORT $LN4@Unguarded_
	mov	eax, DWORD PTR $T230812[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$230825[ebp], ecx
	mov	edx, DWORD PTR $T230812[ebp]
	mov	eax, DWORD PTR $T230798[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T230798[ebp]
	mov	eax, DWORD PTR __Tmp$230825[ebp]
	mov	DWORD PTR [edx], eax
$LN4@Unguarded_:

; 3076 : 		}

	jmp	$LN23@Unguarded_
$LN28@Unguarded_:

; 3077 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unguarded_partition@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YA?AU?$pair@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@V12@@0@V?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z ENDP ; std::_Unguarded_partition<std::_Vector_iterator<int,std::allocator<int> > >
_TEXT	ENDS
PUBLIC	??$_Med3@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<int,std::allocator<int> > >
; Function compile flags: /Odtp
;	COMDAT ??$_Median@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@00@Z
_TEXT	SEGMENT
__Tmp$231534 = -284					; size = 4
__Tmp$231518 = -280					; size = 4
__Tmp$231314 = -204					; size = 4
__Tmp$231291 = -200					; size = 4
__Tmp$231099 = -124					; size = 4
__Tmp$231074 = -120					; size = 4
__Tmp$230886 = -44					; size = 4
__Tmp$230870 = -40					; size = 4
$T230838 = -36						; size = 4
$T230837 = -32						; size = 4
$T230836 = -28						; size = 4
$T230835 = -24						; size = 4
$T230834 = -20						; size = 4
$T230833 = -16						; size = 4
$T230832 = -12						; size = 4
$T230831 = -8						; size = 4
__Step$225149 = -4					; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Median@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@00@Z PROC ; std::_Median<std::_Vector_iterator<int,std::allocator<int> > >, COMDAT

; 3009 : 	{	// sort median element to middle

	push	ebp
	mov	ebp, esp
	sub	esp, 428				; 000001acH

; 3010 : 	if (40 < _Last - _First)

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	cmp	eax, 40					; 00000028H
	jle	$LN2@Median

; 3011 : 		{	// median of nine
; 3012 : 		size_t _Step = (_Last - _First + 1) / 8;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	add	eax, 1
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	DWORD PTR __Step$225149[ebp], eax

; 3013 : 		std::_Med3(_First, _First + _Step, _First + 2 * _Step);

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$230870[ebp], ecx
	mov	edx, DWORD PTR __Step$225149[ebp]
	shl	edx, 1
	mov	eax, DWORD PTR __Tmp$230870[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR __Tmp$230870[ebp], ecx
	mov	edx, DWORD PTR __Tmp$230870[ebp]
	mov	DWORD PTR $T230831[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$230886[ebp], eax
	mov	ecx, DWORD PTR __Step$225149[ebp]
	mov	edx, DWORD PTR __Tmp$230886[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Tmp$230886[ebp], eax
	mov	ecx, DWORD PTR __Tmp$230886[ebp]
	mov	DWORD PTR $T230832[ebp], ecx
	mov	edx, DWORD PTR $T230831[ebp]
	push	edx
	mov	eax, DWORD PTR $T230832[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Med3@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<int,std::allocator<int> > >
	add	esp, 12					; 0000000cH

; 3014 : 		std::_Med3(_Mid - _Step, _Mid, _Mid + _Step);

	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Tmp$231074[ebp], edx
	mov	eax, DWORD PTR __Step$225149[ebp]
	mov	ecx, DWORD PTR __Tmp$231074[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Tmp$231074[ebp], edx
	mov	eax, DWORD PTR __Tmp$231074[ebp]
	mov	DWORD PTR $T230833[ebp], eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Tmp$231099[ebp], ecx
	mov	edx, DWORD PTR __Step$225149[ebp]
	neg	edx
	mov	eax, DWORD PTR __Tmp$231099[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR __Tmp$231099[ebp], ecx
	mov	edx, DWORD PTR __Tmp$231099[ebp]
	mov	DWORD PTR $T230834[ebp], edx
	mov	eax, DWORD PTR $T230833[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T230834[ebp]
	push	edx
	call	??$_Med3@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<int,std::allocator<int> > >
	add	esp, 12					; 0000000cH

; 3015 : 		std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last);

	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __Tmp$231291[ebp], eax
	mov	ecx, DWORD PTR __Step$225149[ebp]
	neg	ecx
	mov	edx, DWORD PTR __Tmp$231291[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Tmp$231291[ebp], eax
	mov	ecx, DWORD PTR __Tmp$231291[ebp]
	mov	DWORD PTR $T230835[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __Tmp$231314[ebp], edx
	mov	eax, DWORD PTR __Step$225149[ebp]
	shl	eax, 1
	neg	eax
	mov	ecx, DWORD PTR __Tmp$231314[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Tmp$231314[ebp], edx
	mov	eax, DWORD PTR __Tmp$231314[ebp]
	mov	DWORD PTR $T230836[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T230835[ebp]
	push	edx
	mov	eax, DWORD PTR $T230836[ebp]
	push	eax
	call	??$_Med3@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<int,std::allocator<int> > >
	add	esp, 12					; 0000000cH

; 3016 : 		std::_Med3(_First + _Step, _Mid, _Last - _Step);

	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __Tmp$231518[ebp], ecx
	mov	edx, DWORD PTR __Step$225149[ebp]
	neg	edx
	mov	eax, DWORD PTR __Tmp$231518[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR __Tmp$231518[ebp], ecx
	mov	edx, DWORD PTR __Tmp$231518[ebp]
	mov	DWORD PTR $T230837[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$231534[ebp], eax
	mov	ecx, DWORD PTR __Step$225149[ebp]
	mov	edx, DWORD PTR __Tmp$231534[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Tmp$231534[ebp], eax
	mov	ecx, DWORD PTR __Tmp$231534[ebp]
	mov	DWORD PTR $T230838[ebp], ecx
	mov	edx, DWORD PTR $T230837[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T230838[ebp]
	push	ecx
	call	??$_Med3@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<int,std::allocator<int> > >
	add	esp, 12					; 0000000cH

; 3017 : 		}
; 3018 : 	else

	jmp	SHORT $LN3@Median
$LN2@Median:

; 3019 : 		std::_Med3(_First, _Mid, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Med3@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<int,std::allocator<int> > >
	add	esp, 12					; 0000000cH
$LN3@Median:

; 3020 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Median@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@00@Z ENDP ; std::_Median<std::_Vector_iterator<int,std::allocator<int> > >
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@HH@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@HHH@Z ; std::_Adjust_heap<std::_Vector_iterator<int,std::allocator<int> >,int,int>
; Function compile flags: /Odtp
;	COMDAT ??$_Make_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@HH@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAH1@Z
_TEXT	SEGMENT
__Tmp$231905 = -16					; size = 4
$T231881 = -12						; size = 4
__Hole$225175 = -8					; size = 4
__Bottom$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Make_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@HH@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAH1@Z PROC ; std::_Make_heap<std::_Vector_iterator<int,std::allocator<int> >,int,int>, COMDAT

; 2164 : 	{	// make nontrivial [_First, _Last) into a heap, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH

; 2165 : 	_Diff _Bottom = _Last - _First;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Bottom$[ebp], eax

; 2166 : 
; 2167 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

	mov	eax, DWORD PTR __Bottom$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Hole$225175[ebp], eax
$LN2@Make_heap:
	cmp	DWORD PTR __Hole$225175[ebp], 0
	jle	SHORT $LN3@Make_heap

; 2168 : 		{	// reheap top half, bottom to top
; 2169 : 		--_Hole;

	mov	ecx, DWORD PTR __Hole$225175[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Hole$225175[ebp], ecx

; 2170 : 		std::_Adjust_heap(_First, _Hole, _Bottom,
; 2171 : 			_Ty(*(_First + _Hole)));

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$231905[ebp], edx
	mov	eax, DWORD PTR __Hole$225175[ebp]
	mov	ecx, DWORD PTR __Tmp$231905[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Tmp$231905[ebp], edx
	mov	eax, DWORD PTR __Tmp$231905[ebp]
	mov	DWORD PTR $T231881[ebp], eax
	mov	ecx, DWORD PTR $T231881[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR __Bottom$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Hole$225175[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Adjust_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@HH@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@HHH@Z ; std::_Adjust_heap<std::_Vector_iterator<int,std::allocator<int> >,int,int>
	add	esp, 16					; 00000010H

; 2172 : 		}

	jmp	SHORT $LN2@Make_heap
$LN3@Make_heap:

; 2173 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Make_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@HH@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAH1@Z ENDP ; std::_Make_heap<std::_Vector_iterator<int,std::allocator<int> >,int,int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Insertion_sort1@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAH@Z
_TEXT	SEGMENT
$T232374 = -64						; size = 4
$T232341 = -60						; size = 4
$T232340 = -56						; size = 4
$T232339 = -52						; size = 4
$T232303 = -46						; size = 1
$T232302 = -45						; size = 1
$T232301 = -44						; size = 4
$T232300 = -40						; size = 4
$T232299 = -36						; size = 4
$T232258 = -32						; size = 4
__Cat$232309 = -24					; size = 1
$T232307 = -23						; size = 1
$T232306 = -22						; size = 1
$T232305 = -21						; size = 1
$T232172 = -20						; size = 4
__First1$225216 = -16					; size = 4
__Val$225205 = -12					; size = 4
__Next1$225204 = -8					; size = 4
__Next$225200 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAH@Z PROC ; std::_Insertion_sort1<std::_Vector_iterator<int,std::allocator<int> >,int>, COMDAT

; 2967 : 	{	// insertion sort [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 2968 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	$LN9@Insertion_

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$225200[ebp], ecx
$LN7@Insertion_:
	mov	edx, DWORD PTR __Next$225200[ebp]
	add	edx, 4
	mov	DWORD PTR __Next$225200[ebp], edx
	mov	eax, DWORD PTR __Next$225200[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	$LN9@Insertion_

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;

	mov	ecx, DWORD PTR __Next$225200[ebp]
	mov	DWORD PTR __Next1$225204[ebp], ecx

; 2972 : 			_Ty _Val = *_Next;

	mov	edx, DWORD PTR __Next$225200[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Val$225205[ebp], eax

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR __Val$225205[ebp]
	cmp	edx, DWORD PTR [ecx]
	jge	$LN5@Insertion_

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	eax, DWORD PTR __Next1$225204[ebp]
	add	eax, 4
	mov	DWORD PTR __Next1$225204[ebp], eax
	mov	ecx, DWORD PTR __Next1$225204[ebp]
	mov	DWORD PTR $T232341[ebp], ecx
	mov	edx, DWORD PTR __Next$225200[ebp]
	mov	DWORD PTR $T232340[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T232339[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T232305[ebp], cl
	mov	dl, BYTE PTR __Cat$232309[ebp]
	mov	BYTE PTR $T232306[ebp], dl
	mov	al, BYTE PTR $T232305[ebp]
	mov	BYTE PTR $T232303[ebp], al
	mov	cl, BYTE PTR $T232307[ebp]
	mov	BYTE PTR $T232302[ebp], cl
	mov	edx, DWORD PTR $T232341[ebp]
	mov	DWORD PTR $T232301[ebp], edx
	mov	eax, DWORD PTR $T232340[ebp]
	mov	DWORD PTR $T232300[ebp], eax
	mov	ecx, DWORD PTR $T232339[ebp]
	mov	DWORD PTR $T232299[ebp], ecx
$LN45@Insertion_:
	mov	edx, DWORD PTR $T232299[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T232300[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN41@Insertion_
	mov	eax, DWORD PTR $T232300[ebp]
	sub	eax, 4
	mov	DWORD PTR $T232300[ebp], eax
	mov	ecx, DWORD PTR $T232300[ebp]
	mov	DWORD PTR $T232258[ebp], ecx
	mov	edx, DWORD PTR $T232301[ebp]
	sub	edx, 4
	mov	DWORD PTR $T232301[ebp], edx
	mov	eax, DWORD PTR $T232301[ebp]
	mov	ecx, DWORD PTR $T232258[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN45@Insertion_
$LN41@Insertion_:
	mov	eax, DWORD PTR $T232301[ebp]
	mov	DWORD PTR $T232172[ebp], eax

; 2977 : 				*_First = _Val;

	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR __Val$225205[ebp]
	mov	DWORD PTR [ecx], edx

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_
$LN5@Insertion_:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;

	mov	eax, DWORD PTR __Next1$225204[ebp]
	mov	DWORD PTR __First1$225216[ebp], eax

; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	jmp	SHORT $LN3@Insertion_
$LN2@Insertion_:
	mov	ecx, DWORD PTR __First1$225216[ebp]
	mov	DWORD PTR __Next1$225204[ebp], ecx
$LN3@Insertion_:
	mov	edx, DWORD PTR __First1$225216[ebp]
	sub	edx, 4
	mov	DWORD PTR __First1$225216[ebp], edx
	mov	eax, DWORD PTR __First1$225216[ebp]
	mov	ecx, DWORD PTR __Val$225205[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN85@Insertion_

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	edx, DWORD PTR __First1$225216[ebp]
	mov	DWORD PTR $T232374[ebp], edx
	mov	eax, DWORD PTR __Next1$225204[ebp]
	mov	ecx, DWORD PTR $T232374[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN2@Insertion_

; 2985 : 				*_Next1 = _Val;	// insert element in hole

$LN85@Insertion_:
	mov	eax, DWORD PTR __Next1$225204[ebp]
	mov	ecx, DWORD PTR __Val$225205[ebp]
	mov	DWORD PTR [eax], ecx
$LN4@Insertion_:

; 2986 : 				}
; 2987 : 			}

	jmp	$LN7@Insertion_
$LN9@Insertion_:

; 2988 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Insertion_sort1@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAH@Z ENDP ; std::_Insertion_sort1<std::_Vector_iterator<int,std::allocator<int> >,int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Med3@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@00@Z
_TEXT	SEGMENT
$T232563 = -72						; size = 4
$T232562 = -68						; size = 4
$T232547 = -64						; size = 4
__Tmp$232560 = -60					; size = 4
$T232533 = -56						; size = 4
$T232515 = -52						; size = 4
$T232506 = -48						; size = 4
$T232505 = -44						; size = 4
$T232490 = -40						; size = 4
__Tmp$232503 = -36					; size = 4
$T232476 = -32						; size = 4
$T232458 = -28						; size = 4
$T232449 = -24						; size = 4
$T232448 = -20						; size = 4
$T232433 = -16						; size = 4
__Tmp$232446 = -12					; size = 4
$T232419 = -8						; size = 4
$T232401 = -4						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Med3@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@00@Z PROC ; std::_Med3<std::_Vector_iterator<int,std::allocator<int> > >, COMDAT

; 2998 : 	{	// sort median of three elements to middle

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H

; 2999 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T232401[ebp], eax
	mov	ecx, DWORD PTR $T232401[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jge	SHORT $LN29@Med3

; 3000 : 		std::iter_swap(_Mid, _First);

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T232449[ebp], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T232448[ebp], edx
	mov	eax, DWORD PTR $T232449[ebp]
	mov	DWORD PTR $T232419[ebp], eax
	mov	ecx, DWORD PTR $T232448[ebp]
	mov	DWORD PTR $T232433[ebp], ecx
	mov	edx, DWORD PTR $T232433[ebp]
	cmp	edx, DWORD PTR $T232419[ebp]
	je	SHORT $LN29@Med3
	mov	eax, DWORD PTR $T232433[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$232446[ebp], ecx
	mov	edx, DWORD PTR $T232433[ebp]
	mov	eax, DWORD PTR $T232419[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T232419[ebp]
	mov	eax, DWORD PTR __Tmp$232446[ebp]
	mov	DWORD PTR [edx], eax

; 3001 : 	if (_DEBUG_LT(*_Last, *_Mid))

$LN29@Med3:
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T232458[ebp], ecx
	mov	edx, DWORD PTR $T232458[ebp]
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN50@Med3

; 3002 : 		std::iter_swap(_Last, _Mid);

	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T232506[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T232505[ebp], eax
	mov	ecx, DWORD PTR $T232506[ebp]
	mov	DWORD PTR $T232476[ebp], ecx
	mov	edx, DWORD PTR $T232505[ebp]
	mov	DWORD PTR $T232490[ebp], edx
	mov	eax, DWORD PTR $T232490[ebp]
	cmp	eax, DWORD PTR $T232476[ebp]
	je	SHORT $LN50@Med3
	mov	ecx, DWORD PTR $T232490[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$232503[ebp], edx
	mov	eax, DWORD PTR $T232490[ebp]
	mov	ecx, DWORD PTR $T232476[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR $T232476[ebp]
	mov	ecx, DWORD PTR __Tmp$232503[ebp]
	mov	DWORD PTR [eax], ecx

; 3003 : 	if (_DEBUG_LT(*_Mid, *_First))

$LN50@Med3:
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T232515[ebp], edx
	mov	eax, DWORD PTR $T232515[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN4@Med3

; 3004 : 		std::iter_swap(_Mid, _First);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T232563[ebp], eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T232562[ebp], ecx
	mov	edx, DWORD PTR $T232563[ebp]
	mov	DWORD PTR $T232533[ebp], edx
	mov	eax, DWORD PTR $T232562[ebp]
	mov	DWORD PTR $T232547[ebp], eax
	mov	ecx, DWORD PTR $T232547[ebp]
	cmp	ecx, DWORD PTR $T232533[ebp]
	je	SHORT $LN4@Med3
	mov	edx, DWORD PTR $T232547[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$232560[ebp], eax
	mov	ecx, DWORD PTR $T232547[ebp]
	mov	edx, DWORD PTR $T232533[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T232533[ebp]
	mov	edx, DWORD PTR __Tmp$232560[ebp]
	mov	DWORD PTR [ecx], edx
$LN4@Med3:

; 3005 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Med3@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@00@Z ENDP ; std::_Med3<std::_Vector_iterator<int,std::allocator<int> > >
_TEXT	ENDS
PUBLIC	??$_Push_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@HH@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@HHH@Z ; std::_Push_heap<std::_Vector_iterator<int,std::allocator<int> >,int,int>
; Function compile flags: /Odtp
;	COMDAT ??$_Adjust_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@HH@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@HHH@Z
_TEXT	SEGMENT
__Tmp$232710 = -68					; size = 4
$T232694 = -64						; size = 4
__Tmp$232685 = -60					; size = 4
__Tmp$232661 = -56					; size = 4
$T232645 = -52						; size = 4
__Tmp$232636 = -48					; size = 4
__Tmp$232612 = -44					; size = 4
$T232596 = -40						; size = 4
__Tmp$232587 = -36					; size = 4
$T232571 = -32						; size = 4
$T232570 = -28						; size = 4
$T232569 = -24						; size = 4
$T232568 = -20						; size = 4
$T232567 = -16						; size = 4
$T232566 = -12						; size = 4
__Idx$ = -8						; size = 4
__Top$ = -4						; size = 4
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 4
??$_Adjust_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@HH@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@HHH@Z PROC ; std::_Adjust_heap<std::_Vector_iterator<int,std::allocator<int> >,int,int>, COMDAT

; 2055 : 	{	// percolate _Hole to _Bottom, then push _Val, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH

; 2056 : 	_Diff _Top = _Hole;

	mov	eax, DWORD PTR __Hole$[ebp]
	mov	DWORD PTR __Top$[ebp], eax

; 2057 : 	_Diff _Idx = 2 * _Hole + 2;

	mov	ecx, DWORD PTR __Hole$[ebp]
	lea	edx, DWORD PTR [ecx+ecx+2]
	mov	DWORD PTR __Idx$[ebp], edx

; 2058 : 
; 2059 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	jmp	SHORT $LN5@Adjust_hea
$LN4@Adjust_hea:
	mov	eax, DWORD PTR __Idx$[ebp]
	lea	ecx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __Idx$[ebp], ecx
$LN5@Adjust_hea:
	mov	edx, DWORD PTR __Idx$[ebp]
	cmp	edx, DWORD PTR __Bottom$[ebp]
	jge	$LN3@Adjust_hea

; 2060 : 		{	// move _Hole down to larger child
; 2061 : 		if (_DEBUG_LT(*(_First + _Idx), *(_First + (_Idx - 1))))

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$232587[ebp], eax
	mov	ecx, DWORD PTR __Idx$[ebp]
	mov	edx, DWORD PTR __Tmp$232587[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Tmp$232587[ebp], eax
	mov	ecx, DWORD PTR __Tmp$232587[ebp]
	mov	DWORD PTR $T232566[ebp], ecx
	mov	edx, DWORD PTR $T232566[ebp]
	mov	DWORD PTR $T232596[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$232612[ebp], eax
	mov	ecx, DWORD PTR __Idx$[ebp]
	mov	edx, DWORD PTR __Tmp$232612[ebp]
	lea	eax, DWORD PTR [edx+ecx*4-4]
	mov	DWORD PTR __Tmp$232612[ebp], eax
	mov	ecx, DWORD PTR __Tmp$232612[ebp]
	mov	DWORD PTR $T232567[ebp], ecx
	mov	edx, DWORD PTR $T232596[ebp]
	mov	eax, DWORD PTR $T232567[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN2@Adjust_hea

; 2062 : 			--_Idx;

	mov	edx, DWORD PTR __Idx$[ebp]
	sub	edx, 1
	mov	DWORD PTR __Idx$[ebp], edx
$LN2@Adjust_hea:

; 2063 : 		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$232636[ebp], eax
	mov	ecx, DWORD PTR __Idx$[ebp]
	mov	edx, DWORD PTR __Tmp$232636[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Tmp$232636[ebp], eax
	mov	ecx, DWORD PTR __Tmp$232636[ebp]
	mov	DWORD PTR $T232569[ebp], ecx
	mov	edx, DWORD PTR $T232569[ebp]
	mov	DWORD PTR $T232645[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$232661[ebp], eax
	mov	ecx, DWORD PTR __Hole$[ebp]
	mov	edx, DWORD PTR __Tmp$232661[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Tmp$232661[ebp], eax
	mov	ecx, DWORD PTR __Tmp$232661[ebp]
	mov	DWORD PTR $T232568[ebp], ecx
	mov	edx, DWORD PTR $T232568[ebp]
	mov	eax, DWORD PTR $T232645[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR __Idx$[ebp]
	mov	DWORD PTR __Hole$[ebp], edx

; 2064 : 		}

	jmp	$LN4@Adjust_hea
$LN3@Adjust_hea:

; 2065 : 
; 2066 : 	if (_Idx == _Bottom)

	mov	eax, DWORD PTR __Idx$[ebp]
	cmp	eax, DWORD PTR __Bottom$[ebp]
	jne	SHORT $LN1@Adjust_hea

; 2067 : 		{	// only child at bottom, move _Hole down to it
; 2068 : 		*(_First + _Hole) = *(_First + (_Bottom - 1));

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$232685[ebp], ecx
	mov	edx, DWORD PTR __Bottom$[ebp]
	mov	eax, DWORD PTR __Tmp$232685[ebp]
	lea	ecx, DWORD PTR [eax+edx*4-4]
	mov	DWORD PTR __Tmp$232685[ebp], ecx
	mov	edx, DWORD PTR __Tmp$232685[ebp]
	mov	DWORD PTR $T232571[ebp], edx
	mov	eax, DWORD PTR $T232571[ebp]
	mov	DWORD PTR $T232694[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$232710[ebp], ecx
	mov	edx, DWORD PTR __Hole$[ebp]
	mov	eax, DWORD PTR __Tmp$232710[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR __Tmp$232710[ebp], ecx
	mov	edx, DWORD PTR __Tmp$232710[ebp]
	mov	DWORD PTR $T232570[ebp], edx
	mov	eax, DWORD PTR $T232570[ebp]
	mov	ecx, DWORD PTR $T232694[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 2069 : 		_Hole = _Bottom - 1;

	mov	eax, DWORD PTR __Bottom$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Hole$[ebp], eax
$LN1@Adjust_hea:

; 2070 : 		}
; 2071 : 	std::_Push_heap(_First, _Hole, _Top, _Val);

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Top$[ebp]
	push	edx
	mov	eax, DWORD PTR __Hole$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Push_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@HH@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@HHH@Z ; std::_Push_heap<std::_Vector_iterator<int,std::allocator<int> >,int,int>
	add	esp, 16					; 00000010H

; 2072 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Adjust_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@HH@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@HHH@Z ENDP ; std::_Adjust_heap<std::_Vector_iterator<int,std::allocator<int> >,int,int>
_TEXT	ENDS
PUBLIC	??$_Pop_heap_0@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAH@Z ; std::_Pop_heap_0<std::_Vector_iterator<int,std::allocator<int> >,int>
; Function compile flags: /Odtp
;	COMDAT ??$pop_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$pop_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z PROC ; std::pop_heap<std::_Vector_iterator<int,std::allocator<int> > >, COMDAT

; 2094 : 	{	// pop *_First to *(_Last - 1) and reheap, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH

; 2095 : 	_DEBUG_RANGE(_First, _Last);
; 2096 : 	_DEBUG_HEAP(_First, _Last);
; 2097 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	cmp	eax, 1
	jle	SHORT $LN2@pop_heap

; 2098 : 		_Pop_heap_0(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val_type(_First));

	push	0
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Pop_heap_0@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAH@Z ; std::_Pop_heap_0<std::_Vector_iterator<int,std::allocator<int> >,int>
	add	esp, 12					; 0000000cH
$LN2@pop_heap:

; 2099 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$pop_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z ENDP ; std::pop_heap<std::_Vector_iterator<int,std::allocator<int> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Push_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@HH@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@HHH@Z
_TEXT	SEGMENT
__Tmp$233319 = -40					; size = 4
__Tmp$233295 = -36					; size = 4
$T233279 = -32						; size = 4
__Tmp$233270 = -28					; size = 4
__Tmp$233246 = -24					; size = 4
$T233230 = -20						; size = 4
$T233229 = -16						; size = 4
$T233228 = -12						; size = 4
$T233227 = -8						; size = 4
__Idx$225353 = -4					; size = 4
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Top$ = 16						; size = 4
__Val$ = 20						; size = 4
??$_Push_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@HH@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@HHH@Z PROC ; std::_Push_heap<std::_Vector_iterator<int,std::allocator<int> >,int,int>, COMDAT

; 1972 : 	{	// percolate _Hole to _Top or where _Val belongs, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 1973 : 	for (_Diff _Idx = (_Hole - 1) / 2;

	mov	eax, DWORD PTR __Hole$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Idx$225353[ebp], eax

; 1974 : 		_Top < _Hole && _DEBUG_LT(*(_First + _Idx), _Val);
; 1975 : 		_Idx = (_Hole - 1) / 2)

	jmp	SHORT $LN3@Push_heap
$LN2@Push_heap:
	mov	eax, DWORD PTR __Hole$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Idx$225353[ebp], eax
$LN3@Push_heap:
	mov	eax, DWORD PTR __Top$[ebp]
	cmp	eax, DWORD PTR __Hole$[ebp]
	jge	SHORT $LN1@Push_heap
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$233246[ebp], ecx
	mov	edx, DWORD PTR __Idx$225353[ebp]
	mov	eax, DWORD PTR __Tmp$233246[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR __Tmp$233246[ebp], ecx
	mov	edx, DWORD PTR __Tmp$233246[ebp]
	mov	DWORD PTR $T233227[ebp], edx
	mov	eax, DWORD PTR $T233227[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR __Val$[ebp]
	jge	SHORT $LN1@Push_heap

; 1976 : 		{	// move _Hole up to parent
; 1977 : 		*(_First + _Hole) = *(_First + _Idx);

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$233270[ebp], edx
	mov	eax, DWORD PTR __Idx$225353[ebp]
	mov	ecx, DWORD PTR __Tmp$233270[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Tmp$233270[ebp], edx
	mov	eax, DWORD PTR __Tmp$233270[ebp]
	mov	DWORD PTR $T233229[ebp], eax
	mov	ecx, DWORD PTR $T233229[ebp]
	mov	DWORD PTR $T233279[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$233295[ebp], edx
	mov	eax, DWORD PTR __Hole$[ebp]
	mov	ecx, DWORD PTR __Tmp$233295[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Tmp$233295[ebp], edx
	mov	eax, DWORD PTR __Tmp$233295[ebp]
	mov	DWORD PTR $T233228[ebp], eax
	mov	ecx, DWORD PTR $T233228[ebp]
	mov	edx, DWORD PTR $T233279[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 1978 : 		_Hole = _Idx;

	mov	ecx, DWORD PTR __Idx$225353[ebp]
	mov	DWORD PTR __Hole$[ebp], ecx

; 1979 : 		}

	jmp	SHORT $LN2@Push_heap
$LN1@Push_heap:

; 1980 : 
; 1981 : 	*(_First + _Hole) = _Val;	// drop _Val into final hole

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$233319[ebp], edx
	mov	eax, DWORD PTR __Hole$[ebp]
	mov	ecx, DWORD PTR __Tmp$233319[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Tmp$233319[ebp], edx
	mov	eax, DWORD PTR __Tmp$233319[ebp]
	mov	DWORD PTR $T233230[ebp], eax
	mov	ecx, DWORD PTR $T233230[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [ecx], edx

; 1982 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Push_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@HH@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@HHH@Z ENDP ; std::_Push_heap<std::_Vector_iterator<int,std::allocator<int> >,int,int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Pop_heap_0@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAH@Z
_TEXT	SEGMENT
$T233719 = -156						; size = 4
$T233718 = -152						; size = 4
$T233717 = -148						; size = 4
$T233716 = -144						; size = 4
$T233429 = -32						; size = 4
__Tmp$233412 = -28					; size = 4
__Tmp$233387 = -24					; size = 4
$T233369 = -20						; size = 4
__Tmp$233353 = -16					; size = 4
$T233332 = -12						; size = 4
$T233331 = -8						; size = 4
$T233330 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Pop_heap_0@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAH@Z PROC ; std::_Pop_heap_0<std::_Vector_iterator<int,std::allocator<int> >,int>, COMDAT

; 2087 : 	{	// pop *_First to *(_Last - 1) and reheap, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH

; 2088 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2089 : 		_Ty(*(_Last - 1)), _Dist_type(_First));

	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __Tmp$233353[ebp], eax
	mov	ecx, 1
	neg	ecx
	mov	edx, DWORD PTR __Tmp$233353[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Tmp$233353[ebp], eax
	mov	ecx, DWORD PTR __Tmp$233353[ebp]
	mov	DWORD PTR $T233330[ebp], ecx
	mov	edx, DWORD PTR $T233330[ebp]
	mov	DWORD PTR $T233369[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __Tmp$233387[ebp], eax
	mov	ecx, 1
	neg	ecx
	mov	edx, DWORD PTR __Tmp$233387[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Tmp$233387[ebp], eax
	mov	ecx, DWORD PTR __Tmp$233387[ebp]
	mov	DWORD PTR $T233331[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __Tmp$233412[ebp], edx
	mov	eax, 1
	neg	eax
	mov	ecx, DWORD PTR __Tmp$233412[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Tmp$233412[ebp], edx
	mov	eax, DWORD PTR __Tmp$233412[ebp]
	mov	DWORD PTR $T233332[ebp], eax
	mov	ecx, DWORD PTR $T233369[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T233719[ebp], edx
	mov	eax, DWORD PTR $T233331[ebp]
	mov	DWORD PTR $T233718[ebp], eax
	mov	ecx, DWORD PTR $T233332[ebp]
	mov	DWORD PTR $T233717[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T233716[ebp], edx
	mov	eax, DWORD PTR $T233716[ebp]
	mov	DWORD PTR $T233429[ebp], eax
	mov	ecx, DWORD PTR $T233718[ebp]
	mov	edx, DWORD PTR $T233429[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T233719[ebp]
	push	ecx
	mov	edx, DWORD PTR $T233717[ebp]
	sub	edx, DWORD PTR $T233716[ebp]
	sar	edx, 2
	push	edx
	push	0
	mov	eax, DWORD PTR $T233716[ebp]
	push	eax
	call	??$_Adjust_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@HH@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@HHH@Z ; std::_Adjust_heap<std::_Vector_iterator<int,std::allocator<int> >,int,int>
	add	esp, 16					; 00000010H

; 2090 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Pop_heap_0@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAH@Z ENDP ; std::_Pop_heap_0<std::_Vector_iterator<int,std::allocator<int> >,int>
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -48						; size = 28
__$ArrayPad$ = -20					; size = 4
_args$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 2124				; 0000084cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);

	lea	eax, DWORD PTR _lpszFormat$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _args$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpszFormat$[ebp]
	push	edx
	lea	eax, DWORD PTR _result$[ebp]
	push	eax
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);

	mov	DWORD PTR _args$[ebp], 0

; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-2128]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	__$ArrayPad$
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	__imp___vsnprintf:PROC
; Function compile flags: /Odtp
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
tv74 = -2096						; size = 4
$T233760 = -2092					; size = 4
$T233759 = -2088					; size = 4
$T233758 = -2084					; size = 4
_maxlen$95294 = -2080					; size = 4
_kMaxAttempts$ = -2076					; size = 4
_buf$ = -2072						; size = 2048
__$ArrayPad$ = -20					; size = 4
_len$ = -16						; size = 4
_attempts$ = -12					; size = 4
_success$ = -5						; size = 1
_pbuf$ = -4						; size = 4
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2096				; 00000830H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	lea	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _pbuf$[ebp], eax

; 194  : 	int len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 195  : 	int attempts = 0;

	mov	DWORD PTR _attempts$[ebp], 0

; 196  : 	bool success = false;

	mov	BYTE PTR _success$[ebp], 0

; 197  : 	const int kMaxAttempts = 40;

	mov	DWORD PTR _kMaxAttempts$[ebp], 40	; 00000028H
$LN10@formatv:

; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;

	mov	ecx, DWORD PTR _attempts$[ebp]
	shl	ecx, 11					; 0000000bH
	add	ecx, 2047				; 000007ffH
	mov	DWORD PTR _maxlen$95294[ebp], ecx

; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	edx, DWORD PTR _args$[ebp]
	push	edx
	mov	eax, DWORD PTR _fmt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _maxlen$95294[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbuf$[ebp]
	push	edx
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR _len$[ebp], eax

; 203  : 		attempts++;

	mov	eax, DWORD PTR _attempts$[ebp]
	add	eax, 1
	mov	DWORD PTR _attempts$[ebp], eax

; 204  : 		success = (len>=0 && len<=maxlen);

	cmp	DWORD PTR _len$[ebp], 0
	jl	SHORT $LN13@formatv
	mov	ecx, DWORD PTR _len$[ebp]
	cmp	ecx, DWORD PTR _maxlen$95294[ebp]
	jg	SHORT $LN13@formatv
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN14@formatv
$LN13@formatv:
	mov	DWORD PTR tv74[ebp], 0
$LN14@formatv:
	mov	dl, BYTE PTR tv74[ebp]
	mov	BYTE PTR _success$[ebp], dl

; 205  : 		if (!success)

	movzx	eax, BYTE PTR _success$[ebp]
	test	eax, eax
	jne	SHORT $LN9@formatv

; 206  : 		{
; 207  : 			if (pbuf!=buf)

	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, edx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T233758[ebp], eax
	mov	ecx, DWORD PTR $T233758[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	mov	edx, DWORD PTR _attempts$[ebp]
	shl	edx, 11					; 0000000bH
	add	edx, 2048				; 00000800H
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T233759[ebp], eax
	mov	eax, DWORD PTR $T233759[ebp]
	mov	DWORD PTR _pbuf$[ebp], eax
$LN9@formatv:

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	movzx	ecx, BYTE PTR _success$[ebp]
	test	ecx, ecx
	jne	SHORT $LN4@formatv
	cmp	DWORD PTR _attempts$[ebp], 40		; 00000028H
	jl	$LN10@formatv
$LN4@formatv:

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)

	movzx	edx, BYTE PTR _success$[ebp]
	test	edx, edx
	je	SHORT $LN3@formatv

; 220  : 		out = pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 221  : 	else

	jmp	SHORT $LN2@formatv
$LN3@formatv:

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN2@formatv:

; 223  : 
; 224  : 	if (pbuf!=buf)

	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, edx
	je	SHORT $LN1@formatv

; 225  : 		delete [] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T233760[ebp], eax
	mov	ecx, DWORD PTR $T233760[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN1@formatv:

; 226  : 
; 227  : 	return success;

	mov	al, BYTE PTR _success$[ebp]

; 228  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT

; 298  : {

	push	ebp
	mov	ebp, esp

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	DWORD PTR _p$[ebp], 0
	jl	SHORT $LN1@teamType
	cmp	DWORD PTR _p$[ebp], 64			; 00000040H
	jge	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	eax, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN2@teamType
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1
$LN2@teamType:

; 302  : }

	pop	ebp
	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
EXTRN	_memset:PROC
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdatabaseutility.h
;	COMDAT ?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T233768 = -8						; size = 4
_i$172577 = -4						; size = 4
_pArray$ = 8						; size = 4
_count$ = 12						; size = 4
_iDefault$ = 16						; size = 4
?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z PROC	; CvDatabaseUtility::InitializeArray, COMDAT
; _this$ = ecx

; 120  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 121  : 	CvAssertMsg(count > 0, "Initializing array to 0 or less items.");
; 122  : #ifdef AUI_WARNING_FIXES
; 123  : 	delete[] pArray;
; 124  : #endif
; 125  : 	pArray = FNEW(int[count], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	eax, DWORD PTR _count$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T233768[ebp], eax
	mov	eax, DWORD PTR _pArray$[ebp]
	mov	ecx, DWORD PTR $T233768[ebp]
	mov	DWORD PTR [eax], ecx

; 126  : 	if(iDefault == 0)

	cmp	DWORD PTR _iDefault$[ebp], 0
	jne	SHORT $LN5@Initialize

; 127  : 	{
; 128  : 		ZeroMemory(pArray, sizeof(int) * count);

	mov	edx, DWORD PTR _count$[ebp]
	shl	edx, 2
	push	edx
	push	0
	mov	eax, DWORD PTR _pArray$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 129  : 	}
; 130  : 	else

	jmp	SHORT $LN6@Initialize
$LN5@Initialize:

; 131  : 	{
; 132  : 		for(size_t i = 0; i < count; ++i)

	mov	DWORD PTR _i$172577[ebp], 0
	jmp	SHORT $LN3@Initialize
$LN2@Initialize:
	mov	edx, DWORD PTR _i$172577[ebp]
	add	edx, 1
	mov	DWORD PTR _i$172577[ebp], edx
$LN3@Initialize:
	mov	eax, DWORD PTR _i$172577[ebp]
	cmp	eax, DWORD PTR _count$[ebp]
	jae	SHORT $LN6@Initialize

; 133  : 			pArray[i] = iDefault;

	mov	ecx, DWORD PTR _pArray$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _i$172577[ebp]
	mov	ecx, DWORD PTR _iDefault$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx
	jmp	SHORT $LN2@Initialize
$LN6@Initialize:

; 134  : 	}
; 135  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z ENDP	; CvDatabaseUtility::InitializeArray
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv88 = -132						; size = 4
tv145 = -128						; size = 4
_this$ = -124						; size = 4
$T233801 = -30						; size = 1
$T233788 = -29						; size = 1
$T233784 = -28						; size = 4
$T233777 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T233801[ebp]
	mov	DWORD PTR $T233777[ebp], eax
	lea	ecx, DWORD PTR $T233788[ebp]
	mov	DWORD PTR $T233784[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv145[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv88[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
; Function compile flags: /Odtp
;	COMDAT ??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Allocate@H@std@@YAPAHIPAH@Z			; std::_Allocate<int>
PUBLIC	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$233928 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z PROC	; std::vector<int,std::allocator<int> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@2

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@2
	jmp	SHORT $LN3@Buy@2
$LN4@Buy@2:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$233928[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$233928[ebp], 0
	jbe	SHORT $LN11@Buy@2
	mov	eax, DWORD PTR __Count$233928[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy@2
$LN11@Buy@2:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy@2:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy@2

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@2

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy@2:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy@2:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@2:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ENDP	; std::vector<int,std::allocator<int> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T233991 = -28						; size = 4
$T233990 = -24						; size = 4
$T233986 = -20						; size = 4
$T233985 = -16						; size = 4
$T233974 = -12						; size = 4
$T233973 = -8						; size = 4
__Cat$233980 = -2					; size = 1
$T233978 = -1						; size = 1
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy@2

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T233986[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T233985[ebp], ecx
	mov	edx, DWORD PTR $T233986[ebp]
	mov	DWORD PTR $T233974[ebp], edx
	mov	eax, DWORD PTR $T233985[ebp]
	mov	DWORD PTR $T233973[ebp], eax
	mov	cl, BYTE PTR __Cat$233980[ebp]
	mov	BYTE PTR $T233978[ebp], cl

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR $T233991[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T233990[ebp], eax
	mov	ecx, DWORD PTR $T233990[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy@2:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0length_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T234009 = -80						; size = 28
$T234008 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ PROC	; std::vector<int,std::allocator<int> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T234009[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T234008[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T234008[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T234009[ebp]
	push	eax
	lea	ecx, DWORD PTR $T234008[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T234008[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T234008[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T234009[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@2:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T234009[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T234008[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ENDP	; std::vector<int,std::allocator<int> >::_Xlen
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT
$T234034 = -16						; size = 4
$T234030 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@H@std@@YAPAHIPAH@Z PROC			; std::_Allocate<int>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@2
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T234034[ebp], 0
	lea	eax, DWORD PTR $T234034[ebp]
	push	eax
	lea	ecx, DWORD PTR $T234030[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T234030[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T234030[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@2:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@H@std@@YAPAHIPAH@Z ENDP			; std::_Allocate<int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ; std::vector<int,std::allocator<int> >::insert
PUBLIC	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z	; stdext::unchecked_fill_n<int *,unsigned int,int>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
tv129 = -96						; size = 4
_this$ = -92						; size = 4
$T234127 = -64						; size = 4
$T234117 = -60						; size = 4
$T234105 = -56						; size = 4
$T234095 = -49						; size = 1
$T234094 = -48						; size = 4
__Cat$234112 = -19					; size = 1
$T234110 = -18						; size = 1
$T234109 = -17						; size = 1
$T234046 = -16						; size = 4
$T234042 = -12						; size = 4
$T234041 = -8						; size = 4
$T234040 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::vector<int,std::allocator<int> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T234046[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN9@push_back
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN7@push_back
$LN9@push_back:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv129[ebp], eax
$LN7@push_back:
	mov	ecx, DWORD PTR $T234046[ebp]
	cmp	ecx, DWORD PTR tv129[ebp]
	jae	SHORT $LN2@push_back

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T234117[ebp], eax
	mov	ecx, DWORD PTR $T234117[ebp]
	mov	DWORD PTR $T234105[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T234109[ebp], dl
	mov	al, BYTE PTR __Cat$234112[ebp]
	mov	BYTE PTR $T234110[ebp], al
	mov	cl, BYTE PTR $T234109[ebp]
	mov	BYTE PTR $T234095[ebp], cl
	mov	edx, DWORD PTR $T234105[ebp]
	mov	DWORD PTR $T234094[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR $T234094[ebp]
	push	ecx
	call	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ; stdext::unchecked_fill_n<int *,unsigned int,int>
	add	esp, 12					; 0000000cH
	mov	edx, 1
	shl	edx, 2
	add	edx, DWORD PTR $T234117[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back
$LN2@push_back:

; 823  : 			insert(end(), _Val);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T234127[ebp], edx
	mov	eax, DWORD PTR $T234127[ebp]
	mov	DWORD PTR $T234041[ebp], eax
	mov	ecx, DWORD PTR $T234041[ebp]
	mov	DWORD PTR $T234040[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR $T234040[ebp]
	push	eax
	lea	ecx, DWORD PTR $T234042[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ; std::vector<int,std::allocator<int> >::insert
$LN3@push_back:

; 824  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::vector<int,std::allocator<int> >::push_back
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
__Tmp$234252 = -24					; size = 4
$T234230 = -20						; size = 4
$T234211 = -16						; size = 4
$T234198 = -12						; size = 4
$T234195 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z PROC ; std::vector<int,std::allocator<int> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	test	edx, edx
	jne	SHORT $LN3@insert
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert
$LN3@insert:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T234211[ebp], ecx
	mov	edx, DWORD PTR $T234211[ebp]
	mov	DWORD PTR $T234195[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	sub	eax, DWORD PTR $T234195[ebp]
	sar	eax, 2
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T234230[ebp], edx
	mov	eax, DWORD PTR $T234230[ebp]
	mov	DWORD PTR $T234198[ebp], eax
	mov	ecx, DWORD PTR $T234198[ebp]
	mov	DWORD PTR __Tmp$234252[ebp], ecx
	mov	edx, DWORD PTR __Off$[ebp]
	mov	eax, DWORD PTR __Tmp$234252[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR __Tmp$234252[ebp], ecx
	mov	edx, DWORD PTR __Tmp$234252[ebp]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ENDP ; std::vector<int,std::allocator<int> >::insert
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>
PUBLIC	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
PUBLIC	??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<int *,int *,std::allocator<int> >
PUBLIC	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$2
__catchsym$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$0
__unwindtable$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$5
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$6
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
_TEXT	SEGMENT
tv84 = -432						; size = 4
tv302 = -428						; size = 4
tv288 = -424						; size = 4
tv280 = -420						; size = 4
_this$ = -416						; size = 4
$T234806 = -412						; size = 4
$T234754 = -368						; size = 4
$T234742 = -364						; size = 4
$T234732 = -357						; size = 1
$T234731 = -356						; size = 4
__Cat$234749 = -327					; size = 1
$T234746 = -326						; size = 1
$T234745 = -325						; size = 1
$T234703 = -324						; size = 4
$T234695 = -320						; size = 4
$T234687 = -316						; size = 4
$T234676 = -312						; size = 4
$T234675 = -308						; size = 4
__Cat$234682 = -302					; size = 1
$T234680 = -301						; size = 1
$T234604 = -276						; size = 4
$T234585 = -272						; size = 4
$T234568 = -265						; size = 1
$T234567 = -264						; size = 4
$T234557 = -260						; size = 4
$T234556 = -256						; size = 4
__Cat$234599 = -250					; size = 1
$T234596 = -249						; size = 1
$T234595 = -248						; size = 1
__Cat$234592 = -247					; size = 1
$T234589 = -246						; size = 1
$T234588 = -245						; size = 1
$T234532 = -244						; size = 4
$T234531 = -240						; size = 4
$T234527 = -236						; size = 4
$T234526 = -232						; size = 4
$T234515 = -228						; size = 4
$T234514 = -224						; size = 4
__Cat$234521 = -218					; size = 1
$T234518 = -217						; size = 1
$T234479 = -216						; size = 4
$T234478 = -212						; size = 4
__Cat$234486 = -206					; size = 1
$T234484 = -205						; size = 1
$T234449 = -204						; size = 4
$T234448 = -200						; size = 4
__Cat$234456 = -194					; size = 1
$T234454 = -193						; size = 1
$T234429 = -192						; size = 4
$T234417 = -188						; size = 4
$T234407 = -181						; size = 1
$T234406 = -180						; size = 4
__Cat$234426 = -175					; size = 1
$T234423 = -174						; size = 1
$T234422 = -173						; size = 1
$T234394 = -172						; size = 4
$T234382 = -168						; size = 4
$T234372 = -161						; size = 1
$T234371 = -160						; size = 4
__Cat$234390 = -155					; size = 1
$T234387 = -154						; size = 1
$T234386 = -153						; size = 1
$T234359 = -152						; size = 4
$T234347 = -148						; size = 4
$T234337 = -141						; size = 1
$T234336 = -140						; size = 4
__Cat$234355 = -135					; size = 1
$T234353 = -134						; size = 1
$T234352 = -133						; size = 1
__Count$234310 = -120					; size = 4
__Count$234284 = -48					; size = 4
__Tmp$214818 = -44					; size = 4
__Oldend$214819 = -40					; size = 4
__Tmp$214808 = -36					; size = 4
__Ncopied$214795 = -32					; size = 4
__Newvec$214793 = -28					; size = 4
__Whereoff$214794 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z PROC ; std::vector<int,std::allocator<int> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 416				; 000001a0H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN29@Insert_n
	mov	DWORD PTR tv280[ebp], 0
	jmp	SHORT $LN27@Insert_n
$LN29@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv280[ebp], eax
$LN27@Insert_n:
	mov	ecx, DWORD PTR tv280[ebp]
	mov	DWORD PTR __Capacity$[ebp], ecx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n
	jmp	$LN16@Insert_n
$LN14@Insert_n:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$234284[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$234284[ebp], 0
	jbe	SHORT $LN35@Insert_n
	mov	edx, DWORD PTR __Count$234284[ebp]
	mov	DWORD PTR tv288[ebp], edx
	jmp	SHORT $LN37@Insert_n
$LN35@Insert_n:
	mov	DWORD PTR tv288[ebp], 1
$LN37@Insert_n:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	eax, DWORD PTR tv288[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN42@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
	jmp	$LN16@Insert_n

; 1167 : 		else if (_Capacity < size() + _Count)

$LN42@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$234310[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$234310[ebp], 0
	jbe	SHORT $LN48@Insert_n
	mov	ecx, DWORD PTR __Count$234310[ebp]
	mov	DWORD PTR tv302[ebp], ecx
	jmp	SHORT $LN44@Insert_n
$LN48@Insert_n:
	mov	DWORD PTR tv302[ebp], 1
$LN44@Insert_n:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	mov	eax, DWORD PTR tv302[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	add	ecx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], ecx
$LN18@Insert_n:
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1171 : 			if (_Capacity < size() + _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], edx
	jae	SHORT $LN54@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN54@Insert_n:
	push	0
	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	add	esp, 8
	mov	DWORD PTR __Newvec$214793[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR __Whereoff$214794[ebp], edx

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$214795[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Whereoff$214794[ebp]
	mov	ecx, DWORD PTR __Newvec$214793[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T234359[ebp], edx
	mov	eax, DWORD PTR $T234359[ebp]
	mov	DWORD PTR $T234347[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T234352[ebp], cl
	mov	dl, BYTE PTR __Cat$234355[ebp]
	mov	BYTE PTR $T234353[ebp], dl
	mov	al, BYTE PTR $T234352[ebp]
	mov	BYTE PTR $T234337[ebp], al
	mov	ecx, DWORD PTR $T234347[ebp]
	mov	DWORD PTR $T234336[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234336[ebp]
	push	ecx
	call	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ; stdext::unchecked_fill_n<int *,unsigned int,int>
	add	esp, 12					; 0000000cH

; 1179 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$214795[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$214795[ebp], edx

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T234394[ebp], ecx
	mov	edx, DWORD PTR __Newvec$214793[ebp]
	mov	DWORD PTR $T234382[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T234386[ebp], al
	mov	cl, BYTE PTR __Cat$234390[ebp]
	mov	BYTE PTR $T234387[ebp], cl
	mov	dl, BYTE PTR $T234386[ebp]
	mov	BYTE PTR $T234372[ebp], dl
	mov	eax, DWORD PTR $T234382[ebp]
	mov	DWORD PTR $T234371[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T234371[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234394[ebp]
	push	ecx
	call	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
	add	esp, 16					; 00000010H

; 1182 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$214795[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$214795[ebp], edx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T234429[ebp], ecx
	mov	edx, DWORD PTR __Whereoff$214794[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Newvec$214793[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T234417[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T234422[ebp], dl
	mov	al, BYTE PTR __Cat$234426[ebp]
	mov	BYTE PTR $T234423[ebp], al
	mov	cl, BYTE PTR $T234422[ebp]
	mov	BYTE PTR $T234407[ebp], cl
	mov	edx, DWORD PTR $T234417[ebp]
	mov	DWORD PTR $T234406[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234406[ebp]
	push	ecx
	mov	edx, DWORD PTR $T234429[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
	add	esp, 16					; 00000010H
	jmp	$LN19@Insert_n
__catch$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$214795[ebp], 1
	jle	SHORT $LN7@Insert_n

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	ecx, DWORD PTR __Whereoff$214794[ebp]
	mov	edx, DWORD PTR __Newvec$214793[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T234449[ebp], eax
	mov	ecx, DWORD PTR __Newvec$214793[ebp]
	mov	DWORD PTR $T234448[ebp], ecx
	mov	dl, BYTE PTR __Cat$234456[ebp]
	mov	BYTE PTR $T234454[ebp], dl
$LN7@Insert_n:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$214795[ebp], 0
	jle	SHORT $LN6@Insert_n

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	eax, DWORD PTR __Whereoff$214794[ebp]
	mov	ecx, DWORD PTR __Newvec$214793[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T234479[ebp], ecx
	mov	edx, DWORD PTR __Whereoff$214794[ebp]
	mov	eax, DWORD PTR __Newvec$214793[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T234478[ebp], ecx
	mov	dl, BYTE PTR __Cat$234486[ebp]
	mov	BYTE PTR $T234484[ebp], dl
$LN6@Insert_n:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Newvec$214793[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN103@Insert_n
	ret	0
$LN19@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN103@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN5@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T234527[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T234526[ebp], edx
	mov	eax, DWORD PTR $T234527[ebp]
	mov	DWORD PTR $T234515[ebp], eax
	mov	ecx, DWORD PTR $T234526[ebp]
	mov	DWORD PTR $T234514[ebp], ecx
	mov	dl, BYTE PTR __Cat$234521[ebp]
	mov	BYTE PTR $T234518[ebp], dl

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T234532[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T234531[ebp], ecx
	mov	edx, DWORD PTR $T234531[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR __Newvec$214793[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Newvec$214793[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$214793[ebp]
	mov	DWORD PTR [edx+4], eax
	jmp	$LN16@Insert_n
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 2
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$214808[ebp], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T234604[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T234585[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T234588[ebp], cl
	mov	dl, BYTE PTR __Cat$234592[ebp]
	mov	BYTE PTR $T234589[ebp], dl
	mov	al, BYTE PTR $T234588[ebp]
	mov	BYTE PTR $T234568[ebp], al
	mov	ecx, DWORD PTR $T234585[ebp]
	mov	DWORD PTR $T234567[ebp], ecx
	mov	edx, DWORD PTR $T234567[ebp]
	mov	DWORD PTR $T234557[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T234556[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T234595[ebp], cl
	mov	dl, BYTE PTR __Cat$234599[ebp]
	mov	BYTE PTR $T234596[ebp], dl
	movzx	eax, BYTE PTR $T234595[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T234596[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T234557[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234604[ebp]
	push	ecx
	mov	edx, DWORD PTR $T234556[ebp]
	push	edx
	call	??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<int *,int *,std::allocator<int> >
	add	esp, 24					; 00000018H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	eax, DWORD PTR __Tmp$214808[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 2
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
	jmp	SHORT $LN21@Insert_n
__catch$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T234687[ebp], eax
	mov	ecx, DWORD PTR $T234687[ebp]
	mov	DWORD PTR $T234676[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T234675[ebp], ecx
	mov	dl, BYTE PTR __Cat$234682[ebp]
	mov	BYTE PTR $T234680[ebp], dl

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$3
	ret	0
$LN21@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, edx
	mov	DWORD PTR $T234703[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T234695[ebp], edx
	jmp	SHORT $LN151@Insert_n
$LN150@Insert_n:
	mov	eax, DWORD PTR $T234695[ebp]
	add	eax, 4
	mov	DWORD PTR $T234695[ebp], eax
$LN151@Insert_n:
	mov	ecx, DWORD PTR $T234695[ebp]
	cmp	ecx, DWORD PTR $T234703[ebp]
	je	SHORT $LN147@Insert_n
	mov	edx, DWORD PTR $T234695[ebp]
	mov	eax, DWORD PTR __Tmp$214808[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN150@Insert_n
$LN147@Insert_n:

; 1232 : 			}
; 1233 : 		else

	jmp	$LN16@Insert_n
$LN3@Insert_n:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$214818[ebp], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Oldend$214819[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T234754[ebp], eax
	mov	ecx, DWORD PTR $T234754[ebp]
	mov	DWORD PTR $T234742[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T234745[ebp], dl
	mov	al, BYTE PTR __Cat$234749[ebp]
	mov	BYTE PTR $T234746[ebp], al
	mov	cl, BYTE PTR $T234745[ebp]
	mov	BYTE PTR $T234732[ebp], cl
	mov	edx, DWORD PTR $T234742[ebp]
	mov	DWORD PTR $T234731[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234731[ebp]
	push	ecx
	mov	edx, DWORD PTR __Oldend$214819[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Oldend$214819[ebp]
	sub	ecx, eax
	push	ecx
	call	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, DWORD PTR __Oldend$214819[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR __Oldend$214819[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T234806[ebp], ecx
	jmp	SHORT $LN186@Insert_n
$LN185@Insert_n:
	mov	edx, DWORD PTR $T234806[ebp]
	add	edx, 4
	mov	DWORD PTR $T234806[ebp], edx
$LN186@Insert_n:
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	cmp	DWORD PTR $T234806[ebp], edx
	je	SHORT $LN16@Insert_n
	mov	eax, DWORD PTR $T234806[ebp]
	mov	ecx, DWORD PTR __Tmp$214818[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN185@Insert_n
$LN16@Insert_n:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-436]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T234877 = -40						; size = 4
$T234867 = -33						; size = 1
$T234866 = -32						; size = 4
__Cat$234872 = -3					; size = 1
$T234870 = -2						; size = 1
$T234869 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z PROC ; std::vector<int,std::allocator<int> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR $T234877[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T234869[ebp], cl
	mov	dl, BYTE PTR __Cat$234872[ebp]
	mov	BYTE PTR $T234870[ebp], dl
	mov	al, BYTE PTR $T234869[ebp]
	mov	BYTE PTR $T234867[ebp], al
	mov	ecx, DWORD PTR $T234877[ebp]
	mov	DWORD PTR $T234866[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234866[ebp]
	push	ecx
	call	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ; stdext::unchecked_fill_n<int *,unsigned int,int>
	add	esp, 12					; 0000000cH

; 1255 : 		return (_Ptr + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [eax+edx*4]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Ufill
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z
_TEXT	SEGMENT
$T234922 = -38						; size = 1
$T234921 = -37						; size = 1
$T234920 = -36						; size = 4
$T234919 = -32						; size = 4
$T234906 = -25						; size = 1
$T234905 = -24						; size = 4
$T234904 = -20						; size = 4
__Off$234914 = -16					; size = 4
__Result$234915 = -12					; size = 4
__Cat$234911 = -8					; size = 1
$T234909 = -7						; size = 1
$T234908 = -6						; size = 1
__Cat$234886 = -4					; size = 1
$T234882 = -3						; size = 1
$T234881 = -2						; size = 1
$T234880 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z PROC ; stdext::_Unchecked_move_backward<int *,int *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T234880[ebp], al
	mov	cl, BYTE PTR __Cat$234886[ebp]
	mov	BYTE PTR $T234881[ebp], cl
	mov	dl, BYTE PTR $T234880[ebp]
	mov	BYTE PTR $T234922[ebp], dl
	mov	al, BYTE PTR $T234882[ebp]
	mov	BYTE PTR $T234921[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T234920[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T234919[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T234908[ebp], al
	mov	cl, BYTE PTR __Cat$234911[ebp]
	mov	BYTE PTR $T234909[ebp], cl
	mov	dl, BYTE PTR $T234908[ebp]
	mov	BYTE PTR $T234906[ebp], dl
	mov	eax, DWORD PTR $T234920[ebp]
	mov	DWORD PTR $T234905[ebp], eax
	mov	ecx, DWORD PTR $T234919[ebp]
	mov	DWORD PTR $T234904[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR $T234904[ebp]
	sar	edx, 2
	mov	DWORD PTR __Off$234914[ebp], edx
	mov	eax, DWORD PTR __Off$234914[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR $T234905[ebp]
	sub	ecx, eax
	mov	DWORD PTR __Result$234915[ebp], ecx
	cmp	DWORD PTR __Off$234914[ebp], 0
	jle	SHORT $LN7@Unchecked_
	mov	edx, DWORD PTR __Off$234914[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR $T234904[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$234914[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __Result$234915[ebp]
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN7@Unchecked_:
	mov	eax, DWORD PTR __Result$234915[ebp]

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ENDP ; stdext::_Unchecked_move_backward<int *,int *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z
_TEXT	SEGMENT
$T234952 = -22						; size = 1
$T234951 = -21						; size = 1
$T234950 = -20						; size = 4
$T234941 = -13						; size = 1
$T234940 = -12						; size = 4
$T234939 = -8						; size = 4
$T234944 = -4						; size = 1
$T234926 = -2						; size = 1
$T234925 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z PROC	; stdext::unchecked_fill_n<int *,unsigned int,int>, COMDAT

; 3720 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T234925[ebp], al
	mov	cl, BYTE PTR $T234925[ebp]
	mov	BYTE PTR $T234952[ebp], cl
	mov	dl, BYTE PTR $T234926[ebp]
	mov	BYTE PTR $T234951[ebp], dl
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T234950[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T234944[ebp], cl
	mov	dl, BYTE PTR $T234944[ebp]
	mov	BYTE PTR $T234941[ebp], dl
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR $T234940[ebp], eax
	mov	ecx, DWORD PTR $T234950[ebp]
	mov	DWORD PTR $T234939[ebp], ecx
	jmp	SHORT $LN9@unchecked_@2
$LN8@unchecked_@2:
	mov	edx, DWORD PTR $T234940[ebp]
	sub	edx, 1
	mov	DWORD PTR $T234940[ebp], edx
	mov	eax, DWORD PTR $T234939[ebp]
	add	eax, 4
	mov	DWORD PTR $T234939[ebp], eax
$LN9@unchecked_@2:
	cmp	DWORD PTR $T234940[ebp], 0
	jbe	SHORT $LN1@unchecked_@2
	mov	ecx, DWORD PTR $T234939[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN8@unchecked_@2
$LN1@unchecked_@2:

; 3722 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ENDP	; stdext::unchecked_fill_n<int *,unsigned int,int>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
$T234969 = -21						; size = 1
$T234968 = -20						; size = 4
$T234967 = -16						; size = 4
__Result$234965 = -12					; size = 4
__Count$234964 = -8					; size = 4
__Cat$234959 = -3					; size = 1
$T234956 = -2						; size = 1
$T234955 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T234955[ebp], al
	mov	cl, BYTE PTR __Cat$234959[ebp]
	mov	BYTE PTR $T234956[ebp], cl
	mov	dl, BYTE PTR $T234955[ebp]
	mov	BYTE PTR $T234969[ebp], dl
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T234968[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T234967[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR $T234967[ebp]
	sar	edx, 2
	mov	DWORD PTR __Count$234964[ebp], edx
	mov	eax, DWORD PTR __Count$234964[ebp]
	mov	ecx, DWORD PTR $T234968[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Result$234965[ebp], edx
	cmp	DWORD PTR __Count$234964[ebp], 0
	jbe	SHORT $LN6@unchecked_@3
	mov	eax, DWORD PTR __Count$234964[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR $T234967[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$234964[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR $T234968[ebp]
	push	eax
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN6@unchecked_@3:
	mov	eax, DWORD PTR __Result$234965[ebp]

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<int *,int *,std::allocator<int> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<int *,int *,std::allocator<int> >
_TEXT	ENDS
END
