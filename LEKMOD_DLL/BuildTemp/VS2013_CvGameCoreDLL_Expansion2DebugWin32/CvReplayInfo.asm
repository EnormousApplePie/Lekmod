; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvReplayInfo.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?REPLAY_VERSION@CvReplayInfo@@1HA		; CvReplayInfo::REPLAY_VERSION
_DATA	SEGMENT
?REPLAY_VERSION@CvReplayInfo@@1HA DD 01H		; CvReplayInfo::REPLAY_VERSION
_DATA	ENDS
PUBLIC	??1?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::~vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
PUBLIC	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??1?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE@XZ ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::~vector<CvReplayMessage,std::allocator<CvReplayMessage> >
PUBLIC	??1?$_Vector_val@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvReplayMessage,std::allocator<CvReplayMessage> >::~_Vector_val<CvReplayMessage,std::allocator<CvReplayMessage> >
PUBLIC	??1?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE@XZ ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::~vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >
PUBLIC	??1?$_Vector_val@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::~_Vector_val<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >
PUBLIC	??1?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE@XZ ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::~vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >
PUBLIC	??1?$_Vector_val@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE@XZ ; std::_Vector_val<enum VictoryTypes,std::allocator<enum VictoryTypes> >::~_Vector_val<enum VictoryTypes,std::allocator<enum VictoryTypes> >
PUBLIC	??1?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE@XZ ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::~vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >
PUBLIC	??1?$_Vector_val@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE@XZ ; std::_Vector_val<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::~_Vector_val<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
PUBLIC	??0?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE@XZ ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
PUBLIC	??0?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
PUBLIC	??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	?_Buy@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAE_NI@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Buy
PUBLIC	?_Buy@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAE_NI@Z ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Buy
PUBLIC	?_Buy@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAE_NI@Z ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Buy
PUBLIC	?_Buy@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAE_NI@Z ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Buy
PUBLIC	??_7CvReplayInfo@@6B@				; CvReplayInfo::`vftable'
PUBLIC	??0CvReplayInfo@@QAE@XZ				; CvReplayInfo::CvReplayInfo
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	??_ECvReplayInfo@@UAEPAXI@Z:PROC		; CvReplayInfo::`vector deleting destructor'
;	COMDAT ??_7CvReplayInfo@@6B@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
CONST	SEGMENT
??_7CvReplayInfo@@6B@ DD FLAT:??_ECvReplayInfo@@UAEPAXI@Z ; CvReplayInfo::`vftable'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CvReplayInfo@@QAE@XZ DD 019930522H
	DD	0cH
	DD	FLAT:__unwindtable$??0CvReplayInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CvReplayInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvReplayInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvReplayInfo@@QAE@XZ$10
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvReplayInfo@@QAE@XZ$1
	DD	02H
	DD	FLAT:__unwindfunclet$??0CvReplayInfo@@QAE@XZ$12
	DD	02H
	DD	FLAT:__unwindfunclet$??0CvReplayInfo@@QAE@XZ$2
	DD	04H
	DD	FLAT:__unwindfunclet$??0CvReplayInfo@@QAE@XZ$3
	DD	05H
	DD	FLAT:__unwindfunclet$??0CvReplayInfo@@QAE@XZ$15
	DD	05H
	DD	FLAT:__unwindfunclet$??0CvReplayInfo@@QAE@XZ$4
	DD	07H
	DD	FLAT:__unwindfunclet$??0CvReplayInfo@@QAE@XZ$17
	DD	07H
	DD	FLAT:__unwindfunclet$??0CvReplayInfo@@QAE@XZ$5
	DD	09H
	DD	FLAT:__unwindfunclet$??0CvReplayInfo@@QAE@XZ$6
	DD	0aH
	DD	FLAT:__unwindfunclet$??0CvReplayInfo@@QAE@XZ$7
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvreplayinfo.cpp
xdata$x	ENDS
;	COMDAT ??0CvReplayInfo@@QAE@XZ
_TEXT	SEGMENT
tv341 = -176						; size = 4
tv366 = -172						; size = 4
tv300 = -168						; size = 4
tv325 = -164						; size = 4
tv248 = -160						; size = 4
tv273 = -156						; size = 4
tv207 = -152						; size = 4
tv232 = -148						; size = 4
_this$ = -144						; size = 4
$T232135 = -116						; size = 4
$T232120 = -110						; size = 1
$T232107 = -109						; size = 1
$T232103 = -108						; size = 4
$T232096 = -100						; size = 4
$T232089 = -92						; size = 4
$T232074 = -86						; size = 1
$T232061 = -85						; size = 1
$T232057 = -84						; size = 4
$T232050 = -76						; size = 4
$T232043 = -68						; size = 4
$T232038 = -64						; size = 4
$T232023 = -58						; size = 1
$T232010 = -57						; size = 1
$T232006 = -56						; size = 4
$T231999 = -48						; size = 4
$T231992 = -40						; size = 4
$T231977 = -34						; size = 1
$T231964 = -33						; size = 1
$T231960 = -32						; size = 4
$T231953 = -24						; size = 4
$T231946 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvReplayInfo@@QAE@XZ PROC				; CvReplayInfo::CvReplayInfo, COMDAT
; _this$ = ecx

; 56   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvReplayInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 164				; 000000a4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvReplayInfo@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	mov	DWORD PTR $T231946[ebp], edx
	mov	ecx, DWORD PTR $T231946[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+36], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+40], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+44], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+48], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+52], -1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 56					; 00000038H
	mov	DWORD PTR $T231992[ebp], edx
	lea	eax, DWORD PTR $T231977[ebp]
	mov	DWORD PTR $T231953[ebp], eax
	lea	ecx, DWORD PTR $T231964[ebp]
	mov	DWORD PTR $T231960[ebp], ecx
	mov	edx, DWORD PTR $T231992[ebp]
	mov	DWORD PTR tv232[ebp], edx
	mov	eax, DWORD PTR $T231992[ebp]
	mov	DWORD PTR tv207[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	push	0
	mov	ecx, DWORD PTR $T231992[ebp]
	call	?_Buy@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAE_NI@Z ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Buy
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	mov	DWORD PTR $T232038[ebp], ecx
	lea	edx, DWORD PTR $T232023[ebp]
	mov	DWORD PTR $T231999[ebp], edx
	lea	eax, DWORD PTR $T232010[ebp]
	mov	DWORD PTR $T232006[ebp], eax
	mov	ecx, DWORD PTR $T232038[ebp]
	mov	DWORD PTR tv273[ebp], ecx
	mov	edx, DWORD PTR $T232038[ebp]
	mov	DWORD PTR tv248[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	push	0
	mov	ecx, DWORD PTR $T232038[ebp]
	call	?_Buy@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAE_NI@Z ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Buy
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+88], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+96], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+100], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+104], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 108				; 0000006cH
	mov	DWORD PTR $T232043[ebp], ecx
	mov	ecx, DWORD PTR $T232043[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+140], 0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 144				; 00000090H
	mov	DWORD PTR $T232089[ebp], eax
	lea	ecx, DWORD PTR $T232074[ebp]
	mov	DWORD PTR $T232050[ebp], ecx
	lea	edx, DWORD PTR $T232061[ebp]
	mov	DWORD PTR $T232057[ebp], edx
	mov	eax, DWORD PTR $T232089[ebp]
	mov	DWORD PTR tv325[ebp], eax
	mov	ecx, DWORD PTR $T232089[ebp]
	mov	DWORD PTR tv300[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	push	0
	mov	ecx, DWORD PTR $T232089[ebp]
	call	?_Buy@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAE_NI@Z ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Buy
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 160				; 000000a0H
	mov	DWORD PTR $T232135[ebp], edx
	lea	eax, DWORD PTR $T232120[ebp]
	mov	DWORD PTR $T232096[ebp], eax
	lea	ecx, DWORD PTR $T232107[ebp]
	mov	DWORD PTR $T232103[ebp], ecx
	mov	edx, DWORD PTR $T232135[ebp]
	mov	DWORD PTR tv366[ebp], edx
	mov	eax, DWORD PTR $T232135[ebp]
	mov	DWORD PTR tv341[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	push	0
	mov	ecx, DWORD PTR $T232135[ebp]
	call	?_Buy@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAE_NI@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Buy
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	call	??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 192				; 000000c0H
	call	??0?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+208], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+212], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 216				; 000000d8H
	call	??0?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE@XZ ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >

; 57   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvReplayInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvReplayInfo@@QAE@XZ$10:
	mov	ecx, DWORD PTR $T231992[ebp]
	jmp	??1?$_Vector_val@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE@XZ
__unwindfunclet$??0CvReplayInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	jmp	??1?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE@XZ ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::~vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >
__unwindfunclet$??0CvReplayInfo@@QAE@XZ$12:
	mov	ecx, DWORD PTR $T232038[ebp]
	jmp	??1?$_Vector_val@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE@XZ
__unwindfunclet$??0CvReplayInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	jmp	??1?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE@XZ ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::~vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >
__unwindfunclet$??0CvReplayInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 108				; 0000006cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvReplayInfo@@QAE@XZ$15:
	mov	ecx, DWORD PTR $T232089[ebp]
	jmp	??1?$_Vector_val@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE@XZ
__unwindfunclet$??0CvReplayInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 144				; 00000090H
	jmp	??1?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE@XZ ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::~vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >
__unwindfunclet$??0CvReplayInfo@@QAE@XZ$17:
	mov	ecx, DWORD PTR $T232135[ebp]
	jmp	??1?$_Vector_val@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE@XZ
__unwindfunclet$??0CvReplayInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 160				; 000000a0H
	jmp	??1?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE@XZ ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::~vector<CvReplayMessage,std::allocator<CvReplayMessage> >
__unwindfunclet$??0CvReplayInfo@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	jmp	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$??0CvReplayInfo@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 192				; 000000c0H
	jmp	??1?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::~vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
__ehhandler$??0CvReplayInfo@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-168]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvReplayInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvReplayInfo@@QAE@XZ ENDP				; CvReplayInfo::CvReplayInfo
PUBLIC	??1CvReplayInfo@@UAE@XZ				; CvReplayInfo::~CvReplayInfo
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp
;	COMDAT ??_GCvReplayInfo@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCvReplayInfo@@UAEPAXI@Z PROC			; CvReplayInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvReplayInfo@@UAE@XZ			; CvReplayInfo::~CvReplayInfo
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCvReplayInfo@@UAEPAXI@Z ENDP			; CvReplayInfo::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??1?$_Vector_val@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ ; std::_Vector_val<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::~_Vector_val<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
PUBLIC	??1?$_Vector_val@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE@XZ ; std::_Vector_val<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::~_Vector_val<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
PUBLIC	?_Tidy@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXXZ ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Tidy
PUBLIC	?_Tidy@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXXZ ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Tidy
PUBLIC	?_Tidy@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXXZ ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Tidy
PUBLIC	?_Tidy@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXXZ ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Tidy
PUBLIC	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
PUBLIC	?_Tidy@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Tidy
PUBLIC	?_Tidy@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXXZ ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Tidy
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$??1CvReplayInfo@@UAE@XZ DD 019930522H
	DD	0fH
	DD	FLAT:__unwindtable$??1CvReplayInfo@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvReplayInfo@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvReplayInfo@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvReplayInfo@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvReplayInfo@@UAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvReplayInfo@@UAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvReplayInfo@@UAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvReplayInfo@@UAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvReplayInfo@@UAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvReplayInfo@@UAE@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??1CvReplayInfo@@UAE@XZ$9
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvReplayInfo@@UAE@XZ$17
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvReplayInfo@@UAE@XZ$21
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvReplayInfo@@UAE@XZ$23
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvReplayInfo@@UAE@XZ$25
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvReplayInfo@@UAE@XZ$28
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvReplayInfo@@UAE@XZ$30
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvreplayinfo.cpp
xdata$x	ENDS
;	COMDAT ??1CvReplayInfo@@UAE@XZ
_TEXT	SEGMENT
_this$ = -296						; size = 4
$T233079 = -292						; size = 4
$T233074 = -288						; size = 4
$T232988 = -252						; size = 4
$T232902 = -216						; size = 4
$T232897 = -212						; size = 4
$T232791 = -172						; size = 4
$T232704 = -132						; size = 4
$T232598 = -92						; size = 4
$T232439 = -52						; size = 4
__$EHRec$ = -12						; size = 12
??1CvReplayInfo@@UAE@XZ PROC				; CvReplayInfo::~CvReplayInfo, COMDAT
; _this$ = ecx

; 60   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvReplayInfo@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 284				; 0000011cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvReplayInfo@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 7

; 61   : };

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 216				; 000000d8H
	mov	DWORD PTR $T232439[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	ecx, DWORD PTR $T232439[ebp]
	call	?_Tidy@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXXZ ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 192				; 000000c0H
	mov	DWORD PTR $T232598[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	mov	ecx, DWORD PTR $T232598[ebp]
	call	?_Tidy@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 176				; 000000b0H
	mov	DWORD PTR $T232704[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	ecx, DWORD PTR $T232704[ebp]
	call	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 160				; 000000a0H
	mov	DWORD PTR $T232791[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	mov	ecx, DWORD PTR $T232791[ebp]
	call	?_Tidy@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXXZ ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 144				; 00000090H
	mov	DWORD PTR $T232897[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	mov	ecx, DWORD PTR $T232897[ebp]
	call	?_Tidy@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXXZ ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 108				; 0000006cH
	mov	DWORD PTR $T232902[ebp], eax
	mov	ecx, DWORD PTR $T232902[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	mov	DWORD PTR $T232988[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH
	mov	ecx, DWORD PTR $T232988[ebp]
	call	?_Tidy@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXXZ ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 56					; 00000038H
	mov	DWORD PTR $T233074[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH
	mov	ecx, DWORD PTR $T233074[ebp]
	call	?_Tidy@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXXZ ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	mov	DWORD PTR $T233079[ebp], eax
	mov	ecx, DWORD PTR $T233079[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvReplayInfo@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvReplayInfo@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	jmp	??1?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE@XZ ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::~vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >
__unwindfunclet$??1CvReplayInfo@@UAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	jmp	??1?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE@XZ ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::~vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >
__unwindfunclet$??1CvReplayInfo@@UAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 108				; 0000006cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvReplayInfo@@UAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 144				; 00000090H
	jmp	??1?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE@XZ ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::~vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >
__unwindfunclet$??1CvReplayInfo@@UAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 160				; 000000a0H
	jmp	??1?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE@XZ ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::~vector<CvReplayMessage,std::allocator<CvReplayMessage> >
__unwindfunclet$??1CvReplayInfo@@UAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	jmp	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$??1CvReplayInfo@@UAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 192				; 000000c0H
	jmp	??1?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::~vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
__unwindfunclet$??1CvReplayInfo@@UAE@XZ$9:
	mov	ecx, DWORD PTR $T232439[ebp]
	jmp	??1?$_Vector_val@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE@XZ
__unwindfunclet$??1CvReplayInfo@@UAE@XZ$17:
	mov	ecx, DWORD PTR $T232598[ebp]
	jmp	??1?$_Vector_val@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ
__unwindfunclet$??1CvReplayInfo@@UAE@XZ$21:
	mov	ecx, DWORD PTR $T232704[ebp]
	jmp	??1?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
__unwindfunclet$??1CvReplayInfo@@UAE@XZ$23:
	mov	ecx, DWORD PTR $T232791[ebp]
	jmp	??1?$_Vector_val@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE@XZ
__unwindfunclet$??1CvReplayInfo@@UAE@XZ$25:
	mov	ecx, DWORD PTR $T232897[ebp]
	jmp	??1?$_Vector_val@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE@XZ
__unwindfunclet$??1CvReplayInfo@@UAE@XZ$28:
	mov	ecx, DWORD PTR $T232988[ebp]
	jmp	??1?$_Vector_val@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE@XZ
__unwindfunclet$??1CvReplayInfo@@UAE@XZ$30:
	mov	ecx, DWORD PTR $T233074[ebp]
	jmp	??1?$_Vector_val@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE@XZ
__ehhandler$??1CvReplayInfo@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-288]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvReplayInfo@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvReplayInfo@@UAE@XZ ENDP				; CvReplayInfo::~CvReplayInfo
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >
PUBLIC	??1?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAE@XZ ; std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >::~map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >
PUBLIC	??1?$_Vector_val@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ ; std::_Vector_val<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::~_Vector_val<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
PUBLIC	??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::~map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >
PUBLIC	??1?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::~vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
PUBLIC	??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::~map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tidy
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tidy
PUBLIC	?push_back@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::push_back
PUBLIC	??A?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAEAAUPlotState@CvReplayInfo@@ABI@Z ; std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >::operator[]
PUBLIC	??0?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAE@XZ ; std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >
PUBLIC	?reserve@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXI@Z ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::reserve
PUBLIC	?push_back@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXABVCvReplayMessage@@@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::push_back
PUBLIC	??0CvReplayMessage@@QAE@ABV0@@Z			; CvReplayMessage::CvReplayMessage
PUBLIC	?reserve@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXI@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::reserve
PUBLIC	?erase@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@V?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@0@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::erase
PUBLIC	??1PlayerInfo@CvReplayInfo@@QAE@XZ		; CvReplayInfo::PlayerInfo::~PlayerInfo
PUBLIC	?_Tidy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Tidy
PUBLIC	?push_back@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAEXABUPlayerInfo@CvReplayInfo@@@Z ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::push_back
PUBLIC	?push_back@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAEXABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::push_back
PUBLIC	??4?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::operator=
PUBLIC	??A?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAEAAHABI@Z ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::operator[]
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Inc
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy
PUBLIC	?push_back@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::push_back
PUBLIC	??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
PUBLIC	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
PUBLIC	??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@I@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
PUBLIC	??0PlayerInfo@CvReplayInfo@@QAE@XZ		; CvReplayInfo::PlayerInfo::PlayerInfo
PUBLIC	??A?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAEAAHABH@Z ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::operator[]
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
PUBLIC	?erase@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@0@Z ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::erase
PUBLIC	?erase@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@V?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@0@Z ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::erase
PUBLIC	?erase@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@0@Z ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::erase
PUBLIC	?erase@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::erase
PUBLIC	?push_back@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAEXABW4VictoryTypes@@@Z ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::push_back
PUBLIC	?erase@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@V?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@0@Z ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::erase
PUBLIC	?push_back@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAEXABW4GameOptionTypes@@@Z ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::push_back
PUBLIC	?erase@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@V?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@0@Z ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::erase
PUBLIC	__$ArrayPad$
PUBLIC	?createInfo@CvReplayInfo@@QAEXXZ		; CvReplayInfo::createInfo
EXTRN	?isNWOfRiver@CvPlot@@QBE_NXZ:PROC		; CvPlot::isNWOfRiver
EXTRN	?isWOfRiver@CvPlot@@QBE_NXZ:PROC		; CvPlot::isWOfRiver
EXTRN	?isNEOfRiver@CvPlot@@QBE_NXZ:PROC		; CvPlot::isNEOfRiver
EXTRN	??1CvReplayMessage@@UAE@XZ:PROC			; CvReplayMessage::~CvReplayMessage
EXTRN	?setPlayer@CvReplayMessage@@QAEXW4PlayerTypes@@@Z:PROC ; CvReplayMessage::setPlayer
EXTRN	?getPlayer@CvReplayMessage@@QBE?AW4PlayerTypes@@XZ:PROC ; CvReplayMessage::getPlayer
EXTRN	?getReplayMessage@CvGame@@QBEPBVCvReplayMessage@@I@Z:PROC ; CvGame::getReplayMessage
EXTRN	?getNumReplayMessages@CvGame@@QBEIXZ:PROC	; CvGame::getNumReplayMessages
EXTRN	?getReplayDataHistory@CvPlayer@@QBE?AV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@I@Z:PROC ; CvPlayer::getReplayDataHistory
EXTRN	__imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	?getReplayDataSetName@CvPlayer@@QBEPBDI@Z:PROC	; CvPlayer::getReplayDataSetName
EXTRN	?getNumReplayDataSets@CvPlayer@@QBEIXZ:PROC	; CvPlayer::getNumReplayDataSets
EXTRN	?getPlayerColor@CvPlayer@@QBE?AW4PlayerColorTypes@@XZ:PROC ; CvPlayer::getPlayerColor
EXTRN	?getCivilizationAdjective@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationAdjective
EXTRN	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationShortDescription
EXTRN	?getCivilizationDescription@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationDescription
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
EXTRN	?getName@CvPlayer@@QBEPBDXZ:PROC		; CvPlayer::getName
EXTRN	?getHandicapType@CvPlayer@@QBE?AW4HandicapTypes@@XZ:PROC ; CvPlayer::getHandicapType
EXTRN	?getCivilizationType@CvPlayer@@QBE?AW4CivilizationTypes@@XZ:PROC ; CvPlayer::getCivilizationType
EXTRN	?getLeaderType@CvPlayer@@QBE?AW4LeaderHeadTypes@@XZ:PROC ; CvPlayer::getLeaderType
EXTRN	?GatherPerTurnReplayStats@CvPlayer@@QAEXH@Z:PROC ; CvPlayer::GatherPerTurnReplayStats
EXTRN	?setYearStr@CvGameTextMgr@@SAXAAVCvString@@H_NW4CalendarTypes@@HW4GameSpeedTypes@@@Z:PROC ; CvGameTextMgr::setYearStr
EXTRN	?getCalendar@CvGame@@QBE?AW4CalendarTypes@@XZ:PROC ; CvGame::getCalendar
EXTRN	?getGameTurn@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurn
EXTRN	?getStartYear@CvGame@@QBEHXZ:PROC		; CvGame::getStartYear
EXTRN	?getStartTurn@CvGame@@QBEHXZ:PROC		; CvGame::getStartTurn
EXTRN	?GetScore@CvPlayer@@QBEH_N0@Z:PROC		; CvPlayer::GetScore
EXTRN	?getVictory@CvGame@@QBE?AW4VictoryTypes@@XZ:PROC ; CvGame::getVictory
EXTRN	?getWinner@CvGame@@QBE?AW4TeamTypes@@XZ:PROC	; CvGame::getWinner
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
EXTRN	?isVictoryValid@CvGame@@QBE_NW4VictoryTypes@@@Z:PROC ; CvGame::isVictoryValid
EXTRN	?getNumVictoryInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumVictoryInfos
EXTRN	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z:PROC ; CvGame::isOption
EXTRN	?getGameSpeedType@CvGame@@QBE?AW4GameSpeedTypes@@XZ:PROC ; CvGame::getGameSpeedType
EXTRN	?era@CvPreGame@@YA?AW4EraTypes@@XZ:PROC		; CvPreGame::era
EXTRN	?seaLevel@CvPreGame@@YA?AW4SeaLevelTypes@@XZ:PROC ; CvPreGame::seaLevel
EXTRN	?climate@CvPreGame@@YA?AW4ClimateTypes@@XZ:PROC	; CvPreGame::climate
EXTRN	?worldSize@CvPreGame@@YA?AW4WorldSizeTypes@@XZ:PROC ; CvPreGame::worldSize
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	?mapScriptName@CvPreGame@@YAABVCvString@@XZ:PROC ; CvPreGame::mapScriptName
EXTRN	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ:PROC ; CvGame::getActivePlayer
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__ehfuncinfo$?createInfo@CvReplayInfo@@QAEXXZ DD 019930522H
	DD	0fH
	DD	FLAT:__unwindtable$?createInfo@CvReplayInfo@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?createInfo@CvReplayInfo@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$4
	DD	03H
	DD	FLAT:__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$24
	DD	03H
	DD	FLAT:__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$5
	DD	06H
	DD	FLAT:__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$31
	DD	03H
	DD	FLAT:__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$37
	DD	01H
	DD	FLAT:__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$42
	DD	00H
	DD	FLAT:__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$7
	DD	00H
	DD	FLAT:__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$8
	DD	00H
	DD	FLAT:__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$55
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$61
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvreplayinfo.cpp
xdata$x	ENDS
;	COMDAT ?createInfo@CvReplayInfo@@QAEXXZ
_TEXT	SEGMENT
tv469 = -1132						; size = 4
_this$ = -1128						; size = 4
_f$234686 = -1121					; size = 1
$T234668 = -1120					; size = 4
$T234642 = -1116					; size = 4
$T234626 = -1112					; size = 4
$T234654 = -1108					; size = 4
$T234653 = -1104					; size = 4
$T234652 = -1100					; size = 4
$T234651 = -1096					; size = 4
$T234650 = -1092					; size = 4
$T234607 = -1088					; size = 4
$T234603 = -1084					; size = 4
$T234483 = -1020					; size = 4
$T234457 = -1016					; size = 4
$T234441 = -1012					; size = 4
$T234470 = -1008					; size = 4
$T234469 = -1004					; size = 4
$T234468 = -1000					; size = 4
$T234467 = -996						; size = 4
$T234466 = -992						; size = 4
$T234183 = -932						; size = 4
$T234097 = -888						; size = 4
$T234052 = -884						; size = 4
$T234024 = -880						; size = 4
$T234011 = -876						; size = 4
$T234003 = -870						; size = 1
$T234002 = -869						; size = 1
$T233992 = -868						; size = 4
$T233886 = -842						; size = 1
$T233885 = -841						; size = 1
$T233841 = -820						; size = 4
$T233759 = -796						; size = 4
$T233758 = -792						; size = 4
$T233754 = -788						; size = 4
$T233748 = -784						; size = 4
$T233742 = -780						; size = 4
$T233736 = -776						; size = 4
$T233646 = -729						; size = 1
$T233552 = -686						; size = 1
$T233551 = -685						; size = 1
$T233542 = -684						; size = 4
$T233516 = -680						; size = 4
$T233500 = -676						; size = 4
$T233528 = -672						; size = 4
$T233527 = -668						; size = 4
$T233526 = -664						; size = 4
$T233525 = -660						; size = 4
$T233524 = -656						; size = 4
$T233484 = -652						; size = 4
$T233458 = -648						; size = 4
$T233442 = -644						; size = 4
$T233471 = -640						; size = 4
$T233470 = -636						; size = 4
$T233469 = -632						; size = 4
$T233468 = -628						; size = 4
$T233467 = -624						; size = 4
$T233426 = -620						; size = 4
$T233400 = -616						; size = 4
$T233384 = -612						; size = 4
$T233413 = -608						; size = 4
$T233412 = -604						; size = 4
$T233411 = -600						; size = 4
$T233410 = -596						; size = 4
$T233409 = -592						; size = 4
$T233368 = -588						; size = 4
$T233342 = -584						; size = 4
$T233326 = -580						; size = 4
$T233355 = -576						; size = 4
$T233354 = -572						; size = 4
$T233353 = -568						; size = 4
$T233352 = -564						; size = 4
$T233351 = -560						; size = 4
$T233310 = -556						; size = 4
$T233301 = -552						; size = 4
$T233258 = -528						; size = 4
$T233232 = -524						; size = 4
$T233216 = -520						; size = 4
$T233244 = -516						; size = 4
$T233243 = -512						; size = 4
$T233242 = -508						; size = 4
$T233241 = -504						; size = 4
$T233240 = -500						; size = 4
$T233169 = -476						; size = 4
$T233143 = -472						; size = 4
$T233127 = -468						; size = 4
$T233155 = -464						; size = 4
$T233154 = -460						; size = 4
$T233153 = -456						; size = 4
$T233152 = -452						; size = 4
$T233151 = -448						; size = 4
$T233111 = -444						; size = 4
$T233110 = -440						; size = 4
$T233094 = -436						; size = 4
$T233093 = -432						; size = 4
$T233092 = -428						; size = 4
$T233091 = -424						; size = 4
$T233090 = -420						; size = 12
$T233089 = -408						; size = 4
_plotState$219912 = -404				; size = 16
_pkPlot$219913 = -388					; size = 4
_plotStatePerTurn$220497 = -384				; size = 12
_i$219908 = -372					; size = 4
_modifiedMessage$219903 = -368				; size = 60
_pMessage$219901 = -308					; size = 4
_i$219897 = -304					; size = 4
_it$219865 = -300					; size = 4
_dataSetName$219764 = -296				; size = 4
_uiDataSet$219759 = -292				; size = 4
_bFound$219760 = -285					; size = 1
_playerData$219768 = -284				; size = 12
_turnData$219770 = -272					; size = 12
_playerDataSetName$219758 = -260			; size = 28
_uiPlayerDataSet$219754 = -232				; size = 4
_dataSet$219752 = -228					; size = 16
_playerInfo$219751 = -212				; size = 128
__$ArrayPad$ = -84					; size = 4
_uiNumDataSets$219753 = -80				; size = 4
_player$219747 = -76					; size = 4
_iPlayer$219743 = -72					; size = 4
_player$219241 = -68					; size = 4
_eVictory$219237 = -64					; size = 4
_i$219233 = -60						; size = 4
_eOption$219230 = -56					; size = 4
_i$219226 = -52						; size = 4
_kMap$ = -48						; size = 4
_game$ = -44						; size = 4
_eActivePlayer$ = -40					; size = 4
_mapPlayers$ = -36					; size = 12
_iPlayerIndex$ = -24					; size = 4
_nMessages$ = -20					; size = 4
_numPlots$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?createInfo@CvReplayInfo@@QAEXXZ PROC			; CvReplayInfo::createInfo, COMDAT
; _this$ = ecx

; 64   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?createInfo@CvReplayInfo@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1120				; 00000460H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 65   : 	CvGame& game = GC.getGame();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR _game$[ebp], eax

; 66   : 
; 67   : 	const PlayerTypes eActivePlayer = game.getActivePlayer();

	mov	ecx, DWORD PTR _game$[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	mov	DWORD PTR _eActivePlayer$[ebp], eax

; 68   : 
; 69   : 	m_strMapScriptName = CvPreGame::mapScriptName();

	call	?mapScriptName@CvPreGame@@YAABVCvString@@XZ ; CvPreGame::mapScriptName
	mov	DWORD PTR $T233111[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	mov	DWORD PTR $T233110[ebp], ecx
	mov	edx, DWORD PTR $T233111[ebp]
	push	edx
	mov	ecx, DWORD PTR $T233110[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 70   : 	m_eWorldSize = CvPreGame::worldSize();

	call	?worldSize@CvPreGame@@YA?AW4WorldSizeTypes@@XZ ; CvPreGame::worldSize
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 71   : 	m_eClimate = CvPreGame::climate();

	call	?climate@CvPreGame@@YA?AW4ClimateTypes@@XZ ; CvPreGame::climate
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+40], eax

; 72   : 	m_eSeaLevel = CvPreGame::seaLevel();

	call	?seaLevel@CvPreGame@@YA?AW4SeaLevelTypes@@XZ ; CvPreGame::seaLevel
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+44], eax

; 73   : 	m_eEra = CvPreGame::era();

	call	?era@CvPreGame@@YA?AW4EraTypes@@XZ	; CvPreGame::era
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+48], eax

; 74   : 	m_eGameSpeed = game.getGameSpeedType();

	mov	ecx, DWORD PTR _game$[ebp]
	call	?getGameSpeedType@CvGame@@QBE?AW4GameSpeedTypes@@XZ ; CvGame::getGameSpeedType
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+52], eax

; 75   : 
; 76   : 	m_listGameOptions.clear();

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 56					; 00000038H
	mov	DWORD PTR $T233169[ebp], edx
	mov	eax, DWORD PTR $T233169[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T233127[ebp], ecx
	mov	edx, DWORD PTR $T233127[ebp]
	mov	DWORD PTR $T233152[ebp], edx
	mov	eax, DWORD PTR $T233152[ebp]
	mov	DWORD PTR $T233151[ebp], eax
	mov	ecx, DWORD PTR $T233169[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T233143[ebp], edx
	mov	eax, DWORD PTR $T233143[ebp]
	mov	DWORD PTR $T233154[ebp], eax
	mov	ecx, DWORD PTR $T233154[ebp]
	mov	DWORD PTR $T233153[ebp], ecx
	mov	edx, DWORD PTR $T233151[ebp]
	push	edx
	mov	eax, DWORD PTR $T233153[ebp]
	push	eax
	lea	ecx, DWORD PTR $T233155[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T233169[ebp]
	call	?erase@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@V?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@0@Z ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::erase

; 77   : 	for(int i = 0; i < NUM_GAMEOPTION_TYPES; i++)

	mov	DWORD PTR _i$219226[ebp], 0
	jmp	SHORT $LN33@createInfo
$LN32@createInfo:
	mov	edx, DWORD PTR _i$219226[ebp]
	add	edx, 1
	mov	DWORD PTR _i$219226[ebp], edx
$LN33@createInfo:
	cmp	DWORD PTR _i$219226[ebp], 22		; 00000016H
	jge	SHORT $LN31@createInfo

; 78   : 	{
; 79   : 		GameOptionTypes eOption = (GameOptionTypes)i;

	mov	eax, DWORD PTR _i$219226[ebp]
	mov	DWORD PTR _eOption$219230[ebp], eax

; 80   : 		if(game.isOption(eOption))

	mov	ecx, DWORD PTR _eOption$219230[ebp]
	push	ecx
	mov	ecx, DWORD PTR _game$[ebp]
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN30@createInfo

; 81   : 		{
; 82   : 			m_listGameOptions.push_back(eOption);

	lea	eax, DWORD PTR _eOption$219230[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	call	?push_back@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAEXABW4GameOptionTypes@@@Z ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::push_back
$LN30@createInfo:

; 83   : 		}
; 84   : 	}

	jmp	SHORT $LN32@createInfo
$LN31@createInfo:

; 85   : 
; 86   : 	m_listVictoryTypes.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	mov	DWORD PTR $T233258[ebp], ecx
	mov	edx, DWORD PTR $T233258[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T233216[ebp], eax
	mov	ecx, DWORD PTR $T233216[ebp]
	mov	DWORD PTR $T233241[ebp], ecx
	mov	edx, DWORD PTR $T233241[ebp]
	mov	DWORD PTR $T233240[ebp], edx
	mov	eax, DWORD PTR $T233258[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T233232[ebp], ecx
	mov	edx, DWORD PTR $T233232[ebp]
	mov	DWORD PTR $T233243[ebp], edx
	mov	eax, DWORD PTR $T233243[ebp]
	mov	DWORD PTR $T233242[ebp], eax
	mov	ecx, DWORD PTR $T233240[ebp]
	push	ecx
	mov	edx, DWORD PTR $T233242[ebp]
	push	edx
	lea	eax, DWORD PTR $T233244[ebp]
	push	eax
	mov	ecx, DWORD PTR $T233258[ebp]
	call	?erase@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@V?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@0@Z ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::erase

; 87   : #ifdef AUI_WARNING_FIXES
; 88   : 	for (uint i = 0; i < GC.getNumVictoryInfos(); i++)
; 89   : #else
; 90   : 	for(int i = 0; i < GC.getNumVictoryInfos(); i++)

	mov	DWORD PTR _i$219233[ebp], 0
	jmp	SHORT $LN29@createInfo
$LN28@createInfo:
	mov	ecx, DWORD PTR _i$219233[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$219233[ebp], ecx
$LN29@createInfo:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumVictoryInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumVictoryInfos
	cmp	DWORD PTR _i$219233[ebp], eax
	jge	SHORT $LN27@createInfo

; 91   : #endif
; 92   : 	{
; 93   : 		VictoryTypes eVictory = (VictoryTypes)i;

	mov	edx, DWORD PTR _i$219233[ebp]
	mov	DWORD PTR _eVictory$219237[ebp], edx

; 94   : 		if(game.isVictoryValid(eVictory))

	mov	eax, DWORD PTR _eVictory$219237[ebp]
	push	eax
	mov	ecx, DWORD PTR _game$[ebp]
	call	?isVictoryValid@CvGame@@QBE_NW4VictoryTypes@@@Z ; CvGame::isVictoryValid
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN26@createInfo

; 95   : 		{
; 96   : 			m_listVictoryTypes.push_back(eVictory);

	lea	edx, DWORD PTR _eVictory$219237[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	call	?push_back@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAEXABW4VictoryTypes@@@Z ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::push_back
$LN26@createInfo:

; 97   : 		}
; 98   : 	}

	jmp	SHORT $LN28@createInfo
$LN27@createInfo:

; 99   : 
; 100  : 	m_eVictoryType = NO_VICTORY;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+88], -1

; 101  : 	m_iNormalizedScore = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+140], 0

; 102  : 	if(NO_PLAYER != eActivePlayer)

	cmp	DWORD PTR _eActivePlayer$[ebp], -1
	je	$LN25@createInfo

; 103  : 	{
; 104  : 		CvPlayer& player = GET_PLAYER(eActivePlayer);

	mov	edx, DWORD PTR _eActivePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _player$219241[ebp], edx

; 105  : 		if(game.getWinner() == player.getTeam())

	mov	eax, DWORD PTR _player$219241[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T233301[ebp], eax
	mov	ecx, DWORD PTR _game$[ebp]
	call	?getWinner@CvGame@@QBE?AW4TeamTypes@@XZ	; CvGame::getWinner
	cmp	eax, DWORD PTR $T233301[ebp]
	jne	SHORT $LN117@createInfo

; 106  : 		{
; 107  : 			m_eVictoryType = game.getVictory();

	mov	ecx, DWORD PTR _game$[ebp]
	call	?getVictory@CvGame@@QBE?AW4VictoryTypes@@XZ ; CvGame::getVictory
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+88], eax

; 108  : 		}
; 109  : 
; 110  : 		m_iNormalizedScore = player.GetScore(true, player.getTeam() == game.getWinner());

$LN117@createInfo:
	mov	eax, DWORD PTR _player$219241[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T233310[ebp], eax
	mov	ecx, DWORD PTR _game$[ebp]
	call	?getWinner@CvGame@@QBE?AW4TeamTypes@@XZ	; CvGame::getWinner
	cmp	DWORD PTR $T233310[ebp], eax
	sete	dl
	movzx	eax, dl
	push	eax
	push	1
	mov	ecx, DWORD PTR _player$219241[ebp]
	call	?GetScore@CvPlayer@@QBEH_N0@Z		; CvPlayer::GetScore
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+140], eax
$LN25@createInfo:

; 111  : 	}
; 112  : 
; 113  : 	//m_eGameType = CvPreGame::getGameType();
; 114  : 
; 115  : 	m_iInitialTurn = game.getStartTurn();

	mov	ecx, DWORD PTR _game$[ebp]
	call	?getStartTurn@CvGame@@QBEHXZ		; CvGame::getStartTurn
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+96], eax

; 116  : 	m_iStartYear = game.getStartYear();

	mov	ecx, DWORD PTR _game$[ebp]
	call	?getStartYear@CvGame@@QBEHXZ		; CvGame::getStartYear
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+104], eax

; 117  : 	m_iFinalTurn = game.getGameTurn();

	mov	ecx, DWORD PTR _game$[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+100], eax

; 118  : 	CvGameTextMgr::setYearStr(m_strFinalDate, m_iFinalTurn, false, game.getCalendar(), game.getStartYear(), game.getGameSpeedType());

	mov	ecx, DWORD PTR _game$[ebp]
	call	?getGameSpeedType@CvGame@@QBE?AW4GameSpeedTypes@@XZ ; CvGame::getGameSpeedType
	push	eax
	mov	ecx, DWORD PTR _game$[ebp]
	call	?getStartYear@CvGame@@QBEHXZ		; CvGame::getStartYear
	push	eax
	mov	ecx, DWORD PTR _game$[ebp]
	call	?getCalendar@CvGame@@QBE?AW4CalendarTypes@@XZ ; CvGame::getCalendar
	push	eax
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 108				; 0000006cH
	push	edx
	call	?setYearStr@CvGameTextMgr@@SAXAAVCvString@@H_NW4CalendarTypes@@HW4GameSpeedTypes@@@Z ; CvGameTextMgr::setYearStr
	add	esp, 24					; 00000018H

; 119  : 
; 120  : 	m_eCalendar = game.getCalendar();

	mov	ecx, DWORD PTR _game$[ebp]
	call	?getCalendar@CvGame@@QBE?AW4CalendarTypes@@XZ ; CvGame::getCalendar
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+136], eax

; 121  : 
; 122  : 	m_dataSetMap.clear();

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 176				; 000000b0H
	mov	DWORD PTR $T233368[ebp], edx
	mov	eax, DWORD PTR $T233368[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T233326[ebp], ecx
	mov	edx, DWORD PTR $T233326[ebp]
	mov	DWORD PTR $T233352[ebp], edx
	mov	eax, DWORD PTR $T233352[ebp]
	mov	DWORD PTR $T233351[ebp], eax
	mov	ecx, DWORD PTR $T233368[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T233342[ebp], edx
	mov	eax, DWORD PTR $T233342[ebp]
	mov	DWORD PTR $T233354[ebp], eax
	mov	ecx, DWORD PTR $T233354[ebp]
	mov	DWORD PTR $T233353[ebp], ecx
	mov	edx, DWORD PTR $T233351[ebp]
	push	edx
	mov	eax, DWORD PTR $T233353[ebp]
	push	eax
	lea	ecx, DWORD PTR $T233355[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T233368[ebp]
	call	?erase@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::erase

; 123  : 	m_listPlayerDataSets.clear();

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 192				; 000000c0H
	mov	DWORD PTR $T233426[ebp], edx
	mov	eax, DWORD PTR $T233426[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T233384[ebp], ecx
	mov	edx, DWORD PTR $T233384[ebp]
	mov	DWORD PTR $T233410[ebp], edx
	mov	eax, DWORD PTR $T233410[ebp]
	mov	DWORD PTR $T233409[ebp], eax
	mov	ecx, DWORD PTR $T233426[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T233400[ebp], edx
	mov	eax, DWORD PTR $T233400[ebp]
	mov	DWORD PTR $T233412[ebp], eax
	mov	ecx, DWORD PTR $T233412[ebp]
	mov	DWORD PTR $T233411[ebp], ecx
	mov	edx, DWORD PTR $T233409[ebp]
	push	edx
	mov	eax, DWORD PTR $T233411[ebp]
	push	eax
	lea	ecx, DWORD PTR $T233413[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T233426[ebp]
	call	?erase@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@0@Z ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::erase

; 124  : 	m_listPlayerInfo.clear();

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 144				; 00000090H
	mov	DWORD PTR $T233484[ebp], edx
	mov	eax, DWORD PTR $T233484[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T233442[ebp], ecx
	mov	edx, DWORD PTR $T233442[ebp]
	mov	DWORD PTR $T233468[ebp], edx
	mov	eax, DWORD PTR $T233468[ebp]
	mov	DWORD PTR $T233467[ebp], eax
	mov	ecx, DWORD PTR $T233484[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T233458[ebp], edx
	mov	eax, DWORD PTR $T233458[ebp]
	mov	DWORD PTR $T233470[ebp], eax
	mov	ecx, DWORD PTR $T233470[ebp]
	mov	DWORD PTR $T233469[ebp], ecx
	mov	edx, DWORD PTR $T233467[ebp]
	push	edx
	mov	eax, DWORD PTR $T233469[ebp]
	push	eax
	lea	ecx, DWORD PTR $T233471[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T233484[ebp]
	call	?erase@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@V?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@0@Z ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::erase

; 125  : #ifndef AUI_WARNING_FIXES
; 126  : 	m_listPlots.clear();

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 216				; 000000d8H
	mov	DWORD PTR $T233542[ebp], edx
	mov	eax, DWORD PTR $T233542[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T233500[ebp], ecx
	mov	edx, DWORD PTR $T233500[ebp]
	mov	DWORD PTR $T233525[ebp], edx
	mov	eax, DWORD PTR $T233525[ebp]
	mov	DWORD PTR $T233524[ebp], eax
	mov	ecx, DWORD PTR $T233542[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T233516[ebp], edx
	mov	eax, DWORD PTR $T233516[ebp]
	mov	DWORD PTR $T233527[ebp], eax
	mov	ecx, DWORD PTR $T233527[ebp]
	mov	DWORD PTR $T233526[ebp], ecx
	mov	edx, DWORD PTR $T233524[ebp]
	push	edx
	mov	eax, DWORD PTR $T233526[ebp]
	push	eax
	lea	ecx, DWORD PTR $T233528[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T233542[ebp]
	call	?erase@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@0@Z ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::erase

; 127  : #endif
; 128  : 
; 129  : 	std::map<int, int> mapPlayers;

	lea	edx, DWORD PTR $T233551[ebp]
	push	edx
	lea	eax, DWORD PTR $T233552[ebp]
	push	eax
	lea	ecx, DWORD PTR _mapPlayers$[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 130  : 	mapPlayers[-1] = -1;	//account for NO_PLAYER.

	mov	DWORD PTR $T233089[ebp], -1
	lea	ecx, DWORD PTR $T233089[ebp]
	push	ecx
	lea	ecx, DWORD PTR _mapPlayers$[ebp]
	call	??A?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAEAAHABH@Z ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::operator[]
	mov	DWORD PTR [eax], -1

; 131  : 
; 132  : 	m_iActivePlayer = -1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], -1

; 133  : 	int iPlayerIndex = 0;

	mov	DWORD PTR _iPlayerIndex$[ebp], 0

; 134  : 	for(int iPlayer = 0; iPlayer < MAX_CIV_PLAYERS; iPlayer++)

	mov	DWORD PTR _iPlayer$219743[ebp], 0
	jmp	SHORT $LN23@createInfo
$LN22@createInfo:
	mov	eax, DWORD PTR _iPlayer$219743[ebp]
	add	eax, 1
	mov	DWORD PTR _iPlayer$219743[ebp], eax
$LN23@createInfo:
	cmp	DWORD PTR _iPlayer$219743[ebp], 63	; 0000003fH
	jge	$LN21@createInfo

; 135  : 	{
; 136  : 		CvPlayer& player = GET_PLAYER((PlayerTypes)iPlayer);

	mov	ecx, DWORD PTR _iPlayer$219743[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _player$219747[ebp], ecx

; 137  : 		if(player.isEverAlive())

	mov	edx, DWORD PTR _player$219747[ebp]
	mov	al, BYTE PTR [edx+2268]
	mov	BYTE PTR $T233646[ebp], al
	movzx	ecx, BYTE PTR $T233646[ebp]
	test	ecx, ecx
	je	$LN20@createInfo

; 138  : 		{
; 139  : 			//Ensure that final turn is stored.
; 140  : 			player.GatherPerTurnReplayStats(m_iFinalTurn);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+100]
	push	eax
	mov	ecx, DWORD PTR _player$219747[ebp]
	call	?GatherPerTurnReplayStats@CvPlayer@@QAEXH@Z ; CvPlayer::GatherPerTurnReplayStats

; 141  : 
; 142  : 			mapPlayers[iPlayer] = iPlayerIndex;

	lea	ecx, DWORD PTR _iPlayer$219743[ebp]
	push	ecx
	lea	ecx, DWORD PTR _mapPlayers$[ebp]
	call	??A?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAEAAHABH@Z ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::operator[]
	mov	edx, DWORD PTR _iPlayerIndex$[ebp]
	mov	DWORD PTR [eax], edx

; 143  : 			if(iPlayer == game.getActivePlayer())

	mov	ecx, DWORD PTR _game$[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	DWORD PTR _iPlayer$219743[ebp], eax
	jne	SHORT $LN19@createInfo

; 144  : 			{
; 145  : 				m_iActivePlayer = iPlayerIndex;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iPlayerIndex$[ebp]
	mov	DWORD PTR [eax+4], ecx
$LN19@createInfo:

; 146  : 			}
; 147  : 			++iPlayerIndex;

	mov	edx, DWORD PTR _iPlayerIndex$[ebp]
	add	edx, 1
	mov	DWORD PTR _iPlayerIndex$[ebp], edx

; 148  : 
; 149  : 			PlayerInfo playerInfo;

	lea	ecx, DWORD PTR _playerInfo$219751[ebp]
	call	??0PlayerInfo@CvReplayInfo@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 150  : 			playerInfo.m_eLeader = player.getLeaderType();

	mov	ecx, DWORD PTR _player$219747[ebp]
	call	?getLeaderType@CvPlayer@@QBE?AW4LeaderHeadTypes@@XZ ; CvPlayer::getLeaderType
	mov	DWORD PTR _playerInfo$219751[ebp+4], eax

; 151  : 			playerInfo.m_eCivilization = player.getCivilizationType();

	mov	ecx, DWORD PTR _player$219747[ebp]
	call	?getCivilizationType@CvPlayer@@QBE?AW4CivilizationTypes@@XZ ; CvPlayer::getCivilizationType
	mov	DWORD PTR _playerInfo$219751[ebp], eax

; 152  : 
; 153  : 			playerInfo.m_eDifficulty = player.getHandicapType();

	mov	ecx, DWORD PTR _player$219747[ebp]
	call	?getHandicapType@CvPlayer@@QBE?AW4HandicapTypes@@XZ ; CvPlayer::getHandicapType
	mov	DWORD PTR _playerInfo$219751[ebp+12], eax

; 154  : 			playerInfo.m_strCustomLeaderName = player.getName();

	mov	ecx, DWORD PTR _player$219747[ebp]
	call	?getName@CvPlayer@@QBEPBDXZ		; CvPlayer::getName
	mov	DWORD PTR $T233736[ebp], eax
	cmp	DWORD PTR $T233736[ebp], 0
	je	SHORT $LN265@createInfo
	mov	eax, DWORD PTR $T233736[ebp]
	push	eax
	lea	ecx, DWORD PTR _playerInfo$219751[ebp+16]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN266@createInfo
$LN265@createInfo:
	lea	ecx, DWORD PTR _playerInfo$219751[ebp+16]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN266@createInfo:

; 155  : 			playerInfo.m_strCustomCivilizationName = player.getCivilizationDescription();

	mov	ecx, DWORD PTR _player$219747[ebp]
	call	?getCivilizationDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationDescription
	mov	DWORD PTR $T233742[ebp], eax
	cmp	DWORD PTR $T233742[ebp], 0
	je	SHORT $LN269@createInfo
	mov	ecx, DWORD PTR $T233742[ebp]
	push	ecx
	lea	ecx, DWORD PTR _playerInfo$219751[ebp+44]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN270@createInfo
$LN269@createInfo:
	lea	ecx, DWORD PTR _playerInfo$219751[ebp+44]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN270@createInfo:

; 156  : 			playerInfo.m_strCustomCivilizationShortName = player.getCivilizationShortDescription();

	mov	ecx, DWORD PTR _player$219747[ebp]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T233748[ebp], eax
	cmp	DWORD PTR $T233748[ebp], 0
	je	SHORT $LN273@createInfo
	mov	edx, DWORD PTR $T233748[ebp]
	push	edx
	lea	ecx, DWORD PTR _playerInfo$219751[ebp+72]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN274@createInfo
$LN273@createInfo:
	lea	ecx, DWORD PTR _playerInfo$219751[ebp+72]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN274@createInfo:

; 157  : 			playerInfo.m_strCustomCivilizationAdjective = player.getCivilizationAdjective();

	mov	ecx, DWORD PTR _player$219747[ebp]
	call	?getCivilizationAdjective@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationAdjective
	mov	DWORD PTR $T233754[ebp], eax
	cmp	DWORD PTR $T233754[ebp], 0
	je	SHORT $LN277@createInfo
	mov	eax, DWORD PTR $T233754[ebp]
	push	eax
	lea	ecx, DWORD PTR _playerInfo$219751[ebp+100]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN278@createInfo
$LN277@createInfo:
	lea	ecx, DWORD PTR _playerInfo$219751[ebp+100]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN278@createInfo:

; 158  : 			playerInfo.m_ePlayerColor = player.getPlayerColor();

	mov	ecx, DWORD PTR _player$219747[ebp]
	call	?getPlayerColor@CvPlayer@@QBE?AW4PlayerColorTypes@@XZ ; CvPlayer::getPlayerColor
	mov	DWORD PTR _playerInfo$219751[ebp+8], eax

; 159  : 
; 160  : 
; 161  : 			TurnDataSets dataSet(m_dataSetMap.size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	mov	DWORD PTR $T233758[ebp], ecx
	mov	edx, DWORD PTR $T233758[ebp]
	mov	eax, DWORD PTR $T233758[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	mov	DWORD PTR $T233759[ebp], eax
	mov	edx, DWORD PTR $T233759[ebp]
	push	edx
	lea	ecx, DWORD PTR _dataSet$219752[ebp]
	call	??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@I@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 162  : 
; 163  : 			unsigned int uiNumDataSets = player.getNumReplayDataSets();

	mov	ecx, DWORD PTR _player$219747[ebp]
	call	?getNumReplayDataSets@CvPlayer@@QBEIXZ	; CvPlayer::getNumReplayDataSets
	mov	DWORD PTR _uiNumDataSets$219753[ebp], eax

; 164  : 			for(unsigned int uiPlayerDataSet = 0; uiPlayerDataSet < uiNumDataSets; ++uiPlayerDataSet)

	mov	DWORD PTR _uiPlayerDataSet$219754[ebp], 0
	jmp	SHORT $LN18@createInfo
$LN17@createInfo:
	mov	eax, DWORD PTR _uiPlayerDataSet$219754[ebp]
	add	eax, 1
	mov	DWORD PTR _uiPlayerDataSet$219754[ebp], eax
$LN18@createInfo:
	mov	ecx, DWORD PTR _uiPlayerDataSet$219754[ebp]
	cmp	ecx, DWORD PTR _uiNumDataSets$219753[ebp]
	jae	$LN16@createInfo

; 165  : 			{
; 166  : 				// First, Locate the index of the dataset
; 167  : 				std::string playerDataSetName = player.getReplayDataSetName(uiPlayerDataSet);

	mov	edx, DWORD PTR _uiPlayerDataSet$219754[ebp]
	push	edx
	mov	ecx, DWORD PTR _player$219747[ebp]
	call	?getReplayDataSetName@CvPlayer@@QBEPBDI@Z ; CvPlayer::getReplayDataSetName
	push	eax
	lea	ecx, DWORD PTR _playerDataSetName$219758[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 168  : 				unsigned int uiDataSet = 0;

	mov	DWORD PTR _uiDataSet$219759[ebp], 0

; 169  : 				bool bFound = false;

	mov	BYTE PTR _bFound$219760[ebp], 0

; 170  : 				for(uiDataSet = 0; uiDataSet < m_dataSetMap.size(); ++uiDataSet)

	mov	DWORD PTR _uiDataSet$219759[ebp], 0
	jmp	SHORT $LN15@createInfo
$LN14@createInfo:
	mov	eax, DWORD PTR _uiDataSet$219759[ebp]
	add	eax, 1
	mov	DWORD PTR _uiDataSet$219759[ebp], eax
$LN15@createInfo:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	mov	DWORD PTR $T233841[ebp], ecx
	mov	edx, DWORD PTR $T233841[ebp]
	mov	eax, DWORD PTR $T233841[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	cmp	DWORD PTR _uiDataSet$219759[ebp], eax
	jae	SHORT $LN13@createInfo

; 171  : 				{
; 172  : 					const std::string& dataSetName = m_dataSetMap[uiDataSet];

	mov	edx, DWORD PTR _uiDataSet$219759[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+180]
	mov	DWORD PTR _dataSetName$219764[ebp], edx

; 173  : 					if(dataSetName == playerDataSetName)

	lea	ecx, DWORD PTR _playerDataSetName$219758[ebp]
	push	ecx
	mov	edx, DWORD PTR _dataSetName$219764[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN12@createInfo

; 174  : 					{
; 175  : 						bFound = true;

	mov	BYTE PTR _bFound$219760[ebp], 1

; 176  : 						break;

	jmp	SHORT $LN13@createInfo
$LN12@createInfo:

; 177  : 					}
; 178  : 				}

	jmp	$LN14@createInfo
$LN13@createInfo:

; 179  : 
; 180  : 				// Add a new index if one doesn't exist.
; 181  : 				if(!bFound)

	movzx	ecx, BYTE PTR _bFound$219760[ebp]
	test	ecx, ecx
	jne	$LN11@createInfo

; 182  : 				{
; 183  : 					m_dataSetMap.push_back(playerDataSetName);

	lea	edx, DWORD PTR _playerDataSetName$219758[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	call	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back

; 184  : 					dataSet.push_back(TurnData());

	lea	eax, DWORD PTR $T233885[ebp]
	push	eax
	lea	ecx, DWORD PTR $T233886[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T233090[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
	lea	edx, DWORD PTR $T233090[ebp]
	mov	DWORD PTR tv469[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	eax, DWORD PTR tv469[ebp]
	push	eax
	lea	ecx, DWORD PTR _dataSet$219752[ebp]
	call	?push_back@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::push_back
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T233090[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 185  : 					uiDataSet = m_dataSetMap.size() - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	mov	DWORD PTR $T233992[ebp], ecx
	mov	edx, DWORD PTR $T233992[ebp]
	mov	eax, DWORD PTR $T233992[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	sub	eax, 1
	mov	DWORD PTR _uiDataSet$219759[ebp], eax
$LN11@createInfo:

; 186  : 				}
; 187  : 
; 188  : 				CvPlayer::TurnData playerData = player.getReplayDataHistory(uiPlayerDataSet);

	mov	edx, DWORD PTR _uiPlayerDataSet$219754[ebp]
	push	edx
	lea	eax, DWORD PTR _playerData$219768[ebp]
	push	eax
	mov	ecx, DWORD PTR _player$219747[ebp]
	call	?getReplayDataHistory@CvPlayer@@QBE?AV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@I@Z ; CvPlayer::getReplayDataHistory
	mov	BYTE PTR __$EHRec$[ebp+8], 6

; 189  : 				TurnData turnData;

	lea	ecx, DWORD PTR $T234002[ebp]
	push	ecx
	lea	edx, DWORD PTR $T234003[ebp]
	push	edx
	lea	ecx, DWORD PTR _turnData$219770[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
	mov	BYTE PTR __$EHRec$[ebp+8], 7

; 190  : 
; 191  : 				for(CvPlayer::TurnData::iterator it = playerData.begin(); it != playerData.end(); ++it)

	mov	eax, DWORD PTR _playerData$219768[ebp+4]
	mov	DWORD PTR $T234011[ebp], eax
	mov	ecx, DWORD PTR $T234011[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T234024[ebp], edx
	mov	eax, DWORD PTR $T234024[ebp]
	mov	DWORD PTR _it$219865[ebp], eax
	jmp	SHORT $LN10@createInfo
$LN9@createInfo:
	lea	ecx, DWORD PTR _it$219865[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Inc
$LN10@createInfo:
	mov	ecx, DWORD PTR _playerData$219768[ebp+4]
	mov	DWORD PTR $T234052[ebp], ecx
	mov	edx, DWORD PTR $T234052[ebp]
	mov	DWORD PTR $T233091[ebp], edx
	mov	eax, DWORD PTR _it$219865[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T233091[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN448@createInfo

; 192  : 				{
; 193  : 					turnData[(*it).first - m_iInitialTurn] = (*it).second;

	mov	ecx, DWORD PTR _it$219865[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+96]
	mov	DWORD PTR $T233092[ebp], eax
	mov	ecx, DWORD PTR _it$219865[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR $T234097[ebp], ecx
	lea	edx, DWORD PTR $T233092[ebp]
	push	edx
	lea	ecx, DWORD PTR _turnData$219770[ebp]
	call	??A?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAEAAHABI@Z ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::operator[]
	mov	ecx, DWORD PTR $T234097[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 194  : 				}

	jmp	$LN9@createInfo

; 195  : 
; 196  : 				dataSet[uiDataSet] = turnData;

$LN448@createInfo:
	mov	eax, DWORD PTR _uiDataSet$219759[ebp]
	imul	eax, 12					; 0000000cH
	add	eax, DWORD PTR _dataSet$219752[ebp+4]
	mov	DWORD PTR $T234183[ebp], eax
	lea	ecx, DWORD PTR _turnData$219770[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T234183[ebp]
	call	??4?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::operator=

; 197  : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	ecx, DWORD PTR _turnData$219770[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	lea	ecx, DWORD PTR _playerData$219768[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _playerDataSetName$219758[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	$LN17@createInfo
$LN16@createInfo:

; 198  : 
; 199  : 			m_listPlayerDataSets.push_back(dataSet);

	lea	edx, DWORD PTR _dataSet$219752[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 192				; 000000c0H
	call	?push_back@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAEXABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::push_back

; 200  : 			m_listPlayerInfo.push_back(playerInfo);

	lea	eax, DWORD PTR _playerInfo$219751[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 144				; 00000090H
	call	?push_back@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAEXABUPlayerInfo@CvReplayInfo@@@Z ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::push_back

; 201  : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	lea	ecx, DWORD PTR _dataSet$219752[ebp]
	call	?_Tidy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _playerInfo$219751[ebp]
	call	??1PlayerInfo@CvReplayInfo@@QAE@XZ
$LN20@createInfo:

; 202  : 	}

	jmp	$LN22@createInfo
$LN21@createInfo:

; 203  : 
; 204  : 	m_listReplayMessages.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 160				; 000000a0H
	mov	DWORD PTR $T234483[ebp], ecx
	mov	edx, DWORD PTR $T234483[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T234441[ebp], eax
	mov	ecx, DWORD PTR $T234441[ebp]
	mov	DWORD PTR $T234467[ebp], ecx
	mov	edx, DWORD PTR $T234467[ebp]
	mov	DWORD PTR $T234466[ebp], edx
	mov	eax, DWORD PTR $T234483[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T234457[ebp], ecx
	mov	edx, DWORD PTR $T234457[ebp]
	mov	DWORD PTR $T234469[ebp], edx
	mov	eax, DWORD PTR $T234469[ebp]
	mov	DWORD PTR $T234468[ebp], eax
	mov	ecx, DWORD PTR $T234466[ebp]
	push	ecx
	mov	edx, DWORD PTR $T234468[ebp]
	push	edx
	lea	eax, DWORD PTR $T234470[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234483[ebp]
	call	?erase@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@V?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@0@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::erase

; 205  : 	const uint nMessages = game.getNumReplayMessages();

	mov	ecx, DWORD PTR _game$[ebp]
	call	?getNumReplayMessages@CvGame@@QBEIXZ	; CvGame::getNumReplayMessages
	mov	DWORD PTR _nMessages$[ebp], eax

; 206  : 	m_listReplayMessages.reserve(nMessages);

	mov	ecx, DWORD PTR _nMessages$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 160				; 000000a0H
	call	?reserve@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXI@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::reserve

; 207  : 
; 208  : 	for(uint i = 0; i < nMessages; ++i)

	mov	DWORD PTR _i$219897[ebp], 0
	jmp	SHORT $LN7@createInfo
$LN6@createInfo:
	mov	edx, DWORD PTR _i$219897[ebp]
	add	edx, 1
	mov	DWORD PTR _i$219897[ebp], edx
$LN7@createInfo:
	mov	eax, DWORD PTR _i$219897[ebp]
	cmp	eax, DWORD PTR _nMessages$[ebp]
	jae	$LN5@createInfo

; 209  : 	{
; 210  : 		const CvReplayMessage* pMessage = game.getReplayMessage(i);

	mov	ecx, DWORD PTR _i$219897[ebp]
	push	ecx
	mov	ecx, DWORD PTR _game$[ebp]
	call	?getReplayMessage@CvGame@@QBEPBVCvReplayMessage@@I@Z ; CvGame::getReplayMessage
	mov	DWORD PTR _pMessage$219901[ebp], eax

; 211  : 		if(pMessage)

	cmp	DWORD PTR _pMessage$219901[ebp], 0
	je	SHORT $LN4@createInfo

; 212  : 		{
; 213  : 			CvReplayMessage modifiedMessage = (*pMessage);

	mov	edx, DWORD PTR _pMessage$219901[ebp]
	push	edx
	lea	ecx, DWORD PTR _modifiedMessage$219903[ebp]
	call	??0CvReplayMessage@@QAE@ABV0@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH

; 214  : 			modifiedMessage.setPlayer((PlayerTypes)mapPlayers[modifiedMessage.getPlayer()]);

	lea	ecx, DWORD PTR _modifiedMessage$219903[ebp]
	call	?getPlayer@CvReplayMessage@@QBE?AW4PlayerTypes@@XZ ; CvReplayMessage::getPlayer
	mov	DWORD PTR $T233093[ebp], eax
	lea	eax, DWORD PTR $T233093[ebp]
	push	eax
	lea	ecx, DWORD PTR _mapPlayers$[ebp]
	call	??A?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAEAAHABH@Z ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::operator[]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR _modifiedMessage$219903[ebp]
	call	?setPlayer@CvReplayMessage@@QAEXW4PlayerTypes@@@Z ; CvReplayMessage::setPlayer

; 215  : 
; 216  : 			m_listReplayMessages.push_back(modifiedMessage);

	lea	edx, DWORD PTR _modifiedMessage$219903[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 160				; 000000a0H
	call	?push_back@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXABVCvReplayMessage@@@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::push_back

; 217  : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _modifiedMessage$219903[ebp]
	call	??1CvReplayMessage@@UAE@XZ		; CvReplayMessage::~CvReplayMessage
$LN4@createInfo:

; 218  : 	}

	jmp	$LN6@createInfo
$LN5@createInfo:

; 219  : 
; 220  : 	CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 221  : 
; 222  : 	m_iMapWidth = kMap.getGridWidth();

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T234603[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T234603[ebp]
	mov	DWORD PTR [eax+212], ecx

; 223  : 	m_iMapHeight = kMap.getGridHeight();

	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T234607[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T234607[ebp]
	mov	DWORD PTR [ecx+208], edx

; 224  : 
; 225  : 	int numPlots = kMap.numPlots();

	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4028]
	mov	DWORD PTR _numPlots$[ebp], ecx

; 226  : 	m_listPlots.clear();

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 216				; 000000d8H
	mov	DWORD PTR $T234668[ebp], edx
	mov	eax, DWORD PTR $T234668[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T234626[ebp], ecx
	mov	edx, DWORD PTR $T234626[ebp]
	mov	DWORD PTR $T234651[ebp], edx
	mov	eax, DWORD PTR $T234651[ebp]
	mov	DWORD PTR $T234650[ebp], eax
	mov	ecx, DWORD PTR $T234668[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T234642[ebp], edx
	mov	eax, DWORD PTR $T234642[ebp]
	mov	DWORD PTR $T234653[ebp], eax
	mov	ecx, DWORD PTR $T234653[ebp]
	mov	DWORD PTR $T234652[ebp], ecx
	mov	edx, DWORD PTR $T234650[ebp]
	push	edx
	mov	eax, DWORD PTR $T234652[ebp]
	push	eax
	lea	ecx, DWORD PTR $T234654[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T234668[ebp]
	call	?erase@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@0@Z ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::erase

; 227  : 	m_listPlots.reserve(numPlots);

	mov	edx, DWORD PTR _numPlots$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 216				; 000000d8H
	call	?reserve@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXI@Z ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::reserve

; 228  : 
; 229  : 	for(int i = 0; i < numPlots; i++)

	mov	DWORD PTR _i$219908[ebp], 0
	jmp	SHORT $LN3@createInfo
$LN2@createInfo:
	mov	eax, DWORD PTR _i$219908[ebp]
	add	eax, 1
	mov	DWORD PTR _i$219908[ebp], eax
$LN3@createInfo:
	mov	ecx, DWORD PTR _i$219908[ebp]
	cmp	ecx, DWORD PTR _numPlots$[ebp]
	jge	$LN1@createInfo

; 230  : 	{
; 231  : 		PlotState plotState;
; 232  : 
; 233  : 		CvPlot* pkPlot = kMap.plotByIndexUnchecked(i);

	mov	edx, DWORD PTR _i$219908[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR _kMap$[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR _pkPlot$219913[ebp], edx

; 234  : 		plotState.m_ePlotType = pkPlot->getPlotType();

	mov	ecx, DWORD PTR _pkPlot$219913[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	mov	DWORD PTR _plotState$219912[ebp], edx

; 235  : 		plotState.m_eTerrain = pkPlot->getTerrainType();

	mov	eax, DWORD PTR _pkPlot$219913[ebp]
	movsx	ecx, BYTE PTR [eax+6]
	mov	DWORD PTR _plotState$219912[ebp+4], ecx

; 236  : 		plotState.m_eFeature = pkPlot->getFeatureType();

	mov	edx, DWORD PTR _pkPlot$219913[ebp]
	mov	al, BYTE PTR [edx+432]
	mov	BYTE PTR _f$234686[ebp], al
	movsx	ecx, BYTE PTR _f$234686[ebp]
	mov	DWORD PTR _plotState$219912[ebp+8], ecx

; 237  : 		plotState.m_bNEOfRiver = pkPlot->isNEOfRiver();

	mov	ecx, DWORD PTR _pkPlot$219913[ebp]
	call	?isNEOfRiver@CvPlot@@QBE_NXZ		; CvPlot::isNEOfRiver
	mov	BYTE PTR _plotState$219912[ebp+12], al

; 238  : 		plotState.m_bWOfRiver = pkPlot->isWOfRiver();

	mov	ecx, DWORD PTR _pkPlot$219913[ebp]
	call	?isWOfRiver@CvPlot@@QBE_NXZ		; CvPlot::isWOfRiver
	mov	BYTE PTR _plotState$219912[ebp+13], al

; 239  : 		plotState.m_bNWOfRiver = pkPlot->isNWOfRiver();

	mov	ecx, DWORD PTR _pkPlot$219913[ebp]
	call	?isNWOfRiver@CvPlot@@QBE_NXZ		; CvPlot::isNWOfRiver
	mov	BYTE PTR _plotState$219912[ebp+14], al

; 240  : 
; 241  : 		PlotStatePerTurn plotStatePerTurn;

	lea	ecx, DWORD PTR _plotStatePerTurn$220497[ebp]
	call	??0?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAE@XZ ; std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH

; 242  : 		plotStatePerTurn[m_iFinalTurn] = plotState;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T233094[ebp], eax
	lea	ecx, DWORD PTR $T233094[ebp]
	push	ecx
	lea	ecx, DWORD PTR _plotStatePerTurn$220497[ebp]
	call	??A?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAEAAUPlotState@CvReplayInfo@@ABI@Z ; std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >::operator[]
	mov	edx, DWORD PTR _plotState$219912[ebp]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR _plotState$219912[ebp+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR _plotState$219912[ebp+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR _plotState$219912[ebp+12]
	mov	DWORD PTR [eax+12], ecx

; 243  : 
; 244  : 		m_listPlots.push_back(plotStatePerTurn);

	lea	edx, DWORD PTR _plotStatePerTurn$220497[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 216				; 000000d8H
	call	?push_back@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::push_back

; 245  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH
	lea	ecx, DWORD PTR _plotStatePerTurn$220497[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	jmp	$LN2@createInfo
$LN1@createInfo:

; 246  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR __$EHRec$[ebp+8], 14		; 0000000eH
	lea	ecx, DWORD PTR _mapPlayers$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$0:
	lea	ecx, DWORD PTR _mapPlayers$[ebp]
	jmp	??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$1:
	lea	ecx, DWORD PTR _playerInfo$219751[ebp]
	jmp	??1PlayerInfo@CvReplayInfo@@QAE@XZ
__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$2:
	lea	ecx, DWORD PTR _dataSet$219752[ebp]
	jmp	??1?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::~vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$3:
	lea	ecx, DWORD PTR _playerDataSetName$219758[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$4:
	lea	ecx, DWORD PTR $T233090[ebp]
	jmp	??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ
__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$24:
	lea	ecx, DWORD PTR $T233090[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$5:
	lea	ecx, DWORD PTR _playerData$219768[ebp]
	jmp	??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ
__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$6:
	lea	ecx, DWORD PTR _turnData$219770[ebp]
	jmp	??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ
__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$31:
	lea	ecx, DWORD PTR _turnData$219770[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$37:
	lea	ecx, DWORD PTR _playerData$219768[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$42:
	lea	ecx, DWORD PTR _dataSet$219752[ebp]
	jmp	??1?$_Vector_val@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ
__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$7:
	lea	ecx, DWORD PTR _modifiedMessage$219903[ebp]
	jmp	??1CvReplayMessage@@UAE@XZ		; CvReplayMessage::~CvReplayMessage
__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$8:
	lea	ecx, DWORD PTR _plotStatePerTurn$220497[ebp]
	jmp	??1?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAE@XZ
__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$55:
	lea	ecx, DWORD PTR _plotStatePerTurn$220497[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__unwindfunclet$?createInfo@CvReplayInfo@@QAEXXZ$61:
	lea	ecx, DWORD PTR _mapPlayers$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$?createInfo@CvReplayInfo@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?createInfo@CvReplayInfo@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?createInfo@CvReplayInfo@@QAEXXZ ENDP			; CvReplayInfo::createInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ$1
__ehfuncinfo$??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -100						; size = 4
__$EHRec$ = -12						; size = 12
??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ PROC ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::~map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-92]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ENDP ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::~map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0PlayerInfo@CvReplayInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0PlayerInfo@CvReplayInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0PlayerInfo@CvReplayInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0PlayerInfo@CvReplayInfo@@QAE@XZ$2
__ehfuncinfo$??0PlayerInfo@CvReplayInfo@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0PlayerInfo@CvReplayInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0PlayerInfo@CvReplayInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T235126 = -28						; size = 4
$T235121 = -24						; size = 4
$T235116 = -20						; size = 4
$T235111 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0PlayerInfo@CvReplayInfo@@QAE@XZ PROC			; CvReplayInfo::PlayerInfo::PlayerInfo, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0PlayerInfo@CvReplayInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR $T235111[ebp], eax
	mov	ecx, DWORD PTR $T235111[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	mov	DWORD PTR $T235116[ebp], ecx
	mov	ecx, DWORD PTR $T235116[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 72					; 00000048H
	mov	DWORD PTR $T235121[ebp], edx
	mov	ecx, DWORD PTR $T235121[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 100				; 00000064H
	mov	DWORD PTR $T235126[ebp], eax
	mov	ecx, DWORD PTR $T235126[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0PlayerInfo@CvReplayInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0PlayerInfo@CvReplayInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0PlayerInfo@CvReplayInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??0PlayerInfo@CvReplayInfo@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0PlayerInfo@CvReplayInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0PlayerInfo@CvReplayInfo@@QAE@XZ ENDP			; CvReplayInfo::PlayerInfo::PlayerInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1PlayerInfo@CvReplayInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1PlayerInfo@CvReplayInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1PlayerInfo@CvReplayInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1PlayerInfo@CvReplayInfo@@QAE@XZ$2
__ehfuncinfo$??1PlayerInfo@CvReplayInfo@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1PlayerInfo@CvReplayInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1PlayerInfo@CvReplayInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T235158 = -28						; size = 4
$T235153 = -24						; size = 4
$T235148 = -20						; size = 4
$T235143 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1PlayerInfo@CvReplayInfo@@QAE@XZ PROC			; CvReplayInfo::PlayerInfo::~PlayerInfo, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1PlayerInfo@CvReplayInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 100				; 00000064H
	mov	DWORD PTR $T235143[ebp], eax
	mov	ecx, DWORD PTR $T235143[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	mov	DWORD PTR $T235148[ebp], ecx
	mov	ecx, DWORD PTR $T235148[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 44					; 0000002cH
	mov	DWORD PTR $T235153[ebp], edx
	mov	ecx, DWORD PTR $T235153[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR $T235158[ebp], eax
	mov	ecx, DWORD PTR $T235158[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1PlayerInfo@CvReplayInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1PlayerInfo@CvReplayInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1PlayerInfo@CvReplayInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1PlayerInfo@CvReplayInfo@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1PlayerInfo@CvReplayInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1PlayerInfo@CvReplayInfo@@QAE@XZ ENDP			; CvReplayInfo::PlayerInfo::~PlayerInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ$1
__ehfuncinfo$??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -100						; size = 4
__$EHRec$ = -12						; size = 12
??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ PROC ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::~map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-92]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ ENDP ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::~map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >
PUBLIC	??1?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::~vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >
PUBLIC	??0?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@ABV01@@Z ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >
PUBLIC	??_7CvReplayMessage@@6B@			; CvReplayMessage::`vftable'
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	??_ECvReplayMessage@@UAEPAXI@Z:PROC		; CvReplayMessage::`vector deleting destructor'
;	COMDAT ??_7CvReplayMessage@@6B@
CONST	SEGMENT
??_7CvReplayMessage@@6B@ DD FLAT:??_ECvReplayMessage@@UAEPAXI@Z ; CvReplayMessage::`vftable'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CvReplayMessage@@QAE@ABV0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvReplayMessage@@QAE@ABV0@@Z$0
__ehfuncinfo$??0CvReplayMessage@@QAE@ABV0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvReplayMessage@@QAE@ABV0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0CvReplayMessage@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T235443 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0CvReplayMessage@@QAE@ABV0@@Z PROC			; CvReplayMessage::CvReplayMessage, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvReplayMessage@@QAE@ABV0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvReplayMessage@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@ABV01@@Z ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR [edx+28], ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 32					; 00000020H
	mov	DWORD PTR $T235443[ebp], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	mov	ecx, DWORD PTR $T235443[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvReplayMessage@@QAE@ABV0@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	??1?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::~vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >
__ehhandler$??0CvReplayMessage@@QAE@ABV0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvReplayMessage@@QAE@ABV0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvReplayMessage@@QAE@ABV0@@Z ENDP			; CvReplayMessage::CvReplayMessage
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAE@XZ$1
__ehfuncinfo$??1?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -100						; size = 4
__$EHRec$ = -12						; size = 12
??1?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAE@XZ PROC ; std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >::~map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-92]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAE@XZ ENDP ; std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >::~map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >
; Function compile flags: /Odtp
;	COMDAT ??_GCvReplayMessage@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCvReplayMessage@@UAEPAXI@Z PROC			; CvReplayMessage::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvReplayMessage@@UAE@XZ		; CvReplayMessage::~CvReplayMessage
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@2
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCvReplayMessage@@UAEPAXI@Z ENDP			; CvReplayMessage::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?getNumPlayers@CvReplayInfo@@QBEHXZ		; CvReplayInfo::getNumPlayers
; Function compile flags: /Odtp
;	COMDAT ?getNumPlayers@CvReplayInfo@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T235727 = -4						; size = 4
?getNumPlayers@CvReplayInfo@@QBEHXZ PROC		; CvReplayInfo::getNumPlayers, COMDAT
; _this$ = ecx

; 249  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 250  : 	return (int)m_listPlayerInfo.size();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 144				; 00000090H
	mov	DWORD PTR $T235727[ebp], eax
	mov	ecx, DWORD PTR $T235727[ebp]
	mov	edx, DWORD PTR $T235727[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 7

; 251  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getNumPlayers@CvReplayInfo@@QBEHXZ ENDP		; CvReplayInfo::getNumPlayers
_TEXT	ENDS
PUBLIC	?isValidPlayer@CvReplayInfo@@IBE_NH@Z		; CvReplayInfo::isValidPlayer
; Function compile flags: /Odtp
;	COMDAT ?isValidPlayer@CvReplayInfo@@IBE_NH@Z
_TEXT	SEGMENT
tv69 = -12						; size = 4
_this$ = -8						; size = 4
$T235735 = -4						; size = 4
_i$ = 8							; size = 4
?isValidPlayer@CvReplayInfo@@IBE_NH@Z PROC		; CvReplayInfo::isValidPlayer, COMDAT
; _this$ = ecx

; 255  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 256  : 	return (i >= 0 && i < (int)m_listPlayerInfo.size());

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN3@isValidPla
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 144				; 00000090H
	mov	DWORD PTR $T235735[ebp], eax
	mov	ecx, DWORD PTR $T235735[ebp]
	mov	edx, DWORD PTR $T235735[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 7
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN3@isValidPla
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@isValidPla
$LN3@isValidPla:
	mov	DWORD PTR tv69[ebp], 0
$LN4@isValidPla:
	mov	al, BYTE PTR tv69[ebp]

; 257  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isValidPlayer@CvReplayInfo@@IBE_NH@Z ENDP		; CvReplayInfo::isValidPlayer
_TEXT	ENDS
PUBLIC	?isValidTurn@CvReplayInfo@@IBE_NH@Z		; CvReplayInfo::isValidTurn
; Function compile flags: /Odtp
;	COMDAT ?isValidTurn@CvReplayInfo@@IBE_NH@Z
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?isValidTurn@CvReplayInfo@@IBE_NH@Z PROC		; CvReplayInfo::isValidTurn, COMDAT
; _this$ = ecx

; 260  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 261  : 	return (i >= m_iInitialTurn && i <= m_iFinalTurn);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+96]
	jl	SHORT $LN3@isValidTur
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+100]
	jg	SHORT $LN3@isValidTur
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@isValidTur
$LN3@isValidTur:
	mov	DWORD PTR tv68[ebp], 0
$LN4@isValidTur:
	mov	al, BYTE PTR tv68[ebp]

; 262  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isValidTurn@CvReplayInfo@@IBE_NH@Z ENDP		; CvReplayInfo::isValidTurn
_TEXT	ENDS
PUBLIC	?getActivePlayer@CvReplayInfo@@QBEHXZ		; CvReplayInfo::getActivePlayer
; Function compile flags: /Odtp
;	COMDAT ?getActivePlayer@CvReplayInfo@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getActivePlayer@CvReplayInfo@@QBEHXZ PROC		; CvReplayInfo::getActivePlayer, COMDAT
; _this$ = ecx

; 265  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 266  : 	return m_iActivePlayer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 267  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getActivePlayer@CvReplayInfo@@QBEHXZ ENDP		; CvReplayInfo::getActivePlayer
_TEXT	ENDS
PUBLIC	?getPlayerCivilization@CvReplayInfo@@QBE?AW4CivilizationTypes@@H@Z ; CvReplayInfo::getPlayerCivilization
; Function compile flags: /Odtp
;	COMDAT ?getPlayerCivilization@CvReplayInfo@@QBE?AW4CivilizationTypes@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T235747 = -4						; size = 4
_iPlayer$ = 8						; size = 4
?getPlayerCivilization@CvReplayInfo@@QBE?AW4CivilizationTypes@@H@Z PROC ; CvReplayInfo::getPlayerCivilization, COMDAT
; _this$ = ecx

; 270  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 271  : 	if(iPlayer >= 0 && iPlayer < (int)m_listPlayerInfo.size())

	cmp	DWORD PTR _iPlayer$[ebp], 0
	jl	SHORT $LN1@getPlayerC
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 144				; 00000090H
	mov	DWORD PTR $T235747[ebp], eax
	mov	ecx, DWORD PTR $T235747[ebp]
	mov	edx, DWORD PTR $T235747[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 7
	cmp	DWORD PTR _iPlayer$[ebp], eax
	jge	SHORT $LN1@getPlayerC

; 272  : 	{
; 273  : 		return m_listPlayerInfo[iPlayer].m_eCivilization;

	mov	ecx, DWORD PTR _iPlayer$[ebp]
	shl	ecx, 7
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	eax, DWORD PTR [ecx+eax]
	jmp	SHORT $LN2@getPlayerC
$LN1@getPlayerC:

; 274  : 	}
; 275  : 
; 276  : 	return NO_CIVILIZATION;

	or	eax, -1
$LN2@getPlayerC:

; 277  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getPlayerCivilization@CvReplayInfo@@QBE?AW4CivilizationTypes@@H@Z ENDP ; CvReplayInfo::getPlayerCivilization
_TEXT	ENDS
PUBLIC	?getPlayerLeader@CvReplayInfo@@QBE?AW4LeaderHeadTypes@@H@Z ; CvReplayInfo::getPlayerLeader
; Function compile flags: /Odtp
;	COMDAT ?getPlayerLeader@CvReplayInfo@@QBE?AW4LeaderHeadTypes@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T235756 = -4						; size = 4
_iPlayer$ = 8						; size = 4
?getPlayerLeader@CvReplayInfo@@QBE?AW4LeaderHeadTypes@@H@Z PROC ; CvReplayInfo::getPlayerLeader, COMDAT
; _this$ = ecx

; 280  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 281  : 	if(iPlayer >= 0 && iPlayer < (int)m_listPlayerInfo.size())

	cmp	DWORD PTR _iPlayer$[ebp], 0
	jl	SHORT $LN1@getPlayerL
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 144				; 00000090H
	mov	DWORD PTR $T235756[ebp], eax
	mov	ecx, DWORD PTR $T235756[ebp]
	mov	edx, DWORD PTR $T235756[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 7
	cmp	DWORD PTR _iPlayer$[ebp], eax
	jge	SHORT $LN1@getPlayerL

; 282  : 	{
; 283  : 		return m_listPlayerInfo[iPlayer].m_eLeader;

	mov	ecx, DWORD PTR _iPlayer$[ebp]
	shl	ecx, 7
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	eax, DWORD PTR [eax+ecx+4]
	jmp	SHORT $LN2@getPlayerL
$LN1@getPlayerL:

; 284  : 	}
; 285  : 
; 286  : 	return NO_LEADER;

	or	eax, -1
$LN2@getPlayerL:

; 287  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getPlayerLeader@CvReplayInfo@@QBE?AW4LeaderHeadTypes@@H@Z ENDP ; CvReplayInfo::getPlayerLeader
_TEXT	ENDS
PUBLIC	?getPlayerColor@CvReplayInfo@@QBE?AW4PlayerColorTypes@@H@Z ; CvReplayInfo::getPlayerColor
; Function compile flags: /Odtp
;	COMDAT ?getPlayerColor@CvReplayInfo@@QBE?AW4PlayerColorTypes@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T235765 = -4						; size = 4
_iPlayer$ = 8						; size = 4
?getPlayerColor@CvReplayInfo@@QBE?AW4PlayerColorTypes@@H@Z PROC ; CvReplayInfo::getPlayerColor, COMDAT
; _this$ = ecx

; 290  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 291  : 	if(iPlayer >= 0 && iPlayer < (int)m_listPlayerInfo.size())

	cmp	DWORD PTR _iPlayer$[ebp], 0
	jl	SHORT $LN1@getPlayerC@2
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 144				; 00000090H
	mov	DWORD PTR $T235765[ebp], eax
	mov	ecx, DWORD PTR $T235765[ebp]
	mov	edx, DWORD PTR $T235765[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 7
	cmp	DWORD PTR _iPlayer$[ebp], eax
	jge	SHORT $LN1@getPlayerC@2

; 292  : 	{
; 293  : 		return m_listPlayerInfo[iPlayer].m_ePlayerColor;

	mov	ecx, DWORD PTR _iPlayer$[ebp]
	shl	ecx, 7
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	eax, DWORD PTR [eax+ecx+8]
	jmp	SHORT $LN2@getPlayerC@2
$LN1@getPlayerC@2:

; 294  : 	}
; 295  : 
; 296  : 	return NO_PLAYERCOLOR;

	or	eax, -1
$LN2@getPlayerC@2:

; 297  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getPlayerColor@CvReplayInfo@@QBE?AW4PlayerColorTypes@@H@Z ENDP ; CvReplayInfo::getPlayerColor
_TEXT	ENDS
PUBLIC	?getPlayerDifficulty@CvReplayInfo@@QBE?AW4HandicapTypes@@H@Z ; CvReplayInfo::getPlayerDifficulty
; Function compile flags: /Odtp
;	COMDAT ?getPlayerDifficulty@CvReplayInfo@@QBE?AW4HandicapTypes@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T235774 = -4						; size = 4
_iPlayer$ = 8						; size = 4
?getPlayerDifficulty@CvReplayInfo@@QBE?AW4HandicapTypes@@H@Z PROC ; CvReplayInfo::getPlayerDifficulty, COMDAT
; _this$ = ecx

; 300  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 301  : 	if(iPlayer >= 0 && iPlayer < (int)m_listPlayerInfo.size())

	cmp	DWORD PTR _iPlayer$[ebp], 0
	jl	SHORT $LN1@getPlayerD
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 144				; 00000090H
	mov	DWORD PTR $T235774[ebp], eax
	mov	ecx, DWORD PTR $T235774[ebp]
	mov	edx, DWORD PTR $T235774[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 7
	cmp	DWORD PTR _iPlayer$[ebp], eax
	jge	SHORT $LN1@getPlayerD

; 302  : 	{
; 303  : 		return m_listPlayerInfo[iPlayer].m_eDifficulty;

	mov	ecx, DWORD PTR _iPlayer$[ebp]
	shl	ecx, 7
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	eax, DWORD PTR [eax+ecx+12]
	jmp	SHORT $LN2@getPlayerD
$LN1@getPlayerD:

; 304  : 	}
; 305  : 
; 306  : 	return NO_HANDICAP;

	or	eax, -1
$LN2@getPlayerD:

; 307  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getPlayerDifficulty@CvReplayInfo@@QBE?AW4HandicapTypes@@H@Z ENDP ; CvReplayInfo::getPlayerDifficulty
_TEXT	ENDS
PUBLIC	?getPlayerLeaderName@CvReplayInfo@@QBEPBDH@Z	; CvReplayInfo::getPlayerLeaderName
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Odtp
;	COMDAT ?getPlayerLeaderName@CvReplayInfo@@QBEPBDH@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T235787 = -8						; size = 4
$T235783 = -4						; size = 4
_iPlayer$ = 8						; size = 4
?getPlayerLeaderName@CvReplayInfo@@QBEPBDH@Z PROC	; CvReplayInfo::getPlayerLeaderName, COMDAT
; _this$ = ecx

; 310  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 311  : 	if(iPlayer >= 0 && iPlayer < (int)m_listPlayerInfo.size())

	cmp	DWORD PTR _iPlayer$[ebp], 0
	jl	SHORT $LN1@getPlayerL@2
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 144				; 00000090H
	mov	DWORD PTR $T235783[ebp], eax
	mov	ecx, DWORD PTR $T235783[ebp]
	mov	edx, DWORD PTR $T235783[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 7
	cmp	DWORD PTR _iPlayer$[ebp], eax
	jge	SHORT $LN1@getPlayerL@2

; 312  : 	{
; 313  : 		return m_listPlayerInfo[iPlayer].m_strCustomLeaderName;

	mov	ecx, DWORD PTR _iPlayer$[ebp]
	shl	ecx, 7
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+148]
	mov	DWORD PTR $T235787[ebp], ecx
	mov	ecx, DWORD PTR $T235787[ebp]
	add	ecx, 16					; 00000010H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	jmp	SHORT $LN2@getPlayerL@2
$LN1@getPlayerL@2:

; 314  : 	}
; 315  : 
; 316  : 	return NULL;

	xor	eax, eax
$LN2@getPlayerL@2:

; 317  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getPlayerLeaderName@CvReplayInfo@@QBEPBDH@Z ENDP	; CvReplayInfo::getPlayerLeaderName
_TEXT	ENDS
PUBLIC	?getPlayerCivDescription@CvReplayInfo@@QBEPBDH@Z ; CvReplayInfo::getPlayerCivDescription
; Function compile flags: /Odtp
;	COMDAT ?getPlayerCivDescription@CvReplayInfo@@QBEPBDH@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T235800 = -8						; size = 4
$T235796 = -4						; size = 4
_iPlayer$ = 8						; size = 4
?getPlayerCivDescription@CvReplayInfo@@QBEPBDH@Z PROC	; CvReplayInfo::getPlayerCivDescription, COMDAT
; _this$ = ecx

; 320  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 321  : 	if(iPlayer >= 0 && iPlayer < (int)m_listPlayerInfo.size())

	cmp	DWORD PTR _iPlayer$[ebp], 0
	jl	SHORT $LN1@getPlayerC@3
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 144				; 00000090H
	mov	DWORD PTR $T235796[ebp], eax
	mov	ecx, DWORD PTR $T235796[ebp]
	mov	edx, DWORD PTR $T235796[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 7
	cmp	DWORD PTR _iPlayer$[ebp], eax
	jge	SHORT $LN1@getPlayerC@3

; 322  : 	{
; 323  : 		return m_listPlayerInfo[iPlayer].m_strCustomCivilizationName;

	mov	ecx, DWORD PTR _iPlayer$[ebp]
	shl	ecx, 7
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+148]
	mov	DWORD PTR $T235800[ebp], ecx
	mov	ecx, DWORD PTR $T235800[ebp]
	add	ecx, 44					; 0000002cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	jmp	SHORT $LN2@getPlayerC@3
$LN1@getPlayerC@3:

; 324  : 	}
; 325  : 
; 326  : 	return NULL;

	xor	eax, eax
$LN2@getPlayerC@3:

; 327  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getPlayerCivDescription@CvReplayInfo@@QBEPBDH@Z ENDP	; CvReplayInfo::getPlayerCivDescription
_TEXT	ENDS
PUBLIC	?getPlayerShortCivDescription@CvReplayInfo@@QBEPBDH@Z ; CvReplayInfo::getPlayerShortCivDescription
; Function compile flags: /Odtp
;	COMDAT ?getPlayerShortCivDescription@CvReplayInfo@@QBEPBDH@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T235813 = -8						; size = 4
$T235809 = -4						; size = 4
_iPlayer$ = 8						; size = 4
?getPlayerShortCivDescription@CvReplayInfo@@QBEPBDH@Z PROC ; CvReplayInfo::getPlayerShortCivDescription, COMDAT
; _this$ = ecx

; 330  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 331  : 	if(iPlayer >= 0 && iPlayer < (int)m_listPlayerInfo.size())

	cmp	DWORD PTR _iPlayer$[ebp], 0
	jl	SHORT $LN1@getPlayerS
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 144				; 00000090H
	mov	DWORD PTR $T235809[ebp], eax
	mov	ecx, DWORD PTR $T235809[ebp]
	mov	edx, DWORD PTR $T235809[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 7
	cmp	DWORD PTR _iPlayer$[ebp], eax
	jge	SHORT $LN1@getPlayerS

; 332  : 	{
; 333  : 		return m_listPlayerInfo[iPlayer].m_strCustomCivilizationShortName;

	mov	ecx, DWORD PTR _iPlayer$[ebp]
	shl	ecx, 7
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+148]
	mov	DWORD PTR $T235813[ebp], ecx
	mov	ecx, DWORD PTR $T235813[ebp]
	add	ecx, 72					; 00000048H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	jmp	SHORT $LN2@getPlayerS
$LN1@getPlayerS:

; 334  : 	}
; 335  : 
; 336  : 	return NULL;

	xor	eax, eax
$LN2@getPlayerS:

; 337  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getPlayerShortCivDescription@CvReplayInfo@@QBEPBDH@Z ENDP ; CvReplayInfo::getPlayerShortCivDescription
_TEXT	ENDS
PUBLIC	?getPlayerCivAdjective@CvReplayInfo@@QBEPBDH@Z	; CvReplayInfo::getPlayerCivAdjective
; Function compile flags: /Odtp
;	COMDAT ?getPlayerCivAdjective@CvReplayInfo@@QBEPBDH@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T235826 = -8						; size = 4
$T235822 = -4						; size = 4
_iPlayer$ = 8						; size = 4
?getPlayerCivAdjective@CvReplayInfo@@QBEPBDH@Z PROC	; CvReplayInfo::getPlayerCivAdjective, COMDAT
; _this$ = ecx

; 340  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 341  : 	if(iPlayer >= 0 && iPlayer < (int)m_listPlayerInfo.size())

	cmp	DWORD PTR _iPlayer$[ebp], 0
	jl	SHORT $LN1@getPlayerC@4
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 144				; 00000090H
	mov	DWORD PTR $T235822[ebp], eax
	mov	ecx, DWORD PTR $T235822[ebp]
	mov	edx, DWORD PTR $T235822[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 7
	cmp	DWORD PTR _iPlayer$[ebp], eax
	jge	SHORT $LN1@getPlayerC@4

; 342  : 	{
; 343  : 		return m_listPlayerInfo[iPlayer].m_strCustomCivilizationAdjective;

	mov	ecx, DWORD PTR _iPlayer$[ebp]
	shl	ecx, 7
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+148]
	mov	DWORD PTR $T235826[ebp], ecx
	mov	ecx, DWORD PTR $T235826[ebp]
	add	ecx, 100				; 00000064H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	jmp	SHORT $LN2@getPlayerC@4
$LN1@getPlayerC@4:

; 344  : 	}
; 345  : 
; 346  : 	return NULL;

	xor	eax, eax
$LN2@getPlayerC@4:

; 347  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getPlayerCivAdjective@CvReplayInfo@@QBEPBDH@Z ENDP	; CvReplayInfo::getPlayerCivAdjective
_TEXT	ENDS
PUBLIC	?getMapScriptName@CvReplayInfo@@QBEABVCvString@@XZ ; CvReplayInfo::getMapScriptName
; Function compile flags: /Odtp
;	COMDAT ?getMapScriptName@CvReplayInfo@@QBEABVCvString@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getMapScriptName@CvReplayInfo@@QBEABVCvString@@XZ PROC	; CvReplayInfo::getMapScriptName, COMDAT
; _this$ = ecx

; 350  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 351  : 	return m_strMapScriptName;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8

; 352  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getMapScriptName@CvReplayInfo@@QBEABVCvString@@XZ ENDP	; CvReplayInfo::getMapScriptName
_TEXT	ENDS
PUBLIC	?getWorldSize@CvReplayInfo@@QBE?AW4WorldSizeTypes@@XZ ; CvReplayInfo::getWorldSize
; Function compile flags: /Odtp
;	COMDAT ?getWorldSize@CvReplayInfo@@QBE?AW4WorldSizeTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getWorldSize@CvReplayInfo@@QBE?AW4WorldSizeTypes@@XZ PROC ; CvReplayInfo::getWorldSize, COMDAT
; _this$ = ecx

; 355  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 356  : 	return m_eWorldSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+36]

; 357  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getWorldSize@CvReplayInfo@@QBE?AW4WorldSizeTypes@@XZ ENDP ; CvReplayInfo::getWorldSize
_TEXT	ENDS
PUBLIC	?getClimate@CvReplayInfo@@QBE?AW4ClimateTypes@@XZ ; CvReplayInfo::getClimate
; Function compile flags: /Odtp
;	COMDAT ?getClimate@CvReplayInfo@@QBE?AW4ClimateTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getClimate@CvReplayInfo@@QBE?AW4ClimateTypes@@XZ PROC	; CvReplayInfo::getClimate, COMDAT
; _this$ = ecx

; 360  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 361  : 	return m_eClimate;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+40]

; 362  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getClimate@CvReplayInfo@@QBE?AW4ClimateTypes@@XZ ENDP	; CvReplayInfo::getClimate
_TEXT	ENDS
PUBLIC	?getSeaLevel@CvReplayInfo@@QBE?AW4SeaLevelTypes@@XZ ; CvReplayInfo::getSeaLevel
; Function compile flags: /Odtp
;	COMDAT ?getSeaLevel@CvReplayInfo@@QBE?AW4SeaLevelTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getSeaLevel@CvReplayInfo@@QBE?AW4SeaLevelTypes@@XZ PROC ; CvReplayInfo::getSeaLevel, COMDAT
; _this$ = ecx

; 365  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 366  : 	return m_eSeaLevel;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+44]

; 367  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getSeaLevel@CvReplayInfo@@QBE?AW4SeaLevelTypes@@XZ ENDP ; CvReplayInfo::getSeaLevel
_TEXT	ENDS
PUBLIC	?getEra@CvReplayInfo@@QBE?AW4EraTypes@@XZ	; CvReplayInfo::getEra
; Function compile flags: /Odtp
;	COMDAT ?getEra@CvReplayInfo@@QBE?AW4EraTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getEra@CvReplayInfo@@QBE?AW4EraTypes@@XZ PROC		; CvReplayInfo::getEra, COMDAT
; _this$ = ecx

; 370  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 371  : 	return m_eEra;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+48]

; 372  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getEra@CvReplayInfo@@QBE?AW4EraTypes@@XZ ENDP		; CvReplayInfo::getEra
_TEXT	ENDS
PUBLIC	?getGameSpeed@CvReplayInfo@@QBE?AW4GameSpeedTypes@@XZ ; CvReplayInfo::getGameSpeed
; Function compile flags: /Odtp
;	COMDAT ?getGameSpeed@CvReplayInfo@@QBE?AW4GameSpeedTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getGameSpeed@CvReplayInfo@@QBE?AW4GameSpeedTypes@@XZ PROC ; CvReplayInfo::getGameSpeed, COMDAT
; _this$ = ecx

; 375  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 376  : 	return m_eGameSpeed;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+52]

; 377  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getGameSpeed@CvReplayInfo@@QBE?AW4GameSpeedTypes@@XZ ENDP ; CvReplayInfo::getGameSpeed
_TEXT	ENDS
PUBLIC	?isGameOption@CvReplayInfo@@QBE_NW4GameOptionTypes@@@Z ; CvReplayInfo::isGameOption
; Function compile flags: /Odtp
;	COMDAT ?isGameOption@CvReplayInfo@@QBE_NW4GameOptionTypes@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T235847 = -8						; size = 4
_i$220605 = -4						; size = 4
_eOption$ = 8						; size = 4
?isGameOption@CvReplayInfo@@QBE_NW4GameOptionTypes@@@Z PROC ; CvReplayInfo::isGameOption, COMDAT
; _this$ = ecx

; 380  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 381  : 	for(uint i = 0; i < m_listGameOptions.size(); i++)

	mov	DWORD PTR _i$220605[ebp], 0
	jmp	SHORT $LN4@isGameOpti
$LN3@isGameOpti:
	mov	eax, DWORD PTR _i$220605[ebp]
	add	eax, 1
	mov	DWORD PTR _i$220605[ebp], eax
$LN4@isGameOpti:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	mov	DWORD PTR $T235847[ebp], ecx
	mov	edx, DWORD PTR $T235847[ebp]
	mov	eax, DWORD PTR $T235847[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	cmp	DWORD PTR _i$220605[ebp], ecx
	jae	SHORT $LN2@isGameOpti

; 382  : 	{
; 383  : 		if(m_listGameOptions[i] == eOption)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	ecx, DWORD PTR _i$220605[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	cmp	edx, DWORD PTR _eOption$[ebp]
	jne	SHORT $LN1@isGameOpti

; 384  : 		{
; 385  : 			return true;

	mov	al, 1
	jmp	SHORT $LN5@isGameOpti
$LN1@isGameOpti:

; 386  : 		}
; 387  : 	}

	jmp	SHORT $LN3@isGameOpti
$LN2@isGameOpti:

; 388  : 	return false;

	xor	al, al
$LN5@isGameOpti:

; 389  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isGameOption@CvReplayInfo@@QBE_NW4GameOptionTypes@@@Z ENDP ; CvReplayInfo::isGameOption
_TEXT	ENDS
PUBLIC	?isVictoryCondition@CvReplayInfo@@QBE_NW4VictoryTypes@@@Z ; CvReplayInfo::isVictoryCondition
; Function compile flags: /Odtp
;	COMDAT ?isVictoryCondition@CvReplayInfo@@QBE_NW4VictoryTypes@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T235856 = -8						; size = 4
_i$220614 = -4						; size = 4
_eVictory$ = 8						; size = 4
?isVictoryCondition@CvReplayInfo@@QBE_NW4VictoryTypes@@@Z PROC ; CvReplayInfo::isVictoryCondition, COMDAT
; _this$ = ecx

; 392  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 393  : 	for(uint i = 0; i < m_listVictoryTypes.size(); i++)

	mov	DWORD PTR _i$220614[ebp], 0
	jmp	SHORT $LN4@isVictoryC
$LN3@isVictoryC:
	mov	eax, DWORD PTR _i$220614[ebp]
	add	eax, 1
	mov	DWORD PTR _i$220614[ebp], eax
$LN4@isVictoryC:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	mov	DWORD PTR $T235856[ebp], ecx
	mov	edx, DWORD PTR $T235856[ebp]
	mov	eax, DWORD PTR $T235856[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	cmp	DWORD PTR _i$220614[ebp], ecx
	jae	SHORT $LN2@isVictoryC

; 394  : 	{
; 395  : 		if(m_listVictoryTypes[i] == eVictory)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	ecx, DWORD PTR _i$220614[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	cmp	edx, DWORD PTR _eVictory$[ebp]
	jne	SHORT $LN1@isVictoryC

; 396  : 		{
; 397  : 			return true;

	mov	al, 1
	jmp	SHORT $LN5@isVictoryC
$LN1@isVictoryC:

; 398  : 		}
; 399  : 	}

	jmp	SHORT $LN3@isVictoryC
$LN2@isVictoryC:

; 400  : 	return false;

	xor	al, al
$LN5@isVictoryC:

; 401  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isVictoryCondition@CvReplayInfo@@QBE_NW4VictoryTypes@@@Z ENDP ; CvReplayInfo::isVictoryCondition
_TEXT	ENDS
PUBLIC	?getVictoryType@CvReplayInfo@@QBE?AW4VictoryTypes@@XZ ; CvReplayInfo::getVictoryType
; Function compile flags: /Odtp
;	COMDAT ?getVictoryType@CvReplayInfo@@QBE?AW4VictoryTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getVictoryType@CvReplayInfo@@QBE?AW4VictoryTypes@@XZ PROC ; CvReplayInfo::getVictoryType, COMDAT
; _this$ = ecx

; 404  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 405  : 	return m_eVictoryType;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+88]

; 406  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getVictoryType@CvReplayInfo@@QBE?AW4VictoryTypes@@XZ ENDP ; CvReplayInfo::getVictoryType
_TEXT	ENDS
PUBLIC	?getGameType@CvReplayInfo@@QBE?AW4GameTypes@@XZ	; CvReplayInfo::getGameType
; Function compile flags: /Odtp
;	COMDAT ?getGameType@CvReplayInfo@@QBE?AW4GameTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getGameType@CvReplayInfo@@QBE?AW4GameTypes@@XZ PROC	; CvReplayInfo::getGameType, COMDAT
; _this$ = ecx

; 409  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 410  : 	return m_eGameType;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+92]

; 411  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getGameType@CvReplayInfo@@QBE?AW4GameTypes@@XZ ENDP	; CvReplayInfo::getGameType
_TEXT	ENDS
PUBLIC	?addReplayMessage@CvReplayInfo@@QAEXABVCvReplayMessage@@@Z ; CvReplayInfo::addReplayMessage
; Function compile flags: /Odtp
;	COMDAT ?addReplayMessage@CvReplayInfo@@QAEXABVCvReplayMessage@@@Z
_TEXT	SEGMENT
_this$ = -60						; size = 4
_pMessage$ = 8						; size = 4
?addReplayMessage@CvReplayInfo@@QAEXABVCvReplayMessage@@@Z PROC ; CvReplayInfo::addReplayMessage, COMDAT
; _this$ = ecx

; 414  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	DWORD PTR _this$[ebp], ecx

; 415  : 	m_listReplayMessages.push_back(pMessage);

	mov	eax, DWORD PTR _pMessage$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 160				; 000000a0H
	call	?push_back@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXABVCvReplayMessage@@@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::push_back

; 416  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?addReplayMessage@CvReplayInfo@@QAEXABVCvReplayMessage@@@Z ENDP ; CvReplayInfo::addReplayMessage
_TEXT	ENDS
PUBLIC	?clearReplayMessageMap@CvReplayInfo@@QAEXXZ	; CvReplayInfo::clearReplayMessageMap
; Function compile flags: /Odtp
;	COMDAT ?clearReplayMessageMap@CvReplayInfo@@QAEXXZ
_TEXT	SEGMENT
_this$ = -108						; size = 4
$T236188 = -104						; size = 4
$T236015 = -28						; size = 4
$T235999 = -24						; size = 4
$T236175 = -20						; size = 4
$T236174 = -16						; size = 4
$T236173 = -12						; size = 4
$T236172 = -8						; size = 4
$T236171 = -4						; size = 4
?clearReplayMessageMap@CvReplayInfo@@QAEXXZ PROC	; CvReplayInfo::clearReplayMessageMap, COMDAT
; _this$ = ecx

; 419  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	DWORD PTR _this$[ebp], ecx

; 420  : 	m_listReplayMessages.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 160				; 000000a0H
	mov	DWORD PTR $T236188[ebp], eax
	mov	ecx, DWORD PTR $T236188[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T235999[ebp], edx
	mov	eax, DWORD PTR $T235999[ebp]
	mov	DWORD PTR $T236172[ebp], eax
	mov	ecx, DWORD PTR $T236172[ebp]
	mov	DWORD PTR $T236171[ebp], ecx
	mov	edx, DWORD PTR $T236188[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T236015[ebp], eax
	mov	ecx, DWORD PTR $T236015[ebp]
	mov	DWORD PTR $T236174[ebp], ecx
	mov	edx, DWORD PTR $T236174[ebp]
	mov	DWORD PTR $T236173[ebp], edx
	mov	eax, DWORD PTR $T236171[ebp]
	push	eax
	mov	ecx, DWORD PTR $T236173[ebp]
	push	ecx
	lea	edx, DWORD PTR $T236175[ebp]
	push	edx
	mov	ecx, DWORD PTR $T236188[ebp]
	call	?erase@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@V?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@0@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::erase

; 421  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?clearReplayMessageMap@CvReplayInfo@@QAEXXZ ENDP	; CvReplayInfo::clearReplayMessageMap
_TEXT	ENDS
PUBLIC	?getNumReplayMessages@CvReplayInfo@@QBEIXZ	; CvReplayInfo::getNumReplayMessages
; Function compile flags: /Odtp
;	COMDAT ?getNumReplayMessages@CvReplayInfo@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T236194 = -4						; size = 4
?getNumReplayMessages@CvReplayInfo@@QBEIXZ PROC		; CvReplayInfo::getNumReplayMessages, COMDAT
; _this$ = ecx

; 424  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 425  : 	return m_listReplayMessages.size();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 160				; 000000a0H
	mov	DWORD PTR $T236194[ebp], eax
	mov	ecx, DWORD PTR $T236194[ebp]
	mov	edx, DWORD PTR $T236194[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 60					; 0000003cH
	idiv	ecx

; 426  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getNumReplayMessages@CvReplayInfo@@QBEIXZ ENDP		; CvReplayInfo::getNumReplayMessages
_TEXT	ENDS
PUBLIC	?getReplayMessage@CvReplayInfo@@QBEPBVCvReplayMessage@@I@Z ; CvReplayInfo::getReplayMessage
; Function compile flags: /Odtp
;	COMDAT ?getReplayMessage@CvReplayInfo@@QBEPBVCvReplayMessage@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T236200 = -4						; size = 4
_i$ = 8							; size = 4
?getReplayMessage@CvReplayInfo@@QBEPBVCvReplayMessage@@I@Z PROC ; CvReplayInfo::getReplayMessage, COMDAT
; _this$ = ecx

; 429  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 430  : 	if(i < m_listReplayMessages.size())

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 160				; 000000a0H
	mov	DWORD PTR $T236200[ebp], eax
	mov	ecx, DWORD PTR $T236200[ebp]
	mov	edx, DWORD PTR $T236200[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 60					; 0000003cH
	idiv	ecx
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN1@getReplayM

; 431  : 	{
; 432  : 		return &(m_listReplayMessages[i]);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 60					; 0000003cH
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx+164]
	jmp	SHORT $LN2@getReplayM
$LN1@getReplayM:

; 433  : 	}
; 434  : 
; 435  : 	return NULL;

	xor	eax, eax
$LN2@getReplayM:

; 436  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getReplayMessage@CvReplayInfo@@QBEPBVCvReplayMessage@@I@Z ENDP ; CvReplayInfo::getReplayMessage
_TEXT	ENDS
PUBLIC	?getInitialTurn@CvReplayInfo@@QBEHXZ		; CvReplayInfo::getInitialTurn
; Function compile flags: /Odtp
;	COMDAT ?getInitialTurn@CvReplayInfo@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getInitialTurn@CvReplayInfo@@QBEHXZ PROC		; CvReplayInfo::getInitialTurn, COMDAT
; _this$ = ecx

; 439  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 440  : 	return m_iInitialTurn;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+96]

; 441  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getInitialTurn@CvReplayInfo@@QBEHXZ ENDP		; CvReplayInfo::getInitialTurn
_TEXT	ENDS
PUBLIC	?getStartYear@CvReplayInfo@@QBEHXZ		; CvReplayInfo::getStartYear
; Function compile flags: /Odtp
;	COMDAT ?getStartYear@CvReplayInfo@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getStartYear@CvReplayInfo@@QBEHXZ PROC			; CvReplayInfo::getStartYear, COMDAT
; _this$ = ecx

; 444  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 445  : 	return m_iStartYear;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+104]

; 446  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getStartYear@CvReplayInfo@@QBEHXZ ENDP			; CvReplayInfo::getStartYear
_TEXT	ENDS
PUBLIC	?getFinalTurn@CvReplayInfo@@QBEHXZ		; CvReplayInfo::getFinalTurn
; Function compile flags: /Odtp
;	COMDAT ?getFinalTurn@CvReplayInfo@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getFinalTurn@CvReplayInfo@@QBEHXZ PROC			; CvReplayInfo::getFinalTurn, COMDAT
; _this$ = ecx

; 449  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 450  : 	return m_iFinalTurn;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+100]

; 451  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getFinalTurn@CvReplayInfo@@QBEHXZ ENDP			; CvReplayInfo::getFinalTurn
_TEXT	ENDS
PUBLIC	?getFinalDate@CvReplayInfo@@QBEPBDXZ		; CvReplayInfo::getFinalDate
; Function compile flags: /Odtp
;	COMDAT ?getFinalDate@CvReplayInfo@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getFinalDate@CvReplayInfo@@QBEPBDXZ PROC		; CvReplayInfo::getFinalDate, COMDAT
; _this$ = ecx

; 454  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 455  : 	return m_strFinalDate;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 108				; 0000006cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 456  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getFinalDate@CvReplayInfo@@QBEPBDXZ ENDP		; CvReplayInfo::getFinalDate
_TEXT	ENDS
PUBLIC	?getCalendar@CvReplayInfo@@QBE?AW4CalendarTypes@@XZ ; CvReplayInfo::getCalendar
; Function compile flags: /Odtp
;	COMDAT ?getCalendar@CvReplayInfo@@QBE?AW4CalendarTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCalendar@CvReplayInfo@@QBE?AW4CalendarTypes@@XZ PROC ; CvReplayInfo::getCalendar, COMDAT
; _this$ = ecx

; 459  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 460  : 	return m_eCalendar;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+136]

; 461  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getCalendar@CvReplayInfo@@QBE?AW4CalendarTypes@@XZ ENDP ; CvReplayInfo::getCalendar
_TEXT	ENDS
PUBLIC	?getNumPlayerDataSets@CvReplayInfo@@QBEIXZ	; CvReplayInfo::getNumPlayerDataSets
; Function compile flags: /Odtp
;	COMDAT ?getNumPlayerDataSets@CvReplayInfo@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T236222 = -4						; size = 4
?getNumPlayerDataSets@CvReplayInfo@@QBEIXZ PROC		; CvReplayInfo::getNumPlayerDataSets, COMDAT
; _this$ = ecx

; 464  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 465  : 	return m_dataSetMap.size();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 176				; 000000b0H
	mov	DWORD PTR $T236222[ebp], eax
	mov	ecx, DWORD PTR $T236222[ebp]
	mov	edx, DWORD PTR $T236222[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx

; 466  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getNumPlayerDataSets@CvReplayInfo@@QBEIXZ ENDP		; CvReplayInfo::getNumPlayerDataSets
_TEXT	ENDS
PUBLIC	?getPlayerDataSetName@CvReplayInfo@@QBEPBDI@Z	; CvReplayInfo::getPlayerDataSetName
; Function compile flags: /Odtp
;	COMDAT ?getPlayerDataSetName@CvReplayInfo@@QBEPBDI@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T236232 = -8						; size = 4
$T236228 = -4						; size = 4
_idx$ = 8						; size = 4
?getPlayerDataSetName@CvReplayInfo@@QBEPBDI@Z PROC	; CvReplayInfo::getPlayerDataSetName, COMDAT
; _this$ = ecx

; 469  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 470  : 	if(idx < m_dataSetMap.size())

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 176				; 000000b0H
	mov	DWORD PTR $T236228[ebp], eax
	mov	ecx, DWORD PTR $T236228[ebp]
	mov	edx, DWORD PTR $T236228[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	cmp	DWORD PTR _idx$[ebp], eax
	jae	SHORT $LN1@getPlayerD@2

; 471  : 	{
; 472  : 		return m_dataSetMap[idx].c_str();

	mov	edx, DWORD PTR _idx$[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+180]
	mov	DWORD PTR $T236232[ebp], edx
	mov	ecx, DWORD PTR $T236232[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	jmp	SHORT $LN2@getPlayerD@2
$LN1@getPlayerD@2:

; 473  : 	}
; 474  : 
; 475  : 	return NULL;

	xor	eax, eax
$LN2@getPlayerD@2:

; 476  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getPlayerDataSetName@CvReplayInfo@@QBEPBDI@Z ENDP	; CvReplayInfo::getPlayerDataSetName
_TEXT	ENDS
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::find
PUBLIC	?getPlayerDataSetValue@CvReplayInfo@@QBE_NIIIAAH@Z ; CvReplayInfo::getPlayerDataSetValue
; Function compile flags: /Odtp
;	COMDAT ?getPlayerDataSetValue@CvReplayInfo@@QBE_NIIIAAH@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
$T236311 = -64						; size = 4
$T236247 = -28						; size = 4
$T236243 = -24						; size = 4
$T236239 = -20						; size = 4
$T236235 = -16						; size = 4
_data$220672 = -12					; size = 4
_it$220673 = -8						; size = 4
_uiAdjustedTurn$ = -4					; size = 4
_uiPlayer$ = 8						; size = 4
_uiDataSet$ = 12					; size = 4
_iTurn$ = 16						; size = 4
_outValue$ = 20						; size = 4
?getPlayerDataSetValue@CvReplayInfo@@QBE_NIIIAAH@Z PROC	; CvReplayInfo::getPlayerDataSetValue, COMDAT
; _this$ = ecx

; 479  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 480  : 	const unsigned int uiAdjustedTurn = iTurn - m_iInitialTurn;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iTurn$[ebp]
	sub	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR _uiAdjustedTurn$[ebp], ecx

; 481  : 	if(uiPlayer < m_listPlayerInfo.size() && uiDataSet < m_dataSetMap.size())

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 144				; 00000090H
	mov	DWORD PTR $T236239[ebp], edx
	mov	eax, DWORD PTR $T236239[ebp]
	mov	ecx, DWORD PTR $T236239[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 7
	cmp	DWORD PTR _uiPlayer$[ebp], edx
	jae	$LN2@getPlayerD@3
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 176				; 000000b0H
	mov	DWORD PTR $T236243[ebp], eax
	mov	ecx, DWORD PTR $T236243[ebp]
	mov	edx, DWORD PTR $T236243[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	cmp	DWORD PTR _uiDataSet$[ebp], eax
	jae	SHORT $LN2@getPlayerD@3

; 482  : 	{
; 483  : 		const TurnData& data = m_listPlayerDataSets[uiPlayer][uiDataSet];

	mov	edx, DWORD PTR _uiPlayer$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+196]
	mov	DWORD PTR $T236247[ebp], edx
	mov	ecx, DWORD PTR _uiDataSet$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR $T236247[ebp]
	add	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _data$220672[ebp], ecx

; 484  : 		TurnData::const_iterator it = data.find(uiAdjustedTurn);

	lea	eax, DWORD PTR _uiAdjustedTurn$[ebp]
	push	eax
	lea	ecx, DWORD PTR _it$220673[ebp]
	push	ecx
	mov	ecx, DWORD PTR _data$220672[ebp]
	call	?find@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::find

; 485  : 		if(it != data.end())

	mov	edx, DWORD PTR _data$220672[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T236311[ebp], eax
	mov	ecx, DWORD PTR $T236311[ebp]
	mov	DWORD PTR $T236235[ebp], ecx
	mov	edx, DWORD PTR _it$220673[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T236235[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@getPlayerD@3

; 486  : 		{
; 487  : 			outValue = (*it).second;

	mov	eax, DWORD PTR _outValue$[ebp]
	mov	ecx, DWORD PTR _it$220673[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax], edx

; 488  : 			return true;

	mov	al, 1
	jmp	SHORT $LN3@getPlayerD@3
$LN2@getPlayerD@3:

; 489  : 		}
; 490  : 	}
; 491  : 
; 492  : 	return false;

	xor	al, al
$LN3@getPlayerD@3:

; 493  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?getPlayerDataSetValue@CvReplayInfo@@QBE_NIIIAAH@Z ENDP	; CvReplayInfo::getPlayerDataSetValue
_TEXT	ENDS
PUBLIC	?getNormalizedScore@CvReplayInfo@@QBEHXZ	; CvReplayInfo::getNormalizedScore
; Function compile flags: /Odtp
;	COMDAT ?getNormalizedScore@CvReplayInfo@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getNormalizedScore@CvReplayInfo@@QBEHXZ PROC		; CvReplayInfo::getNormalizedScore, COMDAT
; _this$ = ecx

; 496  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 	return m_iNormalizedScore;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+140]

; 498  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getNormalizedScore@CvReplayInfo@@QBEHXZ ENDP		; CvReplayInfo::getNormalizedScore
_TEXT	ENDS
PUBLIC	?getMapHeight@CvReplayInfo@@QBEHXZ		; CvReplayInfo::getMapHeight
; Function compile flags: /Odtp
;	COMDAT ?getMapHeight@CvReplayInfo@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getMapHeight@CvReplayInfo@@QBEHXZ PROC			; CvReplayInfo::getMapHeight, COMDAT
; _this$ = ecx

; 501  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 502  : 	return m_iMapHeight;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+208]

; 503  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getMapHeight@CvReplayInfo@@QBEHXZ ENDP			; CvReplayInfo::getMapHeight
_TEXT	ENDS
PUBLIC	?getMapWidth@CvReplayInfo@@QBEHXZ		; CvReplayInfo::getMapWidth
; Function compile flags: /Odtp
;	COMDAT ?getMapWidth@CvReplayInfo@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getMapWidth@CvReplayInfo@@QBEHXZ PROC			; CvReplayInfo::getMapWidth, COMDAT
; _this$ = ecx

; 506  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 507  : 	return m_iMapWidth;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+212]

; 508  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getMapWidth@CvReplayInfo@@QBEHXZ ENDP			; CvReplayInfo::getMapWidth
_TEXT	ENDS
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::find
PUBLIC	?getPlotState@CvReplayInfo@@QBE_NIIIAAUPlotState@1@@Z ; CvReplayInfo::getPlotState
; Function compile flags: /Odtp
;	COMDAT ?getPlotState@CvReplayInfo@@QBE_NIIIAAUPlotState@1@@Z
_TEXT	SEGMENT
_this$ = -60						; size = 4
$T236408 = -56						; size = 4
$T236344 = -20						; size = 4
$T236340 = -16						; size = 4
_match$220770 = -12					; size = 4
_plotStatePerTurn$220695 = -8				; size = 4
_idx$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_uiTurn$ = 16						; size = 4
_plotState$ = 20					; size = 4
?getPlotState@CvReplayInfo@@QBE_NIIIAAUPlotState@1@@Z PROC ; CvReplayInfo::getPlotState, COMDAT
; _this$ = ecx

; 511  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	DWORD PTR _this$[ebp], ecx

; 512  : 	size_t idx = x + y * m_iMapWidth;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _y$[ebp]
	imul	ecx, DWORD PTR [eax+212]
	add	ecx, DWORD PTR _x$[ebp]
	mov	DWORD PTR _idx$[ebp], ecx

; 513  : 	if(idx < m_listPlots.size())

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 216				; 000000d8H
	mov	DWORD PTR $T236344[ebp], edx
	mov	eax, DWORD PTR $T236344[ebp]
	mov	ecx, DWORD PTR $T236344[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	cmp	DWORD PTR _idx$[ebp], eax
	jae	SHORT $LN2@getPlotSta

; 514  : 	{
; 515  : 		const PlotStatePerTurn& plotStatePerTurn = m_listPlots[idx];

	mov	edx, DWORD PTR _idx$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+220]
	mov	DWORD PTR _plotStatePerTurn$220695[ebp], edx

; 516  : 		PlotStatePerTurn::const_iterator match = plotStatePerTurn.find(uiTurn);

	lea	ecx, DWORD PTR _uiTurn$[ebp]
	push	ecx
	lea	edx, DWORD PTR _match$220770[ebp]
	push	edx
	mov	ecx, DWORD PTR _plotStatePerTurn$220695[ebp]
	call	?find@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::find

; 517  : 		if(match != plotStatePerTurn.end())

	mov	eax, DWORD PTR _plotStatePerTurn$220695[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T236408[ebp], ecx
	mov	edx, DWORD PTR $T236408[ebp]
	mov	DWORD PTR $T236340[ebp], edx
	mov	eax, DWORD PTR _match$220770[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T236340[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN2@getPlotSta

; 518  : 		{
; 519  : 			plotState = (*match).second;

	mov	ecx, DWORD PTR _match$220770[ebp]
	add	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _plotState$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx

; 520  : 			return true;

	mov	al, 1
	jmp	SHORT $LN3@getPlotSta
$LN2@getPlotSta:

; 521  : 		}
; 522  : 	}
; 523  : 
; 524  : 	return false;

	xor	al, al
$LN3@getPlotSta:

; 525  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?getPlotState@CvReplayInfo@@QBE_NIIIAAUPlotState@1@@Z ENDP ; CvReplayInfo::getPlotState
_TEXT	ENDS
PUBLIC	??$?5V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z ; operator>><std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >
PUBLIC	??$?5V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z ; operator>><std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >
PUBLIC	??$?5V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ; operator>><std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$?5UPlayerInfo@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@AAV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z ; operator>><CvReplayInfo::PlayerInfo>
PUBLIC	??$?5W4VictoryTypes@@@@YAAAVFDataStream@@AAV0@AAV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@Z ; operator>><enum VictoryTypes>
PUBLIC	??$?5W4GameOptionTypes@@@@YAAAVFDataStream@@AAV0@AAV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@Z ; operator>><enum GameOptionTypes>
PUBLIC	__$ArrayPad$
PUBLIC	?read@CvReplayInfo@@QAE_NAAVFDataStream@@@Z	; CvReplayInfo::read
EXTRN	?read@CvReplayMessage@@QAEXAAVFDataStream@@I@Z:PROC ; CvReplayMessage::read
EXTRN	??0CvReplayMessage@@QAE@XZ:PROC			; CvReplayMessage::CvReplayMessage
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4CalendarTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4GameTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4VictoryTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4GameSpeedTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4EraTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4SeaLevelTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4ClimateTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4WorldSizeTypes@@@Z:PROC ; operator>>
EXTRN	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; FDataStream::Read
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fdatastream.h
xdata$x	SEGMENT
__unwindtable$?read@CvReplayInfo@@QAE_NAAVFDataStream@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?read@CvReplayInfo@@QAE_NAAVFDataStream@@@Z$0
__ehfuncinfo$?read@CvReplayInfo@@QAE_NAAVFDataStream@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?read@CvReplayInfo@@QAE_NAAVFDataStream@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvreplayinfo.cpp
xdata$x	ENDS
;	COMDAT ?read@CvReplayInfo@@QAE_NAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -244						; size = 4
$T236647 = -184						; size = 4
$T236494 = -124						; size = 4
$T236478 = -120						; size = 4
$T236634 = -116						; size = 4
$T236633 = -112						; size = 4
$T236632 = -108						; size = 4
$T236631 = -104						; size = 4
$T236630 = -100						; size = 4
_message$220894 = -96					; size = 60
__$ArrayPad$ = -36					; size = 4
_ui$220890 = -32					; size = 4
_uiReplayMessageVersion$ = -28				; size = 4
_iVersion$ = -24					; size = 4
_bSuccess$ = -17					; size = 1
_uiReplayMessageCount$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
_kStream$ = 8						; size = 4
?read@CvReplayInfo@@QAE_NAAVFDataStream@@@Z PROC	; CvReplayInfo::read, COMDAT
; _this$ = ecx

; 528  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?read@CvReplayInfo@@QAE_NAAVFDataStream@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 529  : 	bool bSuccess = true;

	mov	BYTE PTR _bSuccess$[ebp], 1

; 530  : 
; 531  : 	int iVersion;
; 532  : 	kStream >> iVersion;

	lea	eax, DWORD PTR _iVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 533  : 
; 534  : 	kStream >> m_iActivePlayer;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 535  : 	kStream >> m_strMapScriptName;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read

; 536  : 	kStream >> m_eWorldSize;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 36					; 00000024H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??5@YAAAVFDataStream@@AAV0@AAW4WorldSizeTypes@@@Z ; operator>>
	add	esp, 8

; 537  : 	kStream >> m_eClimate;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??5@YAAAVFDataStream@@AAV0@AAW4ClimateTypes@@@Z ; operator>>
	add	esp, 8

; 538  : 	kStream >> m_eSeaLevel;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??5@YAAAVFDataStream@@AAV0@AAW4SeaLevelTypes@@@Z ; operator>>
	add	esp, 8

; 539  : 	kStream >> m_eEra;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??5@YAAAVFDataStream@@AAV0@AAW4EraTypes@@@Z ; operator>>
	add	esp, 8

; 540  : 	kStream >> m_eGameSpeed;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 52					; 00000034H
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??5@YAAAVFDataStream@@AAV0@AAW4GameSpeedTypes@@@Z ; operator>>
	add	esp, 8

; 541  : 	kStream >> m_listGameOptions;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$?5W4GameOptionTypes@@@@YAAAVFDataStream@@AAV0@AAV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@Z ; operator>><enum GameOptionTypes>
	add	esp, 8

; 542  : 	kStream >> m_listVictoryTypes;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 72					; 00000048H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?5W4VictoryTypes@@@@YAAAVFDataStream@@AAV0@AAV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@Z ; operator>><enum VictoryTypes>
	add	esp, 8

; 543  : 	kStream >> m_eVictoryType;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 88					; 00000058H
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??5@YAAAVFDataStream@@AAV0@AAW4VictoryTypes@@@Z ; operator>>
	add	esp, 8

; 544  : 	kStream >> m_eGameType;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??5@YAAAVFDataStream@@AAV0@AAW4GameTypes@@@Z ; operator>>
	add	esp, 8

; 545  : 	kStream >> m_iInitialTurn;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 96					; 00000060H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 546  : 	kStream >> m_iStartYear;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 104				; 00000068H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 547  : 	kStream >> m_iFinalTurn;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 100				; 00000064H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 548  : 	kStream >> m_strFinalDate;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 108				; 0000006cH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read

; 549  : 	kStream >> m_eCalendar;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 136				; 00000088H
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??5@YAAAVFDataStream@@AAV0@AAW4CalendarTypes@@@Z ; operator>>
	add	esp, 8

; 550  : 	kStream >> m_iNormalizedScore;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 140				; 0000008cH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 551  : 
; 552  : 	kStream >> m_listPlayerInfo;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 144				; 00000090H
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$?5UPlayerInfo@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@AAV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z ; operator>><CvReplayInfo::PlayerInfo>
	add	esp, 8

; 553  : 
; 554  : 	kStream >> m_dataSetMap;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 176				; 000000b0H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?5V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ; operator>><std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	add	esp, 8

; 555  : 	kStream >> m_listPlayerDataSets;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 192				; 000000c0H
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$?5V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z ; operator>><std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >
	add	esp, 8

; 556  : 
; 557  : 	unsigned int uiReplayMessageVersion = 2;

	mov	DWORD PTR _uiReplayMessageVersion$[ebp], 2

; 558  : 	kStream >> uiReplayMessageVersion;

	lea	ecx, DWORD PTR _uiReplayMessageVersion$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 559  : 
; 560  : 	unsigned int uiReplayMessageCount = 0;

	mov	DWORD PTR _uiReplayMessageCount$[ebp], 0

; 561  : 	kStream >> uiReplayMessageCount;

	lea	edx, DWORD PTR _uiReplayMessageCount$[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 562  : 
; 563  : 	m_listReplayMessages.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 160				; 000000a0H
	mov	DWORD PTR $T236647[ebp], eax
	mov	ecx, DWORD PTR $T236647[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T236478[ebp], edx
	mov	eax, DWORD PTR $T236478[ebp]
	mov	DWORD PTR $T236631[ebp], eax
	mov	ecx, DWORD PTR $T236631[ebp]
	mov	DWORD PTR $T236630[ebp], ecx
	mov	edx, DWORD PTR $T236647[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T236494[ebp], eax
	mov	ecx, DWORD PTR $T236494[ebp]
	mov	DWORD PTR $T236633[ebp], ecx
	mov	edx, DWORD PTR $T236633[ebp]
	mov	DWORD PTR $T236632[ebp], edx
	mov	eax, DWORD PTR $T236630[ebp]
	push	eax
	mov	ecx, DWORD PTR $T236632[ebp]
	push	ecx
	lea	edx, DWORD PTR $T236634[ebp]
	push	edx
	mov	ecx, DWORD PTR $T236647[ebp]
	call	?erase@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@V?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@0@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::erase

; 564  : 	m_listReplayMessages.reserve(uiReplayMessageCount);

	mov	eax, DWORD PTR _uiReplayMessageCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 160				; 000000a0H
	call	?reserve@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXI@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::reserve

; 565  : 	for(unsigned int ui = 0; ui < uiReplayMessageCount; ++ui)

	mov	DWORD PTR _ui$220890[ebp], 0
	jmp	SHORT $LN3@read
$LN2@read:
	mov	ecx, DWORD PTR _ui$220890[ebp]
	add	ecx, 1
	mov	DWORD PTR _ui$220890[ebp], ecx
$LN3@read:
	mov	edx, DWORD PTR _ui$220890[ebp]
	cmp	edx, DWORD PTR _uiReplayMessageCount$[ebp]
	jae	SHORT $LN1@read

; 566  : 	{
; 567  : 		CvReplayMessage message;

	lea	ecx, DWORD PTR _message$220894[ebp]
	call	??0CvReplayMessage@@QAE@XZ		; CvReplayMessage::CvReplayMessage
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 568  : 		message.read(kStream, uiReplayMessageVersion);

	mov	eax, DWORD PTR _uiReplayMessageVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _message$220894[ebp]
	call	?read@CvReplayMessage@@QAEXAAVFDataStream@@I@Z ; CvReplayMessage::read

; 569  : 		m_listReplayMessages.push_back(message);

	lea	edx, DWORD PTR _message$220894[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 160				; 000000a0H
	call	?push_back@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXABVCvReplayMessage@@@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::push_back

; 570  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _message$220894[ebp]
	call	??1CvReplayMessage@@UAE@XZ		; CvReplayMessage::~CvReplayMessage
	jmp	SHORT $LN2@read
$LN1@read:

; 571  : 
; 572  : 	kStream >> m_iMapWidth;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 212				; 000000d4H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 573  : 	kStream >> m_iMapHeight;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 208				; 000000d0H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 574  : 	kStream >> m_listPlots;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 216				; 000000d8H
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$?5V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z ; operator>><std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >
	add	esp, 8

; 575  : 
; 576  : 	return bSuccess;

	mov	al, BYTE PTR _bSuccess$[ebp]

; 577  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?read@CvReplayInfo@@QAE_NAAVFDataStream@@@Z$0:
	lea	ecx, DWORD PTR _message$220894[ebp]
	jmp	??1CvReplayMessage@@UAE@XZ		; CvReplayMessage::~CvReplayMessage
__ehhandler$?read@CvReplayInfo@@QAE_NAAVFDataStream@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-236]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?read@CvReplayInfo@@QAE_NAAVFDataStream@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?read@CvReplayInfo@@QAE_NAAVFDataStream@@@Z ENDP	; CvReplayInfo::read
PUBLIC	??$?6V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z ; operator<<<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >
PUBLIC	??$?6V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z ; operator<<<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >
PUBLIC	??$?6V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ; operator<<<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$?6UPlayerInfo@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@ABV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z ; operator<<<CvReplayInfo::PlayerInfo>
PUBLIC	??$?6W4VictoryTypes@@@@YAAAVFDataStream@@AAV0@ABV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@Z ; operator<<<enum VictoryTypes>
PUBLIC	??$?6W4GameOptionTypes@@@@YAAAVFDataStream@@AAV0@ABV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@Z ; operator<<<enum GameOptionTypes>
PUBLIC	?write@CvReplayInfo@@QBEXAAVFDataStream@@@Z	; CvReplayInfo::write
EXTRN	?write@CvReplayMessage@@QBEXAAVFDataStream@@@Z:PROC ; CvReplayMessage::write
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
EXTRN	?Version@CvReplayMessage@@SAIXZ:PROC		; CvReplayMessage::Version
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4CalendarTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4GameTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4VictoryTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4GameSpeedTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4EraTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4SeaLevelTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4ClimateTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4WorldSizeTypes@@@Z:PROC ; operator<<
EXTRN	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; FDataStream::Write
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
; Function compile flags: /Odtp
;	COMDAT ?write@CvReplayInfo@@QBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T236831 = -28						; size = 4
$T236819 = -24						; size = 4
$T236811 = -20						; size = 4
$T236780 = -16						; size = 4
$T236779 = -12						; size = 4
$T236778 = -8						; size = 4
_it$221166 = -4						; size = 4
_kStream$ = 8						; size = 4
?write@CvReplayInfo@@QBEXAAVFDataStream@@@Z PROC	; CvReplayInfo::write, COMDAT
; _this$ = ecx

; 580  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 581  : 	kStream << REPLAY_VERSION;

	push	OFFSET ?REPLAY_VERSION@CvReplayInfo@@1HA ; CvReplayInfo::REPLAY_VERSION
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 582  : 	kStream << m_iActivePlayer;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 583  : 	kStream << m_strMapScriptName;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write

; 584  : 	kStream << m_eWorldSize;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 36					; 00000024H
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??6@YAAAVFDataStream@@AAV0@ABW4WorldSizeTypes@@@Z ; operator<<
	add	esp, 8

; 585  : 	kStream << m_eClimate;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??6@YAAAVFDataStream@@AAV0@ABW4ClimateTypes@@@Z ; operator<<
	add	esp, 8

; 586  : 	kStream << m_eSeaLevel;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??6@YAAAVFDataStream@@AAV0@ABW4SeaLevelTypes@@@Z ; operator<<
	add	esp, 8

; 587  : 	kStream << m_eEra;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 48					; 00000030H
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??6@YAAAVFDataStream@@AAV0@ABW4EraTypes@@@Z ; operator<<
	add	esp, 8

; 588  : 	kStream << m_eGameSpeed;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??6@YAAAVFDataStream@@AAV0@ABW4GameSpeedTypes@@@Z ; operator<<
	add	esp, 8

; 589  : 	kStream << m_listGameOptions;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 56					; 00000038H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?6W4GameOptionTypes@@@@YAAAVFDataStream@@AAV0@ABV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@Z ; operator<<<enum GameOptionTypes>
	add	esp, 8

; 590  : 	kStream << m_listVictoryTypes;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 72					; 00000048H
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$?6W4VictoryTypes@@@@YAAAVFDataStream@@AAV0@ABV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@Z ; operator<<<enum VictoryTypes>
	add	esp, 8

; 591  : 	kStream << m_eVictoryType;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??6@YAAAVFDataStream@@AAV0@ABW4VictoryTypes@@@Z ; operator<<
	add	esp, 8

; 592  : 	kStream << m_eGameType;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 92					; 0000005cH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??6@YAAAVFDataStream@@AAV0@ABW4GameTypes@@@Z ; operator<<
	add	esp, 8

; 593  : 	kStream << m_iInitialTurn;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 96					; 00000060H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 594  : 	kStream << m_iStartYear;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 104				; 00000068H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 595  : 	kStream << m_iFinalTurn;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 596  : 	kStream << m_strFinalDate;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 108				; 0000006cH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write

; 597  : 	kStream << m_eCalendar;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 136				; 00000088H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??6@YAAAVFDataStream@@AAV0@ABW4CalendarTypes@@@Z ; operator<<
	add	esp, 8

; 598  : 	kStream << m_iNormalizedScore;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 140				; 0000008cH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 599  : 
; 600  : 	kStream << m_listPlayerInfo;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 144				; 00000090H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?6UPlayerInfo@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@ABV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z ; operator<<<CvReplayInfo::PlayerInfo>
	add	esp, 8

; 601  : 	kStream << m_dataSetMap;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 176				; 000000b0H
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$?6V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ; operator<<<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	add	esp, 8

; 602  : 	kStream << m_listPlayerDataSets;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 192				; 000000c0H
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$?6V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z ; operator<<<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >
	add	esp, 8

; 603  : 
; 604  : 	kStream << CvReplayMessage::Version();

	call	?Version@CvReplayMessage@@SAIXZ		; CvReplayMessage::Version
	mov	DWORD PTR $T236778[ebp], eax
	lea	eax, DWORD PTR $T236778[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 605  : 	kStream << m_listReplayMessages.size();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 160				; 000000a0H
	mov	DWORD PTR $T236811[ebp], ecx
	mov	edx, DWORD PTR $T236811[ebp]
	mov	eax, DWORD PTR $T236811[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 60					; 0000003cH
	idiv	ecx
	mov	DWORD PTR $T236779[ebp], eax
	lea	edx, DWORD PTR $T236779[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 606  : 	for(ReplayMessageList::const_iterator it = m_listReplayMessages.begin(); it != m_listReplayMessages.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	DWORD PTR $T236819[ebp], ecx
	mov	edx, DWORD PTR $T236819[ebp]
	mov	DWORD PTR _it$221166[ebp], edx
	jmp	SHORT $LN3@write
$LN2@write:
	mov	eax, DWORD PTR _it$221166[ebp]
	add	eax, 60					; 0000003cH
	mov	DWORD PTR _it$221166[ebp], eax
$LN3@write:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+168]
	mov	DWORD PTR $T236831[ebp], edx
	mov	eax, DWORD PTR $T236831[ebp]
	mov	DWORD PTR $T236780[ebp], eax
	mov	ecx, DWORD PTR _it$221166[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T236780[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@write

; 607  : 	{
; 608  : 		(*it).write(kStream);

	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	mov	ecx, DWORD PTR _it$221166[ebp]
	call	?write@CvReplayMessage@@QBEXAAVFDataStream@@@Z ; CvReplayMessage::write

; 609  : 	}

	jmp	SHORT $LN2@write
$LN1@write:

; 610  : 
; 611  : 	kStream << m_iMapWidth;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 212				; 000000d4H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 612  : 	kStream << m_iMapHeight;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 208				; 000000d0H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 613  : 	kStream << m_listPlots;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 216				; 000000d8H
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$?6V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z ; operator<<<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >
	add	esp, 8

; 614  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?write@CvReplayInfo@@QBEXAAVFDataStream@@@Z ENDP	; CvReplayInfo::write
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABUPlayerInfo@CvReplayInfo@@@Z ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4HandicapTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4PlayerColorTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4LeaderHeadTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4CivilizationTypes@@@Z:PROC ; operator<<
; Function compile flags: /Odtp
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABUPlayerInfo@CvReplayInfo@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABUPlayerInfo@CvReplayInfo@@@Z PROC ; operator<<, COMDAT

; 617  : {

	push	ebp
	mov	ebp, esp

; 618  : 	saveTo << readFrom.m_eCivilization;

	mov	eax, DWORD PTR _readFrom$[ebp]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	push	ecx
	call	??6@YAAAVFDataStream@@AAV0@ABW4CivilizationTypes@@@Z ; operator<<
	add	esp, 8

; 619  : 	saveTo << readFrom.m_eLeader;

	mov	edx, DWORD PTR _readFrom$[ebp]
	add	edx, 4
	push	edx
	mov	eax, DWORD PTR _saveTo$[ebp]
	push	eax
	call	??6@YAAAVFDataStream@@AAV0@ABW4LeaderHeadTypes@@@Z ; operator<<
	add	esp, 8

; 620  : 	saveTo << readFrom.m_ePlayerColor;

	mov	ecx, DWORD PTR _readFrom$[ebp]
	add	ecx, 8
	push	ecx
	mov	edx, DWORD PTR _saveTo$[ebp]
	push	edx
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerColorTypes@@@Z ; operator<<
	add	esp, 8

; 621  : 	saveTo << readFrom.m_eDifficulty;

	mov	eax, DWORD PTR _readFrom$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	push	ecx
	call	??6@YAAAVFDataStream@@AAV0@ABW4HandicapTypes@@@Z ; operator<<
	add	esp, 8

; 622  : 	saveTo << readFrom.m_strCustomLeaderName;

	mov	edx, DWORD PTR _readFrom$[ebp]
	add	edx, 16					; 00000010H
	push	edx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write

; 623  : 	saveTo << readFrom.m_strCustomCivilizationName;

	mov	eax, DWORD PTR _readFrom$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write

; 624  : 	saveTo << readFrom.m_strCustomCivilizationShortName;

	mov	ecx, DWORD PTR _readFrom$[ebp]
	add	ecx, 72					; 00000048H
	push	ecx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write

; 625  : 	saveTo << readFrom.m_strCustomCivilizationAdjective;

	mov	edx, DWORD PTR _readFrom$[ebp]
	add	edx, 100				; 00000064H
	push	edx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write

; 626  : 
; 627  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 628  : }

	pop	ebp
	ret	0
??6@YAAAVFDataStream@@AAV0@ABUPlayerInfo@CvReplayInfo@@@Z ENDP ; operator<<
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAUPlayerInfo@CvReplayInfo@@@Z ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4HandicapTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4PlayerColorTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4LeaderHeadTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4CivilizationTypes@@@Z:PROC ; operator>>
; Function compile flags: /Odtp
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAUPlayerInfo@CvReplayInfo@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAUPlayerInfo@CvReplayInfo@@@Z PROC ; operator>>, COMDAT

; 631  : {

	push	ebp
	mov	ebp, esp

; 632  : 	loadFrom >> writeTo.m_eCivilization;

	mov	eax, DWORD PTR _writeTo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	push	ecx
	call	??5@YAAAVFDataStream@@AAV0@AAW4CivilizationTypes@@@Z ; operator>>
	add	esp, 8

; 633  : 	loadFrom >> writeTo.m_eLeader;

	mov	edx, DWORD PTR _writeTo$[ebp]
	add	edx, 4
	push	edx
	mov	eax, DWORD PTR _loadFrom$[ebp]
	push	eax
	call	??5@YAAAVFDataStream@@AAV0@AAW4LeaderHeadTypes@@@Z ; operator>>
	add	esp, 8

; 634  : 	loadFrom >> writeTo.m_ePlayerColor;

	mov	ecx, DWORD PTR _writeTo$[ebp]
	add	ecx, 8
	push	ecx
	mov	edx, DWORD PTR _loadFrom$[ebp]
	push	edx
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerColorTypes@@@Z ; operator>>
	add	esp, 8

; 635  : 	loadFrom >> writeTo.m_eDifficulty;

	mov	eax, DWORD PTR _writeTo$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	push	ecx
	call	??5@YAAAVFDataStream@@AAV0@AAW4HandicapTypes@@@Z ; operator>>
	add	esp, 8

; 636  : 	loadFrom >> writeTo.m_strCustomLeaderName;

	mov	edx, DWORD PTR _writeTo$[ebp]
	add	edx, 16					; 00000010H
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read

; 637  : 	loadFrom >> writeTo.m_strCustomCivilizationName;

	mov	eax, DWORD PTR _writeTo$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read

; 638  : 	loadFrom >> writeTo.m_strCustomCivilizationShortName;

	mov	ecx, DWORD PTR _writeTo$[ebp]
	add	ecx, 72					; 00000048H
	push	ecx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read

; 639  : 	loadFrom >> writeTo.m_strCustomCivilizationAdjective;

	mov	edx, DWORD PTR _writeTo$[ebp]
	add	edx, 100				; 00000064H
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read

; 640  : 
; 641  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 642  : }

	pop	ebp
	ret	0
??5@YAAAVFDataStream@@AAV0@AAUPlayerInfo@CvReplayInfo@@@Z ENDP ; operator>>
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABUOldPlotState@CvReplayInfo@@@Z ; operator<<
EXTRN	?Write@FDataStream@@IAEXABE@Z:PROC		; FDataStream::Write
; Function compile flags: /Odtp
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABUOldPlotState@CvReplayInfo@@@Z
_TEXT	SEGMENT
$T236884 = -3						; size = 1
$T236883 = -2						; size = 1
_uiRiverData$ = -1					; size = 1
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABUOldPlotState@CvReplayInfo@@@Z PROC ; operator<<, COMDAT

; 645  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 646  : 	saveTo << (unsigned char)readFrom.m_eTerrain;

	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR $T236883[ebp], cl
	lea	edx, DWORD PTR $T236883[ebp]
	push	edx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABE@Z		; FDataStream::Write

; 647  : 	saveTo << (unsigned char)readFrom.m_eFeature;

	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	cl, BYTE PTR [eax+4]
	mov	BYTE PTR $T236884[ebp], cl
	lea	edx, DWORD PTR $T236884[ebp]
	push	edx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABE@Z		; FDataStream::Write

; 648  : 
; 649  : 	unsigned char uiRiverData = 0;

	mov	BYTE PTR _uiRiverData$[ebp], 0

; 650  : 	uiRiverData |= (readFrom.m_bNWOfRiver) << 1;

	mov	eax, DWORD PTR _readFrom$[ebp]
	movzx	ecx, BYTE PTR [eax+10]
	shl	ecx, 1
	movzx	edx, BYTE PTR _uiRiverData$[ebp]
	or	edx, ecx
	mov	BYTE PTR _uiRiverData$[ebp], dl

; 651  : 	uiRiverData |= (readFrom.m_bWOfRiver) << 2;

	mov	eax, DWORD PTR _readFrom$[ebp]
	movzx	ecx, BYTE PTR [eax+9]
	shl	ecx, 2
	movzx	edx, BYTE PTR _uiRiverData$[ebp]
	or	edx, ecx
	mov	BYTE PTR _uiRiverData$[ebp], dl

; 652  : 	uiRiverData |= (readFrom.m_bNEOfRiver) << 3;

	mov	eax, DWORD PTR _readFrom$[ebp]
	movzx	ecx, BYTE PTR [eax+8]
	shl	ecx, 3
	movzx	edx, BYTE PTR _uiRiverData$[ebp]
	or	edx, ecx
	mov	BYTE PTR _uiRiverData$[ebp], dl

; 653  : 
; 654  : 	saveTo << uiRiverData;

	lea	eax, DWORD PTR _uiRiverData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABE@Z		; FDataStream::Write

; 655  : 
; 656  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 657  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??6@YAAAVFDataStream@@AAV0@ABUOldPlotState@CvReplayInfo@@@Z ENDP ; operator<<
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAUOldPlotState@CvReplayInfo@@@Z ; operator>>
EXTRN	?Read@FDataStream@@IAEXAAE@Z:PROC		; FDataStream::Read
; Function compile flags: /Odtp
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAUOldPlotState@CvReplayInfo@@@Z
_TEXT	SEGMENT
_ucTempVal$ = -1					; size = 1
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAUOldPlotState@CvReplayInfo@@@Z PROC ; operator>>, COMDAT

; 660  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 661  : 	unsigned char ucTempVal;
; 662  : 	loadFrom >> ucTempVal;

	lea	eax, DWORD PTR _ucTempVal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAE@Z		; FDataStream::Read

; 663  : 	writeTo.m_eTerrain = (TerrainTypes)ucTempVal;

	movzx	ecx, BYTE PTR _ucTempVal$[ebp]
	mov	edx, DWORD PTR _writeTo$[ebp]
	mov	DWORD PTR [edx], ecx

; 664  : 
; 665  : 	loadFrom >> ucTempVal;

	lea	eax, DWORD PTR _ucTempVal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAE@Z		; FDataStream::Read

; 666  : 	writeTo.m_eFeature = (FeatureTypes)ucTempVal;

	movzx	ecx, BYTE PTR _ucTempVal$[ebp]
	mov	edx, DWORD PTR _writeTo$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 667  : 
; 668  : 	loadFrom >> ucTempVal;

	lea	eax, DWORD PTR _ucTempVal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAE@Z		; FDataStream::Read

; 669  : 	writeTo.m_bNWOfRiver = (ucTempVal & (1 << 1)) != 0;

	movzx	ecx, BYTE PTR _ucTempVal$[ebp]
	and	ecx, 2
	neg	ecx
	sbb	ecx, ecx
	neg	ecx
	mov	edx, DWORD PTR _writeTo$[ebp]
	mov	BYTE PTR [edx+10], cl

; 670  : 	writeTo.m_bWOfRiver = (ucTempVal & (1 << 2)) != 0;

	movzx	eax, BYTE PTR _ucTempVal$[ebp]
	and	eax, 4
	neg	eax
	sbb	eax, eax
	neg	eax
	mov	ecx, DWORD PTR _writeTo$[ebp]
	mov	BYTE PTR [ecx+9], al

; 671  : 	writeTo.m_bNEOfRiver = (ucTempVal & (1 << 3)) != 0;

	movzx	edx, BYTE PTR _ucTempVal$[ebp]
	and	edx, 8
	neg	edx
	sbb	edx, edx
	neg	edx
	mov	eax, DWORD PTR _writeTo$[ebp]
	mov	BYTE PTR [eax+8], dl

; 672  : 
; 673  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 674  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??5@YAAAVFDataStream@@AAV0@AAUOldPlotState@CvReplayInfo@@@Z ENDP ; operator>>
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABUPlotState@CvReplayInfo@@@Z ; operator<<
; Function compile flags: /Odtp
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABUPlotState@CvReplayInfo@@@Z
_TEXT	SEGMENT
$T236909 = -4						; size = 1
$T236908 = -3						; size = 1
$T236907 = -2						; size = 1
_uiRiverData$ = -1					; size = 1
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABUPlotState@CvReplayInfo@@@Z PROC ; operator<<, COMDAT

; 677  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 678  : 	saveTo << (unsigned char)readFrom.m_ePlotType;

	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR $T236907[ebp], cl
	lea	edx, DWORD PTR $T236907[ebp]
	push	edx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABE@Z		; FDataStream::Write

; 679  : 	saveTo << (unsigned char)readFrom.m_eTerrain;

	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	cl, BYTE PTR [eax+4]
	mov	BYTE PTR $T236908[ebp], cl
	lea	edx, DWORD PTR $T236908[ebp]
	push	edx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABE@Z		; FDataStream::Write

; 680  : 	saveTo << (unsigned char)readFrom.m_eFeature;

	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	cl, BYTE PTR [eax+8]
	mov	BYTE PTR $T236909[ebp], cl
	lea	edx, DWORD PTR $T236909[ebp]
	push	edx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABE@Z		; FDataStream::Write

; 681  : 
; 682  : 	unsigned char uiRiverData = 0;

	mov	BYTE PTR _uiRiverData$[ebp], 0

; 683  : 	uiRiverData |= (readFrom.m_bNWOfRiver) << 1;

	mov	eax, DWORD PTR _readFrom$[ebp]
	movzx	ecx, BYTE PTR [eax+14]
	shl	ecx, 1
	movzx	edx, BYTE PTR _uiRiverData$[ebp]
	or	edx, ecx
	mov	BYTE PTR _uiRiverData$[ebp], dl

; 684  : 	uiRiverData |= (readFrom.m_bWOfRiver) << 2;

	mov	eax, DWORD PTR _readFrom$[ebp]
	movzx	ecx, BYTE PTR [eax+13]
	shl	ecx, 2
	movzx	edx, BYTE PTR _uiRiverData$[ebp]
	or	edx, ecx
	mov	BYTE PTR _uiRiverData$[ebp], dl

; 685  : 	uiRiverData |= (readFrom.m_bNEOfRiver) << 3;

	mov	eax, DWORD PTR _readFrom$[ebp]
	movzx	ecx, BYTE PTR [eax+12]
	shl	ecx, 3
	movzx	edx, BYTE PTR _uiRiverData$[ebp]
	or	edx, ecx
	mov	BYTE PTR _uiRiverData$[ebp], dl

; 686  : 
; 687  : 	saveTo << uiRiverData;

	lea	eax, DWORD PTR _uiRiverData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABE@Z		; FDataStream::Write

; 688  : 
; 689  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 690  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??6@YAAAVFDataStream@@AAV0@ABUPlotState@CvReplayInfo@@@Z ENDP ; operator<<
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAUPlotState@CvReplayInfo@@@Z ; operator>>
; Function compile flags: /Odtp
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAUPlotState@CvReplayInfo@@@Z
_TEXT	SEGMENT
_ucTempVal$ = -1					; size = 1
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAUPlotState@CvReplayInfo@@@Z PROC ; operator>>, COMDAT

; 693  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 694  : 	unsigned char ucTempVal;
; 695  : 
; 696  : 	loadFrom >> ucTempVal;

	lea	eax, DWORD PTR _ucTempVal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAE@Z		; FDataStream::Read

; 697  : 	writeTo.m_ePlotType = (PlotTypes)ucTempVal;

	movzx	ecx, BYTE PTR _ucTempVal$[ebp]
	mov	edx, DWORD PTR _writeTo$[ebp]
	mov	DWORD PTR [edx], ecx

; 698  : 
; 699  : 	loadFrom >> ucTempVal;

	lea	eax, DWORD PTR _ucTempVal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAE@Z		; FDataStream::Read

; 700  : 	writeTo.m_eTerrain = (TerrainTypes)ucTempVal;

	movzx	ecx, BYTE PTR _ucTempVal$[ebp]
	mov	edx, DWORD PTR _writeTo$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 701  : 
; 702  : 	loadFrom >> ucTempVal;

	lea	eax, DWORD PTR _ucTempVal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAE@Z		; FDataStream::Read

; 703  : 	writeTo.m_eFeature = (FeatureTypes)ucTempVal;

	movzx	ecx, BYTE PTR _ucTempVal$[ebp]
	mov	edx, DWORD PTR _writeTo$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 704  : 
; 705  : 	loadFrom >> ucTempVal;

	lea	eax, DWORD PTR _ucTempVal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAE@Z		; FDataStream::Read

; 706  : 	writeTo.m_bNWOfRiver = (ucTempVal & (1 << 1)) != 0;

	movzx	ecx, BYTE PTR _ucTempVal$[ebp]
	and	ecx, 2
	neg	ecx
	sbb	ecx, ecx
	neg	ecx
	mov	edx, DWORD PTR _writeTo$[ebp]
	mov	BYTE PTR [edx+14], cl

; 707  : 	writeTo.m_bWOfRiver = (ucTempVal & (1 << 2)) != 0;

	movzx	eax, BYTE PTR _ucTempVal$[ebp]
	and	eax, 4
	neg	eax
	sbb	eax, eax
	neg	eax
	mov	ecx, DWORD PTR _writeTo$[ebp]
	mov	BYTE PTR [ecx+13], al

; 708  : 	writeTo.m_bNEOfRiver = (ucTempVal & (1 << 3)) != 0;

	movzx	edx, BYTE PTR _ucTempVal$[ebp]
	and	edx, 8
	neg	edx
	sbb	edx, edx
	neg	edx
	mov	eax, DWORD PTR _writeTo$[ebp]
	mov	BYTE PTR [eax+12], dl

; 709  : 
; 710  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 711  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??5@YAAAVFDataStream@@AAV0@AAUPlotState@CvReplayInfo@@@Z ENDP ; operator>>
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@Z ; operator<<
; Function compile flags: /Odtp
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@Z
_TEXT	SEGMENT
$T237035 = -48						; size = 4
$T237023 = -44						; size = 4
$T236999 = -40						; size = 4
$T236959 = -24						; size = 4
$T236951 = -20						; size = 4
$T236942 = -16						; size = 4
$T236938 = -12						; size = 4
_it$221281 = -8						; size = 4
_count$ = -4						; size = 4
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@Z PROC ; operator<<, COMDAT

; 715  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 716  : 	const size_t count = readFrom.size();

	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T236942[ebp], ecx
	mov	edx, DWORD PTR $T236942[ebp]
	mov	DWORD PTR _count$[ebp], edx

; 717  : 	saveTo << count;

	lea	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 718  : 	for(CvReplayInfo::TurnData::const_iterator it = readFrom.begin(); it != readFrom.end(); ++it)

	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T236951[ebp], edx
	mov	eax, DWORD PTR $T236951[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T236959[ebp], ecx
	mov	edx, DWORD PTR $T236959[ebp]
	mov	DWORD PTR _it$221281[ebp], edx
	jmp	SHORT $LN3@operator
$LN2@operator:
	lea	ecx, DWORD PTR _it$221281[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Inc
$LN3@operator:
	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T236999[ebp], ecx
	mov	edx, DWORD PTR $T236999[ebp]
	mov	DWORD PTR $T236938[ebp], edx
	mov	eax, DWORD PTR _it$221281[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T236938[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN1@operator

; 719  : 	{
; 720  : 		saveTo << (*it).first;

	mov	ecx, DWORD PTR _it$221281[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR $T237023[ebp], ecx
	mov	edx, DWORD PTR $T237023[ebp]
	push	edx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 721  : 		saveTo << (*it).second;

	mov	eax, DWORD PTR _it$221281[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR $T237035[ebp], eax
	mov	ecx, DWORD PTR $T237035[ebp]
	push	ecx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 722  : 	}

	jmp	SHORT $LN2@operator
$LN1@operator:

; 723  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 724  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??6@YAAAVFDataStream@@AAV0@ABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@Z ENDP ; operator<<
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@Z ; operator>>
; Function compile flags: /Odtp
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@Z
_TEXT	SEGMENT
_i$221294 = -16						; size = 4
_uiSize$ = -12						; size = 4
_uiTurn$ = -8						; size = 4
_iValue$ = -4						; size = 4
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@Z PROC ; operator>>, COMDAT

; 727  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 728  : 	size_t uiSize;
; 729  : 	loadFrom >> uiSize;

	lea	eax, DWORD PTR _uiSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 730  : 
; 731  : 	unsigned int uiTurn;
; 732  : 	int iValue;
; 733  : 
; 734  : 	for(unsigned int i = 0; i < uiSize; ++i)

	mov	DWORD PTR _i$221294[ebp], 0
	jmp	SHORT $LN3@operator@2
$LN2@operator@2:
	mov	ecx, DWORD PTR _i$221294[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$221294[ebp], ecx
$LN3@operator@2:
	mov	edx, DWORD PTR _i$221294[ebp]
	cmp	edx, DWORD PTR _uiSize$[ebp]
	jae	SHORT $LN1@operator@2

; 735  : 	{
; 736  : 		loadFrom >> uiTurn;

	lea	eax, DWORD PTR _uiTurn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 737  : 		loadFrom >> iValue;

	lea	ecx, DWORD PTR _iValue$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 738  : 		writeTo[uiTurn] = iValue;

	lea	edx, DWORD PTR _uiTurn$[ebp]
	push	edx
	mov	ecx, DWORD PTR _writeTo$[ebp]
	call	??A?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAEAAHABI@Z ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::operator[]
	mov	ecx, DWORD PTR _iValue$[ebp]
	mov	DWORD PTR [eax], ecx

; 739  : 	}

	jmp	SHORT $LN2@operator@2
$LN1@operator@2:

; 740  : 
; 741  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 742  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??5@YAAAVFDataStream@@AAV0@AAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@Z ENDP ; operator>>
_TEXT	ENDS
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::insert
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lbound
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
;	COMDAT ??A?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAEAAHABI@Z
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T237205 = -48						; size = 4
$T237192 = -44						; size = 4
$T237176 = -40						; size = 4
$T237132 = -28						; size = 4
$T237131 = -24						; size = 4
$T237130 = -20						; size = 4
$T237129 = -16						; size = 8
$T237128 = -8						; size = 4
__Where$ = -4						; size = 4
__Keyval$ = 8						; size = 4
??A?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAEAAHABI@Z PROC ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::operator[], COMDAT
; _this$ = ecx

; 168  : 		{	// find element matching _Keyval or insert with default mapped

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 169  : 		iterator _Where = this->lower_bound(_Keyval);

	mov	eax, DWORD PTR __Keyval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lbound@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lbound
	mov	DWORD PTR $T237176[ebp], eax
	mov	ecx, DWORD PTR $T237176[ebp]
	mov	DWORD PTR __Where$[ebp], ecx

; 170  : 		if (_Where == this->end()
; 171  : 			|| this->comp(_Keyval, this->_Key(_Where._Mynode())))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T237192[ebp], eax
	mov	ecx, DWORD PTR $T237192[ebp]
	mov	DWORD PTR $T237128[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T237128[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@operator@3
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T237205[ebp], edx
	mov	eax, DWORD PTR __Keyval$[ebp]
	mov	ecx, DWORD PTR $T237205[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+12]
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN55@operator@3
$LN1@operator@3:

; 172  : 			_Where = this->insert(_Where,
; 173  : 				value_type(_Keyval, mapped_type()));

	mov	DWORD PTR $T237130[ebp], 0
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T237131[ebp], edx
	mov	eax, DWORD PTR __Keyval$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T237129[ebp], ecx
	mov	edx, DWORD PTR $T237130[ebp]
	mov	DWORD PTR $T237129[ebp+4], edx
	lea	eax, DWORD PTR $T237129[ebp]
	push	eax
	mov	ecx, DWORD PTR $T237131[ebp]
	push	ecx
	lea	edx, DWORD PTR $T237132[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::insert
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Where$[ebp], eax

; 174  : 		return ((*_Where).second);

$LN55@operator@3:
	mov	eax, DWORD PTR __Where$[ebp]
	add	eax, 16					; 00000010H

; 175  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAEAAHABI@Z ENDP ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::operator[]
_TEXT	ENDS
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Copy
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??4?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -124						; size = 4
$T237281 = -32						; size = 4
$T237268 = -28						; size = 4
$T237256 = -24						; size = 4
$T237246 = -20						; size = 4
$T237245 = -16						; size = 4
$T237244 = -12						; size = 4
$T237243 = -8						; size = 4
$T237242 = -4						; size = 4
__Right$ = 8						; size = 4
??4?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::operator=, COMDAT
; _this$ = ecx

; 544  : 		{	// replace contents from _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	DWORD PTR _this$[ebp], ecx

; 545  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	SHORT $LN1@operator@4

; 546  : 			{	// worth doing
; 547  : 			erase(begin(), end());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T237256[ebp], edx
	mov	eax, DWORD PTR $T237256[ebp]
	mov	DWORD PTR $T237243[ebp], eax
	mov	ecx, DWORD PTR $T237243[ebp]
	mov	DWORD PTR $T237242[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T237268[ebp], eax
	mov	ecx, DWORD PTR $T237268[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T237281[ebp], edx
	mov	eax, DWORD PTR $T237281[ebp]
	mov	DWORD PTR $T237245[ebp], eax
	mov	ecx, DWORD PTR $T237245[ebp]
	mov	DWORD PTR $T237244[ebp], ecx
	mov	edx, DWORD PTR $T237242[ebp]
	push	edx
	mov	eax, DWORD PTR $T237244[ebp]
	push	eax
	lea	ecx, DWORD PTR $T237246[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase

; 548  : 			this->comp = _Right.comp;
; 549  : 			_Copy(_Right);

	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Copy
$LN1@operator@4:

; 550  : 			}
; 551  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 552  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::operator=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABI@Z
_TEXT	SEGMENT
tv93 = -48						; size = 4
_this$ = -44						; size = 4
$T237660 = -40						; size = 4
$T237639 = -36						; size = 4
$T237628 = -32						; size = 4
$T237619 = -28						; size = 4
$T237579 = -16						; size = 4
$T237577 = -12						; size = 4
$T237576 = -8						; size = 4
__Where$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABI@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::find, COMDAT
; _this$ = ecx

; 986  : 		{	// find an element in nonmutable sequence that matches _Keyval

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 987  : 		const_iterator _Where = lower_bound(_Keyval);

	mov	eax, DWORD PTR __Keyval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lbound@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lbound
	mov	DWORD PTR $T237619[ebp], eax
	mov	ecx, DWORD PTR $T237619[ebp]
	mov	DWORD PTR __Where$[ebp], ecx

; 988  : 		return (_Where == end()
; 989  : 			|| _DEBUG_LT_PRED(this->comp,
; 990  : 				_Keyval, _Key(_Where._Mynode()))
; 991  : 					? end() : _Where);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T237628[ebp], eax
	mov	ecx, DWORD PTR $T237628[ebp]
	mov	DWORD PTR $T237577[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T237577[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@find
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T237639[ebp], edx
	mov	eax, DWORD PTR __Keyval$[ebp]
	mov	ecx, DWORD PTR $T237639[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+12]
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@find
	lea	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR tv93[ebp], edx
	jmp	SHORT $LN4@find
$LN3@find:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T237660[ebp], ecx
	mov	edx, DWORD PTR $T237660[ebp]
	mov	DWORD PTR $T237579[ebp], edx
	lea	eax, DWORD PTR $T237579[ebp]
	mov	DWORD PTR tv93[ebp], eax
$LN4@find:
	mov	ecx, DWORD PTR tv93[ebp]
	mov	DWORD PTR $T237576[ebp], ecx
	mov	edx, DWORD PTR $T237576[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 992  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?find@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABI@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::find
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE_NI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Buy
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
tv88 = -132						; size = 4
tv145 = -128						; size = 4
_this$ = -124						; size = 4
$T237696 = -30						; size = 1
$T237683 = -29						; size = 1
$T237679 = -28						; size = 4
$T237672 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T237696[ebp]
	mov	DWORD PTR $T237672[ebp], eax
	lea	ecx, DWORD PTR $T237683[ebp]
	mov	DWORD PTR $T237679[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv145[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv88[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE_NI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
__ehhandler$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -52						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
__ehhandler$??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	?insert@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::insert
PUBLIC	??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
tv129 = -64						; size = 4
_this$ = -60						; size = 4
$T237902 = -32						; size = 4
$T237892 = -28						; size = 4
$T237882 = -24						; size = 4
__Cat$237890 = -19					; size = 1
$T237888 = -18						; size = 1
$T237887 = -17						; size = 1
$T237859 = -16						; size = 4
$T237855 = -12						; size = 4
$T237854 = -8						; size = 4
$T237853 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	mov	DWORD PTR $T237859[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN9@push_back
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN7@push_back
$LN9@push_back:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	mov	DWORD PTR tv129[ebp], eax
$LN7@push_back:
	mov	edx, DWORD PTR $T237859[ebp]
	cmp	edx, DWORD PTR tv129[ebp]
	jae	SHORT $LN2@push_back

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T237892[ebp], ecx
	mov	edx, DWORD PTR $T237892[ebp]
	mov	DWORD PTR $T237882[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T237887[ebp], al
	mov	cl, BYTE PTR __Cat$237890[ebp]
	mov	BYTE PTR $T237888[ebp], cl
	movzx	edx, BYTE PTR $T237887[ebp]
	push	edx
	movzx	eax, BYTE PTR $T237888[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR $T237882[ebp]
	push	eax
	call	??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	add	esp, 24					; 00000018H
	mov	ecx, 1
	imul	ecx, 28					; 0000001cH
	add	ecx, DWORD PTR $T237892[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back
$LN2@push_back:

; 823  : 			insert(end(), _Val);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T237902[ebp], ecx
	mov	edx, DWORD PTR $T237902[ebp]
	mov	DWORD PTR $T237854[ebp], edx
	mov	eax, DWORD PTR $T237854[ebp]
	mov	DWORD PTR $T237853[ebp], eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T237853[ebp]
	push	edx
	lea	eax, DWORD PTR $T237855[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::insert
$LN3@push_back:

; 824  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -52						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE@XZ PROC ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::~vector<CvReplayMessage,std::allocator<CvReplayMessage> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXXZ ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::~vector<CvReplayMessage,std::allocator<CvReplayMessage> >
PUBLIC	??$_Uninit_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >,CvReplayMessage *,std::allocator<CvReplayMessage> >
PUBLIC	??$_Allocate@VCvReplayMessage@@@std@@YAPAVCvReplayMessage@@IPAV1@@Z ; std::_Allocate<CvReplayMessage>
PUBLIC	?_Xlen@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@KAXXZ ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXI@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXI@Z$4
__ehfuncinfo$?reserve@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
tv170 = -208						; size = 4
tv168 = -204						; size = 4
_this$ = -200						; size = 4
$T238277 = -196						; size = 4
$T238276 = -192						; size = 4
$T238272 = -188						; size = 4
$T238271 = -184						; size = 4
$T238253 = -180						; size = 4
$T238252 = -176						; size = 4
$T238236 = -172						; size = 4
$T238235 = -168						; size = 4
__Cat$238260 = -162					; size = 1
$T238258 = -161						; size = 1
$T238203 = -160						; size = 4
$T238202 = -156						; size = 4
$T238183 = -152						; size = 4
$T238166 = -145						; size = 1
$T238165 = -144						; size = 4
$T238155 = -140						; size = 4
$T238154 = -136						; size = 4
__Cat$238197 = -130					; size = 1
$T238195 = -129						; size = 1
$T238194 = -128						; size = 1
__Cat$238189 = -127					; size = 1
$T238187 = -126						; size = 1
$T238186 = -125						; size = 1
$T238124 = -124						; size = 4
$T238108 = -120						; size = 4
__Count$238075 = -36					; size = 4
$T238058 = -32						; size = 4
$T238057 = -28						; size = 4
__Size$221597 = -24					; size = 4
__Ptr$221545 = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?reserve@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXI@Z PROC ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::reserve, COMDAT
; _this$ = ecx

; 602  : 		{	// determine new minimum length of allocated storage

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?reserve@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 603  : 		if (max_size() < _Count)

	mov	DWORD PTR __Count$238075[ebp], 71582788	; 04444444H
	cmp	DWORD PTR __Count$238075[ebp], 0
	jbe	SHORT $LN16@reserve
	mov	eax, DWORD PTR __Count$238075[ebp]
	mov	DWORD PTR tv168[ebp], eax
	jmp	SHORT $LN12@reserve
$LN16@reserve:
	mov	DWORD PTR tv168[ebp], 1
$LN12@reserve:
	mov	ecx, DWORD PTR tv168[ebp]
	cmp	ecx, DWORD PTR __Count$[ebp]
	jae	SHORT $LN5@reserve

; 604  : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@KAXXZ ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Xlen
	jmp	$LN7@reserve
$LN5@reserve:

; 605  : 		else if (capacity() < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN26@reserve
	mov	DWORD PTR tv170[ebp], 0
	jmp	SHORT $LN24@reserve
$LN26@reserve:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 60					; 0000003cH
	idiv	ecx
	mov	DWORD PTR tv170[ebp], eax
$LN24@reserve:
	mov	edx, DWORD PTR tv170[ebp]
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN7@reserve

; 606  : 			{	// not enough room, reallocate
; 607  : 			pointer _Ptr = this->_Alval.allocate(_Count);

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@VCvReplayMessage@@@std@@YAPAVCvReplayMessage@@IPAV1@@Z ; std::_Allocate<CvReplayMessage>
	add	esp, 8
	mov	DWORD PTR __Ptr$221545[ebp], eax

; 608  : 
; 609  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 610  : 			_Umove(begin(), end(), _Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T238108[ebp], edx
	mov	eax, DWORD PTR $T238108[ebp]
	mov	DWORD PTR $T238057[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T238124[ebp], edx
	mov	eax, DWORD PTR $T238124[ebp]
	mov	DWORD PTR $T238058[ebp], eax
	mov	ecx, DWORD PTR $T238057[ebp]
	mov	DWORD PTR $T238203[ebp], ecx
	mov	edx, DWORD PTR $T238058[ebp]
	mov	DWORD PTR $T238202[ebp], edx
	mov	eax, DWORD PTR __Ptr$221545[ebp]
	mov	DWORD PTR $T238183[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T238186[ebp], cl
	mov	dl, BYTE PTR __Cat$238189[ebp]
	mov	BYTE PTR $T238187[ebp], dl
	mov	al, BYTE PTR $T238186[ebp]
	mov	BYTE PTR $T238166[ebp], al
	mov	ecx, DWORD PTR $T238183[ebp]
	mov	DWORD PTR $T238165[ebp], ecx
	mov	edx, DWORD PTR $T238165[ebp]
	mov	DWORD PTR $T238155[ebp], edx
	mov	eax, DWORD PTR $T238202[ebp]
	mov	DWORD PTR $T238154[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T238194[ebp], cl
	mov	dl, BYTE PTR __Cat$238197[ebp]
	mov	BYTE PTR $T238195[ebp], dl
	movzx	eax, BYTE PTR $T238194[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T238195[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T238155[ebp]
	push	eax
	mov	ecx, DWORD PTR $T238203[ebp]
	push	ecx
	mov	edx, DWORD PTR $T238154[ebp]
	push	edx
	call	??$_Uninit_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >,CvReplayMessage *,std::allocator<CvReplayMessage> >
	add	esp, 24					; 00000018H
	jmp	SHORT $LN8@reserve
__catch$?reserve@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXI@Z$0:

; 611  : 			_CATCH_ALL
; 612  : 			this->_Alval.deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Ptr$221545[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 613  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 614  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN61@reserve
	ret	0
$LN8@reserve:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 615  : 
; 616  : 			size_type _Size = size();

$LN61@reserve:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 60					; 0000003cH
	idiv	ecx
	mov	DWORD PTR __Size$221597[ebp], eax

; 617  : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN1@reserve

; 618  : 				{	// destroy and deallocate old array
; 619  : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T238272[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T238271[ebp], eax
	mov	ecx, DWORD PTR $T238272[ebp]
	mov	DWORD PTR $T238253[ebp], ecx
	mov	edx, DWORD PTR $T238271[ebp]
	mov	DWORD PTR $T238252[ebp], edx
	mov	al, BYTE PTR __Cat$238260[ebp]
	mov	BYTE PTR $T238258[ebp], al
	mov	ecx, DWORD PTR $T238253[ebp]
	mov	DWORD PTR $T238236[ebp], ecx
	mov	edx, DWORD PTR $T238252[ebp]
	mov	DWORD PTR $T238235[ebp], edx
	jmp	SHORT $LN71@reserve
$LN70@reserve:
	mov	eax, DWORD PTR $T238235[ebp]
	add	eax, 60					; 0000003cH
	mov	DWORD PTR $T238235[ebp], eax
$LN71@reserve:
	mov	ecx, DWORD PTR $T238235[ebp]
	cmp	ecx, DWORD PTR $T238236[ebp]
	je	SHORT $LN63@reserve
	push	0
	mov	edx, DWORD PTR $T238235[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T238235[ebp]
	mov	edx, DWORD PTR [eax]
	call	edx
	jmp	SHORT $LN70@reserve
$LN63@reserve:

; 620  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 60					; 0000003cH
	idiv	ecx
	mov	DWORD PTR $T238277[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T238276[ebp], eax
	mov	ecx, DWORD PTR $T238276[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@reserve:

; 621  : 				}
; 622  : 
; 623  :  #if _HAS_ITERATOR_DEBUGGING
; 624  : 			this->_Orphan_all();
; 625  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 626  : 
; 627  : 			_Myend = _Ptr + _Count;

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 60					; 0000003cH
	add	edx, DWORD PTR __Ptr$221545[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 628  : 			_Mylast = _Ptr + _Size;

	mov	ecx, DWORD PTR __Size$221597[ebp]
	imul	ecx, 60					; 0000003cH
	add	ecx, DWORD PTR __Ptr$221545[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 629  : 			_Myfirst = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$221545[ebp]
	mov	DWORD PTR [eax+4], ecx
$LN7@reserve:

; 630  : 			}
; 631  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-212]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?reserve@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXI@Z ENDP ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::reserve
PUBLIC	?insert@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@V?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@ABVCvReplayMessage@@@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::insert
PUBLIC	??$_Uninit_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvReplayMessage *,unsigned int,CvReplayMessage,std::allocator<CvReplayMessage> >
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXABVCvReplayMessage@@@Z
_TEXT	SEGMENT
tv129 = -64						; size = 4
_this$ = -60						; size = 4
$T238338 = -32						; size = 4
$T238328 = -28						; size = 4
$T238318 = -24						; size = 4
__Cat$238326 = -19					; size = 1
$T238324 = -18						; size = 1
$T238323 = -17						; size = 1
$T238295 = -16						; size = 4
$T238291 = -12						; size = 4
$T238290 = -8						; size = 4
$T238289 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXABVCvReplayMessage@@@Z PROC ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 60					; 0000003cH
	idiv	ecx
	mov	DWORD PTR $T238295[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN9@push_back@2
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN7@push_back@2
$LN9@push_back@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 60					; 0000003cH
	idiv	ecx
	mov	DWORD PTR tv129[ebp], eax
$LN7@push_back@2:
	mov	edx, DWORD PTR $T238295[ebp]
	cmp	edx, DWORD PTR tv129[ebp]
	jae	SHORT $LN2@push_back@2

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T238328[ebp], ecx
	mov	edx, DWORD PTR $T238328[ebp]
	mov	DWORD PTR $T238318[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T238323[ebp], al
	mov	cl, BYTE PTR __Cat$238326[ebp]
	mov	BYTE PTR $T238324[ebp], cl
	movzx	edx, BYTE PTR $T238323[ebp]
	push	edx
	movzx	eax, BYTE PTR $T238324[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR $T238318[ebp]
	push	eax
	call	??$_Uninit_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvReplayMessage *,unsigned int,CvReplayMessage,std::allocator<CvReplayMessage> >
	add	esp, 24					; 00000018H
	mov	ecx, 1
	imul	ecx, 60					; 0000003cH
	add	ecx, DWORD PTR $T238328[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back@2
$LN2@push_back@2:

; 823  : 			insert(end(), _Val);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T238338[ebp], ecx
	mov	edx, DWORD PTR $T238338[ebp]
	mov	DWORD PTR $T238290[ebp], edx
	mov	eax, DWORD PTR $T238290[ebp]
	mov	DWORD PTR $T238289[ebp], eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T238289[ebp]
	push	edx
	lea	eax, DWORD PTR $T238291[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@V?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@ABVCvReplayMessage@@@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::insert
$LN3@push_back@2:

; 824  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAEXABVCvReplayMessage@@@Z ENDP ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::push_back
_TEXT	ENDS
PUBLIC	?_Construct_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXIABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Construct_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@I@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@I@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@I@Z$8
__ehfuncinfo$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@I@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@I@Z
_TEXT	SEGMENT
tv94 = -176						; size = 4
tv95 = -172						; size = 4
tv152 = -168						; size = 4
_this$ = -164						; size = 4
$T238527 = -44						; size = 1
$T238526 = -43						; size = 1
$T238437 = -42						; size = 1
$T238424 = -41						; size = 1
$T238420 = -40						; size = 4
$T238413 = -32						; size = 4
$T238407 = -28						; size = 12
__$EHRec$ = -12						; size = 12
__Count$ = 8						; size = 4
??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@I@Z PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >, COMDAT
; _this$ = ecx

; 482  : 		{	// construct from _Count * _Ty()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 164				; 000000a4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T238437[ebp]
	mov	DWORD PTR $T238413[ebp], eax
	lea	ecx, DWORD PTR $T238424[ebp]
	mov	DWORD PTR $T238420[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv152[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv95[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 483  : 		_Construct_n(_Count, _Ty());

	lea	ecx, DWORD PTR $T238526[ebp]
	push	ecx
	lea	edx, DWORD PTR $T238527[ebp]
	push	edx
	lea	ecx, DWORD PTR $T238407[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
	lea	eax, DWORD PTR $T238407[ebp]
	mov	DWORD PTR tv94[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR tv94[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Construct_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXIABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Construct_n
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T238407[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 0

; 484  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@I@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ
__unwindfunclet$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@I@Z$1:
	lea	ecx, DWORD PTR $T238407[ebp]
	jmp	??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ
__unwindfunclet$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@I@Z$8:
	lea	ecx, DWORD PTR $T238407[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-168]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@I@Z ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -92						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::~vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 80					; 00000050H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ
__ehhandler$??1?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-84]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::~vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
PUBLIC	?insert@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@ABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::insert
PUBLIC	??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,unsigned int,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z
_TEXT	SEGMENT
tv129 = -64						; size = 4
_this$ = -60						; size = 4
$T239212 = -32						; size = 4
$T239202 = -28						; size = 4
$T239192 = -24						; size = 4
__Cat$239200 = -19					; size = 1
$T239198 = -18						; size = 1
$T239197 = -17						; size = 1
$T239169 = -16						; size = 4
$T239165 = -12						; size = 4
$T239164 = -8						; size = 4
$T239163 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR $T239169[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN9@push_back@3
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN7@push_back@3
$LN9@push_back@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR tv129[ebp], eax
$LN7@push_back@3:
	mov	edx, DWORD PTR $T239169[ebp]
	cmp	edx, DWORD PTR tv129[ebp]
	jae	SHORT $LN2@push_back@3

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T239202[ebp], ecx
	mov	edx, DWORD PTR $T239202[ebp]
	mov	DWORD PTR $T239192[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T239197[ebp], al
	mov	cl, BYTE PTR __Cat$239200[ebp]
	mov	BYTE PTR $T239198[ebp], cl
	movzx	edx, BYTE PTR $T239197[ebp]
	push	edx
	movzx	eax, BYTE PTR $T239198[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR $T239192[ebp]
	push	eax
	call	??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,unsigned int,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
	add	esp, 24					; 00000018H
	mov	ecx, 1
	imul	ecx, 12					; 0000000cH
	add	ecx, DWORD PTR $T239202[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back@3
$LN2@push_back@3:

; 823  : 			insert(end(), _Val);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T239212[ebp], ecx
	mov	edx, DWORD PTR $T239212[ebp]
	mov	DWORD PTR $T239164[ebp], edx
	mov	eax, DWORD PTR $T239164[ebp]
	mov	DWORD PTR $T239163[ebp], eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T239163[ebp]
	push	edx
	lea	eax, DWORD PTR $T239165[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@ABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::insert
$LN3@push_back@3:

; 824  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::push_back
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE@XZ PROC ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::~vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXXZ ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE@XZ ENDP ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::~vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >
PUBLIC	?insert@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@V?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@ABW4GameOptionTypes@@@Z ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::insert
PUBLIC	??$_Uninit_fill_n@PAW4GameOptionTypes@@IW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAXPAW4GameOptionTypes@@IABW41@AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum GameOptionTypes *,unsigned int,enum GameOptionTypes,std::allocator<enum GameOptionTypes> >
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAEXABW4GameOptionTypes@@@Z
_TEXT	SEGMENT
tv129 = -64						; size = 4
_this$ = -60						; size = 4
$T239415 = -32						; size = 4
$T239405 = -28						; size = 4
$T239395 = -24						; size = 4
__Cat$239403 = -19					; size = 1
$T239401 = -18						; size = 1
$T239400 = -17						; size = 1
$T239372 = -16						; size = 4
$T239368 = -12						; size = 4
$T239367 = -8						; size = 4
$T239366 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAEXABW4GameOptionTypes@@@Z PROC ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T239372[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN9@push_back@4
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN7@push_back@4
$LN9@push_back@4:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv129[ebp], eax
$LN7@push_back@4:
	mov	ecx, DWORD PTR $T239372[ebp]
	cmp	ecx, DWORD PTR tv129[ebp]
	jae	SHORT $LN2@push_back@4

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T239405[ebp], eax
	mov	ecx, DWORD PTR $T239405[ebp]
	mov	DWORD PTR $T239395[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T239400[ebp], dl
	mov	al, BYTE PTR __Cat$239403[ebp]
	mov	BYTE PTR $T239401[ebp], al
	movzx	ecx, BYTE PTR $T239400[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T239401[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR $T239395[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAW4GameOptionTypes@@IW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAXPAW4GameOptionTypes@@IABW41@AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum GameOptionTypes *,unsigned int,enum GameOptionTypes,std::allocator<enum GameOptionTypes> >
	add	esp, 24					; 00000018H
	mov	eax, 1
	shl	eax, 2
	add	eax, DWORD PTR $T239405[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back@4
$LN2@push_back@4:

; 823  : 			insert(end(), _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T239415[ebp], eax
	mov	ecx, DWORD PTR $T239415[ebp]
	mov	DWORD PTR $T239367[ebp], ecx
	mov	edx, DWORD PTR $T239367[ebp]
	mov	DWORD PTR $T239366[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239366[ebp]
	push	ecx
	lea	edx, DWORD PTR $T239368[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@V?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@ABW4GameOptionTypes@@@Z ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::insert
$LN3@push_back@4:

; 824  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAEXABW4GameOptionTypes@@@Z ENDP ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::push_back
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE@XZ PROC ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::~vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXXZ ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE@XZ ENDP ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::~vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >
PUBLIC	?insert@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@V?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@ABW4VictoryTypes@@@Z ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::insert
PUBLIC	??$_Uninit_fill_n@PAW4VictoryTypes@@IW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAXPAW4VictoryTypes@@IABW41@AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum VictoryTypes *,unsigned int,enum VictoryTypes,std::allocator<enum VictoryTypes> >
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAEXABW4VictoryTypes@@@Z
_TEXT	SEGMENT
tv129 = -64						; size = 4
_this$ = -60						; size = 4
$T239618 = -32						; size = 4
$T239608 = -28						; size = 4
$T239598 = -24						; size = 4
__Cat$239606 = -19					; size = 1
$T239604 = -18						; size = 1
$T239603 = -17						; size = 1
$T239575 = -16						; size = 4
$T239571 = -12						; size = 4
$T239570 = -8						; size = 4
$T239569 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAEXABW4VictoryTypes@@@Z PROC ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T239575[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN9@push_back@5
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN7@push_back@5
$LN9@push_back@5:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv129[ebp], eax
$LN7@push_back@5:
	mov	ecx, DWORD PTR $T239575[ebp]
	cmp	ecx, DWORD PTR tv129[ebp]
	jae	SHORT $LN2@push_back@5

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T239608[ebp], eax
	mov	ecx, DWORD PTR $T239608[ebp]
	mov	DWORD PTR $T239598[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T239603[ebp], dl
	mov	al, BYTE PTR __Cat$239606[ebp]
	mov	BYTE PTR $T239604[ebp], al
	movzx	ecx, BYTE PTR $T239603[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T239604[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR $T239598[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAW4VictoryTypes@@IW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAXPAW4VictoryTypes@@IABW41@AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum VictoryTypes *,unsigned int,enum VictoryTypes,std::allocator<enum VictoryTypes> >
	add	esp, 24					; 00000018H
	mov	eax, 1
	shl	eax, 2
	add	eax, DWORD PTR $T239608[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back@5
$LN2@push_back@5:

; 823  : 			insert(end(), _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T239618[ebp], eax
	mov	ecx, DWORD PTR $T239618[ebp]
	mov	DWORD PTR $T239570[ebp], ecx
	mov	edx, DWORD PTR $T239570[ebp]
	mov	DWORD PTR $T239569[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239569[ebp]
	push	ecx
	lea	edx, DWORD PTR $T239571[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@V?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@ABW4VictoryTypes@@@Z ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::insert
$LN3@push_back@5:

; 824  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAEXABW4VictoryTypes@@@Z ENDP ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::push_back
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -68						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::~vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXXZ ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-60]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::~vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >
PUBLIC	?insert@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@V?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@ABUPlayerInfo@CvReplayInfo@@@Z ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::insert
PUBLIC	??$_Uninit_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvReplayInfo::PlayerInfo *,unsigned int,CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAEXABUPlayerInfo@CvReplayInfo@@@Z
_TEXT	SEGMENT
tv129 = -64						; size = 4
_this$ = -60						; size = 4
$T239866 = -32						; size = 4
$T239856 = -28						; size = 4
$T239846 = -24						; size = 4
__Cat$239853 = -19					; size = 1
$T239850 = -18						; size = 1
$T239849 = -17						; size = 1
$T239823 = -16						; size = 4
$T239819 = -12						; size = 4
$T239818 = -8						; size = 4
$T239817 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAEXABUPlayerInfo@CvReplayInfo@@@Z PROC ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 7
	mov	DWORD PTR $T239823[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN9@push_back@6
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN7@push_back@6
$LN9@push_back@6:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 7
	mov	DWORD PTR tv129[ebp], eax
$LN7@push_back@6:
	mov	ecx, DWORD PTR $T239823[ebp]
	cmp	ecx, DWORD PTR tv129[ebp]
	jae	SHORT $LN2@push_back@6

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T239856[ebp], eax
	mov	ecx, DWORD PTR $T239856[ebp]
	mov	DWORD PTR $T239846[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T239849[ebp], dl
	mov	al, BYTE PTR __Cat$239853[ebp]
	mov	BYTE PTR $T239850[ebp], al
	movzx	ecx, BYTE PTR $T239849[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T239850[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR $T239846[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvReplayInfo::PlayerInfo *,unsigned int,CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >
	add	esp, 24					; 00000018H
	mov	eax, 1
	shl	eax, 7
	add	eax, DWORD PTR $T239856[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back@6
$LN2@push_back@6:

; 823  : 			insert(end(), _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T239866[ebp], eax
	mov	ecx, DWORD PTR $T239866[ebp]
	mov	DWORD PTR $T239818[ebp], ecx
	mov	edx, DWORD PTR $T239818[ebp]
	mov	DWORD PTR $T239817[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239817[ebp]
	push	ecx
	lea	edx, DWORD PTR $T239819[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@V?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@ABUPlayerInfo@CvReplayInfo@@@Z ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::insert
$LN3@push_back@6:

; 824  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAEXABUPlayerInfo@CvReplayInfo@@@Z ENDP ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::push_back
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAE_NI@Z ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Buy
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
tv88 = -132						; size = 4
tv145 = -128						; size = 4
_this$ = -124						; size = 4
$T239963 = -30						; size = 1
$T239950 = -29						; size = 1
$T239946 = -28						; size = 4
$T239939 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T239963[ebp]
	mov	DWORD PTR $T239939[ebp], eax
	lea	ecx, DWORD PTR $T239950[ebp]
	mov	DWORD PTR $T239946[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv145[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv88[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAE_NI@Z ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ
__ehhandler$??0?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -84						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::~vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ
__ehhandler$??1?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::~vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
PUBLIC	?insert@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@ABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::insert
PUBLIC	??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,unsigned int,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAEXABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z
_TEXT	SEGMENT
tv129 = -64						; size = 4
_this$ = -60						; size = 4
$T240462 = -32						; size = 4
$T240452 = -28						; size = 4
$T240442 = -24						; size = 4
__Cat$240450 = -19					; size = 1
$T240448 = -18						; size = 1
$T240447 = -17						; size = 1
$T240419 = -16						; size = 4
$T240415 = -12						; size = 4
$T240414 = -8						; size = 4
$T240413 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAEXABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z PROC ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 4
	mov	DWORD PTR $T240419[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN9@push_back@7
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN7@push_back@7
$LN9@push_back@7:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 4
	mov	DWORD PTR tv129[ebp], eax
$LN7@push_back@7:
	mov	ecx, DWORD PTR $T240419[ebp]
	cmp	ecx, DWORD PTR tv129[ebp]
	jae	SHORT $LN2@push_back@7

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T240452[ebp], eax
	mov	ecx, DWORD PTR $T240452[ebp]
	mov	DWORD PTR $T240442[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T240447[ebp], dl
	mov	al, BYTE PTR __Cat$240450[ebp]
	mov	BYTE PTR $T240448[ebp], al
	movzx	ecx, BYTE PTR $T240447[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T240448[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR $T240442[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,unsigned int,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
	add	esp, 24					; 00000018H
	mov	eax, 1
	shl	eax, 4
	add	eax, DWORD PTR $T240452[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back@7
$LN2@push_back@7:

; 823  : 			insert(end(), _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T240462[ebp], eax
	mov	ecx, DWORD PTR $T240462[ebp]
	mov	DWORD PTR $T240414[ebp], ecx
	mov	edx, DWORD PTR $T240414[ebp]
	mov	DWORD PTR $T240413[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T240413[ebp]
	push	ecx
	lea	edx, DWORD PTR $T240415[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@ABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::insert
$LN3@push_back@7:

; 824  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAEXABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z ENDP ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::push_back
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAE_NI@Z ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Buy
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
tv88 = -132						; size = 4
tv145 = -128						; size = 4
_this$ = -124						; size = 4
$T240559 = -30						; size = 1
$T240546 = -29						; size = 1
$T240542 = -28						; size = 4
$T240535 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T240559[ebp]
	mov	DWORD PTR $T240535[ebp], eax
	lea	ecx, DWORD PTR $T240546[ebp]
	mov	DWORD PTR $T240542[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv145[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv88[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAE_NI@Z ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE@XZ
__ehhandler$??0?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
PUBLIC	??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::_Vector_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
PUBLIC	??$_Allocate@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IPAV10@@Z ; std::_Allocate<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >
PUBLIC	?_Xlen@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@KAXXZ ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXI@Z$10 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXI@Z$0
__tryblocktable$?reserve@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXI@Z$10
__unwindtable$?reserve@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?reserve@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXI@Z$5
__ehfuncinfo$?reserve@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXI@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?reserve@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXI@Z
_TEXT	SEGMENT
tv170 = -228						; size = 4
tv168 = -224						; size = 4
_this$ = -220						; size = 4
$T241044 = -216						; size = 4
$T241043 = -212						; size = 4
$T241039 = -208						; size = 4
$T241038 = -204						; size = 4
$T241003 = -200						; size = 4
$T241002 = -196						; size = 4
$T240969 = -192						; size = 4
$T240968 = -188						; size = 4
__Cat$241009 = -142					; size = 1
$T241006 = -141						; size = 1
$T240709 = -140						; size = 4
$T240708 = -136						; size = 4
$T240698 = -132						; size = 4
__Cat$240706 = -127					; size = 1
$T240703 = -126						; size = 1
$T240702 = -125						; size = 1
$T240676 = -124						; size = 4
$T240660 = -120						; size = 4
__Count$240627 = -36					; size = 4
$T240610 = -32						; size = 4
$T240609 = -28						; size = 4
__Size$222675 = -24					; size = 4
__Ptr$222519 = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?reserve@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXI@Z PROC ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::reserve, COMDAT
; _this$ = ecx

; 602  : 		{	// determine new minimum length of allocated storage

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?reserve@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 212				; 000000d4H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 603  : 		if (max_size() < _Count)

	mov	DWORD PTR __Count$240627[ebp], 357913941 ; 15555555H
	cmp	DWORD PTR __Count$240627[ebp], 0
	jbe	SHORT $LN16@reserve@2
	mov	eax, DWORD PTR __Count$240627[ebp]
	mov	DWORD PTR tv168[ebp], eax
	jmp	SHORT $LN12@reserve@2
$LN16@reserve@2:
	mov	DWORD PTR tv168[ebp], 1
$LN12@reserve@2:
	mov	ecx, DWORD PTR tv168[ebp]
	cmp	ecx, DWORD PTR __Count$[ebp]
	jae	SHORT $LN5@reserve@2

; 604  : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@KAXXZ ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Xlen
	jmp	$LN7@reserve@2
$LN5@reserve@2:

; 605  : 		else if (capacity() < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN26@reserve@2
	mov	DWORD PTR tv170[ebp], 0
	jmp	SHORT $LN24@reserve@2
$LN26@reserve@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR tv170[ebp], eax
$LN24@reserve@2:
	mov	edx, DWORD PTR tv170[ebp]
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN7@reserve@2

; 606  : 			{	// not enough room, reallocate
; 607  : 			pointer _Ptr = this->_Alval.allocate(_Count);

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IPAV10@@Z ; std::_Allocate<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >
	add	esp, 8
	mov	DWORD PTR __Ptr$222519[ebp], eax

; 608  : 
; 609  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 610  : 			_Umove(begin(), end(), _Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T240660[ebp], edx
	mov	eax, DWORD PTR $T240660[ebp]
	mov	DWORD PTR $T240609[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T240676[ebp], edx
	mov	eax, DWORD PTR $T240676[ebp]
	mov	DWORD PTR $T240610[ebp], eax
	mov	ecx, DWORD PTR $T240609[ebp]
	mov	DWORD PTR $T240709[ebp], ecx
	mov	edx, DWORD PTR $T240610[ebp]
	mov	DWORD PTR $T240708[ebp], edx
	mov	eax, DWORD PTR __Ptr$222519[ebp]
	mov	DWORD PTR $T240698[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T240702[ebp], cl
	mov	dl, BYTE PTR __Cat$240706[ebp]
	mov	BYTE PTR $T240703[ebp], dl
	movzx	eax, BYTE PTR $T240702[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T240703[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T240698[ebp]
	push	eax
	mov	ecx, DWORD PTR $T240709[ebp]
	push	ecx
	mov	edx, DWORD PTR $T240708[ebp]
	push	edx
	call	??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::_Vector_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
	add	esp, 24					; 00000018H
	jmp	SHORT $LN8@reserve@2
__catch$?reserve@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXI@Z$0:

; 611  : 			_CATCH_ALL
; 612  : 			this->_Alval.deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Ptr$222519[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 613  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 614  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN55@reserve@2
	ret	0
$LN8@reserve@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 615  : 
; 616  : 			size_type _Size = size();

$LN55@reserve@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR __Size$222675[ebp], eax

; 617  : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN1@reserve@2

; 618  : 				{	// destroy and deallocate old array
; 619  : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T241039[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T241038[ebp], eax
	mov	ecx, DWORD PTR $T241039[ebp]
	mov	DWORD PTR $T241003[ebp], ecx
	mov	edx, DWORD PTR $T241038[ebp]
	mov	DWORD PTR $T241002[ebp], edx
	mov	al, BYTE PTR __Cat$241009[ebp]
	mov	BYTE PTR $T241006[ebp], al
	mov	ecx, DWORD PTR $T241003[ebp]
	mov	DWORD PTR $T240969[ebp], ecx
	mov	edx, DWORD PTR $T241002[ebp]
	mov	DWORD PTR $T240968[ebp], edx
	jmp	SHORT $LN65@reserve@2
$LN64@reserve@2:
	mov	eax, DWORD PTR $T240968[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T240968[ebp], eax
$LN65@reserve@2:
	mov	ecx, DWORD PTR $T240968[ebp]
	cmp	ecx, DWORD PTR $T240969[ebp]
	je	SHORT $LN57@reserve@2
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR $T240968[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	xor	edx, edx
	and	edx, 1
	je	SHORT $LN68@reserve@2
	mov	eax, DWORD PTR $T240968[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN68@reserve@2:
	jmp	SHORT $LN64@reserve@2
$LN57@reserve@2:

; 620  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR $T241044[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T241043[ebp], eax
	mov	ecx, DWORD PTR $T241043[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@reserve@2:

; 621  : 				}
; 622  : 
; 623  :  #if _HAS_ITERATOR_DEBUGGING
; 624  : 			this->_Orphan_all();
; 625  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 626  : 
; 627  : 			_Myend = _Ptr + _Count;

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 12					; 0000000cH
	add	edx, DWORD PTR __Ptr$222519[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 628  : 			_Mylast = _Ptr + _Size;

	mov	ecx, DWORD PTR __Size$222675[ebp]
	imul	ecx, 12					; 0000000cH
	add	ecx, DWORD PTR __Ptr$222519[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 629  : 			_Myfirst = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$222519[ebp]
	mov	DWORD PTR [eax+4], ecx
$LN7@reserve@2:

; 630  : 			}
; 631  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?reserve@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXI@Z$5:
	mov	ecx, DWORD PTR $T240968[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__ehhandler$?reserve@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?reserve@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXI@Z ENDP ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::reserve
PUBLIC	?insert@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@ABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::insert
PUBLIC	??$_Uninit_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IABV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,unsigned int,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z
_TEXT	SEGMENT
tv129 = -64						; size = 4
_this$ = -60						; size = 4
$T241105 = -32						; size = 4
$T241095 = -28						; size = 4
$T241085 = -24						; size = 4
__Cat$241091 = -19					; size = 1
$T241089 = -18						; size = 1
$T241088 = -17						; size = 1
$T241062 = -16						; size = 4
$T241058 = -12						; size = 4
$T241057 = -8						; size = 4
$T241056 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z PROC ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR $T241062[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN9@push_back@8
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN7@push_back@8
$LN9@push_back@8:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR tv129[ebp], eax
$LN7@push_back@8:
	mov	edx, DWORD PTR $T241062[ebp]
	cmp	edx, DWORD PTR tv129[ebp]
	jae	SHORT $LN2@push_back@8

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T241095[ebp], ecx
	mov	edx, DWORD PTR $T241095[ebp]
	mov	DWORD PTR $T241085[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T241088[ebp], al
	mov	cl, BYTE PTR __Cat$241091[ebp]
	mov	BYTE PTR $T241089[ebp], cl
	movzx	edx, BYTE PTR $T241088[ebp]
	push	edx
	movzx	eax, BYTE PTR $T241089[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR $T241085[ebp]
	push	eax
	call	??$_Uninit_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IABV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,unsigned int,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
	add	esp, 24					; 00000018H
	mov	ecx, 1
	imul	ecx, 12					; 0000000cH
	add	ecx, DWORD PTR $T241095[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back@8
$LN2@push_back@8:

; 823  : 			insert(end(), _Val);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T241105[ebp], ecx
	mov	edx, DWORD PTR $T241105[ebp]
	mov	DWORD PTR $T241057[ebp], edx
	mov	eax, DWORD PTR $T241057[ebp]
	mov	DWORD PTR $T241056[ebp], eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T241056[ebp]
	push	edx
	lea	eax, DWORD PTR $T241058[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@ABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::insert
$LN3@push_back@8:

; 824  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z ENDP ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::push_back
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ ; std::_Vector_val<std::pair<short,short>,std::allocator<std::pair<short,short> > >::~_Vector_val<std::pair<short,short>,std::allocator<std::pair<short,short> > >
PUBLIC	?_Tidy@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEXXZ ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Tidy
PUBLIC	??$_Uninit_copy@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > >,std::pair<short,short> *,std::allocator<std::pair<short,short> > >
PUBLIC	?_Buy@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAE_NI@Z ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Buy
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??0?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@ABV01@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@ABV01@@Z$5
__unwindtable$??0?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv215 = -212						; size = 4
tv148 = -208						; size = 4
tv172 = -204						; size = 4
_this$ = -200						; size = 4
$T241285 = -164						; size = 4
$T241284 = -160						; size = 4
$T241283 = -156						; size = 4
$T241273 = -152						; size = 4
$T241272 = -148						; size = 4
__Cat$241280 = -143					; size = 1
$T241278 = -142						; size = 1
$T241277 = -141						; size = 1
$T241252 = -140						; size = 4
$T241243 = -136						; size = 4
$T241212 = -48						; size = 4
$T241208 = -42						; size = 1
$T241195 = -41						; size = 1
$T241191 = -40						; size = 4
$T241184 = -32						; size = 4
$T241175 = -28						; size = 4
$T241174 = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@ABV01@@Z PROC ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T241208[ebp]
	mov	DWORD PTR $T241184[ebp], eax
	lea	ecx, DWORD PTR $T241195[ebp]
	mov	DWORD PTR $T241191[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv172[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv148[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR $T241212[ebp], eax
	mov	ecx, DWORD PTR $T241212[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAE_NI@Z ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Buy
	movzx	edx, al
	test	edx, edx
	je	$LN3@vector

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T241243[ebp], ecx
	mov	edx, DWORD PTR $T241243[ebp]
	mov	DWORD PTR $T241174[ebp], edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T241252[ebp], ecx
	mov	edx, DWORD PTR $T241252[ebp]
	mov	DWORD PTR $T241175[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T241285[ebp], ecx
	mov	edx, DWORD PTR $T241174[ebp]
	mov	DWORD PTR $T241284[ebp], edx
	mov	eax, DWORD PTR $T241175[ebp]
	mov	DWORD PTR $T241283[ebp], eax
	mov	ecx, DWORD PTR $T241285[ebp]
	mov	DWORD PTR $T241273[ebp], ecx
	mov	edx, DWORD PTR $T241283[ebp]
	mov	DWORD PTR $T241272[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T241277[ebp], al
	mov	cl, BYTE PTR __Cat$241280[ebp]
	mov	BYTE PTR $T241278[ebp], cl
	movzx	edx, BYTE PTR $T241277[ebp]
	push	edx
	movzx	eax, BYTE PTR $T241278[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T241273[ebp]
	push	edx
	mov	eax, DWORD PTR $T241284[ebp]
	push	eax
	mov	ecx, DWORD PTR $T241272[ebp]
	push	ecx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > >,std::pair<short,short> *,std::allocator<std::pair<short,short> > >
	add	esp, 24					; 00000018H
	mov	DWORD PTR tv215[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv215[ebp]
	mov	DWORD PTR [edx+8], eax
	jmp	SHORT $LN5@vector
__catch$??0?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEXXZ ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector
	ret	0
$LN5@vector:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ
__ehhandler$??0?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-216]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@ABV01@@Z ENDP ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::~vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEXXZ ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ
__ehhandler$??1?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::~vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::insert
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lbound
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
;	COMDAT ??A?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAEAAHABH@Z
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T241528 = -48						; size = 4
$T241515 = -44						; size = 4
$T241499 = -40						; size = 4
$T241455 = -28						; size = 4
$T241454 = -24						; size = 4
$T241453 = -20						; size = 4
$T241452 = -16						; size = 8
$T241451 = -8						; size = 4
__Where$ = -4						; size = 4
__Keyval$ = 8						; size = 4
??A?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAEAAHABH@Z PROC ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::operator[], COMDAT
; _this$ = ecx

; 168  : 		{	// find element matching _Keyval or insert with default mapped

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 169  : 		iterator _Where = this->lower_bound(_Keyval);

	mov	eax, DWORD PTR __Keyval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lbound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lbound
	mov	DWORD PTR $T241499[ebp], eax
	mov	ecx, DWORD PTR $T241499[ebp]
	mov	DWORD PTR __Where$[ebp], ecx

; 170  : 		if (_Where == this->end()
; 171  : 			|| this->comp(_Keyval, this->_Key(_Where._Mynode())))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T241515[ebp], eax
	mov	ecx, DWORD PTR $T241515[ebp]
	mov	DWORD PTR $T241451[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T241451[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@operator@5
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T241528[ebp], edx
	mov	eax, DWORD PTR __Keyval$[ebp]
	mov	ecx, DWORD PTR $T241528[ebp]
	mov	edx, DWORD PTR [eax]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+12]
	setl	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN55@operator@5
$LN1@operator@5:

; 172  : 			_Where = this->insert(_Where,
; 173  : 				value_type(_Keyval, mapped_type()));

	mov	DWORD PTR $T241453[ebp], 0
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T241454[ebp], edx
	mov	eax, DWORD PTR __Keyval$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T241452[ebp], ecx
	mov	edx, DWORD PTR $T241453[ebp]
	mov	DWORD PTR $T241452[ebp+4], edx
	lea	eax, DWORD PTR $T241452[ebp]
	push	eax
	mov	ecx, DWORD PTR $T241454[ebp]
	push	ecx
	lea	edx, DWORD PTR $T241455[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::insert
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Where$[ebp], eax

; 174  : 		return ((*_Where).second);

$LN55@operator@5:
	mov	eax, DWORD PTR __Where$[ebp]
	add	eax, 16					; 00000010H

; 175  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAEAAHABH@Z ENDP ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::operator[]
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >
; Function compile flags: /Odtp
;	COMDAT ??0?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T241566 = -2						; size = 1
$T241565 = -1						; size = 1
??0?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAE@XZ PROC ; std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >, COMDAT
; _this$ = ecx

; 103  : 		{	// construct empty map from defaults

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T241565[ebp]
	push	eax
	lea	ecx, DWORD PTR $T241566[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >

; 104  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAE@XZ ENDP ; std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >
_TEXT	ENDS
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::insert
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Lbound
; Function compile flags: /Odtp
;	COMDAT ??A?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAEAAUPlotState@CvReplayInfo@@ABI@Z
_TEXT	SEGMENT
_this$ = -76						; size = 4
$T241761 = -72						; size = 4
$T241748 = -68						; size = 4
$T241732 = -64						; size = 4
$T241688 = -52						; size = 4
$T241687 = -48						; size = 4
$T241686 = -44						; size = 16
$T241685 = -28						; size = 20
$T241684 = -8						; size = 4
__Where$ = -4						; size = 4
__Keyval$ = 8						; size = 4
??A?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAEAAUPlotState@CvReplayInfo@@ABI@Z PROC ; std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >::operator[], COMDAT
; _this$ = ecx

; 168  : 		{	// find element matching _Keyval or insert with default mapped

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	DWORD PTR _this$[ebp], ecx

; 169  : 		iterator _Where = this->lower_bound(_Keyval);

	mov	eax, DWORD PTR __Keyval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lbound@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Lbound
	mov	DWORD PTR $T241732[ebp], eax
	mov	ecx, DWORD PTR $T241732[ebp]
	mov	DWORD PTR __Where$[ebp], ecx

; 170  : 		if (_Where == this->end()
; 171  : 			|| this->comp(_Keyval, this->_Key(_Where._Mynode())))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T241748[ebp], eax
	mov	ecx, DWORD PTR $T241748[ebp]
	mov	DWORD PTR $T241684[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T241684[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@operator@6
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T241761[ebp], edx
	mov	eax, DWORD PTR __Keyval$[ebp]
	mov	ecx, DWORD PTR $T241761[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+12]
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN55@operator@6
$LN1@operator@6:

; 172  : 			_Where = this->insert(_Where,
; 173  : 				value_type(_Keyval, mapped_type()));

	xor	edx, edx
	mov	DWORD PTR $T241686[ebp], edx
	mov	DWORD PTR $T241686[ebp+4], edx
	mov	DWORD PTR $T241686[ebp+8], edx
	mov	DWORD PTR $T241686[ebp+12], edx
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T241687[ebp], eax
	mov	ecx, DWORD PTR __Keyval$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T241685[ebp], edx
	lea	eax, DWORD PTR $T241685[ebp+4]
	mov	ecx, DWORD PTR $T241686[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR $T241686[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR $T241686[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR $T241686[ebp+12]
	mov	DWORD PTR [eax+12], edx
	lea	eax, DWORD PTR $T241685[ebp]
	push	eax
	mov	ecx, DWORD PTR $T241687[ebp]
	push	ecx
	lea	edx, DWORD PTR $T241688[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::insert
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Where$[ebp], eax

; 174  : 		return ((*_Where).second);

$LN55@operator@6:
	mov	eax, DWORD PTR __Where$[ebp]
	add	eax, 16					; 00000010H

; 175  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAEAAUPlotState@CvReplayInfo@@ABI@Z ENDP ; std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >::operator[]
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABI@Z
_TEXT	SEGMENT
tv93 = -48						; size = 4
_this$ = -44						; size = 4
$T241882 = -40						; size = 4
$T241861 = -36						; size = 4
$T241850 = -32						; size = 4
$T241841 = -28						; size = 4
$T241801 = -16						; size = 4
$T241799 = -12						; size = 4
$T241798 = -8						; size = 4
__Where$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABI@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::find, COMDAT
; _this$ = ecx

; 986  : 		{	// find an element in nonmutable sequence that matches _Keyval

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 987  : 		const_iterator _Where = lower_bound(_Keyval);

	mov	eax, DWORD PTR __Keyval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lbound@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Lbound
	mov	DWORD PTR $T241841[ebp], eax
	mov	ecx, DWORD PTR $T241841[ebp]
	mov	DWORD PTR __Where$[ebp], ecx

; 988  : 		return (_Where == end()
; 989  : 			|| _DEBUG_LT_PRED(this->comp,
; 990  : 				_Keyval, _Key(_Where._Mynode()))
; 991  : 					? end() : _Where);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T241850[ebp], eax
	mov	ecx, DWORD PTR $T241850[ebp]
	mov	DWORD PTR $T241799[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T241799[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@find@2
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T241861[ebp], edx
	mov	eax, DWORD PTR __Keyval$[ebp]
	mov	ecx, DWORD PTR $T241861[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+12]
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@find@2
	lea	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR tv93[ebp], edx
	jmp	SHORT $LN4@find@2
$LN3@find@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T241882[ebp], ecx
	mov	edx, DWORD PTR $T241882[ebp]
	mov	DWORD PTR $T241801[ebp], edx
	lea	eax, DWORD PTR $T241801[ebp]
	mov	DWORD PTR tv93[ebp], eax
$LN4@find@2:
	mov	ecx, DWORD PTR tv93[ebp]
	mov	DWORD PTR $T241798[ebp], ecx
	mov	edx, DWORD PTR $T241798[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 992  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?find@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABI@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::find
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ PROC ; std::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ENDP ; std::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvReplayMessage,std::allocator<CvReplayMessage> >::~_Vector_val<CvReplayMessage,std::allocator<CvReplayMessage> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvReplayMessage,std::allocator<CvReplayMessage> >::~_Vector_val<CvReplayMessage,std::allocator<CvReplayMessage> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ PROC ; std::_Vector_val<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::~_Vector_val<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ ENDP ; std::_Vector_val<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::~_Vector_val<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::~_Vector_val<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::~_Vector_val<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<enum VictoryTypes,std::allocator<enum VictoryTypes> >::~_Vector_val<enum VictoryTypes,std::allocator<enum VictoryTypes> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<enum VictoryTypes,std::allocator<enum VictoryTypes> >::~_Vector_val<enum VictoryTypes,std::allocator<enum VictoryTypes> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::~_Vector_val<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::~_Vector_val<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ PROC ; std::_Vector_val<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::~_Vector_val<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE@XZ ENDP ; std::_Vector_val<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::~_Vector_val<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE@XZ PROC ; std::_Vector_val<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::~_Vector_val<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE@XZ ENDP ; std::_Vector_val<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::~_Vector_val<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ PROC ; std::_Vector_val<std::pair<short,short>,std::allocator<std::pair<short,short> > >::~_Vector_val<std::pair<short,short>,std::allocator<std::pair<short,short> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ ENDP ; std::_Vector_val<std::pair<short,short>,std::allocator<std::pair<short,short> > >::~_Vector_val<std::pair<short,short>,std::allocator<std::pair<short,short> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Tree_val@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Tree_val@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >
_TEXT	ENDS
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Init
PUBLIC	??0?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z ; std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z
_TEXT	SEGMENT
tv89 = -72						; size = 4
tv147 = -68						; size = 4
tv173 = -64						; size = 4
tv199 = -60						; size = 4
_this$ = -56						; size = 4
$T242113 = -47						; size = 1
$T242088 = -46						; size = 1
$T242070 = -45						; size = 1
$T242059 = -44						; size = 4
$T242102 = -40						; size = 4
$T242052 = -36						; size = 4
$T242045 = -28						; size = 4
$T242038 = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 509  : 		{	// construct empty tree

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T242113[ebp]
	mov	DWORD PTR $T242038[ebp], eax
	lea	ecx, DWORD PTR $T242088[ebp]
	mov	DWORD PTR $T242045[ebp], ecx
	lea	edx, DWORD PTR $T242070[ebp]
	mov	DWORD PTR $T242052[ebp], edx
	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T242102[ebp], esp
	mov	DWORD PTR $T242059[ebp], eax
	mov	ecx, DWORD PTR __Parg$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z ; std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>
	mov	DWORD PTR tv199[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv173[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv147[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv89[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 510  : 		_Init();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Init

; 511  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::insert
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Dec
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Insert
; Function compile flags: /Odtp
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBIH@2@@Z
_TEXT	SEGMENT
_this$ = -376						; size = 4
$T242690 = -372						; size = 4
$T242667 = -368						; size = 4
$T242651 = -364						; size = 4
$T242625 = -360						; size = 4
$T242606 = -356						; size = 4
$T242586 = -352						; size = 4
$T242557 = -348						; size = 4
$T242542 = -344						; size = 4
$T242528 = -340						; size = 4
$T242507 = -336						; size = 4
$T242475 = -332						; size = 4
$T242458 = -328						; size = 4
$T242445 = -324						; size = 4
$T242427 = -320						; size = 4
$T242407 = -316						; size = 4
$T242388 = -312						; size = 4
$T242359 = -308						; size = 4
$T242343 = -304						; size = 4
$T242320 = -300						; size = 4
$T242297 = -296						; size = 4
$T242272 = -216						; size = 4
$T242258 = -212						; size = 4
$T242240 = -208						; size = 4
$T242207 = -128						; size = 4
$T242187 = -124						; size = 4
$T242174 = -120						; size = 4
$T242164 = -40						; size = 4
$T242157 = -36						; size = 8
$T242156 = -28						; size = 4
$T242155 = -24						; size = 4
$T242154 = -20						; size = 4
$T242153 = -16						; size = 4
$T242152 = -12						; size = 4
$T242151 = -8						; size = 4
__Next$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBIH@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::insert, COMDAT
; _this$ = ecx

; 664  : 		{	// try to insert node with value _Val using _Where as a hint

	push	ebp
	mov	ebp, esp
	sub	esp, 376				; 00000178H
	mov	DWORD PTR _this$[ebp], ecx

; 665  : 
; 666  :  #if _HAS_ITERATOR_DEBUGGING
; 667  : 		if (_Where._Mycont != this)
; 668  : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 669  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 670  : 
; 671  : 		const_iterator _Next;

	mov	DWORD PTR __Next$[ebp], 0

; 672  : 
; 673  : 		if (size() == 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T242164[ebp], ecx
	cmp	DWORD PTR $T242164[ebp], 0
	jne	SHORT $LN32@insert

; 674  : 			return (_Insert(true, _Myhead, _Val));	// insert into empty tree

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	1
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert
	jmp	$LN31@insert
$LN32@insert:

; 675  : 		else if (this->_Multi)

	xor	eax, eax
	je	$LN30@insert

; 676  : 			{	// insert even if duplicate
; 677  : 			if (_Where == begin())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T242174[ebp], edx
	mov	eax, DWORD PTR $T242174[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T242187[ebp], ecx
	mov	edx, DWORD PTR $T242187[ebp]
	mov	DWORD PTR $T242151[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T242151[ebp]
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN29@insert

; 678  : 				{	// insert at beginning if before first element
; 679  : 				if (!_DEBUG_LT_PRED(this->comp,

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T242207[ebp], eax
	mov	ecx, DWORD PTR $T242207[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	cmp	eax, DWORD PTR [edx]
	sbb	ecx, ecx
	neg	ecx
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN28@insert

; 680  : 					_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 681  : 					return (_Insert(true, _Where._Mynode(), _Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert
$LN28@insert:

; 682  : 				}

	jmp	$LN27@insert
$LN29@insert:

; 683  : 			else if (_Where == end())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T242240[ebp], ecx
	mov	edx, DWORD PTR $T242240[ebp]
	mov	DWORD PTR $T242152[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T242152[ebp]
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN151@insert

; 684  : 				{	// insert at end if after last element
; 685  : 				if (!_DEBUG_LT_PRED(this->comp,

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 8
	mov	DWORD PTR $T242258[ebp], ecx
	mov	edx, DWORD PTR $T242258[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T242272[ebp], eax
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR $T242272[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	sbb	ecx, ecx
	neg	ecx
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN25@insert

; 686  : 					this->_Kfn(_Val), _Key(_Rmost())))
; 687  : 					return (_Insert(false, _Rmost(), _Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	push	0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert
$LN25@insert:

; 688  : 				}
; 689  : 			else if (!_DEBUG_LT_PRED(this->comp,

	jmp	$LN27@insert

; 690  : 				_Key(_Where._Mynode()), this->_Kfn(_Val))
; 691  : 				&& !_DEBUG_LT_PRED(this->comp,

$LN151@insert:
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T242297[ebp], edx
	mov	eax, DWORD PTR $T242297[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx]
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN23@insert
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Next$[ebp], edx
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Dec
	mov	eax, DWORD PTR __Next$[ebp]
	mov	DWORD PTR $T242320[ebp], eax
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR $T242320[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx+12]
	sbb	ecx, ecx
	neg	ecx
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN23@insert

; 692  : 					this->_Kfn(_Val), _Key((--(_Next = _Where))._Mynode())))
; 693  : 				{	// insert before _Where
; 694  : 				if (_Isnil(_Right(_Next._Mynode())))

	mov	eax, DWORD PTR __Next$[ebp]
	mov	DWORD PTR $T242343[ebp], eax
	mov	ecx, DWORD PTR $T242343[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	je	SHORT $LN185@insert

; 695  : 					return (_Insert(false, _Next._Mynode(), _Val));

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert

; 696  : 				else

	jmp	SHORT $LN21@insert

; 697  : 					return (_Insert(true, _Where._Mynode(), _Val));

$LN185@insert:
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert
$LN21@insert:

; 698  : 				}
; 699  : 			else if (!_DEBUG_LT_PRED(this->comp,

	jmp	$LN27@insert
$LN23@insert:

; 700  : 				this->_Kfn(_Val), _Key(_Where._Mynode()))
; 701  : 				&& (++(_Next = _Where) == end()
; 702  : 					|| !_DEBUG_LT_PRED(this->comp,

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T242359[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR $T242359[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax+12]
	sbb	edx, edx
	neg	edx
	movzx	eax, dl
	test	eax, eax
	jne	$LN27@insert
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Next$[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T242388[ebp], eax
	mov	ecx, DWORD PTR $T242388[ebp]
	mov	DWORD PTR $T242153[ebp], ecx
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Inc
	mov	edx, DWORD PTR __Next$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T242153[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN18@insert
	mov	edx, DWORD PTR __Next$[ebp]
	mov	DWORD PTR $T242407[ebp], edx
	mov	eax, DWORD PTR $T242407[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx]
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN27@insert
$LN18@insert:

; 703  : 						_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 704  : 				{	// insert after _Where
; 705  : 				if (_Isnil(_Right(_Where._Mynode())))

	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T242427[ebp], edx
	mov	eax, DWORD PTR $T242427[ebp]
	mov	ecx, DWORD PTR [eax+8]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	je	SHORT $LN229@insert

; 706  : 					return (_Insert(false, _Where._Mynode(), _Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert

; 707  : 				else

	jmp	SHORT $LN27@insert

; 708  : 					return (_Insert(true, _Next._Mynode(), _Val));

$LN229@insert:
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert
$LN27@insert:

; 709  : 				}
; 710  : 			}
; 711  : 		else

	jmp	$LN31@insert
$LN30@insert:

; 712  : 			{	// insert only if unique
; 713  : 			if (_Where == begin())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T242445[ebp], ecx
	mov	edx, DWORD PTR $T242445[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T242458[ebp], eax
	mov	ecx, DWORD PTR $T242458[ebp]
	mov	DWORD PTR $T242154[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T242154[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN14@insert

; 714  : 				{	// insert at beginning if before first element
; 715  : 				if (_DEBUG_LT_PRED(this->comp,

	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T242475[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR $T242475[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+12]
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN13@insert

; 716  : 					this->_Kfn(_Val), _Key(_Where._Mynode())))
; 717  : 					return (_Insert(true, _Where._Mynode(), _Val));

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert
$LN13@insert:

; 718  : 				}

	jmp	$LN31@insert
$LN14@insert:

; 719  : 			else if (_Where == end())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T242507[ebp], eax
	mov	ecx, DWORD PTR $T242507[ebp]
	mov	DWORD PTR $T242155[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T242155[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN11@insert

; 720  : 				{	// insert at end if after last element
; 721  : 				if (_DEBUG_LT_PRED(this->comp,

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 8
	mov	DWORD PTR $T242528[ebp], eax
	mov	ecx, DWORD PTR $T242528[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR $T242542[ebp], edx
	mov	eax, DWORD PTR $T242542[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN10@insert

; 722  : 					_Key(_Rmost()), this->_Kfn(_Val)))
; 723  : 					return (_Insert(false, _Rmost(), _Val));

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	push	0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert
$LN10@insert:

; 724  : 				}
; 725  : 			else if (_DEBUG_LT_PRED(this->comp,

	jmp	$LN31@insert
$LN11@insert:

; 726  : 				this->_Kfn(_Val), _Key(_Where._Mynode()))
; 727  : 				&& _DEBUG_LT_PRED(this->comp,

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T242557[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR $T242557[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax+12]
	sbb	edx, edx
	neg	edx
	movzx	eax, dl
	test	eax, eax
	je	$LN319@insert
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Next$[ebp], ecx
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Dec
	mov	edx, DWORD PTR __Next$[ebp]
	mov	DWORD PTR $T242586[ebp], edx
	mov	eax, DWORD PTR $T242586[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx]
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN319@insert

; 728  : 					_Key((--(_Next = _Where))._Mynode()), this->_Kfn(_Val)))
; 729  : 				{	// insert before _Where
; 730  : 				if (_Isnil(_Right(_Next._Mynode())))

	mov	edx, DWORD PTR __Next$[ebp]
	mov	DWORD PTR $T242606[ebp], edx
	mov	eax, DWORD PTR $T242606[ebp]
	mov	ecx, DWORD PTR [eax+8]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	je	SHORT $LN317@insert

; 731  : 					return (_Insert(false, _Next._Mynode(), _Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert

; 732  : 				else

	jmp	SHORT $LN6@insert

; 733  : 					return (_Insert(true, _Where._Mynode(), _Val));

$LN317@insert:
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert
$LN6@insert:

; 734  : 				}
; 735  : 			else if (_DEBUG_LT_PRED(this->comp,

	jmp	$LN31@insert

; 736  : 				_Key(_Where._Mynode()), this->_Kfn(_Val))
; 737  : 				&& (++(_Next = _Where) == end()
; 738  : 					|| _DEBUG_LT_PRED(this->comp,

$LN319@insert:
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T242625[ebp], eax
	mov	ecx, DWORD PTR $T242625[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	cmp	eax, DWORD PTR [edx]
	sbb	ecx, ecx
	neg	ecx
	movzx	edx, cl
	test	edx, edx
	je	$LN31@insert
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Next$[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T242651[ebp], edx
	mov	eax, DWORD PTR $T242651[ebp]
	mov	DWORD PTR $T242156[ebp], eax
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Inc
	mov	ecx, DWORD PTR __Next$[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T242156[ebp]
	sete	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN3@insert
	mov	ecx, DWORD PTR __Next$[ebp]
	mov	DWORD PTR $T242667[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR $T242667[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax+12]
	sbb	edx, edx
	neg	edx
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN31@insert
$LN3@insert:

; 739  : 						this->_Kfn(_Val), _Key(_Next._Mynode()))))
; 740  : 				{	// insert after _Where
; 741  : 				if (_Isnil(_Right(_Where._Mynode())))

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T242690[ebp], ecx
	mov	edx, DWORD PTR $T242690[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+21]
	test	ecx, ecx
	je	SHORT $LN361@insert

; 742  : 					return (_Insert(false, _Where._Mynode(), _Val));

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN33@insert

; 743  : 				else

	jmp	SHORT $LN31@insert

; 744  : 					return (_Insert(true, _Next._Mynode(), _Val));

$LN361@insert:
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Next$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN33@insert
$LN31@insert:

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	lea	eax, DWORD PTR $T242157[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::insert
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN33@insert:

; 749  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBIH@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::insert
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::clear
; Function compile flags: /Odtp
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z
_TEXT	SEGMENT
_this$ = -76						; size = 4
$T242923 = -72						; size = 4
$T242917 = -68						; size = 4
__Tmp$242905 = -48					; size = 4
$T242833 = -44						; size = 4
$T242820 = -40						; size = 4
$T242750 = -28						; size = 4
$T242727 = -24						; size = 4
$T242714 = -20						; size = 4
$T242708 = -16						; size = 4
$T242707 = -12						; size = 4
$T242706 = -8						; size = 4
$T242705 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase, COMDAT
; _this$ = ecx

; 934  : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	DWORD PTR _this$[ebp], ecx

; 935  : 		if (_First == begin() && _Last == end())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T242714[ebp], ecx
	mov	edx, DWORD PTR $T242714[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T242727[ebp], eax
	mov	ecx, DWORD PTR $T242727[ebp]
	mov	DWORD PTR $T242705[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T242705[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN72@erase
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T242750[ebp], eax
	mov	ecx, DWORD PTR $T242750[ebp]
	mov	DWORD PTR $T242706[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T242706[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN72@erase

; 936  : 			{	// erase all
; 937  : 			clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::clear

; 938  : 			return (begin());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T242820[ebp], eax
	mov	ecx, DWORD PTR $T242820[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T242833[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR $T242833[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN5@erase

; 939  : 			}
; 940  : 		else

	jmp	SHORT $LN5@erase

; 941  : 			{	// partial erase, one at a time
; 942  : 			while (_First != _Last)

$LN72@erase:
	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@erase

; 943  : 				erase(_First++);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$242905[ebp], eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Inc
	mov	ecx, DWORD PTR __Tmp$242905[ebp]
	mov	DWORD PTR $T242707[ebp], ecx
	mov	edx, DWORD PTR $T242707[ebp]
	push	edx
	lea	eax, DWORD PTR $T242708[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
	jmp	SHORT $LN72@erase
$LN1@erase:

; 944  : 			return (_Make_iter(_First));

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T242923[ebp], ecx
	mov	edx, DWORD PTR $T242923[ebp]
	mov	DWORD PTR $T242917[ebp], edx
	mov	eax, DWORD PTR $T242917[ebp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN5@erase:

; 945  : 			}
; 946  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
_TEXT	ENDS
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Copy
; Function compile flags: /Odtp
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T243041 = -40						; size = 4
$T243028 = -36						; size = 4
$T243007 = -32						; size = 4
$T242994 = -28						; size = 4
$T242989 = -24						; size = 4
$T242968 = -20						; size = 4
$T242956 = -16						; size = 4
$T242947 = -12						; size = 4
$T242943 = -8						; size = 4
$T242934 = -4						; size = 4
__Right$ = 8						; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Copy, COMDAT
; _this$ = ecx

; 1062 : 		{	// copy entire tree from _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1063 : 		_Root() = _Copy(_Right._Root(), _Myhead);

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T242934[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 4
	mov	DWORD PTR $T242943[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR $T242934[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Copy
	mov	edx, DWORD PTR $T242943[ebp]
	mov	DWORD PTR [edx], eax

; 1064 : 		_Mysize = _Right.size();

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T242947[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T242947[ebp]
	mov	DWORD PTR [edx+8], eax

; 1065 : 		if (!_Isnil(_Root()))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T242956[ebp], edx
	mov	eax, DWORD PTR $T242956[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	jne	SHORT $LN2@Copy

; 1066 : 			{	// nonempty tree, look for new smallest and largest
; 1067 : 			_Lmost() = _Min(_Root());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T242968[ebp], ecx
	mov	edx, DWORD PTR $T242968[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T242989[ebp], eax
$LN31@Copy:
	mov	ecx, DWORD PTR $T242989[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	SHORT $LN27@Copy
	mov	ecx, DWORD PTR $T242989[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T242989[ebp], edx
	jmp	SHORT $LN31@Copy
$LN27@Copy:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T242994[ebp], ecx
	mov	edx, DWORD PTR $T242994[ebp]
	mov	eax, DWORD PTR $T242989[ebp]
	mov	DWORD PTR [edx], eax

; 1068 : 			_Rmost() = _Max(_Root());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T243007[ebp], edx
	mov	eax, DWORD PTR $T243007[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T243028[ebp], ecx
$LN49@Copy:
	mov	edx, DWORD PTR $T243028[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+21]
	test	ecx, ecx
	jne	SHORT $LN53@Copy
	mov	edx, DWORD PTR $T243028[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T243028[ebp], eax
	jmp	SHORT $LN49@Copy
$LN53@Copy:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR $T243028[ebp]
	mov	DWORD PTR [edx+8], eax

; 1069 : 			}
; 1070 : 		else

	jmp	SHORT $LN3@Copy
$LN2@Copy:

; 1071 : 			_Lmost() = _Myhead, _Rmost() = _Myhead;	// empty tree

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T243041[ebp], edx
	mov	eax, DWORD PTR $T243041[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+8], eax
$LN3@Copy:

; 1072 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Copy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -92						; size = 4
$T243296 = -88						; size = 4
$T243262 = -84						; size = 4
$T243095 = -32						; size = 4
$T243082 = -28						; size = 4
$T243070 = -24						; size = 4
$T243060 = -20						; size = 4
$T243059 = -16						; size = 4
$T243058 = -12						; size = 4
$T243057 = -8						; size = 4
$T243056 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1420 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	DWORD PTR _this$[ebp], ecx

; 1421 : 		erase(begin(), end());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T243070[ebp], ecx
	mov	edx, DWORD PTR $T243070[ebp]
	mov	DWORD PTR $T243057[ebp], edx
	mov	eax, DWORD PTR $T243057[ebp]
	mov	DWORD PTR $T243056[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T243082[ebp], edx
	mov	eax, DWORD PTR $T243082[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T243095[ebp], ecx
	mov	edx, DWORD PTR $T243095[ebp]
	mov	DWORD PTR $T243059[ebp], edx
	mov	eax, DWORD PTR $T243059[ebp]
	mov	DWORD PTR $T243058[ebp], eax
	mov	ecx, DWORD PTR $T243056[ebp]
	push	ecx
	mov	edx, DWORD PTR $T243058[ebp]
	push	edx
	lea	eax, DWORD PTR $T243060[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase

; 1422 : 		this->_Alptr.destroy(&_Left(_Myhead));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T243262[ebp], edx

; 1423 : 		this->_Alptr.destroy(&_Parent(_Myhead));
; 1424 : 		this->_Alptr.destroy(&_Right(_Myhead));
; 1425 : 		this->_Alnod.deallocate(_Myhead, 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T243296[ebp], ecx
	mov	edx, DWORD PTR $T243296[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1426 : 		_Myhead = 0, _Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 1427 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Insert_n
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?insert@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
__Tmp$243356 = -24					; size = 4
$T243334 = -20						; size = 4
$T243315 = -16						; size = 4
$T243302 = -12						; size = 4
$T243299 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	test	eax, eax
	jne	SHORT $LN3@insert@2
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert@2
$LN3@insert@2:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T243315[ebp], eax
	mov	ecx, DWORD PTR $T243315[ebp]
	mov	DWORD PTR $T243299[ebp], ecx
	mov	eax, DWORD PTR __Where$[ebp]
	sub	eax, DWORD PTR $T243299[ebp]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert@2:
	mov	edx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], edx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T243334[ebp], eax
	mov	ecx, DWORD PTR $T243334[ebp]
	mov	DWORD PTR $T243302[ebp], ecx
	mov	edx, DWORD PTR $T243302[ebp]
	mov	DWORD PTR __Tmp$243356[ebp], edx
	mov	eax, DWORD PTR __Off$[ebp]
	imul	eax, 28					; 0000001cH
	add	eax, DWORD PTR __Tmp$243356[ebp]
	mov	DWORD PTR __Tmp$243356[ebp], eax
	mov	ecx, DWORD PTR __Tmp$243356[ebp]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::insert
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?erase@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@0@Z
_TEXT	SEGMENT
_this$ = -72						; size = 4
$T243518 = -68						; size = 4
$T243497 = -64						; size = 4
$T243496 = -60						; size = 4
$T243477 = -56						; size = 4
$T243476 = -52						; size = 4
__Cat$243503 = -46					; size = 1
$T243501 = -45						; size = 1
$T243437 = -44						; size = 4
$T243436 = -40						; size = 4
$T243435 = -36						; size = 4
$T243418 = -30						; size = 1
$T243417 = -29						; size = 1
$T243416 = -28						; size = 4
$T243415 = -24						; size = 4
__Cat$243424 = -16					; size = 1
$T243422 = -15						; size = 1
$T243421 = -14						; size = 1
$T243420 = -13						; size = 1
__Ptr$223246 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@0@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	$LN1@erase@2

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T243437[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T243436[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T243435[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T243420[ebp], cl
	mov	dl, BYTE PTR __Cat$243424[ebp]
	mov	BYTE PTR $T243421[ebp], dl
	mov	al, BYTE PTR $T243420[ebp]
	mov	BYTE PTR $T243418[ebp], al
	mov	cl, BYTE PTR $T243422[ebp]
	mov	BYTE PTR $T243417[ebp], cl
	mov	edx, DWORD PTR $T243437[ebp]
	mov	DWORD PTR $T243416[ebp], edx
	mov	eax, DWORD PTR $T243435[ebp]
	mov	DWORD PTR $T243415[ebp], eax
	jmp	SHORT $LN28@erase@2
$LN27@erase@2:
	mov	ecx, DWORD PTR $T243416[ebp]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR $T243416[ebp], ecx
	mov	edx, DWORD PTR $T243415[ebp]
	add	edx, 28					; 0000001cH
	mov	DWORD PTR $T243415[ebp], edx
$LN28@erase@2:
	mov	eax, DWORD PTR $T243415[ebp]
	cmp	eax, DWORD PTR $T243436[ebp]
	je	SHORT $LN20@erase@2
	mov	ecx, DWORD PTR $T243415[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T243416[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	jmp	SHORT $LN27@erase@2
$LN20@erase@2:
	mov	edx, DWORD PTR $T243416[ebp]
	mov	DWORD PTR __Ptr$223246[ebp], edx

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T243518[ebp], ecx
	mov	edx, DWORD PTR $T243518[ebp]
	mov	DWORD PTR $T243497[ebp], edx
	mov	eax, DWORD PTR __Ptr$223246[ebp]
	mov	DWORD PTR $T243496[ebp], eax
	mov	cl, BYTE PTR __Cat$243503[ebp]
	mov	BYTE PTR $T243501[ebp], cl
	mov	edx, DWORD PTR $T243497[ebp]
	mov	DWORD PTR $T243477[ebp], edx
	mov	eax, DWORD PTR $T243496[ebp]
	mov	DWORD PTR $T243476[ebp], eax
	jmp	SHORT $LN39@erase@2
$LN38@erase@2:
	mov	ecx, DWORD PTR $T243476[ebp]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR $T243476[ebp], ecx
$LN39@erase@2:
	mov	edx, DWORD PTR $T243476[ebp]
	cmp	edx, DWORD PTR $T243477[ebp]
	je	SHORT $LN31@erase@2
	mov	ecx, DWORD PTR $T243476[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	xor	eax, eax
	and	eax, 1
	je	SHORT $LN42@erase@2
	mov	ecx, DWORD PTR $T243476[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN42@erase@2:
	jmp	SHORT $LN38@erase@2
$LN31@erase@2:

; 1049 : 			_Mylast = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$223246[ebp]
	mov	DWORD PTR [edx+8], eax
$LN1@erase@2:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@0@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::erase
_TEXT	ENDS
PUBLIC	??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$243536 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE_NI@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy
	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$243536[ebp], 153391689 ; 09249249H
	cmp	DWORD PTR __Count$243536[ebp], 0
	jbe	SHORT $LN11@Buy
	mov	eax, DWORD PTR __Count$243536[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy
$LN11@Buy:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], edx
$LN3@Buy:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE_NI@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T243649 = -36						; size = 4
$T243648 = -32						; size = 4
$T243644 = -28						; size = 4
$T243643 = -24						; size = 4
$T243622 = -20						; size = 4
$T243621 = -16						; size = 4
$T243602 = -12						; size = 4
$T243601 = -8						; size = 4
__Cat$243628 = -2					; size = 1
$T243626 = -1						; size = 1
?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	$LN1@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T243644[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T243643[ebp], ecx
	mov	edx, DWORD PTR $T243644[ebp]
	mov	DWORD PTR $T243622[ebp], edx
	mov	eax, DWORD PTR $T243643[ebp]
	mov	DWORD PTR $T243621[ebp], eax
	mov	cl, BYTE PTR __Cat$243628[ebp]
	mov	BYTE PTR $T243626[ebp], cl
	mov	edx, DWORD PTR $T243622[ebp]
	mov	DWORD PTR $T243602[ebp], edx
	mov	eax, DWORD PTR $T243621[ebp]
	mov	DWORD PTR $T243601[ebp], eax
	jmp	SHORT $LN12@Tidy
$LN11@Tidy:
	mov	ecx, DWORD PTR $T243601[ebp]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR $T243601[ebp], ecx
$LN12@Tidy:
	mov	edx, DWORD PTR $T243601[ebp]
	cmp	edx, DWORD PTR $T243602[ebp]
	je	SHORT $LN4@Tidy
	mov	ecx, DWORD PTR $T243601[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	xor	eax, eax
	and	eax, 1
	je	SHORT $LN15@Tidy
	mov	ecx, DWORD PTR $T243601[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN15@Tidy:
	jmp	SHORT $LN11@Tidy
$LN4@Tidy:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	mov	DWORD PTR $T243649[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T243648[ebp], eax
	mov	ecx, DWORD PTR $T243648[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@V?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@ABVCvReplayMessage@@@Z
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
__Tmp$243704 = -24					; size = 4
$T243687 = -20						; size = 4
$T243668 = -16						; size = 4
$T243655 = -12						; size = 4
$T243652 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@V?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@ABVCvReplayMessage@@@Z PROC ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 60					; 0000003cH
	idiv	ecx
	test	eax, eax
	jne	SHORT $LN3@insert@3
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert@3
$LN3@insert@3:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T243668[ebp], eax
	mov	ecx, DWORD PTR $T243668[ebp]
	mov	DWORD PTR $T243652[ebp], ecx
	mov	eax, DWORD PTR __Where$[ebp]
	sub	eax, DWORD PTR $T243652[ebp]
	cdq
	mov	ecx, 60					; 0000003cH
	idiv	ecx
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert@3:
	mov	edx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], edx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T243687[ebp], eax
	mov	ecx, DWORD PTR $T243687[ebp]
	mov	DWORD PTR $T243655[ebp], ecx
	mov	edx, DWORD PTR $T243655[ebp]
	mov	DWORD PTR __Tmp$243704[ebp], edx
	mov	eax, DWORD PTR __Off$[ebp]
	imul	eax, 60					; 0000003cH
	add	eax, DWORD PTR __Tmp$243704[ebp]
	mov	DWORD PTR __Tmp$243704[ebp], eax
	mov	ecx, DWORD PTR __Tmp$243704[ebp]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@V?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@ABVCvReplayMessage@@@Z ENDP ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::insert
_TEXT	ENDS
PUBLIC	??4CvReplayMessage@@QAEAAV0@ABV0@@Z		; CvReplayMessage::operator=
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@V?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -164						; size = 4
$T244024 = -160						; size = 4
$T244006 = -156						; size = 4
$T244005 = -152						; size = 4
$T243989 = -148						; size = 4
$T243988 = -144						; size = 4
__Cat$244013 = -138					; size = 1
$T244011 = -137						; size = 1
$T243962 = -136						; size = 4
$T243961 = -132						; size = 4
$T243960 = -128						; size = 4
$T243943 = -122						; size = 1
$T243942 = -121						; size = 1
$T243941 = -120						; size = 4
$T243940 = -116						; size = 4
__Cat$243950 = -16					; size = 1
$T243947 = -15						; size = 1
$T243946 = -14						; size = 1
$T243945 = -13						; size = 1
__Ptr$223307 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@V?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@0@Z PROC ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 164				; 000000a4H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	$LN1@erase@3

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T243962[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T243961[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T243960[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T243945[ebp], cl
	mov	dl, BYTE PTR __Cat$243950[ebp]
	mov	BYTE PTR $T243946[ebp], dl
	mov	al, BYTE PTR $T243945[ebp]
	mov	BYTE PTR $T243943[ebp], al
	mov	cl, BYTE PTR $T243947[ebp]
	mov	BYTE PTR $T243942[ebp], cl
	mov	edx, DWORD PTR $T243962[ebp]
	mov	DWORD PTR $T243941[ebp], edx
	mov	eax, DWORD PTR $T243960[ebp]
	mov	DWORD PTR $T243940[ebp], eax
	jmp	SHORT $LN28@erase@3
$LN27@erase@3:
	mov	ecx, DWORD PTR $T243941[ebp]
	add	ecx, 60					; 0000003cH
	mov	DWORD PTR $T243941[ebp], ecx
	mov	edx, DWORD PTR $T243940[ebp]
	add	edx, 60					; 0000003cH
	mov	DWORD PTR $T243940[ebp], edx
$LN28@erase@3:
	mov	eax, DWORD PTR $T243940[ebp]
	cmp	eax, DWORD PTR $T243961[ebp]
	je	SHORT $LN20@erase@3
	mov	ecx, DWORD PTR $T243940[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T243941[ebp]
	call	??4CvReplayMessage@@QAEAAV0@ABV0@@Z
	jmp	SHORT $LN27@erase@3
$LN20@erase@3:
	mov	edx, DWORD PTR $T243941[ebp]
	mov	DWORD PTR __Ptr$223307[ebp], edx

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T244024[ebp], ecx
	mov	edx, DWORD PTR $T244024[ebp]
	mov	DWORD PTR $T244006[ebp], edx
	mov	eax, DWORD PTR __Ptr$223307[ebp]
	mov	DWORD PTR $T244005[ebp], eax
	mov	cl, BYTE PTR __Cat$244013[ebp]
	mov	BYTE PTR $T244011[ebp], cl
	mov	edx, DWORD PTR $T244006[ebp]
	mov	DWORD PTR $T243989[ebp], edx
	mov	eax, DWORD PTR $T244005[ebp]
	mov	DWORD PTR $T243988[ebp], eax
	jmp	SHORT $LN106@erase@3
$LN105@erase@3:
	mov	ecx, DWORD PTR $T243988[ebp]
	add	ecx, 60					; 0000003cH
	mov	DWORD PTR $T243988[ebp], ecx
$LN106@erase@3:
	mov	edx, DWORD PTR $T243988[ebp]
	cmp	edx, DWORD PTR $T243989[ebp]
	je	SHORT $LN98@erase@3
	push	0
	mov	eax, DWORD PTR $T243988[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T243988[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	jmp	SHORT $LN105@erase@3
$LN98@erase@3:

; 1049 : 			_Mylast = _Ptr;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Ptr$223307[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN1@erase@3:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@V?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@0@Z ENDP ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::erase
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$244039 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@2

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@2
	jmp	SHORT $LN3@Buy@2
$LN4@Buy@2:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$244039[ebp], 71582788	; 04444444H
	cmp	DWORD PTR __Count$244039[ebp], 0
	jbe	SHORT $LN11@Buy@2
	mov	eax, DWORD PTR __Count$244039[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy@2
$LN11@Buy@2:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy@2:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy@2

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@KAXXZ ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@2

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy@2:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@VCvReplayMessage@@@std@@YAPAVCvReplayMessage@@IPAV1@@Z ; std::_Allocate<CvReplayMessage>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], edx
$LN3@Buy@2:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@2:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T244136 = -36						; size = 4
$T244135 = -32						; size = 4
$T244131 = -28						; size = 4
$T244130 = -24						; size = 4
$T244112 = -20						; size = 4
$T244111 = -16						; size = 4
$T244095 = -12						; size = 4
$T244094 = -8						; size = 4
__Cat$244119 = -2					; size = 1
$T244117 = -1						; size = 1
?_Tidy@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXXZ PROC ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy@2

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T244131[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T244130[ebp], ecx
	mov	edx, DWORD PTR $T244131[ebp]
	mov	DWORD PTR $T244112[ebp], edx
	mov	eax, DWORD PTR $T244130[ebp]
	mov	DWORD PTR $T244111[ebp], eax
	mov	cl, BYTE PTR __Cat$244119[ebp]
	mov	BYTE PTR $T244117[ebp], cl
	mov	edx, DWORD PTR $T244112[ebp]
	mov	DWORD PTR $T244095[ebp], edx
	mov	eax, DWORD PTR $T244111[ebp]
	mov	DWORD PTR $T244094[ebp], eax
	jmp	SHORT $LN12@Tidy@2
$LN11@Tidy@2:
	mov	ecx, DWORD PTR $T244094[ebp]
	add	ecx, 60					; 0000003cH
	mov	DWORD PTR $T244094[ebp], ecx
$LN12@Tidy@2:
	mov	edx, DWORD PTR $T244094[ebp]
	cmp	edx, DWORD PTR $T244095[ebp]
	je	SHORT $LN4@Tidy@2
	push	0
	mov	eax, DWORD PTR $T244094[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T244094[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	jmp	SHORT $LN11@Tidy@2
$LN4@Tidy@2:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 60					; 0000003cH
	idiv	ecx
	mov	DWORD PTR $T244136[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T244135[ebp], eax
	mov	ecx, DWORD PTR $T244135[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy@2:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Tidy
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_Elength_error@std@@UAEPAXI@Z ; std::length_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_Elogic_error@std@@UAEPAXI@Z ; std::logic_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T244140 = -80						; size = 28
$T244139 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@KAXXZ PROC ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T244140[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T244139[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T244139[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T244140[ebp]
	push	eax
	lea	ecx, DWORD PTR $T244139[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T244139[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T244139[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T244140[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T244140[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T244139[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@KAXXZ ENDP ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Xlen
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 34   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 36   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar@3
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@

; 110  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	edx, DWORD PTR ___flags$[ebp]
	and	edx, 1
	je	SHORT $LN1@scalar@4
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAE_NI@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Buy
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Construct_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXIABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$10 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Construct_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXIABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$0
__unwindtable$?_Construct_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXIABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Construct_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXIABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Construct_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXIABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$10
__ehfuncinfo$?_Construct_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXIABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Construct_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXIABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Construct_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXIABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Construct_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXIABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z
_TEXT	SEGMENT
_this$ = -196						; size = 4
$T244246 = -116						; size = 4
$T244236 = -112						; size = 4
__Cat$244244 = -107					; size = 1
$T244242 = -106						; size = 1
$T244241 = -105						; size = 1
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
__Val$ = 12						; size = 4
?_Construct_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXIABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Construct_n, COMDAT
; _this$ = ecx

; 545  : 		{	// construct from _Count * _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Construct_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXIABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 180				; 000000b4H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 546  : 		if (_Buy(_Count))

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAE_NI@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	$LN4@Construct_

; 547  : 			{	// nonzero, fill it
; 548  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 549  : 			_Mylast = _Ufill(_Myfirst, _Count, _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T244246[ebp], eax
	mov	ecx, DWORD PTR $T244246[ebp]
	mov	DWORD PTR $T244236[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T244241[ebp], dl
	mov	al, BYTE PTR __Cat$244244[ebp]
	mov	BYTE PTR $T244242[ebp], al
	movzx	ecx, BYTE PTR $T244241[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T244242[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR $T244236[ebp]
	push	eax
	call	??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,unsigned int,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 12					; 0000000cH
	add	ecx, DWORD PTR $T244246[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
	jmp	SHORT $LN5@Construct_
__catch$?_Construct_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXIABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$0:

; 550  : 			_CATCH_ALL
; 551  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Tidy

; 552  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 553  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN4@Construct_
	ret	0
$LN5@Construct_:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN4@Construct_:

; 554  : 			}
; 555  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Construct_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXIABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-200]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Construct_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXIABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Construct_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXIABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Construct_n
PUBLIC	?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@ABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
__Tmp$244640 = -24					; size = 4
$T244623 = -20						; size = 4
$T244604 = -16						; size = 4
$T244591 = -12						; size = 4
$T244588 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@ABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	test	eax, eax
	jne	SHORT $LN3@insert@4
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert@4
$LN3@insert@4:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T244604[ebp], eax
	mov	ecx, DWORD PTR $T244604[ebp]
	mov	DWORD PTR $T244588[ebp], ecx
	mov	eax, DWORD PTR __Where$[ebp]
	sub	eax, DWORD PTR $T244588[ebp]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert@4:
	mov	edx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], edx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T244623[ebp], eax
	mov	ecx, DWORD PTR $T244623[ebp]
	mov	DWORD PTR $T244591[ebp], ecx
	mov	edx, DWORD PTR $T244591[ebp]
	mov	DWORD PTR __Tmp$244640[ebp], edx
	mov	eax, DWORD PTR __Off$[ebp]
	imul	eax, 12					; 0000000cH
	add	eax, DWORD PTR __Tmp$244640[ebp]
	mov	DWORD PTR __Tmp$244640[ebp], eax
	mov	ecx, DWORD PTR __Tmp$244640[ebp]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@ABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::insert
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?_Tidy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Tidy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXXZ$1
__ehfuncinfo$?_Tidy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Tidy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Tidy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -136						; size = 4
$T245095 = -132						; size = 4
$T245094 = -128						; size = 4
$T245090 = -124						; size = 4
$T245089 = -120						; size = 4
$T245054 = -116						; size = 4
$T245053 = -112						; size = 4
$T245020 = -108						; size = 4
$T245019 = -104						; size = 4
__Cat$245086 = -14					; size = 1
$T245084 = -13						; size = 1
__$EHRec$ = -12						; size = 12
?_Tidy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXXZ PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Tidy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 124				; 0000007cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	$LN1@Tidy@3

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T245090[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T245089[ebp], ecx
	mov	edx, DWORD PTR $T245090[ebp]
	mov	DWORD PTR $T245054[ebp], edx
	mov	eax, DWORD PTR $T245089[ebp]
	mov	DWORD PTR $T245053[ebp], eax
	mov	cl, BYTE PTR __Cat$245086[ebp]
	mov	BYTE PTR $T245084[ebp], cl
	mov	edx, DWORD PTR $T245054[ebp]
	mov	DWORD PTR $T245020[ebp], edx
	mov	eax, DWORD PTR $T245053[ebp]
	mov	DWORD PTR $T245019[ebp], eax
	jmp	SHORT $LN12@Tidy@3
$LN11@Tidy@3:
	mov	ecx, DWORD PTR $T245019[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR $T245019[ebp], ecx
$LN12@Tidy@3:
	mov	edx, DWORD PTR $T245019[ebp]
	cmp	edx, DWORD PTR $T245020[ebp]
	je	SHORT $LN4@Tidy@3
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR $T245019[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	xor	eax, eax
	and	eax, 1
	je	SHORT $LN15@Tidy@3
	mov	ecx, DWORD PTR $T245019[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN15@Tidy@3:
	jmp	SHORT $LN11@Tidy@3
$LN4@Tidy@3:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR $T245095[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T245094[ebp], eax
	mov	ecx, DWORD PTR $T245094[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy@3:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Tidy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXXZ$1:
	mov	ecx, DWORD PTR $T245019[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$?_Tidy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-128]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Tidy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Tidy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXXZ ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Tidy
PUBLIC	?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@V?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@ABW4GameOptionTypes@@@Z
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
__Tmp$245161 = -24					; size = 4
$T245139 = -20						; size = 4
$T245120 = -16						; size = 4
$T245107 = -12						; size = 4
$T245104 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@V?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@ABW4GameOptionTypes@@@Z PROC ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	test	edx, edx
	jne	SHORT $LN3@insert@5
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert@5
$LN3@insert@5:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T245120[ebp], ecx
	mov	edx, DWORD PTR $T245120[ebp]
	mov	DWORD PTR $T245104[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	sub	eax, DWORD PTR $T245104[ebp]
	sar	eax, 2
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert@5:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T245139[ebp], edx
	mov	eax, DWORD PTR $T245139[ebp]
	mov	DWORD PTR $T245107[ebp], eax
	mov	ecx, DWORD PTR $T245107[ebp]
	mov	DWORD PTR __Tmp$245161[ebp], ecx
	mov	edx, DWORD PTR __Off$[ebp]
	mov	eax, DWORD PTR __Tmp$245161[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR __Tmp$245161[ebp], ecx
	mov	edx, DWORD PTR __Tmp$245161[ebp]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@V?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@ABW4GameOptionTypes@@@Z ENDP ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::insert
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?erase@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@V?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
$T245303 = -64						; size = 4
$T245285 = -60						; size = 4
$T245284 = -56						; size = 4
$T245268 = -52						; size = 4
__Cat$245292 = -46					; size = 1
$T245290 = -45						; size = 1
$T245242 = -44						; size = 4
$T245241 = -40						; size = 4
$T245240 = -36						; size = 4
$T245223 = -30						; size = 1
$T245222 = -29						; size = 1
$T245221 = -28						; size = 4
$T245220 = -24						; size = 4
__Cat$245230 = -16					; size = 1
$T245228 = -15						; size = 1
$T245227 = -14						; size = 1
$T245226 = -13						; size = 1
__Ptr$223439 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@V?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@0@Z PROC ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	$LN1@erase@4

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T245242[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T245241[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T245240[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T245226[ebp], cl
	mov	dl, BYTE PTR __Cat$245230[ebp]
	mov	BYTE PTR $T245227[ebp], dl
	mov	al, BYTE PTR $T245226[ebp]
	mov	BYTE PTR $T245223[ebp], al
	mov	cl, BYTE PTR $T245228[ebp]
	mov	BYTE PTR $T245222[ebp], cl
	mov	edx, DWORD PTR $T245242[ebp]
	mov	DWORD PTR $T245221[ebp], edx
	mov	eax, DWORD PTR $T245240[ebp]
	mov	DWORD PTR $T245220[ebp], eax
	jmp	SHORT $LN28@erase@4
$LN27@erase@4:
	mov	ecx, DWORD PTR $T245221[ebp]
	add	ecx, 4
	mov	DWORD PTR $T245221[ebp], ecx
	mov	edx, DWORD PTR $T245220[ebp]
	add	edx, 4
	mov	DWORD PTR $T245220[ebp], edx
$LN28@erase@4:
	mov	eax, DWORD PTR $T245220[ebp]
	cmp	eax, DWORD PTR $T245241[ebp]
	je	SHORT $LN20@erase@4
	mov	ecx, DWORD PTR $T245221[ebp]
	mov	edx, DWORD PTR $T245220[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN27@erase@4
$LN20@erase@4:
	mov	ecx, DWORD PTR $T245221[ebp]
	mov	DWORD PTR __Ptr$223439[ebp], ecx

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T245303[ebp], eax
	mov	ecx, DWORD PTR $T245303[ebp]
	mov	DWORD PTR $T245285[ebp], ecx
	mov	edx, DWORD PTR __Ptr$223439[ebp]
	mov	DWORD PTR $T245284[ebp], edx
	mov	al, BYTE PTR __Cat$245292[ebp]
	mov	BYTE PTR $T245290[ebp], al
	mov	ecx, DWORD PTR $T245284[ebp]
	mov	DWORD PTR $T245268[ebp], ecx
	jmp	SHORT $LN39@erase@4
$LN38@erase@4:
	mov	edx, DWORD PTR $T245268[ebp]
	add	edx, 4
	mov	DWORD PTR $T245268[ebp], edx
$LN39@erase@4:
	mov	eax, DWORD PTR $T245268[ebp]
	cmp	eax, DWORD PTR $T245285[ebp]
	je	SHORT $LN31@erase@4
	jmp	SHORT $LN38@erase@4
$LN31@erase@4:

; 1049 : 			_Mylast = _Ptr;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Ptr$223439[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN1@erase@4:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@V?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@0@Z ENDP ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::erase
_TEXT	ENDS
PUBLIC	??$_Allocate@W4GameOptionTypes@@@std@@YAPAW4GameOptionTypes@@IPAW41@@Z ; std::_Allocate<enum GameOptionTypes>
PUBLIC	?_Xlen@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@KAXXZ ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$245318 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAE_NI@Z PROC ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@3

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@3
	jmp	SHORT $LN3@Buy@3
$LN4@Buy@3:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$245318[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$245318[ebp], 0
	jbe	SHORT $LN11@Buy@3
	mov	eax, DWORD PTR __Count$245318[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy@3
$LN11@Buy@3:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy@3:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy@3

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@KAXXZ ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@3

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy@3:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@W4GameOptionTypes@@@std@@YAPAW4GameOptionTypes@@IPAW41@@Z ; std::_Allocate<enum GameOptionTypes>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy@3:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@3:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T245414 = -32						; size = 4
$T245413 = -28						; size = 4
$T245409 = -24						; size = 4
$T245408 = -20						; size = 4
$T245390 = -16						; size = 4
$T245389 = -12						; size = 4
$T245373 = -8						; size = 4
__Cat$245397 = -2					; size = 1
$T245395 = -1						; size = 1
?_Tidy@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXXZ PROC ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy@4

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T245409[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T245408[ebp], ecx
	mov	edx, DWORD PTR $T245409[ebp]
	mov	DWORD PTR $T245390[ebp], edx
	mov	eax, DWORD PTR $T245408[ebp]
	mov	DWORD PTR $T245389[ebp], eax
	mov	cl, BYTE PTR __Cat$245397[ebp]
	mov	BYTE PTR $T245395[ebp], cl
	mov	edx, DWORD PTR $T245389[ebp]
	mov	DWORD PTR $T245373[ebp], edx
	jmp	SHORT $LN12@Tidy@4
$LN11@Tidy@4:
	mov	eax, DWORD PTR $T245373[ebp]
	add	eax, 4
	mov	DWORD PTR $T245373[ebp], eax
$LN12@Tidy@4:
	mov	ecx, DWORD PTR $T245373[ebp]
	cmp	ecx, DWORD PTR $T245390[ebp]
	je	SHORT $LN4@Tidy@4
	jmp	SHORT $LN11@Tidy@4
$LN4@Tidy@4:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR $T245414[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T245413[ebp], eax
	mov	ecx, DWORD PTR $T245413[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy@4:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXXZ ENDP ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@V?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@ABW4VictoryTypes@@@Z
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
__Tmp$245474 = -24					; size = 4
$T245452 = -20						; size = 4
$T245433 = -16						; size = 4
$T245420 = -12						; size = 4
$T245417 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@V?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@ABW4VictoryTypes@@@Z PROC ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	test	edx, edx
	jne	SHORT $LN3@insert@6
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert@6
$LN3@insert@6:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T245433[ebp], ecx
	mov	edx, DWORD PTR $T245433[ebp]
	mov	DWORD PTR $T245417[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	sub	eax, DWORD PTR $T245417[ebp]
	sar	eax, 2
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert@6:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T245452[ebp], edx
	mov	eax, DWORD PTR $T245452[ebp]
	mov	DWORD PTR $T245420[ebp], eax
	mov	ecx, DWORD PTR $T245420[ebp]
	mov	DWORD PTR __Tmp$245474[ebp], ecx
	mov	edx, DWORD PTR __Off$[ebp]
	mov	eax, DWORD PTR __Tmp$245474[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR __Tmp$245474[ebp], ecx
	mov	edx, DWORD PTR __Tmp$245474[ebp]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@V?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@ABW4VictoryTypes@@@Z ENDP ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::insert
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?erase@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@V?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
$T245616 = -64						; size = 4
$T245598 = -60						; size = 4
$T245597 = -56						; size = 4
$T245581 = -52						; size = 4
__Cat$245605 = -46					; size = 1
$T245603 = -45						; size = 1
$T245555 = -44						; size = 4
$T245554 = -40						; size = 4
$T245553 = -36						; size = 4
$T245536 = -30						; size = 1
$T245535 = -29						; size = 1
$T245534 = -28						; size = 4
$T245533 = -24						; size = 4
__Cat$245543 = -16					; size = 1
$T245541 = -15						; size = 1
$T245540 = -14						; size = 1
$T245539 = -13						; size = 1
__Ptr$223502 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@V?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@0@Z PROC ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	$LN1@erase@5

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T245555[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T245554[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T245553[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T245539[ebp], cl
	mov	dl, BYTE PTR __Cat$245543[ebp]
	mov	BYTE PTR $T245540[ebp], dl
	mov	al, BYTE PTR $T245539[ebp]
	mov	BYTE PTR $T245536[ebp], al
	mov	cl, BYTE PTR $T245541[ebp]
	mov	BYTE PTR $T245535[ebp], cl
	mov	edx, DWORD PTR $T245555[ebp]
	mov	DWORD PTR $T245534[ebp], edx
	mov	eax, DWORD PTR $T245553[ebp]
	mov	DWORD PTR $T245533[ebp], eax
	jmp	SHORT $LN28@erase@5
$LN27@erase@5:
	mov	ecx, DWORD PTR $T245534[ebp]
	add	ecx, 4
	mov	DWORD PTR $T245534[ebp], ecx
	mov	edx, DWORD PTR $T245533[ebp]
	add	edx, 4
	mov	DWORD PTR $T245533[ebp], edx
$LN28@erase@5:
	mov	eax, DWORD PTR $T245533[ebp]
	cmp	eax, DWORD PTR $T245554[ebp]
	je	SHORT $LN20@erase@5
	mov	ecx, DWORD PTR $T245534[ebp]
	mov	edx, DWORD PTR $T245533[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN27@erase@5
$LN20@erase@5:
	mov	ecx, DWORD PTR $T245534[ebp]
	mov	DWORD PTR __Ptr$223502[ebp], ecx

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T245616[ebp], eax
	mov	ecx, DWORD PTR $T245616[ebp]
	mov	DWORD PTR $T245598[ebp], ecx
	mov	edx, DWORD PTR __Ptr$223502[ebp]
	mov	DWORD PTR $T245597[ebp], edx
	mov	al, BYTE PTR __Cat$245605[ebp]
	mov	BYTE PTR $T245603[ebp], al
	mov	ecx, DWORD PTR $T245597[ebp]
	mov	DWORD PTR $T245581[ebp], ecx
	jmp	SHORT $LN39@erase@5
$LN38@erase@5:
	mov	edx, DWORD PTR $T245581[ebp]
	add	edx, 4
	mov	DWORD PTR $T245581[ebp], edx
$LN39@erase@5:
	mov	eax, DWORD PTR $T245581[ebp]
	cmp	eax, DWORD PTR $T245598[ebp]
	je	SHORT $LN31@erase@5
	jmp	SHORT $LN38@erase@5
$LN31@erase@5:

; 1049 : 			_Mylast = _Ptr;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Ptr$223502[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN1@erase@5:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@V?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@0@Z ENDP ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::erase
_TEXT	ENDS
PUBLIC	??$_Allocate@W4VictoryTypes@@@std@@YAPAW4VictoryTypes@@IPAW41@@Z ; std::_Allocate<enum VictoryTypes>
PUBLIC	?_Xlen@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@KAXXZ ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$245631 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAE_NI@Z PROC ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@4

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@4
	jmp	SHORT $LN3@Buy@4
$LN4@Buy@4:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$245631[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$245631[ebp], 0
	jbe	SHORT $LN11@Buy@4
	mov	eax, DWORD PTR __Count$245631[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy@4
$LN11@Buy@4:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy@4:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy@4

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@KAXXZ ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@4

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy@4:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@W4VictoryTypes@@@std@@YAPAW4VictoryTypes@@IPAW41@@Z ; std::_Allocate<enum VictoryTypes>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy@4:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@4:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T245727 = -32						; size = 4
$T245726 = -28						; size = 4
$T245722 = -24						; size = 4
$T245721 = -20						; size = 4
$T245703 = -16						; size = 4
$T245702 = -12						; size = 4
$T245686 = -8						; size = 4
__Cat$245710 = -2					; size = 1
$T245708 = -1						; size = 1
?_Tidy@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXXZ PROC ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy@5

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T245722[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T245721[ebp], ecx
	mov	edx, DWORD PTR $T245722[ebp]
	mov	DWORD PTR $T245703[ebp], edx
	mov	eax, DWORD PTR $T245721[ebp]
	mov	DWORD PTR $T245702[ebp], eax
	mov	cl, BYTE PTR __Cat$245710[ebp]
	mov	BYTE PTR $T245708[ebp], cl
	mov	edx, DWORD PTR $T245702[ebp]
	mov	DWORD PTR $T245686[ebp], edx
	jmp	SHORT $LN12@Tidy@5
$LN11@Tidy@5:
	mov	eax, DWORD PTR $T245686[ebp]
	add	eax, 4
	mov	DWORD PTR $T245686[ebp], eax
$LN12@Tidy@5:
	mov	ecx, DWORD PTR $T245686[ebp]
	cmp	ecx, DWORD PTR $T245703[ebp]
	je	SHORT $LN4@Tidy@5
	jmp	SHORT $LN11@Tidy@5
$LN4@Tidy@5:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR $T245727[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T245726[ebp], eax
	mov	ecx, DWORD PTR $T245726[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy@5:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXXZ ENDP ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@V?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@ABUPlayerInfo@CvReplayInfo@@@Z
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
__Tmp$245787 = -24					; size = 4
$T245765 = -20						; size = 4
$T245746 = -16						; size = 4
$T245733 = -12						; size = 4
$T245730 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@V?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@ABUPlayerInfo@CvReplayInfo@@@Z PROC ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 7
	test	edx, edx
	jne	SHORT $LN3@insert@7
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert@7
$LN3@insert@7:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T245746[ebp], ecx
	mov	edx, DWORD PTR $T245746[ebp]
	mov	DWORD PTR $T245730[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	sub	eax, DWORD PTR $T245730[ebp]
	sar	eax, 7
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert@7:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T245765[ebp], edx
	mov	eax, DWORD PTR $T245765[ebp]
	mov	DWORD PTR $T245733[ebp], eax
	mov	ecx, DWORD PTR $T245733[ebp]
	mov	DWORD PTR __Tmp$245787[ebp], ecx
	mov	edx, DWORD PTR __Off$[ebp]
	shl	edx, 7
	add	edx, DWORD PTR __Tmp$245787[ebp]
	mov	DWORD PTR __Tmp$245787[ebp], edx
	mov	eax, DWORD PTR __Tmp$245787[ebp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@V?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@ABUPlayerInfo@CvReplayInfo@@@Z ENDP ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::insert
_TEXT	ENDS
PUBLIC	??4PlayerInfo@CvReplayInfo@@QAEAAU01@ABU01@@Z	; CvReplayInfo::PlayerInfo::operator=
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@V?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -104						; size = 4
$T245991 = -100						; size = 4
$T245970 = -96						; size = 4
$T245969 = -92						; size = 4
$T245950 = -88						; size = 4
$T245949 = -84						; size = 4
__Cat$245976 = -62					; size = 1
$T245973 = -61						; size = 1
$T245885 = -60						; size = 4
$T245884 = -56						; size = 4
$T245883 = -52						; size = 4
$T245866 = -46						; size = 1
$T245865 = -45						; size = 1
$T245864 = -44						; size = 4
$T245863 = -40						; size = 4
__Cat$245873 = -16					; size = 1
$T245870 = -15						; size = 1
$T245869 = -14						; size = 1
$T245868 = -13						; size = 1
__Ptr$223565 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@V?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@0@Z PROC ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	$LN1@erase@6

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T245885[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T245884[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T245883[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T245868[ebp], cl
	mov	dl, BYTE PTR __Cat$245873[ebp]
	mov	BYTE PTR $T245869[ebp], dl
	mov	al, BYTE PTR $T245868[ebp]
	mov	BYTE PTR $T245866[ebp], al
	mov	cl, BYTE PTR $T245870[ebp]
	mov	BYTE PTR $T245865[ebp], cl
	mov	edx, DWORD PTR $T245885[ebp]
	mov	DWORD PTR $T245864[ebp], edx
	mov	eax, DWORD PTR $T245883[ebp]
	mov	DWORD PTR $T245863[ebp], eax
	jmp	SHORT $LN28@erase@6
$LN27@erase@6:
	mov	ecx, DWORD PTR $T245864[ebp]
	add	ecx, 128				; 00000080H
	mov	DWORD PTR $T245864[ebp], ecx
	mov	edx, DWORD PTR $T245863[ebp]
	add	edx, 128				; 00000080H
	mov	DWORD PTR $T245863[ebp], edx
$LN28@erase@6:
	mov	eax, DWORD PTR $T245863[ebp]
	cmp	eax, DWORD PTR $T245884[ebp]
	je	SHORT $LN20@erase@6
	mov	ecx, DWORD PTR $T245863[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T245864[ebp]
	call	??4PlayerInfo@CvReplayInfo@@QAEAAU01@ABU01@@Z
	jmp	SHORT $LN27@erase@6
$LN20@erase@6:
	mov	edx, DWORD PTR $T245864[ebp]
	mov	DWORD PTR __Ptr$223565[ebp], edx

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T245991[ebp], ecx
	mov	edx, DWORD PTR $T245991[ebp]
	mov	DWORD PTR $T245970[ebp], edx
	mov	eax, DWORD PTR __Ptr$223565[ebp]
	mov	DWORD PTR $T245969[ebp], eax
	mov	cl, BYTE PTR __Cat$245976[ebp]
	mov	BYTE PTR $T245973[ebp], cl
	mov	edx, DWORD PTR $T245970[ebp]
	mov	DWORD PTR $T245950[ebp], edx
	mov	eax, DWORD PTR $T245969[ebp]
	mov	DWORD PTR $T245949[ebp], eax
	jmp	SHORT $LN49@erase@6
$LN48@erase@6:
	mov	ecx, DWORD PTR $T245949[ebp]
	add	ecx, 128				; 00000080H
	mov	DWORD PTR $T245949[ebp], ecx
$LN49@erase@6:
	mov	edx, DWORD PTR $T245949[ebp]
	cmp	edx, DWORD PTR $T245950[ebp]
	je	SHORT $LN41@erase@6
	mov	ecx, DWORD PTR $T245949[ebp]
	call	??1PlayerInfo@CvReplayInfo@@QAE@XZ
	xor	eax, eax
	and	eax, 1
	je	SHORT $LN52@erase@6
	mov	ecx, DWORD PTR $T245949[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN52@erase@6:
	jmp	SHORT $LN48@erase@6
$LN41@erase@6:

; 1049 : 			_Mylast = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$223565[ebp]
	mov	DWORD PTR [edx+8], eax
$LN1@erase@6:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@V?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@0@Z ENDP ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::erase
_TEXT	ENDS
PUBLIC	??$_Allocate@UPlayerInfo@CvReplayInfo@@@std@@YAPAUPlayerInfo@CvReplayInfo@@IPAU12@@Z ; std::_Allocate<CvReplayInfo::PlayerInfo>
PUBLIC	?_Xlen@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@KAXXZ ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$246005 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@5

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@5
	jmp	SHORT $LN3@Buy@5
$LN4@Buy@5:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$246005[ebp], 33554431	; 01ffffffH
	cmp	DWORD PTR __Count$246005[ebp], 0
	jbe	SHORT $LN11@Buy@5
	mov	eax, DWORD PTR __Count$246005[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy@5
$LN11@Buy@5:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy@5:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy@5

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@KAXXZ ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@5

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy@5:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@UPlayerInfo@CvReplayInfo@@@std@@YAPAUPlayerInfo@CvReplayInfo@@IPAU12@@Z ; std::_Allocate<CvReplayInfo::PlayerInfo>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	shl	edx, 7
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], edx
$LN3@Buy@5:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@5:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T246147 = -52						; size = 4
$T246146 = -48						; size = 4
$T246142 = -44						; size = 4
$T246141 = -40						; size = 4
$T246120 = -36						; size = 4
$T246119 = -32						; size = 4
$T246100 = -28						; size = 4
$T246099 = -24						; size = 4
__Cat$246125 = -2					; size = 1
$T246123 = -1						; size = 1
?_Tidy@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	$LN1@Tidy@6

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T246142[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T246141[ebp], ecx
	mov	edx, DWORD PTR $T246142[ebp]
	mov	DWORD PTR $T246120[ebp], edx
	mov	eax, DWORD PTR $T246141[ebp]
	mov	DWORD PTR $T246119[ebp], eax
	mov	cl, BYTE PTR __Cat$246125[ebp]
	mov	BYTE PTR $T246123[ebp], cl
	mov	edx, DWORD PTR $T246120[ebp]
	mov	DWORD PTR $T246100[ebp], edx
	mov	eax, DWORD PTR $T246119[ebp]
	mov	DWORD PTR $T246099[ebp], eax
	jmp	SHORT $LN12@Tidy@6
$LN11@Tidy@6:
	mov	ecx, DWORD PTR $T246099[ebp]
	add	ecx, 128				; 00000080H
	mov	DWORD PTR $T246099[ebp], ecx
$LN12@Tidy@6:
	mov	edx, DWORD PTR $T246099[ebp]
	cmp	edx, DWORD PTR $T246100[ebp]
	je	SHORT $LN4@Tidy@6
	mov	ecx, DWORD PTR $T246099[ebp]
	call	??1PlayerInfo@CvReplayInfo@@QAE@XZ
	xor	eax, eax
	and	eax, 1
	je	SHORT $LN15@Tidy@6
	mov	ecx, DWORD PTR $T246099[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN15@Tidy@6:
	jmp	SHORT $LN11@Tidy@6
$LN4@Tidy@6:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 7
	mov	DWORD PTR $T246147[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T246146[ebp], eax
	mov	ecx, DWORD PTR $T246146[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy@6:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@ABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
__Tmp$246207 = -24					; size = 4
$T246185 = -20						; size = 4
$T246166 = -16						; size = 4
$T246153 = -12						; size = 4
$T246150 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@ABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z PROC ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 4
	test	edx, edx
	jne	SHORT $LN3@insert@8
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert@8
$LN3@insert@8:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T246166[ebp], ecx
	mov	edx, DWORD PTR $T246166[ebp]
	mov	DWORD PTR $T246150[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	sub	eax, DWORD PTR $T246150[ebp]
	sar	eax, 4
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert@8:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T246185[ebp], edx
	mov	eax, DWORD PTR $T246185[ebp]
	mov	DWORD PTR $T246153[ebp], eax
	mov	ecx, DWORD PTR $T246153[ebp]
	mov	DWORD PTR __Tmp$246207[ebp], ecx
	mov	edx, DWORD PTR __Off$[ebp]
	shl	edx, 4
	add	edx, DWORD PTR __Tmp$246207[ebp]
	mov	DWORD PTR __Tmp$246207[ebp], edx
	mov	eax, DWORD PTR __Tmp$246207[ebp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@ABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z ENDP ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::insert
_TEXT	ENDS
PUBLIC	??4?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV01@ABV01@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator=
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?erase@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@0@Z$12
__ehfuncinfo$?erase@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?erase@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?erase@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@0@Z
_TEXT	SEGMENT
_this$ = -244						; size = 4
$T247237 = -240						; size = 4
$T247210 = -236						; size = 4
$T247209 = -232						; size = 4
$T247184 = -228						; size = 4
$T247183 = -224						; size = 4
__Cat$247216 = -186					; size = 1
$T247213 = -185						; size = 1
$T246862 = -184						; size = 4
$T246861 = -180						; size = 4
$T246860 = -176						; size = 4
$T246843 = -170						; size = 1
$T246842 = -169						; size = 1
$T246841 = -168						; size = 4
$T246840 = -164						; size = 4
__Cat$246854 = -28					; size = 1
$T246852 = -27						; size = 1
$T246851 = -26						; size = 1
$T246850 = -25						; size = 1
__Ptr$223630 = -24					; size = 4
__Last$ = -20						; size = 4
__First$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@0@Z PROC ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?erase@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	$LN1@erase@7

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T246862[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T246861[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T246860[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T246850[ebp], cl
	mov	dl, BYTE PTR __Cat$246854[ebp]
	mov	BYTE PTR $T246851[ebp], dl
	mov	al, BYTE PTR $T246850[ebp]
	mov	BYTE PTR $T246843[ebp], al
	mov	cl, BYTE PTR $T246852[ebp]
	mov	BYTE PTR $T246842[ebp], cl
	mov	edx, DWORD PTR $T246862[ebp]
	mov	DWORD PTR $T246841[ebp], edx
	mov	eax, DWORD PTR $T246860[ebp]
	mov	DWORD PTR $T246840[ebp], eax
	jmp	SHORT $LN28@erase@7
$LN27@erase@7:
	mov	ecx, DWORD PTR $T246841[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR $T246841[ebp], ecx
	mov	edx, DWORD PTR $T246840[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR $T246840[ebp], edx
$LN28@erase@7:
	mov	eax, DWORD PTR $T246840[ebp]
	cmp	eax, DWORD PTR $T246861[ebp]
	je	SHORT $LN20@erase@7
	mov	ecx, DWORD PTR $T246840[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T246841[ebp]
	call	??4?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV01@ABV01@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator=
	jmp	SHORT $LN27@erase@7
$LN20@erase@7:
	mov	edx, DWORD PTR $T246841[ebp]
	mov	DWORD PTR __Ptr$223630[ebp], edx

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T247237[ebp], ecx
	mov	edx, DWORD PTR $T247237[ebp]
	mov	DWORD PTR $T247210[ebp], edx
	mov	eax, DWORD PTR __Ptr$223630[ebp]
	mov	DWORD PTR $T247209[ebp], eax
	mov	cl, BYTE PTR __Cat$247216[ebp]
	mov	BYTE PTR $T247213[ebp], cl
	mov	edx, DWORD PTR $T247210[ebp]
	mov	DWORD PTR $T247184[ebp], edx
	mov	eax, DWORD PTR $T247209[ebp]
	mov	DWORD PTR $T247183[ebp], eax
	jmp	SHORT $LN164@erase@7
$LN163@erase@7:
	mov	ecx, DWORD PTR $T247183[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR $T247183[ebp], ecx
$LN164@erase@7:
	mov	edx, DWORD PTR $T247183[ebp]
	cmp	edx, DWORD PTR $T247184[ebp]
	je	SHORT $LN156@erase@7
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR $T247183[ebp]
	call	?_Tidy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	xor	eax, eax
	and	eax, 1
	je	SHORT $LN167@erase@7
	mov	ecx, DWORD PTR $T247183[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN167@erase@7:
	jmp	SHORT $LN163@erase@7
$LN156@erase@7:

; 1049 : 			_Mylast = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$223630[ebp]
	mov	DWORD PTR [edx+8], eax
$LN1@erase@7:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@0@Z$12:
	mov	ecx, DWORD PTR $T247183[ebp]
	jmp	??1?$_Vector_val@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ
__ehhandler$?erase@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-236]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?erase@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@0@Z ENDP ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::erase
PUBLIC	??$_Allocate@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IPAV10@@Z ; std::_Allocate<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >
PUBLIC	?_Xlen@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@KAXXZ ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$247258 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAE_NI@Z PROC ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@6

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@6
	jmp	SHORT $LN3@Buy@6
$LN4@Buy@6:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$247258[ebp], 268435455 ; 0fffffffH
	cmp	DWORD PTR __Count$247258[ebp], 0
	jbe	SHORT $LN11@Buy@6
	mov	eax, DWORD PTR __Count$247258[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy@6
$LN11@Buy@6:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy@6:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy@6

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@KAXXZ ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@6

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy@6:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IPAV10@@Z ; std::_Allocate<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], edx
$LN3@Buy@6:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@6:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAE_NI@Z ENDP ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Buy
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?_Tidy@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Tidy@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXXZ$0
__ehfuncinfo$?_Tidy@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Tidy@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Tidy@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -84						; size = 4
$T247668 = -80						; size = 4
$T247667 = -76						; size = 4
$T247663 = -72						; size = 4
$T247662 = -68						; size = 4
$T247635 = -64						; size = 4
$T247634 = -60						; size = 4
$T247609 = -56						; size = 4
$T247608 = -52						; size = 4
__Cat$247642 = -14					; size = 1
$T247640 = -13						; size = 1
__$EHRec$ = -12						; size = 12
?_Tidy@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXXZ PROC ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Tidy@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	$LN1@Tidy@7

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T247663[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T247662[ebp], ecx
	mov	edx, DWORD PTR $T247663[ebp]
	mov	DWORD PTR $T247635[ebp], edx
	mov	eax, DWORD PTR $T247662[ebp]
	mov	DWORD PTR $T247634[ebp], eax
	mov	cl, BYTE PTR __Cat$247642[ebp]
	mov	BYTE PTR $T247640[ebp], cl
	mov	edx, DWORD PTR $T247635[ebp]
	mov	DWORD PTR $T247609[ebp], edx
	mov	eax, DWORD PTR $T247634[ebp]
	mov	DWORD PTR $T247608[ebp], eax
	jmp	SHORT $LN12@Tidy@7
$LN11@Tidy@7:
	mov	ecx, DWORD PTR $T247608[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR $T247608[ebp], ecx
$LN12@Tidy@7:
	mov	edx, DWORD PTR $T247608[ebp]
	cmp	edx, DWORD PTR $T247609[ebp]
	je	SHORT $LN4@Tidy@7
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR $T247608[ebp]
	call	?_Tidy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	xor	eax, eax
	and	eax, 1
	je	SHORT $LN15@Tidy@7
	mov	ecx, DWORD PTR $T247608[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN15@Tidy@7:
	jmp	SHORT $LN11@Tidy@7
$LN4@Tidy@7:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 4
	mov	DWORD PTR $T247668[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T247667[ebp], eax
	mov	ecx, DWORD PTR $T247667[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy@7:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Tidy@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXXZ$0:
	mov	ecx, DWORD PTR $T247608[ebp]
	jmp	??1?$_Vector_val@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ
__ehhandler$?_Tidy@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Tidy@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Tidy@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXXZ ENDP ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Tidy
PUBLIC	?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@ABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
__Tmp$247730 = -24					; size = 4
$T247712 = -20						; size = 4
$T247693 = -16						; size = 4
$T247680 = -12						; size = 4
$T247677 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@ABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z PROC ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	test	eax, eax
	jne	SHORT $LN3@insert@9
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert@9
$LN3@insert@9:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T247693[ebp], eax
	mov	ecx, DWORD PTR $T247693[ebp]
	mov	DWORD PTR $T247677[ebp], ecx
	mov	eax, DWORD PTR __Where$[ebp]
	sub	eax, DWORD PTR $T247677[ebp]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert@9:
	mov	edx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], edx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T247712[ebp], eax
	mov	ecx, DWORD PTR $T247712[ebp]
	mov	DWORD PTR $T247680[ebp], ecx
	mov	edx, DWORD PTR $T247680[ebp]
	mov	DWORD PTR __Tmp$247730[ebp], edx
	mov	eax, DWORD PTR __Off$[ebp]
	imul	eax, 12					; 0000000cH
	add	eax, DWORD PTR __Tmp$247730[ebp]
	mov	DWORD PTR __Tmp$247730[ebp], eax
	mov	ecx, DWORD PTR __Tmp$247730[ebp]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@ABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z ENDP ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::insert
_TEXT	ENDS
PUBLIC	??4?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::operator=
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?erase@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@0@Z$1
__ehfuncinfo$?erase@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?erase@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?erase@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@0@Z
_TEXT	SEGMENT
_this$ = -244						; size = 4
$T248434 = -240						; size = 4
$T248399 = -236						; size = 4
$T248398 = -232						; size = 4
$T248365 = -228						; size = 4
$T248364 = -224						; size = 4
__Cat$248406 = -134					; size = 1
$T248403 = -133						; size = 1
$T247992 = -132						; size = 4
$T247991 = -128						; size = 4
$T247990 = -124						; size = 4
$T247971 = -118						; size = 1
$T247970 = -117						; size = 1
$T247969 = -116						; size = 4
$T247968 = -112						; size = 4
__Cat$247985 = -28					; size = 1
$T247983 = -27						; size = 1
$T247982 = -26						; size = 1
$T247981 = -25						; size = 1
__Ptr$223695 = -24					; size = 4
__Last$ = -20						; size = 4
__First$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@0@Z PROC ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?erase@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	$LN1@erase@8

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T247992[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T247991[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T247990[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T247981[ebp], cl
	mov	dl, BYTE PTR __Cat$247985[ebp]
	mov	BYTE PTR $T247982[ebp], dl
	mov	al, BYTE PTR $T247981[ebp]
	mov	BYTE PTR $T247971[ebp], al
	mov	cl, BYTE PTR $T247983[ebp]
	mov	BYTE PTR $T247970[ebp], cl
	mov	edx, DWORD PTR $T247992[ebp]
	mov	DWORD PTR $T247969[ebp], edx
	mov	eax, DWORD PTR $T247990[ebp]
	mov	DWORD PTR $T247968[ebp], eax
	jmp	SHORT $LN28@erase@8
$LN27@erase@8:
	mov	ecx, DWORD PTR $T247969[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR $T247969[ebp], ecx
	mov	edx, DWORD PTR $T247968[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR $T247968[ebp], edx
$LN28@erase@8:
	mov	eax, DWORD PTR $T247968[ebp]
	cmp	eax, DWORD PTR $T247991[ebp]
	je	SHORT $LN20@erase@8
	mov	ecx, DWORD PTR $T247968[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T247969[ebp]
	call	??4?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::operator=
	jmp	SHORT $LN27@erase@8
$LN20@erase@8:
	mov	edx, DWORD PTR $T247969[ebp]
	mov	DWORD PTR __Ptr$223695[ebp], edx

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T248434[ebp], ecx
	mov	edx, DWORD PTR $T248434[ebp]
	mov	DWORD PTR $T248399[ebp], edx
	mov	eax, DWORD PTR __Ptr$223695[ebp]
	mov	DWORD PTR $T248398[ebp], eax
	mov	cl, BYTE PTR __Cat$248406[ebp]
	mov	BYTE PTR $T248403[ebp], cl
	mov	edx, DWORD PTR $T248399[ebp]
	mov	DWORD PTR $T248365[ebp], edx
	mov	eax, DWORD PTR $T248398[ebp]
	mov	DWORD PTR $T248364[ebp], eax
	jmp	SHORT $LN110@erase@8
$LN109@erase@8:
	mov	ecx, DWORD PTR $T248364[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR $T248364[ebp], ecx
$LN110@erase@8:
	mov	edx, DWORD PTR $T248364[ebp]
	cmp	edx, DWORD PTR $T248365[ebp]
	je	SHORT $LN102@erase@8
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR $T248364[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	xor	eax, eax
	and	eax, 1
	je	SHORT $LN113@erase@8
	mov	ecx, DWORD PTR $T248364[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN113@erase@8:
	jmp	SHORT $LN109@erase@8
$LN102@erase@8:

; 1049 : 			_Mylast = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$223695[ebp]
	mov	DWORD PTR [edx+8], eax
$LN1@erase@8:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@0@Z$1:
	mov	ecx, DWORD PTR $T248364[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__ehhandler$?erase@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-236]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?erase@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@0@Z ENDP ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::erase
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$248455 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAE_NI@Z PROC ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@7

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@7
	jmp	SHORT $LN3@Buy@7
$LN4@Buy@7:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$248455[ebp], 357913941 ; 15555555H
	cmp	DWORD PTR __Count$248455[ebp], 0
	jbe	SHORT $LN11@Buy@7
	mov	eax, DWORD PTR __Count$248455[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy@7
$LN11@Buy@7:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy@7:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy@7

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@KAXXZ ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@7

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy@7:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IPAV10@@Z ; std::_Allocate<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], edx
$LN3@Buy@7:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@7:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAE_NI@Z ENDP ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Buy
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?_Tidy@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Tidy@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXXZ$1
__ehfuncinfo$?_Tidy@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Tidy@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Tidy@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -136						; size = 4
$T248932 = -132						; size = 4
$T248931 = -128						; size = 4
$T248927 = -124						; size = 4
$T248926 = -120						; size = 4
$T248891 = -116						; size = 4
$T248890 = -112						; size = 4
$T248857 = -108						; size = 4
$T248856 = -104						; size = 4
__Cat$248919 = -14					; size = 1
$T248917 = -13						; size = 1
__$EHRec$ = -12						; size = 12
?_Tidy@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXXZ PROC ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Tidy@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 124				; 0000007cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	$LN1@Tidy@8

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T248927[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T248926[ebp], ecx
	mov	edx, DWORD PTR $T248927[ebp]
	mov	DWORD PTR $T248891[ebp], edx
	mov	eax, DWORD PTR $T248926[ebp]
	mov	DWORD PTR $T248890[ebp], eax
	mov	cl, BYTE PTR __Cat$248919[ebp]
	mov	BYTE PTR $T248917[ebp], cl
	mov	edx, DWORD PTR $T248891[ebp]
	mov	DWORD PTR $T248857[ebp], edx
	mov	eax, DWORD PTR $T248890[ebp]
	mov	DWORD PTR $T248856[ebp], eax
	jmp	SHORT $LN12@Tidy@8
$LN11@Tidy@8:
	mov	ecx, DWORD PTR $T248856[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR $T248856[ebp], ecx
$LN12@Tidy@8:
	mov	edx, DWORD PTR $T248856[ebp]
	cmp	edx, DWORD PTR $T248857[ebp]
	je	SHORT $LN4@Tidy@8
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR $T248856[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	xor	eax, eax
	and	eax, 1
	je	SHORT $LN15@Tidy@8
	mov	ecx, DWORD PTR $T248856[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN15@Tidy@8:
	jmp	SHORT $LN11@Tidy@8
$LN4@Tidy@8:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR $T248932[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T248931[ebp], eax
	mov	ecx, DWORD PTR $T248931[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy@8:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Tidy@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXXZ$1:
	mov	ecx, DWORD PTR $T248856[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__ehhandler$?_Tidy@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-128]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Tidy@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Tidy@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXXZ ENDP ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Tidy
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@KAXXZ
_TEXT	SEGMENT
$T248942 = -80						; size = 28
$T248941 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@KAXXZ PROC ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T248942[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T248941[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T248941[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T248942[ebp]
	push	eax
	lea	ecx, DWORD PTR $T248941[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T248941[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T248941[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T248942[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@2:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T248942[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T248941[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@KAXXZ ENDP ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Xlen
PUBLIC	??$_Allocate@U?$pair@FF@std@@@std@@YAPAU?$pair@FF@0@IPAU10@@Z ; std::_Allocate<std::pair<short,short> >
PUBLIC	?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$248974 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAE_NI@Z PROC ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@8

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@8
	jmp	SHORT $LN3@Buy@8
$LN4@Buy@8:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$248974[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$248974[ebp], 0
	jbe	SHORT $LN11@Buy@8
	mov	eax, DWORD PTR __Count$248974[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy@8
$LN11@Buy@8:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy@8:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy@8

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@8

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy@8:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@U?$pair@FF@std@@@std@@YAPAU?$pair@FF@0@IPAU10@@Z ; std::_Allocate<std::pair<short,short> >
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy@8:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@8:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAE_NI@Z ENDP ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T249071 = -32						; size = 4
$T249070 = -28						; size = 4
$T249066 = -24						; size = 4
$T249065 = -20						; size = 4
$T249047 = -16						; size = 4
$T249046 = -12						; size = 4
$T249030 = -8						; size = 4
__Cat$249053 = -2					; size = 1
$T249050 = -1						; size = 1
?_Tidy@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEXXZ PROC ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy@9

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T249066[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T249065[ebp], ecx
	mov	edx, DWORD PTR $T249066[ebp]
	mov	DWORD PTR $T249047[ebp], edx
	mov	eax, DWORD PTR $T249065[ebp]
	mov	DWORD PTR $T249046[ebp], eax
	mov	cl, BYTE PTR __Cat$249053[ebp]
	mov	BYTE PTR $T249050[ebp], cl
	mov	edx, DWORD PTR $T249046[ebp]
	mov	DWORD PTR $T249030[ebp], edx
	jmp	SHORT $LN12@Tidy@9
$LN11@Tidy@9:
	mov	eax, DWORD PTR $T249030[ebp]
	add	eax, 4
	mov	DWORD PTR $T249030[ebp], eax
$LN12@Tidy@9:
	mov	ecx, DWORD PTR $T249030[ebp]
	cmp	ecx, DWORD PTR $T249047[ebp]
	je	SHORT $LN4@Tidy@9
	jmp	SHORT $LN11@Tidy@9
$LN4@Tidy@9:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR $T249071[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T249070[ebp], eax
	mov	ecx, DWORD PTR $T249070[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy@9:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEXXZ ENDP ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Tidy
_TEXT	ENDS
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Init
PUBLIC	??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	SEGMENT
__unwindtable$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
tv89 = -72						; size = 4
tv147 = -68						; size = 4
tv173 = -64						; size = 4
tv199 = -60						; size = 4
_this$ = -56						; size = 4
$T249154 = -47						; size = 1
$T249129 = -46						; size = 1
$T249111 = -45						; size = 1
$T249100 = -44						; size = 4
$T249143 = -40						; size = 4
$T249093 = -36						; size = 4
$T249086 = -28						; size = 4
$T249079 = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 509  : 		{	// construct empty tree

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T249154[ebp]
	mov	DWORD PTR $T249079[ebp], eax
	lea	ecx, DWORD PTR $T249129[ebp]
	mov	DWORD PTR $T249086[ebp], ecx
	lea	edx, DWORD PTR $T249111[ebp]
	mov	DWORD PTR $T249093[ebp], edx
	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T249143[ebp], esp
	mov	DWORD PTR $T249100[ebp], eax
	mov	ecx, DWORD PTR __Parg$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>
	mov	DWORD PTR tv199[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv173[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv147[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv89[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 510  : 		_Init();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Init

; 511  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::insert
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Inc
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Dec
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
; Function compile flags: /Odtp
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBHH@2@@Z
_TEXT	SEGMENT
_this$ = -376						; size = 4
$T249731 = -372						; size = 4
$T249708 = -368						; size = 4
$T249692 = -364						; size = 4
$T249666 = -360						; size = 4
$T249647 = -356						; size = 4
$T249627 = -352						; size = 4
$T249598 = -348						; size = 4
$T249583 = -344						; size = 4
$T249569 = -340						; size = 4
$T249548 = -336						; size = 4
$T249516 = -332						; size = 4
$T249499 = -328						; size = 4
$T249486 = -324						; size = 4
$T249468 = -320						; size = 4
$T249448 = -316						; size = 4
$T249429 = -312						; size = 4
$T249400 = -308						; size = 4
$T249384 = -304						; size = 4
$T249361 = -300						; size = 4
$T249338 = -296						; size = 4
$T249313 = -216						; size = 4
$T249299 = -212						; size = 4
$T249281 = -208						; size = 4
$T249248 = -128						; size = 4
$T249228 = -124						; size = 4
$T249215 = -120						; size = 4
$T249205 = -40						; size = 4
$T249198 = -36						; size = 8
$T249197 = -28						; size = 4
$T249196 = -24						; size = 4
$T249195 = -20						; size = 4
$T249194 = -16						; size = 4
$T249193 = -12						; size = 4
$T249192 = -8						; size = 4
__Next$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBHH@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::insert, COMDAT
; _this$ = ecx

; 664  : 		{	// try to insert node with value _Val using _Where as a hint

	push	ebp
	mov	ebp, esp
	sub	esp, 376				; 00000178H
	mov	DWORD PTR _this$[ebp], ecx

; 665  : 
; 666  :  #if _HAS_ITERATOR_DEBUGGING
; 667  : 		if (_Where._Mycont != this)
; 668  : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 669  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 670  : 
; 671  : 		const_iterator _Next;

	mov	DWORD PTR __Next$[ebp], 0

; 672  : 
; 673  : 		if (size() == 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T249205[ebp], ecx
	cmp	DWORD PTR $T249205[ebp], 0
	jne	SHORT $LN32@insert@10

; 674  : 			return (_Insert(true, _Myhead, _Val));	// insert into empty tree

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	1
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@10
	jmp	$LN31@insert@10
$LN32@insert@10:

; 675  : 		else if (this->_Multi)

	xor	eax, eax
	je	$LN30@insert@10

; 676  : 			{	// insert even if duplicate
; 677  : 			if (_Where == begin())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T249215[ebp], edx
	mov	eax, DWORD PTR $T249215[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T249228[ebp], ecx
	mov	edx, DWORD PTR $T249228[ebp]
	mov	DWORD PTR $T249192[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T249192[ebp]
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN29@insert@10

; 678  : 				{	// insert at beginning if before first element
; 679  : 				if (!_DEBUG_LT_PRED(this->comp,

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T249248[ebp], eax
	mov	ecx, DWORD PTR $T249248[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setl	cl
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN28@insert@10

; 680  : 					_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 681  : 					return (_Insert(true, _Where._Mynode(), _Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@10
$LN28@insert@10:

; 682  : 				}

	jmp	$LN27@insert@10
$LN29@insert@10:

; 683  : 			else if (_Where == end())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T249281[ebp], ecx
	mov	edx, DWORD PTR $T249281[ebp]
	mov	DWORD PTR $T249193[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T249193[ebp]
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN151@insert@10

; 684  : 				{	// insert at end if after last element
; 685  : 				if (!_DEBUG_LT_PRED(this->comp,

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 8
	mov	DWORD PTR $T249299[ebp], ecx
	mov	edx, DWORD PTR $T249299[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T249313[ebp], eax
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR $T249313[ebp]
	mov	eax, DWORD PTR [ecx]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setl	cl
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN25@insert@10

; 686  : 					this->_Kfn(_Val), _Key(_Rmost())))
; 687  : 					return (_Insert(false, _Rmost(), _Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	push	0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@10
$LN25@insert@10:

; 688  : 				}
; 689  : 			else if (!_DEBUG_LT_PRED(this->comp,

	jmp	$LN27@insert@10

; 690  : 				_Key(_Where._Mynode()), this->_Kfn(_Val))
; 691  : 				&& !_DEBUG_LT_PRED(this->comp,

$LN151@insert@10:
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T249338[ebp], edx
	mov	eax, DWORD PTR $T249338[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [eax+12]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx]
	setl	al
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN23@insert@10
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Next$[ebp], edx
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Dec
	mov	eax, DWORD PTR __Next$[ebp]
	mov	DWORD PTR $T249361[ebp], eax
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR $T249361[ebp]
	mov	eax, DWORD PTR [ecx]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+12]
	setl	cl
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN23@insert@10

; 692  : 					this->_Kfn(_Val), _Key((--(_Next = _Where))._Mynode())))
; 693  : 				{	// insert before _Where
; 694  : 				if (_Isnil(_Right(_Next._Mynode())))

	mov	eax, DWORD PTR __Next$[ebp]
	mov	DWORD PTR $T249384[ebp], eax
	mov	ecx, DWORD PTR $T249384[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	je	SHORT $LN185@insert@10

; 695  : 					return (_Insert(false, _Next._Mynode(), _Val));

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@10

; 696  : 				else

	jmp	SHORT $LN21@insert@10

; 697  : 					return (_Insert(true, _Where._Mynode(), _Val));

$LN185@insert@10:
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@10
$LN21@insert@10:

; 698  : 				}
; 699  : 			else if (!_DEBUG_LT_PRED(this->comp,

	jmp	$LN27@insert@10
$LN23@insert@10:

; 700  : 				this->_Kfn(_Val), _Key(_Where._Mynode()))
; 701  : 				&& (++(_Next = _Where) == end()
; 702  : 					|| !_DEBUG_LT_PRED(this->comp,

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T249400[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR $T249400[ebp]
	mov	ecx, DWORD PTR [edx]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+12]
	setl	dl
	movzx	eax, dl
	test	eax, eax
	jne	$LN27@insert@10
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Next$[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T249429[ebp], eax
	mov	ecx, DWORD PTR $T249429[ebp]
	mov	DWORD PTR $T249194[ebp], ecx
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Inc
	mov	edx, DWORD PTR __Next$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T249194[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN18@insert@10
	mov	edx, DWORD PTR __Next$[ebp]
	mov	DWORD PTR $T249448[ebp], edx
	mov	eax, DWORD PTR $T249448[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [eax+12]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx]
	setl	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN27@insert@10
$LN18@insert@10:

; 703  : 						_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 704  : 				{	// insert after _Where
; 705  : 				if (_Isnil(_Right(_Where._Mynode())))

	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T249468[ebp], edx
	mov	eax, DWORD PTR $T249468[ebp]
	mov	ecx, DWORD PTR [eax+8]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	je	SHORT $LN229@insert@10

; 706  : 					return (_Insert(false, _Where._Mynode(), _Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@10

; 707  : 				else

	jmp	SHORT $LN27@insert@10

; 708  : 					return (_Insert(true, _Next._Mynode(), _Val));

$LN229@insert@10:
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@10
$LN27@insert@10:

; 709  : 				}
; 710  : 			}
; 711  : 		else

	jmp	$LN31@insert@10
$LN30@insert@10:

; 712  : 			{	// insert only if unique
; 713  : 			if (_Where == begin())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T249486[ebp], ecx
	mov	edx, DWORD PTR $T249486[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T249499[ebp], eax
	mov	ecx, DWORD PTR $T249499[ebp]
	mov	DWORD PTR $T249195[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T249195[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN14@insert@10

; 714  : 				{	// insert at beginning if before first element
; 715  : 				if (_DEBUG_LT_PRED(this->comp,

	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T249516[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR $T249516[ebp]
	mov	edx, DWORD PTR [eax]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+12]
	setl	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN13@insert@10

; 716  : 					this->_Kfn(_Val), _Key(_Where._Mynode())))
; 717  : 					return (_Insert(true, _Where._Mynode(), _Val));

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@10
$LN13@insert@10:

; 718  : 				}

	jmp	$LN31@insert@10
$LN14@insert@10:

; 719  : 			else if (_Where == end())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T249548[ebp], eax
	mov	ecx, DWORD PTR $T249548[ebp]
	mov	DWORD PTR $T249196[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T249196[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN11@insert@10

; 720  : 				{	// insert at end if after last element
; 721  : 				if (_DEBUG_LT_PRED(this->comp,

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 8
	mov	DWORD PTR $T249569[ebp], eax
	mov	ecx, DWORD PTR $T249569[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR $T249583[ebp], edx
	mov	eax, DWORD PTR $T249583[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [eax]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx]
	setl	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN10@insert@10

; 722  : 					_Key(_Rmost()), this->_Kfn(_Val)))
; 723  : 					return (_Insert(false, _Rmost(), _Val));

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	push	0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@10
$LN10@insert@10:

; 724  : 				}
; 725  : 			else if (_DEBUG_LT_PRED(this->comp,

	jmp	$LN31@insert@10
$LN11@insert@10:

; 726  : 				this->_Kfn(_Val), _Key(_Where._Mynode()))
; 727  : 				&& _DEBUG_LT_PRED(this->comp,

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T249598[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR $T249598[ebp]
	mov	ecx, DWORD PTR [edx]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+12]
	setl	dl
	movzx	eax, dl
	test	eax, eax
	je	$LN319@insert@10
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Next$[ebp], ecx
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Dec
	mov	edx, DWORD PTR __Next$[ebp]
	mov	DWORD PTR $T249627[ebp], edx
	mov	eax, DWORD PTR $T249627[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [eax+12]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx]
	setl	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN319@insert@10

; 728  : 					_Key((--(_Next = _Where))._Mynode()), this->_Kfn(_Val)))
; 729  : 				{	// insert before _Where
; 730  : 				if (_Isnil(_Right(_Next._Mynode())))

	mov	edx, DWORD PTR __Next$[ebp]
	mov	DWORD PTR $T249647[ebp], edx
	mov	eax, DWORD PTR $T249647[ebp]
	mov	ecx, DWORD PTR [eax+8]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	je	SHORT $LN317@insert@10

; 731  : 					return (_Insert(false, _Next._Mynode(), _Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@10

; 732  : 				else

	jmp	SHORT $LN6@insert@10

; 733  : 					return (_Insert(true, _Where._Mynode(), _Val));

$LN317@insert@10:
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@10
$LN6@insert@10:

; 734  : 				}
; 735  : 			else if (_DEBUG_LT_PRED(this->comp,

	jmp	$LN31@insert@10

; 736  : 				_Key(_Where._Mynode()), this->_Kfn(_Val))
; 737  : 				&& (++(_Next = _Where) == end()
; 738  : 					|| _DEBUG_LT_PRED(this->comp,

$LN319@insert@10:
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T249666[ebp], eax
	mov	ecx, DWORD PTR $T249666[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setl	cl
	movzx	edx, cl
	test	edx, edx
	je	$LN31@insert@10
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Next$[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T249692[ebp], edx
	mov	eax, DWORD PTR $T249692[ebp]
	mov	DWORD PTR $T249197[ebp], eax
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Inc
	mov	ecx, DWORD PTR __Next$[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T249197[ebp]
	sete	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN3@insert@10
	mov	ecx, DWORD PTR __Next$[ebp]
	mov	DWORD PTR $T249708[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR $T249708[ebp]
	mov	ecx, DWORD PTR [edx]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+12]
	setl	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN31@insert@10
$LN3@insert@10:

; 739  : 						this->_Kfn(_Val), _Key(_Next._Mynode()))))
; 740  : 				{	// insert after _Where
; 741  : 				if (_Isnil(_Right(_Where._Mynode())))

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T249731[ebp], ecx
	mov	edx, DWORD PTR $T249731[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+21]
	test	ecx, ecx
	je	SHORT $LN361@insert@10

; 742  : 					return (_Insert(false, _Where._Mynode(), _Val));

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN33@insert@10

; 743  : 				else

	jmp	SHORT $LN31@insert@10

; 744  : 					return (_Insert(true, _Next._Mynode(), _Val));

$LN361@insert@10:
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Next$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN33@insert@10
$LN31@insert@10:

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	lea	eax, DWORD PTR $T249198[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::insert
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN33@insert@10:

; 749  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBHH@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::insert
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
; Function compile flags: /Odtp
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -92						; size = 4
$T249986 = -88						; size = 4
$T249952 = -84						; size = 4
$T249785 = -32						; size = 4
$T249772 = -28						; size = 4
$T249760 = -24						; size = 4
$T249750 = -20						; size = 4
$T249749 = -16						; size = 4
$T249748 = -12						; size = 4
$T249747 = -8						; size = 4
$T249746 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1420 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	DWORD PTR _this$[ebp], ecx

; 1421 : 		erase(begin(), end());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T249760[ebp], ecx
	mov	edx, DWORD PTR $T249760[ebp]
	mov	DWORD PTR $T249747[ebp], edx
	mov	eax, DWORD PTR $T249747[ebp]
	mov	DWORD PTR $T249746[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T249772[ebp], edx
	mov	eax, DWORD PTR $T249772[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T249785[ebp], ecx
	mov	edx, DWORD PTR $T249785[ebp]
	mov	DWORD PTR $T249749[ebp], edx
	mov	eax, DWORD PTR $T249749[ebp]
	mov	DWORD PTR $T249748[ebp], eax
	mov	ecx, DWORD PTR $T249746[ebp]
	push	ecx
	mov	edx, DWORD PTR $T249748[ebp]
	push	edx
	lea	eax, DWORD PTR $T249750[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase

; 1422 : 		this->_Alptr.destroy(&_Left(_Myhead));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T249952[ebp], edx

; 1423 : 		this->_Alptr.destroy(&_Parent(_Myhead));
; 1424 : 		this->_Alptr.destroy(&_Right(_Myhead));
; 1425 : 		this->_Alnod.deallocate(_Myhead, 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T249986[ebp], ecx
	mov	edx, DWORD PTR $T249986[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1426 : 		_Myhead = 0, _Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 1427 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tidy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T250023 = -16						; size = 4
$T250002 = -12						; size = 4
$T249995 = -8						; size = 4
__Pnode$223925 = -4					; size = 4
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 377  : 			{	// move to node with next larger value

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 378  : 
; 379  :  #if _HAS_ITERATOR_DEBUGGING
; 380  : 			if (this->_Mycont == 0
; 381  : 				|| _Ptr == 0
; 382  : 				|| _Isnil(_Ptr))
; 383  : 				{
; 384  : 				_DEBUG_ERROR("map/set iterator not incrementable");
; 385  : 				_SCL_SECURE_OUT_OF_RANGE;
; 386  : 				}
; 387  :  #else
; 388  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 389  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	je	SHORT $LN6@Inc
	jmp	$LN7@Inc
$LN6@Inc:

; 390  : 				{
; 391  : 				_SCL_SECURE_OUT_OF_RANGE;
; 392  : 				// end() shouldn't be incremented, don't move if _SCL_SECURE is not turned on
; 393  : 				}
; 394  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 395  : 
; 396  : 			else if (!_Isnil(_Right(_Ptr)))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	mov	DWORD PTR $T249995[ebp], ecx
	mov	edx, DWORD PTR $T249995[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+21]
	test	ecx, ecx
	jne	SHORT $LN27@Inc

; 397  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 8
	mov	DWORD PTR $T250002[ebp], eax
	mov	ecx, DWORD PTR $T250002[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T250023[ebp], edx
$LN23@Inc:
	mov	eax, DWORD PTR $T250023[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	jne	SHORT $LN19@Inc
	mov	eax, DWORD PTR $T250023[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T250023[ebp], ecx
	jmp	SHORT $LN23@Inc
$LN19@Inc:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T250023[ebp]
	mov	DWORD PTR [edx], eax

; 398  : 			else

	jmp	SHORT $LN7@Inc

; 399  : 				{	// climb looking for right subtree
; 400  : 				_Nodeptr _Pnode;
; 401  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 402  : 					&& _Ptr == _Right(_Pnode))

$LN27@Inc:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$223925[ebp], eax
	mov	ecx, DWORD PTR __Pnode$223925[ebp]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	jne	SHORT $LN1@Inc
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$223925[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN1@Inc

; 403  : 					_Ptr = _Pnode;	// ==> parent while right subtree

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$223925[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN27@Inc
$LN1@Inc:

; 404  : 				_Ptr = _Pnode;	// ==> parent (head if end())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Pnode$223925[ebp]
	mov	DWORD PTR [edx], eax
$LN7@Inc:

; 405  : 				}
; 406  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Inc
_TEXT	ENDS
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Init
PUBLIC	??0?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z ; std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0>::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z
_TEXT	SEGMENT
tv89 = -72						; size = 4
tv147 = -68						; size = 4
tv173 = -64						; size = 4
tv199 = -60						; size = 4
_this$ = -56						; size = 4
$T250115 = -47						; size = 1
$T250090 = -46						; size = 1
$T250072 = -45						; size = 1
$T250061 = -44						; size = 4
$T250103 = -40						; size = 4
$T250054 = -36						; size = 4
$T250047 = -28						; size = 4
$T250040 = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >, COMDAT
; _this$ = ecx

; 509  : 		{	// construct empty tree

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T250115[ebp]
	mov	DWORD PTR $T250040[ebp], eax
	lea	ecx, DWORD PTR $T250090[ebp]
	mov	DWORD PTR $T250047[ebp], ecx
	lea	edx, DWORD PTR $T250072[ebp]
	mov	DWORD PTR $T250054[ebp], edx
	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T250103[ebp], esp
	mov	DWORD PTR $T250061[ebp], eax
	mov	ecx, DWORD PTR __Parg$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z ; std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0>::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0>
	mov	DWORD PTR tv199[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv173[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv147[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv89[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 510  : 		_Init();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Init

; 511  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::insert
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::_Inc
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::_Dec
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Insert
; Function compile flags: /Odtp
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z
_TEXT	SEGMENT
_this$ = -376						; size = 4
$T250692 = -372						; size = 4
$T250669 = -368						; size = 4
$T250653 = -364						; size = 4
$T250627 = -360						; size = 4
$T250608 = -356						; size = 4
$T250588 = -352						; size = 4
$T250559 = -348						; size = 4
$T250544 = -344						; size = 4
$T250530 = -340						; size = 4
$T250509 = -336						; size = 4
$T250477 = -332						; size = 4
$T250460 = -328						; size = 4
$T250447 = -324						; size = 4
$T250429 = -320						; size = 4
$T250409 = -316						; size = 4
$T250390 = -312						; size = 4
$T250361 = -308						; size = 4
$T250345 = -304						; size = 4
$T250322 = -300						; size = 4
$T250299 = -296						; size = 4
$T250274 = -216						; size = 4
$T250260 = -212						; size = 4
$T250242 = -208						; size = 4
$T250209 = -128						; size = 4
$T250189 = -124						; size = 4
$T250176 = -120						; size = 4
$T250166 = -40						; size = 4
$T250159 = -36						; size = 8
$T250158 = -28						; size = 4
$T250157 = -24						; size = 4
$T250156 = -20						; size = 4
$T250155 = -16						; size = 4
$T250154 = -12						; size = 4
$T250153 = -8						; size = 4
__Next$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::insert, COMDAT
; _this$ = ecx

; 664  : 		{	// try to insert node with value _Val using _Where as a hint

	push	ebp
	mov	ebp, esp
	sub	esp, 376				; 00000178H
	mov	DWORD PTR _this$[ebp], ecx

; 665  : 
; 666  :  #if _HAS_ITERATOR_DEBUGGING
; 667  : 		if (_Where._Mycont != this)
; 668  : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 669  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 670  : 
; 671  : 		const_iterator _Next;

	mov	DWORD PTR __Next$[ebp], 0

; 672  : 
; 673  : 		if (size() == 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T250166[ebp], ecx
	cmp	DWORD PTR $T250166[ebp], 0
	jne	SHORT $LN32@insert@11

; 674  : 			return (_Insert(true, _Myhead, _Val));	// insert into empty tree

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	1
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@11
	jmp	$LN31@insert@11
$LN32@insert@11:

; 675  : 		else if (this->_Multi)

	xor	eax, eax
	je	$LN30@insert@11

; 676  : 			{	// insert even if duplicate
; 677  : 			if (_Where == begin())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T250176[ebp], edx
	mov	eax, DWORD PTR $T250176[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T250189[ebp], ecx
	mov	edx, DWORD PTR $T250189[ebp]
	mov	DWORD PTR $T250153[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T250153[ebp]
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN29@insert@11

; 678  : 				{	// insert at beginning if before first element
; 679  : 				if (!_DEBUG_LT_PRED(this->comp,

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T250209[ebp], eax
	mov	ecx, DWORD PTR $T250209[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	cmp	eax, DWORD PTR [edx]
	sbb	ecx, ecx
	neg	ecx
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN28@insert@11

; 680  : 					_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 681  : 					return (_Insert(true, _Where._Mynode(), _Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@11
$LN28@insert@11:

; 682  : 				}

	jmp	$LN27@insert@11
$LN29@insert@11:

; 683  : 			else if (_Where == end())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T250242[ebp], ecx
	mov	edx, DWORD PTR $T250242[ebp]
	mov	DWORD PTR $T250154[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T250154[ebp]
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN151@insert@11

; 684  : 				{	// insert at end if after last element
; 685  : 				if (!_DEBUG_LT_PRED(this->comp,

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 8
	mov	DWORD PTR $T250260[ebp], ecx
	mov	edx, DWORD PTR $T250260[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T250274[ebp], eax
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR $T250274[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	sbb	ecx, ecx
	neg	ecx
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN25@insert@11

; 686  : 					this->_Kfn(_Val), _Key(_Rmost())))
; 687  : 					return (_Insert(false, _Rmost(), _Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	push	0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@11
$LN25@insert@11:

; 688  : 				}
; 689  : 			else if (!_DEBUG_LT_PRED(this->comp,

	jmp	$LN27@insert@11

; 690  : 				_Key(_Where._Mynode()), this->_Kfn(_Val))
; 691  : 				&& !_DEBUG_LT_PRED(this->comp,

$LN151@insert@11:
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T250299[ebp], edx
	mov	eax, DWORD PTR $T250299[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx]
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN23@insert@11
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Next$[ebp], edx
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::_Dec
	mov	eax, DWORD PTR __Next$[ebp]
	mov	DWORD PTR $T250322[ebp], eax
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR $T250322[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx+12]
	sbb	ecx, ecx
	neg	ecx
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN23@insert@11

; 692  : 					this->_Kfn(_Val), _Key((--(_Next = _Where))._Mynode())))
; 693  : 				{	// insert before _Where
; 694  : 				if (_Isnil(_Right(_Next._Mynode())))

	mov	eax, DWORD PTR __Next$[ebp]
	mov	DWORD PTR $T250345[ebp], eax
	mov	ecx, DWORD PTR $T250345[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movsx	eax, BYTE PTR [edx+33]
	test	eax, eax
	je	SHORT $LN185@insert@11

; 695  : 					return (_Insert(false, _Next._Mynode(), _Val));

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@11

; 696  : 				else

	jmp	SHORT $LN21@insert@11

; 697  : 					return (_Insert(true, _Where._Mynode(), _Val));

$LN185@insert@11:
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@11
$LN21@insert@11:

; 698  : 				}
; 699  : 			else if (!_DEBUG_LT_PRED(this->comp,

	jmp	$LN27@insert@11
$LN23@insert@11:

; 700  : 				this->_Kfn(_Val), _Key(_Where._Mynode()))
; 701  : 				&& (++(_Next = _Where) == end()
; 702  : 					|| !_DEBUG_LT_PRED(this->comp,

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T250361[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR $T250361[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax+12]
	sbb	edx, edx
	neg	edx
	movzx	eax, dl
	test	eax, eax
	jne	$LN27@insert@11
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Next$[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T250390[ebp], eax
	mov	ecx, DWORD PTR $T250390[ebp]
	mov	DWORD PTR $T250155[ebp], ecx
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::_Inc
	mov	edx, DWORD PTR __Next$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T250155[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN18@insert@11
	mov	edx, DWORD PTR __Next$[ebp]
	mov	DWORD PTR $T250409[ebp], edx
	mov	eax, DWORD PTR $T250409[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx]
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN27@insert@11
$LN18@insert@11:

; 703  : 						_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 704  : 				{	// insert after _Where
; 705  : 				if (_Isnil(_Right(_Where._Mynode())))

	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T250429[ebp], edx
	mov	eax, DWORD PTR $T250429[ebp]
	mov	ecx, DWORD PTR [eax+8]
	movsx	edx, BYTE PTR [ecx+33]
	test	edx, edx
	je	SHORT $LN229@insert@11

; 706  : 					return (_Insert(false, _Where._Mynode(), _Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@11

; 707  : 				else

	jmp	SHORT $LN27@insert@11

; 708  : 					return (_Insert(true, _Next._Mynode(), _Val));

$LN229@insert@11:
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@11
$LN27@insert@11:

; 709  : 				}
; 710  : 			}
; 711  : 		else

	jmp	$LN31@insert@11
$LN30@insert@11:

; 712  : 			{	// insert only if unique
; 713  : 			if (_Where == begin())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T250447[ebp], ecx
	mov	edx, DWORD PTR $T250447[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T250460[ebp], eax
	mov	ecx, DWORD PTR $T250460[ebp]
	mov	DWORD PTR $T250156[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T250156[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN14@insert@11

; 714  : 				{	// insert at beginning if before first element
; 715  : 				if (_DEBUG_LT_PRED(this->comp,

	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T250477[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR $T250477[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+12]
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN13@insert@11

; 716  : 					this->_Kfn(_Val), _Key(_Where._Mynode())))
; 717  : 					return (_Insert(true, _Where._Mynode(), _Val));

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@11
$LN13@insert@11:

; 718  : 				}

	jmp	$LN31@insert@11
$LN14@insert@11:

; 719  : 			else if (_Where == end())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T250509[ebp], eax
	mov	ecx, DWORD PTR $T250509[ebp]
	mov	DWORD PTR $T250157[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T250157[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN11@insert@11

; 720  : 				{	// insert at end if after last element
; 721  : 				if (_DEBUG_LT_PRED(this->comp,

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 8
	mov	DWORD PTR $T250530[ebp], eax
	mov	ecx, DWORD PTR $T250530[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR $T250544[ebp], edx
	mov	eax, DWORD PTR $T250544[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN10@insert@11

; 722  : 					_Key(_Rmost()), this->_Kfn(_Val)))
; 723  : 					return (_Insert(false, _Rmost(), _Val));

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	push	0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@11
$LN10@insert@11:

; 724  : 				}
; 725  : 			else if (_DEBUG_LT_PRED(this->comp,

	jmp	$LN31@insert@11
$LN11@insert@11:

; 726  : 				this->_Kfn(_Val), _Key(_Where._Mynode()))
; 727  : 				&& _DEBUG_LT_PRED(this->comp,

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T250559[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR $T250559[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax+12]
	sbb	edx, edx
	neg	edx
	movzx	eax, dl
	test	eax, eax
	je	$LN319@insert@11
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Next$[ebp], ecx
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::_Dec
	mov	edx, DWORD PTR __Next$[ebp]
	mov	DWORD PTR $T250588[ebp], edx
	mov	eax, DWORD PTR $T250588[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx]
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN319@insert@11

; 728  : 					_Key((--(_Next = _Where))._Mynode()), this->_Kfn(_Val)))
; 729  : 				{	// insert before _Where
; 730  : 				if (_Isnil(_Right(_Next._Mynode())))

	mov	edx, DWORD PTR __Next$[ebp]
	mov	DWORD PTR $T250608[ebp], edx
	mov	eax, DWORD PTR $T250608[ebp]
	mov	ecx, DWORD PTR [eax+8]
	movsx	edx, BYTE PTR [ecx+33]
	test	edx, edx
	je	SHORT $LN317@insert@11

; 731  : 					return (_Insert(false, _Next._Mynode(), _Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@11

; 732  : 				else

	jmp	SHORT $LN6@insert@11

; 733  : 					return (_Insert(true, _Where._Mynode(), _Val));

$LN317@insert@11:
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@11
$LN6@insert@11:

; 734  : 				}
; 735  : 			else if (_DEBUG_LT_PRED(this->comp,

	jmp	$LN31@insert@11

; 736  : 				_Key(_Where._Mynode()), this->_Kfn(_Val))
; 737  : 				&& (++(_Next = _Where) == end()
; 738  : 					|| _DEBUG_LT_PRED(this->comp,

$LN319@insert@11:
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T250627[ebp], eax
	mov	ecx, DWORD PTR $T250627[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	cmp	eax, DWORD PTR [edx]
	sbb	ecx, ecx
	neg	ecx
	movzx	edx, cl
	test	edx, edx
	je	$LN31@insert@11
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Next$[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T250653[ebp], edx
	mov	eax, DWORD PTR $T250653[ebp]
	mov	DWORD PTR $T250158[ebp], eax
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::_Inc
	mov	ecx, DWORD PTR __Next$[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T250158[ebp]
	sete	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN3@insert@11
	mov	ecx, DWORD PTR __Next$[ebp]
	mov	DWORD PTR $T250669[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR $T250669[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax+12]
	sbb	edx, edx
	neg	edx
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN31@insert@11
$LN3@insert@11:

; 739  : 						this->_Kfn(_Val), _Key(_Next._Mynode()))))
; 740  : 				{	// insert after _Where
; 741  : 				if (_Isnil(_Right(_Where._Mynode())))

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T250692[ebp], ecx
	mov	edx, DWORD PTR $T250692[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+33]
	test	ecx, ecx
	je	SHORT $LN361@insert@11

; 742  : 					return (_Insert(false, _Where._Mynode(), _Val));

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN33@insert@11

; 743  : 				else

	jmp	SHORT $LN31@insert@11

; 744  : 					return (_Insert(true, _Next._Mynode(), _Val));

$LN361@insert@11:
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Next$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN33@insert@11
$LN31@insert@11:

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	lea	eax, DWORD PTR $T250159[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::insert
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN33@insert@11:

; 749  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::insert
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::erase
; Function compile flags: /Odtp
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -92						; size = 4
$T250947 = -88						; size = 4
$T250913 = -84						; size = 4
$T250746 = -32						; size = 4
$T250733 = -28						; size = 4
$T250721 = -24						; size = 4
$T250711 = -20						; size = 4
$T250710 = -16						; size = 4
$T250709 = -12						; size = 4
$T250708 = -8						; size = 4
$T250707 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1420 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	DWORD PTR _this$[ebp], ecx

; 1421 : 		erase(begin(), end());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T250721[ebp], ecx
	mov	edx, DWORD PTR $T250721[ebp]
	mov	DWORD PTR $T250708[ebp], edx
	mov	eax, DWORD PTR $T250708[ebp]
	mov	DWORD PTR $T250707[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T250733[ebp], edx
	mov	eax, DWORD PTR $T250733[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T250746[ebp], ecx
	mov	edx, DWORD PTR $T250746[ebp]
	mov	DWORD PTR $T250710[ebp], edx
	mov	eax, DWORD PTR $T250710[ebp]
	mov	DWORD PTR $T250709[ebp], eax
	mov	ecx, DWORD PTR $T250707[ebp]
	push	ecx
	mov	edx, DWORD PTR $T250709[ebp]
	push	edx
	lea	eax, DWORD PTR $T250711[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::erase

; 1422 : 		this->_Alptr.destroy(&_Left(_Myhead));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T250913[ebp], edx

; 1423 : 		this->_Alptr.destroy(&_Parent(_Myhead));
; 1424 : 		this->_Alptr.destroy(&_Right(_Myhead));
; 1425 : 		this->_Alnod.deallocate(_Myhead, 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T250947[ebp], ecx
	mov	edx, DWORD PTR $T250947[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1426 : 		_Myhead = 0, _Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 1427 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tidy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIH@2@@Z
_TEXT	SEGMENT
tv90 = -156						; size = 4
_this$ = -152						; size = 4
$T251082 = -148						; size = 4
$T251062 = -144						; size = 4
$T251047 = -140						; size = 4
$T251030 = -136						; size = 4
$T251017 = -132						; size = 4
$T251003 = -128						; size = 4
$T250959 = -45						; size = 1
$T250958 = -44						; size = 4
$T250957 = -37						; size = 1
$T250956 = -36						; size = 4
$T250955 = -29						; size = 1
$T250954 = -28						; size = 4
$T250953 = -24						; size = 4
$T250952 = -17						; size = 1
__Where$224139 = -16					; size = 4
__Trynode$ = -12					; size = 4
__Wherenode$ = -8					; size = 4
__Addleft$ = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIH@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::insert, COMDAT
; _this$ = ecx

; 630  : 		{	// try to insert node with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	mov	DWORD PTR _this$[ebp], ecx

; 631  : 		_Nodeptr _Trynode = _Root();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Trynode$[ebp], edx

; 632  : 		_Nodeptr _Wherenode = _Myhead;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 633  : 		bool _Addleft = true;	// add to left of head if tree empty

	mov	BYTE PTR __Addleft$[ebp], 1

; 634  : 		while (!_Isnil(_Trynode))

$LN19@insert@12:
	mov	edx, DWORD PTR __Trynode$[ebp]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	SHORT $LN9@insert@12

; 635  : 			{	// look for leaf to insert before (_Addleft) or after
; 636  : 			_Wherenode = _Trynode;

	mov	ecx, DWORD PTR __Trynode$[ebp]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 637  : 			_Addleft = _DEBUG_LT_PRED(this->comp,

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR __Trynode$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax+12]
	sbb	edx, edx
	neg	edx
	mov	BYTE PTR __Addleft$[ebp], dl

; 638  : 				this->_Kfn(_Val), _Key(_Trynode));
; 639  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

	movzx	eax, BYTE PTR __Addleft$[ebp]
	test	eax, eax
	je	SHORT $LN33@insert@12
	mov	ecx, DWORD PTR __Trynode$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv90[ebp], edx
	jmp	SHORT $LN14@insert@12
$LN33@insert@12:
	mov	eax, DWORD PTR __Trynode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv90[ebp], ecx
$LN14@insert@12:
	mov	edx, DWORD PTR tv90[ebp]
	mov	DWORD PTR __Trynode$[ebp], edx

; 640  : 			}

	jmp	SHORT $LN19@insert@12
$LN9@insert@12:

; 641  : 
; 642  : 		if (this->_Multi)

	xor	eax, eax
	je	SHORT $LN8@insert@12

; 643  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	BYTE PTR $T250952[ebp], 1
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	movzx	eax, BYTE PTR __Addleft$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T250953[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Insert
	mov	DWORD PTR $T251003[ebp], eax
	mov	edx, DWORD PTR $T251003[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	al, BYTE PTR $T250952[ebp]
	mov	BYTE PTR [edx+4], al
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN11@insert@12

; 644  : 		else

	jmp	$LN11@insert@12
$LN8@insert@12:

; 645  : 			{	// insert only if unique
; 646  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR __Where$224139[ebp], ecx

; 647  : 			if (!_Addleft)

	movzx	edx, BYTE PTR __Addleft$[ebp]
	test	edx, edx
	jne	SHORT $LN6@insert@12
	jmp	$LN79@insert@12
$LN6@insert@12:

; 648  : 				;	// need to test if insert after is okay
; 649  : 			else if (_Where == begin())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T251017[ebp], ecx
	mov	edx, DWORD PTR $T251017[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T251030[ebp], eax
	mov	ecx, DWORD PTR $T251030[ebp]
	mov	DWORD PTR $T250954[ebp], ecx
	mov	edx, DWORD PTR __Where$224139[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T250954[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@insert@12

; 650  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

	mov	BYTE PTR $T250955[ebp], 1
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	push	1
	lea	ecx, DWORD PTR $T250956[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Insert
	mov	DWORD PTR $T251047[ebp], eax
	mov	edx, DWORD PTR $T251047[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	al, BYTE PTR $T250955[ebp]
	mov	BYTE PTR [edx+4], al
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN11@insert@12

; 651  : 			else

	jmp	SHORT $LN79@insert@12
$LN4@insert@12:

; 652  : 				--_Where;	// need to test if insert before is okay

	lea	ecx, DWORD PTR __Where$224139[ebp]
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Dec

; 653  : 
; 654  : 			if (_DEBUG_LT_PRED(this->comp,

$LN79@insert@12:
	mov	ecx, DWORD PTR __Where$224139[ebp]
	mov	DWORD PTR $T251062[ebp], ecx
	mov	edx, DWORD PTR $T251062[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	cmp	ecx, DWORD PTR [eax]
	sbb	edx, edx
	neg	edx
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN2@insert@12

; 655  : 				_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 656  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	BYTE PTR $T250957[ebp], 1
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	movzx	eax, BYTE PTR __Addleft$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T250958[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Insert
	mov	DWORD PTR $T251082[ebp], eax
	mov	edx, DWORD PTR $T251082[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	al, BYTE PTR $T250957[ebp]
	mov	BYTE PTR [edx+4], al
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN11@insert@12

; 657  : 			else

	jmp	SHORT $LN11@insert@12
$LN2@insert@12:

; 658  : 				return (_Pairib(_Where, false));

	mov	BYTE PTR $T250959[ebp], 0
	mov	ecx, DWORD PTR __Where$224139[ebp]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	cl, BYTE PTR $T250959[ebp]
	mov	BYTE PTR [eax+4], cl
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN11@insert@12:

; 659  : 			}
; 660  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIH@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::insert
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rrotate
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lrotate
PUBLIC	__TI3?AVout_of_range@std@@
PUBLIC	??_7out_of_range@std@@6B@			; std::out_of_range::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ ; `string'
PUBLIC	??1out_of_range@std@@UAE@XZ			; std::out_of_range::~out_of_range
PUBLIC	__CTA3?AVout_of_range@std@@
PUBLIC	__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVout_of_range@std@@@8			; std::out_of_range `RTTI Type Descriptor'
PUBLIC	??0out_of_range@std@@QAE@ABV01@@Z		; std::out_of_range::out_of_range
EXTRN	??_Eout_of_range@std@@UAEPAXI@Z:PROC		; std::out_of_range::`vector deleting destructor'
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT
??_R0?AVout_of_range@std@@@8 DD FLAT:??_7type_info@@6B@	; std::out_of_range `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVout_of_range@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0out_of_range@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVout_of_range@std@@
xdata$x	SEGMENT
__CTA3?AVout_of_range@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVout_of_range@std@@
xdata$x	SEGMENT
__TI3?AVout_of_range@std@@ DD 00H
	DD	FLAT:??1out_of_range@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVout_of_range@std@@
xdata$x	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT
??_7out_of_range@std@@6B@ DD FLAT:??_Eout_of_range@std@@UAEPAXI@Z ; std::out_of_range::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
CONST	SEGMENT
??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ DB 'invalid '
	DB	'map/set<T> iterator', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0
__ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
tv177 = -216						; size = 4
tv165 = -212						; size = 4
_this$ = -208						; size = 4
$T251946 = -204						; size = 4
$T251940 = -200						; size = 4
$T251345 = -136						; size = 4
$T251344 = -132						; size = 4
__Tmp$251343 = -125					; size = 1
$T251320 = -124						; size = 4
$T251313 = -120						; size = 4
$T251243 = -116						; size = 4
$T251207 = -112						; size = 4
$T251202 = -108						; size = 4
$T251174 = -104						; size = 4
$T251098 = -100						; size = 4
$T251089 = -96						; size = 28
$T251088 = -68						; size = 40
__Fixnodeparent$ = -28					; size = 4
__Pnode$ = -24						; size = 4
__Fixnode$ = -20					; size = 4
__Erasednode$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase, COMDAT
; _this$ = ecx

; 764  : 		{	// erase element at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 765  : 
; 766  :  #if _HAS_ITERATOR_DEBUGGING
; 767  : 		if (_Where._Mycont != this || _Isnil(_Where._Mynode()))
; 768  : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 769  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 770  : 		++_Where;	// save successor iterator for return
; 771  : 		_Orphan_ptr(*this, _Erasednode);
; 772  : 
; 773  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 774  : 		if (_Isnil(_Where._Mynode()))

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T251098[ebp], eax
	mov	ecx, DWORD PTR $T251098[ebp]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	je	SHORT $LN55@erase@9

; 775  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

	push	OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
	lea	ecx, DWORD PTR $T251089[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T251089[ebp]
	push	eax
	lea	ecx, DWORD PTR $T251088[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR $T251088[ebp], OFFSET ??_7out_of_range@std@@6B@
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	ecx, DWORD PTR $T251088[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T251089[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 776  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

$LN55@erase@9:
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Erasednode$[ebp], edx

; 777  : 		++_Where;	// save successor iterator for return

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Inc

; 778  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 779  : 
; 780  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 781  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 782  : 		_Nodeptr _Pnode = _Erasednode;

	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	DWORD PTR __Pnode$[ebp], eax

; 783  : 
; 784  : 		if (_Isnil(_Left(_Pnode)))

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	je	SHORT $LN67@erase@9

; 785  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Fixnode$[ebp], edx
	jmp	SHORT $LN38@erase@9

; 786  : 		else if (_Isnil(_Right(_Pnode)))

$LN67@erase@9:
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	je	SHORT $LN71@erase@9

; 787  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 788  : 		else

	jmp	SHORT $LN38@erase@9

; 789  : 			{	// two subtrees, must lift successor node to replace erased
; 790  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

$LN71@erase@9:
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Pnode$[ebp], edx

; 791  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Fixnode$[ebp], ecx
$LN38@erase@9:

; 792  : 			}
; 793  : 
; 794  : 		if (_Pnode == _Erasednode)

	mov	edx, DWORD PTR __Pnode$[ebp]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	$LN137@erase@9

; 795  : 			{	// at most one subtree, relink it
; 796  : 			_Fixnodeparent = _Parent(_Erasednode);

	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Fixnodeparent$[ebp], ecx

; 797  : 			if (!_Isnil(_Fixnode))

	mov	edx, DWORD PTR __Fixnode$[ebp]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	SHORT $LN81@erase@9

; 798  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 799  : 
; 800  : 			if (_Root() == _Erasednode)

$LN81@erase@9:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN89@erase@9

; 801  : 				_Root() = _Fixnode;	// link down from root

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [ecx+4], edx
	jmp	SHORT $LN32@erase@9

; 802  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

$LN89@erase@9:
	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN93@erase@9

; 803  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [edx], eax

; 804  : 			else

	jmp	SHORT $LN32@erase@9

; 805  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

$LN93@erase@9:
	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN32@erase@9:

; 806  : 
; 807  : 			if (_Lmost() == _Erasednode)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T251174[ebp], ecx
	mov	edx, DWORD PTR $T251174[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN115@erase@9

; 808  : 				_Lmost() = _Isnil(_Fixnode)
; 809  : 					? _Fixnodeparent	// smallest is parent of erased node
; 810  : 					: _Min(_Fixnode);	// smallest in relinked subtree

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	je	SHORT $LN43@erase@9
	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv165[ebp], eax
	jmp	SHORT $LN44@erase@9
$LN43@erase@9:
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR $T251202[ebp], ecx
$LN107@erase@9:
	mov	edx, DWORD PTR $T251202[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+21]
	test	ecx, ecx
	jne	SHORT $LN103@erase@9
	mov	edx, DWORD PTR $T251202[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T251202[ebp], eax
	jmp	SHORT $LN107@erase@9
$LN103@erase@9:
	mov	ecx, DWORD PTR $T251202[ebp]
	mov	DWORD PTR tv165[ebp], ecx
$LN44@erase@9:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T251207[ebp], eax
	mov	ecx, DWORD PTR $T251207[ebp]
	mov	edx, DWORD PTR tv165[ebp]
	mov	DWORD PTR [ecx], edx

; 811  : 
; 812  : 			if (_Rmost() == _Erasednode)

$LN115@erase@9:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN28@erase@9

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	mov	eax, DWORD PTR __Fixnode$[ebp]
	movsx	ecx, BYTE PTR [eax+21]
	test	ecx, ecx
	je	SHORT $LN45@erase@9
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv177[ebp], edx
	jmp	SHORT $LN131@erase@9
$LN45@erase@9:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR $T251243[ebp], eax
$LN127@erase@9:
	mov	ecx, DWORD PTR $T251243[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	SHORT $LN123@erase@9
	mov	ecx, DWORD PTR $T251243[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T251243[ebp], edx
	jmp	SHORT $LN127@erase@9
$LN123@erase@9:
	mov	eax, DWORD PTR $T251243[ebp]
	mov	DWORD PTR tv177[ebp], eax
$LN131@erase@9:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR tv177[ebp]
	mov	DWORD PTR [edx+8], eax
$LN28@erase@9:

; 816  : 			}
; 817  : 		else

	jmp	$LN192@erase@9

; 818  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 819  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

$LN137@erase@9:
	mov	ecx, DWORD PTR __Erasednode$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx+4], eax

; 820  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Erasednode$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 821  : 
; 822  : 			if (_Pnode == _Right(_Erasednode))

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	mov	edx, DWORD PTR __Pnode$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN145@erase@9

; 823  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Fixnodeparent$[ebp], eax

; 824  : 			else

	jmp	SHORT $LN161@erase@9

; 825  : 				{	// successor further down, link in place of erased
; 826  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's

$LN145@erase@9:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Fixnodeparent$[ebp], edx

; 827  : 				if (!_Isnil(_Fixnode))

	mov	eax, DWORD PTR __Fixnode$[ebp]
	movsx	ecx, BYTE PTR [eax+21]
	test	ecx, ecx
	jne	SHORT $LN151@erase@9

; 828  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [edx+4], eax

; 829  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

$LN151@erase@9:
	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [ecx], edx

; 830  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR __Erasednode$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 831  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 832  : 				}
; 833  : 
; 834  : 			if (_Root() == _Erasednode)

$LN161@erase@9:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN169@erase@9

; 835  : 				_Root() = _Pnode;	// link down from root

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx+4], edx
	jmp	SHORT $LN183@erase@9

; 836  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

$LN169@erase@9:
	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T251313[ebp], ecx
	mov	edx, DWORD PTR $T251313[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN179@erase@9

; 837  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T251320[ebp], edx
	mov	eax, DWORD PTR $T251320[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 838  : 			else

	jmp	SHORT $LN183@erase@9

; 839  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

$LN179@erase@9:
	mov	edx, DWORD PTR __Erasednode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 840  : 
; 841  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

$LN183@erase@9:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 842  : 			_STD swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

	mov	edx, DWORD PTR __Erasednode$[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR $T251345[ebp], edx
	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR $T251344[ebp], eax
	mov	ecx, DWORD PTR $T251344[ebp]
	cmp	ecx, DWORD PTR $T251345[ebp]
	je	SHORT $LN192@erase@9
	mov	edx, DWORD PTR $T251344[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR __Tmp$251343[ebp], al
	mov	ecx, DWORD PTR $T251344[ebp]
	mov	edx, DWORD PTR $T251345[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR $T251345[ebp]
	mov	dl, BYTE PTR __Tmp$251343[ebp]
	mov	BYTE PTR [ecx], dl

; 843  : 			}
; 844  : 
; 845  : 		if (_Color(_Erasednode) == _Black)

$LN192@erase@9:
	mov	eax, DWORD PTR __Erasednode$[ebp]
	movsx	ecx, BYTE PTR [eax+20]
	cmp	ecx, 1
	jne	$LN588@erase@9

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	jmp	SHORT $LN196@erase@9
$LN194@erase@9:
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Fixnodeparent$[ebp], eax
$LN196@erase@9:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Fixnode$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	je	$LN586@erase@9
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	movsx	edx, BYTE PTR [ecx+20]
	cmp	edx, 1
	jne	$LN586@erase@9

; 849  : 				if (_Fixnode == _Left(_Fixnodeparent))

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	$LN395@erase@9

; 850  : 					{	// fixup left subtree
; 851  : 					_Pnode = _Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Pnode$[ebp], eax

; 852  : 					if (_Color(_Pnode) == _Red)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	movsx	edx, BYTE PTR [ecx+20]
	test	edx, edx
	jne	SHORT $LN263@erase@9

; 853  : 						{	// rotate red up from right subtree
; 854  : 						_Color(_Pnode) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [eax+20], 1

; 855  : 						_Color(_Fixnodeparent) = _Red;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	BYTE PTR [ecx+20], 0

; 856  : 						_Lrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lrotate

; 857  : 						_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 858  : 						}
; 859  : 
; 860  : 					if (_Isnil(_Pnode))

$LN263@erase@9:
	mov	edx, DWORD PTR __Pnode$[ebp]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	je	SHORT $LN267@erase@9

; 861  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 862  : 					else if (_Color(_Left(_Pnode)) == _Black

	jmp	$LN12@erase@9

; 863  : 						&& _Color(_Right(_Pnode)) == _Black)

$LN267@erase@9:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+20]
	cmp	ecx, 1
	jne	SHORT $LN277@erase@9
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+20]
	cmp	ecx, 1
	jne	SHORT $LN277@erase@9

; 864  : 						{	// redden right subtree with black children
; 865  : 						_Color(_Pnode) = _Red;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [edx+20], 0

; 866  : 						_Fixnode = _Fixnodeparent;

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], eax

; 867  : 						}
; 868  : 					else

	jmp	SHORT $LN12@erase@9

; 869  : 						{	// must rearrange right subtree
; 870  : 						if (_Color(_Right(_Pnode)) == _Black)

$LN277@erase@9:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movsx	eax, BYTE PTR [edx+20]
	cmp	eax, 1
	jne	SHORT $LN338@erase@9

; 871  : 							{	// rotate red up from left sub-subtree
; 872  : 							_Color(_Left(_Pnode)) = _Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	BYTE PTR [edx+20], 1

; 873  : 							_Color(_Pnode) = _Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [eax+20], 0

; 874  : 							_Rrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rrotate

; 875  : 							_Pnode = _Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Pnode$[ebp], eax

; 876  : 							}
; 877  : 
; 878  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

$LN338@erase@9:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	al, BYTE PTR [edx+20]
	mov	BYTE PTR [ecx+20], al

; 879  : 						_Color(_Fixnodeparent) = _Black;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	BYTE PTR [ecx+20], 1

; 880  : 						_Color(_Right(_Pnode)) = _Black;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	BYTE PTR [eax+20], 1

; 881  : 						_Lrotate(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lrotate

; 882  : 						break;	// tree now recolored/rebalanced

	jmp	$LN586@erase@9
$LN12@erase@9:

; 883  : 						}
; 884  : 					}
; 885  : 				else

	jmp	$LN8@erase@9

; 886  : 					{	// fixup right subtree
; 887  : 					_Pnode = _Left(_Fixnodeparent);

$LN395@erase@9:
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Pnode$[ebp], eax

; 888  : 					if (_Color(_Pnode) == _Red)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	movsx	edx, BYTE PTR [ecx+20]
	test	edx, edx
	jne	SHORT $LN454@erase@9

; 889  : 						{	// rotate red up from left subtree
; 890  : 						_Color(_Pnode) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [eax+20], 1

; 891  : 						_Color(_Fixnodeparent) = _Red;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	BYTE PTR [ecx+20], 0

; 892  : 						_Rrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rrotate

; 893  : 						_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 894  : 						}
; 895  : 					if (_Isnil(_Pnode))

$LN454@erase@9:
	mov	edx, DWORD PTR __Pnode$[ebp]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	je	SHORT $LN458@erase@9

; 896  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 897  : 					else if (_Color(_Right(_Pnode)) == _Black

	jmp	$LN8@erase@9

; 898  : 						&& _Color(_Left(_Pnode)) == _Black)

$LN458@erase@9:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+20]
	cmp	ecx, 1
	jne	SHORT $LN468@erase@9
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+20]
	cmp	ecx, 1
	jne	SHORT $LN468@erase@9

; 899  : 						{	// redden left subtree with black children
; 900  : 						_Color(_Pnode) = _Red;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [edx+20], 0

; 901  : 						_Fixnode = _Fixnodeparent;

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], eax

; 902  : 						}
; 903  : 					else

	jmp	SHORT $LN8@erase@9

; 904  : 						{	// must rearrange left subtree
; 905  : 						if (_Color(_Left(_Pnode)) == _Black)

$LN468@erase@9:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx+20]
	cmp	eax, 1
	jne	SHORT $LN529@erase@9

; 906  : 							{	// rotate red up from right sub-subtree
; 907  : 							_Color(_Right(_Pnode)) = _Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	BYTE PTR [edx+20], 1

; 908  : 							_Color(_Pnode) = _Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [eax+20], 0

; 909  : 							_Lrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lrotate

; 910  : 							_Pnode = _Left(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Pnode$[ebp], eax

; 911  : 							}
; 912  : 
; 913  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

$LN529@erase@9:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	al, BYTE PTR [edx+20]
	mov	BYTE PTR [ecx+20], al

; 914  : 						_Color(_Fixnodeparent) = _Black;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	BYTE PTR [ecx+20], 1

; 915  : 						_Color(_Left(_Pnode)) = _Black;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+20], 1

; 916  : 						_Rrotate(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rrotate

; 917  : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN586@erase@9
$LN8@erase@9:

; 918  : 						}
; 919  : 					}

	jmp	$LN194@erase@9

; 920  : 
; 921  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

$LN586@erase@9:
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	BYTE PTR [edx+20], 1

; 922  : 			}
; 923  : 
; 924  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node

$LN588@erase@9:

; 925  : 		this->_Alnod.deallocate(_Erasednode, 1);

	mov	eax, DWORD PTR __Erasednode$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 926  : 
; 927  : 		if (0 < _Mysize)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	jbe	SHORT $LN1@erase@9

; 928  : 			--_Mysize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN1@erase@9:

; 929  : 
; 930  : 		return (_Make_iter(_Where));	// return successor iterator

	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T251946[ebp], edx
	mov	eax, DWORD PTR $T251946[ebp]
	mov	DWORD PTR $T251940[ebp], eax
	mov	ecx, DWORD PTR $T251940[ebp]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN42@erase@9:

; 931  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0:
	lea	ecx, DWORD PTR $T251089[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR __Message$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
; Function compile flags: /Odtp
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1out_of_range@std@@UAE@XZ PROC			; std::out_of_range::~out_of_range, COMDAT
; _this$ = ecx

; 133  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7out_of_range@std@@6B@

; 134  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1out_of_range@std@@UAE@XZ ENDP			; std::out_of_range::~out_of_range
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gout_of_range@std@@UAEPAXI@Z PROC			; std::out_of_range::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7out_of_range@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	edx, DWORD PTR ___flags$[ebp]
	and	edx, 1
	je	SHORT $LN1@scalar@5
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@5:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gout_of_range@std@@UAEPAXI@Z ENDP			; std::out_of_range::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Erase
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T252021 = -8						; size = 4
?clear@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::clear, COMDAT
; _this$ = ecx

; 965  : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 966  : 
; 967  :  #if _HAS_ITERATOR_DEBUGGING
; 968  : 		this->_Orphan_ptr(*this, 0);
; 969  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 970  : 
; 971  : 		_Erase(_Root());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Erase

; 972  : 		_Root() = _Myhead, _Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 973  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T252021[ebp], eax
	mov	ecx, DWORD PTR $T252021[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 974  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::clear
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z$0
__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z$2
__ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z
_TEXT	SEGMENT
tv141 = -40						; size = 4
tv153 = -36						; size = 4
_this$ = -32						; size = 4
__Pnode$224213 = -24					; size = 4
__Newroot$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Rootnode$ = 8						; size = 4
__Wherenode$ = 12					; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Copy, COMDAT
; _this$ = ecx

; 1075 : 		{	// copy entire subtree, recursively

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1076 : 		_Nodeptr _Newroot = _Myhead;	// point at nil node

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Newroot$[ebp], ecx

; 1077 : 
; 1078 : 		if (!_Isnil(_Rootnode))

	mov	edx, DWORD PTR __Rootnode$[ebp]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	$LN3@Copy@2

; 1079 : 			{	// copy a node, then any subtrees
; 1080 : 			_Nodeptr _Pnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1081 : 				_Myval(_Rootnode), _Color(_Rootnode));

	mov	ecx, DWORD PTR __Rootnode$[ebp]
	movzx	edx, BYTE PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR __Rootnode$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode
	mov	DWORD PTR __Pnode$224213[ebp], eax

; 1082 : 			if (_Isnil(_Newroot))

	mov	eax, DWORD PTR __Newroot$[ebp]
	movsx	ecx, BYTE PTR [eax+21]
	test	ecx, ecx
	je	SHORT $LN2@Copy@2

; 1083 : 				_Newroot = _Pnode;	// memorize new root

	mov	edx, DWORD PTR __Pnode$224213[ebp]
	mov	DWORD PTR __Newroot$[ebp], edx
$LN2@Copy@2:

; 1084 : 
; 1085 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1086 : 			_Left(_Pnode) = _Copy(_Left(_Rootnode), _Pnode);

	mov	eax, DWORD PTR __Pnode$224213[ebp]
	push	eax
	mov	ecx, DWORD PTR __Rootnode$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Copy
	mov	DWORD PTR tv153[ebp], eax
	mov	eax, DWORD PTR __Pnode$224213[ebp]
	mov	ecx, DWORD PTR tv153[ebp]
	mov	DWORD PTR [eax], ecx

; 1087 : 			_Right(_Pnode) = _Copy(_Right(_Rootnode), _Pnode);

	mov	edx, DWORD PTR __Pnode$224213[ebp]
	push	edx
	mov	eax, DWORD PTR __Rootnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Copy
	mov	DWORD PTR tv141[ebp], eax
	mov	edx, DWORD PTR __Pnode$224213[ebp]
	mov	eax, DWORD PTR tv141[ebp]
	mov	DWORD PTR [edx+8], eax
	jmp	SHORT $LN6@Copy@2
__catch$?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z$0:

; 1088 : 			_CATCH_ALL
; 1089 : 			_Erase(_Newroot);	// subtree copy failed, bail out

	mov	ecx, DWORD PTR __Newroot$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Erase

; 1090 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1091 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN3@Copy@2
	ret	0
$LN6@Copy@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN3@Copy@2:

; 1092 : 			}
; 1093 : 
; 1094 : 		return (_Newroot);	// return newly constructed tree

	mov	eax, DWORD PTR __Newroot$[ebp]
$LN5@Copy@2:

; 1095 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Copy
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode
; Function compile flags: /Odtp
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T252111 = -4						; size = 4
?_Init@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Init, COMDAT
; _this$ = ecx

; 1177 : 		{	// create head/nil node and make tree empty

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1178 : 		_Myhead = _Buynode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1179 : 		_Isnil(_Myhead) = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	BYTE PTR [eax+21], 1

; 1180 : 		_Root() = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 1181 : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T252111[ebp], eax
	mov	ecx, DWORD PTR $T252111[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1182 : 		_Mysize = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 1183 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Init@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Init
_TEXT	ENDS
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z$0
__ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z
_TEXT	SEGMENT
tv277 = -196						; size = 4
_this$ = -192						; size = 4
$T252660 = -188						; size = 4
$T252572 = -172						; size = 4
$T252487 = -160						; size = 4
$T252471 = -156						; size = 4
$T252452 = -152						; size = 4
$T252448 = -148						; size = 4
$T252363 = -136						; size = 4
$T252262 = -120						; size = 4
$T252240 = -116						; size = 4
$T252233 = -112						; size = 4
$T252229 = -108						; size = 4
$T252190 = -104						; size = 4
$T252181 = -100						; size = 4
$T252161 = -96						; size = 4
__Count$252143 = -92					; size = 4
$T252127 = -88						; size = 28
$T252126 = -60						; size = 40
__Pnode$224232 = -20					; size = 4
__Newnode$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1187 : 		{	// add node with value next to _Wherenode, to left if _Addnode

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 184				; 000000b8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1188 : 		if (max_size() - 1 <= _Mysize)

	mov	DWORD PTR __Count$252143[ebp], 536870911 ; 1fffffffH
	cmp	DWORD PTR __Count$252143[ebp], 0
	jbe	SHORT $LN25@Insert
	mov	eax, DWORD PTR __Count$252143[ebp]
	mov	DWORD PTR tv277[ebp], eax
	jmp	SHORT $LN21@Insert
$LN25@Insert:
	mov	DWORD PTR tv277[ebp], 1
$LN21@Insert:
	mov	ecx, DWORD PTR tv277[ebp]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR [edx+8]
	ja	SHORT $LN17@Insert

; 1189 : 			_THROW(length_error, "map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T252127[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T252127[ebp]
	push	eax
	lea	ecx, DWORD PTR $T252126[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR $T252126[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T252126[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T252127[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN17@Insert:

; 1190 : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1191 : 			_Val, _Red);

	push	0
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode
	mov	DWORD PTR __Newnode$[ebp], eax

; 1192 : 
; 1193 : 		++_Mysize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1194 : 		if (_Wherenode == _Myhead)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Wherenode$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN16@Insert

; 1195 : 			{	// first node in tree, just set head values
; 1196 : 			_Root() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1197 : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T252161[ebp], edx
	mov	eax, DWORD PTR $T252161[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN15@Insert
$LN16@Insert:

; 1198 : 			}
; 1199 : 		else if (_Addleft)

	movzx	edx, BYTE PTR __Addleft$[ebp]
	test	edx, edx
	je	SHORT $LN52@Insert

; 1200 : 			{	// add to left of _Wherenode
; 1201 : 			_Left(_Wherenode) = _Newnode;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1202 : 			if (_Wherenode == _Lmost())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T252181[ebp], eax
	mov	ecx, DWORD PTR $T252181[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN13@Insert

; 1203 : 				_Lmost() = _Newnode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T252190[ebp], ecx
	mov	edx, DWORD PTR $T252190[ebp]
	mov	eax, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [edx], eax
$LN13@Insert:

; 1204 : 			}
; 1205 : 		else

	jmp	SHORT $LN15@Insert

; 1206 : 			{	// add to right of _Wherenode
; 1207 : 			_Right(_Wherenode) = _Newnode;

$LN52@Insert:
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 1208 : 			if (_Wherenode == _Rmost())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN15@Insert

; 1209 : 				_Rmost() = _Newnode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN15@Insert:

; 1210 : 			}
; 1211 : 
; 1212 : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

	mov	eax, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR __Pnode$224232[ebp], eax
$LN64@Insert:
	mov	ecx, DWORD PTR __Pnode$224232[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movsx	eax, BYTE PTR [edx+20]
	test	eax, eax
	jne	$LN360@Insert

; 1213 : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

	mov	ecx, DWORD PTR __Pnode$224232[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T252229[ebp], edx
	mov	eax, DWORD PTR $T252229[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T252233[ebp], ecx
	mov	edx, DWORD PTR __Pnode$224232[ebp]
	mov	eax, DWORD PTR $T252233[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax]
	jne	$LN216@Insert

; 1214 : 				{	// fixup red-red in left subtree
; 1215 : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR __Pnode$224232[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 4
	mov	DWORD PTR $T252240[ebp], eax
	mov	ecx, DWORD PTR $T252240[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1216 : 				if (_Color(_Wherenode) == _Red)

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	movsx	edx, BYTE PTR [ecx+20]
	test	edx, edx
	jne	SHORT $LN100@Insert

; 1217 : 					{	// parent has two red children, blacken both
; 1218 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$224232[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	BYTE PTR [ecx+20], 1

; 1219 : 					_Color(_Wherenode) = _Black;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [edx+20], 1

; 1220 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	eax, DWORD PTR __Pnode$224232[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T252262[ebp], ecx
	mov	edx, DWORD PTR $T252262[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+20], 0

; 1221 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	ecx, DWORD PTR __Pnode$224232[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$224232[ebp], eax

; 1222 : 					}
; 1223 : 				else

	jmp	SHORT $LN6@Insert

; 1224 : 					{	// parent has red and black children
; 1225 : 					if (_Pnode == _Right(_Parent(_Pnode)))

$LN100@Insert:
	mov	ecx, DWORD PTR __Pnode$224232[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Pnode$224232[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN155@Insert

; 1226 : 						{	// rotate right child to left
; 1227 : 						_Pnode = _Parent(_Pnode);

	mov	ecx, DWORD PTR __Pnode$224232[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Pnode$224232[ebp], edx

; 1228 : 						_Lrotate(_Pnode);

	mov	eax, DWORD PTR __Pnode$224232[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lrotate

; 1229 : 						}
; 1230 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

$LN155@Insert:
	mov	ecx, DWORD PTR __Pnode$224232[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+20], 1

; 1231 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	eax, DWORD PTR __Pnode$224232[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T252363[ebp], ecx
	mov	edx, DWORD PTR $T252363[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+20], 0

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

	mov	ecx, DWORD PTR __Pnode$224232[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rrotate
$LN6@Insert:

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	$LN4@Insert

; 1236 : 				{	// fixup red-red in right subtree
; 1237 : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));

$LN216@Insert:
	mov	ecx, DWORD PTR __Pnode$224232[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T252448[ebp], edx
	mov	eax, DWORD PTR $T252448[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T252452[ebp], ecx
	mov	edx, DWORD PTR $T252452[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1238 : 				if (_Color(_Wherenode) == _Red)

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	movsx	edx, BYTE PTR [ecx+20]
	test	edx, edx
	jne	SHORT $LN240@Insert

; 1239 : 					{	// parent has two red children, blacken both
; 1240 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$224232[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	BYTE PTR [ecx+20], 1

; 1241 : 					_Color(_Wherenode) = _Black;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [edx+20], 1

; 1242 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	eax, DWORD PTR __Pnode$224232[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T252471[ebp], ecx
	mov	edx, DWORD PTR $T252471[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+20], 0

; 1243 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	ecx, DWORD PTR __Pnode$224232[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$224232[ebp], eax

; 1244 : 					}
; 1245 : 				else

	jmp	SHORT $LN4@Insert

; 1246 : 					{	// parent has red and black children
; 1247 : 					if (_Pnode == _Left(_Parent(_Pnode)))

$LN240@Insert:
	mov	ecx, DWORD PTR __Pnode$224232[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T252487[ebp], edx
	mov	eax, DWORD PTR $T252487[ebp]
	mov	ecx, DWORD PTR __Pnode$224232[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN297@Insert

; 1248 : 						{	// rotate left child to right
; 1249 : 						_Pnode = _Parent(_Pnode);

	mov	edx, DWORD PTR __Pnode$224232[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$224232[ebp], eax

; 1250 : 						_Rrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$224232[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rrotate

; 1251 : 						}
; 1252 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

$LN297@Insert:
	mov	edx, DWORD PTR __Pnode$224232[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	BYTE PTR [eax+20], 1

; 1253 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR __Pnode$224232[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T252572[ebp], edx
	mov	eax, DWORD PTR $T252572[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	BYTE PTR [ecx+20], 0

; 1254 : 					_Lrotate(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR __Pnode$224232[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lrotate
$LN4@Insert:

; 1255 : 					}
; 1256 : 				}

	jmp	$LN64@Insert

; 1257 : 
; 1258 : 		_Color(_Root()) = _Black;	// root is always black

$LN360@Insert:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 4
	mov	DWORD PTR $T252660[ebp], eax
	mov	ecx, DWORD PTR $T252660[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	BYTE PTR [edx+20], 1

; 1259 : 		return (_TREE_ITERATOR(_Newnode));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN19@Insert:

; 1260 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z$0:
	lea	ecx, DWORD PTR $T252127[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-188]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIH@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Insert
; Function compile flags: /Odtp
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABI@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Pnode$ = -8						; size = 4
__Wherenode$ = -4					; size = 4
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABI@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 1263 : 		{	// find leftmost node not less than _Keyval

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1264 : 		_Nodeptr _Pnode = _Root();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Pnode$[ebp], edx

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

$LN11@Lbound:
	mov	edx, DWORD PTR __Pnode$[ebp]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	SHORT $LN3@Lbound

; 1268 : 			if (_DEBUG_LT_PRED(this->comp, _Key(_Pnode), _Keyval))

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Keyval$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	cmp	eax, DWORD PTR [edx]
	sbb	ecx, ecx
	neg	ecx
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@Lbound

; 1269 : 				_Pnode = _Right(_Pnode);	// descend right subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1270 : 			else

	jmp	SHORT $LN1@Lbound
$LN2@Lbound:

; 1271 : 				{	// _Pnode not less than _Keyval, remember it
; 1272 : 				_Wherenode = _Pnode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Wherenode$[ebp], edx

; 1273 : 				_Pnode = _Left(_Pnode);	// descend left subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
$LN1@Lbound:

; 1274 : 				}

	jmp	SHORT $LN11@Lbound
$LN3@Lbound:

; 1275 : 
; 1276 : 		return (_Wherenode);	// return best remembered candidate

	mov	eax, DWORD PTR __Wherenode$[ebp]

; 1277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Lbound@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABI@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lbound
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	__$ArrayPad$
EXTRN	__imp_?swap@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXAAV12@@Z:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$8 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$2
__catchsym$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$7 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$0
__ehfuncinfo$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$7
	DD	03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$8
__unwindtable$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$4
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$5
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
tv84 = -412						; size = 4
tv312 = -408						; size = 4
tv298 = -404						; size = 4
tv290 = -400						; size = 4
_this$ = -396						; size = 4
$T253355 = -392						; size = 4
$T253347 = -388						; size = 4
$T253346 = -384						; size = 4
$T253326 = -378						; size = 1
$T253325 = -377						; size = 1
$T253324 = -376						; size = 4
$T253323 = -372						; size = 4
$T253322 = -368						; size = 4
__Cat$253333 = -360					; size = 1
$T253331 = -359						; size = 1
$T253330 = -358						; size = 1
$T253329 = -357						; size = 1
$T253292 = -356						; size = 4
$T253282 = -352						; size = 4
__Cat$253290 = -347					; size = 1
$T253288 = -346						; size = 1
$T253287 = -345						; size = 1
$T253266 = -344						; size = 4
$T253258 = -340						; size = 4
$T253250 = -336						; size = 4
$T253229 = -332						; size = 4
$T253228 = -328						; size = 4
$T253209 = -324						; size = 4
$T253208 = -320						; size = 4
__Cat$253235 = -314					; size = 1
$T253233 = -313						; size = 1
$T253169 = -312						; size = 4
$T253168 = -308						; size = 4
$T253158 = -304						; size = 4
__Cat$253166 = -299					; size = 1
$T253164 = -298						; size = 1
$T253163 = -297						; size = 1
$T253142 = -296						; size = 4
$T253132 = -292						; size = 4
__Cat$253140 = -287					; size = 1
$T253137 = -286						; size = 1
$T253136 = -285						; size = 1
$T253116 = -284						; size = 4
$T253115 = -280						; size = 4
$T253111 = -276						; size = 4
$T253110 = -272						; size = 4
$T253089 = -268						; size = 4
$T253088 = -264						; size = 4
$T253069 = -260						; size = 4
$T253068 = -256						; size = 4
__Cat$253096 = -250					; size = 1
$T253093 = -249						; size = 1
$T253003 = -248						; size = 4
$T253002 = -244						; size = 4
$T252983 = -240						; size = 4
$T252982 = -236						; size = 4
__Cat$253010 = -230					; size = 1
$T253007 = -229						; size = 1
$T252923 = -228						; size = 4
$T252922 = -224						; size = 4
$T252903 = -220						; size = 4
$T252902 = -216						; size = 4
__Cat$252929 = -210					; size = 1
$T252927 = -209						; size = 1
$T252863 = -208						; size = 4
$T252853 = -204						; size = 4
__Cat$252861 = -199					; size = 1
$T252859 = -198						; size = 1
$T252858 = -197						; size = 1
$T252837 = -196						; size = 4
$T252827 = -192						; size = 4
__Cat$252835 = -187					; size = 1
$T252833 = -186						; size = 1
$T252832 = -185						; size = 1
$T252811 = -184						; size = 4
$T252801 = -180						; size = 4
__Cat$252809 = -175					; size = 1
$T252807 = -174						; size = 1
$T252806 = -173						; size = 1
__Count$252776 = -172					; size = 4
__Count$252750 = -100					; size = 4
__Tmp$224329 = -96					; size = 28
__Oldend$224330 = -68					; size = 4
__Tmp$224319 = -64					; size = 28
__$ArrayPad$ = -36					; size = 4
__Ncopied$224306 = -32					; size = 4
__Newvec$224304 = -28					; size = 4
__Whereoff$224305 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 396				; 0000018cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN31@Insert_n
	mov	DWORD PTR tv290[ebp], 0
	jmp	SHORT $LN29@Insert_n
$LN31@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	mov	DWORD PTR tv290[ebp], eax
$LN29@Insert_n:
	mov	edx, DWORD PTR tv290[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n
	jmp	$LN16@Insert_n
$LN14@Insert_n:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$252750[ebp], 153391689 ; 09249249H
	cmp	DWORD PTR __Count$252750[ebp], 0
	jbe	SHORT $LN37@Insert_n
	mov	eax, DWORD PTR __Count$252750[ebp]
	mov	DWORD PTR tv298[ebp], eax
	jmp	SHORT $LN39@Insert_n
$LN37@Insert_n:
	mov	DWORD PTR tv298[ebp], 1
$LN39@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	mov	edx, DWORD PTR tv298[ebp]
	sub	edx, eax
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	SHORT $LN44@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen
	jmp	$LN16@Insert_n

; 1167 : 		else if (_Capacity < size() + _Count)

$LN44@Insert_n:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$252776[ebp], 153391689 ; 09249249H
	cmp	DWORD PTR __Count$252776[ebp], 0
	jbe	SHORT $LN50@Insert_n
	mov	edx, DWORD PTR __Count$252776[ebp]
	mov	DWORD PTR tv312[ebp], edx
	jmp	SHORT $LN46@Insert_n
$LN50@Insert_n:
	mov	DWORD PTR tv312[ebp], 1
$LN46@Insert_n:
	mov	eax, DWORD PTR __Capacity$[ebp]
	shr	eax, 1
	mov	ecx, DWORD PTR tv312[ebp]
	sub	ecx, eax
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN56@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN56@Insert_n:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	add	esp, 8
	mov	DWORD PTR __Newvec$224304[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	mov	DWORD PTR __Whereoff$224305[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$224306[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	edx, DWORD PTR __Whereoff$224305[ebp]
	imul	edx, 28					; 0000001cH
	add	edx, DWORD PTR __Newvec$224304[ebp]
	mov	DWORD PTR $T252811[ebp], edx
	mov	eax, DWORD PTR $T252811[ebp]
	mov	DWORD PTR $T252801[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T252806[ebp], cl
	mov	dl, BYTE PTR __Cat$252809[ebp]
	mov	BYTE PTR $T252807[ebp], dl
	movzx	eax, BYTE PTR $T252806[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T252807[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T252801[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	add	esp, 24					; 00000018H

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$224306[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$224306[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T252837[ebp], edx
	mov	eax, DWORD PTR __Newvec$224304[ebp]
	mov	DWORD PTR $T252827[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T252832[ebp], cl
	mov	dl, BYTE PTR __Cat$252835[ebp]
	mov	BYTE PTR $T252833[ebp], dl
	movzx	eax, BYTE PTR $T252832[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T252833[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T252827[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T252837[ebp]
	push	edx
	call	??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	add	esp, 24					; 00000018H

; 1182 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$224306[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$224306[ebp], eax

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T252863[ebp], edx
	mov	eax, DWORD PTR __Whereoff$224305[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	imul	eax, 28					; 0000001cH
	add	eax, DWORD PTR __Newvec$224304[ebp]
	mov	DWORD PTR $T252853[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T252858[ebp], cl
	mov	dl, BYTE PTR __Cat$252861[ebp]
	mov	BYTE PTR $T252859[ebp], dl
	movzx	eax, BYTE PTR $T252858[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T252859[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T252853[ebp]
	push	eax
	mov	ecx, DWORD PTR $T252863[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	call	??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	add	esp, 24					; 00000018H
	jmp	$LN19@Insert_n
__catch$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$224306[ebp], 1
	jle	SHORT $LN7@Insert_n

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	eax, DWORD PTR __Whereoff$224305[ebp]
	imul	eax, 28					; 0000001cH
	add	eax, DWORD PTR __Newvec$224304[ebp]
	mov	DWORD PTR $T252923[ebp], eax
	mov	ecx, DWORD PTR __Newvec$224304[ebp]
	mov	DWORD PTR $T252922[ebp], ecx
	mov	dl, BYTE PTR __Cat$252929[ebp]
	mov	BYTE PTR $T252927[ebp], dl
	mov	eax, DWORD PTR $T252923[ebp]
	mov	DWORD PTR $T252903[ebp], eax
	mov	ecx, DWORD PTR $T252922[ebp]
	mov	DWORD PTR $T252902[ebp], ecx
	jmp	SHORT $LN84@Insert_n
$LN83@Insert_n:
	mov	edx, DWORD PTR $T252902[ebp]
	add	edx, 28					; 0000001cH
	mov	DWORD PTR $T252902[ebp], edx
$LN84@Insert_n:
	mov	eax, DWORD PTR $T252902[ebp]
	cmp	eax, DWORD PTR $T252903[ebp]
	je	SHORT $LN7@Insert_n
	mov	ecx, DWORD PTR $T252902[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	xor	ecx, ecx
	and	ecx, 1
	je	SHORT $LN87@Insert_n
	mov	edx, DWORD PTR $T252902[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN87@Insert_n:
	jmp	SHORT $LN83@Insert_n
$LN7@Insert_n:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$224306[ebp], 0
	jle	$LN6@Insert_n

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR __Whereoff$224305[ebp]
	imul	ecx, 28					; 0000001cH
	add	ecx, DWORD PTR __Newvec$224304[ebp]
	add	ecx, eax
	mov	DWORD PTR $T253003[ebp], ecx
	mov	edx, DWORD PTR __Whereoff$224305[ebp]
	imul	edx, 28					; 0000001cH
	add	edx, DWORD PTR __Newvec$224304[ebp]
	mov	DWORD PTR $T253002[ebp], edx
	mov	al, BYTE PTR __Cat$253010[ebp]
	mov	BYTE PTR $T253007[ebp], al
	mov	ecx, DWORD PTR $T253003[ebp]
	mov	DWORD PTR $T252983[ebp], ecx
	mov	edx, DWORD PTR $T253002[ebp]
	mov	DWORD PTR $T252982[ebp], edx
	jmp	SHORT $LN102@Insert_n
$LN101@Insert_n:
	mov	eax, DWORD PTR $T252982[ebp]
	add	eax, 28					; 0000001cH
	mov	DWORD PTR $T252982[ebp], eax
$LN102@Insert_n:
	mov	ecx, DWORD PTR $T252982[ebp]
	cmp	ecx, DWORD PTR $T252983[ebp]
	je	SHORT $LN6@Insert_n
	mov	ecx, DWORD PTR $T252982[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	xor	edx, edx
	and	edx, 1
	je	SHORT $LN105@Insert_n
	mov	eax, DWORD PTR $T252982[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN105@Insert_n:
	jmp	SHORT $LN101@Insert_n
$LN6@Insert_n:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	ecx, DWORD PTR __Newvec$224304[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN114@Insert_n
	ret	0
$LN19@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN114@Insert_n:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN5@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T253111[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T253110[ebp], eax
	mov	ecx, DWORD PTR $T253111[ebp]
	mov	DWORD PTR $T253089[ebp], ecx
	mov	edx, DWORD PTR $T253110[ebp]
	mov	DWORD PTR $T253088[ebp], edx
	mov	al, BYTE PTR __Cat$253096[ebp]
	mov	BYTE PTR $T253093[ebp], al
	mov	ecx, DWORD PTR $T253089[ebp]
	mov	DWORD PTR $T253069[ebp], ecx
	mov	edx, DWORD PTR $T253088[ebp]
	mov	DWORD PTR $T253068[ebp], edx
	jmp	SHORT $LN124@Insert_n
$LN123@Insert_n:
	mov	eax, DWORD PTR $T253068[ebp]
	add	eax, 28					; 0000001cH
	mov	DWORD PTR $T253068[ebp], eax
$LN124@Insert_n:
	mov	ecx, DWORD PTR $T253068[ebp]
	cmp	ecx, DWORD PTR $T253069[ebp]
	je	SHORT $LN116@Insert_n
	mov	ecx, DWORD PTR $T253068[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	xor	edx, edx
	and	edx, 1
	je	SHORT $LN127@Insert_n
	mov	eax, DWORD PTR $T253068[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN127@Insert_n:
	jmp	SHORT $LN123@Insert_n
$LN116@Insert_n:

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	mov	DWORD PTR $T253116[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T253115[ebp], eax
	mov	ecx, DWORD PTR $T253115[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	imul	edx, 28					; 0000001cH
	add	edx, DWORD PTR __Newvec$224304[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 28					; 0000001cH
	add	ecx, DWORD PTR __Newvec$224304[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newvec$224304[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	$LN16@Insert_n
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Tmp$224319[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T253142[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 28					; 0000001cH
	add	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T253132[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T253136[ebp], al
	mov	cl, BYTE PTR __Cat$253140[ebp]
	mov	BYTE PTR $T253137[ebp], cl
	movzx	edx, BYTE PTR $T253136[ebp]
	push	edx
	movzx	eax, BYTE PTR $T253137[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T253132[ebp]
	push	edx
	mov	eax, DWORD PTR $T253142[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	call	??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	add	esp, 24					; 00000018H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 3

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, eax
	mov	DWORD PTR $T253169[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T253168[ebp], ecx
	mov	edx, DWORD PTR $T253168[ebp]
	mov	DWORD PTR $T253158[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T253163[ebp], al
	mov	cl, BYTE PTR __Cat$253166[ebp]
	mov	BYTE PTR $T253164[ebp], cl
	movzx	edx, BYTE PTR $T253163[ebp]
	push	edx
	movzx	eax, BYTE PTR $T253164[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Tmp$224319[ebp]
	push	edx
	mov	eax, DWORD PTR $T253169[ebp]
	push	eax
	mov	ecx, DWORD PTR $T253158[ebp]
	push	ecx
	call	??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	add	esp, 24					; 00000018H
	jmp	$LN21@Insert_n
__catch$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+8]
	mov	DWORD PTR $T253250[ebp], edx
	mov	ecx, DWORD PTR $T253250[ebp]
	mov	DWORD PTR $T253229[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 28					; 0000001cH
	add	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T253228[ebp], edx
	mov	al, BYTE PTR __Cat$253235[ebp]
	mov	BYTE PTR $T253233[ebp], al
	mov	ecx, DWORD PTR $T253229[ebp]
	mov	DWORD PTR $T253209[ebp], ecx
	mov	edx, DWORD PTR $T253228[ebp]
	mov	DWORD PTR $T253208[ebp], edx
	jmp	SHORT $LN156@Insert_n
$LN155@Insert_n:
	mov	eax, DWORD PTR $T253208[ebp]
	add	eax, 28					; 0000001cH
	mov	DWORD PTR $T253208[ebp], eax
$LN156@Insert_n:
	mov	ecx, DWORD PTR $T253208[ebp]
	cmp	ecx, DWORD PTR $T253209[ebp]
	je	SHORT $LN148@Insert_n
	mov	ecx, DWORD PTR $T253208[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	xor	edx, edx
	and	edx, 1
	je	SHORT $LN159@Insert_n
	mov	eax, DWORD PTR $T253208[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN159@Insert_n:
	jmp	SHORT $LN155@Insert_n
$LN148@Insert_n:

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 2
	mov	eax, __tryend$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$3
	ret	0
$LN21@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], 2
__tryend$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, ecx
	mov	DWORD PTR $T253266[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T253258[ebp], ecx
	jmp	SHORT $LN170@Insert_n
$LN169@Insert_n:
	mov	edx, DWORD PTR $T253258[ebp]
	add	edx, 28					; 0000001cH
	mov	DWORD PTR $T253258[ebp], edx
$LN170@Insert_n:
	mov	eax, DWORD PTR $T253258[ebp]
	cmp	eax, DWORD PTR $T253266[ebp]
	je	SHORT $LN166@Insert_n
	lea	ecx, DWORD PTR __Tmp$224319[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T253258[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	jmp	SHORT $LN169@Insert_n
$LN166@Insert_n:

; 1232 : 			}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Tmp$224319[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1233 : 		else

	jmp	$LN16@Insert_n
$LN3@Insert_n:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Tmp$224329[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+12], 5

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Oldend$224330[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T253292[ebp], eax
	mov	ecx, DWORD PTR $T253292[ebp]
	mov	DWORD PTR $T253282[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T253287[ebp], dl
	mov	al, BYTE PTR __Cat$253290[ebp]
	mov	BYTE PTR $T253288[ebp], al
	movzx	ecx, BYTE PTR $T253287[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T253288[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T253282[ebp]
	push	ecx
	mov	edx, DWORD PTR __Oldend$224330[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR __Oldend$224330[ebp]
	sub	ecx, eax
	push	ecx
	call	??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, DWORD PTR __Oldend$224330[ebp]
	mov	DWORD PTR $T253347[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T253346[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T253329[ebp], dl
	mov	al, BYTE PTR __Cat$253333[ebp]
	mov	BYTE PTR $T253330[ebp], al
	mov	cl, BYTE PTR $T253329[ebp]
	mov	BYTE PTR $T253326[ebp], cl
	mov	dl, BYTE PTR $T253331[ebp]
	mov	BYTE PTR $T253325[ebp], dl
	mov	eax, DWORD PTR $T253347[ebp]
	mov	DWORD PTR $T253324[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR __Oldend$224330[ebp]
	sub	edx, ecx
	mov	DWORD PTR $T253323[ebp], edx
	mov	eax, DWORD PTR $T253346[ebp]
	mov	DWORD PTR $T253322[ebp], eax
$LN186@Insert_n:
	mov	ecx, DWORD PTR $T253322[ebp]
	cmp	ecx, DWORD PTR $T253323[ebp]
	je	SHORT $LN179@Insert_n
	mov	edx, DWORD PTR $T253323[ebp]
	sub	edx, 28					; 0000001cH
	mov	DWORD PTR $T253323[ebp], edx
	mov	eax, DWORD PTR $T253324[ebp]
	sub	eax, 28					; 0000001cH
	mov	DWORD PTR $T253324[ebp], eax
	mov	ecx, DWORD PTR $T253323[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T253324[ebp]
	call	DWORD PTR __imp_?swap@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXAAV12@@Z
	jmp	SHORT $LN186@Insert_n
$LN179@Insert_n:

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T253355[ebp], edx
	jmp	SHORT $LN197@Insert_n
$LN196@Insert_n:
	mov	eax, DWORD PTR $T253355[ebp]
	add	eax, 28					; 0000001cH
	mov	DWORD PTR $T253355[ebp], eax
$LN197@Insert_n:
	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 28					; 0000001cH
	add	ecx, DWORD PTR __Where$[ebp]
	cmp	DWORD PTR $T253355[ebp], ecx
	je	SHORT $LN193@Insert_n
	lea	edx, DWORD PTR __Tmp$224329[ebp]
	push	edx
	mov	ecx, DWORD PTR $T253355[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	jmp	SHORT $LN196@Insert_n
$LN193@Insert_n:

; 1249 : 			}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Tmp$224329[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN16@Insert_n:

; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$4:
	lea	ecx, DWORD PTR __Tmp$224319[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$5:
	lea	ecx, DWORD PTR __Tmp$224329[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-416]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Insert_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ
_TEXT	SEGMENT
$T253377 = -80						; size = 28
$T253376 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T253377[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T253376[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T253376[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T253377[ebp]
	push	eax
	lea	ecx, DWORD PTR $T253376[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T253376[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T253376[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T253377[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@3:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T253377[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T253376[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen
PUBLIC	??$_Unchecked_move_backward@PAVCvReplayMessage@@PAV1@@stdext@@YAPAVCvReplayMessage@@PAV1@00@Z ; stdext::_Unchecked_move_backward<CvReplayMessage *,CvReplayMessage *>
PUBLIC	??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvReplayMessage *,CvReplayMessage *,std::allocator<CvReplayMessage> >
PUBLIC	??$unchecked_uninitialized_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@stdext@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvReplayMessage *,CvReplayMessage *,std::allocator<CvReplayMessage> >
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z$14 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z$2
__catchsym$?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z$13 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z$0
__ehfuncinfo$?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z$13
	DD	03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z$14
__unwindtable$?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z$4
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z$5
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z
_TEXT	SEGMENT
tv84 = -648						; size = 4
tv312 = -644						; size = 4
tv298 = -640						; size = 4
tv290 = -636						; size = 4
_this$ = -632						; size = 4
$T254262 = -628						; size = 4
$T254030 = -488						; size = 4
$T254011 = -484						; size = 4
$T253994 = -477						; size = 1
$T253993 = -476						; size = 4
$T253983 = -472						; size = 4
$T253982 = -468						; size = 4
__Cat$254025 = -462					; size = 1
$T254022 = -461						; size = 1
$T254021 = -460						; size = 1
__Cat$254018 = -459					; size = 1
$T254015 = -458						; size = 1
$T254014 = -457						; size = 1
$T253950 = -452						; size = 4
$T253942 = -448						; size = 4
$T253929 = -440						; size = 4
$T253911 = -436						; size = 4
$T253910 = -432						; size = 4
$T253894 = -428						; size = 4
$T253893 = -424						; size = 4
__Cat$253918 = -418					; size = 1
$T253916 = -417						; size = 1
$T253867 = -416						; size = 4
$T253866 = -412						; size = 4
$T253856 = -408						; size = 4
__Cat$253864 = -403					; size = 1
$T253862 = -402						; size = 1
$T253861 = -401						; size = 1
$T253840 = -400						; size = 4
$T253821 = -396						; size = 4
$T253804 = -389						; size = 1
$T253803 = -388						; size = 4
$T253793 = -384						; size = 4
$T253792 = -380						; size = 4
__Cat$253837 = -374					; size = 1
$T253835 = -373						; size = 1
$T253834 = -372						; size = 1
__Cat$253829 = -371					; size = 1
$T253827 = -370						; size = 1
$T253826 = -369						; size = 1
$T253760 = -364						; size = 4
$T253759 = -360						; size = 4
$T253755 = -356						; size = 4
$T253754 = -352						; size = 4
$T253736 = -348						; size = 4
$T253735 = -344						; size = 4
$T253719 = -340						; size = 4
$T253718 = -336						; size = 4
__Cat$253743 = -330					; size = 1
$T253741 = -329						; size = 1
$T253669 = -328						; size = 4
$T253668 = -324						; size = 4
$T253652 = -320						; size = 4
$T253651 = -316						; size = 4
__Cat$253676 = -310					; size = 1
$T253674 = -309						; size = 1
$T253608 = -308						; size = 4
$T253607 = -304						; size = 4
$T253591 = -300						; size = 4
$T253590 = -296						; size = 4
__Cat$253615 = -290					; size = 1
$T253613 = -289						; size = 1
$T253564 = -288						; size = 4
$T253552 = -284						; size = 4
$T253542 = -277						; size = 1
$T253541 = -276						; size = 4
__Cat$253560 = -271					; size = 1
$T253558 = -270						; size = 1
$T253557 = -269						; size = 1
$T253529 = -268						; size = 4
$T253517 = -264						; size = 4
$T253507 = -257						; size = 1
$T253506 = -256						; size = 4
__Cat$253525 = -251					; size = 1
$T253523 = -250						; size = 1
$T253522 = -249						; size = 1
$T253494 = -248						; size = 4
$T253484 = -244						; size = 4
__Cat$253492 = -239					; size = 1
$T253490 = -238						; size = 1
$T253489 = -237						; size = 1
__Count$253456 = -236					; size = 4
__Count$253430 = -164					; size = 4
__Tmp$224380 = -160					; size = 60
__Oldend$224381 = -100					; size = 4
__Tmp$224370 = -96					; size = 60
__$ArrayPad$ = -36					; size = 4
__Ncopied$224357 = -32					; size = 4
__Newvec$224355 = -28					; size = 4
__Whereoff$224356 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z PROC ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 632				; 00000278H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN31@Insert_n@2
	mov	DWORD PTR tv290[ebp], 0
	jmp	SHORT $LN29@Insert_n@2
$LN31@Insert_n@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 60					; 0000003cH
	idiv	ecx
	mov	DWORD PTR tv290[ebp], eax
$LN29@Insert_n@2:
	mov	edx, DWORD PTR tv290[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@2
	jmp	$LN16@Insert_n@2
$LN14@Insert_n@2:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$253430[ebp], 71582788	; 04444444H
	cmp	DWORD PTR __Count$253430[ebp], 0
	jbe	SHORT $LN37@Insert_n@2
	mov	eax, DWORD PTR __Count$253430[ebp]
	mov	DWORD PTR tv298[ebp], eax
	jmp	SHORT $LN39@Insert_n@2
$LN37@Insert_n@2:
	mov	DWORD PTR tv298[ebp], 1
$LN39@Insert_n@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 60					; 0000003cH
	idiv	ecx
	mov	edx, DWORD PTR tv298[ebp]
	sub	edx, eax
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	SHORT $LN44@Insert_n@2

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@KAXXZ ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Xlen
	jmp	$LN16@Insert_n@2

; 1167 : 		else if (_Capacity < size() + _Count)

$LN44@Insert_n@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 60					; 0000003cH
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@2

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$253456[ebp], 71582788	; 04444444H
	cmp	DWORD PTR __Count$253456[ebp], 0
	jbe	SHORT $LN50@Insert_n@2
	mov	edx, DWORD PTR __Count$253456[ebp]
	mov	DWORD PTR tv312[ebp], edx
	jmp	SHORT $LN46@Insert_n@2
$LN50@Insert_n@2:
	mov	DWORD PTR tv312[ebp], 1
$LN46@Insert_n@2:
	mov	eax, DWORD PTR __Capacity$[ebp]
	shr	eax, 1
	mov	ecx, DWORD PTR tv312[ebp]
	sub	ecx, eax
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@2
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@2
$LN17@Insert_n@2:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n@2:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 60					; 0000003cH
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN56@Insert_n@2

; 1172 : 				_Capacity = size() + _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 60					; 0000003cH
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN56@Insert_n@2:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@VCvReplayMessage@@@std@@YAPAVCvReplayMessage@@IPAV1@@Z ; std::_Allocate<CvReplayMessage>
	add	esp, 8
	mov	DWORD PTR __Newvec$224355[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 60					; 0000003cH
	idiv	ecx
	mov	DWORD PTR __Whereoff$224356[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$224357[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	edx, DWORD PTR __Whereoff$224356[ebp]
	imul	edx, 60					; 0000003cH
	add	edx, DWORD PTR __Newvec$224355[ebp]
	mov	DWORD PTR $T253494[ebp], edx
	mov	eax, DWORD PTR $T253494[ebp]
	mov	DWORD PTR $T253484[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T253489[ebp], cl
	mov	dl, BYTE PTR __Cat$253492[ebp]
	mov	BYTE PTR $T253490[ebp], dl
	movzx	eax, BYTE PTR $T253489[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T253490[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T253484[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvReplayMessage *,unsigned int,CvReplayMessage,std::allocator<CvReplayMessage> >
	add	esp, 24					; 00000018H

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$224357[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$224357[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T253529[ebp], edx
	mov	eax, DWORD PTR __Newvec$224355[ebp]
	mov	DWORD PTR $T253517[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T253522[ebp], cl
	mov	dl, BYTE PTR __Cat$253525[ebp]
	mov	BYTE PTR $T253523[ebp], dl
	mov	al, BYTE PTR $T253522[ebp]
	mov	BYTE PTR $T253507[ebp], al
	mov	ecx, DWORD PTR $T253517[ebp]
	mov	DWORD PTR $T253506[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T253506[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T253529[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@stdext@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvReplayMessage *,CvReplayMessage *,std::allocator<CvReplayMessage> >
	add	esp, 16					; 00000010H

; 1182 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$224357[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$224357[ebp], eax

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T253564[ebp], edx
	mov	eax, DWORD PTR __Whereoff$224356[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	imul	eax, 60					; 0000003cH
	add	eax, DWORD PTR __Newvec$224355[ebp]
	mov	DWORD PTR $T253552[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T253557[ebp], cl
	mov	dl, BYTE PTR __Cat$253560[ebp]
	mov	BYTE PTR $T253558[ebp], dl
	mov	al, BYTE PTR $T253557[ebp]
	mov	BYTE PTR $T253542[ebp], al
	mov	ecx, DWORD PTR $T253552[ebp]
	mov	DWORD PTR $T253541[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T253541[ebp]
	push	eax
	mov	ecx, DWORD PTR $T253564[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@stdext@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvReplayMessage *,CvReplayMessage *,std::allocator<CvReplayMessage> >
	add	esp, 16					; 00000010H
	jmp	$LN19@Insert_n@2
__catch$?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$224357[ebp], 1
	jle	SHORT $LN7@Insert_n@2

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	eax, DWORD PTR __Whereoff$224356[ebp]
	imul	eax, 60					; 0000003cH
	add	eax, DWORD PTR __Newvec$224355[ebp]
	mov	DWORD PTR $T253608[ebp], eax
	mov	ecx, DWORD PTR __Newvec$224355[ebp]
	mov	DWORD PTR $T253607[ebp], ecx
	mov	dl, BYTE PTR __Cat$253615[ebp]
	mov	BYTE PTR $T253613[ebp], dl
	mov	eax, DWORD PTR $T253608[ebp]
	mov	DWORD PTR $T253591[ebp], eax
	mov	ecx, DWORD PTR $T253607[ebp]
	mov	DWORD PTR $T253590[ebp], ecx
	jmp	SHORT $LN88@Insert_n@2
$LN87@Insert_n@2:
	mov	edx, DWORD PTR $T253590[ebp]
	add	edx, 60					; 0000003cH
	mov	DWORD PTR $T253590[ebp], edx
$LN88@Insert_n@2:
	mov	eax, DWORD PTR $T253590[ebp]
	cmp	eax, DWORD PTR $T253591[ebp]
	je	SHORT $LN7@Insert_n@2
	push	0
	mov	ecx, DWORD PTR $T253590[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T253590[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	jmp	SHORT $LN87@Insert_n@2
$LN7@Insert_n@2:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$224357[ebp], 0
	jle	SHORT $LN6@Insert_n@2

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 60					; 0000003cH
	mov	edx, DWORD PTR __Whereoff$224356[ebp]
	imul	edx, 60					; 0000003cH
	add	edx, DWORD PTR __Newvec$224355[ebp]
	add	edx, ecx
	mov	DWORD PTR $T253669[ebp], edx
	mov	eax, DWORD PTR __Whereoff$224356[ebp]
	imul	eax, 60					; 0000003cH
	add	eax, DWORD PTR __Newvec$224355[ebp]
	mov	DWORD PTR $T253668[ebp], eax
	mov	cl, BYTE PTR __Cat$253676[ebp]
	mov	BYTE PTR $T253674[ebp], cl
	mov	edx, DWORD PTR $T253669[ebp]
	mov	DWORD PTR $T253652[ebp], edx
	mov	eax, DWORD PTR $T253668[ebp]
	mov	DWORD PTR $T253651[ebp], eax
	jmp	SHORT $LN103@Insert_n@2
$LN102@Insert_n@2:
	mov	ecx, DWORD PTR $T253651[ebp]
	add	ecx, 60					; 0000003cH
	mov	DWORD PTR $T253651[ebp], ecx
$LN103@Insert_n@2:
	mov	edx, DWORD PTR $T253651[ebp]
	cmp	edx, DWORD PTR $T253652[ebp]
	je	SHORT $LN6@Insert_n@2
	push	0
	mov	eax, DWORD PTR $T253651[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T253651[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	jmp	SHORT $LN102@Insert_n@2
$LN6@Insert_n@2:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	ecx, DWORD PTR __Newvec$224355[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN112@Insert_n@2
	ret	0
$LN19@Insert_n@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN112@Insert_n@2:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 60					; 0000003cH
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN5@Insert_n@2

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T253755[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T253754[ebp], eax
	mov	ecx, DWORD PTR $T253755[ebp]
	mov	DWORD PTR $T253736[ebp], ecx
	mov	edx, DWORD PTR $T253754[ebp]
	mov	DWORD PTR $T253735[ebp], edx
	mov	al, BYTE PTR __Cat$253743[ebp]
	mov	BYTE PTR $T253741[ebp], al
	mov	ecx, DWORD PTR $T253736[ebp]
	mov	DWORD PTR $T253719[ebp], ecx
	mov	edx, DWORD PTR $T253735[ebp]
	mov	DWORD PTR $T253718[ebp], edx
	jmp	SHORT $LN122@Insert_n@2
$LN121@Insert_n@2:
	mov	eax, DWORD PTR $T253718[ebp]
	add	eax, 60					; 0000003cH
	mov	DWORD PTR $T253718[ebp], eax
$LN122@Insert_n@2:
	mov	ecx, DWORD PTR $T253718[ebp]
	cmp	ecx, DWORD PTR $T253719[ebp]
	je	SHORT $LN114@Insert_n@2
	push	0
	mov	edx, DWORD PTR $T253718[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T253718[ebp]
	mov	edx, DWORD PTR [eax]
	call	edx
	jmp	SHORT $LN121@Insert_n@2
$LN114@Insert_n@2:

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 60					; 0000003cH
	idiv	ecx
	mov	DWORD PTR $T253760[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T253759[ebp], eax
	mov	ecx, DWORD PTR $T253759[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n@2:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	imul	edx, 60					; 0000003cH
	add	edx, DWORD PTR __Newvec$224355[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 60					; 0000003cH
	add	ecx, DWORD PTR __Newvec$224355[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newvec$224355[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	$LN16@Insert_n@2
$LN10@Insert_n@2:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	cdq
	mov	ecx, 60					; 0000003cH
	idiv	ecx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@2

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Tmp$224370[ebp]
	call	??0CvReplayMessage@@QAE@ABV0@@Z
	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T253840[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 60					; 0000003cH
	add	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T253821[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T253826[ebp], al
	mov	cl, BYTE PTR __Cat$253829[ebp]
	mov	BYTE PTR $T253827[ebp], cl
	mov	dl, BYTE PTR $T253826[ebp]
	mov	BYTE PTR $T253804[ebp], dl
	mov	eax, DWORD PTR $T253821[ebp]
	mov	DWORD PTR $T253803[ebp], eax
	mov	ecx, DWORD PTR $T253803[ebp]
	mov	DWORD PTR $T253793[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T253792[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T253834[ebp], al
	mov	cl, BYTE PTR __Cat$253837[ebp]
	mov	BYTE PTR $T253835[ebp], cl
	movzx	edx, BYTE PTR $T253834[ebp]
	push	edx
	movzx	eax, BYTE PTR $T253835[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T253793[ebp]
	push	edx
	mov	eax, DWORD PTR $T253840[ebp]
	push	eax
	mov	ecx, DWORD PTR $T253792[ebp]
	push	ecx
	call	??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvReplayMessage *,CvReplayMessage *,std::allocator<CvReplayMessage> >
	add	esp, 24					; 00000018H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 3

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	cdq
	mov	ecx, 60					; 0000003cH
	idiv	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, eax
	mov	DWORD PTR $T253867[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T253866[ebp], ecx
	mov	edx, DWORD PTR $T253866[ebp]
	mov	DWORD PTR $T253856[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T253861[ebp], al
	mov	cl, BYTE PTR __Cat$253864[ebp]
	mov	BYTE PTR $T253862[ebp], cl
	movzx	edx, BYTE PTR $T253861[ebp]
	push	edx
	movzx	eax, BYTE PTR $T253862[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Tmp$224370[ebp]
	push	edx
	mov	eax, DWORD PTR $T253867[ebp]
	push	eax
	mov	ecx, DWORD PTR $T253856[ebp]
	push	ecx
	call	??$_Uninit_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvReplayMessage *,unsigned int,CvReplayMessage,std::allocator<CvReplayMessage> >
	add	esp, 24					; 00000018H
	jmp	$LN21@Insert_n@2
__catch$?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+8]
	mov	DWORD PTR $T253929[ebp], edx
	mov	ecx, DWORD PTR $T253929[ebp]
	mov	DWORD PTR $T253911[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 60					; 0000003cH
	add	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T253910[ebp], edx
	mov	al, BYTE PTR __Cat$253918[ebp]
	mov	BYTE PTR $T253916[ebp], al
	mov	ecx, DWORD PTR $T253911[ebp]
	mov	DWORD PTR $T253894[ebp], ecx
	mov	edx, DWORD PTR $T253910[ebp]
	mov	DWORD PTR $T253893[ebp], edx
	jmp	SHORT $LN164@Insert_n@2
$LN163@Insert_n@2:
	mov	eax, DWORD PTR $T253893[ebp]
	add	eax, 60					; 0000003cH
	mov	DWORD PTR $T253893[ebp], eax
$LN164@Insert_n@2:
	mov	ecx, DWORD PTR $T253893[ebp]
	cmp	ecx, DWORD PTR $T253894[ebp]
	je	SHORT $LN156@Insert_n@2
	push	0
	mov	edx, DWORD PTR $T253893[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T253893[ebp]
	mov	edx, DWORD PTR [eax]
	call	edx
	jmp	SHORT $LN163@Insert_n@2
$LN156@Insert_n@2:

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 2
	mov	eax, __tryend$?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z$3
	ret	0
$LN21@Insert_n@2:
	mov	DWORD PTR __$EHRec$[ebp+12], 2
__tryend$?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 60					; 0000003cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 60					; 0000003cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, eax
	mov	DWORD PTR $T253950[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T253942[ebp], eax
	jmp	SHORT $LN175@Insert_n@2
$LN174@Insert_n@2:
	mov	ecx, DWORD PTR $T253942[ebp]
	add	ecx, 60					; 0000003cH
	mov	DWORD PTR $T253942[ebp], ecx
$LN175@Insert_n@2:
	mov	edx, DWORD PTR $T253942[ebp]
	cmp	edx, DWORD PTR $T253950[ebp]
	je	SHORT $LN171@Insert_n@2
	lea	eax, DWORD PTR __Tmp$224370[ebp]
	push	eax
	mov	ecx, DWORD PTR $T253942[ebp]
	call	??4CvReplayMessage@@QAEAAV0@ABV0@@Z
	jmp	SHORT $LN174@Insert_n@2
$LN171@Insert_n@2:

; 1232 : 			}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Tmp$224370[ebp]
	call	??1CvReplayMessage@@UAE@XZ		; CvReplayMessage::~CvReplayMessage

; 1233 : 		else

	jmp	$LN16@Insert_n@2
$LN3@Insert_n@2:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Tmp$224380[ebp]
	call	??0CvReplayMessage@@QAE@ABV0@@Z
	mov	DWORD PTR __$EHRec$[ebp+12], 5

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Oldend$224381[ebp], eax

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T254030[ebp], edx
	mov	eax, DWORD PTR $T254030[ebp]
	mov	DWORD PTR $T254011[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T254014[ebp], cl
	mov	dl, BYTE PTR __Cat$254018[ebp]
	mov	BYTE PTR $T254015[ebp], dl
	mov	al, BYTE PTR $T254014[ebp]
	mov	BYTE PTR $T253994[ebp], al
	mov	ecx, DWORD PTR $T254011[ebp]
	mov	DWORD PTR $T253993[ebp], ecx
	mov	edx, DWORD PTR $T253993[ebp]
	mov	DWORD PTR $T253983[ebp], edx
	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 60					; 0000003cH
	mov	ecx, DWORD PTR __Oldend$224381[ebp]
	sub	ecx, eax
	mov	DWORD PTR $T253982[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T254021[ebp], dl
	mov	al, BYTE PTR __Cat$254025[ebp]
	mov	BYTE PTR $T254022[ebp], al
	movzx	ecx, BYTE PTR $T254021[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T254022[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T253983[ebp]
	push	ecx
	mov	edx, DWORD PTR __Oldend$224381[ebp]
	push	edx
	mov	eax, DWORD PTR $T253982[ebp]
	push	eax
	call	??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvReplayMessage *,CvReplayMessage *,std::allocator<CvReplayMessage> >
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$224381[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 60					; 0000003cH
	mov	ecx, DWORD PTR __Oldend$224381[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	call	??$_Unchecked_move_backward@PAVCvReplayMessage@@PAV1@@stdext@@YAPAVCvReplayMessage@@PAV1@00@Z ; stdext::_Unchecked_move_backward<CvReplayMessage *,CvReplayMessage *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T254262[ebp], eax
	jmp	SHORT $LN223@Insert_n@2
$LN222@Insert_n@2:
	mov	ecx, DWORD PTR $T254262[ebp]
	add	ecx, 60					; 0000003cH
	mov	DWORD PTR $T254262[ebp], ecx
$LN223@Insert_n@2:
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 60					; 0000003cH
	add	edx, DWORD PTR __Where$[ebp]
	cmp	DWORD PTR $T254262[ebp], edx
	je	SHORT $LN219@Insert_n@2
	lea	eax, DWORD PTR __Tmp$224380[ebp]
	push	eax
	mov	ecx, DWORD PTR $T254262[ebp]
	call	??4CvReplayMessage@@QAEAAV0@ABV0@@Z
	jmp	SHORT $LN222@Insert_n@2
$LN219@Insert_n@2:

; 1249 : 			}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Tmp$224380[ebp]
	call	??1CvReplayMessage@@UAE@XZ		; CvReplayMessage::~CvReplayMessage
$LN16@Insert_n@2:

; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z$4:
	lea	ecx, DWORD PTR __Tmp$224370[ebp]
	jmp	??1CvReplayMessage@@UAE@XZ		; CvReplayMessage::~CvReplayMessage
__unwindfunclet$?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z$5:
	lea	ecx, DWORD PTR __Tmp$224380[ebp]
	jmp	??1CvReplayMessage@@UAE@XZ		; CvReplayMessage::~CvReplayMessage
__ehhandler$?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-652]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@2@IABVCvReplayMessage@@@Z ENDP ; std::vector<CvReplayMessage,std::allocator<CvReplayMessage> >::_Insert_n
PUBLIC	??$_Allocate@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IPAV10@@Z ; std::_Allocate<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >
PUBLIC	?_Xlen@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@KAXXZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$254298 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAE_NI@Z PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@9

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@9
	jmp	SHORT $LN3@Buy@9
$LN4@Buy@9:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$254298[ebp], 357913941 ; 15555555H
	cmp	DWORD PTR __Count$254298[ebp], 0
	jbe	SHORT $LN11@Buy@9
	mov	eax, DWORD PTR __Count$254298[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy@9
$LN11@Buy@9:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy@9:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy@9

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@KAXXZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@9

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy@9:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IPAV10@@Z ; std::_Allocate<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], edx
$LN3@Buy@9:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@9:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAE_NI@Z ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Buy
_TEXT	ENDS
PUBLIC	?swap@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::swap
PUBLIC	??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
PUBLIC	??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$46 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$2
__catchsym$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$45 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$0
__ehfuncinfo$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z DD 019930522H
	DD	0cH
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z DD 00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$45
	DD	06H
	DD	06H
	DD	08H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$46
__unwindtable$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$8
	DD	01H
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$14
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$20
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$4
	DD	05H
	DD	00H
	DD	05H
	DD	00H
	DD	07H
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$27
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$33
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$40
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z
_TEXT	SEGMENT
tv84 = -536						; size = 4
tv312 = -532						; size = 4
tv298 = -528						; size = 4
tv290 = -524						; size = 4
_this$ = -520						; size = 4
$T255835 = -432						; size = 4
$T255652 = -352						; size = 4
$T255651 = -348						; size = 4
$T255631 = -342						; size = 1
$T255630 = -341						; size = 1
$T255629 = -340						; size = 4
$T255628 = -336						; size = 4
$T255627 = -332						; size = 4
__Cat$255638 = -324					; size = 1
$T255636 = -323						; size = 1
$T255635 = -322						; size = 1
$T255634 = -321						; size = 1
$T255597 = -320						; size = 4
$T255587 = -316						; size = 4
__Cat$255595 = -311					; size = 1
$T255593 = -310						; size = 1
$T255592 = -309						; size = 1
$T255498 = -308						; size = 4
$T255488 = -304						; size = 4
$T255475 = -300						; size = 4
$T255440 = -296						; size = 4
$T255439 = -292						; size = 4
$T255406 = -288						; size = 4
$T255405 = -284						; size = 4
__Cat$255447 = -278					; size = 1
$T255445 = -277						; size = 1
$T255241 = -276						; size = 4
$T255240 = -272						; size = 4
$T255230 = -268						; size = 4
__Cat$255238 = -263					; size = 1
$T255236 = -262						; size = 1
$T255235 = -261						; size = 1
$T255214 = -260						; size = 4
$T255204 = -256						; size = 4
__Cat$255212 = -251					; size = 1
$T255209 = -250						; size = 1
$T255208 = -249						; size = 1
$T255184 = -248						; size = 4
$T255183 = -244						; size = 4
$T255179 = -240						; size = 4
$T255178 = -236						; size = 4
$T255143 = -232						; size = 4
$T255142 = -228						; size = 4
$T255109 = -224						; size = 4
$T255108 = -220						; size = 4
__Cat$255175 = -214					; size = 1
$T255173 = -213						; size = 1
$T254904 = -212						; size = 4
$T254903 = -208						; size = 4
$T254870 = -204						; size = 4
$T254869 = -200						; size = 4
__Cat$254911 = -194					; size = 1
$T254909 = -193						; size = 1
$T254671 = -192						; size = 4
$T254670 = -188						; size = 4
$T254637 = -184						; size = 4
$T254636 = -180						; size = 4
__Cat$254678 = -174					; size = 1
$T254676 = -173						; size = 1
$T254472 = -172						; size = 4
$T254462 = -168						; size = 4
__Cat$254470 = -163					; size = 1
$T254468 = -162						; size = 1
$T254467 = -161						; size = 1
$T254446 = -160						; size = 4
$T254436 = -156						; size = 4
__Cat$254444 = -151					; size = 1
$T254442 = -150						; size = 1
$T254441 = -149						; size = 1
$T254420 = -148						; size = 4
$T254410 = -144						; size = 4
__Cat$254418 = -139					; size = 1
$T254416 = -138						; size = 1
$T254415 = -137						; size = 1
__Count$254385 = -136					; size = 4
__Count$254359 = -64					; size = 4
__Tmp$224450 = -60					; size = 12
__Oldend$224451 = -48					; size = 4
__Tmp$224440 = -44					; size = 12
__Ncopied$224427 = -32					; size = 4
__Newvec$224425 = -28					; size = 4
__Whereoff$224426 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 520				; 00000208H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN31@Insert_n@3
	mov	DWORD PTR tv290[ebp], 0
	jmp	SHORT $LN29@Insert_n@3
$LN31@Insert_n@3:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR tv290[ebp], eax
$LN29@Insert_n@3:
	mov	edx, DWORD PTR tv290[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@3
	jmp	$LN16@Insert_n@3
$LN14@Insert_n@3:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$254359[ebp], 357913941 ; 15555555H
	cmp	DWORD PTR __Count$254359[ebp], 0
	jbe	SHORT $LN37@Insert_n@3
	mov	eax, DWORD PTR __Count$254359[ebp]
	mov	DWORD PTR tv298[ebp], eax
	jmp	SHORT $LN39@Insert_n@3
$LN37@Insert_n@3:
	mov	DWORD PTR tv298[ebp], 1
$LN39@Insert_n@3:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	edx, DWORD PTR tv298[ebp]
	sub	edx, eax
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	SHORT $LN44@Insert_n@3

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@KAXXZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Xlen
	jmp	$LN16@Insert_n@3

; 1167 : 		else if (_Capacity < size() + _Count)

$LN44@Insert_n@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@3

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$254385[ebp], 357913941 ; 15555555H
	cmp	DWORD PTR __Count$254385[ebp], 0
	jbe	SHORT $LN50@Insert_n@3
	mov	edx, DWORD PTR __Count$254385[ebp]
	mov	DWORD PTR tv312[ebp], edx
	jmp	SHORT $LN46@Insert_n@3
$LN50@Insert_n@3:
	mov	DWORD PTR tv312[ebp], 1
$LN46@Insert_n@3:
	mov	eax, DWORD PTR __Capacity$[ebp]
	shr	eax, 1
	mov	ecx, DWORD PTR tv312[ebp]
	sub	ecx, eax
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@3
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@3
$LN17@Insert_n@3:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n@3:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN56@Insert_n@3

; 1172 : 				_Capacity = size() + _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN56@Insert_n@3:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IPAV10@@Z ; std::_Allocate<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >
	add	esp, 8
	mov	DWORD PTR __Newvec$224425[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR __Whereoff$224426[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$224427[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	edx, DWORD PTR __Whereoff$224426[ebp]
	imul	edx, 12					; 0000000cH
	add	edx, DWORD PTR __Newvec$224425[ebp]
	mov	DWORD PTR $T254420[ebp], edx
	mov	eax, DWORD PTR $T254420[ebp]
	mov	DWORD PTR $T254410[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T254415[ebp], cl
	mov	dl, BYTE PTR __Cat$254418[ebp]
	mov	BYTE PTR $T254416[ebp], dl
	movzx	eax, BYTE PTR $T254415[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T254416[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T254410[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,unsigned int,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
	add	esp, 24					; 00000018H

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$224427[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$224427[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T254446[ebp], edx
	mov	eax, DWORD PTR __Newvec$224425[ebp]
	mov	DWORD PTR $T254436[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T254441[ebp], cl
	mov	dl, BYTE PTR __Cat$254444[ebp]
	mov	BYTE PTR $T254442[ebp], dl
	movzx	eax, BYTE PTR $T254441[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T254442[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T254436[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T254446[ebp]
	push	edx
	call	??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
	add	esp, 24					; 00000018H

; 1182 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$224427[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$224427[ebp], eax

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T254472[ebp], edx
	mov	eax, DWORD PTR __Whereoff$224426[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	imul	eax, 12					; 0000000cH
	add	eax, DWORD PTR __Newvec$224425[ebp]
	mov	DWORD PTR $T254462[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T254467[ebp], cl
	mov	dl, BYTE PTR __Cat$254470[ebp]
	mov	BYTE PTR $T254468[ebp], dl
	movzx	eax, BYTE PTR $T254467[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T254468[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T254462[ebp]
	push	eax
	mov	ecx, DWORD PTR $T254472[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	call	??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
	add	esp, 24					; 00000018H
	jmp	$LN19@Insert_n@3
__catch$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$224427[ebp], 1
	jle	$LN7@Insert_n@3

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	eax, DWORD PTR __Whereoff$224426[ebp]
	imul	eax, 12					; 0000000cH
	add	eax, DWORD PTR __Newvec$224425[ebp]
	mov	DWORD PTR $T254671[ebp], eax
	mov	ecx, DWORD PTR __Newvec$224425[ebp]
	mov	DWORD PTR $T254670[ebp], ecx
	mov	dl, BYTE PTR __Cat$254678[ebp]
	mov	BYTE PTR $T254676[ebp], dl
	mov	eax, DWORD PTR $T254671[ebp]
	mov	DWORD PTR $T254637[ebp], eax
	mov	ecx, DWORD PTR $T254670[ebp]
	mov	DWORD PTR $T254636[ebp], ecx
	jmp	SHORT $LN84@Insert_n@3
$LN83@Insert_n@3:
	mov	edx, DWORD PTR $T254636[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR $T254636[ebp], edx
$LN84@Insert_n@3:
	mov	eax, DWORD PTR $T254636[ebp]
	cmp	eax, DWORD PTR $T254637[ebp]
	je	SHORT $LN7@Insert_n@3
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR $T254636[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	xor	ecx, ecx
	and	ecx, 1
	je	SHORT $LN87@Insert_n@3
	mov	edx, DWORD PTR $T254636[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN87@Insert_n@3:
	jmp	SHORT $LN83@Insert_n@3
$LN7@Insert_n@3:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$224427[ebp], 0
	jle	$LN6@Insert_n@3

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR __Whereoff$224426[ebp]
	imul	ecx, 12					; 0000000cH
	add	ecx, DWORD PTR __Newvec$224425[ebp]
	add	ecx, eax
	mov	DWORD PTR $T254904[ebp], ecx
	mov	edx, DWORD PTR __Whereoff$224426[ebp]
	imul	edx, 12					; 0000000cH
	add	edx, DWORD PTR __Newvec$224425[ebp]
	mov	DWORD PTR $T254903[ebp], edx
	mov	al, BYTE PTR __Cat$254911[ebp]
	mov	BYTE PTR $T254909[ebp], al
	mov	ecx, DWORD PTR $T254904[ebp]
	mov	DWORD PTR $T254870[ebp], ecx
	mov	edx, DWORD PTR $T254903[ebp]
	mov	DWORD PTR $T254869[ebp], edx
	jmp	SHORT $LN122@Insert_n@3
$LN121@Insert_n@3:
	mov	eax, DWORD PTR $T254869[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T254869[ebp], eax
$LN122@Insert_n@3:
	mov	ecx, DWORD PTR $T254869[ebp]
	cmp	ecx, DWORD PTR $T254870[ebp]
	je	SHORT $LN6@Insert_n@3
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR $T254869[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	xor	edx, edx
	and	edx, 1
	je	SHORT $LN125@Insert_n@3
	mov	eax, DWORD PTR $T254869[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN125@Insert_n@3:
	jmp	SHORT $LN121@Insert_n@3
$LN6@Insert_n@3:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	ecx, DWORD PTR __Newvec$224425[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN154@Insert_n@3
	ret	0
$LN19@Insert_n@3:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN154@Insert_n@3:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN5@Insert_n@3

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T255179[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T255178[ebp], eax
	mov	ecx, DWORD PTR $T255179[ebp]
	mov	DWORD PTR $T255143[ebp], ecx
	mov	edx, DWORD PTR $T255178[ebp]
	mov	DWORD PTR $T255142[ebp], edx
	mov	al, BYTE PTR __Cat$255175[ebp]
	mov	BYTE PTR $T255173[ebp], al
	mov	ecx, DWORD PTR $T255143[ebp]
	mov	DWORD PTR $T255109[ebp], ecx
	mov	edx, DWORD PTR $T255142[ebp]
	mov	DWORD PTR $T255108[ebp], edx
	jmp	SHORT $LN164@Insert_n@3
$LN163@Insert_n@3:
	mov	eax, DWORD PTR $T255108[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T255108[ebp], eax
$LN164@Insert_n@3:
	mov	ecx, DWORD PTR $T255108[ebp]
	cmp	ecx, DWORD PTR $T255109[ebp]
	je	SHORT $LN156@Insert_n@3
	mov	DWORD PTR __$EHRec$[ebp+12], 4
	mov	ecx, DWORD PTR $T255108[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	xor	edx, edx
	and	edx, 1
	je	SHORT $LN167@Insert_n@3
	mov	eax, DWORD PTR $T255108[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN167@Insert_n@3:
	jmp	SHORT $LN163@Insert_n@3
$LN156@Insert_n@3:

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR $T255184[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T255183[ebp], eax
	mov	ecx, DWORD PTR $T255183[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n@3:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	imul	edx, 12					; 0000000cH
	add	edx, DWORD PTR __Newvec$224425[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 12					; 0000000cH
	add	ecx, DWORD PTR __Newvec$224425[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newvec$224425[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	$LN16@Insert_n@3
$LN10@Insert_n@3:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@3

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Tmp$224440[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+12], 5

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T255214[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 12					; 0000000cH
	add	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T255204[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T255208[ebp], al
	mov	cl, BYTE PTR __Cat$255212[ebp]
	mov	BYTE PTR $T255209[ebp], cl
	movzx	edx, BYTE PTR $T255208[ebp]
	push	edx
	movzx	eax, BYTE PTR $T255209[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T255204[ebp]
	push	edx
	mov	eax, DWORD PTR $T255214[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	call	??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
	add	esp, 24					; 00000018H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 6

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, eax
	mov	DWORD PTR $T255241[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T255240[ebp], ecx
	mov	edx, DWORD PTR $T255240[ebp]
	mov	DWORD PTR $T255230[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T255235[ebp], al
	mov	cl, BYTE PTR __Cat$255238[ebp]
	mov	BYTE PTR $T255236[ebp], cl
	movzx	edx, BYTE PTR $T255235[ebp]
	push	edx
	movzx	eax, BYTE PTR $T255236[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Tmp$224440[ebp]
	push	edx
	mov	eax, DWORD PTR $T255241[ebp]
	push	eax
	mov	ecx, DWORD PTR $T255230[ebp]
	push	ecx
	call	??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,unsigned int,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
	add	esp, 24					; 00000018H
	jmp	$LN21@Insert_n@3
__catch$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+8]
	mov	DWORD PTR $T255475[ebp], edx
	mov	ecx, DWORD PTR $T255475[ebp]
	mov	DWORD PTR $T255440[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 12					; 0000000cH
	add	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T255439[ebp], edx
	mov	al, BYTE PTR __Cat$255447[ebp]
	mov	BYTE PTR $T255445[ebp], al
	mov	ecx, DWORD PTR $T255440[ebp]
	mov	DWORD PTR $T255406[ebp], ecx
	mov	edx, DWORD PTR $T255439[ebp]
	mov	DWORD PTR $T255405[ebp], edx
	jmp	SHORT $LN219@Insert_n@3
$LN218@Insert_n@3:
	mov	eax, DWORD PTR $T255405[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T255405[ebp], eax
$LN219@Insert_n@3:
	mov	ecx, DWORD PTR $T255405[ebp]
	cmp	ecx, DWORD PTR $T255406[ebp]
	je	SHORT $LN211@Insert_n@3
	mov	BYTE PTR __$EHRec$[ebp+12], 8
	mov	ecx, DWORD PTR $T255405[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+12], 7
	xor	edx, edx
	and	edx, 1
	je	SHORT $LN222@Insert_n@3
	mov	eax, DWORD PTR $T255405[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN222@Insert_n@3:
	jmp	SHORT $LN218@Insert_n@3
$LN211@Insert_n@3:

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 5
	mov	eax, __tryend$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$3
	ret	0
$LN21@Insert_n@3:
	mov	DWORD PTR __$EHRec$[ebp+12], 5
__tryend$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, ecx
	mov	DWORD PTR $T255498[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T255488[ebp], ecx
	jmp	SHORT $LN253@Insert_n@3
$LN252@Insert_n@3:
	mov	edx, DWORD PTR $T255488[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR $T255488[ebp], edx
$LN253@Insert_n@3:
	mov	eax, DWORD PTR $T255488[ebp]
	cmp	eax, DWORD PTR $T255498[ebp]
	je	SHORT $LN249@Insert_n@3
	lea	ecx, DWORD PTR __Tmp$224440[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T255488[ebp]
	call	??4?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::operator=
	jmp	SHORT $LN252@Insert_n@3
$LN249@Insert_n@3:

; 1232 : 			}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	DWORD PTR __$EHRec$[ebp+12], 9
	lea	ecx, DWORD PTR __Tmp$224440[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1233 : 		else

	jmp	$LN16@Insert_n@3
$LN3@Insert_n@3:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Tmp$224450[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+12], 10		; 0000000aH

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Oldend$224451[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T255597[ebp], eax
	mov	ecx, DWORD PTR $T255597[ebp]
	mov	DWORD PTR $T255587[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T255592[ebp], dl
	mov	al, BYTE PTR __Cat$255595[ebp]
	mov	BYTE PTR $T255593[ebp], al
	movzx	ecx, BYTE PTR $T255592[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T255593[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T255587[ebp]
	push	ecx
	mov	edx, DWORD PTR __Oldend$224451[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR __Oldend$224451[ebp]
	sub	ecx, eax
	push	ecx
	call	??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, DWORD PTR __Oldend$224451[ebp]
	mov	DWORD PTR $T255652[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T255651[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T255634[ebp], dl
	mov	al, BYTE PTR __Cat$255638[ebp]
	mov	BYTE PTR $T255635[ebp], al
	mov	cl, BYTE PTR $T255634[ebp]
	mov	BYTE PTR $T255631[ebp], cl
	mov	dl, BYTE PTR $T255636[ebp]
	mov	BYTE PTR $T255630[ebp], dl
	mov	eax, DWORD PTR $T255652[ebp]
	mov	DWORD PTR $T255629[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR __Oldend$224451[ebp]
	sub	edx, ecx
	mov	DWORD PTR $T255628[ebp], edx
	mov	eax, DWORD PTR $T255651[ebp]
	mov	DWORD PTR $T255627[ebp], eax
$LN294@Insert_n@3:
	mov	ecx, DWORD PTR $T255627[ebp]
	cmp	ecx, DWORD PTR $T255628[ebp]
	je	SHORT $LN287@Insert_n@3
	mov	edx, DWORD PTR $T255628[ebp]
	sub	edx, 12					; 0000000cH
	mov	DWORD PTR $T255628[ebp], edx
	mov	eax, DWORD PTR $T255629[ebp]
	sub	eax, 12					; 0000000cH
	mov	DWORD PTR $T255629[ebp], eax
	mov	ecx, DWORD PTR $T255628[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T255629[ebp]
	call	?swap@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::swap
	jmp	SHORT $LN294@Insert_n@3
$LN287@Insert_n@3:

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T255835[ebp], edx
	jmp	SHORT $LN305@Insert_n@3
$LN304@Insert_n@3:
	mov	eax, DWORD PTR $T255835[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T255835[ebp], eax
$LN305@Insert_n@3:
	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 12					; 0000000cH
	add	ecx, DWORD PTR __Where$[ebp]
	cmp	DWORD PTR $T255835[ebp], ecx
	je	SHORT $LN301@Insert_n@3
	lea	edx, DWORD PTR __Tmp$224450[ebp]
	push	edx
	mov	ecx, DWORD PTR $T255835[ebp]
	call	??4?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::operator=
	jmp	SHORT $LN304@Insert_n@3
$LN301@Insert_n@3:

; 1249 : 			}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	DWORD PTR __$EHRec$[ebp+12], 11		; 0000000bH
	lea	ecx, DWORD PTR __Tmp$224450[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN16@Insert_n@3:

; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$8:
	mov	ecx, DWORD PTR $T254636[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
__unwindfunclet$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$14:
	mov	ecx, DWORD PTR $T254869[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
__unwindfunclet$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$20:
	mov	ecx, DWORD PTR $T255108[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
__unwindfunclet$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$4:
	lea	ecx, DWORD PTR __Tmp$224440[ebp]
	jmp	??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ
__unwindfunclet$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$27:
	mov	ecx, DWORD PTR $T255405[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
__unwindfunclet$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$33:
	lea	ecx, DWORD PTR __Tmp$224440[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
__unwindfunclet$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$5:
	lea	ecx, DWORD PTR __Tmp$224450[ebp]
	jmp	??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ
__unwindfunclet$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z$40:
	lea	ecx, DWORD PTR __Tmp$224450[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-540]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@IABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Insert_n
PUBLIC	??$_Uninit_copy@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum GameOptionTypes *,enum GameOptionTypes *,std::allocator<enum GameOptionTypes> >
PUBLIC	??$unchecked_uninitialized_copy@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@stdext@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@std@@@Z ; stdext::unchecked_uninitialized_copy<enum GameOptionTypes *,enum GameOptionTypes *,std::allocator<enum GameOptionTypes> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z$2
__catchsym$?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z$0
__unwindtable$?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z$5
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z$6
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z
_TEXT	SEGMENT
tv84 = -424						; size = 4
tv302 = -420						; size = 4
tv288 = -416						; size = 4
tv280 = -412						; size = 4
_this$ = -408						; size = 4
$T256816 = -404						; size = 4
$T256808 = -400						; size = 4
$T256807 = -396						; size = 4
$T256784 = -390						; size = 1
$T256783 = -389						; size = 1
$T256782 = -388						; size = 4
$T256781 = -384						; size = 4
$T256769 = -377						; size = 1
$T256768 = -376						; size = 4
$T256767 = -372						; size = 4
$T256766 = -368						; size = 4
__Cat$256801 = -364					; size = 1
$T256799 = -363						; size = 1
$T256798 = -362						; size = 1
__Cat$256791 = -360					; size = 1
$T256789 = -359						; size = 1
$T256788 = -358						; size = 1
$T256787 = -357						; size = 1
$T256741 = -356						; size = 4
$T256722 = -352						; size = 4
$T256705 = -345						; size = 1
$T256704 = -344						; size = 4
$T256694 = -340						; size = 4
$T256693 = -336						; size = 4
__Cat$256738 = -330					; size = 1
$T256736 = -329						; size = 1
$T256735 = -328						; size = 1
__Cat$256730 = -327					; size = 1
$T256728 = -326						; size = 1
$T256727 = -325						; size = 1
$T256669 = -324						; size = 4
$T256661 = -320						; size = 4
$T256653 = -316						; size = 4
$T256635 = -312						; size = 4
$T256634 = -308						; size = 4
$T256618 = -304						; size = 4
__Cat$256642 = -298					; size = 1
$T256640 = -297						; size = 1
$T256592 = -296						; size = 4
$T256591 = -292						; size = 4
$T256581 = -288						; size = 4
__Cat$256589 = -283					; size = 1
$T256587 = -282						; size = 1
$T256586 = -281						; size = 1
$T256565 = -280						; size = 4
$T256546 = -276						; size = 4
$T256529 = -269						; size = 1
$T256528 = -268						; size = 4
$T256518 = -264						; size = 4
$T256517 = -260						; size = 4
__Cat$256562 = -254					; size = 1
$T256560 = -253						; size = 1
$T256559 = -252						; size = 1
__Cat$256554 = -251					; size = 1
$T256552 = -250						; size = 1
$T256551 = -249						; size = 1
$T256493 = -248						; size = 4
$T256492 = -244						; size = 4
$T256488 = -240						; size = 4
$T256487 = -236						; size = 4
$T256469 = -232						; size = 4
$T256468 = -228						; size = 4
$T256452 = -224						; size = 4
__Cat$256476 = -218					; size = 1
$T256474 = -217						; size = 1
$T256403 = -216						; size = 4
$T256402 = -212						; size = 4
$T256386 = -208						; size = 4
__Cat$256410 = -202					; size = 1
$T256408 = -201						; size = 1
$T256343 = -200						; size = 4
$T256342 = -196						; size = 4
$T256326 = -192						; size = 4
__Cat$256350 = -186					; size = 1
$T256348 = -185						; size = 1
$T256300 = -184						; size = 4
$T256288 = -180						; size = 4
$T256278 = -173						; size = 1
$T256277 = -172						; size = 4
__Cat$256296 = -167					; size = 1
$T256293 = -166						; size = 1
$T256292 = -165						; size = 1
$T256265 = -164						; size = 4
$T256253 = -160						; size = 4
$T256243 = -153						; size = 1
$T256242 = -152						; size = 4
__Cat$256261 = -147					; size = 1
$T256257 = -146						; size = 1
$T256256 = -145						; size = 1
$T256230 = -144						; size = 4
$T256220 = -140						; size = 4
__Cat$256226 = -135					; size = 1
$T256224 = -134						; size = 1
$T256223 = -133						; size = 1
__Count$256189 = -120					; size = 4
__Count$256163 = -48					; size = 4
__Tmp$224515 = -44					; size = 4
__Oldend$224516 = -40					; size = 4
__Tmp$224505 = -36					; size = 4
__Ncopied$224492 = -32					; size = 4
__Newvec$224490 = -28					; size = 4
__Whereoff$224491 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z PROC ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 408				; 00000198H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN29@Insert_n@4
	mov	DWORD PTR tv280[ebp], 0
	jmp	SHORT $LN27@Insert_n@4
$LN29@Insert_n@4:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv280[ebp], eax
$LN27@Insert_n@4:
	mov	ecx, DWORD PTR tv280[ebp]
	mov	DWORD PTR __Capacity$[ebp], ecx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@4
	jmp	$LN16@Insert_n@4
$LN14@Insert_n@4:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$256163[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$256163[ebp], 0
	jbe	SHORT $LN35@Insert_n@4
	mov	edx, DWORD PTR __Count$256163[ebp]
	mov	DWORD PTR tv288[ebp], edx
	jmp	SHORT $LN37@Insert_n@4
$LN35@Insert_n@4:
	mov	DWORD PTR tv288[ebp], 1
$LN37@Insert_n@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	eax, DWORD PTR tv288[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN42@Insert_n@4

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@KAXXZ ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Xlen
	jmp	$LN16@Insert_n@4

; 1167 : 		else if (_Capacity < size() + _Count)

$LN42@Insert_n@4:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@4

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$256189[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$256189[ebp], 0
	jbe	SHORT $LN48@Insert_n@4
	mov	ecx, DWORD PTR __Count$256189[ebp]
	mov	DWORD PTR tv302[ebp], ecx
	jmp	SHORT $LN44@Insert_n@4
$LN48@Insert_n@4:
	mov	DWORD PTR tv302[ebp], 1
$LN44@Insert_n@4:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	mov	eax, DWORD PTR tv302[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@4
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@4
$LN17@Insert_n@4:
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	add	ecx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], ecx
$LN18@Insert_n@4:
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1171 : 			if (_Capacity < size() + _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], edx
	jae	SHORT $LN54@Insert_n@4

; 1172 : 				_Capacity = size() + _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN54@Insert_n@4:
	push	0
	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	call	??$_Allocate@W4GameOptionTypes@@@std@@YAPAW4GameOptionTypes@@IPAW41@@Z ; std::_Allocate<enum GameOptionTypes>
	add	esp, 8
	mov	DWORD PTR __Newvec$224490[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR __Whereoff$224491[ebp], edx

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$224492[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Whereoff$224491[ebp]
	mov	ecx, DWORD PTR __Newvec$224490[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T256230[ebp], edx
	mov	eax, DWORD PTR $T256230[ebp]
	mov	DWORD PTR $T256220[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T256223[ebp], cl
	mov	dl, BYTE PTR __Cat$256226[ebp]
	mov	BYTE PTR $T256224[ebp], dl
	movzx	eax, BYTE PTR $T256223[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T256224[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T256220[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAW4GameOptionTypes@@IW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAXPAW4GameOptionTypes@@IABW41@AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum GameOptionTypes *,unsigned int,enum GameOptionTypes,std::allocator<enum GameOptionTypes> >
	add	esp, 24					; 00000018H

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$224492[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$224492[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T256265[ebp], edx
	mov	eax, DWORD PTR __Newvec$224490[ebp]
	mov	DWORD PTR $T256253[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T256256[ebp], cl
	mov	dl, BYTE PTR __Cat$256261[ebp]
	mov	BYTE PTR $T256257[ebp], dl
	mov	al, BYTE PTR $T256256[ebp]
	mov	BYTE PTR $T256243[ebp], al
	mov	ecx, DWORD PTR $T256253[ebp]
	mov	DWORD PTR $T256242[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T256242[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T256265[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@stdext@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@std@@@Z ; stdext::unchecked_uninitialized_copy<enum GameOptionTypes *,enum GameOptionTypes *,std::allocator<enum GameOptionTypes> >
	add	esp, 16					; 00000010H

; 1182 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$224492[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$224492[ebp], eax

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T256300[ebp], edx
	mov	eax, DWORD PTR __Whereoff$224491[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Newvec$224490[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T256288[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T256292[ebp], al
	mov	cl, BYTE PTR __Cat$256296[ebp]
	mov	BYTE PTR $T256293[ebp], cl
	mov	dl, BYTE PTR $T256292[ebp]
	mov	BYTE PTR $T256278[ebp], dl
	mov	eax, DWORD PTR $T256288[ebp]
	mov	DWORD PTR $T256277[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T256277[ebp]
	push	edx
	mov	eax, DWORD PTR $T256300[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	call	??$unchecked_uninitialized_copy@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@stdext@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@std@@@Z ; stdext::unchecked_uninitialized_copy<enum GameOptionTypes *,enum GameOptionTypes *,std::allocator<enum GameOptionTypes> >
	add	esp, 16					; 00000010H
	jmp	$LN19@Insert_n@4
__catch$?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$224492[ebp], 1
	jle	SHORT $LN7@Insert_n@4

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	edx, DWORD PTR __Whereoff$224491[ebp]
	mov	eax, DWORD PTR __Newvec$224490[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T256343[ebp], ecx
	mov	edx, DWORD PTR __Newvec$224490[ebp]
	mov	DWORD PTR $T256342[ebp], edx
	mov	al, BYTE PTR __Cat$256350[ebp]
	mov	BYTE PTR $T256348[ebp], al
	mov	ecx, DWORD PTR $T256342[ebp]
	mov	DWORD PTR $T256326[ebp], ecx
	jmp	SHORT $LN91@Insert_n@4
$LN90@Insert_n@4:
	mov	edx, DWORD PTR $T256326[ebp]
	add	edx, 4
	mov	DWORD PTR $T256326[ebp], edx
$LN91@Insert_n@4:
	mov	eax, DWORD PTR $T256326[ebp]
	cmp	eax, DWORD PTR $T256343[ebp]
	je	SHORT $LN7@Insert_n@4
	jmp	SHORT $LN90@Insert_n@4
$LN7@Insert_n@4:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$224492[ebp], 0
	jle	SHORT $LN6@Insert_n@4

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Whereoff$224491[ebp]
	mov	edx, DWORD PTR __Newvec$224490[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T256403[ebp], edx
	mov	eax, DWORD PTR __Whereoff$224491[ebp]
	mov	ecx, DWORD PTR __Newvec$224490[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T256402[ebp], edx
	mov	al, BYTE PTR __Cat$256410[ebp]
	mov	BYTE PTR $T256408[ebp], al
	mov	ecx, DWORD PTR $T256402[ebp]
	mov	DWORD PTR $T256386[ebp], ecx
	jmp	SHORT $LN106@Insert_n@4
$LN105@Insert_n@4:
	mov	edx, DWORD PTR $T256386[ebp]
	add	edx, 4
	mov	DWORD PTR $T256386[ebp], edx
$LN106@Insert_n@4:
	mov	eax, DWORD PTR $T256386[ebp]
	cmp	eax, DWORD PTR $T256403[ebp]
	je	SHORT $LN6@Insert_n@4
	jmp	SHORT $LN105@Insert_n@4
$LN6@Insert_n@4:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	ecx, DWORD PTR __Newvec$224490[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN115@Insert_n@4
	ret	0
$LN19@Insert_n@4:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN115@Insert_n@4:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], ecx

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN5@Insert_n@4

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T256488[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T256487[ebp], eax
	mov	ecx, DWORD PTR $T256488[ebp]
	mov	DWORD PTR $T256469[ebp], ecx
	mov	edx, DWORD PTR $T256487[ebp]
	mov	DWORD PTR $T256468[ebp], edx
	mov	al, BYTE PTR __Cat$256476[ebp]
	mov	BYTE PTR $T256474[ebp], al
	mov	ecx, DWORD PTR $T256468[ebp]
	mov	DWORD PTR $T256452[ebp], ecx
	jmp	SHORT $LN125@Insert_n@4
$LN124@Insert_n@4:
	mov	edx, DWORD PTR $T256452[ebp]
	add	edx, 4
	mov	DWORD PTR $T256452[ebp], edx
$LN125@Insert_n@4:
	mov	eax, DWORD PTR $T256452[ebp]
	cmp	eax, DWORD PTR $T256469[ebp]
	je	SHORT $LN117@Insert_n@4
	jmp	SHORT $LN124@Insert_n@4
$LN117@Insert_n@4:

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR $T256493[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T256492[ebp], edx
	mov	eax, DWORD PTR $T256492[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n@4:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	ecx, DWORD PTR __Capacity$[ebp]
	mov	edx, DWORD PTR __Newvec$224490[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Newvec$224490[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newvec$224490[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	$LN16@Insert_n@4
$LN10@Insert_n@4:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	sar	eax, 2
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@4

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$224505[ebp], edx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T256565[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T256546[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T256551[ebp], dl
	mov	al, BYTE PTR __Cat$256554[ebp]
	mov	BYTE PTR $T256552[ebp], al
	mov	cl, BYTE PTR $T256551[ebp]
	mov	BYTE PTR $T256529[ebp], cl
	mov	edx, DWORD PTR $T256546[ebp]
	mov	DWORD PTR $T256528[ebp], edx
	mov	eax, DWORD PTR $T256528[ebp]
	mov	DWORD PTR $T256518[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T256517[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T256559[ebp], dl
	mov	al, BYTE PTR __Cat$256562[ebp]
	mov	BYTE PTR $T256560[ebp], al
	movzx	ecx, BYTE PTR $T256559[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T256560[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T256518[ebp]
	push	ecx
	mov	edx, DWORD PTR $T256565[ebp]
	push	edx
	mov	eax, DWORD PTR $T256517[ebp]
	push	eax
	call	??$_Uninit_copy@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum GameOptionTypes *,enum GameOptionTypes *,std::allocator<enum GameOptionTypes> >
	add	esp, 24					; 00000018H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 2
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	mov	DWORD PTR $T256592[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T256591[ebp], edx
	mov	eax, DWORD PTR $T256591[ebp]
	mov	DWORD PTR $T256581[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T256586[ebp], cl
	mov	dl, BYTE PTR __Cat$256589[ebp]
	mov	BYTE PTR $T256587[ebp], dl
	movzx	eax, BYTE PTR $T256586[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T256587[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	lea	eax, DWORD PTR __Tmp$224505[ebp]
	push	eax
	mov	ecx, DWORD PTR $T256592[ebp]
	push	ecx
	mov	edx, DWORD PTR $T256581[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAW4GameOptionTypes@@IW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAXPAW4GameOptionTypes@@IABW41@AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum GameOptionTypes *,unsigned int,enum GameOptionTypes,std::allocator<enum GameOptionTypes> >
	add	esp, 24					; 00000018H
	jmp	SHORT $LN21@Insert_n@4
__catch$?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T256653[ebp], eax
	mov	ecx, DWORD PTR $T256653[ebp]
	mov	DWORD PTR $T256635[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T256634[ebp], ecx
	mov	dl, BYTE PTR __Cat$256642[ebp]
	mov	BYTE PTR $T256640[ebp], dl
	mov	eax, DWORD PTR $T256634[ebp]
	mov	DWORD PTR $T256618[ebp], eax
	jmp	SHORT $LN160@Insert_n@4
$LN159@Insert_n@4:
	mov	ecx, DWORD PTR $T256618[ebp]
	add	ecx, 4
	mov	DWORD PTR $T256618[ebp], ecx
$LN160@Insert_n@4:
	mov	edx, DWORD PTR $T256618[ebp]
	cmp	edx, DWORD PTR $T256635[ebp]
	je	SHORT $LN152@Insert_n@4
	jmp	SHORT $LN159@Insert_n@4
$LN152@Insert_n@4:

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z$3
	ret	0
$LN21@Insert_n@4:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, edx
	mov	DWORD PTR $T256669[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T256661[ebp], edx
	jmp	SHORT $LN171@Insert_n@4
$LN170@Insert_n@4:
	mov	eax, DWORD PTR $T256661[ebp]
	add	eax, 4
	mov	DWORD PTR $T256661[ebp], eax
$LN171@Insert_n@4:
	mov	ecx, DWORD PTR $T256661[ebp]
	cmp	ecx, DWORD PTR $T256669[ebp]
	je	SHORT $LN167@Insert_n@4
	mov	edx, DWORD PTR $T256661[ebp]
	mov	eax, DWORD PTR __Tmp$224505[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN170@Insert_n@4
$LN167@Insert_n@4:

; 1232 : 			}
; 1233 : 		else

	jmp	$LN16@Insert_n@4
$LN3@Insert_n@4:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$224515[ebp], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Oldend$224516[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T256741[ebp], eax
	mov	ecx, DWORD PTR $T256741[ebp]
	mov	DWORD PTR $T256722[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T256727[ebp], dl
	mov	al, BYTE PTR __Cat$256730[ebp]
	mov	BYTE PTR $T256728[ebp], al
	mov	cl, BYTE PTR $T256727[ebp]
	mov	BYTE PTR $T256705[ebp], cl
	mov	edx, DWORD PTR $T256722[ebp]
	mov	DWORD PTR $T256704[ebp], edx
	mov	eax, DWORD PTR $T256704[ebp]
	mov	DWORD PTR $T256694[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR __Oldend$224516[ebp]
	sub	edx, ecx
	mov	DWORD PTR $T256693[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T256735[ebp], al
	mov	cl, BYTE PTR __Cat$256738[ebp]
	mov	BYTE PTR $T256736[ebp], cl
	movzx	edx, BYTE PTR $T256735[ebp]
	push	edx
	movzx	eax, BYTE PTR $T256736[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T256694[ebp]
	push	edx
	mov	eax, DWORD PTR __Oldend$224516[ebp]
	push	eax
	mov	ecx, DWORD PTR $T256693[ebp]
	push	ecx
	call	??$_Uninit_copy@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum GameOptionTypes *,enum GameOptionTypes *,std::allocator<enum GameOptionTypes> >
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, DWORD PTR __Oldend$224516[ebp]
	mov	DWORD PTR $T256808[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T256807[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T256787[ebp], dl
	mov	al, BYTE PTR __Cat$256791[ebp]
	mov	BYTE PTR $T256788[ebp], al
	mov	cl, BYTE PTR $T256787[ebp]
	mov	BYTE PTR $T256784[ebp], cl
	mov	dl, BYTE PTR $T256789[ebp]
	mov	BYTE PTR $T256783[ebp], dl
	mov	eax, DWORD PTR $T256808[ebp]
	mov	DWORD PTR $T256782[ebp], eax
	mov	ecx, DWORD PTR $T256807[ebp]
	mov	DWORD PTR $T256781[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T256798[ebp], dl
	mov	al, BYTE PTR __Cat$256801[ebp]
	mov	BYTE PTR $T256799[ebp], al
	mov	cl, BYTE PTR $T256798[ebp]
	mov	BYTE PTR $T256769[ebp], cl
	mov	edx, DWORD PTR $T256782[ebp]
	mov	DWORD PTR $T256768[ebp], edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Oldend$224516[ebp]
	sub	ecx, eax
	mov	DWORD PTR $T256767[ebp], ecx
	mov	edx, DWORD PTR $T256781[ebp]
	mov	DWORD PTR $T256766[ebp], edx
$LN197@Insert_n@4:
	mov	eax, DWORD PTR $T256766[ebp]
	cmp	eax, DWORD PTR $T256767[ebp]
	je	SHORT $LN186@Insert_n@4
	mov	ecx, DWORD PTR $T256767[ebp]
	sub	ecx, 4
	mov	DWORD PTR $T256767[ebp], ecx
	mov	edx, DWORD PTR $T256768[ebp]
	sub	edx, 4
	mov	DWORD PTR $T256768[ebp], edx
	mov	eax, DWORD PTR $T256768[ebp]
	mov	ecx, DWORD PTR $T256767[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN197@Insert_n@4
$LN186@Insert_n@4:

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T256816[ebp], eax
	jmp	SHORT $LN204@Insert_n@4
$LN203@Insert_n@4:
	mov	ecx, DWORD PTR $T256816[ebp]
	add	ecx, 4
	mov	DWORD PTR $T256816[ebp], ecx
$LN204@Insert_n@4:
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	cmp	DWORD PTR $T256816[ebp], ecx
	je	SHORT $LN16@Insert_n@4
	mov	edx, DWORD PTR $T256816[ebp]
	mov	eax, DWORD PTR __Tmp$224515[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN203@Insert_n@4
$LN16@Insert_n@4:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-428]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@IABW4GameOptionTypes@@@Z ENDP ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T256838 = -80						; size = 28
$T256837 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@KAXXZ PROC ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T256838[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T256837[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T256837[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T256838[ebp]
	push	eax
	lea	ecx, DWORD PTR $T256837[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T256837[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T256837[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T256838[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@4:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T256838[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T256837[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@KAXXZ ENDP ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::_Xlen
PUBLIC	??$_Uninit_copy@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum VictoryTypes *,enum VictoryTypes *,std::allocator<enum VictoryTypes> >
PUBLIC	??$unchecked_uninitialized_copy@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@stdext@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@std@@@Z ; stdext::unchecked_uninitialized_copy<enum VictoryTypes *,enum VictoryTypes *,std::allocator<enum VictoryTypes> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z$2
__catchsym$?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z$0
__unwindtable$?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z$5
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z$6
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z
_TEXT	SEGMENT
tv84 = -424						; size = 4
tv302 = -420						; size = 4
tv288 = -416						; size = 4
tv280 = -412						; size = 4
_this$ = -408						; size = 4
$T257540 = -404						; size = 4
$T257532 = -400						; size = 4
$T257531 = -396						; size = 4
$T257508 = -390						; size = 1
$T257507 = -389						; size = 1
$T257506 = -388						; size = 4
$T257505 = -384						; size = 4
$T257493 = -377						; size = 1
$T257492 = -376						; size = 4
$T257491 = -372						; size = 4
$T257490 = -368						; size = 4
__Cat$257524 = -364					; size = 1
$T257522 = -363						; size = 1
$T257521 = -362						; size = 1
__Cat$257516 = -360					; size = 1
$T257513 = -359						; size = 1
$T257512 = -358						; size = 1
$T257511 = -357						; size = 1
$T257465 = -356						; size = 4
$T257446 = -352						; size = 4
$T257429 = -345						; size = 1
$T257428 = -344						; size = 4
$T257418 = -340						; size = 4
$T257417 = -336						; size = 4
__Cat$257461 = -330					; size = 1
$T257459 = -329						; size = 1
$T257458 = -328						; size = 1
__Cat$257454 = -327					; size = 1
$T257451 = -326						; size = 1
$T257450 = -325						; size = 1
$T257393 = -324						; size = 4
$T257385 = -320						; size = 4
$T257377 = -316						; size = 4
$T257359 = -312						; size = 4
$T257358 = -308						; size = 4
$T257342 = -304						; size = 4
__Cat$257365 = -298					; size = 1
$T257363 = -297						; size = 1
$T257316 = -296						; size = 4
$T257315 = -292						; size = 4
$T257305 = -288						; size = 4
__Cat$257311 = -283					; size = 1
$T257309 = -282						; size = 1
$T257308 = -281						; size = 1
$T257289 = -280						; size = 4
$T257270 = -276						; size = 4
$T257253 = -269						; size = 1
$T257252 = -268						; size = 4
$T257242 = -264						; size = 4
$T257241 = -260						; size = 4
__Cat$257284 = -254					; size = 1
$T257281 = -253						; size = 1
$T257280 = -252						; size = 1
__Cat$257277 = -251					; size = 1
$T257274 = -250						; size = 1
$T257273 = -249						; size = 1
$T257217 = -248						; size = 4
$T257216 = -244						; size = 4
$T257212 = -240						; size = 4
$T257211 = -236						; size = 4
$T257193 = -232						; size = 4
$T257192 = -228						; size = 4
$T257176 = -224						; size = 4
__Cat$257199 = -218					; size = 1
$T257196 = -217						; size = 1
$T257127 = -216						; size = 4
$T257126 = -212						; size = 4
$T257110 = -208						; size = 4
__Cat$257133 = -202					; size = 1
$T257130 = -201						; size = 1
$T257067 = -200						; size = 4
$T257066 = -196						; size = 4
$T257050 = -192						; size = 4
__Cat$257073 = -186					; size = 1
$T257070 = -185						; size = 1
$T257024 = -184						; size = 4
$T257012 = -180						; size = 4
$T257002 = -173						; size = 1
$T257001 = -172						; size = 4
__Cat$257020 = -167					; size = 1
$T257018 = -166						; size = 1
$T257017 = -165						; size = 1
$T256989 = -164						; size = 4
$T256977 = -160						; size = 4
$T256967 = -153						; size = 1
$T256966 = -152						; size = 4
__Cat$256985 = -147					; size = 1
$T256983 = -146						; size = 1
$T256982 = -145						; size = 1
$T256954 = -144						; size = 4
$T256944 = -140						; size = 4
__Cat$256952 = -135					; size = 1
$T256950 = -134						; size = 1
$T256949 = -133						; size = 1
__Count$256914 = -120					; size = 4
__Count$256888 = -48					; size = 4
__Tmp$224590 = -44					; size = 4
__Oldend$224591 = -40					; size = 4
__Tmp$224580 = -36					; size = 4
__Ncopied$224567 = -32					; size = 4
__Newvec$224565 = -28					; size = 4
__Whereoff$224566 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z PROC ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 408				; 00000198H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN29@Insert_n@5
	mov	DWORD PTR tv280[ebp], 0
	jmp	SHORT $LN27@Insert_n@5
$LN29@Insert_n@5:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv280[ebp], eax
$LN27@Insert_n@5:
	mov	ecx, DWORD PTR tv280[ebp]
	mov	DWORD PTR __Capacity$[ebp], ecx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@5
	jmp	$LN16@Insert_n@5
$LN14@Insert_n@5:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$256888[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$256888[ebp], 0
	jbe	SHORT $LN35@Insert_n@5
	mov	edx, DWORD PTR __Count$256888[ebp]
	mov	DWORD PTR tv288[ebp], edx
	jmp	SHORT $LN37@Insert_n@5
$LN35@Insert_n@5:
	mov	DWORD PTR tv288[ebp], 1
$LN37@Insert_n@5:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	eax, DWORD PTR tv288[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN42@Insert_n@5

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@KAXXZ ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Xlen
	jmp	$LN16@Insert_n@5

; 1167 : 		else if (_Capacity < size() + _Count)

$LN42@Insert_n@5:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@5

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$256914[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$256914[ebp], 0
	jbe	SHORT $LN48@Insert_n@5
	mov	ecx, DWORD PTR __Count$256914[ebp]
	mov	DWORD PTR tv302[ebp], ecx
	jmp	SHORT $LN44@Insert_n@5
$LN48@Insert_n@5:
	mov	DWORD PTR tv302[ebp], 1
$LN44@Insert_n@5:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	mov	eax, DWORD PTR tv302[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@5
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@5
$LN17@Insert_n@5:
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	add	ecx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], ecx
$LN18@Insert_n@5:
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1171 : 			if (_Capacity < size() + _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], edx
	jae	SHORT $LN54@Insert_n@5

; 1172 : 				_Capacity = size() + _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN54@Insert_n@5:
	push	0
	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	call	??$_Allocate@W4VictoryTypes@@@std@@YAPAW4VictoryTypes@@IPAW41@@Z ; std::_Allocate<enum VictoryTypes>
	add	esp, 8
	mov	DWORD PTR __Newvec$224565[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR __Whereoff$224566[ebp], edx

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$224567[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Whereoff$224566[ebp]
	mov	ecx, DWORD PTR __Newvec$224565[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T256954[ebp], edx
	mov	eax, DWORD PTR $T256954[ebp]
	mov	DWORD PTR $T256944[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T256949[ebp], cl
	mov	dl, BYTE PTR __Cat$256952[ebp]
	mov	BYTE PTR $T256950[ebp], dl
	movzx	eax, BYTE PTR $T256949[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T256950[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T256944[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAW4VictoryTypes@@IW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAXPAW4VictoryTypes@@IABW41@AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum VictoryTypes *,unsigned int,enum VictoryTypes,std::allocator<enum VictoryTypes> >
	add	esp, 24					; 00000018H

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$224567[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$224567[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T256989[ebp], edx
	mov	eax, DWORD PTR __Newvec$224565[ebp]
	mov	DWORD PTR $T256977[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T256982[ebp], cl
	mov	dl, BYTE PTR __Cat$256985[ebp]
	mov	BYTE PTR $T256983[ebp], dl
	mov	al, BYTE PTR $T256982[ebp]
	mov	BYTE PTR $T256967[ebp], al
	mov	ecx, DWORD PTR $T256977[ebp]
	mov	DWORD PTR $T256966[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T256966[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T256989[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@stdext@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@std@@@Z ; stdext::unchecked_uninitialized_copy<enum VictoryTypes *,enum VictoryTypes *,std::allocator<enum VictoryTypes> >
	add	esp, 16					; 00000010H

; 1182 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$224567[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$224567[ebp], eax

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T257024[ebp], edx
	mov	eax, DWORD PTR __Whereoff$224566[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Newvec$224565[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T257012[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T257017[ebp], al
	mov	cl, BYTE PTR __Cat$257020[ebp]
	mov	BYTE PTR $T257018[ebp], cl
	mov	dl, BYTE PTR $T257017[ebp]
	mov	BYTE PTR $T257002[ebp], dl
	mov	eax, DWORD PTR $T257012[ebp]
	mov	DWORD PTR $T257001[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T257001[ebp]
	push	edx
	mov	eax, DWORD PTR $T257024[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	call	??$unchecked_uninitialized_copy@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@stdext@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@std@@@Z ; stdext::unchecked_uninitialized_copy<enum VictoryTypes *,enum VictoryTypes *,std::allocator<enum VictoryTypes> >
	add	esp, 16					; 00000010H
	jmp	$LN19@Insert_n@5
__catch$?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$224567[ebp], 1
	jle	SHORT $LN7@Insert_n@5

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	edx, DWORD PTR __Whereoff$224566[ebp]
	mov	eax, DWORD PTR __Newvec$224565[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T257067[ebp], ecx
	mov	edx, DWORD PTR __Newvec$224565[ebp]
	mov	DWORD PTR $T257066[ebp], edx
	mov	al, BYTE PTR __Cat$257073[ebp]
	mov	BYTE PTR $T257070[ebp], al
	mov	ecx, DWORD PTR $T257066[ebp]
	mov	DWORD PTR $T257050[ebp], ecx
	jmp	SHORT $LN91@Insert_n@5
$LN90@Insert_n@5:
	mov	edx, DWORD PTR $T257050[ebp]
	add	edx, 4
	mov	DWORD PTR $T257050[ebp], edx
$LN91@Insert_n@5:
	mov	eax, DWORD PTR $T257050[ebp]
	cmp	eax, DWORD PTR $T257067[ebp]
	je	SHORT $LN7@Insert_n@5
	jmp	SHORT $LN90@Insert_n@5
$LN7@Insert_n@5:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$224567[ebp], 0
	jle	SHORT $LN6@Insert_n@5

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Whereoff$224566[ebp]
	mov	edx, DWORD PTR __Newvec$224565[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T257127[ebp], edx
	mov	eax, DWORD PTR __Whereoff$224566[ebp]
	mov	ecx, DWORD PTR __Newvec$224565[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T257126[ebp], edx
	mov	al, BYTE PTR __Cat$257133[ebp]
	mov	BYTE PTR $T257130[ebp], al
	mov	ecx, DWORD PTR $T257126[ebp]
	mov	DWORD PTR $T257110[ebp], ecx
	jmp	SHORT $LN106@Insert_n@5
$LN105@Insert_n@5:
	mov	edx, DWORD PTR $T257110[ebp]
	add	edx, 4
	mov	DWORD PTR $T257110[ebp], edx
$LN106@Insert_n@5:
	mov	eax, DWORD PTR $T257110[ebp]
	cmp	eax, DWORD PTR $T257127[ebp]
	je	SHORT $LN6@Insert_n@5
	jmp	SHORT $LN105@Insert_n@5
$LN6@Insert_n@5:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	ecx, DWORD PTR __Newvec$224565[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN115@Insert_n@5
	ret	0
$LN19@Insert_n@5:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN115@Insert_n@5:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], ecx

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN5@Insert_n@5

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T257212[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T257211[ebp], eax
	mov	ecx, DWORD PTR $T257212[ebp]
	mov	DWORD PTR $T257193[ebp], ecx
	mov	edx, DWORD PTR $T257211[ebp]
	mov	DWORD PTR $T257192[ebp], edx
	mov	al, BYTE PTR __Cat$257199[ebp]
	mov	BYTE PTR $T257196[ebp], al
	mov	ecx, DWORD PTR $T257192[ebp]
	mov	DWORD PTR $T257176[ebp], ecx
	jmp	SHORT $LN125@Insert_n@5
$LN124@Insert_n@5:
	mov	edx, DWORD PTR $T257176[ebp]
	add	edx, 4
	mov	DWORD PTR $T257176[ebp], edx
$LN125@Insert_n@5:
	mov	eax, DWORD PTR $T257176[ebp]
	cmp	eax, DWORD PTR $T257193[ebp]
	je	SHORT $LN117@Insert_n@5
	jmp	SHORT $LN124@Insert_n@5
$LN117@Insert_n@5:

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR $T257217[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T257216[ebp], edx
	mov	eax, DWORD PTR $T257216[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n@5:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	ecx, DWORD PTR __Capacity$[ebp]
	mov	edx, DWORD PTR __Newvec$224565[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Newvec$224565[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newvec$224565[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	$LN16@Insert_n@5
$LN10@Insert_n@5:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	sar	eax, 2
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@5

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$224580[ebp], edx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T257289[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T257270[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T257273[ebp], dl
	mov	al, BYTE PTR __Cat$257277[ebp]
	mov	BYTE PTR $T257274[ebp], al
	mov	cl, BYTE PTR $T257273[ebp]
	mov	BYTE PTR $T257253[ebp], cl
	mov	edx, DWORD PTR $T257270[ebp]
	mov	DWORD PTR $T257252[ebp], edx
	mov	eax, DWORD PTR $T257252[ebp]
	mov	DWORD PTR $T257242[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T257241[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T257280[ebp], dl
	mov	al, BYTE PTR __Cat$257284[ebp]
	mov	BYTE PTR $T257281[ebp], al
	movzx	ecx, BYTE PTR $T257280[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T257281[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T257242[ebp]
	push	ecx
	mov	edx, DWORD PTR $T257289[ebp]
	push	edx
	mov	eax, DWORD PTR $T257241[ebp]
	push	eax
	call	??$_Uninit_copy@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum VictoryTypes *,enum VictoryTypes *,std::allocator<enum VictoryTypes> >
	add	esp, 24					; 00000018H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 2
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	mov	DWORD PTR $T257316[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T257315[ebp], edx
	mov	eax, DWORD PTR $T257315[ebp]
	mov	DWORD PTR $T257305[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T257308[ebp], cl
	mov	dl, BYTE PTR __Cat$257311[ebp]
	mov	BYTE PTR $T257309[ebp], dl
	movzx	eax, BYTE PTR $T257308[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T257309[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	lea	eax, DWORD PTR __Tmp$224580[ebp]
	push	eax
	mov	ecx, DWORD PTR $T257316[ebp]
	push	ecx
	mov	edx, DWORD PTR $T257305[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAW4VictoryTypes@@IW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAXPAW4VictoryTypes@@IABW41@AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum VictoryTypes *,unsigned int,enum VictoryTypes,std::allocator<enum VictoryTypes> >
	add	esp, 24					; 00000018H
	jmp	SHORT $LN21@Insert_n@5
__catch$?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T257377[ebp], eax
	mov	ecx, DWORD PTR $T257377[ebp]
	mov	DWORD PTR $T257359[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T257358[ebp], ecx
	mov	dl, BYTE PTR __Cat$257365[ebp]
	mov	BYTE PTR $T257363[ebp], dl
	mov	eax, DWORD PTR $T257358[ebp]
	mov	DWORD PTR $T257342[ebp], eax
	jmp	SHORT $LN160@Insert_n@5
$LN159@Insert_n@5:
	mov	ecx, DWORD PTR $T257342[ebp]
	add	ecx, 4
	mov	DWORD PTR $T257342[ebp], ecx
$LN160@Insert_n@5:
	mov	edx, DWORD PTR $T257342[ebp]
	cmp	edx, DWORD PTR $T257359[ebp]
	je	SHORT $LN152@Insert_n@5
	jmp	SHORT $LN159@Insert_n@5
$LN152@Insert_n@5:

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z$3
	ret	0
$LN21@Insert_n@5:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, edx
	mov	DWORD PTR $T257393[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T257385[ebp], edx
	jmp	SHORT $LN171@Insert_n@5
$LN170@Insert_n@5:
	mov	eax, DWORD PTR $T257385[ebp]
	add	eax, 4
	mov	DWORD PTR $T257385[ebp], eax
$LN171@Insert_n@5:
	mov	ecx, DWORD PTR $T257385[ebp]
	cmp	ecx, DWORD PTR $T257393[ebp]
	je	SHORT $LN167@Insert_n@5
	mov	edx, DWORD PTR $T257385[ebp]
	mov	eax, DWORD PTR __Tmp$224580[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN170@Insert_n@5
$LN167@Insert_n@5:

; 1232 : 			}
; 1233 : 		else

	jmp	$LN16@Insert_n@5
$LN3@Insert_n@5:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$224590[ebp], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Oldend$224591[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T257465[ebp], eax
	mov	ecx, DWORD PTR $T257465[ebp]
	mov	DWORD PTR $T257446[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T257450[ebp], dl
	mov	al, BYTE PTR __Cat$257454[ebp]
	mov	BYTE PTR $T257451[ebp], al
	mov	cl, BYTE PTR $T257450[ebp]
	mov	BYTE PTR $T257429[ebp], cl
	mov	edx, DWORD PTR $T257446[ebp]
	mov	DWORD PTR $T257428[ebp], edx
	mov	eax, DWORD PTR $T257428[ebp]
	mov	DWORD PTR $T257418[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR __Oldend$224591[ebp]
	sub	edx, ecx
	mov	DWORD PTR $T257417[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T257458[ebp], al
	mov	cl, BYTE PTR __Cat$257461[ebp]
	mov	BYTE PTR $T257459[ebp], cl
	movzx	edx, BYTE PTR $T257458[ebp]
	push	edx
	movzx	eax, BYTE PTR $T257459[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T257418[ebp]
	push	edx
	mov	eax, DWORD PTR __Oldend$224591[ebp]
	push	eax
	mov	ecx, DWORD PTR $T257417[ebp]
	push	ecx
	call	??$_Uninit_copy@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum VictoryTypes *,enum VictoryTypes *,std::allocator<enum VictoryTypes> >
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, DWORD PTR __Oldend$224591[ebp]
	mov	DWORD PTR $T257532[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T257531[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T257511[ebp], dl
	mov	al, BYTE PTR __Cat$257516[ebp]
	mov	BYTE PTR $T257512[ebp], al
	mov	cl, BYTE PTR $T257511[ebp]
	mov	BYTE PTR $T257508[ebp], cl
	mov	dl, BYTE PTR $T257513[ebp]
	mov	BYTE PTR $T257507[ebp], dl
	mov	eax, DWORD PTR $T257532[ebp]
	mov	DWORD PTR $T257506[ebp], eax
	mov	ecx, DWORD PTR $T257531[ebp]
	mov	DWORD PTR $T257505[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T257521[ebp], dl
	mov	al, BYTE PTR __Cat$257524[ebp]
	mov	BYTE PTR $T257522[ebp], al
	mov	cl, BYTE PTR $T257521[ebp]
	mov	BYTE PTR $T257493[ebp], cl
	mov	edx, DWORD PTR $T257506[ebp]
	mov	DWORD PTR $T257492[ebp], edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Oldend$224591[ebp]
	sub	ecx, eax
	mov	DWORD PTR $T257491[ebp], ecx
	mov	edx, DWORD PTR $T257505[ebp]
	mov	DWORD PTR $T257490[ebp], edx
$LN197@Insert_n@5:
	mov	eax, DWORD PTR $T257490[ebp]
	cmp	eax, DWORD PTR $T257491[ebp]
	je	SHORT $LN186@Insert_n@5
	mov	ecx, DWORD PTR $T257491[ebp]
	sub	ecx, 4
	mov	DWORD PTR $T257491[ebp], ecx
	mov	edx, DWORD PTR $T257492[ebp]
	sub	edx, 4
	mov	DWORD PTR $T257492[ebp], edx
	mov	eax, DWORD PTR $T257492[ebp]
	mov	ecx, DWORD PTR $T257491[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN197@Insert_n@5
$LN186@Insert_n@5:

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T257540[ebp], eax
	jmp	SHORT $LN204@Insert_n@5
$LN203@Insert_n@5:
	mov	ecx, DWORD PTR $T257540[ebp]
	add	ecx, 4
	mov	DWORD PTR $T257540[ebp], ecx
$LN204@Insert_n@5:
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	cmp	DWORD PTR $T257540[ebp], ecx
	je	SHORT $LN16@Insert_n@5
	mov	edx, DWORD PTR $T257540[ebp]
	mov	eax, DWORD PTR __Tmp$224590[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN203@Insert_n@5
$LN16@Insert_n@5:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-428]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@IABW4VictoryTypes@@@Z ENDP ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T257562 = -80						; size = 28
$T257561 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@KAXXZ PROC ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T257562[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T257561[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T257561[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T257562[ebp]
	push	eax
	lea	ecx, DWORD PTR $T257561[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T257561[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T257561[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T257562[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@5:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T257562[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T257561[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@KAXXZ ENDP ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::_Xlen
PUBLIC	??$_Copy_backward_opt@PAUPlayerInfo@CvReplayInfo@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::random_access_iterator_tag>
PUBLIC	??0PlayerInfo@CvReplayInfo@@QAE@ABU01@@Z	; CvReplayInfo::PlayerInfo::PlayerInfo
PUBLIC	??$unchecked_uninitialized_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@stdext@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::allocator<CvReplayInfo::PlayerInfo> >
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z$66 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z$2
__catchsym$?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z$65 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z$0
__ehfuncinfo$?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z$65
	DD	03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z$66
__unwindtable$?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z$4
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z$5
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z
_TEXT	SEGMENT
tv84 = -752						; size = 4
tv312 = -748						; size = 4
tv298 = -744						; size = 4
tv290 = -740						; size = 4
_this$ = -736						; size = 4
$T258399 = -716						; size = 4
$T258391 = -712						; size = 4
$T258390 = -708						; size = 4
$T258371 = -702						; size = 1
$T258370 = -701						; size = 1
$T258369 = -700						; size = 4
$T258368 = -696						; size = 4
__Cat$258386 = -692					; size = 1
$T258384 = -691						; size = 1
$T258383 = -690						; size = 1
__Cat$258378 = -688					; size = 1
$T258375 = -687						; size = 1
$T258374 = -686						; size = 1
$T258373 = -685						; size = 1
$T258341 = -684						; size = 4
$T258329 = -680						; size = 4
$T258319 = -673						; size = 1
$T258318 = -672						; size = 4
__Cat$258336 = -667					; size = 1
$T258333 = -666						; size = 1
$T258332 = -665						; size = 1
$T258271 = -644						; size = 4
$T258263 = -640						; size = 4
$T258255 = -636						; size = 4
$T258234 = -632						; size = 4
$T258233 = -628						; size = 4
$T258214 = -624						; size = 4
$T258213 = -620						; size = 4
__Cat$258240 = -598					; size = 1
$T258237 = -597						; size = 1
$T258149 = -596						; size = 4
$T258148 = -592						; size = 4
$T258138 = -588						; size = 4
__Cat$258145 = -583					; size = 1
$T258142 = -582						; size = 1
$T258141 = -581						; size = 1
$T258122 = -580						; size = 4
$T258110 = -576						; size = 4
$T258100 = -569						; size = 1
$T258099 = -568						; size = 4
__Cat$258117 = -563					; size = 1
$T258114 = -562						; size = 1
$T258113 = -561						; size = 1
$T258077 = -556						; size = 4
$T258076 = -552						; size = 4
$T258072 = -548						; size = 4
$T258071 = -544						; size = 4
$T258050 = -540						; size = 4
$T258049 = -536						; size = 4
$T258030 = -532						; size = 4
$T258029 = -528						; size = 4
__Cat$258058 = -506					; size = 1
$T258056 = -505						; size = 1
$T257939 = -504						; size = 4
$T257938 = -500						; size = 4
$T257919 = -496						; size = 4
$T257918 = -492						; size = 4
__Cat$257946 = -470					; size = 1
$T257944 = -469						; size = 1
$T257834 = -468						; size = 4
$T257833 = -464						; size = 4
$T257814 = -460						; size = 4
$T257813 = -456						; size = 4
__Cat$257841 = -434					; size = 1
$T257839 = -433						; size = 1
$T257749 = -432						; size = 4
$T257737 = -428						; size = 4
$T257727 = -421						; size = 1
$T257726 = -420						; size = 4
__Cat$257745 = -415					; size = 1
$T257743 = -414						; size = 1
$T257742 = -413						; size = 1
$T257714 = -412						; size = 4
$T257702 = -408						; size = 4
$T257692 = -401						; size = 1
$T257691 = -400						; size = 4
__Cat$257710 = -395					; size = 1
$T257708 = -394						; size = 1
$T257707 = -393						; size = 1
$T257679 = -392						; size = 4
$T257669 = -388						; size = 4
__Cat$257676 = -383					; size = 1
$T257674 = -382						; size = 1
$T257673 = -381						; size = 1
__Count$257641 = -380					; size = 4
__Count$257615 = -308					; size = 4
__Tmp$224665 = -304					; size = 128
__Oldend$224666 = -172					; size = 4
__Tmp$224655 = -168					; size = 128
__$ArrayPad$ = -36					; size = 4
__Ncopied$224642 = -32					; size = 4
__Newvec$224640 = -28					; size = 4
__Whereoff$224641 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z PROC ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 736				; 000002e0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN31@Insert_n@6
	mov	DWORD PTR tv290[ebp], 0
	jmp	SHORT $LN29@Insert_n@6
$LN31@Insert_n@6:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 7
	mov	DWORD PTR tv290[ebp], eax
$LN29@Insert_n@6:
	mov	ecx, DWORD PTR tv290[ebp]
	mov	DWORD PTR __Capacity$[ebp], ecx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@6
	jmp	$LN16@Insert_n@6
$LN14@Insert_n@6:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$257615[ebp], 33554431	; 01ffffffH
	cmp	DWORD PTR __Count$257615[ebp], 0
	jbe	SHORT $LN37@Insert_n@6
	mov	edx, DWORD PTR __Count$257615[ebp]
	mov	DWORD PTR tv298[ebp], edx
	jmp	SHORT $LN39@Insert_n@6
$LN37@Insert_n@6:
	mov	DWORD PTR tv298[ebp], 1
$LN39@Insert_n@6:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 7
	mov	eax, DWORD PTR tv298[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN44@Insert_n@6

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@KAXXZ ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Xlen
	jmp	$LN16@Insert_n@6

; 1167 : 		else if (_Capacity < size() + _Count)

$LN44@Insert_n@6:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 7
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@6

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$257641[ebp], 33554431	; 01ffffffH
	cmp	DWORD PTR __Count$257641[ebp], 0
	jbe	SHORT $LN50@Insert_n@6
	mov	ecx, DWORD PTR __Count$257641[ebp]
	mov	DWORD PTR tv312[ebp], ecx
	jmp	SHORT $LN46@Insert_n@6
$LN50@Insert_n@6:
	mov	DWORD PTR tv312[ebp], 1
$LN46@Insert_n@6:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	mov	eax, DWORD PTR tv312[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@6
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@6
$LN17@Insert_n@6:
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	add	ecx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], ecx
$LN18@Insert_n@6:
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1171 : 			if (_Capacity < size() + _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 7
	add	edx, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], edx
	jae	SHORT $LN56@Insert_n@6

; 1172 : 				_Capacity = size() + _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 7
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN56@Insert_n@6:
	push	0
	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	call	??$_Allocate@UPlayerInfo@CvReplayInfo@@@std@@YAPAUPlayerInfo@CvReplayInfo@@IPAU12@@Z ; std::_Allocate<CvReplayInfo::PlayerInfo>
	add	esp, 8
	mov	DWORD PTR __Newvec$224640[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 7
	mov	DWORD PTR __Whereoff$224641[ebp], edx

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$224642[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Whereoff$224641[ebp]
	shl	eax, 7
	add	eax, DWORD PTR __Newvec$224640[ebp]
	mov	DWORD PTR $T257679[ebp], eax
	mov	ecx, DWORD PTR $T257679[ebp]
	mov	DWORD PTR $T257669[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T257673[ebp], dl
	mov	al, BYTE PTR __Cat$257676[ebp]
	mov	BYTE PTR $T257674[ebp], al
	movzx	ecx, BYTE PTR $T257673[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T257674[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR $T257669[ebp]
	push	eax
	call	??$_Uninit_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvReplayInfo::PlayerInfo *,unsigned int,CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >
	add	esp, 24					; 00000018H

; 1179 : 			++_Ncopied;

	mov	ecx, DWORD PTR __Ncopied$224642[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ncopied$224642[ebp], ecx

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T257714[ebp], eax
	mov	ecx, DWORD PTR __Newvec$224640[ebp]
	mov	DWORD PTR $T257702[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T257707[ebp], dl
	mov	al, BYTE PTR __Cat$257710[ebp]
	mov	BYTE PTR $T257708[ebp], al
	mov	cl, BYTE PTR $T257707[ebp]
	mov	BYTE PTR $T257692[ebp], cl
	mov	edx, DWORD PTR $T257702[ebp]
	mov	DWORD PTR $T257691[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T257691[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	mov	eax, DWORD PTR $T257714[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@stdext@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::allocator<CvReplayInfo::PlayerInfo> >
	add	esp, 16					; 00000010H

; 1182 : 			++_Ncopied;

	mov	ecx, DWORD PTR __Ncopied$224642[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ncopied$224642[ebp], ecx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T257749[ebp], eax
	mov	ecx, DWORD PTR __Whereoff$224641[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 7
	add	ecx, DWORD PTR __Newvec$224640[ebp]
	mov	DWORD PTR $T257737[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T257742[ebp], dl
	mov	al, BYTE PTR __Cat$257745[ebp]
	mov	BYTE PTR $T257743[ebp], al
	mov	cl, BYTE PTR $T257742[ebp]
	mov	BYTE PTR $T257727[ebp], cl
	mov	edx, DWORD PTR $T257737[ebp]
	mov	DWORD PTR $T257726[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T257726[ebp]
	push	ecx
	mov	edx, DWORD PTR $T257749[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@stdext@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::allocator<CvReplayInfo::PlayerInfo> >
	add	esp, 16					; 00000010H
	jmp	$LN19@Insert_n@6
__catch$?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$224642[ebp], 1
	jle	$LN7@Insert_n@6

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	ecx, DWORD PTR __Whereoff$224641[ebp]
	shl	ecx, 7
	add	ecx, DWORD PTR __Newvec$224640[ebp]
	mov	DWORD PTR $T257834[ebp], ecx
	mov	edx, DWORD PTR __Newvec$224640[ebp]
	mov	DWORD PTR $T257833[ebp], edx
	mov	al, BYTE PTR __Cat$257841[ebp]
	mov	BYTE PTR $T257839[ebp], al
	mov	ecx, DWORD PTR $T257834[ebp]
	mov	DWORD PTR $T257814[ebp], ecx
	mov	edx, DWORD PTR $T257833[ebp]
	mov	DWORD PTR $T257813[ebp], edx
	jmp	SHORT $LN88@Insert_n@6
$LN87@Insert_n@6:
	mov	eax, DWORD PTR $T257813[ebp]
	add	eax, 128				; 00000080H
	mov	DWORD PTR $T257813[ebp], eax
$LN88@Insert_n@6:
	mov	ecx, DWORD PTR $T257813[ebp]
	cmp	ecx, DWORD PTR $T257814[ebp]
	je	SHORT $LN7@Insert_n@6
	mov	ecx, DWORD PTR $T257813[ebp]
	call	??1PlayerInfo@CvReplayInfo@@QAE@XZ
	xor	edx, edx
	and	edx, 1
	je	SHORT $LN91@Insert_n@6
	mov	eax, DWORD PTR $T257813[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN91@Insert_n@6:
	jmp	SHORT $LN87@Insert_n@6
$LN7@Insert_n@6:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$224642[ebp], 0
	jle	$LN6@Insert_n@6

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 7
	mov	edx, DWORD PTR __Whereoff$224641[ebp]
	shl	edx, 7
	add	edx, DWORD PTR __Newvec$224640[ebp]
	add	edx, ecx
	mov	DWORD PTR $T257939[ebp], edx
	mov	eax, DWORD PTR __Whereoff$224641[ebp]
	shl	eax, 7
	add	eax, DWORD PTR __Newvec$224640[ebp]
	mov	DWORD PTR $T257938[ebp], eax
	mov	cl, BYTE PTR __Cat$257946[ebp]
	mov	BYTE PTR $T257944[ebp], cl
	mov	edx, DWORD PTR $T257939[ebp]
	mov	DWORD PTR $T257919[ebp], edx
	mov	eax, DWORD PTR $T257938[ebp]
	mov	DWORD PTR $T257918[ebp], eax
	jmp	SHORT $LN124@Insert_n@6
$LN123@Insert_n@6:
	mov	ecx, DWORD PTR $T257918[ebp]
	add	ecx, 128				; 00000080H
	mov	DWORD PTR $T257918[ebp], ecx
$LN124@Insert_n@6:
	mov	edx, DWORD PTR $T257918[ebp]
	cmp	edx, DWORD PTR $T257919[ebp]
	je	SHORT $LN6@Insert_n@6
	mov	ecx, DWORD PTR $T257918[ebp]
	call	??1PlayerInfo@CvReplayInfo@@QAE@XZ
	xor	eax, eax
	and	eax, 1
	je	SHORT $LN127@Insert_n@6
	mov	ecx, DWORD PTR $T257918[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN127@Insert_n@6:
	jmp	SHORT $LN123@Insert_n@6
$LN6@Insert_n@6:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Newvec$224640[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN154@Insert_n@6
	ret	0
$LN19@Insert_n@6:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN154@Insert_n@6:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 7
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], edx

; 1195 : 			if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	$LN5@Insert_n@6

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T258072[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T258071[ebp], ecx
	mov	edx, DWORD PTR $T258072[ebp]
	mov	DWORD PTR $T258050[ebp], edx
	mov	eax, DWORD PTR $T258071[ebp]
	mov	DWORD PTR $T258049[ebp], eax
	mov	cl, BYTE PTR __Cat$258058[ebp]
	mov	BYTE PTR $T258056[ebp], cl
	mov	edx, DWORD PTR $T258050[ebp]
	mov	DWORD PTR $T258030[ebp], edx
	mov	eax, DWORD PTR $T258049[ebp]
	mov	DWORD PTR $T258029[ebp], eax
	jmp	SHORT $LN164@Insert_n@6
$LN163@Insert_n@6:
	mov	ecx, DWORD PTR $T258029[ebp]
	add	ecx, 128				; 00000080H
	mov	DWORD PTR $T258029[ebp], ecx
$LN164@Insert_n@6:
	mov	edx, DWORD PTR $T258029[ebp]
	cmp	edx, DWORD PTR $T258030[ebp]
	je	SHORT $LN156@Insert_n@6
	mov	ecx, DWORD PTR $T258029[ebp]
	call	??1PlayerInfo@CvReplayInfo@@QAE@XZ
	xor	eax, eax
	and	eax, 1
	je	SHORT $LN167@Insert_n@6
	mov	ecx, DWORD PTR $T258029[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN167@Insert_n@6:
	jmp	SHORT $LN163@Insert_n@6
$LN156@Insert_n@6:

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 7
	mov	DWORD PTR $T258077[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T258076[ebp], eax
	mov	ecx, DWORD PTR $T258076[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n@6:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	shl	edx, 7
	add	edx, DWORD PTR __Newvec$224640[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 7
	add	ecx, DWORD PTR __Newvec$224640[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newvec$224640[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	$LN16@Insert_n@6
$LN10@Insert_n@6:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	sar	eax, 7
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@6

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Tmp$224655[ebp]
	call	??0PlayerInfo@CvReplayInfo@@QAE@ABU01@@Z
	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T258122[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 7
	add	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T258110[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T258113[ebp], dl
	mov	al, BYTE PTR __Cat$258117[ebp]
	mov	BYTE PTR $T258114[ebp], al
	mov	cl, BYTE PTR $T258113[ebp]
	mov	BYTE PTR $T258100[ebp], cl
	mov	edx, DWORD PTR $T258110[ebp]
	mov	DWORD PTR $T258099[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T258099[ebp]
	push	ecx
	mov	edx, DWORD PTR $T258122[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@stdext@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::allocator<CvReplayInfo::PlayerInfo> >
	add	esp, 16					; 00000010H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 3

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 7
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	mov	DWORD PTR $T258149[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T258148[ebp], edx
	mov	eax, DWORD PTR $T258148[ebp]
	mov	DWORD PTR $T258138[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T258141[ebp], cl
	mov	dl, BYTE PTR __Cat$258145[ebp]
	mov	BYTE PTR $T258142[ebp], dl
	movzx	eax, BYTE PTR $T258141[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T258142[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	lea	eax, DWORD PTR __Tmp$224655[ebp]
	push	eax
	mov	ecx, DWORD PTR $T258149[ebp]
	push	ecx
	mov	edx, DWORD PTR $T258138[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvReplayInfo::PlayerInfo *,unsigned int,CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >
	add	esp, 24					; 00000018H
	jmp	$LN21@Insert_n@6
__catch$?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 7
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR $T258255[ebp], eax
	mov	edx, DWORD PTR $T258255[ebp]
	mov	DWORD PTR $T258234[ebp], edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T258233[ebp], eax
	mov	cl, BYTE PTR __Cat$258240[ebp]
	mov	BYTE PTR $T258237[ebp], cl
	mov	edx, DWORD PTR $T258234[ebp]
	mov	DWORD PTR $T258214[ebp], edx
	mov	eax, DWORD PTR $T258233[ebp]
	mov	DWORD PTR $T258213[ebp], eax
	jmp	SHORT $LN225@Insert_n@6
$LN224@Insert_n@6:
	mov	ecx, DWORD PTR $T258213[ebp]
	add	ecx, 128				; 00000080H
	mov	DWORD PTR $T258213[ebp], ecx
$LN225@Insert_n@6:
	mov	edx, DWORD PTR $T258213[ebp]
	cmp	edx, DWORD PTR $T258214[ebp]
	je	SHORT $LN217@Insert_n@6
	mov	ecx, DWORD PTR $T258213[ebp]
	call	??1PlayerInfo@CvReplayInfo@@QAE@XZ
	xor	eax, eax
	and	eax, 1
	je	SHORT $LN228@Insert_n@6
	mov	ecx, DWORD PTR $T258213[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN228@Insert_n@6:
	jmp	SHORT $LN224@Insert_n@6
$LN217@Insert_n@6:

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 2
	mov	eax, __tryend$?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z$3
	ret	0
$LN21@Insert_n@6:
	mov	DWORD PTR __$EHRec$[ebp+12], 2
__tryend$?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 7
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 7
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, edx
	mov	DWORD PTR $T258271[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T258263[ebp], edx
	jmp	SHORT $LN257@Insert_n@6
$LN256@Insert_n@6:
	mov	eax, DWORD PTR $T258263[ebp]
	add	eax, 128				; 00000080H
	mov	DWORD PTR $T258263[ebp], eax
$LN257@Insert_n@6:
	mov	ecx, DWORD PTR $T258263[ebp]
	cmp	ecx, DWORD PTR $T258271[ebp]
	je	SHORT $LN253@Insert_n@6
	lea	edx, DWORD PTR __Tmp$224655[ebp]
	push	edx
	mov	ecx, DWORD PTR $T258263[ebp]
	call	??4PlayerInfo@CvReplayInfo@@QAEAAU01@ABU01@@Z
	jmp	SHORT $LN256@Insert_n@6
$LN253@Insert_n@6:

; 1232 : 			}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Tmp$224655[ebp]
	call	??1PlayerInfo@CvReplayInfo@@QAE@XZ

; 1233 : 		else

	jmp	$LN16@Insert_n@6
$LN3@Insert_n@6:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$224665[ebp]
	call	??0PlayerInfo@CvReplayInfo@@QAE@ABU01@@Z
	mov	DWORD PTR __$EHRec$[ebp+12], 5

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Oldend$224666[ebp], edx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T258341[ebp], ecx
	mov	edx, DWORD PTR $T258341[ebp]
	mov	DWORD PTR $T258329[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T258332[ebp], al
	mov	cl, BYTE PTR __Cat$258336[ebp]
	mov	BYTE PTR $T258333[ebp], cl
	mov	dl, BYTE PTR $T258332[ebp]
	mov	BYTE PTR $T258319[ebp], dl
	mov	eax, DWORD PTR $T258329[ebp]
	mov	DWORD PTR $T258318[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T258318[ebp]
	push	edx
	mov	eax, DWORD PTR __Oldend$224666[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 7
	mov	edx, DWORD PTR __Oldend$224666[ebp]
	sub	edx, ecx
	push	edx
	call	??$unchecked_uninitialized_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@stdext@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::allocator<CvReplayInfo::PlayerInfo> >
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$224666[ebp]
	mov	DWORD PTR $T258391[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T258390[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T258373[ebp], cl
	mov	dl, BYTE PTR __Cat$258378[ebp]
	mov	BYTE PTR $T258374[ebp], dl
	mov	al, BYTE PTR $T258373[ebp]
	mov	BYTE PTR $T258371[ebp], al
	mov	cl, BYTE PTR $T258375[ebp]
	mov	BYTE PTR $T258370[ebp], cl
	mov	edx, DWORD PTR $T258391[ebp]
	mov	DWORD PTR $T258369[ebp], edx
	mov	eax, DWORD PTR $T258390[ebp]
	mov	DWORD PTR $T258368[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T258383[ebp], cl
	mov	dl, BYTE PTR __Cat$258386[ebp]
	mov	BYTE PTR $T258384[ebp], dl
	movzx	eax, BYTE PTR $T258383[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T258384[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T258370[ebp]
	push	edx
	mov	eax, DWORD PTR $T258369[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 7
	mov	edx, DWORD PTR __Oldend$224666[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR $T258368[ebp]
	push	eax
	call	??$_Copy_backward_opt@PAUPlayerInfo@CvReplayInfo@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T258399[ebp], ecx
	jmp	SHORT $LN309@Insert_n@6
$LN308@Insert_n@6:
	mov	edx, DWORD PTR $T258399[ebp]
	add	edx, 128				; 00000080H
	mov	DWORD PTR $T258399[ebp], edx
$LN309@Insert_n@6:
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR __Where$[ebp]
	cmp	DWORD PTR $T258399[ebp], eax
	je	SHORT $LN305@Insert_n@6
	lea	ecx, DWORD PTR __Tmp$224665[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T258399[ebp]
	call	??4PlayerInfo@CvReplayInfo@@QAEAAU01@ABU01@@Z
	jmp	SHORT $LN308@Insert_n@6
$LN305@Insert_n@6:

; 1249 : 			}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Tmp$224665[ebp]
	call	??1PlayerInfo@CvReplayInfo@@QAE@XZ
$LN16@Insert_n@6:

; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z$4:
	lea	ecx, DWORD PTR __Tmp$224655[ebp]
	jmp	??1PlayerInfo@CvReplayInfo@@QAE@XZ
__unwindfunclet$?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z$5:
	lea	ecx, DWORD PTR __Tmp$224665[ebp]
	jmp	??1PlayerInfo@CvReplayInfo@@QAE@XZ
__ehhandler$?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-756]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@IABUPlayerInfo@CvReplayInfo@@@Z ENDP ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T258446 = -80						; size = 28
$T258445 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@KAXXZ PROC ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T258446[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T258445[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T258445[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T258446[ebp]
	push	eax
	lea	ecx, DWORD PTR $T258445[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T258445[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T258445[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T258446[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@6:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T258446[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T258445[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@KAXXZ ENDP ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::_Xlen
PUBLIC	?swap@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXAAV12@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::swap
PUBLIC	??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
PUBLIC	??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z$44 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z$2
__catchsym$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z$43 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z$0
__ehfuncinfo$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z DD 019930522H
	DD	0cH
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z DD 00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z$43
	DD	06H
	DD	06H
	DD	08H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z$44
__unwindtable$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z$7
	DD	01H
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z$11
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z$4
	DD	05H
	DD	00H
	DD	05H
	DD	00H
	DD	07H
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z$19
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z$27
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z$35
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z
_TEXT	SEGMENT
tv84 = -520						; size = 4
tv312 = -516						; size = 4
tv298 = -512						; size = 4
tv290 = -508						; size = 4
_this$ = -504						; size = 4
$T260058 = -464						; size = 4
$T260050 = -460						; size = 4
$T260049 = -456						; size = 4
$T260029 = -450						; size = 1
$T260028 = -449						; size = 1
$T260027 = -448						; size = 4
$T260026 = -444						; size = 4
$T260025 = -440						; size = 4
__Cat$260036 = -432					; size = 1
$T260034 = -431						; size = 1
$T260033 = -430						; size = 1
$T260032 = -429						; size = 1
$T259995 = -428						; size = 4
$T259985 = -424						; size = 4
__Cat$259993 = -419					; size = 1
$T259991 = -418						; size = 1
$T259990 = -417						; size = 1
$T259711 = -380						; size = 4
$T259703 = -376						; size = 4
$T259695 = -372						; size = 4
$T259668 = -368						; size = 4
$T259667 = -364						; size = 4
$T259642 = -360						; size = 4
$T259641 = -356						; size = 4
__Cat$259675 = -318					; size = 1
$T259672 = -317						; size = 1
$T259320 = -316						; size = 4
$T259319 = -312						; size = 4
$T259309 = -308						; size = 4
__Cat$259316 = -303					; size = 1
$T259313 = -302						; size = 1
$T259312 = -301						; size = 1
$T259293 = -300						; size = 4
$T259283 = -296						; size = 4
__Cat$259290 = -291					; size = 1
$T259287 = -290						; size = 1
$T259286 = -289						; size = 1
$T259267 = -288						; size = 4
$T259266 = -284						; size = 4
$T259262 = -280						; size = 4
$T259261 = -276						; size = 4
$T259234 = -272						; size = 4
$T259233 = -268						; size = 4
$T259208 = -264						; size = 4
$T259207 = -260						; size = 4
__Cat$259257 = -222					; size = 1
$T259255 = -221						; size = 1
$T258854 = -220						; size = 4
$T258853 = -216						; size = 4
$T258828 = -212						; size = 4
$T258827 = -208						; size = 4
__Cat$258861 = -202					; size = 1
$T258859 = -201						; size = 1
$T258721 = -200						; size = 4
$T258720 = -196						; size = 4
$T258695 = -192						; size = 4
$T258694 = -188						; size = 4
__Cat$258728 = -182					; size = 1
$T258726 = -181						; size = 1
$T258614 = -180						; size = 4
$T258604 = -176						; size = 4
__Cat$258612 = -171					; size = 1
$T258609 = -170						; size = 1
$T258608 = -169						; size = 1
$T258588 = -168						; size = 4
$T258578 = -164						; size = 4
__Cat$258586 = -159					; size = 1
$T258583 = -158						; size = 1
$T258582 = -157						; size = 1
$T258562 = -156						; size = 4
$T258552 = -152						; size = 4
__Cat$258559 = -147					; size = 1
$T258557 = -146						; size = 1
$T258556 = -145						; size = 1
__Count$258524 = -144					; size = 4
__Count$258498 = -72					; size = 4
__Tmp$224740 = -68					; size = 16
__Oldend$224741 = -52					; size = 4
__Tmp$224730 = -48					; size = 16
__Ncopied$224717 = -32					; size = 4
__Newvec$224715 = -28					; size = 4
__Whereoff$224716 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z PROC ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 504				; 000001f8H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN31@Insert_n@7
	mov	DWORD PTR tv290[ebp], 0
	jmp	SHORT $LN29@Insert_n@7
$LN31@Insert_n@7:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 4
	mov	DWORD PTR tv290[ebp], eax
$LN29@Insert_n@7:
	mov	ecx, DWORD PTR tv290[ebp]
	mov	DWORD PTR __Capacity$[ebp], ecx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@7
	jmp	$LN16@Insert_n@7
$LN14@Insert_n@7:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$258498[ebp], 268435455 ; 0fffffffH
	cmp	DWORD PTR __Count$258498[ebp], 0
	jbe	SHORT $LN37@Insert_n@7
	mov	edx, DWORD PTR __Count$258498[ebp]
	mov	DWORD PTR tv298[ebp], edx
	jmp	SHORT $LN39@Insert_n@7
$LN37@Insert_n@7:
	mov	DWORD PTR tv298[ebp], 1
$LN39@Insert_n@7:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 4
	mov	eax, DWORD PTR tv298[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN44@Insert_n@7

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@KAXXZ ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Xlen
	jmp	$LN16@Insert_n@7

; 1167 : 		else if (_Capacity < size() + _Count)

$LN44@Insert_n@7:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 4
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@7

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$258524[ebp], 268435455 ; 0fffffffH
	cmp	DWORD PTR __Count$258524[ebp], 0
	jbe	SHORT $LN50@Insert_n@7
	mov	ecx, DWORD PTR __Count$258524[ebp]
	mov	DWORD PTR tv312[ebp], ecx
	jmp	SHORT $LN46@Insert_n@7
$LN50@Insert_n@7:
	mov	DWORD PTR tv312[ebp], 1
$LN46@Insert_n@7:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	mov	eax, DWORD PTR tv312[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@7
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@7
$LN17@Insert_n@7:
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	add	ecx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], ecx
$LN18@Insert_n@7:
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1171 : 			if (_Capacity < size() + _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 4
	add	edx, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], edx
	jae	SHORT $LN56@Insert_n@7

; 1172 : 				_Capacity = size() + _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 4
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN56@Insert_n@7:
	push	0
	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	call	??$_Allocate@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IPAV10@@Z ; std::_Allocate<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >
	add	esp, 8
	mov	DWORD PTR __Newvec$224715[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 4
	mov	DWORD PTR __Whereoff$224716[ebp], edx

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$224717[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Whereoff$224716[ebp]
	shl	eax, 4
	add	eax, DWORD PTR __Newvec$224715[ebp]
	mov	DWORD PTR $T258562[ebp], eax
	mov	ecx, DWORD PTR $T258562[ebp]
	mov	DWORD PTR $T258552[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T258556[ebp], dl
	mov	al, BYTE PTR __Cat$258559[ebp]
	mov	BYTE PTR $T258557[ebp], al
	movzx	ecx, BYTE PTR $T258556[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T258557[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR $T258552[ebp]
	push	eax
	call	??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,unsigned int,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
	add	esp, 24					; 00000018H

; 1179 : 			++_Ncopied;

	mov	ecx, DWORD PTR __Ncopied$224717[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ncopied$224717[ebp], ecx

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T258588[ebp], eax
	mov	ecx, DWORD PTR __Newvec$224715[ebp]
	mov	DWORD PTR $T258578[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T258582[ebp], dl
	mov	al, BYTE PTR __Cat$258586[ebp]
	mov	BYTE PTR $T258583[ebp], al
	movzx	ecx, BYTE PTR $T258582[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T258583[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T258578[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	mov	eax, DWORD PTR $T258588[ebp]
	push	eax
	call	??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
	add	esp, 24					; 00000018H

; 1182 : 			++_Ncopied;

	mov	ecx, DWORD PTR __Ncopied$224717[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ncopied$224717[ebp], ecx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T258614[ebp], eax
	mov	ecx, DWORD PTR __Whereoff$224716[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR __Newvec$224715[ebp]
	mov	DWORD PTR $T258604[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T258608[ebp], dl
	mov	al, BYTE PTR __Cat$258612[ebp]
	mov	BYTE PTR $T258609[ebp], al
	movzx	ecx, BYTE PTR $T258608[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T258609[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T258604[ebp]
	push	ecx
	mov	edx, DWORD PTR $T258614[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
	add	esp, 24					; 00000018H
	jmp	$LN19@Insert_n@7
__catch$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$224717[ebp], 1
	jle	$LN7@Insert_n@7

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	ecx, DWORD PTR __Whereoff$224716[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR __Newvec$224715[ebp]
	mov	DWORD PTR $T258721[ebp], ecx
	mov	edx, DWORD PTR __Newvec$224715[ebp]
	mov	DWORD PTR $T258720[ebp], edx
	mov	al, BYTE PTR __Cat$258728[ebp]
	mov	BYTE PTR $T258726[ebp], al
	mov	ecx, DWORD PTR $T258721[ebp]
	mov	DWORD PTR $T258695[ebp], ecx
	mov	edx, DWORD PTR $T258720[ebp]
	mov	DWORD PTR $T258694[ebp], edx
	jmp	SHORT $LN84@Insert_n@7
$LN83@Insert_n@7:
	mov	eax, DWORD PTR $T258694[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR $T258694[ebp], eax
$LN84@Insert_n@7:
	mov	ecx, DWORD PTR $T258694[ebp]
	cmp	ecx, DWORD PTR $T258695[ebp]
	je	SHORT $LN7@Insert_n@7
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR $T258694[ebp]
	call	?_Tidy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	xor	edx, edx
	and	edx, 1
	je	SHORT $LN87@Insert_n@7
	mov	eax, DWORD PTR $T258694[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN87@Insert_n@7:
	jmp	SHORT $LN83@Insert_n@7
$LN7@Insert_n@7:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$224717[ebp], 0
	jle	$LN6@Insert_n@7

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR __Whereoff$224716[ebp]
	shl	edx, 4
	add	edx, DWORD PTR __Newvec$224715[ebp]
	add	edx, ecx
	mov	DWORD PTR $T258854[ebp], edx
	mov	eax, DWORD PTR __Whereoff$224716[ebp]
	shl	eax, 4
	add	eax, DWORD PTR __Newvec$224715[ebp]
	mov	DWORD PTR $T258853[ebp], eax
	mov	cl, BYTE PTR __Cat$258861[ebp]
	mov	BYTE PTR $T258859[ebp], cl
	mov	edx, DWORD PTR $T258854[ebp]
	mov	DWORD PTR $T258828[ebp], edx
	mov	eax, DWORD PTR $T258853[ebp]
	mov	DWORD PTR $T258827[ebp], eax
	jmp	SHORT $LN110@Insert_n@7
$LN109@Insert_n@7:
	mov	ecx, DWORD PTR $T258827[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR $T258827[ebp], ecx
$LN110@Insert_n@7:
	mov	edx, DWORD PTR $T258827[ebp]
	cmp	edx, DWORD PTR $T258828[ebp]
	je	SHORT $LN6@Insert_n@7
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR $T258827[ebp]
	call	?_Tidy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	xor	eax, eax
	and	eax, 1
	je	SHORT $LN113@Insert_n@7
	mov	ecx, DWORD PTR $T258827[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN113@Insert_n@7:
	jmp	SHORT $LN109@Insert_n@7
$LN6@Insert_n@7:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Newvec$224715[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN130@Insert_n@7
	ret	0
$LN19@Insert_n@7:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN130@Insert_n@7:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 4
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], edx

; 1195 : 			if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	$LN5@Insert_n@7

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T259262[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T259261[ebp], ecx
	mov	edx, DWORD PTR $T259262[ebp]
	mov	DWORD PTR $T259234[ebp], edx
	mov	eax, DWORD PTR $T259261[ebp]
	mov	DWORD PTR $T259233[ebp], eax
	mov	cl, BYTE PTR __Cat$259257[ebp]
	mov	BYTE PTR $T259255[ebp], cl
	mov	edx, DWORD PTR $T259234[ebp]
	mov	DWORD PTR $T259208[ebp], edx
	mov	eax, DWORD PTR $T259233[ebp]
	mov	DWORD PTR $T259207[ebp], eax
	jmp	SHORT $LN140@Insert_n@7
$LN139@Insert_n@7:
	mov	ecx, DWORD PTR $T259207[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR $T259207[ebp], ecx
$LN140@Insert_n@7:
	mov	edx, DWORD PTR $T259207[ebp]
	cmp	edx, DWORD PTR $T259208[ebp]
	je	SHORT $LN132@Insert_n@7
	mov	DWORD PTR __$EHRec$[ebp+12], 4
	mov	ecx, DWORD PTR $T259207[ebp]
	call	?_Tidy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	xor	eax, eax
	and	eax, 1
	je	SHORT $LN143@Insert_n@7
	mov	ecx, DWORD PTR $T259207[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN143@Insert_n@7:
	jmp	SHORT $LN139@Insert_n@7
$LN132@Insert_n@7:

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 4
	mov	DWORD PTR $T259267[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T259266[ebp], eax
	mov	ecx, DWORD PTR $T259266[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n@7:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	shl	edx, 4
	add	edx, DWORD PTR __Newvec$224715[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR __Newvec$224715[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newvec$224715[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	$LN16@Insert_n@7
$LN10@Insert_n@7:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	sar	eax, 4
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@7

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Tmp$224730[ebp]
	call	??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
	mov	DWORD PTR __$EHRec$[ebp+12], 5

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T259293[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T259283[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T259286[ebp], dl
	mov	al, BYTE PTR __Cat$259290[ebp]
	mov	BYTE PTR $T259287[ebp], al
	movzx	ecx, BYTE PTR $T259286[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T259287[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T259283[ebp]
	push	ecx
	mov	edx, DWORD PTR $T259293[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
	add	esp, 24					; 00000018H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 6

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 4
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	mov	DWORD PTR $T259320[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T259319[ebp], edx
	mov	eax, DWORD PTR $T259319[ebp]
	mov	DWORD PTR $T259309[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T259312[ebp], cl
	mov	dl, BYTE PTR __Cat$259316[ebp]
	mov	BYTE PTR $T259313[ebp], dl
	movzx	eax, BYTE PTR $T259312[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T259313[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	lea	eax, DWORD PTR __Tmp$224730[ebp]
	push	eax
	mov	ecx, DWORD PTR $T259320[ebp]
	push	ecx
	mov	edx, DWORD PTR $T259309[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,unsigned int,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
	add	esp, 24					; 00000018H
	jmp	$LN21@Insert_n@7
__catch$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR $T259695[ebp], eax
	mov	edx, DWORD PTR $T259695[ebp]
	mov	DWORD PTR $T259668[ebp], edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T259667[ebp], eax
	mov	cl, BYTE PTR __Cat$259675[ebp]
	mov	BYTE PTR $T259672[ebp], cl
	mov	edx, DWORD PTR $T259668[ebp]
	mov	DWORD PTR $T259642[ebp], edx
	mov	eax, DWORD PTR $T259667[ebp]
	mov	DWORD PTR $T259641[ebp], eax
	jmp	SHORT $LN223@Insert_n@7
$LN222@Insert_n@7:
	mov	ecx, DWORD PTR $T259641[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR $T259641[ebp], ecx
$LN223@Insert_n@7:
	mov	edx, DWORD PTR $T259641[ebp]
	cmp	edx, DWORD PTR $T259642[ebp]
	je	SHORT $LN215@Insert_n@7
	mov	BYTE PTR __$EHRec$[ebp+12], 8
	mov	ecx, DWORD PTR $T259641[ebp]
	call	?_Tidy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+12], 7
	xor	eax, eax
	and	eax, 1
	je	SHORT $LN226@Insert_n@7
	mov	ecx, DWORD PTR $T259641[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN226@Insert_n@7:
	jmp	SHORT $LN222@Insert_n@7
$LN215@Insert_n@7:

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 5
	mov	eax, __tryend$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z$3
	ret	0
$LN21@Insert_n@7:
	mov	DWORD PTR __$EHRec$[ebp+12], 5
__tryend$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, edx
	mov	DWORD PTR $T259711[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T259703[ebp], edx
	jmp	SHORT $LN288@Insert_n@7
$LN287@Insert_n@7:
	mov	eax, DWORD PTR $T259703[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR $T259703[ebp], eax
$LN288@Insert_n@7:
	mov	ecx, DWORD PTR $T259703[ebp]
	cmp	ecx, DWORD PTR $T259711[ebp]
	je	SHORT $LN284@Insert_n@7
	lea	edx, DWORD PTR __Tmp$224730[ebp]
	push	edx
	mov	ecx, DWORD PTR $T259703[ebp]
	call	??4?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV01@ABV01@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator=
	jmp	SHORT $LN287@Insert_n@7
$LN284@Insert_n@7:

; 1232 : 			}

	mov	DWORD PTR __$EHRec$[ebp+12], 9
	lea	ecx, DWORD PTR __Tmp$224730[ebp]
	call	?_Tidy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1233 : 		else

	jmp	$LN16@Insert_n@7
$LN3@Insert_n@7:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$224740[ebp]
	call	??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
	mov	DWORD PTR __$EHRec$[ebp+12], 10		; 0000000aH

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Oldend$224741[ebp], edx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T259995[ebp], ecx
	mov	edx, DWORD PTR $T259995[ebp]
	mov	DWORD PTR $T259985[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T259990[ebp], al
	mov	cl, BYTE PTR __Cat$259993[ebp]
	mov	BYTE PTR $T259991[ebp], cl
	movzx	edx, BYTE PTR $T259990[ebp]
	push	edx
	movzx	eax, BYTE PTR $T259991[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T259985[ebp]
	push	edx
	mov	eax, DWORD PTR __Oldend$224741[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR __Oldend$224741[ebp]
	sub	edx, ecx
	push	edx
	call	??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$224741[ebp]
	mov	DWORD PTR $T260050[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T260049[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T260032[ebp], cl
	mov	dl, BYTE PTR __Cat$260036[ebp]
	mov	BYTE PTR $T260033[ebp], dl
	mov	al, BYTE PTR $T260032[ebp]
	mov	BYTE PTR $T260029[ebp], al
	mov	cl, BYTE PTR $T260034[ebp]
	mov	BYTE PTR $T260028[ebp], cl
	mov	edx, DWORD PTR $T260050[ebp]
	mov	DWORD PTR $T260027[ebp], edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR __Oldend$224741[ebp]
	sub	ecx, eax
	mov	DWORD PTR $T260026[ebp], ecx
	mov	edx, DWORD PTR $T260049[ebp]
	mov	DWORD PTR $T260025[ebp], edx
$LN355@Insert_n@7:
	mov	eax, DWORD PTR $T260025[ebp]
	cmp	eax, DWORD PTR $T260026[ebp]
	je	SHORT $LN348@Insert_n@7
	mov	ecx, DWORD PTR $T260026[ebp]
	sub	ecx, 16					; 00000010H
	mov	DWORD PTR $T260026[ebp], ecx
	mov	edx, DWORD PTR $T260027[ebp]
	sub	edx, 16					; 00000010H
	mov	DWORD PTR $T260027[ebp], edx
	mov	eax, DWORD PTR $T260026[ebp]
	push	eax
	mov	ecx, DWORD PTR $T260027[ebp]
	call	?swap@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXAAV12@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::swap
	jmp	SHORT $LN355@Insert_n@7
$LN348@Insert_n@7:

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T260058[ebp], ecx
	jmp	SHORT $LN366@Insert_n@7
$LN365@Insert_n@7:
	mov	edx, DWORD PTR $T260058[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR $T260058[ebp], edx
$LN366@Insert_n@7:
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR __Where$[ebp]
	cmp	DWORD PTR $T260058[ebp], eax
	je	SHORT $LN362@Insert_n@7
	lea	ecx, DWORD PTR __Tmp$224740[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T260058[ebp]
	call	??4?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV01@ABV01@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator=
	jmp	SHORT $LN365@Insert_n@7
$LN362@Insert_n@7:

; 1249 : 			}

	mov	DWORD PTR __$EHRec$[ebp+12], 11		; 0000000bH
	lea	ecx, DWORD PTR __Tmp$224740[ebp]
	call	?_Tidy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN16@Insert_n@7:

; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z$7:
	mov	ecx, DWORD PTR $T258694[ebp]
	jmp	??1?$_Vector_val@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ
__unwindfunclet$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z$9:
	mov	ecx, DWORD PTR $T258827[ebp]
	jmp	??1?$_Vector_val@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ
__unwindfunclet$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z$11:
	mov	ecx, DWORD PTR $T259207[ebp]
	jmp	??1?$_Vector_val@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ
__unwindfunclet$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z$4:
	lea	ecx, DWORD PTR __Tmp$224730[ebp]
	jmp	??1?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::~vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
__unwindfunclet$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z$19:
	mov	ecx, DWORD PTR $T259641[ebp]
	jmp	??1?$_Vector_val@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ
__unwindfunclet$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z$27:
	lea	ecx, DWORD PTR __Tmp$224730[ebp]
	jmp	??1?$_Vector_val@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ
__unwindfunclet$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z$5:
	lea	ecx, DWORD PTR __Tmp$224740[ebp]
	jmp	??1?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::~vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
__unwindfunclet$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z$35:
	lea	ecx, DWORD PTR __Tmp$224740[ebp]
	jmp	??1?$_Vector_val@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ
__ehhandler$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-524]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@IABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z ENDP ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Insert_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@KAXXZ
_TEXT	SEGMENT
$T260338 = -80						; size = 28
$T260337 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@KAXXZ PROC ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T260338[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T260337[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T260337[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T260338[ebp]
	push	eax
	lea	ecx, DWORD PTR $T260337[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T260337[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T260337[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T260338[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@7:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T260338[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T260337[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@KAXXZ ENDP ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::_Xlen
PUBLIC	?swap@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXAAV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::swap
PUBLIC	??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >
PUBLIC	??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z$46 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z$2
__catchsym$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z$45 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z$0
__ehfuncinfo$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z DD 019930522H
	DD	0cH
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z DD 00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z$45
	DD	06H
	DD	06H
	DD	08H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z$46
__unwindtable$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z$8
	DD	01H
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z$14
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z$20
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z$4
	DD	05H
	DD	00H
	DD	05H
	DD	00H
	DD	07H
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z$27
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z$33
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z$40
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z
_TEXT	SEGMENT
tv84 = -536						; size = 4
tv312 = -532						; size = 4
tv298 = -528						; size = 4
tv290 = -524						; size = 4
_this$ = -520						; size = 4
$T261869 = -432						; size = 4
$T261686 = -352						; size = 4
$T261685 = -348						; size = 4
$T261665 = -342						; size = 1
$T261664 = -341						; size = 1
$T261663 = -340						; size = 4
$T261662 = -336						; size = 4
$T261661 = -332						; size = 4
__Cat$261672 = -324					; size = 1
$T261669 = -323						; size = 1
$T261668 = -322						; size = 1
$T261667 = -321						; size = 1
$T261631 = -320						; size = 4
$T261621 = -316						; size = 4
__Cat$261628 = -311					; size = 1
$T261625 = -310						; size = 1
$T261624 = -309						; size = 1
$T261532 = -308						; size = 4
$T261522 = -304						; size = 4
$T261509 = -300						; size = 4
$T261474 = -296						; size = 4
$T261473 = -292						; size = 4
$T261440 = -288						; size = 4
$T261439 = -284						; size = 4
__Cat$261480 = -278					; size = 1
$T261477 = -277						; size = 1
$T261275 = -276						; size = 4
$T261274 = -272						; size = 4
$T261264 = -268						; size = 4
__Cat$261271 = -263					; size = 1
$T261268 = -262						; size = 1
$T261267 = -261						; size = 1
$T261248 = -260						; size = 4
$T261238 = -256						; size = 4
__Cat$261245 = -251					; size = 1
$T261242 = -250						; size = 1
$T261241 = -249						; size = 1
$T261218 = -248						; size = 4
$T261217 = -244						; size = 4
$T261213 = -240						; size = 4
$T261212 = -236						; size = 4
$T261177 = -232						; size = 4
$T261176 = -228						; size = 4
$T261143 = -224						; size = 4
$T261142 = -220						; size = 4
__Cat$261203 = -214					; size = 1
$T261201 = -213						; size = 1
$T260938 = -212						; size = 4
$T260937 = -208						; size = 4
$T260904 = -204						; size = 4
$T260903 = -200						; size = 4
__Cat$260944 = -194					; size = 1
$T260942 = -193						; size = 1
$T260705 = -192						; size = 4
$T260704 = -188						; size = 4
$T260671 = -184						; size = 4
$T260670 = -180						; size = 4
__Cat$260711 = -174					; size = 1
$T260709 = -173						; size = 1
$T260506 = -172						; size = 4
$T260496 = -168						; size = 4
__Cat$260503 = -163					; size = 1
$T260500 = -162						; size = 1
$T260499 = -161						; size = 1
$T260480 = -160						; size = 4
$T260470 = -156						; size = 4
__Cat$260477 = -151					; size = 1
$T260474 = -150						; size = 1
$T260473 = -149						; size = 1
$T260454 = -148						; size = 4
$T260444 = -144						; size = 4
__Cat$260450 = -139					; size = 1
$T260448 = -138						; size = 1
$T260447 = -137						; size = 1
__Count$260418 = -136					; size = 4
__Count$260392 = -64					; size = 4
__Tmp$224805 = -60					; size = 12
__Oldend$224806 = -48					; size = 4
__Tmp$224795 = -44					; size = 12
__Ncopied$224782 = -32					; size = 4
__Newvec$224780 = -28					; size = 4
__Whereoff$224781 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z PROC ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 520				; 00000208H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN31@Insert_n@8
	mov	DWORD PTR tv290[ebp], 0
	jmp	SHORT $LN29@Insert_n@8
$LN31@Insert_n@8:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR tv290[ebp], eax
$LN29@Insert_n@8:
	mov	edx, DWORD PTR tv290[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@8
	jmp	$LN16@Insert_n@8
$LN14@Insert_n@8:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$260392[ebp], 357913941 ; 15555555H
	cmp	DWORD PTR __Count$260392[ebp], 0
	jbe	SHORT $LN37@Insert_n@8
	mov	eax, DWORD PTR __Count$260392[ebp]
	mov	DWORD PTR tv298[ebp], eax
	jmp	SHORT $LN39@Insert_n@8
$LN37@Insert_n@8:
	mov	DWORD PTR tv298[ebp], 1
$LN39@Insert_n@8:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	edx, DWORD PTR tv298[ebp]
	sub	edx, eax
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	SHORT $LN44@Insert_n@8

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@KAXXZ ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Xlen
	jmp	$LN16@Insert_n@8

; 1167 : 		else if (_Capacity < size() + _Count)

$LN44@Insert_n@8:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@8

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$260418[ebp], 357913941 ; 15555555H
	cmp	DWORD PTR __Count$260418[ebp], 0
	jbe	SHORT $LN50@Insert_n@8
	mov	edx, DWORD PTR __Count$260418[ebp]
	mov	DWORD PTR tv312[ebp], edx
	jmp	SHORT $LN46@Insert_n@8
$LN50@Insert_n@8:
	mov	DWORD PTR tv312[ebp], 1
$LN46@Insert_n@8:
	mov	eax, DWORD PTR __Capacity$[ebp]
	shr	eax, 1
	mov	ecx, DWORD PTR tv312[ebp]
	sub	ecx, eax
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@8
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@8
$LN17@Insert_n@8:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n@8:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN56@Insert_n@8

; 1172 : 				_Capacity = size() + _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN56@Insert_n@8:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IPAV10@@Z ; std::_Allocate<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >
	add	esp, 8
	mov	DWORD PTR __Newvec$224780[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR __Whereoff$224781[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$224782[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	edx, DWORD PTR __Whereoff$224781[ebp]
	imul	edx, 12					; 0000000cH
	add	edx, DWORD PTR __Newvec$224780[ebp]
	mov	DWORD PTR $T260454[ebp], edx
	mov	eax, DWORD PTR $T260454[ebp]
	mov	DWORD PTR $T260444[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T260447[ebp], cl
	mov	dl, BYTE PTR __Cat$260450[ebp]
	mov	BYTE PTR $T260448[ebp], dl
	movzx	eax, BYTE PTR $T260447[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T260448[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T260444[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IABV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,unsigned int,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
	add	esp, 24					; 00000018H

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$224782[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$224782[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T260480[ebp], edx
	mov	eax, DWORD PTR __Newvec$224780[ebp]
	mov	DWORD PTR $T260470[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T260473[ebp], cl
	mov	dl, BYTE PTR __Cat$260477[ebp]
	mov	BYTE PTR $T260474[ebp], dl
	movzx	eax, BYTE PTR $T260473[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T260474[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T260470[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T260480[ebp]
	push	edx
	call	??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
	add	esp, 24					; 00000018H

; 1182 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$224782[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$224782[ebp], eax

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T260506[ebp], edx
	mov	eax, DWORD PTR __Whereoff$224781[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	imul	eax, 12					; 0000000cH
	add	eax, DWORD PTR __Newvec$224780[ebp]
	mov	DWORD PTR $T260496[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T260499[ebp], cl
	mov	dl, BYTE PTR __Cat$260503[ebp]
	mov	BYTE PTR $T260500[ebp], dl
	movzx	eax, BYTE PTR $T260499[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T260500[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T260496[ebp]
	push	eax
	mov	ecx, DWORD PTR $T260506[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	call	??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
	add	esp, 24					; 00000018H
	jmp	$LN19@Insert_n@8
__catch$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$224782[ebp], 1
	jle	$LN7@Insert_n@8

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	eax, DWORD PTR __Whereoff$224781[ebp]
	imul	eax, 12					; 0000000cH
	add	eax, DWORD PTR __Newvec$224780[ebp]
	mov	DWORD PTR $T260705[ebp], eax
	mov	ecx, DWORD PTR __Newvec$224780[ebp]
	mov	DWORD PTR $T260704[ebp], ecx
	mov	dl, BYTE PTR __Cat$260711[ebp]
	mov	BYTE PTR $T260709[ebp], dl
	mov	eax, DWORD PTR $T260705[ebp]
	mov	DWORD PTR $T260671[ebp], eax
	mov	ecx, DWORD PTR $T260704[ebp]
	mov	DWORD PTR $T260670[ebp], ecx
	jmp	SHORT $LN84@Insert_n@8
$LN83@Insert_n@8:
	mov	edx, DWORD PTR $T260670[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR $T260670[ebp], edx
$LN84@Insert_n@8:
	mov	eax, DWORD PTR $T260670[ebp]
	cmp	eax, DWORD PTR $T260671[ebp]
	je	SHORT $LN7@Insert_n@8
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR $T260670[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	xor	ecx, ecx
	and	ecx, 1
	je	SHORT $LN87@Insert_n@8
	mov	edx, DWORD PTR $T260670[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN87@Insert_n@8:
	jmp	SHORT $LN83@Insert_n@8
$LN7@Insert_n@8:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$224782[ebp], 0
	jle	$LN6@Insert_n@8

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR __Whereoff$224781[ebp]
	imul	ecx, 12					; 0000000cH
	add	ecx, DWORD PTR __Newvec$224780[ebp]
	add	ecx, eax
	mov	DWORD PTR $T260938[ebp], ecx
	mov	edx, DWORD PTR __Whereoff$224781[ebp]
	imul	edx, 12					; 0000000cH
	add	edx, DWORD PTR __Newvec$224780[ebp]
	mov	DWORD PTR $T260937[ebp], edx
	mov	al, BYTE PTR __Cat$260944[ebp]
	mov	BYTE PTR $T260942[ebp], al
	mov	ecx, DWORD PTR $T260938[ebp]
	mov	DWORD PTR $T260904[ebp], ecx
	mov	edx, DWORD PTR $T260937[ebp]
	mov	DWORD PTR $T260903[ebp], edx
	jmp	SHORT $LN122@Insert_n@8
$LN121@Insert_n@8:
	mov	eax, DWORD PTR $T260903[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T260903[ebp], eax
$LN122@Insert_n@8:
	mov	ecx, DWORD PTR $T260903[ebp]
	cmp	ecx, DWORD PTR $T260904[ebp]
	je	SHORT $LN6@Insert_n@8
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR $T260903[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	xor	edx, edx
	and	edx, 1
	je	SHORT $LN125@Insert_n@8
	mov	eax, DWORD PTR $T260903[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN125@Insert_n@8:
	jmp	SHORT $LN121@Insert_n@8
$LN6@Insert_n@8:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	ecx, DWORD PTR __Newvec$224780[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN154@Insert_n@8
	ret	0
$LN19@Insert_n@8:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN154@Insert_n@8:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN5@Insert_n@8

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T261213[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T261212[ebp], eax
	mov	ecx, DWORD PTR $T261213[ebp]
	mov	DWORD PTR $T261177[ebp], ecx
	mov	edx, DWORD PTR $T261212[ebp]
	mov	DWORD PTR $T261176[ebp], edx
	mov	al, BYTE PTR __Cat$261203[ebp]
	mov	BYTE PTR $T261201[ebp], al
	mov	ecx, DWORD PTR $T261177[ebp]
	mov	DWORD PTR $T261143[ebp], ecx
	mov	edx, DWORD PTR $T261176[ebp]
	mov	DWORD PTR $T261142[ebp], edx
	jmp	SHORT $LN164@Insert_n@8
$LN163@Insert_n@8:
	mov	eax, DWORD PTR $T261142[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T261142[ebp], eax
$LN164@Insert_n@8:
	mov	ecx, DWORD PTR $T261142[ebp]
	cmp	ecx, DWORD PTR $T261143[ebp]
	je	SHORT $LN156@Insert_n@8
	mov	DWORD PTR __$EHRec$[ebp+12], 4
	mov	ecx, DWORD PTR $T261142[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	xor	edx, edx
	and	edx, 1
	je	SHORT $LN167@Insert_n@8
	mov	eax, DWORD PTR $T261142[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN167@Insert_n@8:
	jmp	SHORT $LN163@Insert_n@8
$LN156@Insert_n@8:

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR $T261218[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T261217[ebp], eax
	mov	ecx, DWORD PTR $T261217[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n@8:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	imul	edx, 12					; 0000000cH
	add	edx, DWORD PTR __Newvec$224780[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 12					; 0000000cH
	add	ecx, DWORD PTR __Newvec$224780[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newvec$224780[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	$LN16@Insert_n@8
$LN10@Insert_n@8:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@8

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Tmp$224795[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+12], 5

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T261248[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 12					; 0000000cH
	add	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T261238[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T261241[ebp], al
	mov	cl, BYTE PTR __Cat$261245[ebp]
	mov	BYTE PTR $T261242[ebp], cl
	movzx	edx, BYTE PTR $T261241[ebp]
	push	edx
	movzx	eax, BYTE PTR $T261242[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T261238[ebp]
	push	edx
	mov	eax, DWORD PTR $T261248[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	call	??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
	add	esp, 24					; 00000018H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 6

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, eax
	mov	DWORD PTR $T261275[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T261274[ebp], ecx
	mov	edx, DWORD PTR $T261274[ebp]
	mov	DWORD PTR $T261264[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T261267[ebp], al
	mov	cl, BYTE PTR __Cat$261271[ebp]
	mov	BYTE PTR $T261268[ebp], cl
	movzx	edx, BYTE PTR $T261267[ebp]
	push	edx
	movzx	eax, BYTE PTR $T261268[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Tmp$224795[ebp]
	push	edx
	mov	eax, DWORD PTR $T261275[ebp]
	push	eax
	mov	ecx, DWORD PTR $T261264[ebp]
	push	ecx
	call	??$_Uninit_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IABV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,unsigned int,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
	add	esp, 24					; 00000018H
	jmp	$LN21@Insert_n@8
__catch$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+8]
	mov	DWORD PTR $T261509[ebp], edx
	mov	ecx, DWORD PTR $T261509[ebp]
	mov	DWORD PTR $T261474[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 12					; 0000000cH
	add	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T261473[ebp], edx
	mov	al, BYTE PTR __Cat$261480[ebp]
	mov	BYTE PTR $T261477[ebp], al
	mov	ecx, DWORD PTR $T261474[ebp]
	mov	DWORD PTR $T261440[ebp], ecx
	mov	edx, DWORD PTR $T261473[ebp]
	mov	DWORD PTR $T261439[ebp], edx
	jmp	SHORT $LN219@Insert_n@8
$LN218@Insert_n@8:
	mov	eax, DWORD PTR $T261439[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T261439[ebp], eax
$LN219@Insert_n@8:
	mov	ecx, DWORD PTR $T261439[ebp]
	cmp	ecx, DWORD PTR $T261440[ebp]
	je	SHORT $LN211@Insert_n@8
	mov	BYTE PTR __$EHRec$[ebp+12], 8
	mov	ecx, DWORD PTR $T261439[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+12], 7
	xor	edx, edx
	and	edx, 1
	je	SHORT $LN222@Insert_n@8
	mov	eax, DWORD PTR $T261439[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN222@Insert_n@8:
	jmp	SHORT $LN218@Insert_n@8
$LN211@Insert_n@8:

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 5
	mov	eax, __tryend$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z$3
	ret	0
$LN21@Insert_n@8:
	mov	DWORD PTR __$EHRec$[ebp+12], 5
__tryend$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, ecx
	mov	DWORD PTR $T261532[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T261522[ebp], ecx
	jmp	SHORT $LN253@Insert_n@8
$LN252@Insert_n@8:
	mov	edx, DWORD PTR $T261522[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR $T261522[ebp], edx
$LN253@Insert_n@8:
	mov	eax, DWORD PTR $T261522[ebp]
	cmp	eax, DWORD PTR $T261532[ebp]
	je	SHORT $LN249@Insert_n@8
	lea	ecx, DWORD PTR __Tmp$224795[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T261522[ebp]
	call	??4?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::operator=
	jmp	SHORT $LN252@Insert_n@8
$LN249@Insert_n@8:

; 1232 : 			}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	DWORD PTR __$EHRec$[ebp+12], 9
	lea	ecx, DWORD PTR __Tmp$224795[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1233 : 		else

	jmp	$LN16@Insert_n@8
$LN3@Insert_n@8:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Tmp$224805[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+12], 10		; 0000000aH

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Oldend$224806[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T261631[ebp], eax
	mov	ecx, DWORD PTR $T261631[ebp]
	mov	DWORD PTR $T261621[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T261624[ebp], dl
	mov	al, BYTE PTR __Cat$261628[ebp]
	mov	BYTE PTR $T261625[ebp], al
	movzx	ecx, BYTE PTR $T261624[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T261625[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T261621[ebp]
	push	ecx
	mov	edx, DWORD PTR __Oldend$224806[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR __Oldend$224806[ebp]
	sub	ecx, eax
	push	ecx
	call	??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, DWORD PTR __Oldend$224806[ebp]
	mov	DWORD PTR $T261686[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T261685[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T261667[ebp], dl
	mov	al, BYTE PTR __Cat$261672[ebp]
	mov	BYTE PTR $T261668[ebp], al
	mov	cl, BYTE PTR $T261667[ebp]
	mov	BYTE PTR $T261665[ebp], cl
	mov	dl, BYTE PTR $T261669[ebp]
	mov	BYTE PTR $T261664[ebp], dl
	mov	eax, DWORD PTR $T261686[ebp]
	mov	DWORD PTR $T261663[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR __Oldend$224806[ebp]
	sub	edx, ecx
	mov	DWORD PTR $T261662[ebp], edx
	mov	eax, DWORD PTR $T261685[ebp]
	mov	DWORD PTR $T261661[ebp], eax
$LN294@Insert_n@8:
	mov	ecx, DWORD PTR $T261661[ebp]
	cmp	ecx, DWORD PTR $T261662[ebp]
	je	SHORT $LN287@Insert_n@8
	mov	edx, DWORD PTR $T261662[ebp]
	sub	edx, 12					; 0000000cH
	mov	DWORD PTR $T261662[ebp], edx
	mov	eax, DWORD PTR $T261663[ebp]
	sub	eax, 12					; 0000000cH
	mov	DWORD PTR $T261663[ebp], eax
	mov	ecx, DWORD PTR $T261662[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T261663[ebp]
	call	?swap@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXAAV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::swap
	jmp	SHORT $LN294@Insert_n@8
$LN287@Insert_n@8:

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T261869[ebp], edx
	jmp	SHORT $LN305@Insert_n@8
$LN304@Insert_n@8:
	mov	eax, DWORD PTR $T261869[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T261869[ebp], eax
$LN305@Insert_n@8:
	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 12					; 0000000cH
	add	ecx, DWORD PTR __Where$[ebp]
	cmp	DWORD PTR $T261869[ebp], ecx
	je	SHORT $LN301@Insert_n@8
	lea	edx, DWORD PTR __Tmp$224805[ebp]
	push	edx
	mov	ecx, DWORD PTR $T261869[ebp]
	call	??4?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::operator=
	jmp	SHORT $LN304@Insert_n@8
$LN301@Insert_n@8:

; 1249 : 			}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	DWORD PTR __$EHRec$[ebp+12], 11		; 0000000bH
	lea	ecx, DWORD PTR __Tmp$224805[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN16@Insert_n@8:

; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z$8:
	mov	ecx, DWORD PTR $T260670[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__unwindfunclet$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z$14:
	mov	ecx, DWORD PTR $T260903[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__unwindfunclet$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z$20:
	mov	ecx, DWORD PTR $T261142[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__unwindfunclet$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z$4:
	lea	ecx, DWORD PTR __Tmp$224795[ebp]
	jmp	??1?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAE@XZ
__unwindfunclet$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z$27:
	mov	ecx, DWORD PTR $T261439[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__unwindfunclet$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z$33:
	lea	ecx, DWORD PTR __Tmp$224795[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__unwindfunclet$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z$5:
	lea	ecx, DWORD PTR __Tmp$224805[ebp]
	jmp	??1?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAE@XZ
__unwindfunclet$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z$40:
	lea	ecx, DWORD PTR __Tmp$224805[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__ehhandler$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-540]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@IABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z ENDP ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::_Insert_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ
_TEXT	SEGMENT
$T262170 = -80						; size = 28
$T262169 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ PROC ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T262170[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T262169[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T262169[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T262170[ebp]
	push	eax
	lea	ecx, DWORD PTR $T262169[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T262169[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T262169[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T262170[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@8:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T262170[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T262169[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ ENDP ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Xlen
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHH@2@@Z
_TEXT	SEGMENT
tv90 = -156						; size = 4
_this$ = -152						; size = 4
$T262323 = -148						; size = 4
$T262303 = -144						; size = 4
$T262288 = -140						; size = 4
$T262271 = -136						; size = 4
$T262258 = -132						; size = 4
$T262244 = -128						; size = 4
$T262200 = -45						; size = 1
$T262199 = -44						; size = 4
$T262198 = -37						; size = 1
$T262197 = -36						; size = 4
$T262196 = -29						; size = 1
$T262195 = -28						; size = 4
$T262194 = -24						; size = 4
$T262193 = -17						; size = 1
__Where$224902 = -16					; size = 4
__Trynode$ = -12					; size = 4
__Wherenode$ = -8					; size = 4
__Addleft$ = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHH@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::insert, COMDAT
; _this$ = ecx

; 630  : 		{	// try to insert node with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	mov	DWORD PTR _this$[ebp], ecx

; 631  : 		_Nodeptr _Trynode = _Root();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Trynode$[ebp], edx

; 632  : 		_Nodeptr _Wherenode = _Myhead;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 633  : 		bool _Addleft = true;	// add to left of head if tree empty

	mov	BYTE PTR __Addleft$[ebp], 1

; 634  : 		while (!_Isnil(_Trynode))

$LN19@insert@13:
	mov	edx, DWORD PTR __Trynode$[ebp]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	SHORT $LN9@insert@13

; 635  : 			{	// look for leaf to insert before (_Addleft) or after
; 636  : 			_Wherenode = _Trynode;

	mov	ecx, DWORD PTR __Trynode$[ebp]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 637  : 			_Addleft = _DEBUG_LT_PRED(this->comp,

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR __Trynode$[ebp]
	mov	ecx, DWORD PTR [edx]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+12]
	setl	dl
	mov	BYTE PTR __Addleft$[ebp], dl

; 638  : 				this->_Kfn(_Val), _Key(_Trynode));
; 639  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

	movzx	eax, BYTE PTR __Addleft$[ebp]
	test	eax, eax
	je	SHORT $LN33@insert@13
	mov	ecx, DWORD PTR __Trynode$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv90[ebp], edx
	jmp	SHORT $LN14@insert@13
$LN33@insert@13:
	mov	eax, DWORD PTR __Trynode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv90[ebp], ecx
$LN14@insert@13:
	mov	edx, DWORD PTR tv90[ebp]
	mov	DWORD PTR __Trynode$[ebp], edx

; 640  : 			}

	jmp	SHORT $LN19@insert@13
$LN9@insert@13:

; 641  : 
; 642  : 		if (this->_Multi)

	xor	eax, eax
	je	SHORT $LN8@insert@13

; 643  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	BYTE PTR $T262193[ebp], 1
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	movzx	eax, BYTE PTR __Addleft$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T262194[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	mov	DWORD PTR $T262244[ebp], eax
	mov	edx, DWORD PTR $T262244[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	al, BYTE PTR $T262193[ebp]
	mov	BYTE PTR [edx+4], al
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN11@insert@13

; 644  : 		else

	jmp	$LN11@insert@13
$LN8@insert@13:

; 645  : 			{	// insert only if unique
; 646  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR __Where$224902[ebp], ecx

; 647  : 			if (!_Addleft)

	movzx	edx, BYTE PTR __Addleft$[ebp]
	test	edx, edx
	jne	SHORT $LN6@insert@13
	jmp	$LN79@insert@13
$LN6@insert@13:

; 648  : 				;	// need to test if insert after is okay
; 649  : 			else if (_Where == begin())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T262258[ebp], ecx
	mov	edx, DWORD PTR $T262258[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T262271[ebp], eax
	mov	ecx, DWORD PTR $T262271[ebp]
	mov	DWORD PTR $T262195[ebp], ecx
	mov	edx, DWORD PTR __Where$224902[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T262195[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@insert@13

; 650  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

	mov	BYTE PTR $T262196[ebp], 1
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	push	1
	lea	ecx, DWORD PTR $T262197[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	mov	DWORD PTR $T262288[ebp], eax
	mov	edx, DWORD PTR $T262288[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	al, BYTE PTR $T262196[ebp]
	mov	BYTE PTR [edx+4], al
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN11@insert@13

; 651  : 			else

	jmp	SHORT $LN79@insert@13
$LN4@insert@13:

; 652  : 				--_Where;	// need to test if insert before is okay

	lea	ecx, DWORD PTR __Where$224902[ebp]
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Dec

; 653  : 
; 654  : 			if (_DEBUG_LT_PRED(this->comp,

$LN79@insert@13:
	mov	ecx, DWORD PTR __Where$224902[ebp]
	mov	DWORD PTR $T262303[ebp], ecx
	mov	edx, DWORD PTR $T262303[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax]
	setl	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN2@insert@13

; 655  : 				_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 656  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	BYTE PTR $T262198[ebp], 1
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	movzx	eax, BYTE PTR __Addleft$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T262199[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	mov	DWORD PTR $T262323[ebp], eax
	mov	edx, DWORD PTR $T262323[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	al, BYTE PTR $T262198[ebp]
	mov	BYTE PTR [edx+4], al
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN11@insert@13

; 657  : 			else

	jmp	SHORT $LN11@insert@13
$LN2@insert@13:

; 658  : 				return (_Pairib(_Where, false));

	mov	BYTE PTR $T262200[ebp], 0
	mov	ecx, DWORD PTR __Where$224902[ebp]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	cl, BYTE PTR $T262200[ebp]
	mov	BYTE PTR [eax+4], cl
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN11@insert@13:

; 659  : 			}
; 660  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHH@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::insert
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::clear
; Function compile flags: /Odtp
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z
_TEXT	SEGMENT
_this$ = -76						; size = 4
$T262547 = -72						; size = 4
$T262542 = -68						; size = 4
__Tmp$262529 = -48					; size = 4
$T262457 = -44						; size = 4
$T262444 = -40						; size = 4
$T262374 = -28						; size = 4
$T262351 = -24						; size = 4
$T262338 = -20						; size = 4
$T262332 = -16						; size = 4
$T262331 = -12						; size = 4
$T262330 = -8						; size = 4
$T262329 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase, COMDAT
; _this$ = ecx

; 934  : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	DWORD PTR _this$[ebp], ecx

; 935  : 		if (_First == begin() && _Last == end())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T262338[ebp], ecx
	mov	edx, DWORD PTR $T262338[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T262351[ebp], eax
	mov	ecx, DWORD PTR $T262351[ebp]
	mov	DWORD PTR $T262329[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T262329[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN72@erase@10
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T262374[ebp], eax
	mov	ecx, DWORD PTR $T262374[ebp]
	mov	DWORD PTR $T262330[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T262330[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN72@erase@10

; 936  : 			{	// erase all
; 937  : 			clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::clear

; 938  : 			return (begin());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T262444[ebp], eax
	mov	ecx, DWORD PTR $T262444[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T262457[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR $T262457[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN5@erase@10

; 939  : 			}
; 940  : 		else

	jmp	SHORT $LN5@erase@10

; 941  : 			{	// partial erase, one at a time
; 942  : 			while (_First != _Last)

$LN72@erase@10:
	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@erase@10

; 943  : 				erase(_First++);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$262529[ebp], eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Inc
	mov	ecx, DWORD PTR __Tmp$262529[ebp]
	mov	DWORD PTR $T262331[ebp], ecx
	mov	edx, DWORD PTR $T262331[ebp]
	push	edx
	lea	eax, DWORD PTR $T262332[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
	jmp	SHORT $LN72@erase@10
$LN1@erase@10:

; 944  : 			return (_Make_iter(_First));

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T262547[ebp], ecx
	mov	edx, DWORD PTR $T262547[ebp]
	mov	DWORD PTR $T262542[ebp], edx
	mov	eax, DWORD PTR $T262542[ebp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN5@erase@10:

; 945  : 			}
; 946  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode
; Function compile flags: /Odtp
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T262565 = -4						; size = 4
?_Init@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Init, COMDAT
; _this$ = ecx

; 1177 : 		{	// create head/nil node and make tree empty

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1178 : 		_Myhead = _Buynode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1179 : 		_Isnil(_Myhead) = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	BYTE PTR [eax+21], 1

; 1180 : 		_Root() = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 1181 : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T262565[ebp], eax
	mov	ecx, DWORD PTR $T262565[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1182 : 		_Mysize = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 1183 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Init@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Init
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z$0
__ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z
_TEXT	SEGMENT
tv277 = -196						; size = 4
_this$ = -192						; size = 4
$T263114 = -188						; size = 4
$T263026 = -172						; size = 4
$T262941 = -160						; size = 4
$T262925 = -156						; size = 4
$T262906 = -152						; size = 4
$T262902 = -148						; size = 4
$T262817 = -136						; size = 4
$T262716 = -120						; size = 4
$T262694 = -116						; size = 4
$T262687 = -112						; size = 4
$T262683 = -108						; size = 4
$T262644 = -104						; size = 4
$T262635 = -100						; size = 4
$T262615 = -96						; size = 4
__Count$262598 = -92					; size = 4
$T262581 = -88						; size = 28
$T262580 = -60						; size = 40
__Pnode$224949 = -20					; size = 4
__Newnode$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1187 : 		{	// add node with value next to _Wherenode, to left if _Addnode

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 184				; 000000b8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1188 : 		if (max_size() - 1 <= _Mysize)

	mov	DWORD PTR __Count$262598[ebp], 536870911 ; 1fffffffH
	cmp	DWORD PTR __Count$262598[ebp], 0
	jbe	SHORT $LN25@Insert@2
	mov	eax, DWORD PTR __Count$262598[ebp]
	mov	DWORD PTR tv277[ebp], eax
	jmp	SHORT $LN21@Insert@2
$LN25@Insert@2:
	mov	DWORD PTR tv277[ebp], 1
$LN21@Insert@2:
	mov	ecx, DWORD PTR tv277[ebp]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR [edx+8]
	ja	SHORT $LN17@Insert@2

; 1189 : 			_THROW(length_error, "map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T262581[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T262581[ebp]
	push	eax
	lea	ecx, DWORD PTR $T262580[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR $T262580[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T262580[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T262581[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN17@Insert@2:

; 1190 : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1191 : 			_Val, _Red);

	push	0
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode
	mov	DWORD PTR __Newnode$[ebp], eax

; 1192 : 
; 1193 : 		++_Mysize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1194 : 		if (_Wherenode == _Myhead)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Wherenode$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN16@Insert@2

; 1195 : 			{	// first node in tree, just set head values
; 1196 : 			_Root() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1197 : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T262615[ebp], edx
	mov	eax, DWORD PTR $T262615[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN15@Insert@2
$LN16@Insert@2:

; 1198 : 			}
; 1199 : 		else if (_Addleft)

	movzx	edx, BYTE PTR __Addleft$[ebp]
	test	edx, edx
	je	SHORT $LN52@Insert@2

; 1200 : 			{	// add to left of _Wherenode
; 1201 : 			_Left(_Wherenode) = _Newnode;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1202 : 			if (_Wherenode == _Lmost())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T262635[ebp], eax
	mov	ecx, DWORD PTR $T262635[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN13@Insert@2

; 1203 : 				_Lmost() = _Newnode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T262644[ebp], ecx
	mov	edx, DWORD PTR $T262644[ebp]
	mov	eax, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [edx], eax
$LN13@Insert@2:

; 1204 : 			}
; 1205 : 		else

	jmp	SHORT $LN15@Insert@2

; 1206 : 			{	// add to right of _Wherenode
; 1207 : 			_Right(_Wherenode) = _Newnode;

$LN52@Insert@2:
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 1208 : 			if (_Wherenode == _Rmost())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN15@Insert@2

; 1209 : 				_Rmost() = _Newnode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN15@Insert@2:

; 1210 : 			}
; 1211 : 
; 1212 : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

	mov	eax, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR __Pnode$224949[ebp], eax
$LN64@Insert@2:
	mov	ecx, DWORD PTR __Pnode$224949[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movsx	eax, BYTE PTR [edx+20]
	test	eax, eax
	jne	$LN360@Insert@2

; 1213 : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

	mov	ecx, DWORD PTR __Pnode$224949[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T262683[ebp], edx
	mov	eax, DWORD PTR $T262683[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T262687[ebp], ecx
	mov	edx, DWORD PTR __Pnode$224949[ebp]
	mov	eax, DWORD PTR $T262687[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax]
	jne	$LN216@Insert@2

; 1214 : 				{	// fixup red-red in left subtree
; 1215 : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR __Pnode$224949[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 4
	mov	DWORD PTR $T262694[ebp], eax
	mov	ecx, DWORD PTR $T262694[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1216 : 				if (_Color(_Wherenode) == _Red)

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	movsx	edx, BYTE PTR [ecx+20]
	test	edx, edx
	jne	SHORT $LN100@Insert@2

; 1217 : 					{	// parent has two red children, blacken both
; 1218 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$224949[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	BYTE PTR [ecx+20], 1

; 1219 : 					_Color(_Wherenode) = _Black;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [edx+20], 1

; 1220 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	eax, DWORD PTR __Pnode$224949[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T262716[ebp], ecx
	mov	edx, DWORD PTR $T262716[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+20], 0

; 1221 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	ecx, DWORD PTR __Pnode$224949[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$224949[ebp], eax

; 1222 : 					}
; 1223 : 				else

	jmp	SHORT $LN6@Insert@2

; 1224 : 					{	// parent has red and black children
; 1225 : 					if (_Pnode == _Right(_Parent(_Pnode)))

$LN100@Insert@2:
	mov	ecx, DWORD PTR __Pnode$224949[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Pnode$224949[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN155@Insert@2

; 1226 : 						{	// rotate right child to left
; 1227 : 						_Pnode = _Parent(_Pnode);

	mov	ecx, DWORD PTR __Pnode$224949[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Pnode$224949[ebp], edx

; 1228 : 						_Lrotate(_Pnode);

	mov	eax, DWORD PTR __Pnode$224949[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate

; 1229 : 						}
; 1230 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

$LN155@Insert@2:
	mov	ecx, DWORD PTR __Pnode$224949[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+20], 1

; 1231 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	eax, DWORD PTR __Pnode$224949[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T262817[ebp], ecx
	mov	edx, DWORD PTR $T262817[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+20], 0

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

	mov	ecx, DWORD PTR __Pnode$224949[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate
$LN6@Insert@2:

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	$LN4@Insert@2

; 1236 : 				{	// fixup red-red in right subtree
; 1237 : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));

$LN216@Insert@2:
	mov	ecx, DWORD PTR __Pnode$224949[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T262902[ebp], edx
	mov	eax, DWORD PTR $T262902[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T262906[ebp], ecx
	mov	edx, DWORD PTR $T262906[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1238 : 				if (_Color(_Wherenode) == _Red)

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	movsx	edx, BYTE PTR [ecx+20]
	test	edx, edx
	jne	SHORT $LN240@Insert@2

; 1239 : 					{	// parent has two red children, blacken both
; 1240 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$224949[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	BYTE PTR [ecx+20], 1

; 1241 : 					_Color(_Wherenode) = _Black;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [edx+20], 1

; 1242 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	eax, DWORD PTR __Pnode$224949[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T262925[ebp], ecx
	mov	edx, DWORD PTR $T262925[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+20], 0

; 1243 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	ecx, DWORD PTR __Pnode$224949[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$224949[ebp], eax

; 1244 : 					}
; 1245 : 				else

	jmp	SHORT $LN4@Insert@2

; 1246 : 					{	// parent has red and black children
; 1247 : 					if (_Pnode == _Left(_Parent(_Pnode)))

$LN240@Insert@2:
	mov	ecx, DWORD PTR __Pnode$224949[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T262941[ebp], edx
	mov	eax, DWORD PTR $T262941[ebp]
	mov	ecx, DWORD PTR __Pnode$224949[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN297@Insert@2

; 1248 : 						{	// rotate left child to right
; 1249 : 						_Pnode = _Parent(_Pnode);

	mov	edx, DWORD PTR __Pnode$224949[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$224949[ebp], eax

; 1250 : 						_Rrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$224949[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate

; 1251 : 						}
; 1252 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

$LN297@Insert@2:
	mov	edx, DWORD PTR __Pnode$224949[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	BYTE PTR [eax+20], 1

; 1253 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR __Pnode$224949[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T263026[ebp], edx
	mov	eax, DWORD PTR $T263026[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	BYTE PTR [ecx+20], 0

; 1254 : 					_Lrotate(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR __Pnode$224949[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate
$LN4@Insert@2:

; 1255 : 					}
; 1256 : 				}

	jmp	$LN64@Insert@2

; 1257 : 
; 1258 : 		_Color(_Root()) = _Black;	// root is always black

$LN360@Insert@2:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 4
	mov	DWORD PTR $T263114[ebp], eax
	mov	ecx, DWORD PTR $T263114[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	BYTE PTR [edx+20], 1

; 1259 : 		return (_TREE_ITERATOR(_Newnode));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN19@Insert@2:

; 1260 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z$0:
	lea	ecx, DWORD PTR $T262581[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-188]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
; Function compile flags: /Odtp
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Pnode$ = -8						; size = 4
__Wherenode$ = -4					; size = 4
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 1263 : 		{	// find leftmost node not less than _Keyval

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1264 : 		_Nodeptr _Pnode = _Root();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Pnode$[ebp], edx

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

$LN11@Lbound@2:
	mov	edx, DWORD PTR __Pnode$[ebp]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	SHORT $LN3@Lbound@2

; 1268 : 			if (_DEBUG_LT_PRED(this->comp, _Key(_Pnode), _Keyval))

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Keyval$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setl	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@Lbound@2

; 1269 : 				_Pnode = _Right(_Pnode);	// descend right subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1270 : 			else

	jmp	SHORT $LN1@Lbound@2
$LN2@Lbound@2:

; 1271 : 				{	// _Pnode not less than _Keyval, remember it
; 1272 : 				_Wherenode = _Pnode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Wherenode$[ebp], edx

; 1273 : 				_Pnode = _Left(_Pnode);	// descend left subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
$LN1@Lbound@2:

; 1274 : 				}

	jmp	SHORT $LN11@Lbound@2
$LN3@Lbound@2:

; 1275 : 
; 1276 : 		return (_Wherenode);	// return best remembered candidate

	mov	eax, DWORD PTR __Wherenode$[ebp]

; 1277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Lbound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lbound
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z
_TEXT	SEGMENT
tv90 = -156						; size = 4
_this$ = -152						; size = 4
$T263301 = -148						; size = 4
$T263281 = -144						; size = 4
$T263266 = -140						; size = 4
$T263249 = -136						; size = 4
$T263236 = -132						; size = 4
$T263222 = -128						; size = 4
$T263178 = -45						; size = 1
$T263177 = -44						; size = 4
$T263176 = -37						; size = 1
$T263175 = -36						; size = 4
$T263174 = -29						; size = 1
$T263173 = -28						; size = 4
$T263172 = -24						; size = 4
$T263171 = -17						; size = 1
__Where$225030 = -16					; size = 4
__Trynode$ = -12					; size = 4
__Wherenode$ = -8					; size = 4
__Addleft$ = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::insert, COMDAT
; _this$ = ecx

; 630  : 		{	// try to insert node with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	mov	DWORD PTR _this$[ebp], ecx

; 631  : 		_Nodeptr _Trynode = _Root();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Trynode$[ebp], edx

; 632  : 		_Nodeptr _Wherenode = _Myhead;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 633  : 		bool _Addleft = true;	// add to left of head if tree empty

	mov	BYTE PTR __Addleft$[ebp], 1

; 634  : 		while (!_Isnil(_Trynode))

$LN19@insert@14:
	mov	edx, DWORD PTR __Trynode$[ebp]
	movsx	eax, BYTE PTR [edx+33]
	test	eax, eax
	jne	SHORT $LN9@insert@14

; 635  : 			{	// look for leaf to insert before (_Addleft) or after
; 636  : 			_Wherenode = _Trynode;

	mov	ecx, DWORD PTR __Trynode$[ebp]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 637  : 			_Addleft = _DEBUG_LT_PRED(this->comp,

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR __Trynode$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax+12]
	sbb	edx, edx
	neg	edx
	mov	BYTE PTR __Addleft$[ebp], dl

; 638  : 				this->_Kfn(_Val), _Key(_Trynode));
; 639  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

	movzx	eax, BYTE PTR __Addleft$[ebp]
	test	eax, eax
	je	SHORT $LN33@insert@14
	mov	ecx, DWORD PTR __Trynode$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv90[ebp], edx
	jmp	SHORT $LN14@insert@14
$LN33@insert@14:
	mov	eax, DWORD PTR __Trynode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv90[ebp], ecx
$LN14@insert@14:
	mov	edx, DWORD PTR tv90[ebp]
	mov	DWORD PTR __Trynode$[ebp], edx

; 640  : 			}

	jmp	SHORT $LN19@insert@14
$LN9@insert@14:

; 641  : 
; 642  : 		if (this->_Multi)

	xor	eax, eax
	je	SHORT $LN8@insert@14

; 643  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	BYTE PTR $T263171[ebp], 1
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	movzx	eax, BYTE PTR __Addleft$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T263172[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Insert
	mov	DWORD PTR $T263222[ebp], eax
	mov	edx, DWORD PTR $T263222[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	al, BYTE PTR $T263171[ebp]
	mov	BYTE PTR [edx+4], al
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN11@insert@14

; 644  : 		else

	jmp	$LN11@insert@14
$LN8@insert@14:

; 645  : 			{	// insert only if unique
; 646  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR __Where$225030[ebp], ecx

; 647  : 			if (!_Addleft)

	movzx	edx, BYTE PTR __Addleft$[ebp]
	test	edx, edx
	jne	SHORT $LN6@insert@14
	jmp	$LN79@insert@14
$LN6@insert@14:

; 648  : 				;	// need to test if insert after is okay
; 649  : 			else if (_Where == begin())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T263236[ebp], ecx
	mov	edx, DWORD PTR $T263236[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T263249[ebp], eax
	mov	ecx, DWORD PTR $T263249[ebp]
	mov	DWORD PTR $T263173[ebp], ecx
	mov	edx, DWORD PTR __Where$225030[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T263173[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@insert@14

; 650  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

	mov	BYTE PTR $T263174[ebp], 1
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	push	1
	lea	ecx, DWORD PTR $T263175[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Insert
	mov	DWORD PTR $T263266[ebp], eax
	mov	edx, DWORD PTR $T263266[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	al, BYTE PTR $T263174[ebp]
	mov	BYTE PTR [edx+4], al
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN11@insert@14

; 651  : 			else

	jmp	SHORT $LN79@insert@14
$LN4@insert@14:

; 652  : 				--_Where;	// need to test if insert before is okay

	lea	ecx, DWORD PTR __Where$225030[ebp]
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::_Dec

; 653  : 
; 654  : 			if (_DEBUG_LT_PRED(this->comp,

$LN79@insert@14:
	mov	ecx, DWORD PTR __Where$225030[ebp]
	mov	DWORD PTR $T263281[ebp], ecx
	mov	edx, DWORD PTR $T263281[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	cmp	ecx, DWORD PTR [eax]
	sbb	edx, edx
	neg	edx
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN2@insert@14

; 655  : 				_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 656  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	BYTE PTR $T263176[ebp], 1
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	movzx	eax, BYTE PTR __Addleft$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T263177[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Insert
	mov	DWORD PTR $T263301[ebp], eax
	mov	edx, DWORD PTR $T263301[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	al, BYTE PTR $T263176[ebp]
	mov	BYTE PTR [edx+4], al
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN11@insert@14

; 657  : 			else

	jmp	SHORT $LN11@insert@14
$LN2@insert@14:

; 658  : 				return (_Pairib(_Where, false));

	mov	BYTE PTR $T263178[ebp], 0
	mov	ecx, DWORD PTR __Where$225030[ebp]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	cl, BYTE PTR $T263178[ebp]
	mov	BYTE PTR [eax+4], cl
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN11@insert@14:

; 659  : 			}
; 660  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::insert
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::erase
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::clear
; Function compile flags: /Odtp
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z
_TEXT	SEGMENT
_this$ = -76						; size = 4
$T263525 = -72						; size = 4
$T263520 = -68						; size = 4
__Tmp$263505 = -48					; size = 4
$T263435 = -44						; size = 4
$T263422 = -40						; size = 4
$T263352 = -28						; size = 4
$T263329 = -24						; size = 4
$T263316 = -20						; size = 4
$T263310 = -16						; size = 4
$T263309 = -12						; size = 4
$T263308 = -8						; size = 4
$T263307 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::erase, COMDAT
; _this$ = ecx

; 934  : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	DWORD PTR _this$[ebp], ecx

; 935  : 		if (_First == begin() && _Last == end())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T263316[ebp], ecx
	mov	edx, DWORD PTR $T263316[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T263329[ebp], eax
	mov	ecx, DWORD PTR $T263329[ebp]
	mov	DWORD PTR $T263307[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T263307[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN72@erase@11
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T263352[ebp], eax
	mov	ecx, DWORD PTR $T263352[ebp]
	mov	DWORD PTR $T263308[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T263308[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN72@erase@11

; 936  : 			{	// erase all
; 937  : 			clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::clear

; 938  : 			return (begin());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T263422[ebp], eax
	mov	ecx, DWORD PTR $T263422[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T263435[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR $T263435[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN5@erase@11

; 939  : 			}
; 940  : 		else

	jmp	SHORT $LN5@erase@11

; 941  : 			{	// partial erase, one at a time
; 942  : 			while (_First != _Last)

$LN72@erase@11:
	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@erase@11

; 943  : 				erase(_First++);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$263505[ebp], eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::_Inc
	mov	ecx, DWORD PTR __Tmp$263505[ebp]
	mov	DWORD PTR $T263309[ebp], ecx
	mov	edx, DWORD PTR $T263309[ebp]
	push	edx
	lea	eax, DWORD PTR $T263310[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::erase
	jmp	SHORT $LN72@erase@11
$LN1@erase@11:

; 944  : 			return (_Make_iter(_First));

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T263525[ebp], ecx
	mov	edx, DWORD PTR $T263525[ebp]
	mov	DWORD PTR $T263520[ebp], edx
	mov	eax, DWORD PTR $T263520[ebp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN5@erase@11:

; 945  : 			}
; 946  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::erase
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Buynode
; Function compile flags: /Odtp
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T263543 = -4						; size = 4
?_Init@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Init, COMDAT
; _this$ = ecx

; 1177 : 		{	// create head/nil node and make tree empty

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1178 : 		_Myhead = _Buynode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Buynode
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1179 : 		_Isnil(_Myhead) = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	BYTE PTR [eax+33], 1

; 1180 : 		_Root() = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 1181 : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T263543[ebp], eax
	mov	ecx, DWORD PTR $T263543[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1182 : 		_Mysize = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 1183 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Init@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Init
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Rrotate
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Lrotate
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Buynode
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z$0
__ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z
_TEXT	SEGMENT
tv277 = -196						; size = 4
_this$ = -192						; size = 4
$T264092 = -188						; size = 4
$T264004 = -172						; size = 4
$T263919 = -160						; size = 4
$T263903 = -156						; size = 4
$T263884 = -152						; size = 4
$T263880 = -148						; size = 4
$T263795 = -136						; size = 4
$T263694 = -120						; size = 4
$T263672 = -116						; size = 4
$T263665 = -112						; size = 4
$T263661 = -108						; size = 4
$T263622 = -104						; size = 4
$T263613 = -100						; size = 4
$T263593 = -96						; size = 4
__Count$263576 = -92					; size = 4
$T263559 = -88						; size = 28
$T263558 = -60						; size = 40
__Pnode$225077 = -20					; size = 4
__Newnode$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1187 : 		{	// add node with value next to _Wherenode, to left if _Addnode

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 184				; 000000b8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1188 : 		if (max_size() - 1 <= _Mysize)

	mov	DWORD PTR __Count$263576[ebp], 214748364 ; 0cccccccH
	cmp	DWORD PTR __Count$263576[ebp], 0
	jbe	SHORT $LN25@Insert@3
	mov	eax, DWORD PTR __Count$263576[ebp]
	mov	DWORD PTR tv277[ebp], eax
	jmp	SHORT $LN21@Insert@3
$LN25@Insert@3:
	mov	DWORD PTR tv277[ebp], 1
$LN21@Insert@3:
	mov	ecx, DWORD PTR tv277[ebp]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR [edx+8]
	ja	SHORT $LN17@Insert@3

; 1189 : 			_THROW(length_error, "map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T263559[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T263559[ebp]
	push	eax
	lea	ecx, DWORD PTR $T263558[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR $T263558[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T263558[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T263559[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN17@Insert@3:

; 1190 : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1191 : 			_Val, _Red);

	push	0
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Buynode
	mov	DWORD PTR __Newnode$[ebp], eax

; 1192 : 
; 1193 : 		++_Mysize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1194 : 		if (_Wherenode == _Myhead)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Wherenode$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN16@Insert@3

; 1195 : 			{	// first node in tree, just set head values
; 1196 : 			_Root() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1197 : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T263593[ebp], edx
	mov	eax, DWORD PTR $T263593[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN15@Insert@3
$LN16@Insert@3:

; 1198 : 			}
; 1199 : 		else if (_Addleft)

	movzx	edx, BYTE PTR __Addleft$[ebp]
	test	edx, edx
	je	SHORT $LN52@Insert@3

; 1200 : 			{	// add to left of _Wherenode
; 1201 : 			_Left(_Wherenode) = _Newnode;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1202 : 			if (_Wherenode == _Lmost())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T263613[ebp], eax
	mov	ecx, DWORD PTR $T263613[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN13@Insert@3

; 1203 : 				_Lmost() = _Newnode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T263622[ebp], ecx
	mov	edx, DWORD PTR $T263622[ebp]
	mov	eax, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [edx], eax
$LN13@Insert@3:

; 1204 : 			}
; 1205 : 		else

	jmp	SHORT $LN15@Insert@3

; 1206 : 			{	// add to right of _Wherenode
; 1207 : 			_Right(_Wherenode) = _Newnode;

$LN52@Insert@3:
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 1208 : 			if (_Wherenode == _Rmost())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN15@Insert@3

; 1209 : 				_Rmost() = _Newnode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN15@Insert@3:

; 1210 : 			}
; 1211 : 
; 1212 : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

	mov	eax, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR __Pnode$225077[ebp], eax
$LN64@Insert@3:
	mov	ecx, DWORD PTR __Pnode$225077[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movsx	eax, BYTE PTR [edx+32]
	test	eax, eax
	jne	$LN360@Insert@3

; 1213 : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

	mov	ecx, DWORD PTR __Pnode$225077[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T263661[ebp], edx
	mov	eax, DWORD PTR $T263661[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T263665[ebp], ecx
	mov	edx, DWORD PTR __Pnode$225077[ebp]
	mov	eax, DWORD PTR $T263665[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax]
	jne	$LN216@Insert@3

; 1214 : 				{	// fixup red-red in left subtree
; 1215 : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR __Pnode$225077[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 4
	mov	DWORD PTR $T263672[ebp], eax
	mov	ecx, DWORD PTR $T263672[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1216 : 				if (_Color(_Wherenode) == _Red)

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	movsx	edx, BYTE PTR [ecx+32]
	test	edx, edx
	jne	SHORT $LN100@Insert@3

; 1217 : 					{	// parent has two red children, blacken both
; 1218 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$225077[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	BYTE PTR [ecx+32], 1

; 1219 : 					_Color(_Wherenode) = _Black;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [edx+32], 1

; 1220 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	eax, DWORD PTR __Pnode$225077[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T263694[ebp], ecx
	mov	edx, DWORD PTR $T263694[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+32], 0

; 1221 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	ecx, DWORD PTR __Pnode$225077[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$225077[ebp], eax

; 1222 : 					}
; 1223 : 				else

	jmp	SHORT $LN6@Insert@3

; 1224 : 					{	// parent has red and black children
; 1225 : 					if (_Pnode == _Right(_Parent(_Pnode)))

$LN100@Insert@3:
	mov	ecx, DWORD PTR __Pnode$225077[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Pnode$225077[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN155@Insert@3

; 1226 : 						{	// rotate right child to left
; 1227 : 						_Pnode = _Parent(_Pnode);

	mov	ecx, DWORD PTR __Pnode$225077[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Pnode$225077[ebp], edx

; 1228 : 						_Lrotate(_Pnode);

	mov	eax, DWORD PTR __Pnode$225077[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Lrotate

; 1229 : 						}
; 1230 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

$LN155@Insert@3:
	mov	ecx, DWORD PTR __Pnode$225077[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+32], 1

; 1231 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	eax, DWORD PTR __Pnode$225077[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T263795[ebp], ecx
	mov	edx, DWORD PTR $T263795[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+32], 0

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

	mov	ecx, DWORD PTR __Pnode$225077[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Rrotate
$LN6@Insert@3:

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	$LN4@Insert@3

; 1236 : 				{	// fixup red-red in right subtree
; 1237 : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));

$LN216@Insert@3:
	mov	ecx, DWORD PTR __Pnode$225077[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T263880[ebp], edx
	mov	eax, DWORD PTR $T263880[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T263884[ebp], ecx
	mov	edx, DWORD PTR $T263884[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1238 : 				if (_Color(_Wherenode) == _Red)

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	movsx	edx, BYTE PTR [ecx+32]
	test	edx, edx
	jne	SHORT $LN240@Insert@3

; 1239 : 					{	// parent has two red children, blacken both
; 1240 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$225077[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	BYTE PTR [ecx+32], 1

; 1241 : 					_Color(_Wherenode) = _Black;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [edx+32], 1

; 1242 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	eax, DWORD PTR __Pnode$225077[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T263903[ebp], ecx
	mov	edx, DWORD PTR $T263903[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+32], 0

; 1243 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	ecx, DWORD PTR __Pnode$225077[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$225077[ebp], eax

; 1244 : 					}
; 1245 : 				else

	jmp	SHORT $LN4@Insert@3

; 1246 : 					{	// parent has red and black children
; 1247 : 					if (_Pnode == _Left(_Parent(_Pnode)))

$LN240@Insert@3:
	mov	ecx, DWORD PTR __Pnode$225077[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T263919[ebp], edx
	mov	eax, DWORD PTR $T263919[ebp]
	mov	ecx, DWORD PTR __Pnode$225077[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN297@Insert@3

; 1248 : 						{	// rotate left child to right
; 1249 : 						_Pnode = _Parent(_Pnode);

	mov	edx, DWORD PTR __Pnode$225077[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$225077[ebp], eax

; 1250 : 						_Rrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$225077[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Rrotate

; 1251 : 						}
; 1252 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

$LN297@Insert@3:
	mov	edx, DWORD PTR __Pnode$225077[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	BYTE PTR [eax+32], 1

; 1253 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR __Pnode$225077[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T264004[ebp], edx
	mov	eax, DWORD PTR $T264004[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	BYTE PTR [ecx+32], 0

; 1254 : 					_Lrotate(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR __Pnode$225077[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Lrotate
$LN4@Insert@3:

; 1255 : 					}
; 1256 : 				}

	jmp	$LN64@Insert@3

; 1257 : 
; 1258 : 		_Color(_Root()) = _Black;	// root is always black

$LN360@Insert@3:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 4
	mov	DWORD PTR $T264092[ebp], eax
	mov	ecx, DWORD PTR $T264092[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	BYTE PTR [edx+32], 1

; 1259 : 		return (_TREE_ITERATOR(_Newnode));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN19@Insert@3:

; 1260 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z$0:
	lea	ecx, DWORD PTR $T263559[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-188]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Insert
; Function compile flags: /Odtp
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABI@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Pnode$ = -8						; size = 4
__Wherenode$ = -4					; size = 4
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABI@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 1263 : 		{	// find leftmost node not less than _Keyval

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1264 : 		_Nodeptr _Pnode = _Root();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Pnode$[ebp], edx

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

$LN11@Lbound@3:
	mov	edx, DWORD PTR __Pnode$[ebp]
	movsx	eax, BYTE PTR [edx+33]
	test	eax, eax
	jne	SHORT $LN3@Lbound@3

; 1268 : 			if (_DEBUG_LT_PRED(this->comp, _Key(_Pnode), _Keyval))

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Keyval$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	cmp	eax, DWORD PTR [edx]
	sbb	ecx, ecx
	neg	ecx
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@Lbound@3

; 1269 : 				_Pnode = _Right(_Pnode);	// descend right subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1270 : 			else

	jmp	SHORT $LN1@Lbound@3
$LN2@Lbound@3:

; 1271 : 				{	// _Pnode not less than _Keyval, remember it
; 1272 : 				_Wherenode = _Pnode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Wherenode$[ebp], edx

; 1273 : 				_Pnode = _Left(_Pnode);	// descend left subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
$LN1@Lbound@3:

; 1274 : 				}

	jmp	SHORT $LN11@Lbound@3
$LN3@Lbound@3:

; 1275 : 
; 1276 : 		return (_Wherenode);	// return best remembered candidate

	mov	eax, DWORD PTR __Wherenode$[ebp]

; 1277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Lbound@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@ABI@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Lbound
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0PlayerInfo@CvReplayInfo@@QAE@ABU01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0PlayerInfo@CvReplayInfo@@QAE@ABU01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0PlayerInfo@CvReplayInfo@@QAE@ABU01@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0PlayerInfo@CvReplayInfo@@QAE@ABU01@@Z$2
__ehfuncinfo$??0PlayerInfo@CvReplayInfo@@QAE@ABU01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0PlayerInfo@CvReplayInfo@@QAE@ABU01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0PlayerInfo@CvReplayInfo@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T264170 = -28						; size = 4
$T264165 = -24						; size = 4
$T264160 = -20						; size = 4
$T264155 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0PlayerInfo@CvReplayInfo@@QAE@ABU01@@Z PROC		; CvReplayInfo::PlayerInfo::PlayerInfo, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0PlayerInfo@CvReplayInfo@@QAE@ABU01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR $T264155[ebp], eax
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	mov	ecx, DWORD PTR $T264155[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 44					; 0000002cH
	mov	DWORD PTR $T264160[ebp], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	mov	ecx, DWORD PTR $T264160[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	mov	DWORD PTR $T264165[ebp], ecx
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 72					; 00000048H
	push	edx
	mov	ecx, DWORD PTR $T264165[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 100				; 00000064H
	mov	DWORD PTR $T264170[ebp], eax
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 100				; 00000064H
	push	ecx
	mov	ecx, DWORD PTR $T264170[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0PlayerInfo@CvReplayInfo@@QAE@ABU01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0PlayerInfo@CvReplayInfo@@QAE@ABU01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0PlayerInfo@CvReplayInfo@@QAE@ABU01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??0PlayerInfo@CvReplayInfo@@QAE@ABU01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0PlayerInfo@CvReplayInfo@@QAE@ABU01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0PlayerInfo@CvReplayInfo@@QAE@ABU01@@Z ENDP		; CvReplayInfo::PlayerInfo::PlayerInfo
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$5
__unwindtable$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv137 = -192						; size = 4
tv163 = -188						; size = 4
tv189 = -184						; size = 4
_this$ = -180						; size = 4
$T264240 = -46						; size = 1
$T264222 = -45						; size = 1
$T264211 = -44						; size = 4
$T264232 = -40						; size = 4
$T264204 = -36						; size = 4
$T264194 = -28						; size = 4
$T264180 = -21						; size = 1
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 528  : 		{	// construct tree by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 176				; 000000b0H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T264240[ebp]
	mov	DWORD PTR $T264194[ebp], eax
	lea	ecx, DWORD PTR $T264222[ebp]
	mov	DWORD PTR $T264204[ebp], ecx
	push	ecx
	mov	edx, esp
	mov	DWORD PTR $T264232[ebp], esp
	mov	DWORD PTR $T264211[ebp], edx
	lea	eax, DWORD PTR $T264180[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
	mov	DWORD PTR tv189[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv163[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv137[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 529  : 		_Init();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Init

; 530  : 		_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 531  : 		_Copy(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Copy
	jmp	SHORT $LN4@Tree
__catch$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$0:

; 532  : 		_CATCH_ALL
; 533  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy

; 534  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 535  : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN2@Tree
	ret	0
$LN4@Tree:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN2@Tree:

; 536  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN3@Tree:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-196]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
; Function compile flags: /Odtp
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$225238 = -4					; size = 4
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1166 : 		{	// free entire subtree, recursively

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1167 : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	eax, DWORD PTR __Rootnode$[ebp]
	mov	DWORD PTR __Pnode$225238[ebp], eax
	jmp	SHORT $LN6@Erase
$LN2@Erase:
	mov	ecx, DWORD PTR __Pnode$225238[ebp]
	mov	DWORD PTR __Rootnode$[ebp], ecx
$LN6@Erase:
	mov	edx, DWORD PTR __Pnode$225238[ebp]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	SHORT $LN4@Erase

; 1168 : 			{	// free subtrees, then node
; 1169 : 			_Erase(_Right(_Pnode));

	mov	ecx, DWORD PTR __Pnode$225238[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Erase

; 1170 : 			_Pnode = _Left(_Pnode);

	mov	eax, DWORD PTR __Pnode$225238[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$225238[ebp], ecx

; 1171 : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node
; 1172 : 			this->_Alnod.deallocate(_Rootnode, 1);

	mov	edx, DWORD PTR __Rootnode$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1173 : 			}

	jmp	SHORT $LN2@Erase
$LN4@Erase:

; 1174 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Erase
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T264696 = -12						; size = 4
$T264689 = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1285 : 		{	// promote right node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1286 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1287 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+8], ecx

; 1288 : 
; 1289 : 		if (!_Isnil(_Left(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+21]
	test	ecx, ecx
	jne	SHORT $LN24@Lrotate

; 1290 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1291 : 		_Parent(_Pnode) = _Parent(_Wherenode);

$LN24@Lrotate:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 1292 : 
; 1293 : 		if (_Wherenode == _Root())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN34@Lrotate

; 1294 : 			_Root() = _Pnode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	SHORT $LN46@Lrotate

; 1295 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

$LN34@Lrotate:
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T264689[ebp], eax
	mov	ecx, DWORD PTR $T264689[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN44@Lrotate

; 1296 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T264696[ebp], ecx
	mov	edx, DWORD PTR $T264696[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx], eax

; 1297 : 		else

	jmp	SHORT $LN46@Lrotate

; 1298 : 			_Right(_Parent(_Wherenode)) = _Pnode;

$LN44@Lrotate:
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

$LN46@Lrotate:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [ecx], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1302 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Lrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lrotate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T264772 = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1329 : 		{	// promote left node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1330 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1331 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], ecx

; 1332 : 
; 1333 : 		if (!_Isnil(_Right(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+21]
	test	ecx, ecx
	jne	SHORT $LN24@Rrotate

; 1334 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1335 : 		_Parent(_Pnode) = _Parent(_Wherenode);

$LN24@Rrotate:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 1336 : 
; 1337 : 		if (_Wherenode == _Root())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN36@Rrotate

; 1338 : 			_Root() = _Pnode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	SHORT $LN46@Rrotate

; 1339 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

$LN36@Rrotate:
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN42@Rrotate

; 1340 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1341 : 		else

	jmp	SHORT $LN46@Rrotate

; 1342 : 			_Left(_Parent(_Wherenode)) = _Pnode;

$LN42@Rrotate:
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T264772[ebp], eax
	mov	ecx, DWORD PTR $T264772[ebp]
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx], edx

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

$LN46@Rrotate:
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Rrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rrotate
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0out_of_range@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0out_of_range@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0out_of_range@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0out_of_range@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV01@@Z PROC			; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0out_of_range@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7out_of_range@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0out_of_range@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0out_of_range@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0out_of_range@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0out_of_range@std@@QAE@ABV01@@Z ENDP			; std::out_of_range::out_of_range
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::allocate
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ$0
__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ$2
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
tv72 = -96						; size = 4
tv182 = -92						; size = 4
tv177 = -88						; size = 4
_this$ = -84						; size = 4
$T264903 = -80						; size = 4
__Vptr$264909 = -76					; size = 4
$T264874 = -72						; size = 4
__Vptr$264880 = -68					; size = 4
$T264845 = -64						; size = 4
__Vptr$264851 = -60					; size = 4
$T264807 = -36						; size = 4
$T264806 = -32						; size = 4
$T264805 = -28						; size = 4
__Wherenode$ = -24					; size = 4
__Linkcnt$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1383 : 		{	// allocate a head/nil node

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1384 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1
	call	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::allocate
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1385 : 		int _Linkcnt = 0;

	mov	DWORD PTR __Linkcnt$[ebp], 0

; 1386 : 
; 1387 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1388 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

	mov	DWORD PTR $T264805[ebp], 0
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR __Vptr$264851[ebp], eax
	mov	ecx, DWORD PTR __Vptr$264851[ebp]
	mov	DWORD PTR $T264845[ebp], ecx
	cmp	DWORD PTR $T264845[ebp], 0
	je	SHORT $LN23@Buynode
	mov	edx, DWORD PTR $T264845[ebp]
	mov	eax, DWORD PTR $T264805[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T264845[ebp]
	mov	DWORD PTR tv177[ebp], ecx
	jmp	SHORT $LN19@Buynode
$LN23@Buynode:
	mov	DWORD PTR tv177[ebp], 0
$LN19@Buynode:

; 1389 : 		++_Linkcnt;

	mov	edx, DWORD PTR __Linkcnt$[ebp]
	add	edx, 1
	mov	DWORD PTR __Linkcnt$[ebp], edx

; 1390 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

	mov	DWORD PTR $T264806[ebp], 0
	mov	eax, DWORD PTR __Wherenode$[ebp]
	add	eax, 4
	mov	DWORD PTR __Vptr$264880[ebp], eax
	mov	ecx, DWORD PTR __Vptr$264880[ebp]
	mov	DWORD PTR $T264874[ebp], ecx
	cmp	DWORD PTR $T264874[ebp], 0
	je	SHORT $LN33@Buynode
	mov	edx, DWORD PTR $T264874[ebp]
	mov	eax, DWORD PTR $T264806[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T264874[ebp]
	mov	DWORD PTR tv182[ebp], ecx
	jmp	SHORT $LN29@Buynode
$LN33@Buynode:
	mov	DWORD PTR tv182[ebp], 0
$LN29@Buynode:

; 1391 : 		++_Linkcnt;

	mov	edx, DWORD PTR __Linkcnt$[ebp]
	add	edx, 1
	mov	DWORD PTR __Linkcnt$[ebp], edx

; 1392 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

	mov	DWORD PTR $T264807[ebp], 0
	mov	eax, DWORD PTR __Wherenode$[ebp]
	add	eax, 8
	mov	DWORD PTR __Vptr$264909[ebp], eax
	mov	ecx, DWORD PTR __Vptr$264909[ebp]
	mov	DWORD PTR $T264903[ebp], ecx
	cmp	DWORD PTR $T264903[ebp], 0
	je	SHORT $LN43@Buynode
	mov	edx, DWORD PTR $T264903[ebp]
	mov	eax, DWORD PTR $T264807[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T264903[ebp]
	mov	DWORD PTR tv72[ebp], ecx
	jmp	SHORT $LN39@Buynode
$LN43@Buynode:
	mov	DWORD PTR tv72[ebp], 0
$LN39@Buynode:
	jmp	SHORT $LN6@Buynode
__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ$0:

; 1393 : 		_CATCH_ALL
; 1394 : 		if (1 < _Linkcnt)
; 1395 : 			this->_Alptr.destroy(&_Parent(_Wherenode));
; 1396 : 		if (0 < _Linkcnt)
; 1397 : 			this->_Alptr.destroy(&_Left(_Wherenode));
; 1398 : 		this->_Alnod.deallocate(_Wherenode, 1);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1399 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1400 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN61@Buynode
	ret	0
$LN6@Buynode:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1401 : 		_Color(_Wherenode) = _Black;

$LN61@Buynode:
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [eax+20], 1

; 1402 : 		_Isnil(_Wherenode) = false;

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [ecx+21], 0

; 1403 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN5@Buynode:

; 1404 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-100]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z$0
__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z$3
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z
_TEXT	SEGMENT
tv86 = -52						; size = 4
_this$ = -48						; size = 4
$T264953 = -28						; size = 4
$T264952 = -24						; size = 4
__Wherenode$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1408 : 		{	// allocate a node with pointers, value, and color

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	0
	push	1
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>
	add	esp, 8
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1410 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR $T264953[ebp], eax
	cmp	DWORD PTR $T264953[ebp], 0
	je	SHORT $LN4@Buynode@2
	mov	ecx, DWORD PTR $T264953[ebp]
	mov	edx, DWORD PTR __Larg$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR $T264953[ebp]
	mov	ecx, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR $T264953[ebp]
	mov	eax, DWORD PTR __Rarg$[ebp]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T264953[ebp]
	mov	DWORD PTR [ecx+12], edx
	mov	DWORD PTR [ecx+16], eax
	mov	edx, DWORD PTR $T264953[ebp]
	mov	al, BYTE PTR __Carg$[ebp]
	mov	BYTE PTR [edx+20], al
	mov	ecx, DWORD PTR $T264953[ebp]
	mov	BYTE PTR [ecx+21], 0
	mov	edx, DWORD PTR $T264953[ebp]
	mov	DWORD PTR tv86[ebp], edx
	jmp	SHORT $LN5@Buynode@2
$LN4@Buynode@2:
	mov	DWORD PTR tv86[ebp], 0
$LN5@Buynode@2:
	mov	eax, DWORD PTR tv86[ebp]
	mov	DWORD PTR $T264952[ebp], eax
	jmp	SHORT $LN6@Buynode@2
__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z$0:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1414 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1415 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z$1
	ret	0
$LN6@Buynode@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z$1:

; 1416 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN3@Buynode@2:

; 1417 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode
PUBLIC	??$_Uninit_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z$11 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z$11
__unwindtable$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv215 = -256						; size = 4
tv148 = -252						; size = 4
tv172 = -248						; size = 4
_this$ = -244						; size = 4
$T265102 = -164						; size = 4
$T265101 = -160						; size = 4
$T265100 = -156						; size = 4
$T265090 = -152						; size = 4
$T265089 = -148						; size = 4
__Cat$265098 = -143					; size = 1
$T265096 = -142						; size = 1
$T265095 = -141						; size = 1
$T265069 = -140						; size = 4
$T265060 = -136						; size = 4
$T265029 = -48						; size = 4
$T265025 = -42						; size = 1
$T265012 = -41						; size = 1
$T265008 = -40						; size = 4
$T265001 = -32						; size = 4
$T264992 = -28						; size = 4
$T264991 = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T265025[ebp]
	mov	DWORD PTR $T265001[ebp], eax
	lea	ecx, DWORD PTR $T265012[ebp]
	mov	DWORD PTR $T265008[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv172[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv148[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR $T265029[ebp], eax
	mov	edx, DWORD PTR $T265029[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAE_NI@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Buy
	movzx	eax, al
	test	eax, eax
	je	$LN3@vector@2

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T265060[ebp], edx
	mov	eax, DWORD PTR $T265060[ebp]
	mov	DWORD PTR $T264991[ebp], eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T265069[ebp], edx
	mov	eax, DWORD PTR $T265069[ebp]
	mov	DWORD PTR $T264992[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T265102[ebp], edx
	mov	eax, DWORD PTR $T264991[ebp]
	mov	DWORD PTR $T265101[ebp], eax
	mov	ecx, DWORD PTR $T264992[ebp]
	mov	DWORD PTR $T265100[ebp], ecx
	mov	edx, DWORD PTR $T265102[ebp]
	mov	DWORD PTR $T265090[ebp], edx
	mov	eax, DWORD PTR $T265100[ebp]
	mov	DWORD PTR $T265089[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T265095[ebp], cl
	mov	dl, BYTE PTR __Cat$265098[ebp]
	mov	BYTE PTR $T265096[ebp], dl
	movzx	eax, BYTE PTR $T265095[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T265096[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T265090[ebp]
	push	eax
	mov	ecx, DWORD PTR $T265101[ebp]
	push	ecx
	mov	edx, DWORD PTR $T265089[ebp]
	push	edx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
	add	esp, 24					; 00000018H
	mov	DWORD PTR tv215[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR tv215[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN5@vector@2
__catch$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@2
	ret	0
$LN5@vector@2:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@2:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@2:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ
__ehhandler$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-260]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@KAXXZ
_TEXT	SEGMENT
$T265445 = -80						; size = 28
$T265444 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@KAXXZ PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T265445[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T265444[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T265444[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T265445[ebp]
	push	eax
	lea	ecx, DWORD PTR $T265444[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T265444[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T265444[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T265445[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@9:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T265445[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T265444[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@KAXXZ ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	SEGMENT
__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0
__ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
tv177 = -216						; size = 4
tv165 = -212						; size = 4
_this$ = -208						; size = 4
$T266324 = -204						; size = 4
$T266319 = -200						; size = 4
$T265723 = -136						; size = 4
$T265722 = -132						; size = 4
__Tmp$265721 = -125					; size = 1
$T265698 = -124						; size = 4
$T265691 = -120						; size = 4
$T265621 = -116						; size = 4
$T265585 = -112						; size = 4
$T265580 = -108						; size = 4
$T265552 = -104						; size = 4
$T265476 = -100						; size = 4
$T265467 = -96						; size = 28
$T265466 = -68						; size = 40
__Fixnodeparent$ = -28					; size = 4
__Pnode$ = -24						; size = 4
__Fixnode$ = -20					; size = 4
__Erasednode$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase, COMDAT
; _this$ = ecx

; 764  : 		{	// erase element at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 765  : 
; 766  :  #if _HAS_ITERATOR_DEBUGGING
; 767  : 		if (_Where._Mycont != this || _Isnil(_Where._Mynode()))
; 768  : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 769  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 770  : 		++_Where;	// save successor iterator for return
; 771  : 		_Orphan_ptr(*this, _Erasednode);
; 772  : 
; 773  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 774  : 		if (_Isnil(_Where._Mynode()))

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T265476[ebp], eax
	mov	ecx, DWORD PTR $T265476[ebp]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	je	SHORT $LN55@erase@12

; 775  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

	push	OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
	lea	ecx, DWORD PTR $T265467[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T265467[ebp]
	push	eax
	lea	ecx, DWORD PTR $T265466[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR $T265466[ebp], OFFSET ??_7out_of_range@std@@6B@
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	ecx, DWORD PTR $T265466[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T265467[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 776  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

$LN55@erase@12:
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Erasednode$[ebp], edx

; 777  : 		++_Where;	// save successor iterator for return

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Inc

; 778  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 779  : 
; 780  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 781  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 782  : 		_Nodeptr _Pnode = _Erasednode;

	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	DWORD PTR __Pnode$[ebp], eax

; 783  : 
; 784  : 		if (_Isnil(_Left(_Pnode)))

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	je	SHORT $LN67@erase@12

; 785  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Fixnode$[ebp], edx
	jmp	SHORT $LN38@erase@12

; 786  : 		else if (_Isnil(_Right(_Pnode)))

$LN67@erase@12:
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	je	SHORT $LN71@erase@12

; 787  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 788  : 		else

	jmp	SHORT $LN38@erase@12

; 789  : 			{	// two subtrees, must lift successor node to replace erased
; 790  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

$LN71@erase@12:
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Pnode$[ebp], edx

; 791  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Fixnode$[ebp], ecx
$LN38@erase@12:

; 792  : 			}
; 793  : 
; 794  : 		if (_Pnode == _Erasednode)

	mov	edx, DWORD PTR __Pnode$[ebp]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	$LN137@erase@12

; 795  : 			{	// at most one subtree, relink it
; 796  : 			_Fixnodeparent = _Parent(_Erasednode);

	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Fixnodeparent$[ebp], ecx

; 797  : 			if (!_Isnil(_Fixnode))

	mov	edx, DWORD PTR __Fixnode$[ebp]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	SHORT $LN81@erase@12

; 798  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 799  : 
; 800  : 			if (_Root() == _Erasednode)

$LN81@erase@12:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN89@erase@12

; 801  : 				_Root() = _Fixnode;	// link down from root

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [ecx+4], edx
	jmp	SHORT $LN32@erase@12

; 802  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

$LN89@erase@12:
	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN93@erase@12

; 803  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [edx], eax

; 804  : 			else

	jmp	SHORT $LN32@erase@12

; 805  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

$LN93@erase@12:
	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN32@erase@12:

; 806  : 
; 807  : 			if (_Lmost() == _Erasednode)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T265552[ebp], ecx
	mov	edx, DWORD PTR $T265552[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN115@erase@12

; 808  : 				_Lmost() = _Isnil(_Fixnode)
; 809  : 					? _Fixnodeparent	// smallest is parent of erased node
; 810  : 					: _Min(_Fixnode);	// smallest in relinked subtree

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	je	SHORT $LN43@erase@12
	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv165[ebp], eax
	jmp	SHORT $LN44@erase@12
$LN43@erase@12:
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR $T265580[ebp], ecx
$LN107@erase@12:
	mov	edx, DWORD PTR $T265580[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+21]
	test	ecx, ecx
	jne	SHORT $LN103@erase@12
	mov	edx, DWORD PTR $T265580[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T265580[ebp], eax
	jmp	SHORT $LN107@erase@12
$LN103@erase@12:
	mov	ecx, DWORD PTR $T265580[ebp]
	mov	DWORD PTR tv165[ebp], ecx
$LN44@erase@12:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T265585[ebp], eax
	mov	ecx, DWORD PTR $T265585[ebp]
	mov	edx, DWORD PTR tv165[ebp]
	mov	DWORD PTR [ecx], edx

; 811  : 
; 812  : 			if (_Rmost() == _Erasednode)

$LN115@erase@12:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN28@erase@12

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	mov	eax, DWORD PTR __Fixnode$[ebp]
	movsx	ecx, BYTE PTR [eax+21]
	test	ecx, ecx
	je	SHORT $LN45@erase@12
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv177[ebp], edx
	jmp	SHORT $LN131@erase@12
$LN45@erase@12:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR $T265621[ebp], eax
$LN127@erase@12:
	mov	ecx, DWORD PTR $T265621[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	SHORT $LN123@erase@12
	mov	ecx, DWORD PTR $T265621[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T265621[ebp], edx
	jmp	SHORT $LN127@erase@12
$LN123@erase@12:
	mov	eax, DWORD PTR $T265621[ebp]
	mov	DWORD PTR tv177[ebp], eax
$LN131@erase@12:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR tv177[ebp]
	mov	DWORD PTR [edx+8], eax
$LN28@erase@12:

; 816  : 			}
; 817  : 		else

	jmp	$LN192@erase@12

; 818  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 819  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

$LN137@erase@12:
	mov	ecx, DWORD PTR __Erasednode$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx+4], eax

; 820  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Erasednode$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 821  : 
; 822  : 			if (_Pnode == _Right(_Erasednode))

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	mov	edx, DWORD PTR __Pnode$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN145@erase@12

; 823  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Fixnodeparent$[ebp], eax

; 824  : 			else

	jmp	SHORT $LN161@erase@12

; 825  : 				{	// successor further down, link in place of erased
; 826  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's

$LN145@erase@12:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Fixnodeparent$[ebp], edx

; 827  : 				if (!_Isnil(_Fixnode))

	mov	eax, DWORD PTR __Fixnode$[ebp]
	movsx	ecx, BYTE PTR [eax+21]
	test	ecx, ecx
	jne	SHORT $LN151@erase@12

; 828  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [edx+4], eax

; 829  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

$LN151@erase@12:
	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [ecx], edx

; 830  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR __Erasednode$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 831  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 832  : 				}
; 833  : 
; 834  : 			if (_Root() == _Erasednode)

$LN161@erase@12:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN169@erase@12

; 835  : 				_Root() = _Pnode;	// link down from root

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx+4], edx
	jmp	SHORT $LN183@erase@12

; 836  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

$LN169@erase@12:
	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T265691[ebp], ecx
	mov	edx, DWORD PTR $T265691[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN179@erase@12

; 837  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T265698[ebp], edx
	mov	eax, DWORD PTR $T265698[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 838  : 			else

	jmp	SHORT $LN183@erase@12

; 839  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

$LN179@erase@12:
	mov	edx, DWORD PTR __Erasednode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 840  : 
; 841  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

$LN183@erase@12:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 842  : 			_STD swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

	mov	edx, DWORD PTR __Erasednode$[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR $T265723[ebp], edx
	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR $T265722[ebp], eax
	mov	ecx, DWORD PTR $T265722[ebp]
	cmp	ecx, DWORD PTR $T265723[ebp]
	je	SHORT $LN192@erase@12
	mov	edx, DWORD PTR $T265722[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR __Tmp$265721[ebp], al
	mov	ecx, DWORD PTR $T265722[ebp]
	mov	edx, DWORD PTR $T265723[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR $T265723[ebp]
	mov	dl, BYTE PTR __Tmp$265721[ebp]
	mov	BYTE PTR [ecx], dl

; 843  : 			}
; 844  : 
; 845  : 		if (_Color(_Erasednode) == _Black)

$LN192@erase@12:
	mov	eax, DWORD PTR __Erasednode$[ebp]
	movsx	ecx, BYTE PTR [eax+20]
	cmp	ecx, 1
	jne	$LN588@erase@12

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	jmp	SHORT $LN196@erase@12
$LN194@erase@12:
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Fixnodeparent$[ebp], eax
$LN196@erase@12:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Fixnode$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	je	$LN586@erase@12
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	movsx	edx, BYTE PTR [ecx+20]
	cmp	edx, 1
	jne	$LN586@erase@12

; 849  : 				if (_Fixnode == _Left(_Fixnodeparent))

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	$LN395@erase@12

; 850  : 					{	// fixup left subtree
; 851  : 					_Pnode = _Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Pnode$[ebp], eax

; 852  : 					if (_Color(_Pnode) == _Red)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	movsx	edx, BYTE PTR [ecx+20]
	test	edx, edx
	jne	SHORT $LN263@erase@12

; 853  : 						{	// rotate red up from right subtree
; 854  : 						_Color(_Pnode) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [eax+20], 1

; 855  : 						_Color(_Fixnodeparent) = _Red;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	BYTE PTR [ecx+20], 0

; 856  : 						_Lrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate

; 857  : 						_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 858  : 						}
; 859  : 
; 860  : 					if (_Isnil(_Pnode))

$LN263@erase@12:
	mov	edx, DWORD PTR __Pnode$[ebp]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	je	SHORT $LN267@erase@12

; 861  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 862  : 					else if (_Color(_Left(_Pnode)) == _Black

	jmp	$LN12@erase@12

; 863  : 						&& _Color(_Right(_Pnode)) == _Black)

$LN267@erase@12:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+20]
	cmp	ecx, 1
	jne	SHORT $LN277@erase@12
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+20]
	cmp	ecx, 1
	jne	SHORT $LN277@erase@12

; 864  : 						{	// redden right subtree with black children
; 865  : 						_Color(_Pnode) = _Red;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [edx+20], 0

; 866  : 						_Fixnode = _Fixnodeparent;

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], eax

; 867  : 						}
; 868  : 					else

	jmp	SHORT $LN12@erase@12

; 869  : 						{	// must rearrange right subtree
; 870  : 						if (_Color(_Right(_Pnode)) == _Black)

$LN277@erase@12:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movsx	eax, BYTE PTR [edx+20]
	cmp	eax, 1
	jne	SHORT $LN338@erase@12

; 871  : 							{	// rotate red up from left sub-subtree
; 872  : 							_Color(_Left(_Pnode)) = _Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	BYTE PTR [edx+20], 1

; 873  : 							_Color(_Pnode) = _Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [eax+20], 0

; 874  : 							_Rrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate

; 875  : 							_Pnode = _Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Pnode$[ebp], eax

; 876  : 							}
; 877  : 
; 878  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

$LN338@erase@12:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	al, BYTE PTR [edx+20]
	mov	BYTE PTR [ecx+20], al

; 879  : 						_Color(_Fixnodeparent) = _Black;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	BYTE PTR [ecx+20], 1

; 880  : 						_Color(_Right(_Pnode)) = _Black;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	BYTE PTR [eax+20], 1

; 881  : 						_Lrotate(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate

; 882  : 						break;	// tree now recolored/rebalanced

	jmp	$LN586@erase@12
$LN12@erase@12:

; 883  : 						}
; 884  : 					}
; 885  : 				else

	jmp	$LN8@erase@12

; 886  : 					{	// fixup right subtree
; 887  : 					_Pnode = _Left(_Fixnodeparent);

$LN395@erase@12:
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Pnode$[ebp], eax

; 888  : 					if (_Color(_Pnode) == _Red)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	movsx	edx, BYTE PTR [ecx+20]
	test	edx, edx
	jne	SHORT $LN454@erase@12

; 889  : 						{	// rotate red up from left subtree
; 890  : 						_Color(_Pnode) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [eax+20], 1

; 891  : 						_Color(_Fixnodeparent) = _Red;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	BYTE PTR [ecx+20], 0

; 892  : 						_Rrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate

; 893  : 						_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 894  : 						}
; 895  : 					if (_Isnil(_Pnode))

$LN454@erase@12:
	mov	edx, DWORD PTR __Pnode$[ebp]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	je	SHORT $LN458@erase@12

; 896  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 897  : 					else if (_Color(_Right(_Pnode)) == _Black

	jmp	$LN8@erase@12

; 898  : 						&& _Color(_Left(_Pnode)) == _Black)

$LN458@erase@12:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+20]
	cmp	ecx, 1
	jne	SHORT $LN468@erase@12
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+20]
	cmp	ecx, 1
	jne	SHORT $LN468@erase@12

; 899  : 						{	// redden left subtree with black children
; 900  : 						_Color(_Pnode) = _Red;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [edx+20], 0

; 901  : 						_Fixnode = _Fixnodeparent;

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], eax

; 902  : 						}
; 903  : 					else

	jmp	SHORT $LN8@erase@12

; 904  : 						{	// must rearrange left subtree
; 905  : 						if (_Color(_Left(_Pnode)) == _Black)

$LN468@erase@12:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx+20]
	cmp	eax, 1
	jne	SHORT $LN529@erase@12

; 906  : 							{	// rotate red up from right sub-subtree
; 907  : 							_Color(_Right(_Pnode)) = _Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	BYTE PTR [edx+20], 1

; 908  : 							_Color(_Pnode) = _Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [eax+20], 0

; 909  : 							_Lrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate

; 910  : 							_Pnode = _Left(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Pnode$[ebp], eax

; 911  : 							}
; 912  : 
; 913  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

$LN529@erase@12:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	al, BYTE PTR [edx+20]
	mov	BYTE PTR [ecx+20], al

; 914  : 						_Color(_Fixnodeparent) = _Black;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	BYTE PTR [ecx+20], 1

; 915  : 						_Color(_Left(_Pnode)) = _Black;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+20], 1

; 916  : 						_Rrotate(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate

; 917  : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN586@erase@12
$LN8@erase@12:

; 918  : 						}
; 919  : 					}

	jmp	$LN194@erase@12

; 920  : 
; 921  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

$LN586@erase@12:
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	BYTE PTR [edx+20], 1

; 922  : 			}
; 923  : 
; 924  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node

$LN588@erase@12:

; 925  : 		this->_Alnod.deallocate(_Erasednode, 1);

	mov	eax, DWORD PTR __Erasednode$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 926  : 
; 927  : 		if (0 < _Mysize)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	jbe	SHORT $LN1@erase@12

; 928  : 			--_Mysize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN1@erase@12:

; 929  : 
; 930  : 		return (_Make_iter(_Where));	// return successor iterator

	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T266324[ebp], edx
	mov	eax, DWORD PTR $T266324[ebp]
	mov	DWORD PTR $T266319[ebp], eax
	mov	ecx, DWORD PTR $T266319[ebp]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN42@erase@12:

; 931  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0:
	lea	ecx, DWORD PTR $T265467[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase
; Function compile flags: /Odtp
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T266374 = -8						; size = 4
?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::clear, COMDAT
; _this$ = ecx

; 965  : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 966  : 
; 967  :  #if _HAS_ITERATOR_DEBUGGING
; 968  : 		this->_Orphan_ptr(*this, 0);
; 969  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 970  : 
; 971  : 		_Erase(_Root());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase

; 972  : 		_Root() = _Myhead, _Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 973  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T266374[ebp], eax
	mov	ecx, DWORD PTR $T266374[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 974  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::clear
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T266445 = -12						; size = 4
$T266438 = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1285 : 		{	// promote right node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1286 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1287 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+8], ecx

; 1288 : 
; 1289 : 		if (!_Isnil(_Left(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+21]
	test	ecx, ecx
	jne	SHORT $LN24@Lrotate@2

; 1290 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1291 : 		_Parent(_Pnode) = _Parent(_Wherenode);

$LN24@Lrotate@2:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 1292 : 
; 1293 : 		if (_Wherenode == _Root())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN34@Lrotate@2

; 1294 : 			_Root() = _Pnode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	SHORT $LN46@Lrotate@2

; 1295 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

$LN34@Lrotate@2:
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T266438[ebp], eax
	mov	ecx, DWORD PTR $T266438[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN44@Lrotate@2

; 1296 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T266445[ebp], ecx
	mov	edx, DWORD PTR $T266445[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx], eax

; 1297 : 		else

	jmp	SHORT $LN46@Lrotate@2

; 1298 : 			_Right(_Parent(_Wherenode)) = _Pnode;

$LN44@Lrotate@2:
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

$LN46@Lrotate@2:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [ecx], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1302 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T266521 = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1329 : 		{	// promote left node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1330 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1331 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], ecx

; 1332 : 
; 1333 : 		if (!_Isnil(_Right(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+21]
	test	ecx, ecx
	jne	SHORT $LN24@Rrotate@2

; 1334 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1335 : 		_Parent(_Pnode) = _Parent(_Wherenode);

$LN24@Rrotate@2:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 1336 : 
; 1337 : 		if (_Wherenode == _Root())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN36@Rrotate@2

; 1338 : 			_Root() = _Pnode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	SHORT $LN46@Rrotate@2

; 1339 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

$LN36@Rrotate@2:
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN42@Rrotate@2

; 1340 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1341 : 		else

	jmp	SHORT $LN46@Rrotate@2

; 1342 : 			_Left(_Parent(_Wherenode)) = _Pnode;

$LN42@Rrotate@2:
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T266521[ebp], eax
	mov	ecx, DWORD PTR $T266521[ebp]
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx], edx

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

$LN46@Rrotate@2:
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::allocate
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ$0
__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ$2
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
tv72 = -96						; size = 4
tv182 = -92						; size = 4
tv177 = -88						; size = 4
_this$ = -84						; size = 4
$T266627 = -80						; size = 4
__Vptr$266633 = -76					; size = 4
$T266598 = -72						; size = 4
__Vptr$266604 = -68					; size = 4
$T266569 = -64						; size = 4
__Vptr$266575 = -60					; size = 4
$T266532 = -36						; size = 4
$T266531 = -32						; size = 4
$T266530 = -28						; size = 4
__Wherenode$ = -24					; size = 4
__Linkcnt$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1383 : 		{	// allocate a head/nil node

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1384 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1
	call	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::allocate
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1385 : 		int _Linkcnt = 0;

	mov	DWORD PTR __Linkcnt$[ebp], 0

; 1386 : 
; 1387 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1388 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

	mov	DWORD PTR $T266530[ebp], 0
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR __Vptr$266575[ebp], eax
	mov	ecx, DWORD PTR __Vptr$266575[ebp]
	mov	DWORD PTR $T266569[ebp], ecx
	cmp	DWORD PTR $T266569[ebp], 0
	je	SHORT $LN23@Buynode@3
	mov	edx, DWORD PTR $T266569[ebp]
	mov	eax, DWORD PTR $T266530[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T266569[ebp]
	mov	DWORD PTR tv177[ebp], ecx
	jmp	SHORT $LN19@Buynode@3
$LN23@Buynode@3:
	mov	DWORD PTR tv177[ebp], 0
$LN19@Buynode@3:

; 1389 : 		++_Linkcnt;

	mov	edx, DWORD PTR __Linkcnt$[ebp]
	add	edx, 1
	mov	DWORD PTR __Linkcnt$[ebp], edx

; 1390 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

	mov	DWORD PTR $T266531[ebp], 0
	mov	eax, DWORD PTR __Wherenode$[ebp]
	add	eax, 4
	mov	DWORD PTR __Vptr$266604[ebp], eax
	mov	ecx, DWORD PTR __Vptr$266604[ebp]
	mov	DWORD PTR $T266598[ebp], ecx
	cmp	DWORD PTR $T266598[ebp], 0
	je	SHORT $LN33@Buynode@3
	mov	edx, DWORD PTR $T266598[ebp]
	mov	eax, DWORD PTR $T266531[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T266598[ebp]
	mov	DWORD PTR tv182[ebp], ecx
	jmp	SHORT $LN29@Buynode@3
$LN33@Buynode@3:
	mov	DWORD PTR tv182[ebp], 0
$LN29@Buynode@3:

; 1391 : 		++_Linkcnt;

	mov	edx, DWORD PTR __Linkcnt$[ebp]
	add	edx, 1
	mov	DWORD PTR __Linkcnt$[ebp], edx

; 1392 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

	mov	DWORD PTR $T266532[ebp], 0
	mov	eax, DWORD PTR __Wherenode$[ebp]
	add	eax, 8
	mov	DWORD PTR __Vptr$266633[ebp], eax
	mov	ecx, DWORD PTR __Vptr$266633[ebp]
	mov	DWORD PTR $T266627[ebp], ecx
	cmp	DWORD PTR $T266627[ebp], 0
	je	SHORT $LN43@Buynode@3
	mov	edx, DWORD PTR $T266627[ebp]
	mov	eax, DWORD PTR $T266532[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T266627[ebp]
	mov	DWORD PTR tv72[ebp], ecx
	jmp	SHORT $LN39@Buynode@3
$LN43@Buynode@3:
	mov	DWORD PTR tv72[ebp], 0
$LN39@Buynode@3:
	jmp	SHORT $LN6@Buynode@3
__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ$0:

; 1393 : 		_CATCH_ALL
; 1394 : 		if (1 < _Linkcnt)
; 1395 : 			this->_Alptr.destroy(&_Parent(_Wherenode));
; 1396 : 		if (0 < _Linkcnt)
; 1397 : 			this->_Alptr.destroy(&_Left(_Wherenode));
; 1398 : 		this->_Alnod.deallocate(_Wherenode, 1);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1399 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1400 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN61@Buynode@3
	ret	0
$LN6@Buynode@3:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1401 : 		_Color(_Wherenode) = _Black;

$LN61@Buynode@3:
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [eax+20], 1

; 1402 : 		_Isnil(_Wherenode) = false;

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [ecx+21], 0

; 1403 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN5@Buynode@3:

; 1404 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-100]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z$0
__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z$3
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z
_TEXT	SEGMENT
tv86 = -52						; size = 4
_this$ = -48						; size = 4
$T266678 = -28						; size = 4
$T266677 = -24						; size = 4
__Wherenode$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1408 : 		{	// allocate a node with pointers, value, and color

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	0
	push	1
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>
	add	esp, 8
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1410 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR $T266678[ebp], eax
	cmp	DWORD PTR $T266678[ebp], 0
	je	SHORT $LN4@Buynode@4
	mov	ecx, DWORD PTR $T266678[ebp]
	mov	edx, DWORD PTR __Larg$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR $T266678[ebp]
	mov	ecx, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR $T266678[ebp]
	mov	eax, DWORD PTR __Rarg$[ebp]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T266678[ebp]
	mov	DWORD PTR [ecx+12], edx
	mov	DWORD PTR [ecx+16], eax
	mov	edx, DWORD PTR $T266678[ebp]
	mov	al, BYTE PTR __Carg$[ebp]
	mov	BYTE PTR [edx+20], al
	mov	ecx, DWORD PTR $T266678[ebp]
	mov	BYTE PTR [ecx+21], 0
	mov	edx, DWORD PTR $T266678[ebp]
	mov	DWORD PTR tv86[ebp], edx
	jmp	SHORT $LN5@Buynode@4
$LN4@Buynode@4:
	mov	DWORD PTR tv86[ebp], 0
$LN5@Buynode@4:
	mov	eax, DWORD PTR tv86[ebp]
	mov	DWORD PTR $T266677[ebp], eax
	jmp	SHORT $LN6@Buynode@4
__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z$0:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1414 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1415 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z$1
	ret	0
$LN6@Buynode@4:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z$1:

; 1416 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN3@Buynode@4:

; 1417 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode
; Function compile flags: /Odtp
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T266755 = -16						; size = 4
$T266734 = -12						; size = 4
$T266727 = -8						; size = 4
__Pnode$225463 = -4					; size = 4
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 320  : 			{	// move to node with next smaller value

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 321  : 
; 322  :  #if _HAS_ITERATOR_DEBUGGING
; 323  : 			if (this->_Mycont == 0
; 324  : 				|| _Ptr == 0)
; 325  : 				{
; 326  : 				_DEBUG_ERROR("map/set iterator not decrementable");
; 327  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 				}
; 329  :  #else
; 330  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 331  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 332  : 
; 333  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	je	SHORT $LN9@Dec

; 334  : 			{
; 335  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx], eax

; 336  :    				if (_Isnil(_Ptr))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	je	SHORT $LN8@Dec

; 337  : #if _HAS_ITERATOR_DEBUGGING
; 338  : 				{
; 339  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 340  : 					_SCL_SECURE_OUT_OF_RANGE;
; 341  : 				}
; 342  : #elif _SECURE_SCL
; 343  : 				{
; 344  :     				_SCL_SECURE_OUT_OF_RANGE;
; 345  : 				}
; 346  : #else
; 347  : 				return;	// begin() shouldn't be incremented, don't move

	jmp	$LN10@Dec
$LN8@Dec:

; 348  : #endif
; 349  : 			}

	jmp	$LN10@Dec
$LN9@Dec:

; 350  : 			else if (!_Isnil(_Left(_Ptr)))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T266727[ebp], edx
	mov	eax, DWORD PTR $T266727[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	jne	SHORT $LN34@Dec

; 351  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T266734[ebp], ecx
	mov	edx, DWORD PTR $T266734[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T266755[ebp], eax
$LN30@Dec:
	mov	ecx, DWORD PTR $T266755[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	SHORT $LN26@Dec
	mov	ecx, DWORD PTR $T266755[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T266755[ebp], edx
	jmp	SHORT $LN30@Dec
$LN26@Dec:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T266755[ebp]
	mov	DWORD PTR [eax], ecx

; 352  : 			else

	jmp	SHORT $LN10@Dec

; 353  : 				{	// climb looking for left subtree
; 354  : 				_Nodeptr _Pnode;
; 355  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 356  : 					&& _Ptr == _Left(_Pnode))

$LN34@Dec:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Pnode$225463[ebp], ecx
	mov	edx, DWORD PTR __Pnode$225463[ebp]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	SHORT $LN40@Dec
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Pnode$225463[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN40@Dec

; 357  : 					_Ptr = _Pnode;	// ==> parent while left subtree

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Pnode$225463[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN34@Dec

; 358  : 				if (_Isnil(_Ptr))

$LN40@Dec:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	je	SHORT $LN2@Dec

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move

	jmp	SHORT $LN10@Dec

; 370  :  #endif
; 371  : 				else

	jmp	SHORT $LN10@Dec
$LN2@Dec:

; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$225463[ebp]
	mov	DWORD PTR [eax], ecx
$LN10@Dec:

; 373  : 				}
; 374  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Dec
_TEXT	ENDS
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Copy
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z$5
__unwindtable$??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv137 = -192						; size = 4
tv163 = -188						; size = 4
tv189 = -184						; size = 4
_this$ = -180						; size = 4
$T266831 = -46						; size = 1
$T266813 = -45						; size = 1
$T266802 = -44						; size = 4
$T266823 = -40						; size = 4
$T266795 = -36						; size = 4
$T266785 = -28						; size = 4
$T266771 = -21						; size = 1
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >, COMDAT
; _this$ = ecx

; 528  : 		{	// construct tree by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 176				; 000000b0H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T266831[ebp]
	mov	DWORD PTR $T266785[ebp], eax
	lea	ecx, DWORD PTR $T266813[ebp]
	mov	DWORD PTR $T266795[ebp], ecx
	push	ecx
	mov	edx, esp
	mov	DWORD PTR $T266823[ebp], esp
	mov	DWORD PTR $T266802[ebp], edx
	lea	eax, DWORD PTR $T266771[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >
	mov	DWORD PTR tv189[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv163[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv137[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 529  : 		_Init();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Init

; 530  : 		_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 531  : 		_Copy(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Copy
	jmp	SHORT $LN4@Tree@2
__catch$??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z$0:

; 532  : 		_CATCH_ALL
; 533  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tidy

; 534  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 535  : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN2@Tree@2
	ret	0
$LN4@Tree@2:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN2@Tree@2:

; 536  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN3@Tree@2:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-196]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0
__ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
tv177 = -216						; size = 4
tv165 = -212						; size = 4
_this$ = -208						; size = 4
$T268067 = -204						; size = 4
$T268062 = -200						; size = 4
$T267466 = -136						; size = 4
$T267465 = -132						; size = 4
__Tmp$267464 = -125					; size = 1
$T267441 = -124						; size = 4
$T267434 = -120						; size = 4
$T267364 = -116						; size = 4
$T267328 = -112						; size = 4
$T267323 = -108						; size = 4
$T267295 = -104						; size = 4
$T267219 = -100						; size = 4
$T267210 = -96						; size = 28
$T267209 = -68						; size = 40
__Fixnodeparent$ = -28					; size = 4
__Pnode$ = -24						; size = 4
__Fixnode$ = -20					; size = 4
__Erasednode$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::erase, COMDAT
; _this$ = ecx

; 764  : 		{	// erase element at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 765  : 
; 766  :  #if _HAS_ITERATOR_DEBUGGING
; 767  : 		if (_Where._Mycont != this || _Isnil(_Where._Mynode()))
; 768  : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 769  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 770  : 		++_Where;	// save successor iterator for return
; 771  : 		_Orphan_ptr(*this, _Erasednode);
; 772  : 
; 773  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 774  : 		if (_Isnil(_Where._Mynode()))

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T267219[ebp], eax
	mov	ecx, DWORD PTR $T267219[ebp]
	movsx	edx, BYTE PTR [ecx+33]
	test	edx, edx
	je	SHORT $LN55@erase@13

; 775  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

	push	OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
	lea	ecx, DWORD PTR $T267210[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T267210[ebp]
	push	eax
	lea	ecx, DWORD PTR $T267209[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR $T267209[ebp], OFFSET ??_7out_of_range@std@@6B@
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	ecx, DWORD PTR $T267209[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T267210[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 776  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

$LN55@erase@13:
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Erasednode$[ebp], edx

; 777  : 		++_Where;	// save successor iterator for return

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::_Inc

; 778  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 779  : 
; 780  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 781  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 782  : 		_Nodeptr _Pnode = _Erasednode;

	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	DWORD PTR __Pnode$[ebp], eax

; 783  : 
; 784  : 		if (_Isnil(_Left(_Pnode)))

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx+33]
	test	eax, eax
	je	SHORT $LN67@erase@13

; 785  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Fixnode$[ebp], edx
	jmp	SHORT $LN38@erase@13

; 786  : 		else if (_Isnil(_Right(_Pnode)))

$LN67@erase@13:
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	movsx	edx, BYTE PTR [ecx+33]
	test	edx, edx
	je	SHORT $LN71@erase@13

; 787  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 788  : 		else

	jmp	SHORT $LN38@erase@13

; 789  : 			{	// two subtrees, must lift successor node to replace erased
; 790  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

$LN71@erase@13:
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Pnode$[ebp], edx

; 791  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Fixnode$[ebp], ecx
$LN38@erase@13:

; 792  : 			}
; 793  : 
; 794  : 		if (_Pnode == _Erasednode)

	mov	edx, DWORD PTR __Pnode$[ebp]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	$LN137@erase@13

; 795  : 			{	// at most one subtree, relink it
; 796  : 			_Fixnodeparent = _Parent(_Erasednode);

	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Fixnodeparent$[ebp], ecx

; 797  : 			if (!_Isnil(_Fixnode))

	mov	edx, DWORD PTR __Fixnode$[ebp]
	movsx	eax, BYTE PTR [edx+33]
	test	eax, eax
	jne	SHORT $LN81@erase@13

; 798  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 799  : 
; 800  : 			if (_Root() == _Erasednode)

$LN81@erase@13:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN89@erase@13

; 801  : 				_Root() = _Fixnode;	// link down from root

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [ecx+4], edx
	jmp	SHORT $LN32@erase@13

; 802  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

$LN89@erase@13:
	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN93@erase@13

; 803  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [edx], eax

; 804  : 			else

	jmp	SHORT $LN32@erase@13

; 805  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

$LN93@erase@13:
	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN32@erase@13:

; 806  : 
; 807  : 			if (_Lmost() == _Erasednode)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T267295[ebp], ecx
	mov	edx, DWORD PTR $T267295[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN115@erase@13

; 808  : 				_Lmost() = _Isnil(_Fixnode)
; 809  : 					? _Fixnodeparent	// smallest is parent of erased node
; 810  : 					: _Min(_Fixnode);	// smallest in relinked subtree

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	movsx	edx, BYTE PTR [ecx+33]
	test	edx, edx
	je	SHORT $LN43@erase@13
	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv165[ebp], eax
	jmp	SHORT $LN44@erase@13
$LN43@erase@13:
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR $T267323[ebp], ecx
$LN107@erase@13:
	mov	edx, DWORD PTR $T267323[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+33]
	test	ecx, ecx
	jne	SHORT $LN103@erase@13
	mov	edx, DWORD PTR $T267323[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T267323[ebp], eax
	jmp	SHORT $LN107@erase@13
$LN103@erase@13:
	mov	ecx, DWORD PTR $T267323[ebp]
	mov	DWORD PTR tv165[ebp], ecx
$LN44@erase@13:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T267328[ebp], eax
	mov	ecx, DWORD PTR $T267328[ebp]
	mov	edx, DWORD PTR tv165[ebp]
	mov	DWORD PTR [ecx], edx

; 811  : 
; 812  : 			if (_Rmost() == _Erasednode)

$LN115@erase@13:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN28@erase@13

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	mov	eax, DWORD PTR __Fixnode$[ebp]
	movsx	ecx, BYTE PTR [eax+33]
	test	ecx, ecx
	je	SHORT $LN45@erase@13
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv177[ebp], edx
	jmp	SHORT $LN131@erase@13
$LN45@erase@13:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR $T267364[ebp], eax
$LN127@erase@13:
	mov	ecx, DWORD PTR $T267364[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movsx	eax, BYTE PTR [edx+33]
	test	eax, eax
	jne	SHORT $LN123@erase@13
	mov	ecx, DWORD PTR $T267364[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T267364[ebp], edx
	jmp	SHORT $LN127@erase@13
$LN123@erase@13:
	mov	eax, DWORD PTR $T267364[ebp]
	mov	DWORD PTR tv177[ebp], eax
$LN131@erase@13:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR tv177[ebp]
	mov	DWORD PTR [edx+8], eax
$LN28@erase@13:

; 816  : 			}
; 817  : 		else

	jmp	$LN192@erase@13

; 818  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 819  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

$LN137@erase@13:
	mov	ecx, DWORD PTR __Erasednode$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx+4], eax

; 820  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Erasednode$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 821  : 
; 822  : 			if (_Pnode == _Right(_Erasednode))

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	mov	edx, DWORD PTR __Pnode$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN145@erase@13

; 823  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Fixnodeparent$[ebp], eax

; 824  : 			else

	jmp	SHORT $LN161@erase@13

; 825  : 				{	// successor further down, link in place of erased
; 826  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's

$LN145@erase@13:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Fixnodeparent$[ebp], edx

; 827  : 				if (!_Isnil(_Fixnode))

	mov	eax, DWORD PTR __Fixnode$[ebp]
	movsx	ecx, BYTE PTR [eax+33]
	test	ecx, ecx
	jne	SHORT $LN151@erase@13

; 828  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [edx+4], eax

; 829  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

$LN151@erase@13:
	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [ecx], edx

; 830  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR __Erasednode$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 831  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 832  : 				}
; 833  : 
; 834  : 			if (_Root() == _Erasednode)

$LN161@erase@13:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN169@erase@13

; 835  : 				_Root() = _Pnode;	// link down from root

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx+4], edx
	jmp	SHORT $LN183@erase@13

; 836  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

$LN169@erase@13:
	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T267434[ebp], ecx
	mov	edx, DWORD PTR $T267434[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN179@erase@13

; 837  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T267441[ebp], edx
	mov	eax, DWORD PTR $T267441[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 838  : 			else

	jmp	SHORT $LN183@erase@13

; 839  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

$LN179@erase@13:
	mov	edx, DWORD PTR __Erasednode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 840  : 
; 841  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

$LN183@erase@13:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 842  : 			_STD swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

	mov	edx, DWORD PTR __Erasednode$[ebp]
	add	edx, 32					; 00000020H
	mov	DWORD PTR $T267466[ebp], edx
	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR $T267465[ebp], eax
	mov	ecx, DWORD PTR $T267465[ebp]
	cmp	ecx, DWORD PTR $T267466[ebp]
	je	SHORT $LN192@erase@13
	mov	edx, DWORD PTR $T267465[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR __Tmp$267464[ebp], al
	mov	ecx, DWORD PTR $T267465[ebp]
	mov	edx, DWORD PTR $T267466[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR $T267466[ebp]
	mov	dl, BYTE PTR __Tmp$267464[ebp]
	mov	BYTE PTR [ecx], dl

; 843  : 			}
; 844  : 
; 845  : 		if (_Color(_Erasednode) == _Black)

$LN192@erase@13:
	mov	eax, DWORD PTR __Erasednode$[ebp]
	movsx	ecx, BYTE PTR [eax+32]
	cmp	ecx, 1
	jne	$LN588@erase@13

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	jmp	SHORT $LN196@erase@13
$LN194@erase@13:
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Fixnodeparent$[ebp], eax
$LN196@erase@13:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Fixnode$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	je	$LN586@erase@13
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	movsx	edx, BYTE PTR [ecx+32]
	cmp	edx, 1
	jne	$LN586@erase@13

; 849  : 				if (_Fixnode == _Left(_Fixnodeparent))

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	$LN395@erase@13

; 850  : 					{	// fixup left subtree
; 851  : 					_Pnode = _Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Pnode$[ebp], eax

; 852  : 					if (_Color(_Pnode) == _Red)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	movsx	edx, BYTE PTR [ecx+32]
	test	edx, edx
	jne	SHORT $LN263@erase@13

; 853  : 						{	// rotate red up from right subtree
; 854  : 						_Color(_Pnode) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [eax+32], 1

; 855  : 						_Color(_Fixnodeparent) = _Red;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	BYTE PTR [ecx+32], 0

; 856  : 						_Lrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Lrotate

; 857  : 						_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 858  : 						}
; 859  : 
; 860  : 					if (_Isnil(_Pnode))

$LN263@erase@13:
	mov	edx, DWORD PTR __Pnode$[ebp]
	movsx	eax, BYTE PTR [edx+33]
	test	eax, eax
	je	SHORT $LN267@erase@13

; 861  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 862  : 					else if (_Color(_Left(_Pnode)) == _Black

	jmp	$LN12@erase@13

; 863  : 						&& _Color(_Right(_Pnode)) == _Black)

$LN267@erase@13:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+32]
	cmp	ecx, 1
	jne	SHORT $LN277@erase@13
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+32]
	cmp	ecx, 1
	jne	SHORT $LN277@erase@13

; 864  : 						{	// redden right subtree with black children
; 865  : 						_Color(_Pnode) = _Red;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [edx+32], 0

; 866  : 						_Fixnode = _Fixnodeparent;

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], eax

; 867  : 						}
; 868  : 					else

	jmp	SHORT $LN12@erase@13

; 869  : 						{	// must rearrange right subtree
; 870  : 						if (_Color(_Right(_Pnode)) == _Black)

$LN277@erase@13:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movsx	eax, BYTE PTR [edx+32]
	cmp	eax, 1
	jne	SHORT $LN338@erase@13

; 871  : 							{	// rotate red up from left sub-subtree
; 872  : 							_Color(_Left(_Pnode)) = _Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	BYTE PTR [edx+32], 1

; 873  : 							_Color(_Pnode) = _Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [eax+32], 0

; 874  : 							_Rrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Rrotate

; 875  : 							_Pnode = _Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Pnode$[ebp], eax

; 876  : 							}
; 877  : 
; 878  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

$LN338@erase@13:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	al, BYTE PTR [edx+32]
	mov	BYTE PTR [ecx+32], al

; 879  : 						_Color(_Fixnodeparent) = _Black;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	BYTE PTR [ecx+32], 1

; 880  : 						_Color(_Right(_Pnode)) = _Black;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	BYTE PTR [eax+32], 1

; 881  : 						_Lrotate(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Lrotate

; 882  : 						break;	// tree now recolored/rebalanced

	jmp	$LN586@erase@13
$LN12@erase@13:

; 883  : 						}
; 884  : 					}
; 885  : 				else

	jmp	$LN8@erase@13

; 886  : 					{	// fixup right subtree
; 887  : 					_Pnode = _Left(_Fixnodeparent);

$LN395@erase@13:
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Pnode$[ebp], eax

; 888  : 					if (_Color(_Pnode) == _Red)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	movsx	edx, BYTE PTR [ecx+32]
	test	edx, edx
	jne	SHORT $LN454@erase@13

; 889  : 						{	// rotate red up from left subtree
; 890  : 						_Color(_Pnode) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [eax+32], 1

; 891  : 						_Color(_Fixnodeparent) = _Red;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	BYTE PTR [ecx+32], 0

; 892  : 						_Rrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Rrotate

; 893  : 						_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 894  : 						}
; 895  : 					if (_Isnil(_Pnode))

$LN454@erase@13:
	mov	edx, DWORD PTR __Pnode$[ebp]
	movsx	eax, BYTE PTR [edx+33]
	test	eax, eax
	je	SHORT $LN458@erase@13

; 896  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 897  : 					else if (_Color(_Right(_Pnode)) == _Black

	jmp	$LN8@erase@13

; 898  : 						&& _Color(_Left(_Pnode)) == _Black)

$LN458@erase@13:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+32]
	cmp	ecx, 1
	jne	SHORT $LN468@erase@13
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+32]
	cmp	ecx, 1
	jne	SHORT $LN468@erase@13

; 899  : 						{	// redden left subtree with black children
; 900  : 						_Color(_Pnode) = _Red;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [edx+32], 0

; 901  : 						_Fixnode = _Fixnodeparent;

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], eax

; 902  : 						}
; 903  : 					else

	jmp	SHORT $LN8@erase@13

; 904  : 						{	// must rearrange left subtree
; 905  : 						if (_Color(_Left(_Pnode)) == _Black)

$LN468@erase@13:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx+32]
	cmp	eax, 1
	jne	SHORT $LN529@erase@13

; 906  : 							{	// rotate red up from right sub-subtree
; 907  : 							_Color(_Right(_Pnode)) = _Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	BYTE PTR [edx+32], 1

; 908  : 							_Color(_Pnode) = _Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [eax+32], 0

; 909  : 							_Lrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Lrotate

; 910  : 							_Pnode = _Left(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Pnode$[ebp], eax

; 911  : 							}
; 912  : 
; 913  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

$LN529@erase@13:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	al, BYTE PTR [edx+32]
	mov	BYTE PTR [ecx+32], al

; 914  : 						_Color(_Fixnodeparent) = _Black;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	BYTE PTR [ecx+32], 1

; 915  : 						_Color(_Left(_Pnode)) = _Black;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+32], 1

; 916  : 						_Rrotate(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Rrotate

; 917  : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN586@erase@13
$LN8@erase@13:

; 918  : 						}
; 919  : 					}

	jmp	$LN194@erase@13

; 920  : 
; 921  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

$LN586@erase@13:
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	BYTE PTR [edx+32], 1

; 922  : 			}
; 923  : 
; 924  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node

$LN588@erase@13:

; 925  : 		this->_Alnod.deallocate(_Erasednode, 1);

	mov	eax, DWORD PTR __Erasednode$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 926  : 
; 927  : 		if (0 < _Mysize)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	jbe	SHORT $LN1@erase@13

; 928  : 			--_Mysize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN1@erase@13:

; 929  : 
; 930  : 		return (_Make_iter(_Where));	// return successor iterator

	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T268067[ebp], edx
	mov	eax, DWORD PTR $T268067[ebp]
	mov	DWORD PTR $T268062[ebp], eax
	mov	ecx, DWORD PTR $T268062[ebp]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN42@erase@13:

; 931  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0:
	lea	ecx, DWORD PTR $T267210[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::erase
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Erase
; Function compile flags: /Odtp
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T268117 = -8						; size = 4
?clear@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::clear, COMDAT
; _this$ = ecx

; 965  : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 966  : 
; 967  :  #if _HAS_ITERATOR_DEBUGGING
; 968  : 		this->_Orphan_ptr(*this, 0);
; 969  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 970  : 
; 971  : 		_Erase(_Root());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Erase

; 972  : 		_Root() = _Myhead, _Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 973  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T268117[ebp], eax
	mov	ecx, DWORD PTR $T268117[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 974  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::clear
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T268188 = -12						; size = 4
$T268181 = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1285 : 		{	// promote right node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1286 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1287 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+8], ecx

; 1288 : 
; 1289 : 		if (!_Isnil(_Left(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+33]
	test	ecx, ecx
	jne	SHORT $LN24@Lrotate@3

; 1290 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1291 : 		_Parent(_Pnode) = _Parent(_Wherenode);

$LN24@Lrotate@3:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 1292 : 
; 1293 : 		if (_Wherenode == _Root())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN34@Lrotate@3

; 1294 : 			_Root() = _Pnode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	SHORT $LN46@Lrotate@3

; 1295 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

$LN34@Lrotate@3:
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T268181[ebp], eax
	mov	ecx, DWORD PTR $T268181[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN44@Lrotate@3

; 1296 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T268188[ebp], ecx
	mov	edx, DWORD PTR $T268188[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx], eax

; 1297 : 		else

	jmp	SHORT $LN46@Lrotate@3

; 1298 : 			_Right(_Parent(_Wherenode)) = _Pnode;

$LN44@Lrotate@3:
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

$LN46@Lrotate@3:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [ecx], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1302 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Lrotate@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Lrotate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T268264 = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1329 : 		{	// promote left node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1330 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1331 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], ecx

; 1332 : 
; 1333 : 		if (!_Isnil(_Right(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+33]
	test	ecx, ecx
	jne	SHORT $LN24@Rrotate@3

; 1334 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1335 : 		_Parent(_Pnode) = _Parent(_Wherenode);

$LN24@Rrotate@3:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 1336 : 
; 1337 : 		if (_Wherenode == _Root())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN36@Rrotate@3

; 1338 : 			_Root() = _Pnode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	SHORT $LN46@Rrotate@3

; 1339 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

$LN36@Rrotate@3:
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN42@Rrotate@3

; 1340 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1341 : 		else

	jmp	SHORT $LN46@Rrotate@3

; 1342 : 			_Left(_Parent(_Wherenode)) = _Pnode;

$LN42@Rrotate@3:
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T268264[ebp], eax
	mov	ecx, DWORD PTR $T268264[ebp]
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx], edx

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

$LN46@Rrotate@3:
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Rrotate@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node>::allocate
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@XZ$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@XZ$0
__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@XZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@XZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@XZ$2
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@XZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@XZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@XZ
_TEXT	SEGMENT
tv72 = -96						; size = 4
tv182 = -92						; size = 4
tv177 = -88						; size = 4
_this$ = -84						; size = 4
$T268370 = -80						; size = 4
__Vptr$268376 = -76					; size = 4
$T268341 = -72						; size = 4
__Vptr$268347 = -68					; size = 4
$T268312 = -64						; size = 4
__Vptr$268318 = -60					; size = 4
$T268275 = -36						; size = 4
$T268274 = -32						; size = 4
$T268273 = -28						; size = 4
__Wherenode$ = -24					; size = 4
__Linkcnt$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1383 : 		{	// allocate a head/nil node

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1384 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1
	call	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node>::allocate
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1385 : 		int _Linkcnt = 0;

	mov	DWORD PTR __Linkcnt$[ebp], 0

; 1386 : 
; 1387 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1388 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

	mov	DWORD PTR $T268273[ebp], 0
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR __Vptr$268318[ebp], eax
	mov	ecx, DWORD PTR __Vptr$268318[ebp]
	mov	DWORD PTR $T268312[ebp], ecx
	cmp	DWORD PTR $T268312[ebp], 0
	je	SHORT $LN23@Buynode@5
	mov	edx, DWORD PTR $T268312[ebp]
	mov	eax, DWORD PTR $T268273[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T268312[ebp]
	mov	DWORD PTR tv177[ebp], ecx
	jmp	SHORT $LN19@Buynode@5
$LN23@Buynode@5:
	mov	DWORD PTR tv177[ebp], 0
$LN19@Buynode@5:

; 1389 : 		++_Linkcnt;

	mov	edx, DWORD PTR __Linkcnt$[ebp]
	add	edx, 1
	mov	DWORD PTR __Linkcnt$[ebp], edx

; 1390 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

	mov	DWORD PTR $T268274[ebp], 0
	mov	eax, DWORD PTR __Wherenode$[ebp]
	add	eax, 4
	mov	DWORD PTR __Vptr$268347[ebp], eax
	mov	ecx, DWORD PTR __Vptr$268347[ebp]
	mov	DWORD PTR $T268341[ebp], ecx
	cmp	DWORD PTR $T268341[ebp], 0
	je	SHORT $LN33@Buynode@5
	mov	edx, DWORD PTR $T268341[ebp]
	mov	eax, DWORD PTR $T268274[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T268341[ebp]
	mov	DWORD PTR tv182[ebp], ecx
	jmp	SHORT $LN29@Buynode@5
$LN33@Buynode@5:
	mov	DWORD PTR tv182[ebp], 0
$LN29@Buynode@5:

; 1391 : 		++_Linkcnt;

	mov	edx, DWORD PTR __Linkcnt$[ebp]
	add	edx, 1
	mov	DWORD PTR __Linkcnt$[ebp], edx

; 1392 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

	mov	DWORD PTR $T268275[ebp], 0
	mov	eax, DWORD PTR __Wherenode$[ebp]
	add	eax, 8
	mov	DWORD PTR __Vptr$268376[ebp], eax
	mov	ecx, DWORD PTR __Vptr$268376[ebp]
	mov	DWORD PTR $T268370[ebp], ecx
	cmp	DWORD PTR $T268370[ebp], 0
	je	SHORT $LN43@Buynode@5
	mov	edx, DWORD PTR $T268370[ebp]
	mov	eax, DWORD PTR $T268275[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T268370[ebp]
	mov	DWORD PTR tv72[ebp], ecx
	jmp	SHORT $LN39@Buynode@5
$LN43@Buynode@5:
	mov	DWORD PTR tv72[ebp], 0
$LN39@Buynode@5:
	jmp	SHORT $LN6@Buynode@5
__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@XZ$0:

; 1393 : 		_CATCH_ALL
; 1394 : 		if (1 < _Linkcnt)
; 1395 : 			this->_Alptr.destroy(&_Parent(_Wherenode));
; 1396 : 		if (0 < _Linkcnt)
; 1397 : 			this->_Alptr.destroy(&_Left(_Wherenode));
; 1398 : 		this->_Alnod.deallocate(_Wherenode, 1);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1399 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1400 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN61@Buynode@5
	ret	0
$LN6@Buynode@5:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1401 : 		_Color(_Wherenode) = _Black;

$LN61@Buynode@5:
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [eax+32], 1

; 1402 : 		_Isnil(_Wherenode) = false;

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [ecx+33], 0

; 1403 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN5@Buynode@5:

; 1404 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-100]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Buynode
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@D@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@D@Z$0
__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@D@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@D@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@D@Z$3
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@D@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@D@Z
_TEXT	SEGMENT
tv86 = -52						; size = 4
_this$ = -48						; size = 4
$T268421 = -28						; size = 4
$T268420 = -24						; size = 4
__Wherenode$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@D@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1408 : 		{	// allocate a node with pointers, value, and color

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	0
	push	1
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node>
	add	esp, 8
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1410 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR $T268421[ebp], eax
	cmp	DWORD PTR $T268421[ebp], 0
	je	SHORT $LN4@Buynode@6
	mov	ecx, DWORD PTR $T268421[ebp]
	mov	edx, DWORD PTR __Larg$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR $T268421[ebp]
	mov	ecx, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR $T268421[ebp]
	mov	eax, DWORD PTR __Rarg$[ebp]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR $T268421[ebp]
	add	edx, 12					; 0000000cH
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], ecx
	mov	edx, DWORD PTR $T268421[ebp]
	mov	al, BYTE PTR __Carg$[ebp]
	mov	BYTE PTR [edx+32], al
	mov	ecx, DWORD PTR $T268421[ebp]
	mov	BYTE PTR [ecx+33], 0
	mov	edx, DWORD PTR $T268421[ebp]
	mov	DWORD PTR tv86[ebp], edx
	jmp	SHORT $LN5@Buynode@6
$LN4@Buynode@6:
	mov	DWORD PTR tv86[ebp], 0
$LN5@Buynode@6:
	mov	eax, DWORD PTR tv86[ebp]
	mov	DWORD PTR $T268420[ebp], eax
	jmp	SHORT $LN6@Buynode@6
__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@D@Z$0:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1414 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1415 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@D@Z$1
	ret	0
$LN6@Buynode@6:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@D@Z$1:

; 1416 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN3@Buynode@6:

; 1417 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@D@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Buynode
; Function compile flags: /Odtp
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T268498 = -16						; size = 4
$T268477 = -12						; size = 4
$T268470 = -8						; size = 4
__Pnode$225596 = -4					; size = 4
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 320  : 			{	// move to node with next smaller value

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 321  : 
; 322  :  #if _HAS_ITERATOR_DEBUGGING
; 323  : 			if (this->_Mycont == 0
; 324  : 				|| _Ptr == 0)
; 325  : 				{
; 326  : 				_DEBUG_ERROR("map/set iterator not decrementable");
; 327  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 				}
; 329  :  #else
; 330  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 331  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 332  : 
; 333  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+33]
	test	edx, edx
	je	SHORT $LN9@Dec@2

; 334  : 			{
; 335  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx], eax

; 336  :    				if (_Isnil(_Ptr))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx+33]
	test	eax, eax
	je	SHORT $LN8@Dec@2

; 337  : #if _HAS_ITERATOR_DEBUGGING
; 338  : 				{
; 339  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 340  : 					_SCL_SECURE_OUT_OF_RANGE;
; 341  : 				}
; 342  : #elif _SECURE_SCL
; 343  : 				{
; 344  :     				_SCL_SECURE_OUT_OF_RANGE;
; 345  : 				}
; 346  : #else
; 347  : 				return;	// begin() shouldn't be incremented, don't move

	jmp	$LN10@Dec@2
$LN8@Dec@2:

; 348  : #endif
; 349  : 			}

	jmp	$LN10@Dec@2
$LN9@Dec@2:

; 350  : 			else if (!_Isnil(_Left(_Ptr)))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T268470[ebp], edx
	mov	eax, DWORD PTR $T268470[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+33]
	test	edx, edx
	jne	SHORT $LN34@Dec@2

; 351  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T268477[ebp], ecx
	mov	edx, DWORD PTR $T268477[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T268498[ebp], eax
$LN30@Dec@2:
	mov	ecx, DWORD PTR $T268498[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movsx	eax, BYTE PTR [edx+33]
	test	eax, eax
	jne	SHORT $LN26@Dec@2
	mov	ecx, DWORD PTR $T268498[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T268498[ebp], edx
	jmp	SHORT $LN30@Dec@2
$LN26@Dec@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T268498[ebp]
	mov	DWORD PTR [eax], ecx

; 352  : 			else

	jmp	SHORT $LN10@Dec@2

; 353  : 				{	// climb looking for left subtree
; 354  : 				_Nodeptr _Pnode;
; 355  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 356  : 					&& _Ptr == _Left(_Pnode))

$LN34@Dec@2:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Pnode$225596[ebp], ecx
	mov	edx, DWORD PTR __Pnode$225596[ebp]
	movsx	eax, BYTE PTR [edx+33]
	test	eax, eax
	jne	SHORT $LN40@Dec@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Pnode$225596[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN40@Dec@2

; 357  : 					_Ptr = _Pnode;	// ==> parent while left subtree

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Pnode$225596[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN34@Dec@2

; 358  : 				if (_Isnil(_Ptr))

$LN40@Dec@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+33]
	test	edx, edx
	je	SHORT $LN2@Dec@2

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move

	jmp	SHORT $LN10@Dec@2

; 370  :  #endif
; 371  : 				else

	jmp	SHORT $LN10@Dec@2
$LN2@Dec@2:

; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$225596[ebp]
	mov	DWORD PTR [eax], ecx
$LN10@Dec@2:

; 373  : 				}
; 374  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::_Dec
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T268547 = -16						; size = 4
$T268526 = -12						; size = 4
$T268519 = -8						; size = 4
__Pnode$225608 = -4					; size = 4
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 377  : 			{	// move to node with next larger value

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 378  : 
; 379  :  #if _HAS_ITERATOR_DEBUGGING
; 380  : 			if (this->_Mycont == 0
; 381  : 				|| _Ptr == 0
; 382  : 				|| _Isnil(_Ptr))
; 383  : 				{
; 384  : 				_DEBUG_ERROR("map/set iterator not incrementable");
; 385  : 				_SCL_SECURE_OUT_OF_RANGE;
; 386  : 				}
; 387  :  #else
; 388  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 389  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+33]
	test	edx, edx
	je	SHORT $LN6@Inc@2
	jmp	$LN7@Inc@2
$LN6@Inc@2:

; 390  : 				{
; 391  : 				_SCL_SECURE_OUT_OF_RANGE;
; 392  : 				// end() shouldn't be incremented, don't move if _SCL_SECURE is not turned on
; 393  : 				}
; 394  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 395  : 
; 396  : 			else if (!_Isnil(_Right(_Ptr)))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	mov	DWORD PTR $T268519[ebp], ecx
	mov	edx, DWORD PTR $T268519[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+33]
	test	ecx, ecx
	jne	SHORT $LN27@Inc@2

; 397  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 8
	mov	DWORD PTR $T268526[ebp], eax
	mov	ecx, DWORD PTR $T268526[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T268547[ebp], edx
$LN23@Inc@2:
	mov	eax, DWORD PTR $T268547[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+33]
	test	edx, edx
	jne	SHORT $LN19@Inc@2
	mov	eax, DWORD PTR $T268547[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T268547[ebp], ecx
	jmp	SHORT $LN23@Inc@2
$LN19@Inc@2:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T268547[ebp]
	mov	DWORD PTR [edx], eax

; 398  : 			else

	jmp	SHORT $LN7@Inc@2

; 399  : 				{	// climb looking for right subtree
; 400  : 				_Nodeptr _Pnode;
; 401  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 402  : 					&& _Ptr == _Right(_Pnode))

$LN27@Inc@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$225608[ebp], eax
	mov	ecx, DWORD PTR __Pnode$225608[ebp]
	movsx	edx, BYTE PTR [ecx+33]
	test	edx, edx
	jne	SHORT $LN1@Inc@2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$225608[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN1@Inc@2

; 403  : 					_Ptr = _Pnode;	// ==> parent while right subtree

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$225608[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN27@Inc@2
$LN1@Inc@2:

; 404  : 				_Ptr = _Pnode;	// ==> parent (head if end())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Pnode$225608[ebp]
	mov	DWORD PTR [edx], eax
$LN7@Inc@2:

; 405  : 				}
; 406  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::_Inc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T268599 = -16						; size = 4
$T268578 = -12						; size = 4
$T268571 = -8						; size = 4
__Pnode$225680 = -4					; size = 4
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 320  : 			{	// move to node with next smaller value

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 321  : 
; 322  :  #if _HAS_ITERATOR_DEBUGGING
; 323  : 			if (this->_Mycont == 0
; 324  : 				|| _Ptr == 0)
; 325  : 				{
; 326  : 				_DEBUG_ERROR("map/set iterator not decrementable");
; 327  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 				}
; 329  :  #else
; 330  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 331  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 332  : 
; 333  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	je	SHORT $LN9@Dec@3

; 334  : 			{
; 335  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx], eax

; 336  :    				if (_Isnil(_Ptr))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	je	SHORT $LN8@Dec@3

; 337  : #if _HAS_ITERATOR_DEBUGGING
; 338  : 				{
; 339  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 340  : 					_SCL_SECURE_OUT_OF_RANGE;
; 341  : 				}
; 342  : #elif _SECURE_SCL
; 343  : 				{
; 344  :     				_SCL_SECURE_OUT_OF_RANGE;
; 345  : 				}
; 346  : #else
; 347  : 				return;	// begin() shouldn't be incremented, don't move

	jmp	$LN10@Dec@3
$LN8@Dec@3:

; 348  : #endif
; 349  : 			}

	jmp	$LN10@Dec@3
$LN9@Dec@3:

; 350  : 			else if (!_Isnil(_Left(_Ptr)))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T268571[ebp], edx
	mov	eax, DWORD PTR $T268571[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	jne	SHORT $LN34@Dec@3

; 351  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T268578[ebp], ecx
	mov	edx, DWORD PTR $T268578[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T268599[ebp], eax
$LN30@Dec@3:
	mov	ecx, DWORD PTR $T268599[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	SHORT $LN26@Dec@3
	mov	ecx, DWORD PTR $T268599[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T268599[ebp], edx
	jmp	SHORT $LN30@Dec@3
$LN26@Dec@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T268599[ebp]
	mov	DWORD PTR [eax], ecx

; 352  : 			else

	jmp	SHORT $LN10@Dec@3

; 353  : 				{	// climb looking for left subtree
; 354  : 				_Nodeptr _Pnode;
; 355  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 356  : 					&& _Ptr == _Left(_Pnode))

$LN34@Dec@3:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Pnode$225680[ebp], ecx
	mov	edx, DWORD PTR __Pnode$225680[ebp]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	SHORT $LN40@Dec@3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Pnode$225680[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN40@Dec@3

; 357  : 					_Ptr = _Pnode;	// ==> parent while left subtree

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Pnode$225680[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN34@Dec@3

; 358  : 				if (_Isnil(_Ptr))

$LN40@Dec@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	je	SHORT $LN2@Dec@3

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move

	jmp	SHORT $LN10@Dec@3

; 370  :  #endif
; 371  : 				else

	jmp	SHORT $LN10@Dec@3
$LN2@Dec@3:

; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$225680[ebp]
	mov	DWORD PTR [eax], ecx
$LN10@Dec@3:

; 373  : 				}
; 374  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Dec
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T268648 = -16						; size = 4
$T268627 = -12						; size = 4
$T268620 = -8						; size = 4
__Pnode$225692 = -4					; size = 4
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 377  : 			{	// move to node with next larger value

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 378  : 
; 379  :  #if _HAS_ITERATOR_DEBUGGING
; 380  : 			if (this->_Mycont == 0
; 381  : 				|| _Ptr == 0
; 382  : 				|| _Isnil(_Ptr))
; 383  : 				{
; 384  : 				_DEBUG_ERROR("map/set iterator not incrementable");
; 385  : 				_SCL_SECURE_OUT_OF_RANGE;
; 386  : 				}
; 387  :  #else
; 388  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 389  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	je	SHORT $LN6@Inc@3
	jmp	$LN7@Inc@3
$LN6@Inc@3:

; 390  : 				{
; 391  : 				_SCL_SECURE_OUT_OF_RANGE;
; 392  : 				// end() shouldn't be incremented, don't move if _SCL_SECURE is not turned on
; 393  : 				}
; 394  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 395  : 
; 396  : 			else if (!_Isnil(_Right(_Ptr)))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	mov	DWORD PTR $T268620[ebp], ecx
	mov	edx, DWORD PTR $T268620[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+21]
	test	ecx, ecx
	jne	SHORT $LN27@Inc@3

; 397  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 8
	mov	DWORD PTR $T268627[ebp], eax
	mov	ecx, DWORD PTR $T268627[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T268648[ebp], edx
$LN23@Inc@3:
	mov	eax, DWORD PTR $T268648[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	jne	SHORT $LN19@Inc@3
	mov	eax, DWORD PTR $T268648[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T268648[ebp], ecx
	jmp	SHORT $LN23@Inc@3
$LN19@Inc@3:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T268648[ebp]
	mov	DWORD PTR [edx], eax

; 398  : 			else

	jmp	SHORT $LN7@Inc@3

; 399  : 				{	// climb looking for right subtree
; 400  : 				_Nodeptr _Pnode;
; 401  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 402  : 					&& _Ptr == _Right(_Pnode))

$LN27@Inc@3:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$225692[ebp], eax
	mov	ecx, DWORD PTR __Pnode$225692[ebp]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	jne	SHORT $LN1@Inc@3
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$225692[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN1@Inc@3

; 403  : 					_Ptr = _Pnode;	// ==> parent while right subtree

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$225692[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN27@Inc@3
$LN1@Inc@3:

; 404  : 				_Ptr = _Pnode;	// ==> parent (head if end())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Pnode$225692[ebp]
	mov	DWORD PTR [edx], eax
$LN7@Inc@3:

; 405  : 				}
; 406  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Inc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z
_TEXT	SEGMENT
tv91 = -32						; size = 4
tv145 = -28						; size = 4
_this$ = -24						; size = 4
$T268685 = -19						; size = 1
$T268684 = -18						; size = 1
$T268676 = -17						; size = 1
$T268672 = -16						; size = 4
$T268665 = -8						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 52   : 		{	// construct traits from _Parg and allocator from _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T268684[ebp]
	mov	DWORD PTR $T268665[ebp], eax
	mov	ecx, DWORD PTR __Parg$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR $T268685[ebp], dl
	lea	eax, DWORD PTR $T268676[ebp]
	mov	DWORD PTR $T268672[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv145[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv91[ebp], edx

; 53   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::allocate
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$225760 = -4					; size = 4
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1166 : 		{	// free entire subtree, recursively

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1167 : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	eax, DWORD PTR __Rootnode$[ebp]
	mov	DWORD PTR __Pnode$225760[ebp], eax
	jmp	SHORT $LN6@Erase@2
$LN2@Erase@2:
	mov	ecx, DWORD PTR __Pnode$225760[ebp]
	mov	DWORD PTR __Rootnode$[ebp], ecx
$LN6@Erase@2:
	mov	edx, DWORD PTR __Pnode$225760[ebp]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	SHORT $LN4@Erase@2

; 1168 : 			{	// free subtrees, then node
; 1169 : 			_Erase(_Right(_Pnode));

	mov	ecx, DWORD PTR __Pnode$225760[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase

; 1170 : 			_Pnode = _Left(_Pnode);

	mov	eax, DWORD PTR __Pnode$225760[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$225760[ebp], ecx

; 1171 : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node
; 1172 : 			this->_Alnod.deallocate(_Rootnode, 1);

	mov	edx, DWORD PTR __Rootnode$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1173 : 			}

	jmp	SHORT $LN2@Erase@2
$LN4@Erase@2:

; 1174 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Copy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T268844 = -40						; size = 4
$T268831 = -36						; size = 4
$T268810 = -32						; size = 4
$T268797 = -28						; size = 4
$T268792 = -24						; size = 4
$T268771 = -20						; size = 4
$T268759 = -16						; size = 4
$T268750 = -12						; size = 4
$T268746 = -8						; size = 4
$T268737 = -4						; size = 4
__Right$ = 8						; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Copy, COMDAT
; _this$ = ecx

; 1062 : 		{	// copy entire tree from _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1063 : 		_Root() = _Copy(_Right._Root(), _Myhead);

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T268737[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 4
	mov	DWORD PTR $T268746[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR $T268737[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Copy
	mov	edx, DWORD PTR $T268746[ebp]
	mov	DWORD PTR [edx], eax

; 1064 : 		_Mysize = _Right.size();

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T268750[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T268750[ebp]
	mov	DWORD PTR [edx+8], eax

; 1065 : 		if (!_Isnil(_Root()))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T268759[ebp], edx
	mov	eax, DWORD PTR $T268759[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+33]
	test	edx, edx
	jne	SHORT $LN2@Copy@3

; 1066 : 			{	// nonempty tree, look for new smallest and largest
; 1067 : 			_Lmost() = _Min(_Root());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T268771[ebp], ecx
	mov	edx, DWORD PTR $T268771[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T268792[ebp], eax
$LN31@Copy@3:
	mov	ecx, DWORD PTR $T268792[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx+33]
	test	eax, eax
	jne	SHORT $LN27@Copy@3
	mov	ecx, DWORD PTR $T268792[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T268792[ebp], edx
	jmp	SHORT $LN31@Copy@3
$LN27@Copy@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T268797[ebp], ecx
	mov	edx, DWORD PTR $T268797[ebp]
	mov	eax, DWORD PTR $T268792[ebp]
	mov	DWORD PTR [edx], eax

; 1068 : 			_Rmost() = _Max(_Root());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T268810[ebp], edx
	mov	eax, DWORD PTR $T268810[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T268831[ebp], ecx
$LN49@Copy@3:
	mov	edx, DWORD PTR $T268831[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+33]
	test	ecx, ecx
	jne	SHORT $LN53@Copy@3
	mov	edx, DWORD PTR $T268831[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T268831[ebp], eax
	jmp	SHORT $LN49@Copy@3
$LN53@Copy@3:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR $T268831[ebp]
	mov	DWORD PTR [edx+8], eax

; 1069 : 			}
; 1070 : 		else

	jmp	SHORT $LN3@Copy@3
$LN2@Copy@3:

; 1071 : 			_Lmost() = _Myhead, _Rmost() = _Myhead;	// empty tree

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T268844[ebp], edx
	mov	eax, DWORD PTR $T268844[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+8], eax
$LN3@Copy@3:

; 1072 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Copy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$225814 = -4					; size = 4
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1166 : 		{	// free entire subtree, recursively

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1167 : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	eax, DWORD PTR __Rootnode$[ebp]
	mov	DWORD PTR __Pnode$225814[ebp], eax
	jmp	SHORT $LN6@Erase@3
$LN2@Erase@3:
	mov	ecx, DWORD PTR __Pnode$225814[ebp]
	mov	DWORD PTR __Rootnode$[ebp], ecx
$LN6@Erase@3:
	mov	edx, DWORD PTR __Pnode$225814[ebp]
	movsx	eax, BYTE PTR [edx+33]
	test	eax, eax
	jne	SHORT $LN4@Erase@3

; 1168 : 			{	// free subtrees, then node
; 1169 : 			_Erase(_Right(_Pnode));

	mov	ecx, DWORD PTR __Pnode$225814[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Erase

; 1170 : 			_Pnode = _Left(_Pnode);

	mov	eax, DWORD PTR __Pnode$225814[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$225814[ebp], ecx

; 1171 : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node
; 1172 : 			this->_Alnod.deallocate(_Rootnode, 1);

	mov	edx, DWORD PTR __Rootnode$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1173 : 			}

	jmp	SHORT $LN2@Erase@3
$LN4@Erase@3:

; 1174 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Erase
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z
_TEXT	SEGMENT
tv91 = -32						; size = 4
tv145 = -28						; size = 4
_this$ = -24						; size = 4
$T268906 = -19						; size = 1
$T268905 = -18						; size = 1
$T268897 = -17						; size = 1
$T268893 = -16						; size = 4
$T268886 = -8						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >, COMDAT
; _this$ = ecx

; 52   : 		{	// construct traits from _Parg and allocator from _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T268905[ebp]
	mov	DWORD PTR $T268886[ebp], eax
	mov	ecx, DWORD PTR __Parg$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR $T268906[ebp], dl
	lea	eax, DWORD PTR $T268897[ebp]
	mov	DWORD PTR $T268893[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv145[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv91[ebp], edx

; 53   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node>::allocate
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z
_TEXT	SEGMENT
tv87 = -20						; size = 4
_this$ = -16						; size = 4
$T268929 = -9						; size = 1
$T268925 = -8						; size = 4
__Parg$ = 8						; size = 1
__Al$ = 12						; size = 1
??0?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z PROC ; std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with specified comparator

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T268929[ebp]
	mov	DWORD PTR $T268925[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv87[ebp], ecx

; 40   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z ENDP ; std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
tv87 = -20						; size = 4
_this$ = -16						; size = 4
$T268941 = -9						; size = 1
$T268937 = -8						; size = 4
__Parg$ = 8						; size = 1
__Al$ = 12						; size = 1
??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with specified comparator

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T268941[ebp]
	mov	DWORD PTR $T268937[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv87[ebp], ecx

; 40   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@0@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@0@Z$0
__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@0@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@0@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@0@Z$2
__ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@0@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@0@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@0@Z
_TEXT	SEGMENT
tv141 = -40						; size = 4
tv153 = -36						; size = 4
_this$ = -32						; size = 4
__Pnode$225919 = -24					; size = 4
__Newroot$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Rootnode$ = 8						; size = 4
__Wherenode$ = 12					; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@0@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Copy, COMDAT
; _this$ = ecx

; 1075 : 		{	// copy entire subtree, recursively

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1076 : 		_Nodeptr _Newroot = _Myhead;	// point at nil node

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Newroot$[ebp], ecx

; 1077 : 
; 1078 : 		if (!_Isnil(_Rootnode))

	mov	edx, DWORD PTR __Rootnode$[ebp]
	movsx	eax, BYTE PTR [edx+33]
	test	eax, eax
	jne	$LN3@Copy@4

; 1079 : 			{	// copy a node, then any subtrees
; 1080 : 			_Nodeptr _Pnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1081 : 				_Myval(_Rootnode), _Color(_Rootnode));

	mov	ecx, DWORD PTR __Rootnode$[ebp]
	movzx	edx, BYTE PTR [ecx+32]
	push	edx
	mov	eax, DWORD PTR __Rootnode$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Buynode
	mov	DWORD PTR __Pnode$225919[ebp], eax

; 1082 : 			if (_Isnil(_Newroot))

	mov	eax, DWORD PTR __Newroot$[ebp]
	movsx	ecx, BYTE PTR [eax+33]
	test	ecx, ecx
	je	SHORT $LN2@Copy@4

; 1083 : 				_Newroot = _Pnode;	// memorize new root

	mov	edx, DWORD PTR __Pnode$225919[ebp]
	mov	DWORD PTR __Newroot$[ebp], edx
$LN2@Copy@4:

; 1084 : 
; 1085 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1086 : 			_Left(_Pnode) = _Copy(_Left(_Rootnode), _Pnode);

	mov	eax, DWORD PTR __Pnode$225919[ebp]
	push	eax
	mov	ecx, DWORD PTR __Rootnode$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Copy
	mov	DWORD PTR tv153[ebp], eax
	mov	eax, DWORD PTR __Pnode$225919[ebp]
	mov	ecx, DWORD PTR tv153[ebp]
	mov	DWORD PTR [eax], ecx

; 1087 : 			_Right(_Pnode) = _Copy(_Right(_Rootnode), _Pnode);

	mov	edx, DWORD PTR __Pnode$225919[ebp]
	push	edx
	mov	eax, DWORD PTR __Rootnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Copy
	mov	DWORD PTR tv141[ebp], eax
	mov	edx, DWORD PTR __Pnode$225919[ebp]
	mov	eax, DWORD PTR tv141[ebp]
	mov	DWORD PTR [edx+8], eax
	jmp	SHORT $LN6@Copy@4
__catch$?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@0@Z$0:

; 1088 : 			_CATCH_ALL
; 1089 : 			_Erase(_Newroot);	// subtree copy failed, bail out

	mov	ecx, DWORD PTR __Newroot$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Erase

; 1090 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1091 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN3@Copy@4
	ret	0
$LN6@Copy@4:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN3@Copy@4:

; 1092 : 			}
; 1093 : 
; 1094 : 		return (_Newroot);	// return newly constructed tree

	mov	eax, DWORD PTR __Newroot$[ebp]
$LN5@Copy@4:

; 1095 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@2@PAU342@0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Copy
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z
_TEXT	SEGMENT
tv87 = -20						; size = 4
_this$ = -16						; size = 4
$T269016 = -9						; size = 1
$T269012 = -8						; size = 4
__Parg$ = 8						; size = 1
__Al$ = 12						; size = 1
??0?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z PROC ; std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0>::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0>, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with specified comparator

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T269016[ebp]
	mov	DWORD PTR $T269012[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv87[ebp], ecx

; 40   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z ENDP ; std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0>::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0>
_TEXT	ENDS
PUBLIC	??$SerializeToSequenceContainer@W4GameOptionTypes@@V?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@Z ; SerializeToSequenceContainer<enum GameOptionTypes,std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> > >
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$?5W4GameOptionTypes@@@@YAAAVFDataStream@@AAV0@AAV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5W4GameOptionTypes@@@@YAAAVFDataStream@@AAV0@AAV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@Z PROC ; operator>><enum GameOptionTypes>, COMDAT

; 225  : {

	push	ebp
	mov	ebp, esp

; 226  : 	// The functor needs to be instantiated to properly resize the container based 
; 227  : 	// on how many elements the stream says it should have before passing it along
; 228  : 	// to std::for_each
; 229  : 	SerializeToSequenceContainer<ElementType, std::vector<ElementType> >(loadFrom, writeTo);

	mov	eax, DWORD PTR _writeTo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	push	ecx
	call	??$SerializeToSequenceContainer@W4GameOptionTypes@@V?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@Z ; SerializeToSequenceContainer<enum GameOptionTypes,std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> > >
	add	esp, 8

; 230  : 
; 231  : 	//std::for_each(writeTo.begin(), writeTo.end(), func);
; 232  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 233  : }

	pop	ebp
	ret	0
??$?5W4GameOptionTypes@@@@YAAAVFDataStream@@AAV0@AAV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@Z ENDP ; operator>><enum GameOptionTypes>
_TEXT	ENDS
PUBLIC	??$SerializeToSequenceContainer@W4VictoryTypes@@V?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@Z ; SerializeToSequenceContainer<enum VictoryTypes,std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> > >
; Function compile flags: /Odtp
;	COMDAT ??$?5W4VictoryTypes@@@@YAAAVFDataStream@@AAV0@AAV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5W4VictoryTypes@@@@YAAAVFDataStream@@AAV0@AAV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@Z PROC ; operator>><enum VictoryTypes>, COMDAT

; 225  : {

	push	ebp
	mov	ebp, esp

; 226  : 	// The functor needs to be instantiated to properly resize the container based 
; 227  : 	// on how many elements the stream says it should have before passing it along
; 228  : 	// to std::for_each
; 229  : 	SerializeToSequenceContainer<ElementType, std::vector<ElementType> >(loadFrom, writeTo);

	mov	eax, DWORD PTR _writeTo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	push	ecx
	call	??$SerializeToSequenceContainer@W4VictoryTypes@@V?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@Z ; SerializeToSequenceContainer<enum VictoryTypes,std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> > >
	add	esp, 8

; 230  : 
; 231  : 	//std::for_each(writeTo.begin(), writeTo.end(), func);
; 232  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 233  : }

	pop	ebp
	ret	0
??$?5W4VictoryTypes@@@@YAAAVFDataStream@@AAV0@AAV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@Z ENDP ; operator>><enum VictoryTypes>
_TEXT	ENDS
PUBLIC	??$SerializeToSequenceContainer@UPlayerInfo@CvReplayInfo@@V?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z ; SerializeToSequenceContainer<CvReplayInfo::PlayerInfo,std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> > >
; Function compile flags: /Odtp
;	COMDAT ??$?5UPlayerInfo@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@AAV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5UPlayerInfo@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@AAV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z PROC ; operator>><CvReplayInfo::PlayerInfo>, COMDAT

; 225  : {

	push	ebp
	mov	ebp, esp

; 226  : 	// The functor needs to be instantiated to properly resize the container based 
; 227  : 	// on how many elements the stream says it should have before passing it along
; 228  : 	// to std::for_each
; 229  : 	SerializeToSequenceContainer<ElementType, std::vector<ElementType> >(loadFrom, writeTo);

	mov	eax, DWORD PTR _writeTo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	push	ecx
	call	??$SerializeToSequenceContainer@UPlayerInfo@CvReplayInfo@@V?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z ; SerializeToSequenceContainer<CvReplayInfo::PlayerInfo,std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> > >
	add	esp, 8

; 230  : 
; 231  : 	//std::for_each(writeTo.begin(), writeTo.end(), func);
; 232  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 233  : }

	pop	ebp
	ret	0
??$?5UPlayerInfo@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@AAV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z ENDP ; operator>><CvReplayInfo::PlayerInfo>
_TEXT	ENDS
PUBLIC	??$SerializeToSequenceContainer@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ; SerializeToSequenceContainer<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
; Function compile flags: /Odtp
;	COMDAT ??$?5V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z PROC ; operator>><std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 225  : {

	push	ebp
	mov	ebp, esp

; 226  : 	// The functor needs to be instantiated to properly resize the container based 
; 227  : 	// on how many elements the stream says it should have before passing it along
; 228  : 	// to std::for_each
; 229  : 	SerializeToSequenceContainer<ElementType, std::vector<ElementType> >(loadFrom, writeTo);

	mov	eax, DWORD PTR _writeTo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	push	ecx
	call	??$SerializeToSequenceContainer@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ; SerializeToSequenceContainer<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
	add	esp, 8

; 230  : 
; 231  : 	//std::for_each(writeTo.begin(), writeTo.end(), func);
; 232  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 233  : }

	pop	ebp
	ret	0
??$?5V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ENDP ; operator>><std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	??$SerializeToSequenceContainer@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z ; SerializeToSequenceContainer<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > > >
; Function compile flags: /Odtp
;	COMDAT ??$?5V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z PROC ; operator>><std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >, COMDAT

; 225  : {

	push	ebp
	mov	ebp, esp

; 226  : 	// The functor needs to be instantiated to properly resize the container based 
; 227  : 	// on how many elements the stream says it should have before passing it along
; 228  : 	// to std::for_each
; 229  : 	SerializeToSequenceContainer<ElementType, std::vector<ElementType> >(loadFrom, writeTo);

	mov	eax, DWORD PTR _writeTo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	push	ecx
	call	??$SerializeToSequenceContainer@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z ; SerializeToSequenceContainer<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > > >
	add	esp, 8

; 230  : 
; 231  : 	//std::for_each(writeTo.begin(), writeTo.end(), func);
; 232  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 233  : }

	pop	ebp
	ret	0
??$?5V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z ENDP ; operator>><std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >
_TEXT	ENDS
PUBLIC	??$SerializeToSequenceContainer@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z ; SerializeToSequenceContainer<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > > >
; Function compile flags: /Odtp
;	COMDAT ??$?5V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z PROC ; operator>><std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >, COMDAT

; 225  : {

	push	ebp
	mov	ebp, esp

; 226  : 	// The functor needs to be instantiated to properly resize the container based 
; 227  : 	// on how many elements the stream says it should have before passing it along
; 228  : 	// to std::for_each
; 229  : 	SerializeToSequenceContainer<ElementType, std::vector<ElementType> >(loadFrom, writeTo);

	mov	eax, DWORD PTR _writeTo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	push	ecx
	call	??$SerializeToSequenceContainer@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z ; SerializeToSequenceContainer<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > > >
	add	esp, 8

; 230  : 
; 231  : 	//std::for_each(writeTo.begin(), writeTo.end(), func);
; 232  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 233  : }

	pop	ebp
	ret	0
??$?5V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z ENDP ; operator>><std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >
_TEXT	ENDS
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4GameOptionTypes@@@Z:PROC ; operator<<
; Function compile flags: /Odtp
;	COMDAT ??$?6W4GameOptionTypes@@@@YAAAVFDataStream@@AAV0@ABV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@Z
_TEXT	SEGMENT
$T269107 = -68						; size = 8
$T269106 = -60						; size = 4
$T269105 = -56						; size = 4
$T269087 = -52						; size = 4
__ChkFirst$269100 = -48					; size = 4
__ChkLast$269101 = -44					; size = 4
$T269064 = -40						; size = 4
$T269055 = -36						; size = 4
$T269043 = -32						; size = 4
$T269045 = -28						; size = 4
$T269034 = -24						; size = 8
$T269033 = -16						; size = 4
$T269032 = -12						; size = 4
$T269031 = -8						; size = 8
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??$?6W4GameOptionTypes@@@@YAAAVFDataStream@@AAV0@ABV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@Z PROC ; operator<<<enum GameOptionTypes>, COMDAT

; 198  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H

; 199  : 	std::for_each(readFrom.begin(), readFrom.end(), SerializeFromSequenceContainer<const ElementType, const std::vector<ElementType> >(saveTo, readFrom));

	mov	eax, DWORD PTR _saveTo$[ebp]
	mov	DWORD PTR $T269031[ebp], eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	DWORD PTR $T269031[ebp+4], ecx
	mov	edx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR $T269045[ebp], ecx
	mov	edx, DWORD PTR $T269031[ebp]
	mov	DWORD PTR $T269043[ebp], edx
	lea	eax, DWORD PTR $T269045[ebp]
	push	eax
	mov	ecx, DWORD PTR $T269043[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T269055[ebp], edx
	mov	eax, DWORD PTR $T269055[ebp]
	mov	DWORD PTR $T269032[ebp], eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T269064[ebp], edx
	mov	eax, DWORD PTR $T269064[ebp]
	mov	DWORD PTR $T269033[ebp], eax
	mov	ecx, DWORD PTR $T269031[ebp]
	mov	DWORD PTR $T269107[ebp], ecx
	mov	edx, DWORD PTR $T269031[ebp+4]
	mov	DWORD PTR $T269107[ebp+4], edx
	mov	eax, DWORD PTR $T269032[ebp]
	mov	DWORD PTR $T269106[ebp], eax
	mov	ecx, DWORD PTR $T269033[ebp]
	mov	DWORD PTR $T269105[ebp], ecx
	mov	edx, DWORD PTR $T269105[ebp]
	mov	DWORD PTR __ChkFirst$269100[ebp], edx
	mov	eax, DWORD PTR $T269106[ebp]
	mov	DWORD PTR __ChkLast$269101[ebp], eax
	jmp	SHORT $LN24@operator@7
$LN18@operator@7:
	mov	ecx, DWORD PTR __ChkFirst$269100[ebp]
	add	ecx, 4
	mov	DWORD PTR __ChkFirst$269100[ebp], ecx
$LN24@operator@7:
	mov	edx, DWORD PTR __ChkFirst$269100[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __ChkLast$269101[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN17@operator@7
	mov	eax, DWORD PTR __ChkFirst$269100[ebp]
	mov	DWORD PTR $T269087[ebp], eax
	mov	ecx, DWORD PTR $T269087[ebp]
	push	ecx
	mov	edx, DWORD PTR $T269107[ebp]
	push	edx
	call	??6@YAAAVFDataStream@@AAV0@ABW4GameOptionTypes@@@Z ; operator<<
	add	esp, 8
	jmp	SHORT $LN18@operator@7
$LN17@operator@7:
	mov	eax, DWORD PTR $T269107[ebp]
	mov	DWORD PTR $T269034[ebp], eax
	mov	ecx, DWORD PTR $T269107[ebp+4]
	mov	DWORD PTR $T269034[ebp+4], ecx

; 200  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 201  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?6W4GameOptionTypes@@@@YAAAVFDataStream@@AAV0@ABV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@Z ENDP ; operator<<<enum GameOptionTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?6W4VictoryTypes@@@@YAAAVFDataStream@@AAV0@ABV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@Z
_TEXT	SEGMENT
$T269186 = -68						; size = 8
$T269185 = -60						; size = 4
$T269184 = -56						; size = 4
$T269166 = -52						; size = 4
__ChkFirst$269179 = -48					; size = 4
__ChkLast$269180 = -44					; size = 4
$T269143 = -40						; size = 4
$T269134 = -36						; size = 4
$T269122 = -32						; size = 4
$T269124 = -28						; size = 4
$T269113 = -24						; size = 8
$T269112 = -16						; size = 4
$T269111 = -12						; size = 4
$T269110 = -8						; size = 8
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??$?6W4VictoryTypes@@@@YAAAVFDataStream@@AAV0@ABV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@Z PROC ; operator<<<enum VictoryTypes>, COMDAT

; 198  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H

; 199  : 	std::for_each(readFrom.begin(), readFrom.end(), SerializeFromSequenceContainer<const ElementType, const std::vector<ElementType> >(saveTo, readFrom));

	mov	eax, DWORD PTR _saveTo$[ebp]
	mov	DWORD PTR $T269110[ebp], eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	DWORD PTR $T269110[ebp+4], ecx
	mov	edx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR $T269124[ebp], ecx
	mov	edx, DWORD PTR $T269110[ebp]
	mov	DWORD PTR $T269122[ebp], edx
	lea	eax, DWORD PTR $T269124[ebp]
	push	eax
	mov	ecx, DWORD PTR $T269122[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T269134[ebp], edx
	mov	eax, DWORD PTR $T269134[ebp]
	mov	DWORD PTR $T269111[ebp], eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T269143[ebp], edx
	mov	eax, DWORD PTR $T269143[ebp]
	mov	DWORD PTR $T269112[ebp], eax
	mov	ecx, DWORD PTR $T269110[ebp]
	mov	DWORD PTR $T269186[ebp], ecx
	mov	edx, DWORD PTR $T269110[ebp+4]
	mov	DWORD PTR $T269186[ebp+4], edx
	mov	eax, DWORD PTR $T269111[ebp]
	mov	DWORD PTR $T269185[ebp], eax
	mov	ecx, DWORD PTR $T269112[ebp]
	mov	DWORD PTR $T269184[ebp], ecx
	mov	edx, DWORD PTR $T269184[ebp]
	mov	DWORD PTR __ChkFirst$269179[ebp], edx
	mov	eax, DWORD PTR $T269185[ebp]
	mov	DWORD PTR __ChkLast$269180[ebp], eax
	jmp	SHORT $LN24@operator@8
$LN18@operator@8:
	mov	ecx, DWORD PTR __ChkFirst$269179[ebp]
	add	ecx, 4
	mov	DWORD PTR __ChkFirst$269179[ebp], ecx
$LN24@operator@8:
	mov	edx, DWORD PTR __ChkFirst$269179[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __ChkLast$269180[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN17@operator@8
	mov	eax, DWORD PTR __ChkFirst$269179[ebp]
	mov	DWORD PTR $T269166[ebp], eax
	mov	ecx, DWORD PTR $T269166[ebp]
	push	ecx
	mov	edx, DWORD PTR $T269186[ebp]
	push	edx
	call	??6@YAAAVFDataStream@@AAV0@ABW4VictoryTypes@@@Z ; operator<<
	add	esp, 8
	jmp	SHORT $LN18@operator@8
$LN17@operator@8:
	mov	eax, DWORD PTR $T269186[ebp]
	mov	DWORD PTR $T269113[ebp], eax
	mov	ecx, DWORD PTR $T269186[ebp+4]
	mov	DWORD PTR $T269113[ebp+4], ecx

; 200  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 201  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?6W4VictoryTypes@@@@YAAAVFDataStream@@AAV0@ABV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@Z ENDP ; operator<<<enum VictoryTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?6UPlayerInfo@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@ABV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z
_TEXT	SEGMENT
$T269265 = -68						; size = 8
$T269264 = -60						; size = 4
$T269263 = -56						; size = 4
$T269245 = -52						; size = 4
__ChkFirst$269258 = -48					; size = 4
__ChkLast$269259 = -44					; size = 4
$T269222 = -40						; size = 4
$T269213 = -36						; size = 4
$T269201 = -32						; size = 4
$T269204 = -28						; size = 4
$T269192 = -24						; size = 8
$T269191 = -16						; size = 4
$T269190 = -12						; size = 4
$T269189 = -8						; size = 8
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??$?6UPlayerInfo@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@ABV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z PROC ; operator<<<CvReplayInfo::PlayerInfo>, COMDAT

; 198  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H

; 199  : 	std::for_each(readFrom.begin(), readFrom.end(), SerializeFromSequenceContainer<const ElementType, const std::vector<ElementType> >(saveTo, readFrom));

	mov	eax, DWORD PTR _saveTo$[ebp]
	mov	DWORD PTR $T269189[ebp], eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	DWORD PTR $T269189[ebp+4], ecx
	mov	edx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 7
	mov	DWORD PTR $T269204[ebp], ecx
	mov	edx, DWORD PTR $T269189[ebp]
	mov	DWORD PTR $T269201[ebp], edx
	lea	eax, DWORD PTR $T269204[ebp]
	push	eax
	mov	ecx, DWORD PTR $T269201[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T269213[ebp], edx
	mov	eax, DWORD PTR $T269213[ebp]
	mov	DWORD PTR $T269190[ebp], eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T269222[ebp], edx
	mov	eax, DWORD PTR $T269222[ebp]
	mov	DWORD PTR $T269191[ebp], eax
	mov	ecx, DWORD PTR $T269189[ebp]
	mov	DWORD PTR $T269265[ebp], ecx
	mov	edx, DWORD PTR $T269189[ebp+4]
	mov	DWORD PTR $T269265[ebp+4], edx
	mov	eax, DWORD PTR $T269190[ebp]
	mov	DWORD PTR $T269264[ebp], eax
	mov	ecx, DWORD PTR $T269191[ebp]
	mov	DWORD PTR $T269263[ebp], ecx
	mov	edx, DWORD PTR $T269263[ebp]
	mov	DWORD PTR __ChkFirst$269258[ebp], edx
	mov	eax, DWORD PTR $T269264[ebp]
	mov	DWORD PTR __ChkLast$269259[ebp], eax
	jmp	SHORT $LN24@operator@9
$LN18@operator@9:
	mov	ecx, DWORD PTR __ChkFirst$269258[ebp]
	add	ecx, 128				; 00000080H
	mov	DWORD PTR __ChkFirst$269258[ebp], ecx
$LN24@operator@9:
	mov	edx, DWORD PTR __ChkFirst$269258[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __ChkLast$269259[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN17@operator@9
	mov	eax, DWORD PTR __ChkFirst$269258[ebp]
	mov	DWORD PTR $T269245[ebp], eax
	mov	ecx, DWORD PTR $T269245[ebp]
	push	ecx
	mov	edx, DWORD PTR $T269265[ebp]
	push	edx
	call	??6@YAAAVFDataStream@@AAV0@ABUPlayerInfo@CvReplayInfo@@@Z ; operator<<
	add	esp, 8
	jmp	SHORT $LN18@operator@9
$LN17@operator@9:
	mov	eax, DWORD PTR $T269265[ebp]
	mov	DWORD PTR $T269192[ebp], eax
	mov	ecx, DWORD PTR $T269265[ebp+4]
	mov	DWORD PTR $T269192[ebp+4], ecx

; 200  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 201  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?6UPlayerInfo@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@ABV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z ENDP ; operator<<<CvReplayInfo::PlayerInfo>
_TEXT	ENDS
EXTRN	??6@YAAAVFDataStream@@AAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; operator<<
; Function compile flags: /Odtp
;	COMDAT ??$?6V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
_TEXT	SEGMENT
$T269344 = -68						; size = 8
$T269343 = -60						; size = 4
$T269342 = -56						; size = 4
$T269324 = -52						; size = 4
__ChkFirst$269334 = -48					; size = 4
__ChkLast$269335 = -44					; size = 4
$T269301 = -40						; size = 4
$T269292 = -36						; size = 4
$T269280 = -32						; size = 4
$T269283 = -28						; size = 4
$T269271 = -24						; size = 8
$T269270 = -16						; size = 4
$T269269 = -12						; size = 4
$T269268 = -8						; size = 8
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??$?6V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z PROC ; operator<<<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 198  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H

; 199  : 	std::for_each(readFrom.begin(), readFrom.end(), SerializeFromSequenceContainer<const ElementType, const std::vector<ElementType> >(saveTo, readFrom));

	mov	eax, DWORD PTR _saveTo$[ebp]
	mov	DWORD PTR $T269268[ebp], eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	DWORD PTR $T269268[ebp+4], ecx
	mov	edx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	mov	DWORD PTR $T269283[ebp], eax
	mov	edx, DWORD PTR $T269268[ebp]
	mov	DWORD PTR $T269280[ebp], edx
	lea	eax, DWORD PTR $T269283[ebp]
	push	eax
	mov	ecx, DWORD PTR $T269280[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T269292[ebp], edx
	mov	eax, DWORD PTR $T269292[ebp]
	mov	DWORD PTR $T269269[ebp], eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T269301[ebp], edx
	mov	eax, DWORD PTR $T269301[ebp]
	mov	DWORD PTR $T269270[ebp], eax
	mov	ecx, DWORD PTR $T269268[ebp]
	mov	DWORD PTR $T269344[ebp], ecx
	mov	edx, DWORD PTR $T269268[ebp+4]
	mov	DWORD PTR $T269344[ebp+4], edx
	mov	eax, DWORD PTR $T269269[ebp]
	mov	DWORD PTR $T269343[ebp], eax
	mov	ecx, DWORD PTR $T269270[ebp]
	mov	DWORD PTR $T269342[ebp], ecx
	mov	edx, DWORD PTR $T269342[ebp]
	mov	DWORD PTR __ChkFirst$269334[ebp], edx
	mov	eax, DWORD PTR $T269343[ebp]
	mov	DWORD PTR __ChkLast$269335[ebp], eax
	jmp	SHORT $LN24@operator@10
$LN18@operator@10:
	mov	ecx, DWORD PTR __ChkFirst$269334[ebp]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR __ChkFirst$269334[ebp], ecx
$LN24@operator@10:
	mov	edx, DWORD PTR __ChkFirst$269334[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __ChkLast$269335[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN17@operator@10
	mov	eax, DWORD PTR __ChkFirst$269334[ebp]
	mov	DWORD PTR $T269324[ebp], eax
	mov	ecx, DWORD PTR $T269324[ebp]
	push	ecx
	mov	edx, DWORD PTR $T269344[ebp]
	push	edx
	call	??6@YAAAVFDataStream@@AAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; operator<<
	add	esp, 8
	jmp	SHORT $LN18@operator@10
$LN17@operator@10:
	mov	eax, DWORD PTR $T269344[ebp]
	mov	DWORD PTR $T269271[ebp], eax
	mov	ecx, DWORD PTR $T269344[ebp+4]
	mov	DWORD PTR $T269271[ebp+4], ecx

; 200  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 201  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?6V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ENDP ; operator<<<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	??$?6V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z ; operator<<<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >
; Function compile flags: /Odtp
;	COMDAT ??$?6V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z
_TEXT	SEGMENT
$T269423 = -68						; size = 8
$T269422 = -60						; size = 4
$T269421 = -56						; size = 4
$T269403 = -52						; size = 4
__ChkFirst$269416 = -48					; size = 4
__ChkLast$269417 = -44					; size = 4
$T269380 = -40						; size = 4
$T269371 = -36						; size = 4
$T269359 = -32						; size = 4
$T269361 = -28						; size = 4
$T269350 = -24						; size = 8
$T269349 = -16						; size = 4
$T269348 = -12						; size = 4
$T269347 = -8						; size = 8
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??$?6V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z PROC ; operator<<<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >, COMDAT

; 198  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H

; 199  : 	std::for_each(readFrom.begin(), readFrom.end(), SerializeFromSequenceContainer<const ElementType, const std::vector<ElementType> >(saveTo, readFrom));

	mov	eax, DWORD PTR _saveTo$[ebp]
	mov	DWORD PTR $T269347[ebp], eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	DWORD PTR $T269347[ebp+4], ecx
	mov	edx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 4
	mov	DWORD PTR $T269361[ebp], ecx
	mov	edx, DWORD PTR $T269347[ebp]
	mov	DWORD PTR $T269359[ebp], edx
	lea	eax, DWORD PTR $T269361[ebp]
	push	eax
	mov	ecx, DWORD PTR $T269359[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T269371[ebp], edx
	mov	eax, DWORD PTR $T269371[ebp]
	mov	DWORD PTR $T269348[ebp], eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T269380[ebp], edx
	mov	eax, DWORD PTR $T269380[ebp]
	mov	DWORD PTR $T269349[ebp], eax
	mov	ecx, DWORD PTR $T269347[ebp]
	mov	DWORD PTR $T269423[ebp], ecx
	mov	edx, DWORD PTR $T269347[ebp+4]
	mov	DWORD PTR $T269423[ebp+4], edx
	mov	eax, DWORD PTR $T269348[ebp]
	mov	DWORD PTR $T269422[ebp], eax
	mov	ecx, DWORD PTR $T269349[ebp]
	mov	DWORD PTR $T269421[ebp], ecx
	mov	edx, DWORD PTR $T269421[ebp]
	mov	DWORD PTR __ChkFirst$269416[ebp], edx
	mov	eax, DWORD PTR $T269422[ebp]
	mov	DWORD PTR __ChkLast$269417[ebp], eax
	jmp	SHORT $LN24@operator@11
$LN18@operator@11:
	mov	ecx, DWORD PTR __ChkFirst$269416[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __ChkFirst$269416[ebp], ecx
$LN24@operator@11:
	mov	edx, DWORD PTR __ChkFirst$269416[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __ChkLast$269417[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN17@operator@11
	mov	eax, DWORD PTR __ChkFirst$269416[ebp]
	mov	DWORD PTR $T269403[ebp], eax
	mov	ecx, DWORD PTR $T269403[ebp]
	push	ecx
	mov	edx, DWORD PTR $T269423[ebp]
	push	edx
	call	??$?6V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z ; operator<<<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >
	add	esp, 8
	jmp	SHORT $LN18@operator@11
$LN17@operator@11:
	mov	eax, DWORD PTR $T269423[ebp]
	mov	DWORD PTR $T269350[ebp], eax
	mov	ecx, DWORD PTR $T269423[ebp+4]
	mov	DWORD PTR $T269350[ebp+4], ecx

; 200  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 201  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?6V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z ENDP ; operator<<<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >
_TEXT	ENDS
PUBLIC	??$?6IUPlotState@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@ABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@Z ; operator<<<unsigned int,CvReplayInfo::PlotState>
; Function compile flags: /Odtp
;	COMDAT ??$?6V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z
_TEXT	SEGMENT
$T269502 = -68						; size = 8
$T269501 = -60						; size = 4
$T269500 = -56						; size = 4
$T269482 = -52						; size = 4
__ChkFirst$269495 = -48					; size = 4
__ChkLast$269496 = -44					; size = 4
$T269459 = -40						; size = 4
$T269450 = -36						; size = 4
$T269438 = -32						; size = 4
$T269440 = -28						; size = 4
$T269429 = -24						; size = 8
$T269428 = -16						; size = 4
$T269427 = -12						; size = 4
$T269426 = -8						; size = 8
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??$?6V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z PROC ; operator<<<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >, COMDAT

; 198  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H

; 199  : 	std::for_each(readFrom.begin(), readFrom.end(), SerializeFromSequenceContainer<const ElementType, const std::vector<ElementType> >(saveTo, readFrom));

	mov	eax, DWORD PTR _saveTo$[ebp]
	mov	DWORD PTR $T269426[ebp], eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	DWORD PTR $T269426[ebp+4], ecx
	mov	edx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR $T269440[ebp], eax
	mov	edx, DWORD PTR $T269426[ebp]
	mov	DWORD PTR $T269438[ebp], edx
	lea	eax, DWORD PTR $T269440[ebp]
	push	eax
	mov	ecx, DWORD PTR $T269438[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T269450[ebp], edx
	mov	eax, DWORD PTR $T269450[ebp]
	mov	DWORD PTR $T269427[ebp], eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T269459[ebp], edx
	mov	eax, DWORD PTR $T269459[ebp]
	mov	DWORD PTR $T269428[ebp], eax
	mov	ecx, DWORD PTR $T269426[ebp]
	mov	DWORD PTR $T269502[ebp], ecx
	mov	edx, DWORD PTR $T269426[ebp+4]
	mov	DWORD PTR $T269502[ebp+4], edx
	mov	eax, DWORD PTR $T269427[ebp]
	mov	DWORD PTR $T269501[ebp], eax
	mov	ecx, DWORD PTR $T269428[ebp]
	mov	DWORD PTR $T269500[ebp], ecx
	mov	edx, DWORD PTR $T269500[ebp]
	mov	DWORD PTR __ChkFirst$269495[ebp], edx
	mov	eax, DWORD PTR $T269501[ebp]
	mov	DWORD PTR __ChkLast$269496[ebp], eax
	jmp	SHORT $LN24@operator@12
$LN18@operator@12:
	mov	ecx, DWORD PTR __ChkFirst$269495[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR __ChkFirst$269495[ebp], ecx
$LN24@operator@12:
	mov	edx, DWORD PTR __ChkFirst$269495[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __ChkLast$269496[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN17@operator@12
	mov	eax, DWORD PTR __ChkFirst$269495[ebp]
	mov	DWORD PTR $T269482[ebp], eax
	mov	ecx, DWORD PTR $T269482[ebp]
	push	ecx
	mov	edx, DWORD PTR $T269502[ebp]
	push	edx
	call	??$?6IUPlotState@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@ABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@Z ; operator<<<unsigned int,CvReplayInfo::PlotState>
	add	esp, 8
	jmp	SHORT $LN18@operator@12
$LN17@operator@12:
	mov	eax, DWORD PTR $T269502[ebp]
	mov	DWORD PTR $T269429[ebp], eax
	mov	ecx, DWORD PTR $T269502[ebp+4]
	mov	DWORD PTR $T269429[ebp+4], ecx

; 200  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 201  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?6V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z ENDP ; operator<<<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R0?AVbad_alloc@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
xdata$x	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_Ebad_alloc@std@@UAEPAXI@Z ; std::bad_alloc::`vftable'
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
CONST	ENDS
;	COMDAT ??$_Allocate@VCvReplayMessage@@@std@@YAPAVCvReplayMessage@@IPAV1@@Z
_TEXT	SEGMENT
$T269509 = -16						; size = 4
$T269505 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@VCvReplayMessage@@@std@@YAPAVCvReplayMessage@@IPAV1@@Z PROC ; std::_Allocate<CvReplayMessage>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 60					; 0000003cH
	jae	SHORT $LN2@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T269509[ebp], 0
	lea	eax, DWORD PTR $T269509[ebp]
	push	eax
	lea	ecx, DWORD PTR $T269505[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T269505[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T269505[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 60					; 0000003cH
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@VCvReplayMessage@@@std@@YAPAVCvReplayMessage@@IPAV1@@Z ENDP ; std::_Allocate<CvReplayMessage>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar@6
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@6:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IPAV10@@Z
_TEXT	SEGMENT
$T269523 = -16						; size = 4
$T269519 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IPAV10@@Z PROC ; std::_Allocate<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@2
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 12					; 0000000cH
	jae	SHORT $LN2@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T269523[ebp], 0
	lea	eax, DWORD PTR $T269523[ebp]
	push	eax
	lea	ecx, DWORD PTR $T269519[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T269519[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T269519[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 12					; 0000000cH
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@2:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IPAV10@@Z ENDP ; std::_Allocate<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z
_TEXT	SEGMENT
$T269530 = -16						; size = 4
$T269526 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z PROC ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@3

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@3
$LN3@Allocate@3:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 28					; 0000001cH
	jae	SHORT $LN2@Allocate@3

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T269530[ebp], 0
	lea	eax, DWORD PTR $T269530[ebp]
	push	eax
	lea	ecx, DWORD PTR $T269526[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T269526[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T269526[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@3:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 28					; 0000001cH
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@3:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z ENDP ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Unchecked_move_backward@PAVCvReplayMessage@@PAV1@@stdext@@YAPAVCvReplayMessage@@PAV1@00@Z
_TEXT	SEGMENT
$T269881 = -206						; size = 1
$T269880 = -205						; size = 1
$T269879 = -204						; size = 4
$T269878 = -200						; size = 4
$T269866 = -193						; size = 1
$T269865 = -192						; size = 4
$T269864 = -188						; size = 4
$T269863 = -184						; size = 4
__Cat$269871 = -8					; size = 1
$T269869 = -7						; size = 1
$T269868 = -6						; size = 1
__Cat$269539 = -4					; size = 1
$T269535 = -3						; size = 1
$T269534 = -2						; size = 1
$T269533 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAVCvReplayMessage@@PAV1@@stdext@@YAPAVCvReplayMessage@@PAV1@00@Z PROC ; stdext::_Unchecked_move_backward<CvReplayMessage *,CvReplayMessage *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T269533[ebp], al
	mov	cl, BYTE PTR __Cat$269539[ebp]
	mov	BYTE PTR $T269534[ebp], cl
	mov	dl, BYTE PTR $T269533[ebp]
	mov	BYTE PTR $T269881[ebp], dl
	mov	al, BYTE PTR $T269535[ebp]
	mov	BYTE PTR $T269880[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T269879[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T269878[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T269868[ebp], al
	mov	cl, BYTE PTR __Cat$269871[ebp]
	mov	BYTE PTR $T269869[ebp], cl
	mov	dl, BYTE PTR $T269868[ebp]
	mov	BYTE PTR $T269866[ebp], dl
	mov	eax, DWORD PTR $T269879[ebp]
	mov	DWORD PTR $T269865[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T269864[ebp], ecx
	mov	edx, DWORD PTR $T269878[ebp]
	mov	DWORD PTR $T269863[ebp], edx
$LN12@Unchecked_:
	mov	eax, DWORD PTR $T269863[ebp]
	cmp	eax, DWORD PTR $T269864[ebp]
	je	SHORT $LN7@Unchecked_
	mov	ecx, DWORD PTR $T269864[ebp]
	sub	ecx, 60					; 0000003cH
	mov	DWORD PTR $T269864[ebp], ecx
	mov	edx, DWORD PTR $T269865[ebp]
	sub	edx, 60					; 0000003cH
	mov	DWORD PTR $T269865[ebp], edx
	mov	eax, DWORD PTR $T269864[ebp]
	push	eax
	mov	ecx, DWORD PTR $T269865[ebp]
	call	??4CvReplayMessage@@QAEAAV0@ABV0@@Z
	jmp	SHORT $LN12@Unchecked_
$LN7@Unchecked_:
	mov	eax, DWORD PTR $T269865[ebp]

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAVCvReplayMessage@@PAV1@@stdext@@YAPAVCvReplayMessage@@PAV1@00@Z ENDP ; stdext::_Unchecked_move_backward<CvReplayMessage *,CvReplayMessage *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@W4GameOptionTypes@@@std@@YAPAW4GameOptionTypes@@IPAW41@@Z
_TEXT	SEGMENT
$T269888 = -16						; size = 4
$T269884 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@W4GameOptionTypes@@@std@@YAPAW4GameOptionTypes@@IPAW41@@Z PROC ; std::_Allocate<enum GameOptionTypes>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@4

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@4
$LN3@Allocate@4:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@4

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T269888[ebp], 0
	lea	eax, DWORD PTR $T269888[ebp]
	push	eax
	lea	ecx, DWORD PTR $T269884[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T269884[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T269884[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@4:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@4:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@W4GameOptionTypes@@@std@@YAPAW4GameOptionTypes@@IPAW41@@Z ENDP ; std::_Allocate<enum GameOptionTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@W4VictoryTypes@@@std@@YAPAW4VictoryTypes@@IPAW41@@Z
_TEXT	SEGMENT
$T269895 = -16						; size = 4
$T269891 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@W4VictoryTypes@@@std@@YAPAW4VictoryTypes@@IPAW41@@Z PROC ; std::_Allocate<enum VictoryTypes>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@5

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@5
$LN3@Allocate@5:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@5

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T269895[ebp], 0
	lea	eax, DWORD PTR $T269895[ebp]
	push	eax
	lea	ecx, DWORD PTR $T269891[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T269891[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T269891[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@5:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@5:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@W4VictoryTypes@@@std@@YAPAW4VictoryTypes@@IPAW41@@Z ENDP ; std::_Allocate<enum VictoryTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@UPlayerInfo@CvReplayInfo@@@std@@YAPAUPlayerInfo@CvReplayInfo@@IPAU12@@Z
_TEXT	SEGMENT
$T269902 = -16						; size = 4
$T269898 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UPlayerInfo@CvReplayInfo@@@std@@YAPAUPlayerInfo@CvReplayInfo@@IPAU12@@Z PROC ; std::_Allocate<CvReplayInfo::PlayerInfo>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@6

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@6
$LN3@Allocate@6:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 128				; 00000080H
	jae	SHORT $LN2@Allocate@6

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T269902[ebp], 0
	lea	eax, DWORD PTR $T269902[ebp]
	push	eax
	lea	ecx, DWORD PTR $T269898[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T269898[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T269898[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@6:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 7
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@6:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@UPlayerInfo@CvReplayInfo@@@std@@YAPAUPlayerInfo@CvReplayInfo@@IPAU12@@Z ENDP ; std::_Allocate<CvReplayInfo::PlayerInfo>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IPAV10@@Z
_TEXT	SEGMENT
$T269909 = -16						; size = 4
$T269905 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IPAV10@@Z PROC ; std::_Allocate<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@7

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@7
$LN3@Allocate@7:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 16					; 00000010H
	jae	SHORT $LN2@Allocate@7

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T269909[ebp], 0
	lea	eax, DWORD PTR $T269909[ebp]
	push	eax
	lea	ecx, DWORD PTR $T269905[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T269905[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T269905[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@7:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 4
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@7:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IPAV10@@Z ENDP ; std::_Allocate<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@U?$pair@FF@std@@@std@@YAPAU?$pair@FF@0@IPAU10@@Z
_TEXT	SEGMENT
$T269916 = -16						; size = 4
$T269912 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U?$pair@FF@std@@@std@@YAPAU?$pair@FF@0@IPAU10@@Z PROC ; std::_Allocate<std::pair<short,short> >, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@8

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@8
$LN3@Allocate@8:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@8

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T269916[ebp], 0
	lea	eax, DWORD PTR $T269916[ebp]
	push	eax
	lea	ecx, DWORD PTR $T269912[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T269912[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T269912[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@8:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@8:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@U?$pair@FF@std@@@std@@YAPAU?$pair@FF@0@IPAU10@@Z ENDP ; std::_Allocate<std::pair<short,short> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IPAV10@@Z
_TEXT	SEGMENT
$T269923 = -16						; size = 4
$T269919 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IPAV10@@Z PROC ; std::_Allocate<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@9

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@9
$LN3@Allocate@9:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 12					; 0000000cH
	jae	SHORT $LN2@Allocate@9

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T269923[ebp], 0
	lea	eax, DWORD PTR $T269923[ebp]
	push	eax
	lea	ecx, DWORD PTR $T269919[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T269919[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T269919[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@9:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 12					; 0000000cH
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@9:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IPAV10@@Z ENDP ; std::_Allocate<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T269930 = -16						; size = 4
$T269926 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@10

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@10
$LN3@Allocate@10:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 24					; 00000018H
	jae	SHORT $LN2@Allocate@10

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T269930[ebp], 0
	lea	eax, DWORD PTR $T269930[ebp]
	push	eax
	lea	ecx, DWORD PTR $T269926[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T269926[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T269926[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@10:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 24					; 00000018H
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@10:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T269937 = -16						; size = 4
$T269933 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@11

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@11
$LN3@Allocate@11:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 24					; 00000018H
	jae	SHORT $LN2@Allocate@11

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T269937[ebp], 0
	lea	eax, DWORD PTR $T269937[ebp]
	push	eax
	lea	ecx, DWORD PTR $T269933[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T269933[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T269933[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@11:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 24					; 00000018H
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@11:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T269944 = -16						; size = 4
$T269940 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@12

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@12
$LN3@Allocate@12:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 36					; 00000024H
	jae	SHORT $LN2@Allocate@12

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T269944[ebp], 0
	lea	eax, DWORD PTR $T269944[ebp]
	push	eax
	lea	ecx, DWORD PTR $T269940[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T269940[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T269940[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@12:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 36					; 00000024H
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@12:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Node>
_TEXT	ENDS
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4GameOptionTypes@@@Z:PROC ; operator>>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$SerializeToSequenceContainer@W4GameOptionTypes@@V?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@Z
_TEXT	SEGMENT
$T269978 = -40						; size = 4
$T269962 = -36						; size = 4
$T270131 = -32						; size = 4
$T270130 = -28						; size = 4
$T270129 = -24						; size = 4
$T270128 = -20						; size = 4
$T270127 = -16						; size = 4
_v$228204 = -12						; size = 4
_i$ = -8						; size = 4
_count$ = -4						; size = 4
_loadFrom$ = 8						; size = 4
_container$ = 12					; size = 4
??$SerializeToSequenceContainer@W4GameOptionTypes@@V?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@Z PROC ; SerializeToSequenceContainer<enum GameOptionTypes,std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> > >, COMDAT

; 83   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 160				; 000000a0H

; 84   : 	container.clear();

	mov	eax, DWORD PTR _container$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T269962[ebp], ecx
	mov	edx, DWORD PTR $T269962[ebp]
	mov	DWORD PTR $T270128[ebp], edx
	mov	eax, DWORD PTR $T270128[ebp]
	mov	DWORD PTR $T270127[ebp], eax
	mov	ecx, DWORD PTR _container$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T269978[ebp], edx
	mov	eax, DWORD PTR $T269978[ebp]
	mov	DWORD PTR $T270130[ebp], eax
	mov	ecx, DWORD PTR $T270130[ebp]
	mov	DWORD PTR $T270129[ebp], ecx
	mov	edx, DWORD PTR $T270127[ebp]
	push	edx
	mov	eax, DWORD PTR $T270129[ebp]
	push	eax
	lea	ecx, DWORD PTR $T270131[ebp]
	push	ecx
	mov	ecx, DWORD PTR _container$[ebp]
	call	?erase@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@V?$_Vector_const_iterator@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@2@0@Z ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::erase

; 85   : 	ContainerType::size_type count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 86   : 	loadFrom >> count;

	lea	edx, DWORD PTR _count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 87   : 	ContainerType::size_type i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 88   : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@SerializeT
$LN2@SerializeT:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@SerializeT:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _count$[ebp]
	jae	SHORT $LN4@SerializeT

; 89   : 	{
; 90   : 		ElementType v;
; 91   : 		loadFrom >> v;

	lea	edx, DWORD PTR _v$228204[ebp]
	push	edx
	mov	eax, DWORD PTR _loadFrom$[ebp]
	push	eax
	call	??5@YAAAVFDataStream@@AAV0@AAW4GameOptionTypes@@@Z ; operator>>
	add	esp, 8

; 92   : 		container.push_back(v);

	lea	ecx, DWORD PTR _v$228204[ebp]
	push	ecx
	mov	ecx, DWORD PTR _container$[ebp]
	call	?push_back@?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@QAEXABW4GameOptionTypes@@@Z ; std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> >::push_back

; 93   : 	}

	jmp	SHORT $LN2@SerializeT
$LN4@SerializeT:

; 94   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$SerializeToSequenceContainer@W4GameOptionTypes@@V?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@W4GameOptionTypes@@V?$allocator@W4GameOptionTypes@@@std@@@std@@@Z ENDP ; SerializeToSequenceContainer<enum GameOptionTypes,std::vector<enum GameOptionTypes,std::allocator<enum GameOptionTypes> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$SerializeToSequenceContainer@W4VictoryTypes@@V?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@Z
_TEXT	SEGMENT
$T270297 = -40						; size = 4
$T270281 = -36						; size = 4
$T270450 = -32						; size = 4
$T270449 = -28						; size = 4
$T270448 = -24						; size = 4
$T270447 = -20						; size = 4
$T270446 = -16						; size = 4
_v$228214 = -12						; size = 4
_i$ = -8						; size = 4
_count$ = -4						; size = 4
_loadFrom$ = 8						; size = 4
_container$ = 12					; size = 4
??$SerializeToSequenceContainer@W4VictoryTypes@@V?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@Z PROC ; SerializeToSequenceContainer<enum VictoryTypes,std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> > >, COMDAT

; 83   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 160				; 000000a0H

; 84   : 	container.clear();

	mov	eax, DWORD PTR _container$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T270281[ebp], ecx
	mov	edx, DWORD PTR $T270281[ebp]
	mov	DWORD PTR $T270447[ebp], edx
	mov	eax, DWORD PTR $T270447[ebp]
	mov	DWORD PTR $T270446[ebp], eax
	mov	ecx, DWORD PTR _container$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T270297[ebp], edx
	mov	eax, DWORD PTR $T270297[ebp]
	mov	DWORD PTR $T270449[ebp], eax
	mov	ecx, DWORD PTR $T270449[ebp]
	mov	DWORD PTR $T270448[ebp], ecx
	mov	edx, DWORD PTR $T270446[ebp]
	push	edx
	mov	eax, DWORD PTR $T270448[ebp]
	push	eax
	lea	ecx, DWORD PTR $T270450[ebp]
	push	ecx
	mov	ecx, DWORD PTR _container$[ebp]
	call	?erase@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@V?$_Vector_const_iterator@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@2@0@Z ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::erase

; 85   : 	ContainerType::size_type count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 86   : 	loadFrom >> count;

	lea	edx, DWORD PTR _count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 87   : 	ContainerType::size_type i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 88   : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@SerializeT@2
$LN2@SerializeT@2:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@SerializeT@2:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _count$[ebp]
	jae	SHORT $LN4@SerializeT@2

; 89   : 	{
; 90   : 		ElementType v;
; 91   : 		loadFrom >> v;

	lea	edx, DWORD PTR _v$228214[ebp]
	push	edx
	mov	eax, DWORD PTR _loadFrom$[ebp]
	push	eax
	call	??5@YAAAVFDataStream@@AAV0@AAW4VictoryTypes@@@Z ; operator>>
	add	esp, 8

; 92   : 		container.push_back(v);

	lea	ecx, DWORD PTR _v$228214[ebp]
	push	ecx
	mov	ecx, DWORD PTR _container$[ebp]
	call	?push_back@?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@QAEXABW4VictoryTypes@@@Z ; std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> >::push_back

; 93   : 	}

	jmp	SHORT $LN2@SerializeT@2
$LN4@SerializeT@2:

; 94   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$SerializeToSequenceContainer@W4VictoryTypes@@V?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@W4VictoryTypes@@V?$allocator@W4VictoryTypes@@@std@@@std@@@Z ENDP ; SerializeToSequenceContainer<enum VictoryTypes,std::vector<enum VictoryTypes,std::allocator<enum VictoryTypes> > >
_TEXT	ENDS
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$SerializeToSequenceContainer@UPlayerInfo@CvReplayInfo@@V?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$SerializeToSequenceContainer@UPlayerInfo@CvReplayInfo@@V?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z$0
__ehfuncinfo$??$SerializeToSequenceContainer@UPlayerInfo@CvReplayInfo@@V?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$SerializeToSequenceContainer@UPlayerInfo@CvReplayInfo@@V?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
xdata$x	ENDS
;	COMDAT ??$SerializeToSequenceContainer@UPlayerInfo@CvReplayInfo@@V?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z
_TEXT	SEGMENT
$T270618 = -184						; size = 4
$T270602 = -180						; size = 4
$T270751 = -176						; size = 4
$T270750 = -172						; size = 4
$T270749 = -168						; size = 4
$T270748 = -164						; size = 4
$T270747 = -160						; size = 4
_v$228221 = -156					; size = 128
__$ArrayPad$ = -24					; size = 4
_i$ = -20						; size = 4
_count$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_loadFrom$ = 8						; size = 4
_container$ = 12					; size = 4
??$SerializeToSequenceContainer@UPlayerInfo@CvReplayInfo@@V?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z PROC ; SerializeToSequenceContainer<CvReplayInfo::PlayerInfo,std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> > >, COMDAT

; 83   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$SerializeToSequenceContainer@UPlayerInfo@CvReplayInfo@@V?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 84   : 	container.clear();

	mov	eax, DWORD PTR _container$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T270602[ebp], ecx
	mov	edx, DWORD PTR $T270602[ebp]
	mov	DWORD PTR $T270748[ebp], edx
	mov	eax, DWORD PTR $T270748[ebp]
	mov	DWORD PTR $T270747[ebp], eax
	mov	ecx, DWORD PTR _container$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T270618[ebp], edx
	mov	eax, DWORD PTR $T270618[ebp]
	mov	DWORD PTR $T270750[ebp], eax
	mov	ecx, DWORD PTR $T270750[ebp]
	mov	DWORD PTR $T270749[ebp], ecx
	mov	edx, DWORD PTR $T270747[ebp]
	push	edx
	mov	eax, DWORD PTR $T270749[ebp]
	push	eax
	lea	ecx, DWORD PTR $T270751[ebp]
	push	ecx
	mov	ecx, DWORD PTR _container$[ebp]
	call	?erase@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@V?$_Vector_const_iterator@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@2@0@Z ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::erase

; 85   : 	ContainerType::size_type count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 86   : 	loadFrom >> count;

	lea	edx, DWORD PTR _count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 87   : 	ContainerType::size_type i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 88   : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@SerializeT@3
$LN2@SerializeT@3:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@SerializeT@3:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _count$[ebp]
	jae	SHORT $LN4@SerializeT@3

; 89   : 	{
; 90   : 		ElementType v;

	lea	ecx, DWORD PTR _v$228221[ebp]
	call	??0PlayerInfo@CvReplayInfo@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 91   : 		loadFrom >> v;

	lea	edx, DWORD PTR _v$228221[ebp]
	push	edx
	mov	eax, DWORD PTR _loadFrom$[ebp]
	push	eax
	call	??5@YAAAVFDataStream@@AAV0@AAUPlayerInfo@CvReplayInfo@@@Z ; operator>>
	add	esp, 8

; 92   : 		container.push_back(v);

	lea	ecx, DWORD PTR _v$228221[ebp]
	push	ecx
	mov	ecx, DWORD PTR _container$[ebp]
	call	?push_back@?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@QAEXABUPlayerInfo@CvReplayInfo@@@Z ; std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >::push_back

; 93   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _v$228221[ebp]
	call	??1PlayerInfo@CvReplayInfo@@QAE@XZ
	jmp	SHORT $LN2@SerializeT@3
$LN4@SerializeT@3:

; 94   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$SerializeToSequenceContainer@UPlayerInfo@CvReplayInfo@@V?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z$0:
	lea	ecx, DWORD PTR _v$228221[ebp]
	jmp	??1PlayerInfo@CvReplayInfo@@QAE@XZ
__ehhandler$??$SerializeToSequenceContainer@UPlayerInfo@CvReplayInfo@@V?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-300]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$SerializeToSequenceContainer@UPlayerInfo@CvReplayInfo@@V?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$SerializeToSequenceContainer@UPlayerInfo@CvReplayInfo@@V?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UPlayerInfo@CvReplayInfo@@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@@Z ENDP ; SerializeToSequenceContainer<CvReplayInfo::PlayerInfo,std::vector<CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> > >
PUBLIC	__$ArrayPad$
EXTRN	??5@YAAAVFDataStream@@AAV0@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; operator>>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$??$SerializeToSequenceContainer@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$SerializeToSequenceContainer@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$0
__ehfuncinfo$??$SerializeToSequenceContainer@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$SerializeToSequenceContainer@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
xdata$x	ENDS
;	COMDAT ??$SerializeToSequenceContainer@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
_TEXT	SEGMENT
$T270974 = -80						; size = 4
$T270958 = -76						; size = 4
$T271107 = -72						; size = 4
$T271106 = -68						; size = 4
$T271105 = -64						; size = 4
$T271104 = -60						; size = 4
$T271103 = -56						; size = 4
_v$228231 = -52						; size = 28
__$ArrayPad$ = -24					; size = 4
_i$ = -20						; size = 4
_count$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_loadFrom$ = 8						; size = 4
_container$ = 12					; size = 4
??$SerializeToSequenceContainer@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z PROC ; SerializeToSequenceContainer<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT

; 83   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$SerializeToSequenceContainer@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 160				; 000000a0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 84   : 	container.clear();

	mov	eax, DWORD PTR _container$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T270958[ebp], ecx
	mov	edx, DWORD PTR $T270958[ebp]
	mov	DWORD PTR $T271104[ebp], edx
	mov	eax, DWORD PTR $T271104[ebp]
	mov	DWORD PTR $T271103[ebp], eax
	mov	ecx, DWORD PTR _container$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T270974[ebp], edx
	mov	eax, DWORD PTR $T270974[ebp]
	mov	DWORD PTR $T271106[ebp], eax
	mov	ecx, DWORD PTR $T271106[ebp]
	mov	DWORD PTR $T271105[ebp], ecx
	mov	edx, DWORD PTR $T271103[ebp]
	push	edx
	mov	eax, DWORD PTR $T271105[ebp]
	push	eax
	lea	ecx, DWORD PTR $T271107[ebp]
	push	ecx
	mov	ecx, DWORD PTR _container$[ebp]
	call	?erase@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::erase

; 85   : 	ContainerType::size_type count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 86   : 	loadFrom >> count;

	lea	edx, DWORD PTR _count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 87   : 	ContainerType::size_type i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 88   : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@SerializeT@4
$LN2@SerializeT@4:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@SerializeT@4:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _count$[ebp]
	jae	SHORT $LN4@SerializeT@4

; 89   : 	{
; 90   : 		ElementType v;

	lea	ecx, DWORD PTR _v$228231[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 91   : 		loadFrom >> v;

	lea	edx, DWORD PTR _v$228231[ebp]
	push	edx
	mov	eax, DWORD PTR _loadFrom$[ebp]
	push	eax
	call	??5@YAAAVFDataStream@@AAV0@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; operator>>
	add	esp, 8

; 92   : 		container.push_back(v);

	lea	ecx, DWORD PTR _v$228231[ebp]
	push	ecx
	mov	ecx, DWORD PTR _container$[ebp]
	call	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back

; 93   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _v$228231[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	SHORT $LN2@SerializeT@4
$LN4@SerializeT@4:

; 94   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$SerializeToSequenceContainer@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$0:
	lea	ecx, DWORD PTR _v$228231[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??$SerializeToSequenceContainer@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-164]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$SerializeToSequenceContainer@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$SerializeToSequenceContainer@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ENDP ; SerializeToSequenceContainer<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??$?5V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z ; operator>><std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >
PUBLIC	??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??$SerializeToSequenceContainer@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$SerializeToSequenceContainer@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$SerializeToSequenceContainer@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z$5
__ehfuncinfo$??$SerializeToSequenceContainer@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$SerializeToSequenceContainer@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
xdata$x	ENDS
;	COMDAT ??$SerializeToSequenceContainer@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z
_TEXT	SEGMENT
$T271279 = -64						; size = 4
$T271263 = -60						; size = 4
$T271465 = -56						; size = 4
$T271464 = -52						; size = 4
$T271463 = -48						; size = 4
$T271462 = -44						; size = 4
$T271461 = -40						; size = 4
_v$228241 = -36						; size = 16
_i$ = -20						; size = 4
_count$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_loadFrom$ = 8						; size = 4
_container$ = 12					; size = 4
??$SerializeToSequenceContainer@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z PROC ; SerializeToSequenceContainer<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > > >, COMDAT

; 83   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$SerializeToSequenceContainer@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 84   : 	container.clear();

	mov	eax, DWORD PTR _container$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T271263[ebp], ecx
	mov	edx, DWORD PTR $T271263[ebp]
	mov	DWORD PTR $T271462[ebp], edx
	mov	eax, DWORD PTR $T271462[ebp]
	mov	DWORD PTR $T271461[ebp], eax
	mov	ecx, DWORD PTR _container$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T271279[ebp], edx
	mov	eax, DWORD PTR $T271279[ebp]
	mov	DWORD PTR $T271464[ebp], eax
	mov	ecx, DWORD PTR $T271464[ebp]
	mov	DWORD PTR $T271463[ebp], ecx
	mov	edx, DWORD PTR $T271461[ebp]
	push	edx
	mov	eax, DWORD PTR $T271463[ebp]
	push	eax
	lea	ecx, DWORD PTR $T271465[ebp]
	push	ecx
	mov	ecx, DWORD PTR _container$[ebp]
	call	?erase@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@0@Z ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::erase

; 85   : 	ContainerType::size_type count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 86   : 	loadFrom >> count;

	lea	edx, DWORD PTR _count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 87   : 	ContainerType::size_type i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 88   : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@SerializeT@5
$LN2@SerializeT@5:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@SerializeT@5:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _count$[ebp]
	jae	SHORT $LN4@SerializeT@5

; 89   : 	{
; 90   : 		ElementType v;

	lea	ecx, DWORD PTR _v$228241[ebp]
	call	??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 91   : 		loadFrom >> v;

	lea	edx, DWORD PTR _v$228241[ebp]
	push	edx
	mov	eax, DWORD PTR _loadFrom$[ebp]
	push	eax
	call	??$?5V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z ; operator>><std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >
	add	esp, 8

; 92   : 		container.push_back(v);

	lea	ecx, DWORD PTR _v$228241[ebp]
	push	ecx
	mov	ecx, DWORD PTR _container$[ebp]
	call	?push_back@?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@QAEXABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@Z ; std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >::push_back

; 93   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _v$228241[ebp]
	call	?_Tidy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	jmp	SHORT $LN2@SerializeT@5
$LN4@SerializeT@5:

; 94   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$SerializeToSequenceContainer@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z$0:
	lea	ecx, DWORD PTR _v$228241[ebp]
	jmp	??1?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::~vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
__unwindfunclet$??$SerializeToSequenceContainer@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z$5:
	lea	ecx, DWORD PTR _v$228241[ebp]
	jmp	??1?$_Vector_val@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ
__ehhandler$??$SerializeToSequenceContainer@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$SerializeToSequenceContainer@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$SerializeToSequenceContainer@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@@Z ENDP ; SerializeToSequenceContainer<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::vector<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > > >
PUBLIC	??$?5IUPlotState@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@AAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@Z ; operator>><unsigned int,CvReplayInfo::PlotState>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??$SerializeToSequenceContainer@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$SerializeToSequenceContainer@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$SerializeToSequenceContainer@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z$11
__ehfuncinfo$??$SerializeToSequenceContainer@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$SerializeToSequenceContainer@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
xdata$x	ENDS
;	COMDAT ??$SerializeToSequenceContainer@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z
_TEXT	SEGMENT
$T272312 = -98						; size = 1
$T272311 = -97						; size = 1
$T271946 = -60						; size = 4
$T271930 = -56						; size = 4
$T272232 = -52						; size = 4
$T272231 = -48						; size = 4
$T272230 = -44						; size = 4
$T272229 = -40						; size = 4
$T272228 = -36						; size = 4
_v$228260 = -32						; size = 12
_i$ = -20						; size = 4
_count$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_loadFrom$ = 8						; size = 4
_container$ = 12					; size = 4
??$SerializeToSequenceContainer@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z PROC ; SerializeToSequenceContainer<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > > >, COMDAT

; 83   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$SerializeToSequenceContainer@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 252				; 000000fcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 84   : 	container.clear();

	mov	eax, DWORD PTR _container$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T271930[ebp], ecx
	mov	edx, DWORD PTR $T271930[ebp]
	mov	DWORD PTR $T272229[ebp], edx
	mov	eax, DWORD PTR $T272229[ebp]
	mov	DWORD PTR $T272228[ebp], eax
	mov	ecx, DWORD PTR _container$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T271946[ebp], edx
	mov	eax, DWORD PTR $T271946[ebp]
	mov	DWORD PTR $T272231[ebp], eax
	mov	ecx, DWORD PTR $T272231[ebp]
	mov	DWORD PTR $T272230[ebp], ecx
	mov	edx, DWORD PTR $T272228[ebp]
	push	edx
	mov	eax, DWORD PTR $T272230[ebp]
	push	eax
	lea	ecx, DWORD PTR $T272232[ebp]
	push	ecx
	mov	ecx, DWORD PTR _container$[ebp]
	call	?erase@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@0@Z ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::erase

; 85   : 	ContainerType::size_type count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 86   : 	loadFrom >> count;

	lea	edx, DWORD PTR _count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 87   : 	ContainerType::size_type i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 88   : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@SerializeT@6
$LN2@SerializeT@6:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@SerializeT@6:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _count$[ebp]
	jae	SHORT $LN4@SerializeT@6

; 89   : 	{
; 90   : 		ElementType v;

	lea	edx, DWORD PTR $T272311[ebp]
	push	edx
	lea	eax, DWORD PTR $T272312[ebp]
	push	eax
	lea	ecx, DWORD PTR _v$228260[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 91   : 		loadFrom >> v;

	lea	ecx, DWORD PTR _v$228260[ebp]
	push	ecx
	mov	edx, DWORD PTR _loadFrom$[ebp]
	push	edx
	call	??$?5IUPlotState@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@AAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@Z ; operator>><unsigned int,CvReplayInfo::PlotState>
	add	esp, 8

; 92   : 		container.push_back(v);

	lea	eax, DWORD PTR _v$228260[ebp]
	push	eax
	mov	ecx, DWORD PTR _container$[ebp]
	call	?push_back@?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@QAEXABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@Z ; std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >::push_back

; 93   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _v$228260[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	jmp	SHORT $LN2@SerializeT@6
$LN4@SerializeT@6:

; 94   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$SerializeToSequenceContainer@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z$0:
	lea	ecx, DWORD PTR _v$228260[ebp]
	jmp	??1?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAE@XZ
__unwindfunclet$??$SerializeToSequenceContainer@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z$11:
	lea	ecx, DWORD PTR _v$228260[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__ehhandler$??$SerializeToSequenceContainer@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-256]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$SerializeToSequenceContainer@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$SerializeToSequenceContainer@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@@Z ENDP ; SerializeToSequenceContainer<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::vector<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > > >
PUBLIC	??3@YAXPAX0@Z					; operator delete
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3
__unwindtable$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv89 = -40						; size = 4
tv68 = -36						; size = 4
$T272742 = -32						; size = 4
$T272741 = -28						; size = 4
__Vptr$272748 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil
$LN5@Uninit_fil:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 28					; 0000001cH
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Vptr$272748[ebp], eax
	mov	ecx, DWORD PTR __Vptr$272748[ebp]
	mov	DWORD PTR $T272742[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T272742[ebp], 0
	je	SHORT $LN18@Uninit_fil
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T272742[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv68[ebp], eax
	mov	eax, DWORD PTR tv68[ebp]
	mov	DWORD PTR tv89[ebp], eax
	jmp	SHORT $LN19@Uninit_fil
$LN18@Uninit_fil:
	mov	DWORD PTR tv89[ebp], 0
$LN19@Uninit_fil:
	mov	ecx, DWORD PTR tv89[ebp]
	mov	DWORD PTR $T272741[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN5@Uninit_fil
$LN4@Uninit_fil:
	jmp	SHORT $LN10@Uninit_fil
__catch$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil
$LN2@Uninit_fil:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 28					; 0000001cH
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_fil:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil

; 407  : 		_Al.destroy(_Next);

	mov	ecx, DWORD PTR __Next$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	xor	ecx, ecx
	and	ecx, 1
	je	SHORT $LN23@Uninit_fil
	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN23@Uninit_fil:
	jmp	SHORT $LN2@Uninit_fil
$LN1@Uninit_fil:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil
	ret	0
$LN10@Uninit_fil:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$272748[ebp]
	push	eax
	mov	ecx, DWORD PTR $T272742[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 63   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 64   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$6
__unwindtable$??$_Uninit_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv89 = -44						; size = 4
tv68 = -40						; size = 4
$T272815 = -32						; size = 4
$T272814 = -28						; size = 4
__Vptr$272821 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<CvReplayMessage *,unsigned int,CvReplayMessage,std::allocator<CvReplayMessage> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil@2
$LN5@Uninit_fil@2:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 60					; 0000003cH
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil@2:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil@2

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Vptr$272821[ebp], eax
	mov	ecx, DWORD PTR __Vptr$272821[ebp]
	mov	DWORD PTR $T272815[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T272815[ebp], 0
	je	SHORT $LN18@Uninit_fil@2
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T272815[ebp]
	call	??0CvReplayMessage@@QAE@ABV0@@Z
	mov	DWORD PTR tv68[ebp], eax
	mov	eax, DWORD PTR tv68[ebp]
	mov	DWORD PTR tv89[ebp], eax
	jmp	SHORT $LN19@Uninit_fil@2
$LN18@Uninit_fil@2:
	mov	DWORD PTR tv89[ebp], 0
$LN19@Uninit_fil@2:
	mov	ecx, DWORD PTR tv89[ebp]
	mov	DWORD PTR $T272814[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN5@Uninit_fil@2
$LN4@Uninit_fil@2:
	jmp	SHORT $LN10@Uninit_fil@2
__catch$??$_Uninit_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil@2
$LN2@Uninit_fil@2:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 60					; 0000003cH
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_fil@2:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil@2

; 407  : 		_Al.destroy(_Next);

	push	0
	mov	ecx, DWORD PTR __Next$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Next$[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	jmp	SHORT $LN2@Uninit_fil@2
$LN1@Uninit_fil@2:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil@2
	ret	0
$LN10@Uninit_fil@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil@2:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$272821[ebp]
	push	eax
	mov	ecx, DWORD PTR $T272815[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAVCvReplayMessage@@IV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAXPAVCvReplayMessage@@IABV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CvReplayMessage *,unsigned int,CvReplayMessage,std::allocator<CvReplayMessage> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$10 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$10
__unwindtable$??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
	DD	02H
	DD	FLAT:__unwindfunclet$??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$5
__ehfuncinfo$??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv89 = -120						; size = 4
$T272874 = -32						; size = 4
$T272873 = -28						; size = 4
__Vptr$272882 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,unsigned int,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil@3
$LN5@Uninit_fil@3:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil@3:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil@3

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Vptr$272882[ebp], eax
	mov	ecx, DWORD PTR __Vptr$272882[ebp]
	mov	DWORD PTR $T272874[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T272874[ebp], 0
	je	SHORT $LN18@Uninit_fil@3
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T272874[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
	mov	eax, DWORD PTR $T272874[ebp]
	mov	DWORD PTR tv89[ebp], eax
	jmp	SHORT $LN19@Uninit_fil@3
$LN18@Uninit_fil@3:
	mov	DWORD PTR tv89[ebp], 0
$LN19@Uninit_fil@3:
	mov	ecx, DWORD PTR tv89[ebp]
	mov	DWORD PTR $T272873[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN5@Uninit_fil@3
$LN4@Uninit_fil@3:
	jmp	SHORT $LN10@Uninit_fil@3
__catch$??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil@3
$LN2@Uninit_fil@3:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_fil@3:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil@3

; 407  : 		_Al.destroy(_Next);

	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR __Next$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	xor	ecx, ecx
	and	ecx, 1
	je	SHORT $LN26@Uninit_fil@3
	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN26@Uninit_fil@3:
	jmp	SHORT $LN2@Uninit_fil@3
$LN1@Uninit_fil@3:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil@3
	ret	0
$LN10@Uninit_fil@3:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil@3:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$272882[ebp]
	push	eax
	mov	ecx, DWORD PTR $T272874[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$5:
	mov	ecx, DWORD PTR __Next$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@IV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAXPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@IABV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,unsigned int,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAW4GameOptionTypes@@IW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAXPAW4GameOptionTypes@@IABW41@AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAW4GameOptionTypes@@IW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAXPAW4GameOptionTypes@@IABW41@AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAW4GameOptionTypes@@IW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAXPAW4GameOptionTypes@@IABW41@AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAW4GameOptionTypes@@IW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAXPAW4GameOptionTypes@@IABW41@AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAW4GameOptionTypes@@IW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAXPAW4GameOptionTypes@@IABW41@AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_fill_n@PAW4GameOptionTypes@@IW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAXPAW4GameOptionTypes@@IABW41@AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAW4GameOptionTypes@@IW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAXPAW4GameOptionTypes@@IABW41@AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAW4GameOptionTypes@@IW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAXPAW4GameOptionTypes@@IABW41@AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAW4GameOptionTypes@@IW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAXPAW4GameOptionTypes@@IABW41@AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv83 = -32						; size = 4
$T273256 = -28						; size = 4
__Vptr$273254 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAW4GameOptionTypes@@IW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAXPAW4GameOptionTypes@@IABW41@AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<enum GameOptionTypes *,unsigned int,enum GameOptionTypes,std::allocator<enum GameOptionTypes> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAW4GameOptionTypes@@IW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAXPAW4GameOptionTypes@@IABW41@AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil@4
$LN5@Uninit_fil@4:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 4
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil@4:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil@4

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Vptr$273254[ebp], eax
	mov	ecx, DWORD PTR __Vptr$273254[ebp]
	mov	DWORD PTR $T273256[ebp], ecx
	cmp	DWORD PTR $T273256[ebp], 0
	je	SHORT $LN18@Uninit_fil@4
	mov	edx, DWORD PTR $T273256[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T273256[ebp]
	mov	DWORD PTR tv83[ebp], edx
	jmp	SHORT $LN14@Uninit_fil@4
$LN18@Uninit_fil@4:
	mov	DWORD PTR tv83[ebp], 0
$LN14@Uninit_fil@4:
	jmp	SHORT $LN5@Uninit_fil@4
$LN4@Uninit_fil@4:
	jmp	SHORT $LN10@Uninit_fil@4
__catch$??$_Uninit_fill_n@PAW4GameOptionTypes@@IW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAXPAW4GameOptionTypes@@IABW41@AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil@4
$LN2@Uninit_fil@4:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 4
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_fil@4:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil@4

; 407  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_fil@4
$LN1@Uninit_fil@4:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil@4
	ret	0
$LN10@Uninit_fil@4:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil@4:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAW4GameOptionTypes@@IW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAXPAW4GameOptionTypes@@IABW41@AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAW4GameOptionTypes@@IW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAXPAW4GameOptionTypes@@IABW41@AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAW4GameOptionTypes@@IW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAXPAW4GameOptionTypes@@IABW41@AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<enum GameOptionTypes *,unsigned int,enum GameOptionTypes,std::allocator<enum GameOptionTypes> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAW4VictoryTypes@@IW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAXPAW4VictoryTypes@@IABW41@AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAW4VictoryTypes@@IW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAXPAW4VictoryTypes@@IABW41@AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAW4VictoryTypes@@IW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAXPAW4VictoryTypes@@IABW41@AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAW4VictoryTypes@@IW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAXPAW4VictoryTypes@@IABW41@AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAW4VictoryTypes@@IW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAXPAW4VictoryTypes@@IABW41@AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_fill_n@PAW4VictoryTypes@@IW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAXPAW4VictoryTypes@@IABW41@AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAW4VictoryTypes@@IW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAXPAW4VictoryTypes@@IABW41@AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAW4VictoryTypes@@IW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAXPAW4VictoryTypes@@IABW41@AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAW4VictoryTypes@@IW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAXPAW4VictoryTypes@@IABW41@AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv83 = -32						; size = 4
$T273305 = -28						; size = 4
__Vptr$273303 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAW4VictoryTypes@@IW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAXPAW4VictoryTypes@@IABW41@AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<enum VictoryTypes *,unsigned int,enum VictoryTypes,std::allocator<enum VictoryTypes> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAW4VictoryTypes@@IW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAXPAW4VictoryTypes@@IABW41@AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil@5
$LN5@Uninit_fil@5:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 4
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil@5:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil@5

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Vptr$273303[ebp], eax
	mov	ecx, DWORD PTR __Vptr$273303[ebp]
	mov	DWORD PTR $T273305[ebp], ecx
	cmp	DWORD PTR $T273305[ebp], 0
	je	SHORT $LN18@Uninit_fil@5
	mov	edx, DWORD PTR $T273305[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T273305[ebp]
	mov	DWORD PTR tv83[ebp], edx
	jmp	SHORT $LN14@Uninit_fil@5
$LN18@Uninit_fil@5:
	mov	DWORD PTR tv83[ebp], 0
$LN14@Uninit_fil@5:
	jmp	SHORT $LN5@Uninit_fil@5
$LN4@Uninit_fil@5:
	jmp	SHORT $LN10@Uninit_fil@5
__catch$??$_Uninit_fill_n@PAW4VictoryTypes@@IW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAXPAW4VictoryTypes@@IABW41@AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil@5
$LN2@Uninit_fil@5:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 4
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_fil@5:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil@5

; 407  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_fil@5
$LN1@Uninit_fil@5:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil@5
	ret	0
$LN10@Uninit_fil@5:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil@5:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAW4VictoryTypes@@IW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAXPAW4VictoryTypes@@IABW41@AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAW4VictoryTypes@@IW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAXPAW4VictoryTypes@@IABW41@AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAW4VictoryTypes@@IW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAXPAW4VictoryTypes@@IABW41@AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<enum VictoryTypes *,unsigned int,enum VictoryTypes,std::allocator<enum VictoryTypes> >
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$19 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$19
__unwindtable$??$_Uninit_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv89 = -72						; size = 4
tv68 = -68						; size = 4
$T273384 = -32						; size = 4
$T273383 = -28						; size = 4
__Vptr$273381 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<CvReplayInfo::PlayerInfo *,unsigned int,CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 56					; 00000038H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil@6
$LN5@Uninit_fil@6:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 128				; 00000080H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil@6:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil@6

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Vptr$273381[ebp], eax
	mov	ecx, DWORD PTR __Vptr$273381[ebp]
	mov	DWORD PTR $T273384[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T273384[ebp], 0
	je	SHORT $LN18@Uninit_fil@6
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T273384[ebp]
	call	??0PlayerInfo@CvReplayInfo@@QAE@ABU01@@Z
	mov	DWORD PTR tv68[ebp], eax
	mov	eax, DWORD PTR tv68[ebp]
	mov	DWORD PTR tv89[ebp], eax
	jmp	SHORT $LN19@Uninit_fil@6
$LN18@Uninit_fil@6:
	mov	DWORD PTR tv89[ebp], 0
$LN19@Uninit_fil@6:
	mov	ecx, DWORD PTR tv89[ebp]
	mov	DWORD PTR $T273383[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN5@Uninit_fil@6
$LN4@Uninit_fil@6:
	jmp	SHORT $LN10@Uninit_fil@6
__catch$??$_Uninit_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil@6
$LN2@Uninit_fil@6:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 128				; 00000080H
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_fil@6:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil@6

; 407  : 		_Al.destroy(_Next);

	mov	ecx, DWORD PTR __Next$[ebp]
	call	??1PlayerInfo@CvReplayInfo@@QAE@XZ
	xor	ecx, ecx
	and	ecx, 1
	je	SHORT $LN41@Uninit_fil@6
	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN41@Uninit_fil@6:
	jmp	SHORT $LN2@Uninit_fil@6
$LN1@Uninit_fil@6:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil@6
	ret	0
$LN10@Uninit_fil@6:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil@6:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$273381[ebp]
	push	eax
	mov	ecx, DWORD PTR $T273384[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAUPlayerInfo@CvReplayInfo@@IU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAXPAUPlayerInfo@CvReplayInfo@@IABU12@AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CvReplayInfo::PlayerInfo *,unsigned int,CvReplayInfo::PlayerInfo,std::allocator<CvReplayInfo::PlayerInfo> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$11 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$11
__unwindtable$??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
	DD	02H
	DD	FLAT:__unwindfunclet$??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3
__ehfuncinfo$??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv89 = -116						; size = 4
tv68 = -112						; size = 4
$T273469 = -32						; size = 4
$T273468 = -28						; size = 4
__Vptr$273475 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,unsigned int,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil@7
$LN5@Uninit_fil@7:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil@7:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil@7

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Vptr$273475[ebp], eax
	mov	ecx, DWORD PTR __Vptr$273475[ebp]
	mov	DWORD PTR $T273469[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T273469[ebp], 0
	je	SHORT $LN18@Uninit_fil@7
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T273469[ebp]
	call	??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
	mov	DWORD PTR tv68[ebp], eax
	mov	eax, DWORD PTR tv68[ebp]
	mov	DWORD PTR tv89[ebp], eax
	jmp	SHORT $LN19@Uninit_fil@7
$LN18@Uninit_fil@7:
	mov	DWORD PTR tv89[ebp], 0
$LN19@Uninit_fil@7:
	mov	ecx, DWORD PTR tv89[ebp]
	mov	DWORD PTR $T273468[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN5@Uninit_fil@7
$LN4@Uninit_fil@7:
	jmp	SHORT $LN10@Uninit_fil@7
__catch$??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil@7
$LN2@Uninit_fil@7:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_fil@7:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil@7

; 407  : 		_Al.destroy(_Next);

	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR __Next$[ebp]
	call	?_Tidy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	xor	ecx, ecx
	and	ecx, 1
	je	SHORT $LN23@Uninit_fil@7
	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN23@Uninit_fil@7:
	jmp	SHORT $LN2@Uninit_fil@7
$LN1@Uninit_fil@7:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil@7
	ret	0
$LN10@Uninit_fil@7:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil@7:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$273475[ebp]
	push	eax
	mov	ecx, DWORD PTR $T273469[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3:
	mov	ecx, DWORD PTR __Next$[ebp]
	jmp	??1?$_Vector_val@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ
__ehhandler$??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-120]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,unsigned int,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IABV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$10 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IABV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IABV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IABV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$10
__unwindtable$??$_Uninit_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IABV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IABV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
	DD	02H
	DD	FLAT:__unwindfunclet$??$_Uninit_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IABV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$5
__ehfuncinfo$??$_Uninit_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IABV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IABV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IABV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IABV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv89 = -120						; size = 4
$T273903 = -32						; size = 4
$T273902 = -28						; size = 4
__Vptr$273911 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IABV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,unsigned int,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IABV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil@8
$LN5@Uninit_fil@8:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil@8:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil@8

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Vptr$273911[ebp], eax
	mov	ecx, DWORD PTR __Vptr$273911[ebp]
	mov	DWORD PTR $T273903[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T273903[ebp], 0
	je	SHORT $LN18@Uninit_fil@8
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T273903[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >
	mov	eax, DWORD PTR $T273903[ebp]
	mov	DWORD PTR tv89[ebp], eax
	jmp	SHORT $LN19@Uninit_fil@8
$LN18@Uninit_fil@8:
	mov	DWORD PTR tv89[ebp], 0
$LN19@Uninit_fil@8:
	mov	ecx, DWORD PTR tv89[ebp]
	mov	DWORD PTR $T273902[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN5@Uninit_fil@8
$LN4@Uninit_fil@8:
	jmp	SHORT $LN10@Uninit_fil@8
__catch$??$_Uninit_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IABV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil@8
$LN2@Uninit_fil@8:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_fil@8:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil@8

; 407  : 		_Al.destroy(_Next);

	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR __Next$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	xor	ecx, ecx
	and	ecx, 1
	je	SHORT $LN26@Uninit_fil@8
	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN26@Uninit_fil@8:
	jmp	SHORT $LN2@Uninit_fil@8
$LN1@Uninit_fil@8:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil@8
	ret	0
$LN10@Uninit_fil@8:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil@8:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IABV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$273911[ebp]
	push	eax
	mov	ecx, DWORD PTR $T273903[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??$_Uninit_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IABV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$5:
	mov	ecx, DWORD PTR __Next$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__ehhandler$??$_Uninit_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IABV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IABV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@IV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAXPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@IABV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,unsigned int,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
PUBLIC	??4?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAEAAV01@ABV01@@Z ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::operator=
; Function compile flags: /Odtp
;	COMDAT ??4CvReplayMessage@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_this$ = -168						; size = 4
$T274563 = -164						; size = 4
___that$ = 8						; size = 4
??4CvReplayMessage@@QAEAAV0@ABV0@@Z PROC		; CvReplayMessage::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 168				; 000000a8H
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??4?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAEAAV01@ABV01@@Z ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::operator=
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [ecx+28], eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	mov	DWORD PTR $T274563[ebp], ecx
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 32					; 00000020H
	push	edx
	mov	ecx, DWORD PTR $T274563[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4CvReplayMessage@@QAEAAV0@ABV0@@Z ENDP		; CvReplayMessage::operator=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??4PlayerInfo@CvReplayInfo@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T274581 = -16						; size = 4
$T274577 = -12						; size = 4
$T274573 = -8						; size = 4
$T274569 = -4						; size = 4
___that$ = 8						; size = 4
??4PlayerInfo@CvReplayInfo@@QAEAAU01@ABU01@@Z PROC	; CvReplayInfo::PlayerInfo::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR $T274569[ebp], eax
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	mov	ecx, DWORD PTR $T274569[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 44					; 0000002cH
	mov	DWORD PTR $T274573[ebp], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	mov	ecx, DWORD PTR $T274573[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	mov	DWORD PTR $T274577[ebp], ecx
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 72					; 00000048H
	push	edx
	mov	ecx, DWORD PTR $T274577[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 100				; 00000064H
	mov	DWORD PTR $T274581[ebp], eax
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 100				; 00000064H
	push	ecx
	mov	ecx, DWORD PTR $T274581[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4PlayerInfo@CvReplayInfo@@QAEAAU01@ABU01@@Z ENDP	; CvReplayInfo::PlayerInfo::operator=
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
tv88 = -132						; size = 4
tv145 = -128						; size = 4
_this$ = -124						; size = 4
$T274613 = -30						; size = 1
$T274600 = -29						; size = 1
$T274596 = -28						; size = 4
$T274589 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T274613[ebp]
	mov	DWORD PTR $T274589[ebp], eax
	lea	ecx, DWORD PTR $T274600[ebp]
	mov	DWORD PTR $T274596[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv145[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv88[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAE_NI@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ
__ehhandler$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
PUBLIC	??$_Uninit_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
PUBLIC	??4?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAEAAV01@ABV01@@Z ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::operator=
PUBLIC	?erase@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@0@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::erase
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??4?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV01@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??4?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV01@ABV01@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??4?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV01@ABV01@@Z$7
__ehfuncinfo$??4?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV01@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??4?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV01@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??4?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
tv241 = -320						; size = 4
_this$ = -316						; size = 4
$T275403 = -312						; size = 4
$T275402 = -308						; size = 4
$T275401 = -304						; size = 4
$T275391 = -300						; size = 4
$T275390 = -296						; size = 4
__Cat$275398 = -291					; size = 1
$T275396 = -290						; size = 1
$T275395 = -289						; size = 1
$T275340 = -200						; size = 4
$T275336 = -196						; size = 4
$T275335 = -192						; size = 4
$T275331 = -188						; size = 4
$T275330 = -184						; size = 4
$T275295 = -180						; size = 4
$T275294 = -176						; size = 4
$T275261 = -172						; size = 4
$T275260 = -168						; size = 4
__Cat$275302 = -162					; size = 1
$T275300 = -161						; size = 1
$T275096 = -160						; size = 4
$T275095 = -156						; size = 4
$T275085 = -152						; size = 4
$T275084 = -148						; size = 4
__Cat$275092 = -143					; size = 1
$T275090 = -142						; size = 1
$T275089 = -141						; size = 1
$T275068 = -140						; size = 4
$T275067 = -136						; size = 4
$T275048 = -130						; size = 1
$T275047 = -129						; size = 1
$T275046 = -128						; size = 4
$T275045 = -124						; size = 4
__Cat$275055 = -116					; size = 1
$T275053 = -115						; size = 1
$T275052 = -114						; size = 1
$T275051 = -113						; size = 1
$T275011 = -112						; size = 4
$T275004 = -108						; size = 4
$T274969 = -104						; size = 4
$T274968 = -100						; size = 4
$T274935 = -96						; size = 4
$T274934 = -92						; size = 4
__Cat$274976 = -86					; size = 1
$T274974 = -85						; size = 1
$T274770 = -84						; size = 4
$T274769 = -80						; size = 4
$T274768 = -76						; size = 4
$T274751 = -70						; size = 1
$T274750 = -69						; size = 1
$T274749 = -68						; size = 4
$T274748 = -64						; size = 4
__Cat$274757 = -56					; size = 1
$T274755 = -55						; size = 1
$T274754 = -54						; size = 1
$T274753 = -53						; size = 1
$T274726 = -52						; size = 4
$T274697 = -48						; size = 4
$T274681 = -44						; size = 4
$T274710 = -40						; size = 4
$T274709 = -36						; size = 4
$T274708 = -32						; size = 4
$T274707 = -28						; size = 4
$T274706 = -24						; size = 4
__Ptr$229233 = -20					; size = 4
__Ptr$229223 = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??4?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??4?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV01@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 308				; 00000134H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@13

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	test	eax, eax
	jne	SHORT $LN8@operator@13

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T274681[ebp], eax
	mov	ecx, DWORD PTR $T274681[ebp]
	mov	DWORD PTR $T274707[ebp], ecx
	mov	edx, DWORD PTR $T274707[ebp]
	mov	DWORD PTR $T274706[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T274697[ebp], ecx
	mov	edx, DWORD PTR $T274697[ebp]
	mov	DWORD PTR $T274709[ebp], edx
	mov	eax, DWORD PTR $T274709[ebp]
	mov	DWORD PTR $T274708[ebp], eax
	mov	ecx, DWORD PTR $T274706[ebp]
	push	ecx
	mov	edx, DWORD PTR $T274708[ebp]
	push	edx
	lea	eax, DWORD PTR $T274710[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@0@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::erase

; 573  : 			else if (_Right.size() <= size())

	jmp	$LN9@operator@13
$LN8@operator@13:
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR $T274726[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	cmp	DWORD PTR $T274726[ebp], eax
	ja	$LN6@operator@13

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T274770[ebp], eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T274769[ebp], edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T274768[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T274753[ebp], dl
	mov	al, BYTE PTR __Cat$274757[ebp]
	mov	BYTE PTR $T274754[ebp], al
	mov	cl, BYTE PTR $T274753[ebp]
	mov	BYTE PTR $T274751[ebp], cl
	mov	dl, BYTE PTR $T274755[ebp]
	mov	BYTE PTR $T274750[ebp], dl
	mov	eax, DWORD PTR $T274770[ebp]
	mov	DWORD PTR $T274749[ebp], eax
	mov	ecx, DWORD PTR $T274768[ebp]
	mov	DWORD PTR $T274748[ebp], ecx
	jmp	SHORT $LN40@operator@13
$LN39@operator@13:
	mov	edx, DWORD PTR $T274749[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR $T274749[ebp], edx
	mov	eax, DWORD PTR $T274748[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T274748[ebp], eax
$LN40@operator@13:
	mov	ecx, DWORD PTR $T274748[ebp]
	cmp	ecx, DWORD PTR $T274769[ebp]
	je	SHORT $LN32@operator@13
	mov	edx, DWORD PTR $T274748[ebp]
	push	edx
	mov	ecx, DWORD PTR $T274749[ebp]
	call	??4?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAEAAV01@ABV01@@Z
	jmp	SHORT $LN39@operator@13
$LN32@operator@13:
	mov	eax, DWORD PTR $T274749[ebp]
	mov	DWORD PTR __Ptr$229223[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T275004[ebp], edx
	mov	eax, DWORD PTR $T275004[ebp]
	mov	DWORD PTR $T274969[ebp], eax
	mov	ecx, DWORD PTR __Ptr$229223[ebp]
	mov	DWORD PTR $T274968[ebp], ecx
	mov	dl, BYTE PTR __Cat$274976[ebp]
	mov	BYTE PTR $T274974[ebp], dl
	mov	eax, DWORD PTR $T274969[ebp]
	mov	DWORD PTR $T274935[ebp], eax
	mov	ecx, DWORD PTR $T274968[ebp]
	mov	DWORD PTR $T274934[ebp], ecx
	jmp	SHORT $LN51@operator@13
$LN50@operator@13:
	mov	edx, DWORD PTR $T274934[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR $T274934[ebp], edx
$LN51@operator@13:
	mov	eax, DWORD PTR $T274934[ebp]
	cmp	eax, DWORD PTR $T274935[ebp]
	je	SHORT $LN81@operator@13
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR $T274934[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	xor	ecx, ecx
	and	ecx, 1
	je	SHORT $LN54@operator@13
	mov	edx, DWORD PTR $T274934[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN54@operator@13:
	jmp	SHORT $LN50@operator@13

; 578  : 				_Mylast = _Myfirst + _Right.size();

$LN81@operator@13:
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	imul	eax, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax
	jmp	$LN9@operator@13
$LN6@operator@13:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR $T275011[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN87@operator@13
	mov	DWORD PTR tv241[ebp], 0
	jmp	SHORT $LN85@operator@13
$LN87@operator@13:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR tv241[ebp], eax
$LN85@operator@13:
	mov	edx, DWORD PTR $T275011[ebp]
	cmp	edx, DWORD PTR tv241[ebp]
	ja	$LN4@operator@13

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	imul	eax, 12					; 0000000cH
	mov	edx, DWORD PTR __Right$[ebp]
	add	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Ptr$229233[ebp], eax

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T275068[ebp], ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T275067[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T275051[ebp], cl
	mov	dl, BYTE PTR __Cat$275055[ebp]
	mov	BYTE PTR $T275052[ebp], dl
	mov	al, BYTE PTR $T275051[ebp]
	mov	BYTE PTR $T275048[ebp], al
	mov	cl, BYTE PTR $T275053[ebp]
	mov	BYTE PTR $T275047[ebp], cl
	mov	edx, DWORD PTR $T275068[ebp]
	mov	DWORD PTR $T275046[ebp], edx
	mov	eax, DWORD PTR $T275067[ebp]
	mov	DWORD PTR $T275045[ebp], eax
	jmp	SHORT $LN99@operator@13
$LN98@operator@13:
	mov	ecx, DWORD PTR $T275046[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR $T275046[ebp], ecx
	mov	edx, DWORD PTR $T275045[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR $T275045[ebp], edx
$LN99@operator@13:
	mov	eax, DWORD PTR $T275045[ebp]
	cmp	eax, DWORD PTR __Ptr$229233[ebp]
	je	SHORT $LN91@operator@13
	mov	ecx, DWORD PTR $T275045[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T275046[ebp]
	call	??4?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::operator=
	jmp	SHORT $LN98@operator@13
$LN91@operator@13:

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T275096[ebp], eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T275095[ebp], edx
	mov	eax, DWORD PTR $T275096[ebp]
	mov	DWORD PTR $T275085[ebp], eax
	mov	ecx, DWORD PTR __Ptr$229233[ebp]
	mov	DWORD PTR $T275084[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T275089[ebp], dl
	mov	al, BYTE PTR __Cat$275092[ebp]
	mov	BYTE PTR $T275090[ebp], al
	movzx	ecx, BYTE PTR $T275089[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T275090[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T275085[ebp]
	push	ecx
	mov	edx, DWORD PTR $T275095[ebp]
	push	edx
	mov	eax, DWORD PTR $T275084[ebp]
	push	eax
	call	??$_Uninit_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 585  : 				}
; 586  : 			else

	jmp	$LN9@operator@13
$LN4@operator@13:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN2@operator@13

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T275331[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T275330[ebp], eax
	mov	ecx, DWORD PTR $T275331[ebp]
	mov	DWORD PTR $T275295[ebp], ecx
	mov	edx, DWORD PTR $T275330[ebp]
	mov	DWORD PTR $T275294[ebp], edx
	mov	al, BYTE PTR __Cat$275302[ebp]
	mov	BYTE PTR $T275300[ebp], al
	mov	ecx, DWORD PTR $T275295[ebp]
	mov	DWORD PTR $T275261[ebp], ecx
	mov	edx, DWORD PTR $T275294[ebp]
	mov	DWORD PTR $T275260[ebp], edx
	jmp	SHORT $LN118@operator@13
$LN117@operator@13:
	mov	eax, DWORD PTR $T275260[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T275260[ebp], eax
$LN118@operator@13:
	mov	ecx, DWORD PTR $T275260[ebp]
	cmp	ecx, DWORD PTR $T275261[ebp]
	je	SHORT $LN110@operator@13
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR $T275260[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	xor	edx, edx
	and	edx, 1
	je	SHORT $LN121@operator@13
	mov	eax, DWORD PTR $T275260[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN121@operator@13:
	jmp	SHORT $LN117@operator@13
$LN110@operator@13:

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR $T275336[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T275335[ebp], eax
	mov	ecx, DWORD PTR $T275335[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@operator@13:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR $T275340[ebp], eax
	mov	edx, DWORD PTR $T275340[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAE_NI@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Buy
	movzx	eax, al
	test	eax, eax
	je	$LN9@operator@13

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T275403[ebp], edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T275402[ebp], ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T275401[ebp], eax
	mov	ecx, DWORD PTR $T275403[ebp]
	mov	DWORD PTR $T275391[ebp], ecx
	mov	edx, DWORD PTR $T275401[ebp]
	mov	DWORD PTR $T275390[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T275395[ebp], al
	mov	cl, BYTE PTR __Cat$275398[ebp]
	mov	BYTE PTR $T275396[ebp], cl
	movzx	edx, BYTE PTR $T275395[ebp]
	push	edx
	movzx	eax, BYTE PTR $T275396[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T275391[ebp]
	push	edx
	mov	eax, DWORD PTR $T275402[ebp]
	push	eax
	mov	ecx, DWORD PTR $T275390[ebp]
	push	ecx
	call	??$_Uninit_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax
$LN9@operator@13:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??4?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV01@ABV01@@Z$1:
	mov	ecx, DWORD PTR $T274934[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
__unwindfunclet$??4?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV01@ABV01@@Z$7:
	mov	ecx, DWORD PTR $T275260[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??4?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV01@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-312]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??4?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV01@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??4?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator=
; Function compile flags: /Odtp
;	COMDAT ??4?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -124						; size = 4
___that$ = 8						; size = 4
??4?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::operator=
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<short,short> *,std::pair<short,short> *,std::allocator<std::pair<short,short> > >
PUBLIC	?erase@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@0@Z ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::erase
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
tv240 = -300						; size = 4
_this$ = -296						; size = 4
$T276134 = -292						; size = 4
$T276133 = -288						; size = 4
$T276132 = -284						; size = 4
$T276122 = -280						; size = 4
$T276121 = -276						; size = 4
__Cat$276131 = -271					; size = 1
$T276128 = -270						; size = 1
$T276127 = -269						; size = 1
$T276071 = -180						; size = 4
$T276067 = -176						; size = 4
$T276066 = -172						; size = 4
$T276062 = -168						; size = 4
$T276061 = -164						; size = 4
$T276043 = -160						; size = 4
$T276042 = -156						; size = 4
$T276026 = -152						; size = 4
__Cat$276050 = -146					; size = 1
$T276047 = -145						; size = 1
$T276000 = -144						; size = 4
$T275999 = -140						; size = 4
$T275989 = -136						; size = 4
$T275988 = -132						; size = 4
__Cat$275997 = -127					; size = 1
$T275994 = -126						; size = 1
$T275993 = -125						; size = 1
$T275972 = -124						; size = 4
$T275971 = -120						; size = 4
$T275954 = -114						; size = 1
$T275953 = -113						; size = 1
$T275952 = -112						; size = 4
$T275951 = -108						; size = 4
__Cat$275961 = -100					; size = 1
$T275958 = -99						; size = 1
$T275957 = -98						; size = 1
$T275956 = -97						; size = 1
$T275922 = -96						; size = 4
$T275915 = -92						; size = 4
$T275897 = -88						; size = 4
$T275896 = -84						; size = 4
$T275880 = -80						; size = 4
__Cat$275903 = -74					; size = 1
$T275900 = -73						; size = 1
$T275854 = -72						; size = 4
$T275853 = -68						; size = 4
$T275852 = -64						; size = 4
$T275835 = -58						; size = 1
$T275834 = -57						; size = 1
$T275833 = -56						; size = 4
$T275832 = -52						; size = 4
__Cat$275842 = -44					; size = 1
$T275839 = -43						; size = 1
$T275838 = -42						; size = 1
$T275837 = -41						; size = 1
$T275810 = -40						; size = 4
$T275781 = -36						; size = 4
$T275765 = -32						; size = 4
$T275794 = -28						; size = 4
$T275793 = -24						; size = 4
$T275792 = -20						; size = 4
$T275791 = -16						; size = 4
$T275790 = -12						; size = 4
__Ptr$229342 = -8					; size = 4
__Ptr$229332 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 300				; 0000012cH
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@14

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	test	eax, eax
	jne	SHORT $LN8@operator@14

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T275765[ebp], edx
	mov	eax, DWORD PTR $T275765[ebp]
	mov	DWORD PTR $T275791[ebp], eax
	mov	ecx, DWORD PTR $T275791[ebp]
	mov	DWORD PTR $T275790[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T275781[ebp], eax
	mov	ecx, DWORD PTR $T275781[ebp]
	mov	DWORD PTR $T275793[ebp], ecx
	mov	edx, DWORD PTR $T275793[ebp]
	mov	DWORD PTR $T275792[ebp], edx
	mov	eax, DWORD PTR $T275790[ebp]
	push	eax
	mov	ecx, DWORD PTR $T275792[ebp]
	push	ecx
	lea	edx, DWORD PTR $T275794[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@0@Z ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::erase

; 573  : 			else if (_Right.size() <= size())

	jmp	$LN9@operator@14
$LN8@operator@14:
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T275810[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	DWORD PTR $T275810[ebp], edx
	ja	$LN6@operator@14

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T275854[ebp], ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T275853[ebp], eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T275852[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T275837[ebp], al
	mov	cl, BYTE PTR __Cat$275842[ebp]
	mov	BYTE PTR $T275838[ebp], cl
	mov	dl, BYTE PTR $T275837[ebp]
	mov	BYTE PTR $T275835[ebp], dl
	mov	al, BYTE PTR $T275839[ebp]
	mov	BYTE PTR $T275834[ebp], al
	mov	ecx, DWORD PTR $T275854[ebp]
	mov	DWORD PTR $T275833[ebp], ecx
	mov	edx, DWORD PTR $T275852[ebp]
	mov	DWORD PTR $T275832[ebp], edx
	jmp	SHORT $LN40@operator@14
$LN39@operator@14:
	mov	eax, DWORD PTR $T275833[ebp]
	add	eax, 4
	mov	DWORD PTR $T275833[ebp], eax
	mov	ecx, DWORD PTR $T275832[ebp]
	add	ecx, 4
	mov	DWORD PTR $T275832[ebp], ecx
$LN40@operator@14:
	mov	edx, DWORD PTR $T275832[ebp]
	cmp	edx, DWORD PTR $T275853[ebp]
	je	SHORT $LN32@operator@14
	mov	eax, DWORD PTR $T275832[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR $T275833[ebp]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN39@operator@14
$LN32@operator@14:
	mov	eax, DWORD PTR $T275833[ebp]
	mov	DWORD PTR __Ptr$229332[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T275915[ebp], edx
	mov	eax, DWORD PTR $T275915[ebp]
	mov	DWORD PTR $T275897[ebp], eax
	mov	ecx, DWORD PTR __Ptr$229332[ebp]
	mov	DWORD PTR $T275896[ebp], ecx
	mov	dl, BYTE PTR __Cat$275903[ebp]
	mov	BYTE PTR $T275900[ebp], dl
	mov	eax, DWORD PTR $T275896[ebp]
	mov	DWORD PTR $T275880[ebp], eax
	jmp	SHORT $LN51@operator@14
$LN50@operator@14:
	mov	ecx, DWORD PTR $T275880[ebp]
	add	ecx, 4
	mov	DWORD PTR $T275880[ebp], ecx
$LN51@operator@14:
	mov	edx, DWORD PTR $T275880[ebp]
	cmp	edx, DWORD PTR $T275897[ebp]
	je	SHORT $LN58@operator@14
	jmp	SHORT $LN50@operator@14

; 578  : 				_Mylast = _Myfirst + _Right.size();

$LN58@operator@14:
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx
	jmp	$LN9@operator@14
$LN6@operator@14:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR $T275922[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN64@operator@14
	mov	DWORD PTR tv240[ebp], 0
	jmp	SHORT $LN62@operator@14
$LN64@operator@14:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR tv240[ebp], ecx
$LN62@operator@14:
	mov	edx, DWORD PTR $T275922[ebp]
	cmp	edx, DWORD PTR tv240[ebp]
	ja	$LN4@operator@14

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR __Ptr$229342[ebp], edx

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T275972[ebp], ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T275971[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T275956[ebp], cl
	mov	dl, BYTE PTR __Cat$275961[ebp]
	mov	BYTE PTR $T275957[ebp], dl
	mov	al, BYTE PTR $T275956[ebp]
	mov	BYTE PTR $T275954[ebp], al
	mov	cl, BYTE PTR $T275958[ebp]
	mov	BYTE PTR $T275953[ebp], cl
	mov	edx, DWORD PTR $T275972[ebp]
	mov	DWORD PTR $T275952[ebp], edx
	mov	eax, DWORD PTR $T275971[ebp]
	mov	DWORD PTR $T275951[ebp], eax
	jmp	SHORT $LN76@operator@14
$LN75@operator@14:
	mov	ecx, DWORD PTR $T275952[ebp]
	add	ecx, 4
	mov	DWORD PTR $T275952[ebp], ecx
	mov	edx, DWORD PTR $T275951[ebp]
	add	edx, 4
	mov	DWORD PTR $T275951[ebp], edx
$LN76@operator@14:
	mov	eax, DWORD PTR $T275951[ebp]
	cmp	eax, DWORD PTR __Ptr$229342[ebp]
	je	SHORT $LN68@operator@14
	mov	ecx, DWORD PTR $T275951[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR $T275952[ebp]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN75@operator@14
$LN68@operator@14:

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T276000[ebp], edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T275999[ebp], ecx
	mov	edx, DWORD PTR $T276000[ebp]
	mov	DWORD PTR $T275989[ebp], edx
	mov	eax, DWORD PTR __Ptr$229342[ebp]
	mov	DWORD PTR $T275988[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T275993[ebp], cl
	mov	dl, BYTE PTR __Cat$275997[ebp]
	mov	BYTE PTR $T275994[ebp], dl
	movzx	eax, BYTE PTR $T275993[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T275994[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T275989[ebp]
	push	eax
	mov	ecx, DWORD PTR $T275999[ebp]
	push	ecx
	mov	edx, DWORD PTR $T275988[ebp]
	push	edx
	call	??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<short,short> *,std::pair<short,short> *,std::allocator<std::pair<short,short> > >
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 585  : 				}
; 586  : 			else

	jmp	$LN9@operator@14
$LN4@operator@14:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN2@operator@14

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T276062[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T276061[ebp], eax
	mov	ecx, DWORD PTR $T276062[ebp]
	mov	DWORD PTR $T276043[ebp], ecx
	mov	edx, DWORD PTR $T276061[ebp]
	mov	DWORD PTR $T276042[ebp], edx
	mov	al, BYTE PTR __Cat$276050[ebp]
	mov	BYTE PTR $T276047[ebp], al
	mov	ecx, DWORD PTR $T276042[ebp]
	mov	DWORD PTR $T276026[ebp], ecx
	jmp	SHORT $LN93@operator@14
$LN92@operator@14:
	mov	edx, DWORD PTR $T276026[ebp]
	add	edx, 4
	mov	DWORD PTR $T276026[ebp], edx
$LN93@operator@14:
	mov	eax, DWORD PTR $T276026[ebp]
	cmp	eax, DWORD PTR $T276043[ebp]
	je	SHORT $LN85@operator@14
	jmp	SHORT $LN92@operator@14
$LN85@operator@14:

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR $T276067[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T276066[ebp], edx
	mov	eax, DWORD PTR $T276066[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@operator@14:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR $T276071[ebp], eax
	mov	ecx, DWORD PTR $T276071[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAE_NI@Z ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Buy
	movzx	edx, al
	test	edx, edx
	je	$LN9@operator@14

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T276134[ebp], ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T276133[ebp], eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T276132[ebp], edx
	mov	eax, DWORD PTR $T276134[ebp]
	mov	DWORD PTR $T276122[ebp], eax
	mov	ecx, DWORD PTR $T276132[ebp]
	mov	DWORD PTR $T276121[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T276127[ebp], dl
	mov	al, BYTE PTR __Cat$276131[ebp]
	mov	BYTE PTR $T276128[ebp], al
	movzx	ecx, BYTE PTR $T276127[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T276128[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T276122[ebp]
	push	ecx
	mov	edx, DWORD PTR $T276133[ebp]
	push	edx
	mov	eax, DWORD PTR $T276121[ebp]
	push	eax
	call	??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<short,short> *,std::pair<short,short> *,std::allocator<std::pair<short,short> > >
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN9@operator@14:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::operator=
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??4?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -124						; size = 4
$T276176 = -32						; size = 4
$T276163 = -28						; size = 4
$T276151 = -24						; size = 4
$T276141 = -20						; size = 4
$T276140 = -16						; size = 4
$T276139 = -12						; size = 4
$T276138 = -8						; size = 4
$T276137 = -4						; size = 4
__Right$ = 8						; size = 4
??4?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::operator=, COMDAT
; _this$ = ecx

; 544  : 		{	// replace contents from _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	DWORD PTR _this$[ebp], ecx

; 545  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	SHORT $LN1@operator@15

; 546  : 			{	// worth doing
; 547  : 			erase(begin(), end());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T276151[ebp], edx
	mov	eax, DWORD PTR $T276151[ebp]
	mov	DWORD PTR $T276138[ebp], eax
	mov	ecx, DWORD PTR $T276138[ebp]
	mov	DWORD PTR $T276137[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T276163[ebp], eax
	mov	ecx, DWORD PTR $T276163[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T276176[ebp], edx
	mov	eax, DWORD PTR $T276176[ebp]
	mov	DWORD PTR $T276140[ebp], eax
	mov	ecx, DWORD PTR $T276140[ebp]
	mov	DWORD PTR $T276139[ebp], ecx
	mov	edx, DWORD PTR $T276137[ebp]
	push	edx
	mov	eax, DWORD PTR $T276139[ebp]
	push	eax
	lea	ecx, DWORD PTR $T276141[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::erase

; 548  : 			this->comp = _Right.comp;
; 549  : 			_Copy(_Right);

	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Copy
$LN1@operator@15:

; 550  : 			}
; 551  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 552  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::operator=
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?erase@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@0@Z$1
__ehfuncinfo$?erase@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?erase@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?erase@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@0@Z
_TEXT	SEGMENT
_this$ = -244						; size = 4
$T277168 = -240						; size = 4
$T277133 = -236						; size = 4
$T277132 = -232						; size = 4
$T277099 = -228						; size = 4
$T277098 = -224						; size = 4
__Cat$277140 = -134					; size = 1
$T277138 = -133						; size = 1
$T276726 = -132						; size = 4
$T276725 = -128						; size = 4
$T276724 = -124						; size = 4
$T276705 = -118						; size = 1
$T276704 = -117						; size = 1
$T276703 = -116						; size = 4
$T276702 = -112						; size = 4
__Cat$276712 = -28					; size = 1
$T276709 = -27						; size = 1
$T276708 = -26						; size = 1
$T276707 = -25						; size = 1
__Ptr$229540 = -24					; size = 4
__Last$ = -20						; size = 4
__First$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@0@Z PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?erase@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	$LN1@erase@14

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T276726[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T276725[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T276724[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T276707[ebp], cl
	mov	dl, BYTE PTR __Cat$276712[ebp]
	mov	BYTE PTR $T276708[ebp], dl
	mov	al, BYTE PTR $T276707[ebp]
	mov	BYTE PTR $T276705[ebp], al
	mov	cl, BYTE PTR $T276709[ebp]
	mov	BYTE PTR $T276704[ebp], cl
	mov	edx, DWORD PTR $T276726[ebp]
	mov	DWORD PTR $T276703[ebp], edx
	mov	eax, DWORD PTR $T276724[ebp]
	mov	DWORD PTR $T276702[ebp], eax
	jmp	SHORT $LN28@erase@14
$LN27@erase@14:
	mov	ecx, DWORD PTR $T276703[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR $T276703[ebp], ecx
	mov	edx, DWORD PTR $T276702[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR $T276702[ebp], edx
$LN28@erase@14:
	mov	eax, DWORD PTR $T276702[ebp]
	cmp	eax, DWORD PTR $T276725[ebp]
	je	SHORT $LN20@erase@14
	mov	ecx, DWORD PTR $T276702[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T276703[ebp]
	call	??4?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::operator=
	jmp	SHORT $LN27@erase@14
$LN20@erase@14:
	mov	edx, DWORD PTR $T276703[ebp]
	mov	DWORD PTR __Ptr$229540[ebp], edx

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T277168[ebp], ecx
	mov	edx, DWORD PTR $T277168[ebp]
	mov	DWORD PTR $T277133[ebp], edx
	mov	eax, DWORD PTR __Ptr$229540[ebp]
	mov	DWORD PTR $T277132[ebp], eax
	mov	cl, BYTE PTR __Cat$277140[ebp]
	mov	BYTE PTR $T277138[ebp], cl
	mov	edx, DWORD PTR $T277133[ebp]
	mov	DWORD PTR $T277099[ebp], edx
	mov	eax, DWORD PTR $T277132[ebp]
	mov	DWORD PTR $T277098[ebp], eax
	jmp	SHORT $LN110@erase@14
$LN109@erase@14:
	mov	ecx, DWORD PTR $T277098[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR $T277098[ebp], ecx
$LN110@erase@14:
	mov	edx, DWORD PTR $T277098[ebp]
	cmp	edx, DWORD PTR $T277099[ebp]
	je	SHORT $LN102@erase@14
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR $T277098[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	xor	eax, eax
	and	eax, 1
	je	SHORT $LN113@erase@14
	mov	ecx, DWORD PTR $T277098[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN113@erase@14:
	jmp	SHORT $LN109@erase@14
$LN102@erase@14:

; 1049 : 			_Mylast = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$229540[ebp]
	mov	DWORD PTR [edx+8], eax
$LN1@erase@14:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@0@Z$1:
	mov	ecx, DWORD PTR $T277098[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$?erase@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-236]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?erase@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@0@Z ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::erase
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@0@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
$T277316 = -64						; size = 4
$T277298 = -60						; size = 4
$T277297 = -56						; size = 4
$T277281 = -52						; size = 4
__Cat$277305 = -46					; size = 1
$T277303 = -45						; size = 1
$T277255 = -44						; size = 4
$T277254 = -40						; size = 4
$T277253 = -36						; size = 4
$T277236 = -30						; size = 1
$T277235 = -29						; size = 1
$T277234 = -28						; size = 4
$T277233 = -24						; size = 4
__Cat$277244 = -16					; size = 1
$T277241 = -15						; size = 1
$T277240 = -14						; size = 1
$T277239 = -13						; size = 1
__Ptr$229557 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@0@Z PROC ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	$LN1@erase@15

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T277255[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T277254[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T277253[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T277239[ebp], cl
	mov	dl, BYTE PTR __Cat$277244[ebp]
	mov	BYTE PTR $T277240[ebp], dl
	mov	al, BYTE PTR $T277239[ebp]
	mov	BYTE PTR $T277236[ebp], al
	mov	cl, BYTE PTR $T277241[ebp]
	mov	BYTE PTR $T277235[ebp], cl
	mov	edx, DWORD PTR $T277255[ebp]
	mov	DWORD PTR $T277234[ebp], edx
	mov	eax, DWORD PTR $T277253[ebp]
	mov	DWORD PTR $T277233[ebp], eax
	jmp	SHORT $LN28@erase@15
$LN27@erase@15:
	mov	ecx, DWORD PTR $T277234[ebp]
	add	ecx, 4
	mov	DWORD PTR $T277234[ebp], ecx
	mov	edx, DWORD PTR $T277233[ebp]
	add	edx, 4
	mov	DWORD PTR $T277233[ebp], edx
$LN28@erase@15:
	mov	eax, DWORD PTR $T277233[ebp]
	cmp	eax, DWORD PTR $T277254[ebp]
	je	SHORT $LN20@erase@15
	mov	ecx, DWORD PTR $T277233[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR $T277234[ebp]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN27@erase@15
$LN20@erase@15:
	mov	ecx, DWORD PTR $T277234[ebp]
	mov	DWORD PTR __Ptr$229557[ebp], ecx

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T277316[ebp], eax
	mov	ecx, DWORD PTR $T277316[ebp]
	mov	DWORD PTR $T277298[ebp], ecx
	mov	edx, DWORD PTR __Ptr$229557[ebp]
	mov	DWORD PTR $T277297[ebp], edx
	mov	al, BYTE PTR __Cat$277305[ebp]
	mov	BYTE PTR $T277303[ebp], al
	mov	ecx, DWORD PTR $T277297[ebp]
	mov	DWORD PTR $T277281[ebp], ecx
	jmp	SHORT $LN39@erase@15
$LN38@erase@15:
	mov	edx, DWORD PTR $T277281[ebp]
	add	edx, 4
	mov	DWORD PTR $T277281[ebp], edx
$LN39@erase@15:
	mov	eax, DWORD PTR $T277281[ebp]
	cmp	eax, DWORD PTR $T277298[ebp]
	je	SHORT $LN31@erase@15
	jmp	SHORT $LN38@erase@15
$LN31@erase@15:

; 1049 : 			_Mylast = _Ptr;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Ptr$229557[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN1@erase@15:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@0@Z ENDP ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::erase
_TEXT	ENDS
PUBLIC	??$SerializeToSequenceContainer@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z ; SerializeToSequenceContainer<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$?5V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z PROC ; operator>><std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >, COMDAT

; 225  : {

	push	ebp
	mov	ebp, esp

; 226  : 	// The functor needs to be instantiated to properly resize the container based 
; 227  : 	// on how many elements the stream says it should have before passing it along
; 228  : 	// to std::for_each
; 229  : 	SerializeToSequenceContainer<ElementType, std::vector<ElementType> >(loadFrom, writeTo);

	mov	eax, DWORD PTR _writeTo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	push	ecx
	call	??$SerializeToSequenceContainer@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z ; SerializeToSequenceContainer<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >
	add	esp, 8

; 230  : 
; 231  : 	//std::for_each(writeTo.begin(), writeTo.end(), func);
; 232  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 233  : }

	pop	ebp
	ret	0
??$?5V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z ENDP ; operator>><std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >
_TEXT	ENDS
PUBLIC	??$SerializeToAssociativeContainer@U?$pair@IUPlotState@CvReplayInfo@@@std@@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@@YAXAAVFDataStream@@AAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@Z ; SerializeToAssociativeContainer<std::pair<unsigned int,CvReplayInfo::PlotState>,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >
; Function compile flags: /Odtp
;	COMDAT ??$?5IUPlotState@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@AAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5IUPlotState@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@AAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@Z PROC ; operator>><unsigned int,CvReplayInfo::PlotState>, COMDAT

; 237  : {

	push	ebp
	mov	ebp, esp

; 238  : 	SerializeToAssociativeContainer<std::pair<KeyType, ElementType>, std::map<KeyType, ElementType> >(loadFrom, writeTo);

	mov	eax, DWORD PTR _writeTo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	push	ecx
	call	??$SerializeToAssociativeContainer@U?$pair@IUPlotState@CvReplayInfo@@@std@@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@@YAXAAVFDataStream@@AAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@Z ; SerializeToAssociativeContainer<std::pair<unsigned int,CvReplayInfo::PlotState>,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >
	add	esp, 8

; 239  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 240  : }

	pop	ebp
	ret	0
??$?5IUPlotState@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@AAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@Z ENDP ; operator>><unsigned int,CvReplayInfo::PlotState>
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$25 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z DD 01H
	DD	02H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$25
__ehfuncinfo$??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	00H
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$5
	DD	00H
	DD	00H
	DD	03H
	DD	FLAT:__unwindfunclet$??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$14
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$20
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv177 = -188						; size = 4
$T277517 = -104						; size = 4
$T277394 = -60						; size = 4
$T277393 = -56						; size = 4
__Vptr$277391 = -52					; size = 4
$T277323 = -36						; size = 4
__Val$ = -32						; size = 12
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<std::_Vector_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >, COMDAT

; 214  : 	{	// use swap to instead of the copy constructor

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 172				; 000000acH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 215  : 	_DEBUG_RANGE(_First, _Last);
; 216  : 	_DEBUG_POINTER(_Dest);
; 217  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 218  : 	// empty value used in the construction
; 219  : 	typename _Alloc::value_type _Val;

	lea	ecx, DWORD PTR __Val$[ebp]
	call	??0?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAE@XZ ; std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 220  : 
; 221  : 	_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 222  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN29@Uninit_mov
$LN5@Uninit_mov:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR __First$[ebp], edx
$LN29@Uninit_mov:
	mov	eax, DWORD PTR __First$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN4@Uninit_mov

; 223  : 		{
; 224  : 		_Al.construct(_Dest, _Val);

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$277391[ebp], ecx
	mov	edx, DWORD PTR __Vptr$277391[ebp]
	mov	DWORD PTR $T277394[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	cmp	DWORD PTR $T277394[ebp], 0
	je	SHORT $LN37@Uninit_mov
	lea	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T277394[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >
	mov	ecx, DWORD PTR $T277394[ebp]
	mov	DWORD PTR tv177[ebp], ecx
	jmp	SHORT $LN38@Uninit_mov
$LN37@Uninit_mov:
	mov	DWORD PTR tv177[ebp], 0
$LN38@Uninit_mov:
	mov	edx, DWORD PTR tv177[ebp]
	mov	DWORD PTR $T277393[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 225  : 		_STD _Swap_adl(*_Dest, *_First);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T277517[ebp], eax
	mov	ecx, DWORD PTR $T277517[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Dest$[ebp]
	call	?swap@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXAAV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::swap

; 226  : 		}

	jmp	$LN5@Uninit_mov
$LN4@Uninit_mov:
	jmp	SHORT $LN10@Uninit_mov
__catch$??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 227  : 	_CATCH_ALL
; 228  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_mov
$LN2@Uninit_mov:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_mov:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_mov

; 229  : 		_Al.destroy(_Next);

	mov	BYTE PTR __$EHRec$[ebp+12], 4
	mov	ecx, DWORD PTR __Next$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	xor	ecx, ecx
	and	ecx, 1
	je	SHORT $LN99@Uninit_mov
	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN99@Uninit_mov:
	jmp	SHORT $LN2@Uninit_mov
$LN1@Uninit_mov:

; 230  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 231  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, __tryend$??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_mov:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
__tryend$??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 232  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T277323[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	DWORD PTR __$EHRec$[ebp+12], 5
	lea	ecx, DWORD PTR __Val$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR $T277323[ebp]
$LN9@Uninit_mov:

; 233  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	lea	ecx, DWORD PTR __Val$[ebp]
	jmp	??1?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAE@XZ
__unwindfunclet$??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$5:
	mov	eax, DWORD PTR __Vptr$277391[ebp]
	push	eax
	mov	ecx, DWORD PTR $T277394[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$14:
	mov	ecx, DWORD PTR __Next$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$20:
	lea	ecx, DWORD PTR __Val$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__ehhandler$??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-192]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@V?$_Vector_iterator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<std::_Vector_iterator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > >,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv95 = -36						; size = 4
$T277949 = -32						; size = 4
$T277943 = -28						; size = 4
__Vptr$277941 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_const_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > >,std::pair<short,short> *,std::allocator<std::pair<short,short> > >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN16@Uninit_cop
$LN5@Uninit_cop:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 4
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 4
	mov	DWORD PTR __First$[ebp], edx
$LN16@Uninit_cop:
	mov	eax, DWORD PTR __First$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN4@Uninit_cop

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T277949[ebp], ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$277941[ebp], edx
	mov	eax, DWORD PTR __Vptr$277941[ebp]
	mov	DWORD PTR $T277943[ebp], eax
	cmp	DWORD PTR $T277943[ebp], 0
	je	SHORT $LN26@Uninit_cop
	mov	ecx, DWORD PTR $T277949[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR $T277943[ebp]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR $T277943[ebp]
	mov	DWORD PTR tv95[ebp], ecx
	jmp	SHORT $LN22@Uninit_cop
$LN26@Uninit_cop:
	mov	DWORD PTR tv95[ebp], 0
$LN22@Uninit_cop:
	jmp	SHORT $LN5@Uninit_cop
$LN4@Uninit_cop:
	jmp	SHORT $LN10@Uninit_cop
__catch$??$_Uninit_copy@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop
$LN2@Uninit_cop:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 4
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_cop:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop

; 134  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_cop
$LN1@Uninit_cop:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_const_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > >,std::pair<short,short> *,std::allocator<std::pair<short,short> > >
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z DD 01H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$4
__unwindtable$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	00H
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$3
	DD	00H
	DD	00H
__ehfuncinfo$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv128 = -76						; size = 4
tv77 = -72						; size = 4
$T278000 = -68						; size = 4
$T277999 = -64						; size = 4
__Vptr$277997 = -60					; size = 4
$T277970 = -56						; size = 4
__Val$ = -52						; size = 28
__$ArrayPad$ = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 214  : 	{	// use swap to instead of the copy constructor

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 215  : 	_DEBUG_RANGE(_First, _Last);
; 216  : 	_DEBUG_POINTER(_Dest);
; 217  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 218  : 	// empty value used in the construction
; 219  : 	typename _Alloc::value_type _Val;

	lea	ecx, DWORD PTR __Val$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 220  : 
; 221  : 	_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 222  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_mov@2
$LN5@Uninit_mov@2:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 28					; 0000001cH
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_mov@2:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_mov@2

; 223  : 		{
; 224  : 		_Al.construct(_Dest, _Val);

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$277997[ebp], ecx
	mov	edx, DWORD PTR __Vptr$277997[ebp]
	mov	DWORD PTR $T278000[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	cmp	DWORD PTR $T278000[ebp], 0
	je	SHORT $LN19@Uninit_mov@2
	lea	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T278000[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv77[ebp], eax
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR tv128[ebp], ecx
	jmp	SHORT $LN20@Uninit_mov@2
$LN19@Uninit_mov@2:
	mov	DWORD PTR tv128[ebp], 0
$LN20@Uninit_mov@2:
	mov	edx, DWORD PTR tv128[ebp]
	mov	DWORD PTR $T277999[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 225  : 		_STD _Swap_adl(*_Dest, *_First);

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	call	DWORD PTR __imp_?swap@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXAAV12@@Z

; 226  : 		}

	jmp	SHORT $LN5@Uninit_mov@2
$LN4@Uninit_mov@2:
	jmp	SHORT $LN10@Uninit_mov@2
__catch$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 227  : 	_CATCH_ALL
; 228  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_mov@2
$LN2@Uninit_mov@2:
	mov	ecx, DWORD PTR __Next$[ebp]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR __Next$[ebp], ecx
$LN3@Uninit_mov@2:
	mov	edx, DWORD PTR __Next$[ebp]
	cmp	edx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_mov@2

; 229  : 		_Al.destroy(_Next);

	mov	ecx, DWORD PTR __Next$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	xor	eax, eax
	and	eax, 1
	je	SHORT $LN28@Uninit_mov@2
	mov	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN28@Uninit_mov@2:
	jmp	SHORT $LN2@Uninit_mov@2
$LN1@Uninit_mov@2:

; 230  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 231  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, __tryend$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_mov@2:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
__tryend$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 232  : 	return (_Dest);

	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T277970[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Val$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR $T277970[ebp]
$LN9@Uninit_mov@2:

; 233  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	lea	ecx, DWORD PTR __Val$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$3:
	mov	eax, DWORD PTR __Vptr$277997[ebp]
	push	eax
	mov	ecx, DWORD PTR $T278000[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$26 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z DD 01H
	DD	02H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$26
__ehfuncinfo$??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	00H
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$6
	DD	00H
	DD	00H
	DD	03H
	DD	FLAT:__unwindfunclet$??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$15
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$21
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv164 = -196						; size = 4
$T278117 = -72						; size = 4
$T278116 = -68						; size = 4
__Vptr$278114 = -64					; size = 4
$T278084 = -38						; size = 1
$T278083 = -37						; size = 1
$T278043 = -36						; size = 4
__Val$ = -32						; size = 12
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >, COMDAT

; 214  : 	{	// use swap to instead of the copy constructor

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 180				; 000000b4H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 215  : 	_DEBUG_RANGE(_First, _Last);
; 216  : 	_DEBUG_POINTER(_Dest);
; 217  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 218  : 	// empty value used in the construction
; 219  : 	typename _Alloc::value_type _Val;

	lea	ecx, DWORD PTR $T278083[ebp]
	push	ecx
	lea	edx, DWORD PTR $T278084[ebp]
	push	edx
	lea	ecx, DWORD PTR __Val$[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 220  : 
; 221  : 	_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 222  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_mov@3
$LN5@Uninit_mov@3:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR __First$[ebp], ecx
$LN6@Uninit_mov@3:
	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_mov@3

; 223  : 		{
; 224  : 		_Al.construct(_Dest, _Val);

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$278114[ebp], eax
	mov	ecx, DWORD PTR __Vptr$278114[ebp]
	mov	DWORD PTR $T278117[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	cmp	DWORD PTR $T278117[ebp], 0
	je	SHORT $LN36@Uninit_mov@3
	lea	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T278117[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
	mov	eax, DWORD PTR $T278117[ebp]
	mov	DWORD PTR tv164[ebp], eax
	jmp	SHORT $LN37@Uninit_mov@3
$LN36@Uninit_mov@3:
	mov	DWORD PTR tv164[ebp], 0
$LN37@Uninit_mov@3:
	mov	ecx, DWORD PTR tv164[ebp]
	mov	DWORD PTR $T278116[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 225  : 		_STD _Swap_adl(*_Dest, *_First);

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Dest$[ebp]
	call	?swap@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::swap

; 226  : 		}

	jmp	SHORT $LN5@Uninit_mov@3
$LN4@Uninit_mov@3:
	jmp	SHORT $LN10@Uninit_mov@3
__catch$??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 227  : 	_CATCH_ALL
; 228  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_mov@3
$LN2@Uninit_mov@3:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_mov@3:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_mov@3

; 229  : 		_Al.destroy(_Next);

	mov	BYTE PTR __$EHRec$[ebp+12], 4
	mov	ecx, DWORD PTR __Next$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	xor	edx, edx
	and	edx, 1
	je	SHORT $LN94@Uninit_mov@3
	mov	eax, DWORD PTR __Next$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN94@Uninit_mov@3:
	jmp	SHORT $LN2@Uninit_mov@3
$LN1@Uninit_mov@3:

; 230  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 231  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, __tryend$??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_mov@3:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
__tryend$??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 232  : 	return (_Dest);

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T278043[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	DWORD PTR __$EHRec$[ebp+12], 5
	lea	ecx, DWORD PTR __Val$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR $T278043[ebp]
$LN9@Uninit_mov@3:

; 233  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	lea	ecx, DWORD PTR __Val$[ebp]
	jmp	??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ
__unwindfunclet$??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$6:
	mov	eax, DWORD PTR __Vptr$278114[ebp]
	push	eax
	mov	ecx, DWORD PTR $T278117[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$15:
	mov	ecx, DWORD PTR __Next$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$21:
	lea	ecx, DWORD PTR __Val$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-200]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAUPlayerInfo@CvReplayInfo@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUPlayerInfo@CvReplayInfo@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::random_access_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
$LN2@Copy_backw:

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_backw

; 2676 : 		*--_Dest = *--_Last;

	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, 128				; 00000080H
	mov	DWORD PTR __Last$[ebp], ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, 128				; 00000080H
	mov	DWORD PTR __Dest$[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	call	??4PlayerInfo@CvReplayInfo@@QAEAAU01@ABU01@@Z
	jmp	SHORT $LN2@Copy_backw
$LN1@Copy_backw:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2678 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@PAUPlayerInfo@CvReplayInfo@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::random_access_iterator_tag>
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$31 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z DD 01H
	DD	02H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$31
__ehfuncinfo$??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	00H
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$5
	DD	00H
	DD	00H
	DD	03H
	DD	FLAT:__unwindfunclet$??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$15
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$23
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv154 = -240						; size = 4
tv74 = -236						; size = 4
$T278697 = -72						; size = 4
$T278696 = -68						; size = 4
__Vptr$278703 = -64					; size = 4
$T278638 = -40						; size = 4
__Val$ = -36						; size = 16
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >, COMDAT

; 214  : 	{	// use swap to instead of the copy constructor

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 224				; 000000e0H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 215  : 	_DEBUG_RANGE(_First, _Last);
; 216  : 	_DEBUG_POINTER(_Dest);
; 217  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 218  : 	// empty value used in the construction
; 219  : 	typename _Alloc::value_type _Val;

	lea	ecx, DWORD PTR __Val$[ebp]
	call	??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 220  : 
; 221  : 	_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 222  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_mov@4
$LN5@Uninit_mov@4:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_mov@4:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_mov@4

; 223  : 		{
; 224  : 		_Al.construct(_Dest, _Val);

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$278703[ebp], ecx
	mov	edx, DWORD PTR __Vptr$278703[ebp]
	mov	DWORD PTR $T278697[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	cmp	DWORD PTR $T278697[ebp], 0
	je	SHORT $LN33@Uninit_mov@4
	lea	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T278697[ebp]
	call	??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
	mov	DWORD PTR tv74[ebp], eax
	mov	ecx, DWORD PTR tv74[ebp]
	mov	DWORD PTR tv154[ebp], ecx
	jmp	SHORT $LN34@Uninit_mov@4
$LN33@Uninit_mov@4:
	mov	DWORD PTR tv154[ebp], 0
$LN34@Uninit_mov@4:
	mov	edx, DWORD PTR tv154[ebp]
	mov	DWORD PTR $T278696[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 225  : 		_STD _Swap_adl(*_Dest, *_First);

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	call	?swap@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXAAV12@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::swap

; 226  : 		}

	jmp	SHORT $LN5@Uninit_mov@4
$LN4@Uninit_mov@4:
	jmp	SHORT $LN10@Uninit_mov@4
__catch$??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 227  : 	_CATCH_ALL
; 228  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_mov@4
$LN2@Uninit_mov@4:
	mov	ecx, DWORD PTR __Next$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __Next$[ebp], ecx
$LN3@Uninit_mov@4:
	mov	edx, DWORD PTR __Next$[ebp]
	cmp	edx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_mov@4

; 229  : 		_Al.destroy(_Next);

	mov	BYTE PTR __$EHRec$[ebp+12], 4
	mov	ecx, DWORD PTR __Next$[ebp]
	call	?_Tidy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	xor	eax, eax
	and	eax, 1
	je	SHORT $LN115@Uninit_mov@4
	mov	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN115@Uninit_mov@4:
	jmp	SHORT $LN2@Uninit_mov@4
$LN1@Uninit_mov@4:

; 230  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 231  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, __tryend$??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_mov@4:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
__tryend$??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 232  : 	return (_Dest);

	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T278638[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+12], 5
	lea	ecx, DWORD PTR __Val$[ebp]
	call	?_Tidy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR $T278638[ebp]
$LN9@Uninit_mov@4:

; 233  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	lea	ecx, DWORD PTR __Val$[ebp]
	jmp	??1?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::~vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
__unwindfunclet$??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$5:
	mov	eax, DWORD PTR __Vptr$278703[ebp]
	push	eax
	mov	ecx, DWORD PTR $T278697[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$15:
	mov	ecx, DWORD PTR __Next$[ebp]
	jmp	??1?$_Vector_val@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ
__unwindfunclet$??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$23:
	lea	ecx, DWORD PTR __Val$[ebp]
	jmp	??1?$_Vector_val@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ
__ehhandler$??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-244]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV12@V?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@2@@std@@YAPAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@PAV10@00AAV?$allocator@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > *,std::allocator<std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$26 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z DD 01H
	DD	02H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$26
__ehfuncinfo$??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	00H
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$6
	DD	00H
	DD	00H
	DD	03H
	DD	FLAT:__unwindfunclet$??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$15
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$21
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv164 = -196						; size = 4
$T279638 = -72						; size = 4
$T279637 = -68						; size = 4
__Vptr$279646 = -64					; size = 4
$T279606 = -38						; size = 1
$T279605 = -37						; size = 1
$T279566 = -36						; size = 4
__Val$ = -32						; size = 12
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >, COMDAT

; 214  : 	{	// use swap to instead of the copy constructor

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 180				; 000000b4H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 215  : 	_DEBUG_RANGE(_First, _Last);
; 216  : 	_DEBUG_POINTER(_Dest);
; 217  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 218  : 	// empty value used in the construction
; 219  : 	typename _Alloc::value_type _Val;

	lea	ecx, DWORD PTR $T279605[ebp]
	push	ecx
	lea	edx, DWORD PTR $T279606[ebp]
	push	edx
	lea	ecx, DWORD PTR __Val$[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 220  : 
; 221  : 	_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 222  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_mov@5
$LN5@Uninit_mov@5:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR __First$[ebp], ecx
$LN6@Uninit_mov@5:
	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_mov@5

; 223  : 		{
; 224  : 		_Al.construct(_Dest, _Val);

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$279646[ebp], eax
	mov	ecx, DWORD PTR __Vptr$279646[ebp]
	mov	DWORD PTR $T279638[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	cmp	DWORD PTR $T279638[ebp], 0
	je	SHORT $LN36@Uninit_mov@5
	lea	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T279638[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >
	mov	eax, DWORD PTR $T279638[ebp]
	mov	DWORD PTR tv164[ebp], eax
	jmp	SHORT $LN37@Uninit_mov@5
$LN36@Uninit_mov@5:
	mov	DWORD PTR tv164[ebp], 0
$LN37@Uninit_mov@5:
	mov	ecx, DWORD PTR tv164[ebp]
	mov	DWORD PTR $T279637[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 225  : 		_STD _Swap_adl(*_Dest, *_First);

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Dest$[ebp]
	call	?swap@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXAAV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::swap

; 226  : 		}

	jmp	SHORT $LN5@Uninit_mov@5
$LN4@Uninit_mov@5:
	jmp	SHORT $LN10@Uninit_mov@5
__catch$??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 227  : 	_CATCH_ALL
; 228  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_mov@5
$LN2@Uninit_mov@5:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_mov@5:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_mov@5

; 229  : 		_Al.destroy(_Next);

	mov	BYTE PTR __$EHRec$[ebp+12], 4
	mov	ecx, DWORD PTR __Next$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	xor	edx, edx
	and	edx, 1
	je	SHORT $LN94@Uninit_mov@5
	mov	eax, DWORD PTR __Next$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN94@Uninit_mov@5:
	jmp	SHORT $LN2@Uninit_mov@5
$LN1@Uninit_mov@5:

; 230  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 231  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, __tryend$??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_mov@5:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
__tryend$??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 232  : 	return (_Dest);

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T279566[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	DWORD PTR __$EHRec$[ebp+12], 5
	lea	ecx, DWORD PTR __Val$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR $T279566[ebp]
$LN9@Uninit_mov@5:

; 233  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	lea	ecx, DWORD PTR __Val$[ebp]
	jmp	??1?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@QAE@XZ
__unwindfunclet$??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$6:
	mov	eax, DWORD PTR __Vptr$279646[ebp]
	push	eax
	mov	ecx, DWORD PTR $T279638[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$15:
	mov	ecx, DWORD PTR __Next$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$21:
	lea	ecx, DWORD PTR __Val$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__ehhandler$??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-200]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@PAV12@V?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@2@@std@@YAPAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@0@PAV10@00AAV?$allocator@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > *,std::allocator<std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$10 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$10
__unwindtable$??$_Uninit_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
	DD	02H
	DD	FLAT:__unwindfunclet$??$_Uninit_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$5
__ehfuncinfo$??$_Uninit_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??$_Uninit_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv132 = -124						; size = 4
$T280198 = -36						; size = 4
$T280190 = -32						; size = 4
$T280189 = -28						; size = 4
__Vptr$280187 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 108				; 0000006cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN16@Uninit_cop@2
$LN5@Uninit_cop@2:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR __First$[ebp], edx
$LN16@Uninit_cop@2:
	mov	eax, DWORD PTR __First$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN4@Uninit_cop@2

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T280198[ebp], ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$280187[ebp], edx
	mov	eax, DWORD PTR __Vptr$280187[ebp]
	mov	DWORD PTR $T280190[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T280190[ebp], 0
	je	SHORT $LN26@Uninit_cop@2
	mov	ecx, DWORD PTR $T280198[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T280190[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
	mov	edx, DWORD PTR $T280190[ebp]
	mov	DWORD PTR tv132[ebp], edx
	jmp	SHORT $LN27@Uninit_cop@2
$LN26@Uninit_cop@2:
	mov	DWORD PTR tv132[ebp], 0
$LN27@Uninit_cop@2:
	mov	eax, DWORD PTR tv132[ebp]
	mov	DWORD PTR $T280189[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN5@Uninit_cop@2
$LN4@Uninit_cop@2:
	jmp	SHORT $LN10@Uninit_cop@2
__catch$??$_Uninit_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@2
$LN2@Uninit_cop@2:
	mov	ecx, DWORD PTR __Next$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR __Next$[ebp], ecx
$LN3@Uninit_cop@2:
	mov	edx, DWORD PTR __Next$[ebp]
	cmp	edx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@2

; 134  : 		_Al.destroy(_Next);

	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR __Next$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	xor	eax, eax
	and	eax, 1
	je	SHORT $LN34@Uninit_cop@2
	mov	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN34@Uninit_cop@2:
	jmp	SHORT $LN2@Uninit_cop@2
$LN1@Uninit_cop@2:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@2:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$280187[ebp]
	push	eax
	mov	ecx, DWORD PTR $T280190[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??$_Uninit_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$5:
	mov	ecx, DWORD PTR __Next$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??$_Uninit_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-128]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_const_iterator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$?6V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z
_TEXT	SEGMENT
$T280623 = -68						; size = 8
$T280622 = -60						; size = 4
$T280621 = -56						; size = 4
$T280603 = -52						; size = 4
__ChkFirst$280616 = -48					; size = 4
__ChkLast$280617 = -44					; size = 4
$T280580 = -40						; size = 4
$T280571 = -36						; size = 4
$T280559 = -32						; size = 4
$T280562 = -28						; size = 4
$T280550 = -24						; size = 8
$T280549 = -16						; size = 4
$T280548 = -12						; size = 4
$T280547 = -8						; size = 8
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??$?6V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z PROC ; operator<<<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >, COMDAT

; 198  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H

; 199  : 	std::for_each(readFrom.begin(), readFrom.end(), SerializeFromSequenceContainer<const ElementType, const std::vector<ElementType> >(saveTo, readFrom));

	mov	eax, DWORD PTR _saveTo$[ebp]
	mov	DWORD PTR $T280547[ebp], eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	DWORD PTR $T280547[ebp+4], ecx
	mov	edx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR $T280562[ebp], eax
	mov	edx, DWORD PTR $T280547[ebp]
	mov	DWORD PTR $T280559[ebp], edx
	lea	eax, DWORD PTR $T280562[ebp]
	push	eax
	mov	ecx, DWORD PTR $T280559[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T280571[ebp], edx
	mov	eax, DWORD PTR $T280571[ebp]
	mov	DWORD PTR $T280548[ebp], eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T280580[ebp], edx
	mov	eax, DWORD PTR $T280580[ebp]
	mov	DWORD PTR $T280549[ebp], eax
	mov	ecx, DWORD PTR $T280547[ebp]
	mov	DWORD PTR $T280623[ebp], ecx
	mov	edx, DWORD PTR $T280547[ebp+4]
	mov	DWORD PTR $T280623[ebp+4], edx
	mov	eax, DWORD PTR $T280548[ebp]
	mov	DWORD PTR $T280622[ebp], eax
	mov	ecx, DWORD PTR $T280549[ebp]
	mov	DWORD PTR $T280621[ebp], ecx
	mov	edx, DWORD PTR $T280621[ebp]
	mov	DWORD PTR __ChkFirst$280616[ebp], edx
	mov	eax, DWORD PTR $T280622[ebp]
	mov	DWORD PTR __ChkLast$280617[ebp], eax
	jmp	SHORT $LN24@operator@16
$LN18@operator@16:
	mov	ecx, DWORD PTR __ChkFirst$280616[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR __ChkFirst$280616[ebp], ecx
$LN24@operator@16:
	mov	edx, DWORD PTR __ChkFirst$280616[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __ChkLast$280617[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN17@operator@16
	mov	eax, DWORD PTR __ChkFirst$280616[ebp]
	mov	DWORD PTR $T280603[ebp], eax
	mov	ecx, DWORD PTR $T280603[ebp]
	push	ecx
	mov	edx, DWORD PTR $T280623[ebp]
	push	edx
	call	??6@YAAAVFDataStream@@AAV0@ABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@Z ; operator<<
	add	esp, 8
	jmp	SHORT $LN18@operator@16
$LN17@operator@16:
	mov	eax, DWORD PTR $T280623[ebp]
	mov	DWORD PTR $T280550[ebp], eax
	mov	ecx, DWORD PTR $T280623[ebp+4]
	mov	DWORD PTR $T280550[ebp+4], ecx

; 200  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 201  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?6V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z ENDP ; operator<<<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > >
_TEXT	ENDS
PUBLIC	??$for_each@Vconst_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@U?$SerializeFromAssociativeContainer@U?$pair@IUPlotState@CvReplayInfo@@@std@@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@@@std@@YA?AU?$SerializeFromAssociativeContainer@U?$pair@IUPlotState@CvReplayInfo@@@std@@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@@Vconst_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@0@0U1@@Z ; std::for_each<std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator,SerializeFromAssociativeContainer<std::pair<unsigned int,CvReplayInfo::PlotState>,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > const > >
; Function compile flags: /Odtp
;	COMDAT ??$?6IUPlotState@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@ABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@Z
_TEXT	SEGMENT
$T280668 = -48						; size = 4
$T280660 = -44						; size = 4
$T280650 = -40						; size = 4
$T280638 = -36						; size = 4
$T280634 = -32						; size = 4
_count$280645 = -28					; size = 4
$T280629 = -24						; size = 8
$T280628 = -16						; size = 4
$T280627 = -12						; size = 4
$T280626 = -8						; size = 8
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??$?6IUPlotState@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@ABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@Z PROC ; operator<<<unsigned int,CvReplayInfo::PlotState>, COMDAT

; 156  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H

; 157  : 	std::for_each(readFrom.begin(), readFrom.end(), SerializeFromAssociativeContainer<std::pair<KeyType, ElementType>, const std::map<KeyType, ElementType> >(saveTo, readFrom));

	mov	eax, DWORD PTR _saveTo$[ebp]
	mov	DWORD PTR $T280626[ebp], eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	DWORD PTR $T280626[ebp+4], ecx
	mov	edx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T280634[ebp], eax
	mov	ecx, DWORD PTR $T280634[ebp]
	mov	DWORD PTR _count$280645[ebp], ecx
	mov	edx, DWORD PTR $T280626[ebp]
	mov	DWORD PTR $T280638[ebp], edx
	lea	eax, DWORD PTR _count$280645[ebp]
	push	eax
	mov	ecx, DWORD PTR $T280638[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T280650[ebp], edx
	mov	eax, DWORD PTR $T280650[ebp]
	mov	DWORD PTR $T280627[ebp], eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T280660[ebp], edx
	mov	eax, DWORD PTR $T280660[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T280668[ebp], ecx
	mov	edx, DWORD PTR $T280668[ebp]
	mov	DWORD PTR $T280628[ebp], edx
	mov	eax, DWORD PTR $T280626[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T280626[ebp]
	push	ecx
	mov	edx, DWORD PTR $T280627[ebp]
	push	edx
	mov	eax, DWORD PTR $T280628[ebp]
	push	eax
	lea	ecx, DWORD PTR $T280629[ebp]
	push	ecx
	call	??$for_each@Vconst_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@U?$SerializeFromAssociativeContainer@U?$pair@IUPlotState@CvReplayInfo@@@std@@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@@@std@@YA?AU?$SerializeFromAssociativeContainer@U?$pair@IUPlotState@CvReplayInfo@@@std@@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@@Vconst_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@0@0U1@@Z ; std::for_each<std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator,SerializeFromAssociativeContainer<std::pair<unsigned int,CvReplayInfo::PlotState>,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > const > >
	add	esp, 20					; 00000014H

; 158  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 159  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?6IUPlotState@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@ABV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@Z ENDP ; operator<<<unsigned int,CvReplayInfo::PlotState>
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??$SerializeToSequenceContainer@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$SerializeToSequenceContainer@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$SerializeToSequenceContainer@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z$11
__ehfuncinfo$??$SerializeToSequenceContainer@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$SerializeToSequenceContainer@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
xdata$x	ENDS
;	COMDAT ??$SerializeToSequenceContainer@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z
_TEXT	SEGMENT
$T281150 = -98						; size = 1
$T281149 = -97						; size = 1
$T280784 = -60						; size = 4
$T280768 = -56						; size = 4
$T281070 = -52						; size = 4
$T281069 = -48						; size = 4
$T281068 = -44						; size = 4
$T281067 = -40						; size = 4
$T281066 = -36						; size = 4
_v$230132 = -32						; size = 12
_i$ = -20						; size = 4
_count$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_loadFrom$ = 8						; size = 4
_container$ = 12					; size = 4
??$SerializeToSequenceContainer@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z PROC ; SerializeToSequenceContainer<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >, COMDAT

; 83   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$SerializeToSequenceContainer@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 252				; 000000fcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 84   : 	container.clear();

	mov	eax, DWORD PTR _container$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T280768[ebp], ecx
	mov	edx, DWORD PTR $T280768[ebp]
	mov	DWORD PTR $T281067[ebp], edx
	mov	eax, DWORD PTR $T281067[ebp]
	mov	DWORD PTR $T281066[ebp], eax
	mov	ecx, DWORD PTR _container$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T280784[ebp], edx
	mov	eax, DWORD PTR $T280784[ebp]
	mov	DWORD PTR $T281069[ebp], eax
	mov	ecx, DWORD PTR $T281069[ebp]
	mov	DWORD PTR $T281068[ebp], ecx
	mov	edx, DWORD PTR $T281066[ebp]
	push	edx
	mov	eax, DWORD PTR $T281068[ebp]
	push	eax
	lea	ecx, DWORD PTR $T281070[ebp]
	push	ecx
	mov	ecx, DWORD PTR _container$[ebp]
	call	?erase@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@0@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::erase

; 85   : 	ContainerType::size_type count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 86   : 	loadFrom >> count;

	lea	edx, DWORD PTR _count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 87   : 	ContainerType::size_type i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 88   : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@SerializeT@7
$LN2@SerializeT@7:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@SerializeT@7:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _count$[ebp]
	jae	SHORT $LN4@SerializeT@7

; 89   : 	{
; 90   : 		ElementType v;

	lea	edx, DWORD PTR $T281149[ebp]
	push	edx
	lea	eax, DWORD PTR $T281150[ebp]
	push	eax
	lea	ecx, DWORD PTR _v$230132[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 91   : 		loadFrom >> v;

	lea	ecx, DWORD PTR _v$230132[ebp]
	push	ecx
	mov	edx, DWORD PTR _loadFrom$[ebp]
	push	edx
	call	??5@YAAAVFDataStream@@AAV0@AAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@Z ; operator>>
	add	esp, 8

; 92   : 		container.push_back(v);

	lea	eax, DWORD PTR _v$230132[ebp]
	push	eax
	mov	ecx, DWORD PTR _container$[ebp]
	call	?push_back@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXABV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@2@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::push_back

; 93   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _v$230132[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	jmp	SHORT $LN2@SerializeT@7
$LN4@SerializeT@7:

; 94   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$SerializeToSequenceContainer@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z$0:
	lea	ecx, DWORD PTR _v$230132[ebp]
	jmp	??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ
__unwindfunclet$??$SerializeToSequenceContainer@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z$11:
	lea	ecx, DWORD PTR _v$230132[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??$SerializeToSequenceContainer@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-256]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$SerializeToSequenceContainer@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$SerializeToSequenceContainer@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@2@@@YAXAAVFDataStream@@AAV?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@@Z ENDP ; SerializeToSequenceContainer<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > > >
PUBLIC	??$?5IUPlotState@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@AAU?$pair@IUPlotState@CvReplayInfo@@@std@@@Z ; operator>><unsigned int,CvReplayInfo::PlotState>
; Function compile flags: /Odtp
;	COMDAT ??$SerializeToAssociativeContainer@U?$pair@IUPlotState@CvReplayInfo@@@std@@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@@YAXAAVFDataStream@@AAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@Z
_TEXT	SEGMENT
$T281617 = -80						; size = 16
$T281555 = -56						; size = 8
$T281554 = -48						; size = 20
_e$230187 = -28						; size = 20
_i$ = -8						; size = 4
_count$ = -4						; size = 4
_loadFrom$ = 8						; size = 4
_container$ = 12					; size = 4
??$SerializeToAssociativeContainer@U?$pair@IUPlotState@CvReplayInfo@@@std@@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@@YAXAAVFDataStream@@AAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@Z PROC ; SerializeToAssociativeContainer<std::pair<unsigned int,CvReplayInfo::PlotState>,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >, COMDAT

; 141  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H

; 142  : 	container.clear();

	mov	ecx, DWORD PTR _container$[ebp]
	call	?clear@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::clear

; 143  : 	size_t count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 144  : 	loadFrom >> count;

	lea	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 145  : 	size_t i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 146  : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@SerializeT@8
$LN2@SerializeT@8:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN3@SerializeT@8:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _count$[ebp]
	jae	SHORT $LN4@SerializeT@8

; 147  : 	{
; 148  : 		ElementType e;

	mov	DWORD PTR _e$230187[ebp], 0
	xor	eax, eax
	mov	DWORD PTR $T281617[ebp], eax
	mov	DWORD PTR $T281617[ebp+4], eax
	mov	DWORD PTR $T281617[ebp+8], eax
	mov	DWORD PTR $T281617[ebp+12], eax
	lea	ecx, DWORD PTR _e$230187[ebp+4]
	mov	edx, DWORD PTR $T281617[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR $T281617[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T281617[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR $T281617[ebp+12]
	mov	DWORD PTR [ecx+12], eax

; 149  : 		loadFrom >> e;

	lea	ecx, DWORD PTR _e$230187[ebp]
	push	ecx
	mov	edx, DWORD PTR _loadFrom$[ebp]
	push	edx
	call	??$?5IUPlotState@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@AAU?$pair@IUPlotState@CvReplayInfo@@@std@@@Z ; operator>><unsigned int,CvReplayInfo::PlotState>
	add	esp, 8

; 150  : 		container.insert(e);

	mov	eax, DWORD PTR _e$230187[ebp]
	mov	DWORD PTR $T281554[ebp], eax
	lea	ecx, DWORD PTR _e$230187[ebp+4]
	lea	edx, DWORD PTR $T281554[ebp+4]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	lea	edx, DWORD PTR $T281554[ebp]
	push	edx
	lea	eax, DWORD PTR $T281555[ebp]
	push	eax
	mov	ecx, DWORD PTR _container$[ebp]
	call	?insert@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIUPlotState@CvReplayInfo@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::insert

; 151  : 	}

	jmp	$LN2@SerializeT@8
$LN4@SerializeT@8:

; 152  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$SerializeToAssociativeContainer@U?$pair@IUPlotState@CvReplayInfo@@@std@@V?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@@YAXAAVFDataStream@@AAV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@std@@@Z ENDP ; SerializeToAssociativeContainer<std::pair<unsigned int,CvReplayInfo::PlotState>,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@stdext@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@std@@@Z
_TEXT	SEGMENT
__Cat$281761 = -3					; size = 1
$T281758 = -2						; size = 1
$T281757 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@stdext@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<CvReplayMessage *,CvReplayMessage *,std::allocator<CvReplayMessage> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T281757[ebp], al
	mov	cl, BYTE PTR __Cat$281761[ebp]
	mov	BYTE PTR $T281758[ebp], cl
	movzx	edx, BYTE PTR $T281757[ebp]
	push	edx
	movzx	eax, BYTE PTR $T281758[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvReplayMessage *,CvReplayMessage *,std::allocator<CvReplayMessage> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@stdext@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<CvReplayMessage *,CvReplayMessage *,std::allocator<CvReplayMessage> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@stdext@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@std@@@Z
_TEXT	SEGMENT
__Cat$281770 = -3					; size = 1
$T281766 = -2						; size = 1
$T281765 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@stdext@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<enum GameOptionTypes *,enum GameOptionTypes *,std::allocator<enum GameOptionTypes> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T281765[ebp], al
	mov	cl, BYTE PTR __Cat$281770[ebp]
	mov	BYTE PTR $T281766[ebp], cl
	movzx	edx, BYTE PTR $T281765[ebp]
	push	edx
	movzx	eax, BYTE PTR $T281766[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninit_copy@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum GameOptionTypes *,enum GameOptionTypes *,std::allocator<enum GameOptionTypes> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@stdext@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<enum GameOptionTypes *,enum GameOptionTypes *,std::allocator<enum GameOptionTypes> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@stdext@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@std@@@Z
_TEXT	SEGMENT
__Cat$281778 = -3					; size = 1
$T281774 = -2						; size = 1
$T281773 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@stdext@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<enum VictoryTypes *,enum VictoryTypes *,std::allocator<enum VictoryTypes> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T281773[ebp], al
	mov	cl, BYTE PTR __Cat$281778[ebp]
	mov	BYTE PTR $T281774[ebp], cl
	movzx	edx, BYTE PTR $T281773[ebp]
	push	edx
	movzx	eax, BYTE PTR $T281774[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninit_copy@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum VictoryTypes *,enum VictoryTypes *,std::allocator<enum VictoryTypes> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@stdext@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<enum VictoryTypes *,enum VictoryTypes *,std::allocator<enum VictoryTypes> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::allocator<CvReplayInfo::PlayerInfo> >
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@stdext@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@Z
_TEXT	SEGMENT
__Cat$281786 = -3					; size = 1
$T281782 = -2						; size = 1
$T281781 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@stdext@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::allocator<CvReplayInfo::PlayerInfo> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T281781[ebp], al
	mov	cl, BYTE PTR __Cat$281786[ebp]
	mov	BYTE PTR $T281782[ebp], cl
	movzx	edx, BYTE PTR $T281781[ebp]
	push	edx
	movzx	eax, BYTE PTR $T281782[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::allocator<CvReplayInfo::PlayerInfo> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@stdext@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::allocator<CvReplayInfo::PlayerInfo> >
_TEXT	ENDS
PUBLIC	??$?6IUPlotState@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@ABU?$pair@IUPlotState@CvReplayInfo@@@std@@@Z ; operator<<<unsigned int,CvReplayInfo::PlotState>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$for_each@Vconst_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@U?$SerializeFromAssociativeContainer@U?$pair@IUPlotState@CvReplayInfo@@@std@@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@@@std@@YA?AU?$SerializeFromAssociativeContainer@U?$pair@IUPlotState@CvReplayInfo@@@std@@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@@Vconst_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@0@0U1@@Z
_TEXT	SEGMENT
$T281857 = -48						; size = 4
$T281789 = -28						; size = 20
__ChkFirst$ = -8					; size = 4
__ChkLast$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Func$ = 20						; size = 8
??$for_each@Vconst_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@U?$SerializeFromAssociativeContainer@U?$pair@IUPlotState@CvReplayInfo@@@std@@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@@@std@@YA?AU?$SerializeFromAssociativeContainer@U?$pair@IUPlotState@CvReplayInfo@@@std@@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@@Vconst_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@0@0U1@@Z PROC ; std::for_each<std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator,SerializeFromAssociativeContainer<std::pair<unsigned int,CvReplayInfo::PlotState>,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > const > >, COMDAT

; 23   : 	{	// perform function for each element

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 24   : 	_DEBUG_RANGE(_First, _Last);
; 25   : 	_DEBUG_POINTER(_Func);
; 26   : 	_CHECKED_BASE_TYPE(_InIt) _ChkFirst(_CHECKED_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __ChkFirst$[ebp], eax

; 27   : 	_CHECKED_BASE_TYPE(_InIt) _ChkLast(_CHECKED_BASE(_Last));

	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __ChkLast$[ebp], ecx

; 28   : 	for (; _ChkFirst != _ChkLast; ++_ChkFirst)

	jmp	SHORT $LN40@for_each
$LN2@for_each:
	lea	ecx, DWORD PTR __ChkFirst$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator::_Inc
$LN40@for_each:
	mov	edx, DWORD PTR __ChkFirst$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __ChkLast$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@for_each

; 29   : 		_Func(*_ChkFirst);

	mov	eax, DWORD PTR __ChkFirst$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T281857[ebp], eax
	mov	ecx, DWORD PTR $T281857[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T281789[ebp], edx
	mov	eax, DWORD PTR $T281857[ebp]
	add	eax, 4
	lea	ecx, DWORD PTR $T281789[ebp+4]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	lea	ecx, DWORD PTR $T281789[ebp]
	push	ecx
	mov	edx, DWORD PTR __Func$[ebp]
	push	edx
	call	??$?6IUPlotState@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@ABU?$pair@IUPlotState@CvReplayInfo@@@std@@@Z ; operator<<<unsigned int,CvReplayInfo::PlotState>
	add	esp, 8
	jmp	SHORT $LN2@for_each
$LN1@for_each:

; 30   : 	return (_Func);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Func$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Func$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 31   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$for_each@Vconst_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@U?$SerializeFromAssociativeContainer@U?$pair@IUPlotState@CvReplayInfo@@@std@@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@@@std@@YA?AU?$SerializeFromAssociativeContainer@U?$pair@IUPlotState@CvReplayInfo@@@std@@$$CBV?$map@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@@2@@@Vconst_iterator@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@0@0U1@@Z ENDP ; std::for_each<std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::const_iterator,SerializeFromAssociativeContainer<std::pair<unsigned int,CvReplayInfo::PlotState>,std::map<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> > > const > >
_TEXT	ENDS
PUBLIC	??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?swap@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?swap@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?swap@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z$1
__ehfuncinfo$?swap@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?swap@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?swap@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
_this$ = -376						; size = 4
$T281913 = -52						; size = 4
$T281912 = -48						; size = 4
__Tmp$281911 = -44					; size = 4
$T281906 = -40						; size = 4
$T281905 = -36						; size = 4
__Tmp$281904 = -32					; size = 4
__Tmp$230542 = -24					; size = 12
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
?swap@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::swap, COMDAT
; _this$ = ecx

; 1033 : 		{	// exchange contents with _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?swap@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 364				; 0000016cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1034 : 		if (this == &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN16@swap
	jmp	$LN5@swap

; 1035 : 			;	// same object, do nothing
; 1036 : 		else if (get_allocator() == _Right.get_allocator())

$LN16@swap:
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN31@swap

; 1037 : 			{	// same allocator, swap control information
; 1038 : 
; 1039 :  #if _HAS_ITERATOR_DEBUGGING
; 1040 : 			this->_Swap_all(_Right);
; 1041 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1042 : 
; 1043 : 			this->_Swap_aux(_Right);
; 1044 : 
; 1045 : 			_STD _Swap_adl(this->comp, _Right.comp);
; 1046 : 			_STD swap(_Myhead, _Right._Myhead);

	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 4
	mov	DWORD PTR $T281906[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	mov	DWORD PTR $T281905[ebp], ecx
	mov	edx, DWORD PTR $T281905[ebp]
	cmp	edx, DWORD PTR $T281906[ebp]
	je	SHORT $LN26@swap
	mov	eax, DWORD PTR $T281905[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$281904[ebp], ecx
	mov	edx, DWORD PTR $T281905[ebp]
	mov	eax, DWORD PTR $T281906[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T281906[ebp]
	mov	eax, DWORD PTR __Tmp$281904[ebp]
	mov	DWORD PTR [edx], eax
$LN26@swap:

; 1047 : 			_STD swap(_Mysize, _Right._Mysize);

	mov	ecx, DWORD PTR __Right$[ebp]
	add	ecx, 8
	mov	DWORD PTR $T281913[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	mov	DWORD PTR $T281912[ebp], edx
	mov	eax, DWORD PTR $T281912[ebp]
	cmp	eax, DWORD PTR $T281913[ebp]
	je	SHORT $LN29@swap
	mov	ecx, DWORD PTR $T281912[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$281911[ebp], edx
	mov	eax, DWORD PTR $T281912[ebp]
	mov	ecx, DWORD PTR $T281913[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR $T281913[ebp]
	mov	ecx, DWORD PTR __Tmp$281911[ebp]
	mov	DWORD PTR [eax], ecx
$LN29@swap:

; 1048 : 			}
; 1049 : 		else

	jmp	SHORT $LN5@swap

; 1050 : 			{	// different allocator, do multiple assigns
; 1051 : 			this->_Swap_aux(_Right);

$LN31@swap:

; 1052 : 
; 1053 : 			_Myt _Tmp = *this;

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Tmp$230542[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1054 : 
; 1055 : 			*this = _Right;

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::operator=

; 1056 : 			_Right = _Tmp;

	lea	ecx, DWORD PTR __Tmp$230542[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	??4?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::operator=

; 1057 : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR __Tmp$230542[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN5@swap:

; 1058 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?swap@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z$0:
	lea	ecx, DWORD PTR __Tmp$230542[ebp]
	jmp	??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
__unwindfunclet$?swap@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z$1:
	lea	ecx, DWORD PTR __Tmp$230542[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$?swap@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-368]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?swap@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?swap@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::swap
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -100						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 539  : 		{	// destroy tree

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 540  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy

; 541  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-92]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?swap@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXAAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?swap@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXAAV12@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?swap@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXAAV12@@Z$25
__ehfuncinfo$?swap@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXAAV12@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?swap@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXAAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?swap@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
_this$ = -416						; size = 4
$T283094 = -64						; size = 4
$T283093 = -60						; size = 4
__Tmp$283091 = -56					; size = 4
$T283087 = -52						; size = 4
$T283086 = -48						; size = 4
__Tmp$283084 = -44					; size = 4
$T283080 = -40						; size = 4
$T283079 = -36						; size = 4
__Tmp$283077 = -32					; size = 4
__Ts$230562 = -28					; size = 16
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
?swap@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXAAV12@@Z PROC ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::swap, COMDAT
; _this$ = ecx

; 1064 : 		{	// exchange contents with _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?swap@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXAAV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 404				; 00000194H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1065 : 		if (this == &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN8@swap@2
	jmp	$LN5@swap@2

; 1066 : 			;	// same object, do nothing
; 1067 : 		else if (this->_Alval == _Right._Alval)

$LN8@swap@2:
	mov	ecx, 1
	test	ecx, ecx
	je	$LN21@swap@2

; 1068 : 			{	// same allocator, swap control information
; 1069 : 
; 1070 :  #if _HAS_ITERATOR_DEBUGGING
; 1071 : 			this->_Swap_all(_Right);
; 1072 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1073 : 
; 1074 : 			this->_Swap_aux(_Right);
; 1075 : 
; 1076 : 			_STD swap(_Myfirst, _Right._Myfirst);

	mov	edx, DWORD PTR __Right$[ebp]
	add	edx, 4
	mov	DWORD PTR $T283080[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR $T283079[ebp], eax
	mov	ecx, DWORD PTR $T283079[ebp]
	cmp	ecx, DWORD PTR $T283080[ebp]
	je	SHORT $LN13@swap@2
	mov	edx, DWORD PTR $T283079[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$283077[ebp], eax
	mov	ecx, DWORD PTR $T283079[ebp]
	mov	edx, DWORD PTR $T283080[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T283080[ebp]
	mov	edx, DWORD PTR __Tmp$283077[ebp]
	mov	DWORD PTR [ecx], edx
$LN13@swap@2:

; 1077 : 			_STD swap(_Mylast, _Right._Mylast);

	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	mov	DWORD PTR $T283087[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	mov	DWORD PTR $T283086[ebp], ecx
	mov	edx, DWORD PTR $T283086[ebp]
	cmp	edx, DWORD PTR $T283087[ebp]
	je	SHORT $LN16@swap@2
	mov	eax, DWORD PTR $T283086[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$283084[ebp], ecx
	mov	edx, DWORD PTR $T283086[ebp]
	mov	eax, DWORD PTR $T283087[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T283087[ebp]
	mov	eax, DWORD PTR __Tmp$283084[ebp]
	mov	DWORD PTR [edx], eax
$LN16@swap@2:

; 1078 : 			_STD swap(_Myend, _Right._Myend);

	mov	ecx, DWORD PTR __Right$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR $T283094[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR $T283093[ebp], edx
	mov	eax, DWORD PTR $T283093[ebp]
	cmp	eax, DWORD PTR $T283094[ebp]
	je	SHORT $LN19@swap@2
	mov	ecx, DWORD PTR $T283093[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$283091[ebp], edx
	mov	eax, DWORD PTR $T283093[ebp]
	mov	ecx, DWORD PTR $T283094[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR $T283094[ebp]
	mov	ecx, DWORD PTR __Tmp$283091[ebp]
	mov	DWORD PTR [eax], ecx
$LN19@swap@2:

; 1079 : 			}
; 1080 : 		else

	jmp	SHORT $LN5@swap@2

; 1081 : 			{	// different allocator, do multiple assigns
; 1082 : 			this->_Swap_aux(_Right);

$LN21@swap@2:

; 1083 : 
; 1084 : 			_Myt _Ts = *this;

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Ts$230562[ebp]
	call	??0?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@ABV01@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1085 : 
; 1086 : 			*this = _Right;

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV01@ABV01@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator=

; 1087 : 			_Right = _Ts;

	lea	ecx, DWORD PTR __Ts$230562[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	??4?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEAAV01@ABV01@@Z ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::operator=

; 1088 : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR __Ts$230562[ebp]
	call	?_Tidy@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN5@swap@2:

; 1089 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?swap@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXAAV12@@Z$0:
	lea	ecx, DWORD PTR __Ts$230562[ebp]
	jmp	??1?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::~vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
__unwindfunclet$?swap@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXAAV12@@Z$25:
	lea	ecx, DWORD PTR __Ts$230562[ebp]
	jmp	??1?$_Vector_val@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAE@XZ
__ehhandler$?swap@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXAAV12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-408]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?swap@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXAAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?swap@?$vector@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@QAEXAAV12@@Z ENDP ; std::vector<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >::swap
PUBLIC	??1?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?swap@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXAAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?swap@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXAAV12@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?swap@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXAAV12@@Z$1
__ehfuncinfo$?swap@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXAAV12@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?swap@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXAAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?swap@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
_this$ = -376						; size = 4
$T284639 = -52						; size = 4
$T284638 = -48						; size = 4
__Tmp$284636 = -44					; size = 4
$T284632 = -40						; size = 4
$T284631 = -36						; size = 4
__Tmp$284629 = -32					; size = 4
__Tmp$230584 = -24					; size = 12
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
?swap@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXAAV12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::swap, COMDAT
; _this$ = ecx

; 1033 : 		{	// exchange contents with _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?swap@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXAAV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 364				; 0000016cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1034 : 		if (this == &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN16@swap@3
	jmp	$LN5@swap@3

; 1035 : 			;	// same object, do nothing
; 1036 : 		else if (get_allocator() == _Right.get_allocator())

$LN16@swap@3:
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN31@swap@3

; 1037 : 			{	// same allocator, swap control information
; 1038 : 
; 1039 :  #if _HAS_ITERATOR_DEBUGGING
; 1040 : 			this->_Swap_all(_Right);
; 1041 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1042 : 
; 1043 : 			this->_Swap_aux(_Right);
; 1044 : 
; 1045 : 			_STD _Swap_adl(this->comp, _Right.comp);
; 1046 : 			_STD swap(_Myhead, _Right._Myhead);

	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 4
	mov	DWORD PTR $T284632[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	mov	DWORD PTR $T284631[ebp], ecx
	mov	edx, DWORD PTR $T284631[ebp]
	cmp	edx, DWORD PTR $T284632[ebp]
	je	SHORT $LN26@swap@3
	mov	eax, DWORD PTR $T284631[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$284629[ebp], ecx
	mov	edx, DWORD PTR $T284631[ebp]
	mov	eax, DWORD PTR $T284632[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T284632[ebp]
	mov	eax, DWORD PTR __Tmp$284629[ebp]
	mov	DWORD PTR [edx], eax
$LN26@swap@3:

; 1047 : 			_STD swap(_Mysize, _Right._Mysize);

	mov	ecx, DWORD PTR __Right$[ebp]
	add	ecx, 8
	mov	DWORD PTR $T284639[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	mov	DWORD PTR $T284638[ebp], edx
	mov	eax, DWORD PTR $T284638[ebp]
	cmp	eax, DWORD PTR $T284639[ebp]
	je	SHORT $LN29@swap@3
	mov	ecx, DWORD PTR $T284638[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$284636[ebp], edx
	mov	eax, DWORD PTR $T284638[ebp]
	mov	ecx, DWORD PTR $T284639[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR $T284639[ebp]
	mov	ecx, DWORD PTR __Tmp$284636[ebp]
	mov	DWORD PTR [eax], ecx
$LN29@swap@3:

; 1048 : 			}
; 1049 : 		else

	jmp	SHORT $LN5@swap@3

; 1050 : 			{	// different allocator, do multiple assigns
; 1051 : 			this->_Swap_aux(_Right);

$LN31@swap@3:

; 1052 : 
; 1053 : 			_Myt _Tmp = *this;

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Tmp$230584[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1054 : 
; 1055 : 			*this = _Right;

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::operator=

; 1056 : 			_Right = _Tmp;

	lea	ecx, DWORD PTR __Tmp$230584[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	??4?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::operator=

; 1057 : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR __Tmp$230584[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN5@swap@3:

; 1058 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?swap@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXAAV12@@Z$0:
	lea	ecx, DWORD PTR __Tmp$230584[ebp]
	jmp	??1?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >
__unwindfunclet$?swap@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXAAV12@@Z$1:
	lea	ecx, DWORD PTR __Tmp$230584[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__ehhandler$?swap@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXAAV12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-368]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?swap@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXAAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?swap@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAEXAAV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::swap
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -100						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >, COMDAT
; _this$ = ecx

; 539  : 		{	// destroy tree

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 540  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::_Tidy

; 541  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-92]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree@V?$_Tmap_traits@IUPlotState@CvReplayInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIUPlotState@CvReplayInfo@@@std@@@4@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,CvReplayInfo::PlotState,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,CvReplayInfo::PlotState> >,0> >
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$?5IUPlotState@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@AAU?$pair@IUPlotState@CvReplayInfo@@@std@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5IUPlotState@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@AAU?$pair@IUPlotState@CvReplayInfo@@@std@@@Z PROC ; operator>><unsigned int,CvReplayInfo::PlotState>, COMDAT

; 53   : {

	push	ebp
	mov	ebp, esp

; 54   : 	loadFrom >> writeTo.first;

	mov	eax, DWORD PTR _writeTo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 55   : 	loadFrom >> writeTo.second;

	mov	ecx, DWORD PTR _writeTo$[ebp]
	add	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _loadFrom$[ebp]
	push	edx
	call	??5@YAAAVFDataStream@@AAV0@AAUPlotState@CvReplayInfo@@@Z ; operator>>
	add	esp, 8

; 56   : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 57   : }

	pop	ebp
	ret	0
??$?5IUPlotState@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@AAU?$pair@IUPlotState@CvReplayInfo@@@std@@@Z ENDP ; operator>><unsigned int,CvReplayInfo::PlotState>
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$6
__unwindtable$??$_Uninit_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv149 = -48						; size = 4
tv82 = -44						; size = 4
$T285864 = -40						; size = 4
$T285856 = -32						; size = 4
$T285855 = -28						; size = 4
__Vptr$285862 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >,CvReplayMessage *,std::allocator<CvReplayMessage> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN18@Uninit_cop@3
$LN5@Uninit_cop@3:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 60					; 0000003cH
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 60					; 0000003cH
	mov	DWORD PTR __First$[ebp], edx
$LN18@Uninit_cop@3:
	mov	eax, DWORD PTR __First$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN4@Uninit_cop@3

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T285864[ebp], ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$285862[ebp], edx
	mov	eax, DWORD PTR __Vptr$285862[ebp]
	mov	DWORD PTR $T285856[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T285856[ebp], 0
	je	SHORT $LN30@Uninit_cop@3
	mov	ecx, DWORD PTR $T285864[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T285856[ebp]
	call	??0CvReplayMessage@@QAE@ABV0@@Z
	mov	DWORD PTR tv82[ebp], eax
	mov	edx, DWORD PTR tv82[ebp]
	mov	DWORD PTR tv149[ebp], edx
	jmp	SHORT $LN31@Uninit_cop@3
$LN30@Uninit_cop@3:
	mov	DWORD PTR tv149[ebp], 0
$LN31@Uninit_cop@3:
	mov	eax, DWORD PTR tv149[ebp]
	mov	DWORD PTR $T285855[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN5@Uninit_cop@3
$LN4@Uninit_cop@3:
	jmp	SHORT $LN10@Uninit_cop@3
__catch$??$_Uninit_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@3
$LN2@Uninit_cop@3:
	mov	ecx, DWORD PTR __Next$[ebp]
	add	ecx, 60					; 0000003cH
	mov	DWORD PTR __Next$[ebp], ecx
$LN3@Uninit_cop@3:
	mov	edx, DWORD PTR __Next$[ebp]
	cmp	edx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@3

; 134  : 		_Al.destroy(_Next);

	push	0
	mov	eax, DWORD PTR __Next$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Next$[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	jmp	SHORT $LN2@Uninit_cop@3
$LN1@Uninit_cop@3:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@3:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@3:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$285862[ebp]
	push	eax
	mov	ecx, DWORD PTR $T285856[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@std@@PAVCvReplayMessage@@V?$allocator@VCvReplayMessage@@@2@@std@@YAPAVCvReplayMessage@@V?$_Vector_iterator@VCvReplayMessage@@V?$allocator@VCvReplayMessage@@@std@@@0@0PAV1@AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_iterator<CvReplayMessage,std::allocator<CvReplayMessage> >,CvReplayMessage *,std::allocator<CvReplayMessage> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$6
__unwindtable$??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv89 = -44						; size = 4
tv68 = -40						; size = 4
$T285918 = -32						; size = 4
$T285917 = -28						; size = 4
__Vptr$285924 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CvReplayMessage *,CvReplayMessage *,std::allocator<CvReplayMessage> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@4
$LN5@Uninit_cop@4:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 60					; 0000003cH
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 60					; 0000003cH
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@4:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@4

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$285924[ebp], ecx
	mov	edx, DWORD PTR __Vptr$285924[ebp]
	mov	DWORD PTR $T285918[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T285918[ebp], 0
	je	SHORT $LN18@Uninit_cop@4
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T285918[ebp]
	call	??0CvReplayMessage@@QAE@ABV0@@Z
	mov	DWORD PTR tv68[ebp], eax
	mov	ecx, DWORD PTR tv68[ebp]
	mov	DWORD PTR tv89[ebp], ecx
	jmp	SHORT $LN19@Uninit_cop@4
$LN18@Uninit_cop@4:
	mov	DWORD PTR tv89[ebp], 0
$LN19@Uninit_cop@4:
	mov	edx, DWORD PTR tv89[ebp]
	mov	DWORD PTR $T285917[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN5@Uninit_cop@4
$LN4@Uninit_cop@4:
	jmp	SHORT $LN10@Uninit_cop@4
__catch$??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@4
$LN2@Uninit_cop@4:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 60					; 0000003cH
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@4:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@4

; 134  : 		_Al.destroy(_Next);

	push	0
	mov	edx, DWORD PTR __Next$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Next$[ebp]
	mov	edx, DWORD PTR [eax]
	call	edx
	jmp	SHORT $LN2@Uninit_cop@4
$LN1@Uninit_cop@4:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@4:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@4:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$285924[ebp]
	push	eax
	mov	ecx, DWORD PTR $T285918[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAVCvReplayMessage@@PAV1@V?$allocator@VCvReplayMessage@@@std@@@std@@YAPAVCvReplayMessage@@PAV1@00AAV?$allocator@VCvReplayMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CvReplayMessage *,CvReplayMessage *,std::allocator<CvReplayMessage> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv83 = -32						; size = 4
$T285967 = -28						; size = 4
__Vptr$285973 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<enum GameOptionTypes *,enum GameOptionTypes *,std::allocator<enum GameOptionTypes> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@5
$LN5@Uninit_cop@5:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 4
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 4
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@5:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@5

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$285973[ebp], ecx
	mov	edx, DWORD PTR __Vptr$285973[ebp]
	mov	DWORD PTR $T285967[ebp], edx
	cmp	DWORD PTR $T285967[ebp], 0
	je	SHORT $LN18@Uninit_cop@5
	mov	eax, DWORD PTR $T285967[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR $T285967[ebp]
	mov	DWORD PTR tv83[ebp], eax
	jmp	SHORT $LN14@Uninit_cop@5
$LN18@Uninit_cop@5:
	mov	DWORD PTR tv83[ebp], 0
$LN14@Uninit_cop@5:
	jmp	SHORT $LN5@Uninit_cop@5
$LN4@Uninit_cop@5:
	jmp	SHORT $LN10@Uninit_cop@5
__catch$??$_Uninit_copy@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@5
$LN2@Uninit_cop@5:
	mov	ecx, DWORD PTR __Next$[ebp]
	add	ecx, 4
	mov	DWORD PTR __Next$[ebp], ecx
$LN3@Uninit_cop@5:
	mov	edx, DWORD PTR __Next$[ebp]
	cmp	edx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@5

; 134  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_cop@5
$LN1@Uninit_cop@5:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@5:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@5:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAW4GameOptionTypes@@PAW41@V?$allocator@W4GameOptionTypes@@@std@@@std@@YAPAW4GameOptionTypes@@PAW41@00AAV?$allocator@W4GameOptionTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<enum GameOptionTypes *,enum GameOptionTypes *,std::allocator<enum GameOptionTypes> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv83 = -32						; size = 4
$T286016 = -28						; size = 4
__Vptr$286022 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<enum VictoryTypes *,enum VictoryTypes *,std::allocator<enum VictoryTypes> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@6
$LN5@Uninit_cop@6:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 4
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 4
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@6:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@6

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$286022[ebp], ecx
	mov	edx, DWORD PTR __Vptr$286022[ebp]
	mov	DWORD PTR $T286016[ebp], edx
	cmp	DWORD PTR $T286016[ebp], 0
	je	SHORT $LN18@Uninit_cop@6
	mov	eax, DWORD PTR $T286016[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR $T286016[ebp]
	mov	DWORD PTR tv83[ebp], eax
	jmp	SHORT $LN14@Uninit_cop@6
$LN18@Uninit_cop@6:
	mov	DWORD PTR tv83[ebp], 0
$LN14@Uninit_cop@6:
	jmp	SHORT $LN5@Uninit_cop@6
$LN4@Uninit_cop@6:
	jmp	SHORT $LN10@Uninit_cop@6
__catch$??$_Uninit_copy@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@6
$LN2@Uninit_cop@6:
	mov	ecx, DWORD PTR __Next$[ebp]
	add	ecx, 4
	mov	DWORD PTR __Next$[ebp], ecx
$LN3@Uninit_cop@6:
	mov	edx, DWORD PTR __Next$[ebp]
	cmp	edx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@6

; 134  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_cop@6
$LN1@Uninit_cop@6:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@6:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@6:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAW4VictoryTypes@@PAW41@V?$allocator@W4VictoryTypes@@@std@@@std@@YAPAW4VictoryTypes@@PAW41@00AAV?$allocator@W4VictoryTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<enum VictoryTypes *,enum VictoryTypes *,std::allocator<enum VictoryTypes> >
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$19 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$19
__unwindtable$??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv89 = -72						; size = 4
tv68 = -68						; size = 4
$T286094 = -32						; size = 4
$T286093 = -28						; size = 4
__Vptr$286100 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::allocator<CvReplayInfo::PlayerInfo> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 56					; 00000038H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@7
$LN5@Uninit_cop@7:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 128				; 00000080H
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 128				; 00000080H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@7:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@7

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$286100[ebp], ecx
	mov	edx, DWORD PTR __Vptr$286100[ebp]
	mov	DWORD PTR $T286094[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T286094[ebp], 0
	je	SHORT $LN18@Uninit_cop@7
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T286094[ebp]
	call	??0PlayerInfo@CvReplayInfo@@QAE@ABU01@@Z
	mov	DWORD PTR tv68[ebp], eax
	mov	ecx, DWORD PTR tv68[ebp]
	mov	DWORD PTR tv89[ebp], ecx
	jmp	SHORT $LN19@Uninit_cop@7
$LN18@Uninit_cop@7:
	mov	DWORD PTR tv89[ebp], 0
$LN19@Uninit_cop@7:
	mov	edx, DWORD PTR tv89[ebp]
	mov	DWORD PTR $T286093[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN5@Uninit_cop@7
$LN4@Uninit_cop@7:
	jmp	SHORT $LN10@Uninit_cop@7
__catch$??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@7
$LN2@Uninit_cop@7:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 128				; 00000080H
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@7:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@7

; 134  : 		_Al.destroy(_Next);

	mov	ecx, DWORD PTR __Next$[ebp]
	call	??1PlayerInfo@CvReplayInfo@@QAE@XZ
	xor	edx, edx
	and	edx, 1
	je	SHORT $LN41@Uninit_cop@7
	mov	eax, DWORD PTR __Next$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN41@Uninit_cop@7:
	jmp	SHORT $LN2@Uninit_cop@7
$LN1@Uninit_cop@7:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@7:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@7:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$286100[ebp]
	push	eax
	mov	ecx, DWORD PTR $T286094[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAUPlayerInfo@CvReplayInfo@@PAU12@V?$allocator@UPlayerInfo@CvReplayInfo@@@std@@@std@@YAPAUPlayerInfo@CvReplayInfo@@PAU12@00AAV?$allocator@UPlayerInfo@CvReplayInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CvReplayInfo::PlayerInfo *,CvReplayInfo::PlayerInfo *,std::allocator<CvReplayInfo::PlayerInfo> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$10 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$10
__unwindtable$??$_Uninit_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
	DD	02H
	DD	FLAT:__unwindfunclet$??$_Uninit_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$5
__ehfuncinfo$??$_Uninit_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv89 = -120						; size = 4
$T286188 = -32						; size = 4
$T286187 = -28						; size = 4
__Vptr$286196 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@8
$LN5@Uninit_cop@8:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@8:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@8

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$286196[ebp], ecx
	mov	edx, DWORD PTR __Vptr$286196[ebp]
	mov	DWORD PTR $T286188[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T286188[ebp], 0
	je	SHORT $LN18@Uninit_cop@8
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T286188[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
	mov	ecx, DWORD PTR $T286188[ebp]
	mov	DWORD PTR tv89[ebp], ecx
	jmp	SHORT $LN19@Uninit_cop@8
$LN18@Uninit_cop@8:
	mov	DWORD PTR tv89[ebp], 0
$LN19@Uninit_cop@8:
	mov	edx, DWORD PTR tv89[ebp]
	mov	DWORD PTR $T286187[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN5@Uninit_cop@8
$LN4@Uninit_cop@8:
	jmp	SHORT $LN10@Uninit_cop@8
__catch$??$_Uninit_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@8
$LN2@Uninit_cop@8:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@8:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@8

; 134  : 		_Al.destroy(_Next);

	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR __Next$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	xor	edx, edx
	and	edx, 1
	je	SHORT $LN26@Uninit_cop@8
	mov	eax, DWORD PTR __Next$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN26@Uninit_cop@8:
	jmp	SHORT $LN2@Uninit_cop@8
$LN1@Uninit_cop@8:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@8:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@8:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$286196[ebp]
	push	eax
	mov	ecx, DWORD PTR $T286188[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??$_Uninit_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$5:
	mov	ecx, DWORD PTR __Next$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??$_Uninit_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@PAV12@V?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@2@@std@@YAPAV?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@0@PAV10@00AAV?$allocator@V?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > *,std::allocator<std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > > > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv84 = -32						; size = 4
$T286571 = -28						; size = 4
__Vptr$286569 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::pair<short,short> *,std::pair<short,short> *,std::allocator<std::pair<short,short> > >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@9
$LN5@Uninit_cop@9:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 4
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 4
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@9:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@9

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$286569[ebp], ecx
	mov	edx, DWORD PTR __Vptr$286569[ebp]
	mov	DWORD PTR $T286571[ebp], edx
	cmp	DWORD PTR $T286571[ebp], 0
	je	SHORT $LN18@Uninit_cop@9
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR $T286571[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR $T286571[ebp]
	mov	DWORD PTR tv84[ebp], eax
	jmp	SHORT $LN14@Uninit_cop@9
$LN18@Uninit_cop@9:
	mov	DWORD PTR tv84[ebp], 0
$LN14@Uninit_cop@9:
	jmp	SHORT $LN5@Uninit_cop@9
$LN4@Uninit_cop@9:
	jmp	SHORT $LN10@Uninit_cop@9
__catch$??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@9
$LN2@Uninit_cop@9:
	mov	ecx, DWORD PTR __Next$[ebp]
	add	ecx, 4
	mov	DWORD PTR __Next$[ebp], ecx
$LN3@Uninit_cop@9:
	mov	edx, DWORD PTR __Next$[ebp]
	cmp	edx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@9

; 134  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_cop@9
$LN1@Uninit_cop@9:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@9:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@9:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::pair<short,short> *,std::pair<short,short> *,std::allocator<std::pair<short,short> > >
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$?6IUPlotState@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@ABU?$pair@IUPlotState@CvReplayInfo@@@std@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??$?6IUPlotState@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@ABU?$pair@IUPlotState@CvReplayInfo@@@std@@@Z PROC ; operator<<<unsigned int,CvReplayInfo::PlotState>, COMDAT

; 45   : {

	push	ebp
	mov	ebp, esp

; 46   : 	saveTo << readFrom.first;

	mov	eax, DWORD PTR _readFrom$[ebp]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 47   : 	saveTo << readFrom.second;

	mov	ecx, DWORD PTR _readFrom$[ebp]
	add	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _saveTo$[ebp]
	push	edx
	call	??6@YAAAVFDataStream@@AAV0@ABUPlotState@CvReplayInfo@@@Z ; operator<<
	add	esp, 8

; 48   : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 49   : }

	pop	ebp
	ret	0
??$?6IUPlotState@CvReplayInfo@@@@YAAAVFDataStream@@AAV0@ABU?$pair@IUPlotState@CvReplayInfo@@@std@@@Z ENDP ; operator<<<unsigned int,CvReplayInfo::PlotState>
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT

; 298  : {

	push	ebp
	mov	ebp, esp

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	DWORD PTR _p$[ebp], 0
	jl	SHORT $LN1@teamType
	cmp	DWORD PTR _p$[ebp], 64			; 00000040H
	jge	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	eax, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN2@teamType
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1
$LN2@teamType:

; 302  : }

	pop	ebp
	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0length_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
; Function compile flags: /Odtp
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
END
