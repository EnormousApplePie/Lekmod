; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvUnitMovement.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?isRoughGround@CvPlot@@QBE_NXZ			; CvPlot::isRoughGround
PUBLIC	?isCity@CvPlot@@QBE_NXZ				; CvPlot::isCity
PUBLIC	?directionXY@@YA?AW4DirectionTypes@@PBVCvPlot@@0@Z ; directionXY
PUBLIC	?GetCostsForMove@CvUnitMovement@@SAXPBVCvUnit@@PBVCvPlot@@1HAAH22@Z ; CvUnitMovement::GetCostsForMove
EXTRN	?IsAllowsSailLand@CvPlot@@QBE_NXZ:PROC		; CvPlot::IsAllowsSailLand
EXTRN	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ:PROC ; CvUnit::getDomainType
EXTRN	?getRouteChange@CvTeam@@QBEHW4RouteTypes@@@Z:PROC ; CvTeam::getRouteChange
EXTRN	?getFlatMovementCost@CvRouteInfo@@QBEHXZ:PROC	; CvRouteInfo::getFlatMovementCost
EXTRN	?getMovementCost@CvRouteInfo@@QBEHXZ:PROC	; CvRouteInfo::getMovementCost
EXTRN	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z:PROC ; CvGlobals::getRouteInfo
EXTRN	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ:PROC ; CvPlot::getRouteType
EXTRN	?isBridgeBuilding@CvTeam@@QBE_NXZ:PROC		; CvTeam::isBridgeBuilding
EXTRN	?isValidRoute@CvPlot@@QBE_NPBVCvUnit@@@Z:PROC	; CvPlot::isValidRoute
EXTRN	?isFeatureDoubleMove@CvUnit@@QBE_NW4FeatureTypes@@@Z:PROC ; CvUnit::isFeatureDoubleMove
EXTRN	?isTerrainDoubleMove@CvUnit@@QBE_NW4TerrainTypes@@@Z:PROC ; CvUnit::isTerrainDoubleMove
EXTRN	?isHillsDoubleMove@CvUnit@@QBE_NXZ:PROC		; CvUnit::isHillsDoubleMove
EXTRN	?IsRoughTerrainEndsTurn@CvUnit@@QBE_NXZ:PROC	; CvUnit::IsRoughTerrainEndsTurn
EXTRN	?getExtraMoveDiscount@CvUnit@@QBEHXZ:PROC	; CvUnit::getExtraMoveDiscount
EXTRN	?getMovementCost@CvFeatureInfo@@QBEHXZ:PROC	; CvFeatureInfo::getMovementCost
EXTRN	?getMovementCost@CvTerrainInfo@@QBEHXZ:PROC	; CvTerrainInfo::getMovementCost
EXTRN	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z:PROC ; CvGlobals::getTerrainInfo
EXTRN	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z:PROC ; CvGlobals::getFeatureInfo
EXTRN	?isRiverCrossing@CvPlot@@QBE_NW4DirectionTypes@@@Z:PROC ; CvPlot::isRiverCrossing
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
EXTRN	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ:PROC	; CvUnit::getTeam
EXTRN	?ignoreTerrainCost@CvUnit@@QBE_NXZ:PROC		; CvUnit::ignoreTerrainCost
EXTRN	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ:PROC ; CvPlayer::GetPlayerTraits
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvunitmovement.cpp
;	COMDAT ?GetCostsForMove@CvUnitMovement@@SAXPBVCvUnit@@PBVCvPlot@@1HAAH22@Z
_TEXT	SEGMENT
tv282 = -252						; size = 4
tv386 = -248						; size = 4
tv271 = -244						; size = 4
tv267 = -240						; size = 4
tv260 = -236						; size = 4
tv256 = -232						; size = 4
tv214 = -225						; size = 1
tv402 = -224						; size = 4
tv164 = -220						; size = 4
tv165 = -216						; size = 4
tv160 = -212						; size = 4
tv137 = -208						; size = 4
tv130 = -204						; size = 4
$T217666 = -200						; size = 4
$T217657 = -193						; size = 1
$T217651 = -192						; size = 4
$T217642 = -188						; size = 4
$T217635 = -181						; size = 1
$T217587 = -148						; size = 4
$T217580 = -144						; size = 4
_f$217556 = -133					; size = 1
$T217515 = -116						; size = 4
$T217506 = -112						; size = 4
$T217505 = -108						; size = 4
$T217504 = -104						; size = 4
$T217503 = -100						; size = 4
$T217492 = -96						; size = 4
$T217491 = -92						; size = 4
_pRoadInfo$217189 = -88					; size = 4
_pFromRouteInfo$217176 = -84				; size = 4
_eFromPlotRoute$217171 = -80				; size = 4
_pRouteInfo$217179 = -76				; size = 4
_iFromMovementCost$217177 = -72				; size = 4
_iMovementCost$217180 = -68				; size = 4
_eToPlotRoute$217172 = -64				; size = 4
_iFlatMovementCost$217181 = -60				; size = 4
_iFromFlatMovementCost$217178 = -56			; size = 4
_bRiverCrossing$ = -49					; size = 1
_eTerrain$ = -48					; size = 4
_pTerrainInfo$ = -44					; size = 4
_iMoveDenominator$ = -40				; size = 4
_pFeatureInfo$ = -36					; size = 4
_bFasterAlongRiver$ = -29				; size = 1
_eUnitTeam$ = -28					; size = 4
_kUnitTeam$ = -24					; size = 4
_pTraits$ = -20						; size = 4
_bIgnoreTerrainCost$ = -13				; size = 1
_eFeature$ = -12					; size = 4
_kPlayer$ = -8						; size = 4
_bFasterInHills$ = -1					; size = 1
_pUnit$ = 8						; size = 4
_pFromPlot$ = 12					; size = 4
_pToPlot$ = 16						; size = 4
_iBaseMoves$ = 20					; size = 4
_iRegularCost$ = 24					; size = 4
_iRouteCost$ = 28					; size = 4
_iRouteFlatCost$ = 32					; size = 4
?GetCostsForMove@CvUnitMovement@@SAXPBVCvUnit@@PBVCvPlot@@1HAAH22@Z PROC ; CvUnitMovement::GetCostsForMove, COMDAT

; 10   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	esi

; 11   : 	CvPlayerAI& kPlayer = GET_PLAYER(pUnit->getOwner());

	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR $T217515[ebp], ecx
	mov	edx, DWORD PTR $T217515[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$[ebp], edx

; 12   : 	CvPlayerTraits* pTraits = kPlayer.GetPlayerTraits();

	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR _pTraits$[ebp], eax

; 13   : 	bool bFasterAlongRiver = pTraits->IsFasterAlongRiver();

	mov	eax, DWORD PTR _pTraits$[ebp]
	mov	cl, BYTE PTR [eax+334]
	mov	BYTE PTR _bFasterAlongRiver$[ebp], cl

; 14   : 	bool bFasterInHills = pTraits->IsFasterInHills();

	mov	edx, DWORD PTR _pTraits$[ebp]
	mov	al, BYTE PTR [edx+335]
	mov	BYTE PTR _bFasterInHills$[ebp], al

; 15   : 	bool bIgnoreTerrainCost = pUnit->ignoreTerrainCost();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?ignoreTerrainCost@CvUnit@@QBE_NXZ	; CvUnit::ignoreTerrainCost
	mov	BYTE PTR _bIgnoreTerrainCost$[ebp], al

; 16   : 	//int iBaseMoves = pUnit->baseMoves(isWater()?DOMAIN_SEA:NO_DOMAIN);
; 17   : 	TeamTypes eUnitTeam = pUnit->getTeam();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	mov	DWORD PTR _eUnitTeam$[ebp], eax

; 18   : 	CvTeam& kUnitTeam = GET_TEAM(eUnitTeam);

	mov	ecx, DWORD PTR _eUnitTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR _kUnitTeam$[ebp], ecx

; 19   : 	int iMoveDenominator = GC.getMOVE_DENOMINATOR();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6236
	mov	DWORD PTR _iMoveDenominator$[ebp], edx

; 20   : 	bool bRiverCrossing = pFromPlot->isRiverCrossing(directionXY(pFromPlot, pToPlot));

	mov	eax, DWORD PTR _pToPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFromPlot$[ebp]
	push	ecx
	call	?directionXY@@YA?AW4DirectionTypes@@PBVCvPlot@@0@Z ; directionXY
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pFromPlot$[ebp]
	call	?isRiverCrossing@CvPlot@@QBE_NW4DirectionTypes@@@Z ; CvPlot::isRiverCrossing
	mov	BYTE PTR _bRiverCrossing$[ebp], al

; 21   : 	FeatureTypes eFeature = pToPlot->getFeatureType();

	mov	edx, DWORD PTR _pToPlot$[ebp]
	mov	al, BYTE PTR [edx+432]
	mov	BYTE PTR _f$217556[ebp], al
	movsx	ecx, BYTE PTR _f$217556[ebp]
	mov	DWORD PTR _eFeature$[ebp], ecx

; 22   : 	CvFeatureInfo* pFeatureInfo = (eFeature > NO_FEATURE) ? GC.getFeatureInfo(eFeature) : 0;

	cmp	DWORD PTR _eFeature$[ebp], -1
	jle	SHORT $LN27@GetCostsFo
	mov	edx, DWORD PTR _eFeature$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	DWORD PTR tv130[ebp], eax
	jmp	SHORT $LN28@GetCostsFo
$LN27@GetCostsFo:
	mov	DWORD PTR tv130[ebp], 0
$LN28@GetCostsFo:
	mov	eax, DWORD PTR tv130[ebp]
	mov	DWORD PTR _pFeatureInfo$[ebp], eax

; 23   : 	TerrainTypes eTerrain = pToPlot->getTerrainType();

	mov	ecx, DWORD PTR _pToPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+6]
	mov	DWORD PTR _eTerrain$[ebp], edx

; 24   : 	CvTerrainInfo* pTerrainInfo = (eTerrain > NO_TERRAIN) ? GC.getTerrainInfo(eTerrain) : 0;

	cmp	DWORD PTR _eTerrain$[ebp], -1
	jle	SHORT $LN29@GetCostsFo
	mov	eax, DWORD PTR _eTerrain$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo
	mov	DWORD PTR tv137[ebp], eax
	jmp	SHORT $LN30@GetCostsFo
$LN29@GetCostsFo:
	mov	DWORD PTR tv137[ebp], 0
$LN30@GetCostsFo:
	mov	ecx, DWORD PTR tv137[ebp]
	mov	DWORD PTR _pTerrainInfo$[ebp], ecx

; 25   : 	
; 26   : 	
; 27   : 	
; 28   : 
; 29   : #ifdef NQ_FIX_FASTER_ALONG_RIVER
; 30   : 	if(bIgnoreTerrainCost || (bFasterAlongRiver && pToPlot->isRiver() && pFromPlot->isRiver()) || (bFasterInHills && pToPlot->isHills()))

	movzx	edx, BYTE PTR _bIgnoreTerrainCost$[ebp]
	test	edx, edx
	jne	SHORT $LN23@GetCostsFo
	movzx	eax, BYTE PTR _bFasterAlongRiver$[ebp]
	test	eax, eax
	je	SHORT $LN22@GetCostsFo
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+457]
	xor	eax, eax
	test	edx, edx
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN22@GetCostsFo
	mov	edx, DWORD PTR _pFromPlot$[ebp]
	movsx	eax, BYTE PTR [edx+457]
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN23@GetCostsFo
$LN22@GetCostsFo:
	movzx	eax, BYTE PTR _bFasterInHills$[ebp]
	test	eax, eax
	je	SHORT $LN24@GetCostsFo
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	sub	edx, 1
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN24@GetCostsFo
$LN23@GetCostsFo:

; 31   : #else
; 32   : 	if(bIgnoreTerrainCost || (bFasterAlongRiver && pToPlot->isRiver()) || (bFasterInHills && pToPlot->isHills()))
; 33   : #endif
; 34   : 	{
; 35   : 		iRegularCost = 1;

	mov	ecx, DWORD PTR _iRegularCost$[ebp]
	mov	DWORD PTR [ecx], 1

; 36   : 	}
; 37   : 	else

	jmp	$LN21@GetCostsFo
$LN24@GetCostsFo:

; 38   : 	{
; 39   : 		iRegularCost = ((eFeature == NO_FEATURE) ? (pTerrainInfo ? pTerrainInfo->getMovementCost() : 0) : (pFeatureInfo ? pFeatureInfo->getMovementCost() : 0));

	cmp	DWORD PTR _eFeature$[ebp], -1
	jne	SHORT $LN35@GetCostsFo
	cmp	DWORD PTR _pTerrainInfo$[ebp], 0
	je	SHORT $LN31@GetCostsFo
	mov	ecx, DWORD PTR _pTerrainInfo$[ebp]
	call	?getMovementCost@CvTerrainInfo@@QBEHXZ	; CvTerrainInfo::getMovementCost
	mov	DWORD PTR tv160[ebp], eax
	jmp	SHORT $LN32@GetCostsFo
$LN31@GetCostsFo:
	mov	DWORD PTR tv160[ebp], 0
$LN32@GetCostsFo:
	mov	edx, DWORD PTR tv160[ebp]
	mov	DWORD PTR tv165[ebp], edx
	jmp	SHORT $LN36@GetCostsFo
$LN35@GetCostsFo:
	cmp	DWORD PTR _pFeatureInfo$[ebp], 0
	je	SHORT $LN33@GetCostsFo
	mov	ecx, DWORD PTR _pFeatureInfo$[ebp]
	call	?getMovementCost@CvFeatureInfo@@QBEHXZ	; CvFeatureInfo::getMovementCost
	mov	DWORD PTR tv164[ebp], eax
	jmp	SHORT $LN34@GetCostsFo
$LN33@GetCostsFo:
	mov	DWORD PTR tv164[ebp], 0
$LN34@GetCostsFo:
	mov	eax, DWORD PTR tv164[ebp]
	mov	DWORD PTR tv165[ebp], eax
$LN36@GetCostsFo:
	mov	ecx, DWORD PTR _iRegularCost$[ebp]
	mov	edx, DWORD PTR tv165[ebp]
	mov	DWORD PTR [ecx], edx

; 40   : 
; 41   : 		// Hill cost, except for when a City is present here, then it just counts as flat land
; 42   : 		if((PlotTypes)pToPlot->getPlotType() == PLOT_HILLS && !pToPlot->isCity())

	mov	eax, DWORD PTR _pToPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	cmp	ecx, 1
	jne	SHORT $LN20@GetCostsFo
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN20@GetCostsFo

; 43   : 		{
; 44   : 			iRegularCost += GC.getHILLS_EXTRA_MOVEMENT();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6592
	mov	DWORD PTR $T217580[ebp], eax
	mov	ecx, DWORD PTR _iRegularCost$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, DWORD PTR $T217580[ebp]
	mov	eax, DWORD PTR _iRegularCost$[ebp]
	mov	DWORD PTR [eax], edx
$LN20@GetCostsFo:

; 45   : 		}
; 46   : 
; 47   : 		if(iRegularCost > 0)

	mov	ecx, DWORD PTR _iRegularCost$[ebp]
	cmp	DWORD PTR [ecx], 0
	jle	SHORT $LN21@GetCostsFo

; 48   : 		{
; 49   : 			iRegularCost = std::max(1, (iRegularCost - pUnit->getExtraMoveDiscount()));

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getExtraMoveDiscount@CvUnit@@QBEHXZ	; CvUnit::getExtraMoveDiscount
	mov	edx, DWORD PTR _iRegularCost$[ebp]
	mov	ecx, DWORD PTR [edx]
	sub	ecx, eax
	mov	DWORD PTR $T217491[ebp], ecx
	mov	DWORD PTR $T217492[ebp], 1
	mov	edx, DWORD PTR $T217492[ebp]
	cmp	edx, DWORD PTR $T217491[ebp]
	jge	SHORT $LN94@GetCostsFo
	lea	eax, DWORD PTR $T217491[ebp]
	mov	DWORD PTR tv402[ebp], eax
	jmp	SHORT $LN95@GetCostsFo
$LN94@GetCostsFo:
	lea	ecx, DWORD PTR $T217492[ebp]
	mov	DWORD PTR tv402[ebp], ecx
$LN95@GetCostsFo:
	mov	edx, DWORD PTR tv402[ebp]
	mov	DWORD PTR $T217587[ebp], edx
	mov	eax, DWORD PTR _iRegularCost$[ebp]
	mov	ecx, DWORD PTR $T217587[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN21@GetCostsFo:

; 50   : 		}
; 51   : 
; 52   : 		
; 53   : 	}
; 54   : 
; 55   : 	// Is a unit's movement consumed for entering rough terrain?
; 56   : #ifdef NQ_FIX_MOVES_THAT_CONSUME_ALL_MOVEMENT
; 57   : 	if ((pToPlot->isRoughGround() && pUnit->IsRoughTerrainEndsTurn()) || (!(bIgnoreTerrainCost || bFasterAlongRiver) && bRiverCrossing))

	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?isRoughGround@CvPlot@@QBE_NXZ		; CvPlot::isRoughGround
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN16@GetCostsFo
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?IsRoughTerrainEndsTurn@CvUnit@@QBE_NXZ	; CvUnit::IsRoughTerrainEndsTurn
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN17@GetCostsFo
$LN16@GetCostsFo:
	movzx	edx, BYTE PTR _bIgnoreTerrainCost$[ebp]
	test	edx, edx
	jne	SHORT $LN18@GetCostsFo
	movzx	eax, BYTE PTR _bFasterAlongRiver$[ebp]
	test	eax, eax
	jne	SHORT $LN18@GetCostsFo
	movzx	ecx, BYTE PTR _bRiverCrossing$[ebp]
	test	ecx, ecx
	je	SHORT $LN18@GetCostsFo
$LN17@GetCostsFo:

; 58   : #else
; 59   : 	if(pToPlot->isRoughGround() && pUnit->IsRoughTerrainEndsTurn())
; 60   : #endif
; 61   : 	{
; 62   : 		iRegularCost = INT_MAX;

	mov	edx, DWORD PTR _iRegularCost$[ebp]
	mov	DWORD PTR [edx], 2147483647		; 7fffffffH

; 63   : 	}
; 64   : 	else

	jmp	$LN15@GetCostsFo
$LN18@GetCostsFo:

; 65   : 	{
; 66   : #ifndef NQ_FIX_MOVES_THAT_CONSUME_ALL_MOVEMENT
; 67   : 		if(!(bIgnoreTerrainCost || bFasterAlongRiver) && bRiverCrossing)
; 68   : 		{
; 69   : 			iRegularCost += GC.getRIVER_EXTRA_MOVEMENT();
; 70   : 		}
; 71   : #endif
; 72   : 		iRegularCost *= iMoveDenominator;

	mov	eax, DWORD PTR _iRegularCost$[ebp]
	mov	ecx, DWORD PTR [eax]
	imul	ecx, DWORD PTR _iMoveDenominator$[ebp]
	mov	edx, DWORD PTR _iRegularCost$[ebp]
	mov	DWORD PTR [edx], ecx

; 73   : 
; 74   : 		if(pToPlot->isHills() && pUnit->isHillsDoubleMove())

	mov	eax, DWORD PTR _pToPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	sub	ecx, 1
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN14@GetCostsFo
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?isHillsDoubleMove@CvUnit@@QBE_NXZ	; CvUnit::isHillsDoubleMove
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN14@GetCostsFo

; 75   : 		{
; 76   : 			iRegularCost /= 2;

	mov	ecx, DWORD PTR _iRegularCost$[ebp]
	mov	eax, DWORD PTR [ecx]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edx, DWORD PTR _iRegularCost$[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN15@GetCostsFo
$LN14@GetCostsFo:

; 77   : 		}
; 78   : 
; 79   : 		else if((eFeature == NO_FEATURE) ? pUnit->isTerrainDoubleMove(eTerrain) : pUnit->isFeatureDoubleMove(eFeature))

	cmp	DWORD PTR _eFeature$[ebp], -1
	jne	SHORT $LN37@GetCostsFo
	mov	eax, DWORD PTR _eTerrain$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?isTerrainDoubleMove@CvUnit@@QBE_NW4TerrainTypes@@@Z ; CvUnit::isTerrainDoubleMove
	mov	BYTE PTR tv214[ebp], al
	jmp	SHORT $LN38@GetCostsFo
$LN37@GetCostsFo:
	mov	ecx, DWORD PTR _eFeature$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?isFeatureDoubleMove@CvUnit@@QBE_NW4FeatureTypes@@@Z ; CvUnit::isFeatureDoubleMove
	mov	BYTE PTR tv214[ebp], al
$LN38@GetCostsFo:
	movzx	edx, BYTE PTR tv214[ebp]
	test	edx, edx
	je	SHORT $LN15@GetCostsFo

; 80   : 		{
; 81   : 			iRegularCost /= 2;

	mov	eax, DWORD PTR _iRegularCost$[ebp]
	mov	eax, DWORD PTR [eax]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _iRegularCost$[ebp]
	mov	DWORD PTR [ecx], eax
$LN15@GetCostsFo:

; 82   : 		}
; 83   : 	}
; 84   : 
; 85   : #ifndef NQ_FIX_MOVES_THAT_CONSUME_ALL_MOVEMENT
; 86   : 	iRegularCost = std::min(iRegularCost, (iBaseMoves * iMoveDenominator));
; 87   : #endif
; 88   : 
; 89   : 	if(pFromPlot->isValidRoute(pUnit) && pToPlot->isValidRoute(pUnit) && ((kUnitTeam.isBridgeBuilding() || !(pFromPlot->isRiverCrossing(directionXY(pFromPlot, pToPlot))))))

	mov	edx, DWORD PTR _pUnit$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pFromPlot$[ebp]
	call	?isValidRoute@CvPlot@@QBE_NPBVCvUnit@@@Z ; CvPlot::isValidRoute
	movzx	eax, al
	test	eax, eax
	je	$LN11@GetCostsFo
	mov	ecx, DWORD PTR _pUnit$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?isValidRoute@CvPlot@@QBE_NPBVCvUnit@@@Z ; CvPlot::isValidRoute
	movzx	edx, al
	test	edx, edx
	je	$LN11@GetCostsFo
	mov	ecx, DWORD PTR _kUnitTeam$[ebp]
	call	?isBridgeBuilding@CvTeam@@QBE_NXZ	; CvTeam::isBridgeBuilding
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN10@GetCostsFo
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pFromPlot$[ebp]
	push	edx
	call	?directionXY@@YA?AW4DirectionTypes@@PBVCvPlot@@0@Z ; directionXY
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pFromPlot$[ebp]
	call	?isRiverCrossing@CvPlot@@QBE_NW4DirectionTypes@@@Z ; CvPlot::isRiverCrossing
	movzx	eax, al
	test	eax, eax
	jne	$LN11@GetCostsFo
$LN10@GetCostsFo:

; 90   : 	{
; 91   : #ifdef AUI_UNIT_MOVEMENT_IROQUOIS_ROAD_TRANSITION_FIX
; 92   : 		RouteTypes eFromPlotRoute = pFromPlot->getRouteType();

	mov	ecx, DWORD PTR _pFromPlot$[ebp]
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	mov	DWORD PTR _eFromPlotRoute$217171[ebp], eax

; 93   : 		RouteTypes eToPlotRoute = pToPlot->getRouteType();

	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	mov	DWORD PTR _eToPlotRoute$217172[ebp], eax

; 94   : 		if (pTraits->IsMoveFriendlyWoodsAsRoad())

	mov	ecx, DWORD PTR _pTraits$[ebp]
	mov	dl, BYTE PTR [ecx+333]
	mov	BYTE PTR $T217635[ebp], dl
	movzx	eax, BYTE PTR $T217635[ebp]
	test	eax, eax
	je	SHORT $LN9@GetCostsFo

; 95   : 		{
; 96   : 			if (eFromPlotRoute == NO_ROUTE)

	cmp	DWORD PTR _eFromPlotRoute$217171[ebp], -1
	jne	SHORT $LN8@GetCostsFo

; 97   : 				eFromPlotRoute = ROUTE_ROAD;

	mov	DWORD PTR _eFromPlotRoute$217171[ebp], 0
$LN8@GetCostsFo:

; 98   : 			if (eToPlotRoute == NO_ROUTE)

	cmp	DWORD PTR _eToPlotRoute$217172[ebp], -1
	jne	SHORT $LN9@GetCostsFo

; 99   : 				eToPlotRoute = ROUTE_ROAD;

	mov	DWORD PTR _eToPlotRoute$217172[ebp], 0
$LN9@GetCostsFo:

; 100  : 		}
; 101  : 		CvRouteInfo* pFromRouteInfo = GC.getRouteInfo(eFromPlotRoute);

	mov	ecx, DWORD PTR _eFromPlotRoute$217171[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo
	mov	DWORD PTR _pFromRouteInfo$217176[ebp], eax

; 102  : #else
; 103  : 		CvRouteInfo* pFromRouteInfo = GC.getRouteInfo(pFromPlot->getRouteType());
; 104  : #endif
; 105  : 		CvAssert(pFromRouteInfo != NULL);
; 106  : 
; 107  : 		int iFromMovementCost = (pFromRouteInfo != NULL)? pFromRouteInfo->getMovementCost() : 0;

	cmp	DWORD PTR _pFromRouteInfo$217176[ebp], 0
	je	SHORT $LN39@GetCostsFo
	mov	ecx, DWORD PTR _pFromRouteInfo$217176[ebp]
	call	?getMovementCost@CvRouteInfo@@QBEHXZ	; CvRouteInfo::getMovementCost
	mov	DWORD PTR tv256[ebp], eax
	jmp	SHORT $LN40@GetCostsFo
$LN39@GetCostsFo:
	mov	DWORD PTR tv256[ebp], 0
$LN40@GetCostsFo:
	mov	edx, DWORD PTR tv256[ebp]
	mov	DWORD PTR _iFromMovementCost$217177[ebp], edx

; 108  : 		int iFromFlatMovementCost = (pFromRouteInfo != NULL)? pFromRouteInfo->getFlatMovementCost() : 0;

	cmp	DWORD PTR _pFromRouteInfo$217176[ebp], 0
	je	SHORT $LN41@GetCostsFo
	mov	ecx, DWORD PTR _pFromRouteInfo$217176[ebp]
	call	?getFlatMovementCost@CvRouteInfo@@QBEHXZ ; CvRouteInfo::getFlatMovementCost
	mov	DWORD PTR tv260[ebp], eax
	jmp	SHORT $LN42@GetCostsFo
$LN41@GetCostsFo:
	mov	DWORD PTR tv260[ebp], 0
$LN42@GetCostsFo:
	mov	eax, DWORD PTR tv260[ebp]
	mov	DWORD PTR _iFromFlatMovementCost$217178[ebp], eax

; 109  : 
; 110  : #ifdef AUI_UNIT_MOVEMENT_IROQUOIS_ROAD_TRANSITION_FIX
; 111  : 		CvRouteInfo* pRouteInfo = GC.getRouteInfo(eToPlotRoute);

	mov	ecx, DWORD PTR _eToPlotRoute$217172[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo
	mov	DWORD PTR _pRouteInfo$217179[ebp], eax

; 112  : #else
; 113  : 		CvRouteInfo* pRouteInfo = GC.getRouteInfo(pToPlot->getRouteType());
; 114  : #endif
; 115  : 		CvAssert(pRouteInfo != NULL);
; 116  : 
; 117  : 		int iMovementCost = (pRouteInfo != NULL)? pRouteInfo->getMovementCost() : 0;

	cmp	DWORD PTR _pRouteInfo$217179[ebp], 0
	je	SHORT $LN43@GetCostsFo
	mov	ecx, DWORD PTR _pRouteInfo$217179[ebp]
	call	?getMovementCost@CvRouteInfo@@QBEHXZ	; CvRouteInfo::getMovementCost
	mov	DWORD PTR tv267[ebp], eax
	jmp	SHORT $LN44@GetCostsFo
$LN43@GetCostsFo:
	mov	DWORD PTR tv267[ebp], 0
$LN44@GetCostsFo:
	mov	edx, DWORD PTR tv267[ebp]
	mov	DWORD PTR _iMovementCost$217180[ebp], edx

; 118  : 		int iFlatMovementCost = (pRouteInfo != NULL)? pRouteInfo->getFlatMovementCost() : 0;

	cmp	DWORD PTR _pRouteInfo$217179[ebp], 0
	je	SHORT $LN45@GetCostsFo
	mov	ecx, DWORD PTR _pRouteInfo$217179[ebp]
	call	?getFlatMovementCost@CvRouteInfo@@QBEHXZ ; CvRouteInfo::getFlatMovementCost
	mov	DWORD PTR tv271[ebp], eax
	jmp	SHORT $LN46@GetCostsFo
$LN45@GetCostsFo:
	mov	DWORD PTR tv271[ebp], 0
$LN46@GetCostsFo:
	mov	eax, DWORD PTR tv271[ebp]
	mov	DWORD PTR _iFlatMovementCost$217181[ebp], eax

; 119  : 
; 120  : #ifdef NQM_FAST_COMP
; 121  : #ifdef AUI_UNIT_MOVEMENT_IROQUOIS_ROAD_TRANSITION_FIX
; 122  : 		iRouteCost = MAX(iFromMovementCost + kUnitTeam.getRouteChange(eFromPlotRoute), iMovementCost + kUnitTeam.getRouteChange(eToPlotRoute));
; 123  : #else
; 124  : 		iRouteCost = MAX(iFromMovementCost + kUnitTeam.getRouteChange(pFromPlot->getRouteType()), iMovementCost + kUnitTeam.getRouteChange(pToPlot->getRouteType()));
; 125  : #endif
; 126  : 		iRouteFlatCost = MAX(iFromFlatMovementCost * iBaseMoves, iFlatMovementCost * iBaseMoves);
; 127  : #else
; 128  : #ifdef AUI_UNIT_MOVEMENT_IROQUOIS_ROAD_TRANSITION_FIX
; 129  : 		iRouteCost = std::max(iFromMovementCost + kUnitTeam.getRouteChange(eFromPlotRoute), iMovementCost + kUnitTeam.getRouteChange(eToPlotRoute));

	mov	ecx, DWORD PTR _eToPlotRoute$217172[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kUnitTeam$[ebp]
	call	?getRouteChange@CvTeam@@QBEHW4RouteTypes@@@Z ; CvTeam::getRouteChange
	add	eax, DWORD PTR _iMovementCost$217180[ebp]
	mov	DWORD PTR $T217503[ebp], eax
	mov	edx, DWORD PTR _eFromPlotRoute$217171[ebp]
	push	edx
	mov	ecx, DWORD PTR _kUnitTeam$[ebp]
	call	?getRouteChange@CvTeam@@QBEHW4RouteTypes@@@Z ; CvTeam::getRouteChange
	add	eax, DWORD PTR _iFromMovementCost$217177[ebp]
	mov	DWORD PTR $T217504[ebp], eax
	mov	eax, DWORD PTR $T217504[ebp]
	cmp	eax, DWORD PTR $T217503[ebp]
	jge	SHORT $LN142@GetCostsFo
	lea	ecx, DWORD PTR $T217503[ebp]
	mov	DWORD PTR tv386[ebp], ecx
	jmp	SHORT $LN143@GetCostsFo
$LN142@GetCostsFo:
	lea	edx, DWORD PTR $T217504[ebp]
	mov	DWORD PTR tv386[ebp], edx
$LN143@GetCostsFo:
	mov	eax, DWORD PTR tv386[ebp]
	mov	DWORD PTR $T217642[ebp], eax
	mov	ecx, DWORD PTR _iRouteCost$[ebp]
	mov	edx, DWORD PTR $T217642[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 130  : #else
; 131  : 		iRouteCost = std::max(iFromMovementCost + kUnitTeam.getRouteChange(pFromPlot->getRouteType()), iMovementCost + kUnitTeam.getRouteChange(pToPlot->getRouteType()));
; 132  : #endif
; 133  : 		iRouteFlatCost = std::max(iFromFlatMovementCost * iBaseMoves, iFlatMovementCost * iBaseMoves);

	mov	ecx, DWORD PTR _iFlatMovementCost$217181[ebp]
	imul	ecx, DWORD PTR _iBaseMoves$[ebp]
	mov	DWORD PTR $T217505[ebp], ecx
	mov	edx, DWORD PTR _iFromFlatMovementCost$217178[ebp]
	imul	edx, DWORD PTR _iBaseMoves$[ebp]
	mov	DWORD PTR $T217506[ebp], edx
	mov	eax, DWORD PTR $T217506[ebp]
	cmp	eax, DWORD PTR $T217505[ebp]
	jge	SHORT $LN146@GetCostsFo
	lea	ecx, DWORD PTR $T217505[ebp]
	mov	DWORD PTR tv282[ebp], ecx
	jmp	SHORT $LN147@GetCostsFo
$LN146@GetCostsFo:
	lea	edx, DWORD PTR $T217506[ebp]
	mov	DWORD PTR tv282[ebp], edx
$LN147@GetCostsFo:
	mov	eax, DWORD PTR tv282[ebp]
	mov	DWORD PTR $T217651[ebp], eax
	mov	ecx, DWORD PTR _iRouteFlatCost$[ebp]
	mov	edx, DWORD PTR $T217651[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	jmp	$LN6@GetCostsFo
$LN11@GetCostsFo:

; 134  : #endif
; 135  : 	}
; 136  : #ifdef AUI_UNIT_MOVEMENT_IROQUOIS_ROAD_TRANSITION_FIX
; 137  : 	else if (pTraits->IsMoveFriendlyWoodsAsRoad() && pUnit->getOwner() == pToPlot->getOwner() && (eFeature == FEATURE_FOREST || eFeature == FEATURE_JUNGLE))

	mov	ecx, DWORD PTR _pTraits$[ebp]
	mov	dl, BYTE PTR [ecx+333]
	mov	BYTE PTR $T217657[ebp], dl
	movzx	eax, BYTE PTR $T217657[ebp]
	test	eax, eax
	je	SHORT $LN5@GetCostsFo
	mov	ecx, DWORD PTR _pUnit$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR $T217666[ebp], edx
	mov	eax, DWORD PTR _pToPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	cmp	DWORD PTR $T217666[ebp], ecx
	jne	SHORT $LN5@GetCostsFo
	cmp	DWORD PTR _eFeature$[ebp], 5
	je	SHORT $LN4@GetCostsFo
	cmp	DWORD PTR _eFeature$[ebp], 1
	jne	SHORT $LN5@GetCostsFo
$LN4@GetCostsFo:

; 138  : 	{
; 139  : 		CvRouteInfo* pRoadInfo = GC.getRouteInfo(ROUTE_ROAD);

	push	0
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo
	mov	DWORD PTR _pRoadInfo$217189[ebp], eax

; 140  : 		iRouteCost = pRoadInfo->getMovementCost() + kUnitTeam.getRouteChange(ROUTE_ROAD);

	mov	ecx, DWORD PTR _pRoadInfo$217189[ebp]
	call	?getMovementCost@CvRouteInfo@@QBEHXZ	; CvRouteInfo::getMovementCost
	mov	esi, eax
	push	0
	mov	ecx, DWORD PTR _kUnitTeam$[ebp]
	call	?getRouteChange@CvTeam@@QBEHW4RouteTypes@@@Z ; CvTeam::getRouteChange
	add	esi, eax
	mov	edx, DWORD PTR _iRouteCost$[ebp]
	mov	DWORD PTR [edx], esi

; 141  : #else
; 142  : 	else if(pUnit->getOwner() == pToPlot->getOwner() && (eFeature == FEATURE_FOREST || eFeature == FEATURE_JUNGLE) && pTraits->IsMoveFriendlyWoodsAsRoad())
; 143  : 	{
; 144  : 		CvRouteInfo* pRoadInfo = GC.getRouteInfo(ROUTE_ROAD);
; 145  : 		iRouteCost = pRoadInfo->getMovementCost();
; 146  : #endif
; 147  : 		iRouteFlatCost = pRoadInfo->getFlatMovementCost() * iBaseMoves;

	mov	ecx, DWORD PTR _pRoadInfo$217189[ebp]
	call	?getFlatMovementCost@CvRouteInfo@@QBEHXZ ; CvRouteInfo::getFlatMovementCost
	imul	eax, DWORD PTR _iBaseMoves$[ebp]
	mov	ecx, DWORD PTR _iRouteFlatCost$[ebp]
	mov	DWORD PTR [ecx], eax

; 148  : 	}
; 149  : 	else

	jmp	SHORT $LN6@GetCostsFo
$LN5@GetCostsFo:

; 150  : 	{
; 151  : 		iRouteCost = INT_MAX;

	mov	edx, DWORD PTR _iRouteCost$[ebp]
	mov	DWORD PTR [edx], 2147483647		; 7fffffffH

; 152  : 		iRouteFlatCost = INT_MAX;

	mov	eax, DWORD PTR _iRouteFlatCost$[ebp]
	mov	DWORD PTR [eax], 2147483647		; 7fffffffH
$LN6@GetCostsFo:

; 153  : 	}
; 154  : 
; 155  : 	if(pUnit->getDomainType() == DOMAIN_SEA && pToPlot->IsAllowsSailLand()){ // from Izy

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	jne	SHORT $LN2@GetCostsFo
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?IsAllowsSailLand@CvPlot@@QBE_NXZ	; CvPlot::IsAllowsSailLand
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@GetCostsFo

; 156  : 			iRegularCost = iMoveDenominator*3;

	mov	edx, DWORD PTR _iMoveDenominator$[ebp]
	imul	edx, 3
	mov	eax, DWORD PTR _iRegularCost$[ebp]
	mov	DWORD PTR [eax], edx

; 157  : 			iRouteCost = iRegularCost;

	mov	ecx, DWORD PTR _iRouteCost$[ebp]
	mov	edx, DWORD PTR _iRegularCost$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 158  : 			iRouteFlatCost = iRegularCost;

	mov	ecx, DWORD PTR _iRouteFlatCost$[ebp]
	mov	edx, DWORD PTR _iRegularCost$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
$LN2@GetCostsFo:

; 159  : 		}
; 160  : 	if(pUnit->getDomainType() == DOMAIN_LAND && pToPlot->IsAllowsSailLand() && (!bIgnoreTerrainCost)) { 

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN25@GetCostsFo
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?IsAllowsSailLand@CvPlot@@QBE_NXZ	; CvPlot::IsAllowsSailLand
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN25@GetCostsFo
	movzx	edx, BYTE PTR _bIgnoreTerrainCost$[ebp]
	test	edx, edx
	jne	SHORT $LN25@GetCostsFo

; 161  : 			iRegularCost = iMoveDenominator;

	mov	eax, DWORD PTR _iRegularCost$[ebp]
	mov	ecx, DWORD PTR _iMoveDenominator$[ebp]
	mov	DWORD PTR [eax], ecx

; 162  : 			iRouteCost = iRegularCost;

	mov	edx, DWORD PTR _iRouteCost$[ebp]
	mov	eax, DWORD PTR _iRegularCost$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 163  : 			iRouteFlatCost = iRegularCost;

	mov	edx, DWORD PTR _iRouteFlatCost$[ebp]
	mov	eax, DWORD PTR _iRegularCost$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
$LN25@GetCostsFo:

; 164  : 		}
; 165  : 
; 166  : 	
; 167  : 
; 168  : 	// NQMP GJS - Great Wall fix
; 169  : 	/*
; 170  : 	TeamTypes eTeam = pToPlot->getTeam();
; 171  : 	if(eTeam != NO_TEAM)
; 172  : 	{
; 173  : 		CvTeam* pPlotTeam = &GET_TEAM(eTeam);
; 174  : 		CvPlayer* pPlotPlayer = &GET_PLAYER(pToPlot->getOwner());
; 175  : 
; 176  : 		// Great Wall increases movement cost by 1
; 177  : 		if(pPlotTeam->isBorderObstacle() || pPlotPlayer->isBorderObstacle())
; 178  : 		{
; 179  : 			if(!pToPlot->isWater() && pUnit->getDomainType() == DOMAIN_LAND)
; 180  : 			{
; 181  : 				// Don't apply penalty to OUR team or teams we've given open borders to
; 182  : 				if(eUnitTeam != eTeam && !pPlotTeam->IsAllowsOpenBordersToTeam(eUnitTeam))
; 183  : 				{
; 184  : 					iRegularCost += iMoveDenominator;
; 185  : 				}
; 186  : 			}
; 187  : 		}
; 188  : 	}
; 189  : 	*/
; 190  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCostsForMove@CvUnitMovement@@SAXPBVCvUnit@@PBVCvPlot@@1HAAH22@Z ENDP ; CvUnitMovement::GetCostsForMove
_TEXT	ENDS
PUBLIC	?directionXY@@YA?AW4DirectionTypes@@HHHH@Z	; directionXY
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?directionXY@@YA?AW4DirectionTypes@@PBVCvPlot@@0@Z
_TEXT	SEGMENT
$T217687 = -16						; size = 4
$T217683 = -12						; size = 4
$T217679 = -8						; size = 4
$T217675 = -4						; size = 4
_pFromPlot$ = 8						; size = 4
_pToPlot$ = 12						; size = 4
?directionXY@@YA?AW4DirectionTypes@@PBVCvPlot@@0@Z PROC	; directionXY, COMDAT

; 311  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 312  : 	return directionXY(pFromPlot->getX(), pFromPlot->getY(),
; 313  : 	                   pToPlot->getX(), pToPlot->getY());

	mov	eax, DWORD PTR _pToPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T217675[ebp], ecx
	mov	edx, DWORD PTR _pToPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T217679[ebp], eax
	mov	ecx, DWORD PTR _pFromPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T217683[ebp], edx
	mov	eax, DWORD PTR _pFromPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T217687[ebp], ecx
	mov	edx, DWORD PTR $T217675[ebp]
	push	edx
	mov	eax, DWORD PTR $T217679[ebp]
	push	eax
	mov	ecx, DWORD PTR $T217683[ebp]
	push	ecx
	mov	edx, DWORD PTR $T217687[ebp]
	push	edx
	call	?directionXY@@YA?AW4DirectionTypes@@HHHH@Z ; directionXY
	add	esp, 16					; 00000010H

; 314  : 
; 315  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?directionXY@@YA?AW4DirectionTypes@@PBVCvPlot@@0@Z ENDP	; directionXY
_TEXT	ENDS
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
; Function compile flags: /Odtp
;	COMDAT ?directionXY@@YA?AW4DirectionTypes@@HHHH@Z
_TEXT	SEGMENT
tv90 = -56						; size = 4
tv86 = -52						; size = 4
_iDestHexX$ = -16					; size = 4
_iWrappedXOffset$ = -12					; size = 4
_iSourceHexX$ = -8					; size = 4
_iWrappedYOffset$ = -4					; size = 4
_iSourceX$ = 8						; size = 4
_iSourceY$ = 12						; size = 4
_iDestX$ = 16						; size = 4
_iDestY$ = 20						; size = 4
?directionXY@@YA?AW4DirectionTypes@@HHHH@Z PROC		; directionXY, COMDAT

; 264  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 265  : 	int iSourceHexX = xToHexspaceX(iSourceX, iSourceY);

	cmp	DWORD PTR _iSourceY$[ebp], 0
	jl	SHORT $LN17@directionX
	mov	eax, DWORD PTR _iSourceY$[ebp]
	sar	eax, 1
	mov	DWORD PTR tv86[ebp], eax
	jmp	SHORT $LN15@directionX
$LN17@directionX:
	mov	eax, DWORD PTR _iSourceY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv86[ebp], eax
$LN15@directionX:
	mov	ecx, DWORD PTR _iSourceX$[ebp]
	sub	ecx, DWORD PTR tv86[ebp]
	mov	DWORD PTR _iSourceHexX$[ebp], ecx

; 266  : 	int iDestHexX = xToHexspaceX(iDestX, iDestY);

	cmp	DWORD PTR _iDestY$[ebp], 0
	jl	SHORT $LN21@directionX
	mov	edx, DWORD PTR _iDestY$[ebp]
	sar	edx, 1
	mov	DWORD PTR tv90[ebp], edx
	jmp	SHORT $LN19@directionX
$LN21@directionX:
	mov	eax, DWORD PTR _iDestY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv90[ebp], eax
$LN19@directionX:
	mov	eax, DWORD PTR _iDestX$[ebp]
	sub	eax, DWORD PTR tv90[ebp]
	mov	DWORD PTR _iDestHexX$[ebp], eax

; 267  : 
; 268  : 	int iWrappedXOffset = dxWrap(iDestHexX - iSourceHexX);

	mov	ecx, DWORD PTR _iDestHexX$[ebp]
	sub	ecx, DWORD PTR _iSourceHexX$[ebp]
	push	ecx
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedXOffset$[ebp], eax

; 269  : 	int iWrappedYOffset = dyWrap(iDestY - iSourceY);

	mov	edx, DWORD PTR _iDestY$[ebp]
	sub	edx, DWORD PTR _iSourceY$[ebp]
	push	edx
	call	?dyWrap@@YAHH@Z				; dyWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedYOffset$[ebp], eax

; 270  : 
; 271  : 	if(iWrappedYOffset > 0)

	cmp	DWORD PTR _iWrappedYOffset$[ebp], 0
	jle	SHORT $LN12@directionX

; 272  : 	{
; 273  : 		if(iWrappedXOffset >= 0)

	cmp	DWORD PTR _iWrappedXOffset$[ebp], 0
	jl	SHORT $LN11@directionX

; 274  : 		{
; 275  : 			return DIRECTION_NORTHEAST;

	xor	eax, eax
	jmp	SHORT $LN13@directionX

; 276  : 		}
; 277  : 		else

	jmp	SHORT $LN10@directionX
$LN11@directionX:

; 278  : 		{
; 279  : 			return DIRECTION_NORTHWEST;

	mov	eax, 5
	jmp	SHORT $LN13@directionX
$LN10@directionX:

; 280  : 		}

	jmp	SHORT $LN13@directionX
$LN12@directionX:

; 281  : 	}
; 282  : 	else if(iWrappedYOffset == 0)

	cmp	DWORD PTR _iWrappedYOffset$[ebp], 0
	jne	SHORT $LN8@directionX

; 283  : 	{
; 284  : 		if(iWrappedXOffset > 0)

	cmp	DWORD PTR _iWrappedXOffset$[ebp], 0
	jle	SHORT $LN7@directionX

; 285  : 		{
; 286  : 			return DIRECTION_EAST;

	mov	eax, 1
	jmp	SHORT $LN13@directionX
	jmp	SHORT $LN6@directionX
$LN7@directionX:

; 287  : 		}
; 288  : 		else if(iWrappedXOffset == 0)

	cmp	DWORD PTR _iWrappedXOffset$[ebp], 0
	jne	SHORT $LN5@directionX

; 289  : 		{
; 290  : 			return NO_DIRECTION;

	or	eax, -1
	jmp	SHORT $LN13@directionX

; 291  : 		}
; 292  : 		else

	jmp	SHORT $LN6@directionX
$LN5@directionX:

; 293  : 		{
; 294  : 			return DIRECTION_WEST;

	mov	eax, 4
	jmp	SHORT $LN13@directionX
$LN6@directionX:

; 295  : 		}
; 296  : 	}
; 297  : 	else// if (iWrappedYOffset < 0)

	jmp	SHORT $LN13@directionX
$LN8@directionX:

; 298  : 	{
; 299  : 		if(iWrappedXOffset > 0)

	cmp	DWORD PTR _iWrappedXOffset$[ebp], 0
	jle	SHORT $LN2@directionX

; 300  : 		{
; 301  : 			return DIRECTION_SOUTHEAST;

	mov	eax, 2
	jmp	SHORT $LN13@directionX

; 302  : 		}
; 303  : 		else

	jmp	SHORT $LN13@directionX
$LN2@directionX:

; 304  : 		{
; 305  : 			return DIRECTION_SOUTHWEST;

	mov	eax, 3
$LN13@directionX:

; 306  : 		}
; 307  : 	}
; 308  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?directionXY@@YA?AW4DirectionTypes@@HHHH@Z ENDP		; directionXY
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
$T217819 = -16						; size = 4
$T217811 = -12						; size = 4
$T217807 = -5						; size = 1
_kMap$ = -4						; size = 4
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T217807[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T217811[ebp], ecx
	movzx	edx, BYTE PTR $T217807[ebp]
	test	edx, edx
	je	SHORT $LN12@dxWrap
	mov	eax, DWORD PTR $T217811[ebp]
	shr	eax, 1
	cmp	DWORD PTR _iDX$[ebp], eax
	jle	SHORT $LN11@dxWrap
	mov	ecx, DWORD PTR _iDX$[ebp]
	sub	ecx, DWORD PTR $T217811[ebp]
	mov	DWORD PTR $T217819[ebp], ecx
	jmp	SHORT $LN13@dxWrap
	jmp	SHORT $LN12@dxWrap
$LN11@dxWrap:
	mov	edx, DWORD PTR $T217811[ebp]
	shr	edx, 1
	neg	edx
	cmp	DWORD PTR _iDX$[ebp], edx
	jge	SHORT $LN12@dxWrap
	mov	eax, DWORD PTR _iDX$[ebp]
	add	eax, DWORD PTR $T217811[ebp]
	mov	DWORD PTR $T217819[ebp], eax
	jmp	SHORT $LN13@dxWrap
$LN12@dxWrap:
	mov	ecx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR $T217819[ebp], ecx
$LN13@dxWrap:
	mov	eax, DWORD PTR $T217819[ebp]

; 76   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
$T217840 = -16						; size = 4
$T217832 = -12						; size = 4
$T217828 = -5						; size = 1
_kMap$ = -4						; size = 4
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 79   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T217828[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T217832[ebp], ecx
	movzx	edx, BYTE PTR $T217828[ebp]
	test	edx, edx
	je	SHORT $LN12@dyWrap
	mov	eax, DWORD PTR $T217832[ebp]
	shr	eax, 1
	cmp	DWORD PTR _iDY$[ebp], eax
	jle	SHORT $LN11@dyWrap
	mov	ecx, DWORD PTR _iDY$[ebp]
	sub	ecx, DWORD PTR $T217832[ebp]
	mov	DWORD PTR $T217840[ebp], ecx
	jmp	SHORT $LN13@dyWrap
	jmp	SHORT $LN12@dyWrap
$LN11@dyWrap:
	mov	edx, DWORD PTR $T217832[ebp]
	shr	edx, 1
	neg	edx
	cmp	DWORD PTR _iDY$[ebp], edx
	jge	SHORT $LN12@dyWrap
	mov	eax, DWORD PTR _iDY$[ebp]
	add	eax, DWORD PTR $T217832[ebp]
	mov	DWORD PTR $T217840[ebp], eax
	jmp	SHORT $LN13@dyWrap
$LN12@dyWrap:
	mov	ecx, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR $T217840[ebp], ecx
$LN13@dyWrap:
	mov	eax, DWORD PTR $T217840[ebp]

; 82   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
_TEXT	ENDS
PUBLIC	?IsSlowedByZOC@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z ; CvUnitMovement::IsSlowedByZOC
PUBLIC	?CostsOnlyOne@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z ; CvUnitMovement::CostsOnlyOne
PUBLIC	?ConsumesAllMoves@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z ; CvUnitMovement::ConsumesAllMoves
PUBLIC	?MovementCost@CvUnitMovement@@SAHPBVCvUnit@@PBVCvPlot@@1HHH@Z ; CvUnitMovement::MovementCost
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvunitmovement.cpp
;	COMDAT ?MovementCost@CvUnitMovement@@SAHPBVCvUnit@@PBVCvPlot@@1HHH@Z
_TEXT	SEGMENT
tv131 = -44						; size = 4
tv129 = -40						; size = 4
tv135 = -36						; size = 4
$T217872 = -32						; size = 4
$T217863 = -28						; size = 4
$T217854 = -24						; size = 4
$T217847 = -20						; size = 4
$T217843 = -16						; size = 4
_iRouteFlatCost$ = -12					; size = 4
_iRegularCost$ = -8					; size = 4
_iRouteCost$ = -4					; size = 4
_pUnit$ = 8						; size = 4
_pFromPlot$ = 12					; size = 4
_pToPlot$ = 16						; size = 4
_iBaseMoves$ = 20					; size = 4
_iMaxMoves$ = 24					; size = 4
_iMovesRemaining$ = 28					; size = 4
?MovementCost@CvUnitMovement@@SAHPBVCvUnit@@PBVCvPlot@@1HHH@Z PROC ; CvUnitMovement::MovementCost, COMDAT

; 194  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 195  : 	int iRegularCost;
; 196  : 	int iRouteCost;
; 197  : 	int iRouteFlatCost;
; 198  : 
; 199  : 	CvAssertMsg(pToPlot->getTerrainType() != NO_TERRAIN, "TerrainType is not assigned a valid value");
; 200  : 
; 201  : 	if(ConsumesAllMoves(pUnit, pFromPlot, pToPlot))

	mov	eax, DWORD PTR _pToPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFromPlot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pUnit$[ebp]
	push	edx
	call	?ConsumesAllMoves@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z ; CvUnitMovement::ConsumesAllMoves
	add	esp, 12					; 0000000cH
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@MovementCo

; 202  : 	{
; 203  : 		if (iMovesRemaining > 0)

	cmp	DWORD PTR _iMovesRemaining$[ebp], 0
	jle	SHORT $LN8@MovementCo

; 204  : 			return iMovesRemaining;

	mov	eax, DWORD PTR _iMovesRemaining$[ebp]
	jmp	$LN10@MovementCo

; 205  : 		else

	jmp	SHORT $LN7@MovementCo
$LN8@MovementCo:

; 206  : 			return iMaxMoves;

	mov	eax, DWORD PTR _iMaxMoves$[ebp]
	jmp	$LN10@MovementCo
$LN7@MovementCo:
	jmp	SHORT $LN6@MovementCo
$LN9@MovementCo:

; 207  : 	}
; 208  : 	else if(CostsOnlyOne(pUnit, pFromPlot, pToPlot))

	mov	ecx, DWORD PTR _pToPlot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pFromPlot$[ebp]
	push	edx
	mov	eax, DWORD PTR _pUnit$[ebp]
	push	eax
	call	?CostsOnlyOne@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z ; CvUnitMovement::CostsOnlyOne
	add	esp, 12					; 0000000cH
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@MovementCo

; 209  : 	{
; 210  : 		return GC.getMOVE_DENOMINATOR();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6236
	mov	DWORD PTR $T217847[ebp], edx
	mov	eax, DWORD PTR $T217847[ebp]
	jmp	$LN10@MovementCo
	jmp	SHORT $LN6@MovementCo
$LN5@MovementCo:

; 211  : 	}
; 212  : 	else if(IsSlowedByZOC(pUnit, pFromPlot, pToPlot))

	mov	eax, DWORD PTR _pToPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFromPlot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pUnit$[ebp]
	push	edx
	call	?IsSlowedByZOC@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z ; CvUnitMovement::IsSlowedByZOC
	add	esp, 12					; 0000000cH
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@MovementCo

; 213  : 	{
; 214  : 		if (iMovesRemaining > 0)

	cmp	DWORD PTR _iMovesRemaining$[ebp], 0
	jle	SHORT $LN2@MovementCo

; 215  : 			return iMovesRemaining;

	mov	eax, DWORD PTR _iMovesRemaining$[ebp]
	jmp	$LN10@MovementCo

; 216  : 		else

	jmp	SHORT $LN6@MovementCo
$LN2@MovementCo:

; 217  : 			return iMaxMoves;

	mov	eax, DWORD PTR _iMaxMoves$[ebp]
	jmp	$LN10@MovementCo
$LN6@MovementCo:

; 218  : 	}
; 219  : 
; 220  : 	GetCostsForMove(pUnit, pFromPlot, pToPlot, iBaseMoves, iRegularCost, iRouteCost, iRouteFlatCost);

	lea	ecx, DWORD PTR _iRouteFlatCost$[ebp]
	push	ecx
	lea	edx, DWORD PTR _iRouteCost$[ebp]
	push	edx
	lea	eax, DWORD PTR _iRegularCost$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iBaseMoves$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pToPlot$[ebp]
	push	edx
	mov	eax, DWORD PTR _pFromPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	push	ecx
	call	?GetCostsForMove@CvUnitMovement@@SAXPBVCvUnit@@PBVCvPlot@@1HAAH22@Z ; CvUnitMovement::GetCostsForMove
	add	esp, 28					; 0000001cH

; 221  : 
; 222  : 	return std::max(1, std::min(iRegularCost, std::min(iRouteCost, iRouteFlatCost)));

	mov	DWORD PTR $T217843[ebp], 1
	mov	edx, DWORD PTR _iRouteFlatCost$[ebp]
	cmp	edx, DWORD PTR _iRouteCost$[ebp]
	jge	SHORT $LN16@MovementCo
	lea	eax, DWORD PTR _iRouteFlatCost$[ebp]
	mov	DWORD PTR tv135[ebp], eax
	jmp	SHORT $LN17@MovementCo
$LN16@MovementCo:
	lea	ecx, DWORD PTR _iRouteCost$[ebp]
	mov	DWORD PTR tv135[ebp], ecx
$LN17@MovementCo:
	mov	edx, DWORD PTR tv135[ebp]
	mov	DWORD PTR $T217854[ebp], edx
	mov	eax, DWORD PTR $T217854[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _iRegularCost$[ebp]
	jge	SHORT $LN20@MovementCo
	mov	edx, DWORD PTR $T217854[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN21@MovementCo
$LN20@MovementCo:
	lea	eax, DWORD PTR _iRegularCost$[ebp]
	mov	DWORD PTR tv129[ebp], eax
$LN21@MovementCo:
	mov	ecx, DWORD PTR tv129[ebp]
	mov	DWORD PTR $T217863[ebp], ecx
	mov	edx, DWORD PTR $T217863[ebp]
	mov	eax, DWORD PTR $T217843[ebp]
	cmp	eax, DWORD PTR [edx]
	jge	SHORT $LN24@MovementCo
	mov	ecx, DWORD PTR $T217863[ebp]
	mov	DWORD PTR tv131[ebp], ecx
	jmp	SHORT $LN25@MovementCo
$LN24@MovementCo:
	lea	edx, DWORD PTR $T217843[ebp]
	mov	DWORD PTR tv131[ebp], edx
$LN25@MovementCo:
	mov	eax, DWORD PTR tv131[ebp]
	mov	DWORD PTR $T217872[ebp], eax
	mov	ecx, DWORD PTR $T217872[ebp]
	mov	eax, DWORD PTR [ecx]
$LN10@MovementCo:

; 223  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?MovementCost@CvUnitMovement@@SAHPBVCvUnit@@PBVCvPlot@@1HHH@Z ENDP ; CvUnitMovement::MovementCost
_TEXT	ENDS
PUBLIC	?MovementCostNoZOC@CvUnitMovement@@SAHPBVCvUnit@@PBVCvPlot@@1HHH@Z ; CvUnitMovement::MovementCostNoZOC
; Function compile flags: /Odtp
;	COMDAT ?MovementCostNoZOC@CvUnitMovement@@SAHPBVCvUnit@@PBVCvPlot@@1HHH@Z
_TEXT	SEGMENT
tv92 = -44						; size = 4
tv90 = -40						; size = 4
tv128 = -36						; size = 4
$T217906 = -32						; size = 4
$T217897 = -28						; size = 4
$T217888 = -24						; size = 4
$T217881 = -20						; size = 4
$T217877 = -16						; size = 4
_iRouteFlatCost$ = -12					; size = 4
_iRegularCost$ = -8					; size = 4
_iRouteCost$ = -4					; size = 4
_pUnit$ = 8						; size = 4
_pFromPlot$ = 12					; size = 4
_pToPlot$ = 16						; size = 4
_iBaseMoves$ = 20					; size = 4
_iMaxMoves$ = 24					; size = 4
_iMovesRemaining$ = 28					; size = 4
?MovementCostNoZOC@CvUnitMovement@@SAHPBVCvUnit@@PBVCvPlot@@1HHH@Z PROC ; CvUnitMovement::MovementCostNoZOC, COMDAT

; 227  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 228  : 	int iRegularCost;
; 229  : 	int iRouteCost;
; 230  : 	int iRouteFlatCost;
; 231  : 
; 232  : 	CvAssertMsg(pToPlot->getTerrainType() != NO_TERRAIN, "TerrainType is not assigned a valid value");
; 233  : 
; 234  : 	if(ConsumesAllMoves(pUnit, pFromPlot, pToPlot))

	mov	eax, DWORD PTR _pToPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFromPlot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pUnit$[ebp]
	push	edx
	call	?ConsumesAllMoves@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z ; CvUnitMovement::ConsumesAllMoves
	add	esp, 12					; 0000000cH
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@MovementCo@2

; 235  : 	{
; 236  : 		if (iMovesRemaining > 0)

	cmp	DWORD PTR _iMovesRemaining$[ebp], 0
	jle	SHORT $LN4@MovementCo@2

; 237  : 			return iMovesRemaining;

	mov	eax, DWORD PTR _iMovesRemaining$[ebp]
	jmp	$LN6@MovementCo@2

; 238  : 		else

	jmp	SHORT $LN3@MovementCo@2
$LN4@MovementCo@2:

; 239  : 			return iMaxMoves;

	mov	eax, DWORD PTR _iMaxMoves$[ebp]
	jmp	$LN6@MovementCo@2
$LN3@MovementCo@2:
	jmp	SHORT $LN2@MovementCo@2
$LN5@MovementCo@2:

; 240  : 	}
; 241  : 	else if(CostsOnlyOne(pUnit, pFromPlot, pToPlot))

	mov	ecx, DWORD PTR _pToPlot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pFromPlot$[ebp]
	push	edx
	mov	eax, DWORD PTR _pUnit$[ebp]
	push	eax
	call	?CostsOnlyOne@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z ; CvUnitMovement::CostsOnlyOne
	add	esp, 12					; 0000000cH
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@MovementCo@2

; 242  : 	{
; 243  : 		return GC.getMOVE_DENOMINATOR();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6236
	mov	DWORD PTR $T217881[ebp], edx
	mov	eax, DWORD PTR $T217881[ebp]
	jmp	$LN6@MovementCo@2
$LN2@MovementCo@2:

; 244  : 	}
; 245  : 
; 246  : 	GetCostsForMove(pUnit, pFromPlot, pToPlot, iBaseMoves, iRegularCost, iRouteCost, iRouteFlatCost);

	lea	eax, DWORD PTR _iRouteFlatCost$[ebp]
	push	eax
	lea	ecx, DWORD PTR _iRouteCost$[ebp]
	push	ecx
	lea	edx, DWORD PTR _iRegularCost$[ebp]
	push	edx
	mov	eax, DWORD PTR _iBaseMoves$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pFromPlot$[ebp]
	push	edx
	mov	eax, DWORD PTR _pUnit$[ebp]
	push	eax
	call	?GetCostsForMove@CvUnitMovement@@SAXPBVCvUnit@@PBVCvPlot@@1HAAH22@Z ; CvUnitMovement::GetCostsForMove
	add	esp, 28					; 0000001cH

; 247  : 
; 248  : 	return std::max(1, std::min(iRegularCost, std::min(iRouteCost, iRouteFlatCost)));

	mov	DWORD PTR $T217877[ebp], 1
	mov	ecx, DWORD PTR _iRouteFlatCost$[ebp]
	cmp	ecx, DWORD PTR _iRouteCost$[ebp]
	jge	SHORT $LN12@MovementCo@2
	lea	edx, DWORD PTR _iRouteFlatCost$[ebp]
	mov	DWORD PTR tv128[ebp], edx
	jmp	SHORT $LN13@MovementCo@2
$LN12@MovementCo@2:
	lea	eax, DWORD PTR _iRouteCost$[ebp]
	mov	DWORD PTR tv128[ebp], eax
$LN13@MovementCo@2:
	mov	ecx, DWORD PTR tv128[ebp]
	mov	DWORD PTR $T217888[ebp], ecx
	mov	edx, DWORD PTR $T217888[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _iRegularCost$[ebp]
	jge	SHORT $LN16@MovementCo@2
	mov	ecx, DWORD PTR $T217888[ebp]
	mov	DWORD PTR tv90[ebp], ecx
	jmp	SHORT $LN17@MovementCo@2
$LN16@MovementCo@2:
	lea	edx, DWORD PTR _iRegularCost$[ebp]
	mov	DWORD PTR tv90[ebp], edx
$LN17@MovementCo@2:
	mov	eax, DWORD PTR tv90[ebp]
	mov	DWORD PTR $T217897[ebp], eax
	mov	ecx, DWORD PTR $T217897[ebp]
	mov	edx, DWORD PTR $T217877[ebp]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN20@MovementCo@2
	mov	eax, DWORD PTR $T217897[ebp]
	mov	DWORD PTR tv92[ebp], eax
	jmp	SHORT $LN21@MovementCo@2
$LN20@MovementCo@2:
	lea	ecx, DWORD PTR $T217877[ebp]
	mov	DWORD PTR tv92[ebp], ecx
$LN21@MovementCo@2:
	mov	edx, DWORD PTR tv92[ebp]
	mov	DWORD PTR $T217906[ebp], edx
	mov	eax, DWORD PTR $T217906[ebp]
	mov	eax, DWORD PTR [eax]
$LN6@MovementCo@2:

; 249  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?MovementCostNoZOC@CvUnitMovement@@SAHPBVCvUnit@@PBVCvPlot@@1HHH@Z ENDP ; CvUnitMovement::MovementCostNoZOC
_TEXT	ENDS
EXTRN	?CanEverEmbark@CvUnit@@QBE_NXZ:PROC		; CvUnit::CanEverEmbark
EXTRN	?canMoveAllTerrain@CvUnit@@QBE_NXZ:PROC		; CvUnit::canMoveAllTerrain
EXTRN	?IsHoveringUnit@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsHoveringUnit
EXTRN	?isValidDomainForLocation@CvPlot@@QBE_NABVCvUnit@@@Z:PROC ; CvPlot::isValidDomainForLocation
EXTRN	?IsAllowsWalkWater@CvPlot@@QBE_NXZ:PROC		; CvPlot::IsAllowsWalkWater
EXTRN	?isHuman@CvUnit@@QBE_NXZ:PROC			; CvUnit::isHuman
; Function compile flags: /Odtp
;	COMDAT ?ConsumesAllMoves@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z
_TEXT	SEGMENT
$T217961 = -25						; size = 1
$T217960 = -24						; size = 4
$T217956 = -20						; size = 4
$T217952 = -16						; size = 4
$T217934 = -10						; size = 1
$T217930 = -9						; size = 1
$T217921 = -8						; size = 4
_uiOffset$217919 = -4					; size = 4
_pUnit$ = 8						; size = 4
_pFromPlot$ = 12					; size = 4
_pToPlot$ = 16						; size = 4
?ConsumesAllMoves@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z PROC ; CvUnitMovement::ConsumesAllMoves, COMDAT

; 253  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 254  : 
; 255  : 	
; 256  : 
; 257  : 	if(!pToPlot->isRevealed(pUnit->getTeam()) && pUnit->isHuman())

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	mov	DWORD PTR $T217921[ebp], eax
	mov	eax, DWORD PTR $T217921[ebp]
	shr	eax, 5
	mov	DWORD PTR _uiOffset$217919[ebp], eax
	mov	ecx, DWORD PTR _uiOffset$217919[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR $T217921[ebp]
	sub	edx, ecx
	mov	eax, 1
	mov	ecx, edx
	shl	eax, cl
	mov	ecx, DWORD PTR _uiOffset$217919[ebp]
	mov	edx, DWORD PTR _pToPlot$[ebp]
	and	eax, DWORD PTR [edx+ecx*4+8]
	setne	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN18@ConsumesAl
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?isHuman@CvUnit@@QBE_NXZ		; CvUnit::isHuman
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN18@ConsumesAl

; 258  : 	{
; 259  : 		return true;

	mov	al, 1
	jmp	$LN10@ConsumesAl

; 260  : 	}
; 261  : 
; 262  : #ifndef AUI_UNIT_MOVEMENT_FIX_BAD_ALLOWS_WATER_WALK_CHECK
; 263  : 	if (!pUnit->isEmbarked() && (pToPlot->IsAllowsWalkWater() || pFromPlot->IsAllowsWalkWater()))

$LN18@ConsumesAl:
	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	cl, BYTE PTR [eax+1652]
	mov	BYTE PTR $T217930[ebp], cl
	movzx	edx, BYTE PTR $T217930[ebp]
	test	edx, edx
	jne	SHORT $LN8@ConsumesAl
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?IsAllowsWalkWater@CvPlot@@QBE_NXZ	; CvPlot::IsAllowsWalkWater
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN7@ConsumesAl
	mov	ecx, DWORD PTR _pFromPlot$[ebp]
	call	?IsAllowsWalkWater@CvPlot@@QBE_NXZ	; CvPlot::IsAllowsWalkWater
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN8@ConsumesAl
$LN7@ConsumesAl:

; 264  : 	{
; 265  : 		return false;

	xor	al, al
	jmp	$LN10@ConsumesAl
$LN8@ConsumesAl:

; 266  : 	}
; 267  : #endif
; 268  : 
; 269  : 	if(!pFromPlot->isValidDomainForLocation(*pUnit))

	mov	edx, DWORD PTR _pUnit$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pFromPlot$[ebp]
	call	?isValidDomainForLocation@CvPlot@@QBE_NABVCvUnit@@@Z ; CvPlot::isValidDomainForLocation
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@ConsumesAl

; 270  : 	{
; 271  : 		// If we are a land unit that can embark, then do further tests.
; 272  : #ifdef AUI_UNIT_FIX_HOVERING_EMBARK
; 273  : 		if (pUnit->getDomainType() != DOMAIN_LAND || pUnit->canMoveAllTerrain() || !pUnit->CanEverEmbark())
; 274  : #else
; 275  : 		if(pUnit->getDomainType() != DOMAIN_LAND || pUnit->IsHoveringUnit() || pUnit->canMoveAllTerrain() || !pUnit->CanEverEmbark())

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN4@ConsumesAl
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?IsHoveringUnit@CvUnit@@QBE_NXZ		; CvUnit::IsHoveringUnit
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN4@ConsumesAl
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canMoveAllTerrain@CvUnit@@QBE_NXZ	; CvUnit::canMoveAllTerrain
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN4@ConsumesAl
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?CanEverEmbark@CvUnit@@QBE_NXZ		; CvUnit::CanEverEmbark
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@ConsumesAl
$LN4@ConsumesAl:

; 276  : #endif
; 277  : 			return true;

	mov	al, 1
	jmp	$LN10@ConsumesAl
$LN6@ConsumesAl:

; 278  : 	}
; 279  : 
; 280  : 	if(pToPlot->isWater() != pFromPlot->isWater() && pUnit->CanEverEmbark())

	mov	ecx, DWORD PTR _pToPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	xor	eax, eax
	cmp	edx, 3
	sete	al
	mov	BYTE PTR $T217934[ebp], al
	movzx	ecx, BYTE PTR $T217934[ebp]
	mov	edx, DWORD PTR _pFromPlot$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	edx, edx
	cmp	eax, 3
	sete	dl
	movzx	eax, dl
	cmp	ecx, eax
	je	$LN3@ConsumesAl
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?CanEverEmbark@CvUnit@@QBE_NXZ		; CvUnit::CanEverEmbark
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@ConsumesAl

; 281  : 
; 282  : 	{
; 283  : #ifdef LEK_EMBARK_1_MOVEMENT
; 284  : 		//EAP: Embarking now costs 1 movement
; 285  : 
; 286  : 		if (pToPlot->isWater() && !pFromPlot->isWater() && pUnit->CanEverEmbark())
; 287  : 		{
; 288  : 			return false;
; 289  : 		}
; 290  : #endif
; 291  : 
; 292  : 		//
; 293  : 		
; 294  : 		// Is the unit from a civ that can disembark for just 1 MP?
; 295  : #ifdef AUI_UNIT_FIX_HOVERING_EMBARK
; 296  : 		if (bFromPlotNeedEmbark && GET_PLAYER(pUnit->getOwner()).GetPlayerTraits()->IsEmbarkedToLandFlatCost())
; 297  : #elif defined(AUI_UNIT_MOVEMENT_FIX_BAD_VIKING_DISEMBARK_PREVIEW)
; 298  : 		if (!pToPlot->isWater() && pFromPlot->isWater() && GET_PLAYER(pUnit->getOwner()).GetPlayerTraits()->IsEmbarkedToLandFlatCost())

	mov	edx, DWORD PTR _pToPlot$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN2@ConsumesAl
	mov	eax, DWORD PTR _pFromPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN2@ConsumesAl
	mov	ecx, DWORD PTR _pUnit$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR $T217952[ebp], edx
	mov	eax, DWORD PTR $T217952[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T217956[ebp], eax
	mov	ecx, DWORD PTR $T217956[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T217960[ebp], eax
	mov	ecx, DWORD PTR $T217960[ebp]
	mov	dl, BYTE PTR [ecx+337]
	mov	BYTE PTR $T217961[ebp], dl
	movzx	eax, BYTE PTR $T217961[ebp]
	test	eax, eax
	je	SHORT $LN2@ConsumesAl

; 299  : #else
; 300  : 		if(!pToPlot->isWater() && pFromPlot->isWater() && pUnit->isEmbarked() && GET_PLAYER(pUnit->getOwner()).GetPlayerTraits()->IsEmbarkedToLandFlatCost())
; 301  : #endif
; 302  : 		{
; 303  : 			return false;	// Then no, it does not.

	xor	al, al
	jmp	SHORT $LN10@ConsumesAl
$LN2@ConsumesAl:

; 304  : 		}
; 305  : 
; 306  : 		
; 307  : 		
; 308  : 		if(!pUnit->canMoveAllTerrain())

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canMoveAllTerrain@CvUnit@@QBE_NXZ	; CvUnit::canMoveAllTerrain
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@ConsumesAl

; 309  : 		{
; 310  : 			return true;

	mov	al, 1
	jmp	SHORT $LN10@ConsumesAl
$LN3@ConsumesAl:

; 311  : 		}
; 312  : 	}
; 313  : 	
; 314  : 
; 315  : 	return false;

	xor	al, al
$LN10@ConsumesAl:

; 316  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ConsumesAllMoves@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z ENDP ; CvUnitMovement::ConsumesAllMoves
_TEXT	ENDS
EXTRN	?flatMovementCost@CvUnit@@QBE_NXZ:PROC		; CvUnit::flatMovementCost
EXTRN	?isValidDomainForAction@CvPlot@@QBE_NABVCvUnit@@@Z:PROC ; CvPlot::isValidDomainForAction
; Function compile flags: /Odtp
;	COMDAT ?CostsOnlyOne@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z
_TEXT	SEGMENT
$T217987 = -13						; size = 1
$T217986 = -12						; size = 4
$T217982 = -8						; size = 4
$T217978 = -4						; size = 4
_pUnit$ = 8						; size = 4
_pFromPlot$ = 12					; size = 4
_pToPlot$ = 16						; size = 4
?CostsOnlyOne@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z PROC ; CvUnitMovement::CostsOnlyOne, COMDAT

; 320  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 321  : 	
; 322  : 	if(!pToPlot->isValidDomainForAction(*pUnit))

	mov	eax, DWORD PTR _pUnit$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?isValidDomainForAction@CvPlot@@QBE_NABVCvUnit@@@Z ; CvPlot::isValidDomainForAction
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN6@CostsOnlyO

; 323  : 	{
; 324  : 		// If we are a land unit that can embark, then do further tests.
; 325  : 		if(pUnit->getDomainType() != DOMAIN_LAND || pUnit->IsHoveringUnit() || pUnit->canMoveAllTerrain() || !pUnit->CanEverEmbark())

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN4@CostsOnlyO
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?IsHoveringUnit@CvUnit@@QBE_NXZ		; CvUnit::IsHoveringUnit
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN4@CostsOnlyO
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canMoveAllTerrain@CvUnit@@QBE_NXZ	; CvUnit::canMoveAllTerrain
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@CostsOnlyO
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?CanEverEmbark@CvUnit@@QBE_NXZ		; CvUnit::CanEverEmbark
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN6@CostsOnlyO
$LN4@CostsOnlyO:

; 326  : 			return true;

	mov	al, 1
	jmp	$LN7@CostsOnlyO
$LN6@CostsOnlyO:

; 327  : 	}
; 328  : 
; 329  : 	CvAssert(!pUnit->IsImmobile());
; 330  : 
; 331  : 	
; 332  : 	if(pUnit->flatMovementCost() || pUnit->getDomainType() == DOMAIN_AIR)

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?flatMovementCost@CvUnit@@QBE_NXZ	; CvUnit::flatMovementCost
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@CostsOnlyO
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 1
	jne	SHORT $LN9@CostsOnlyO
$LN2@CostsOnlyO:

; 333  : 	{
; 334  : 		return true;

	mov	al, 1
	jmp	SHORT $LN7@CostsOnlyO

; 335  : 	}
; 336  : 
; 337  : 	// Is the unit from a civ that can disembark for just 1 MP?
; 338  : #ifdef AUI_UNIT_FIX_HOVERING_EMBARK
; 339  : 	bool bToPlotNeedEmbark = !pToPlot->IsAllowsWalkWater();
; 340  : 	bool bFromPlotNeedEmbark = !pFromPlot->IsAllowsWalkWater();
; 341  : 	if (pUnit->IsHoveringUnit())
; 342  : 	{
; 343  : 		bToPlotNeedEmbark = bToPlotNeedEmbark && pToPlot->getTerrainType() == GC.getDEEP_WATER_TERRAIN();
; 344  : 		bFromPlotNeedEmbark = bFromPlotNeedEmbark && pFromPlot->getTerrainType() == GC.getDEEP_WATER_TERRAIN();
; 345  : 	}
; 346  : 	else
; 347  : 	{
; 348  : 		bToPlotNeedEmbark = bToPlotNeedEmbark && pToPlot->isWater();
; 349  : 		bFromPlotNeedEmbark = bFromPlotNeedEmbark && pFromPlot->isWater();
; 350  : 	}
; 351  : 
; 352  : 	if (pUnit->CanEverEmbark() && bFromPlotNeedEmbark && GET_PLAYER(pUnit->getOwner()).GetPlayerTraits()->IsEmbarkedToLandFlatCost())
; 353  : #elif defined(AUI_UNIT_MOVEMENT_FIX_BAD_VIKING_DISEMBARK_PREVIEW)
; 354  : 	if (!pToPlot->isWater() && pFromPlot->isWater() && pUnit->CanEverEmbark() && GET_PLAYER(pUnit->getOwner()).GetPlayerTraits()->IsEmbarkedToLandFlatCost())

$LN9@CostsOnlyO:
	mov	eax, DWORD PTR _pToPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN1@CostsOnlyO
	mov	ecx, DWORD PTR _pFromPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	xor	eax, eax
	cmp	edx, 3
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@CostsOnlyO
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?CanEverEmbark@CvUnit@@QBE_NXZ		; CvUnit::CanEverEmbark
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@CostsOnlyO
	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR $T217978[ebp], ecx
	mov	edx, DWORD PTR $T217978[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T217982[ebp], edx
	mov	ecx, DWORD PTR $T217982[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T217986[ebp], eax
	mov	eax, DWORD PTR $T217986[ebp]
	mov	cl, BYTE PTR [eax+337]
	mov	BYTE PTR $T217987[ebp], cl
	movzx	edx, BYTE PTR $T217987[ebp]
	test	edx, edx
	je	SHORT $LN1@CostsOnlyO

; 355  : #else
; 356  : 	if(!pToPlot->isWater() && pFromPlot->isWater() && pUnit->isEmbarked() && GET_PLAYER(pUnit->getOwner()).GetPlayerTraits()->IsEmbarkedToLandFlatCost())
; 357  : #endif
; 358  : 	{
; 359  : 		return true;

	mov	al, 1
	jmp	SHORT $LN7@CostsOnlyO
$LN1@CostsOnlyO:

; 360  : 	}
; 361  : 
; 362  : 	
; 363  : 
; 364  : 	return false;

	xor	al, al
$LN7@CostsOnlyO:

; 365  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CostsOnlyOne@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z ENDP ; CvUnitMovement::CostsOnlyOne
_TEXT	ENDS
PUBLIC	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ		; CvPlot::getPlotCity
PUBLIC	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
EXTRN	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC	; CvTeam::isAtWar
EXTRN	?isInvisible@CvUnit@@QBE_NW4TeamTypes@@_N1@Z:PROC ; CvUnit::isInvisible
EXTRN	?nextUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z:PROC ; CvPlot::nextUnitNode
EXTRN	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z:PROC	; CvPlayer::getUnit
EXTRN	?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ:PROC	; CvPlot::headUnitNode
EXTRN	?plot@CvUnit@@QBEPAVCvPlot@@XZ:PROC		; CvUnit::plot
EXTRN	?isEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z:PROC ; CvUnit::isEnemy
EXTRN	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ:PROC	; CvCity::getTeam
EXTRN	?isVisibleEnemyUnit@CvPlot@@QBE_NPBVCvUnit@@@Z:PROC ; CvPlot::isVisibleEnemyUnit
EXTRN	?IsIgnoreZOC@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsIgnoreZOC
; Function compile flags: /Odtp
;	COMDAT ?IsSlowedByZOC@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z
_TEXT	SEGMENT
$T218359 = -268						; size = 4
$T218355 = -264						; size = 4
$T218351 = -257						; size = 1
$T218334 = -256						; size = 4
$T218330 = -249						; size = 1
$T218329 = -248						; size = 4
$T218173 = -172						; size = 4
$T218169 = -168						; size = 4
$T218165 = -164						; size = 4
_uiOffset$218163 = -160					; size = 4
$T218154 = -153						; size = 1
_pCity$218152 = -152					; size = 4
$T217993 = -76						; size = 4
_pEnemyAdjPlot$217318 = -72				; size = 4
_iDirection2$217314 = -68				; size = 4
_loop_unit_domain_type$217309 = -64			; size = 4
_unit_loop_team_type$217303 = -60			; size = 4
_pEnemyAdjPlot$217292 = -56				; size = 4
_iDirection$217288 = -52				; size = 4
_pAdjPlot$217283 = -48					; size = 4
_iDirection0$217279 = -44				; size = 4
_bIsVisibleEnemyUnit$217277 = -37			; size = 1
_iFromPlotX$217271 = -36				; size = 4
_iFromPlotY$217272 = -32				; size = 4
_iToPlotX$217273 = -28					; size = 4
_unit_team_type$217275 = -24				; size = 4
_pAdjUnitNode$217269 = -20				; size = 4
_pLoopUnit$217270 = -16					; size = 4
_unit_domain_type$217276 = -12				; size = 4
_kUnitTeam$217278 = -8					; size = 4
_iToPlotY$217274 = -4					; size = 4
_pUnit$ = 8						; size = 4
_pFromPlot$ = 12					; size = 4
_pToPlot$ = 16						; size = 4
?IsSlowedByZOC@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z PROC ; CvUnitMovement::IsSlowedByZOC, COMDAT

; 369  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 348				; 0000015cH

; 370  : 	if (pUnit->IsIgnoreZOC() || CostsOnlyOne(pUnit, pFromPlot, pToPlot))

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?IsIgnoreZOC@CvUnit@@QBE_NXZ		; CvUnit::IsIgnoreZOC
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN33@IsSlowedBy
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pFromPlot$[ebp]
	push	edx
	mov	eax, DWORD PTR _pUnit$[ebp]
	push	eax
	call	?CostsOnlyOne@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z ; CvUnitMovement::CostsOnlyOne
	add	esp, 12					; 0000000cH
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN34@IsSlowedBy
$LN33@IsSlowedBy:

; 371  : 	{
; 372  : 		return false;

	xor	al, al
	jmp	$LN35@IsSlowedBy
$LN34@IsSlowedBy:

; 373  : 	}
; 374  : 
; 375  : 	// Zone of Control
; 376  : 	if(GC.getZONE_OF_CONTROL_ENABLED() > 0)

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7360
	mov	DWORD PTR $T217993[ebp], edx
	cmp	DWORD PTR $T217993[ebp], 0
	jle	$LN32@IsSlowedBy

; 377  : 	{
; 378  : 		IDInfo* pAdjUnitNode;
; 379  : 		CvUnit* pLoopUnit;
; 380  : 
; 381  : 		int iFromPlotX = pFromPlot->getX();

	mov	eax, DWORD PTR _pFromPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR _iFromPlotX$217271[ebp], ecx

; 382  : 		int iFromPlotY = pFromPlot->getY();

	mov	edx, DWORD PTR _pFromPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR _iFromPlotY$217272[ebp], eax

; 383  : 		int iToPlotX = pToPlot->getX();

	mov	ecx, DWORD PTR _pToPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR _iToPlotX$217273[ebp], edx

; 384  : 		int iToPlotY = pToPlot->getY();

	mov	eax, DWORD PTR _pToPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR _iToPlotY$217274[ebp], ecx

; 385  : 		TeamTypes unit_team_type     = pUnit->getTeam();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	mov	DWORD PTR _unit_team_type$217275[ebp], eax

; 386  : 		DomainTypes unit_domain_type = pUnit->getDomainType();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	mov	DWORD PTR _unit_domain_type$217276[ebp], eax

; 387  : 		bool bIsVisibleEnemyUnit     = pToPlot->isVisibleEnemyUnit(pUnit);

	mov	edx, DWORD PTR _pUnit$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?isVisibleEnemyUnit@CvPlot@@QBE_NPBVCvUnit@@@Z ; CvPlot::isVisibleEnemyUnit
	mov	BYTE PTR _bIsVisibleEnemyUnit$217277[ebp], al

; 388  : 		CvTeam& kUnitTeam = GET_TEAM(unit_team_type);

	mov	eax, DWORD PTR _unit_team_type$217275[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR _kUnitTeam$217278[ebp], eax

; 389  : 
; 390  : 		for(int iDirection0 = 0; iDirection0 < NUM_DIRECTION_TYPES; iDirection0++)

	mov	DWORD PTR _iDirection0$217279[ebp], 0
	jmp	SHORT $LN31@IsSlowedBy
$LN30@IsSlowedBy:
	mov	ecx, DWORD PTR _iDirection0$217279[ebp]
	add	ecx, 1
	mov	DWORD PTR _iDirection0$217279[ebp], ecx
$LN31@IsSlowedBy:
	cmp	DWORD PTR _iDirection0$217279[ebp], 6
	jge	$LN32@IsSlowedBy

; 391  : 		{
; 392  : 			CvPlot* pAdjPlot = plotDirection(iFromPlotX, iFromPlotY, ((DirectionTypes)iDirection0));

	mov	edx, DWORD PTR _iDirection0$217279[ebp]
	push	edx
	mov	eax, DWORD PTR _iFromPlotY$217272[ebp]
	push	eax
	mov	ecx, DWORD PTR _iFromPlotX$217271[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjPlot$217283[ebp], eax

; 393  : 			if(NULL != pAdjPlot)

	cmp	DWORD PTR _pAdjPlot$217283[ebp], 0
	je	$LN28@IsSlowedBy

; 394  : 			{
; 395  : 				// check city zone of control
; 396  : #ifdef AUI_UNIT_MOVEMENT_FIX_RADAR_ZOC
; 397  : 				if (pAdjPlot->isEnemyCity(*pUnit) && (pAdjPlot->isRevealed(pUnit->getTeam()) || pUnit->plot() == pFromPlot))

	mov	ecx, DWORD PTR _pAdjPlot$217283[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pCity$218152[ebp], eax
	cmp	DWORD PTR _pCity$218152[ebp], 0
	je	SHORT $LN111@IsSlowedBy
	mov	edx, DWORD PTR _pAdjPlot$217283[ebp]
	push	edx
	mov	ecx, DWORD PTR _pCity$218152[ebp]
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?isEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z ; CvUnit::isEnemy
	mov	BYTE PTR $T218154[ebp], al
	jmp	SHORT $LN112@IsSlowedBy
$LN111@IsSlowedBy:
	mov	BYTE PTR $T218154[ebp], 0
$LN112@IsSlowedBy:
	movzx	eax, BYTE PTR $T218154[ebp]
	test	eax, eax
	je	$LN27@IsSlowedBy
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	mov	DWORD PTR $T218165[ebp], eax
	mov	ecx, DWORD PTR $T218165[ebp]
	shr	ecx, 5
	mov	DWORD PTR _uiOffset$218163[ebp], ecx
	mov	edx, DWORD PTR _uiOffset$218163[ebp]
	shl	edx, 5
	mov	ecx, DWORD PTR $T218165[ebp]
	sub	ecx, edx
	mov	eax, 1
	shl	eax, cl
	mov	ecx, DWORD PTR _uiOffset$218163[ebp]
	mov	edx, DWORD PTR _pAdjPlot$217283[ebp]
	and	eax, DWORD PTR [edx+ecx*4+8]
	setne	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN26@IsSlowedBy
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, DWORD PTR _pFromPlot$[ebp]
	jne	SHORT $LN27@IsSlowedBy
$LN26@IsSlowedBy:

; 398  : #else
; 399  : 				if(pAdjPlot->isEnemyCity(*pUnit))
; 400  : #endif
; 401  : 				{
; 402  : 					// Loop through plots adjacent to the enemy city and see if it's the same as our unit's Destination Plot
; 403  : 					for(int iDirection = 0; iDirection < NUM_DIRECTION_TYPES; iDirection++)

	mov	DWORD PTR _iDirection$217288[ebp], 0
	jmp	SHORT $LN25@IsSlowedBy
$LN24@IsSlowedBy:
	mov	edx, DWORD PTR _iDirection$217288[ebp]
	add	edx, 1
	mov	DWORD PTR _iDirection$217288[ebp], edx
$LN25@IsSlowedBy:
	cmp	DWORD PTR _iDirection$217288[ebp], 6
	jge	SHORT $LN27@IsSlowedBy

; 404  : 					{
; 405  : 						CvPlot* pEnemyAdjPlot = plotDirection(pAdjPlot->getX(), pAdjPlot->getY(), ((DirectionTypes)iDirection));

	mov	eax, DWORD PTR _pAdjPlot$217283[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T218169[ebp], ecx
	mov	edx, DWORD PTR _pAdjPlot$217283[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T218173[ebp], eax
	mov	ecx, DWORD PTR _iDirection$217288[ebp]
	push	ecx
	mov	edx, DWORD PTR $T218169[ebp]
	push	edx
	mov	eax, DWORD PTR $T218173[ebp]
	push	eax
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pEnemyAdjPlot$217292[ebp], eax

; 406  : 						if(NULL != pEnemyAdjPlot)

	cmp	DWORD PTR _pEnemyAdjPlot$217292[ebp], 0
	je	SHORT $LN22@IsSlowedBy

; 407  : 						{
; 408  : 							// Destination adjacent to enemy city?
; 409  : 							if(pEnemyAdjPlot->getX() == iToPlotX && pEnemyAdjPlot->getY() == iToPlotY)

	mov	ecx, DWORD PTR _pEnemyAdjPlot$217292[ebp]
	movsx	edx, WORD PTR [ecx]
	cmp	edx, DWORD PTR _iToPlotX$217273[ebp]
	jne	SHORT $LN22@IsSlowedBy
	mov	eax, DWORD PTR _pEnemyAdjPlot$217292[ebp]
	movsx	ecx, WORD PTR [eax+2]
	cmp	ecx, DWORD PTR _iToPlotY$217274[ebp]
	jne	SHORT $LN22@IsSlowedBy

; 410  : 							{
; 411  : 								return true;

	mov	al, 1
	jmp	$LN35@IsSlowedBy
$LN22@IsSlowedBy:

; 412  : 							}
; 413  : 						}
; 414  : 					}

	jmp	SHORT $LN24@IsSlowedBy
$LN27@IsSlowedBy:

; 415  : 				}
; 416  : 
; 417  : #ifdef AUI_UNIT_MOVEMENT_FIX_RADAR_ZOC
; 418  : 				if (!pAdjPlot->isVisible(pUnit->getTeam()) && pUnit->plot() != pFromPlot)

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	mov	DWORD PTR $T218329[ebp], eax
	cmp	DWORD PTR $T218329[ebp], -1
	jne	SHORT $LN191@IsSlowedBy
	mov	BYTE PTR $T218330[ebp], 0
	jmp	SHORT $LN189@IsSlowedBy
$LN191@IsSlowedBy:
	mov	edx, DWORD PTR _pAdjPlot$217283[ebp]
	mov	eax, DWORD PTR [edx+156]
	mov	ecx, DWORD PTR $T218329[ebp]
	movsx	edx, WORD PTR [eax+ecx*2]
	xor	eax, eax
	test	edx, edx
	setg	al
	mov	BYTE PTR $T218330[ebp], al
$LN189@IsSlowedBy:
	movzx	ecx, BYTE PTR $T218330[ebp]
	test	ecx, ecx
	jne	SHORT $LN20@IsSlowedBy
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, DWORD PTR _pFromPlot$[ebp]
	je	SHORT $LN20@IsSlowedBy

; 419  : 					continue;

	jmp	$LN30@IsSlowedBy
$LN20@IsSlowedBy:

; 420  : #endif
; 421  : 				pAdjUnitNode = pAdjPlot->headUnitNode();

	mov	ecx, DWORD PTR _pAdjPlot$217283[ebp]
	call	?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ	; CvPlot::headUnitNode
	mov	DWORD PTR _pAdjUnitNode$217269[ebp], eax
$LN19@IsSlowedBy:

; 422  : 				// Loop through all units to see if there's an enemy unit here
; 423  : 				while(pAdjUnitNode != NULL)

	cmp	DWORD PTR _pAdjUnitNode$217269[ebp], 0
	je	$LN28@IsSlowedBy

; 424  : 				{
; 425  : 					if((pAdjUnitNode->eOwner >= 0) && pAdjUnitNode->eOwner < MAX_PLAYERS)

	mov	edx, DWORD PTR _pAdjUnitNode$217269[ebp]
	cmp	DWORD PTR [edx], 0
	jl	SHORT $LN17@IsSlowedBy
	mov	eax, DWORD PTR _pAdjUnitNode$217269[ebp]
	cmp	DWORD PTR [eax], 64			; 00000040H
	jge	SHORT $LN17@IsSlowedBy

; 426  : 					{
; 427  : 						pLoopUnit = (GET_PLAYER(pAdjUnitNode->eOwner).getUnit(pAdjUnitNode->iID));

	mov	ecx, DWORD PTR _pAdjUnitNode$217269[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T218334[ebp], edx
	mov	eax, DWORD PTR _pAdjUnitNode$217269[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR $T218334[ebp]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR _pLoopUnit$217270[ebp], eax

; 428  : 					}
; 429  : 					else

	jmp	SHORT $LN16@IsSlowedBy
$LN17@IsSlowedBy:

; 430  : 					{
; 431  : 						pLoopUnit = NULL;

	mov	DWORD PTR _pLoopUnit$217270[ebp], 0
$LN16@IsSlowedBy:

; 432  : 					}
; 433  : 
; 434  : 					pAdjUnitNode = pAdjPlot->nextUnitNode(pAdjUnitNode);

	mov	edx, DWORD PTR _pAdjUnitNode$217269[ebp]
	push	edx
	mov	ecx, DWORD PTR _pAdjPlot$217283[ebp]
	call	?nextUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z ; CvPlot::nextUnitNode
	mov	DWORD PTR _pAdjUnitNode$217269[ebp], eax

; 435  : 
; 436  : 					if(!pLoopUnit) continue;

	cmp	DWORD PTR _pLoopUnit$217270[ebp], 0
	jne	SHORT $LN15@IsSlowedBy
	jmp	SHORT $LN19@IsSlowedBy
$LN15@IsSlowedBy:

; 437  : 
; 438  : #ifdef AUI_UNIT_MOVEMENT_FIX_DELAYED_DEATH_UNITS_GENERATE_ZOC
; 439  : 					if (pLoopUnit->isDelayedDeath())
; 440  : 						continue;
; 441  : #endif
; 442  : 
; 443  : 					TeamTypes unit_loop_team_type = pLoopUnit->getTeam();

	mov	ecx, DWORD PTR _pLoopUnit$217270[ebp]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	mov	DWORD PTR _unit_loop_team_type$217303[ebp], eax

; 444  : 
; 445  : 					if(pLoopUnit->isInvisible(unit_team_type,false)) continue;

	push	1
	push	0
	mov	eax, DWORD PTR _unit_team_type$217275[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopUnit$217270[ebp]
	call	?isInvisible@CvUnit@@QBE_NW4TeamTypes@@_N1@Z ; CvUnit::isInvisible
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN195@IsSlowedBy
	jmp	$LN19@IsSlowedBy

; 446  : 
; 447  : 					// Combat unit?
; 448  : 					if(!pLoopUnit->IsCombatUnit())

$LN195@IsSlowedBy:
	mov	edx, DWORD PTR _pLoopUnit$217270[ebp]
	xor	eax, eax
	cmp	DWORD PTR [edx+1044], 0
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN13@IsSlowedBy

; 449  : 					{
; 450  : 						continue;

	jmp	$LN19@IsSlowedBy
$LN13@IsSlowedBy:

; 451  : 					}
; 452  : 
; 453  : 					// At war with this unit's team?
; 454  : 					if(unit_loop_team_type == BARBARIAN_TEAM || kUnitTeam.isAtWar(unit_loop_team_type))

	cmp	DWORD PTR _unit_loop_team_type$217303[ebp], 63 ; 0000003fH
	je	SHORT $LN11@IsSlowedBy
	mov	edx, DWORD PTR _unit_loop_team_type$217303[ebp]
	push	edx
	mov	ecx, DWORD PTR _kUnitTeam$217278[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	eax, al
	test	eax, eax
	je	$LN12@IsSlowedBy
$LN11@IsSlowedBy:

; 455  : 					{
; 456  : 
; 457  : 						// Same Domain?
; 458  : 
; 459  : 						DomainTypes loop_unit_domain_type = pLoopUnit->getDomainType();

	mov	ecx, DWORD PTR _pLoopUnit$217270[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	mov	DWORD PTR _loop_unit_domain_type$217309[ebp], eax

; 460  : 						if(loop_unit_domain_type != unit_domain_type)

	mov	ecx, DWORD PTR _loop_unit_domain_type$217309[ebp]
	cmp	ecx, DWORD PTR _unit_domain_type$217276[ebp]
	je	SHORT $LN10@IsSlowedBy

; 461  : 						{
; 462  : 							// this is valid
; 463  : 							if(loop_unit_domain_type == DOMAIN_SEA && unit_domain_type)

	cmp	DWORD PTR _loop_unit_domain_type$217309[ebp], 0
	jne	SHORT $LN9@IsSlowedBy
	cmp	DWORD PTR _unit_domain_type$217276[ebp], 0
	je	SHORT $LN9@IsSlowedBy

; 464  : 							{
; 465  : 								// continue on
; 466  : 							}
; 467  : 							else

	jmp	SHORT $LN10@IsSlowedBy
$LN9@IsSlowedBy:

; 468  : 							{
; 469  : 								continue;

	jmp	$LN19@IsSlowedBy
$LN10@IsSlowedBy:

; 470  : 							}
; 471  : 						}
; 472  : 
; 473  : 						// Embarked?
; 474  : 						if(unit_domain_type == DOMAIN_LAND && pLoopUnit->isEmbarked())

	cmp	DWORD PTR _unit_domain_type$217276[ebp], 2
	jne	SHORT $LN7@IsSlowedBy
	mov	edx, DWORD PTR _pLoopUnit$217270[ebp]
	mov	al, BYTE PTR [edx+1652]
	mov	BYTE PTR $T218351[ebp], al
	movzx	ecx, BYTE PTR $T218351[ebp]
	test	ecx, ecx
	je	SHORT $LN7@IsSlowedBy

; 475  : 						{
; 476  : 							continue;

	jmp	$LN19@IsSlowedBy
$LN7@IsSlowedBy:

; 477  : 						}
; 478  : 
; 479  : 						// Loop through plots adjacent to the enemy unit and see if it's the same as our unit's Destination Plot
; 480  : 						for(int iDirection2 = 0; iDirection2 < NUM_DIRECTION_TYPES; iDirection2++)

	mov	DWORD PTR _iDirection2$217314[ebp], 0
	jmp	SHORT $LN6@IsSlowedBy
$LN5@IsSlowedBy:
	mov	edx, DWORD PTR _iDirection2$217314[ebp]
	add	edx, 1
	mov	DWORD PTR _iDirection2$217314[ebp], edx
$LN6@IsSlowedBy:
	cmp	DWORD PTR _iDirection2$217314[ebp], 6
	jge	SHORT $LN12@IsSlowedBy

; 481  : 						{
; 482  : 							CvPlot* pEnemyAdjPlot = plotDirection(pAdjPlot->getX(), pAdjPlot->getY(), ((DirectionTypes)iDirection2));

	mov	eax, DWORD PTR _pAdjPlot$217283[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T218355[ebp], ecx
	mov	edx, DWORD PTR _pAdjPlot$217283[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T218359[ebp], eax
	mov	ecx, DWORD PTR _iDirection2$217314[ebp]
	push	ecx
	mov	edx, DWORD PTR $T218355[ebp]
	push	edx
	mov	eax, DWORD PTR $T218359[ebp]
	push	eax
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pEnemyAdjPlot$217318[ebp], eax

; 483  : 							if(!pEnemyAdjPlot)

	cmp	DWORD PTR _pEnemyAdjPlot$217318[ebp], 0
	jne	SHORT $LN3@IsSlowedBy

; 484  : 							{
; 485  : 								continue;

	jmp	SHORT $LN5@IsSlowedBy
$LN3@IsSlowedBy:

; 486  : 							}
; 487  : 
; 488  : 							// Don't check Enemy Unit's plot
; 489  : 							if(!bIsVisibleEnemyUnit)

	movzx	ecx, BYTE PTR _bIsVisibleEnemyUnit$217277[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@IsSlowedBy

; 490  : 							{
; 491  : 								// Destination adjacent to enemy unit?
; 492  : 								if(pEnemyAdjPlot->getX() == iToPlotX && pEnemyAdjPlot->getY() == iToPlotY)

	mov	edx, DWORD PTR _pEnemyAdjPlot$217318[ebp]
	movsx	eax, WORD PTR [edx]
	cmp	eax, DWORD PTR _iToPlotX$217273[ebp]
	jne	SHORT $LN2@IsSlowedBy
	mov	ecx, DWORD PTR _pEnemyAdjPlot$217318[ebp]
	movsx	edx, WORD PTR [ecx+2]
	cmp	edx, DWORD PTR _iToPlotY$217274[ebp]
	jne	SHORT $LN2@IsSlowedBy

; 493  : 								{
; 494  : 									return true;

	mov	al, 1
	jmp	SHORT $LN35@IsSlowedBy
$LN2@IsSlowedBy:

; 495  : 								}
; 496  : 							}
; 497  : 						}

	jmp	SHORT $LN5@IsSlowedBy
$LN12@IsSlowedBy:

; 498  : 					}
; 499  : 				}

	jmp	$LN19@IsSlowedBy
$LN28@IsSlowedBy:

; 500  : 			}
; 501  : 		}

	jmp	$LN30@IsSlowedBy
$LN32@IsSlowedBy:

; 502  : 	}
; 503  : 	return false;

	xor	al, al
$LN35@IsSlowedBy:

; 504  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsSlowedByZOC@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z ENDP ; CvUnitMovement::IsSlowedByZOC
_TEXT	ENDS
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z
_TEXT	SEGMENT
tv198 = -100						; size = 4
tv213 = -96						; size = 4
tv168 = -92						; size = 4
tv151 = -88						; size = 4
tv155 = -84						; size = 4
$T218757 = -80						; size = 4
$T218712 = -76						; size = 4
$T218699 = -72						; size = 4
$T218695 = -68						; size = 4
$T218681 = -64						; size = 4
$T218677 = -57						; size = 1
$T218666 = -56						; size = 4
$T218662 = -49						; size = 1
_iMapY$218756 = -48					; size = 4
_iMapX$218755 = -44					; size = 4
$T218655 = -40						; size = 4
$T218631 = -36						; size = 4
$T218594 = -32						; size = 4
$T218582 = -28						; size = 4
$T218578 = -21						; size = 1
$T218567 = -20						; size = 4
$T218563 = -13						; size = 1
_iMapY$218630 = -12					; size = 4
_iMapX$218629 = -8					; size = 4
$T218556 = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_eDirection$ = 16					; size = 4
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z PROC ; plotDirection, COMDAT

; 193  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H

; 194  : 	if(eDirection == NO_DIRECTION)

	cmp	DWORD PTR _eDirection$[ebp], -1
	jne	$LN2@plotDirect

; 195  : 	{
; 196  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T218556[ebp], eax
	cmp	DWORD PTR _iX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN7@plotDirect
	cmp	DWORD PTR _iY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN8@plotDirect
$LN7@plotDirect:
	mov	DWORD PTR $T218631[ebp], 0
	jmp	$LN9@plotDirect
$LN8@plotDirect:
	mov	ecx, DWORD PTR $T218556[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T218563[ebp], dl
	mov	eax, DWORD PTR $T218556[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T218567[ebp], ecx
	movzx	edx, BYTE PTR $T218563[ebp]
	test	edx, edx
	je	SHORT $LN20@plotDirect
	cmp	DWORD PTR _iX$[ebp], 0
	jge	SHORT $LN19@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T218567[ebp]
	add	edx, DWORD PTR $T218567[ebp]
	mov	DWORD PTR _iMapX$218629[ebp], edx
	jmp	SHORT $LN21@plotDirect
	jmp	SHORT $LN20@plotDirect
$LN19@plotDirect:
	mov	eax, DWORD PTR _iX$[ebp]
	cmp	eax, DWORD PTR $T218567[ebp]
	jl	SHORT $LN20@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T218567[ebp]
	mov	DWORD PTR _iMapX$218629[ebp], edx
	jmp	SHORT $LN21@plotDirect
$LN20@plotDirect:
	mov	ecx, DWORD PTR _iX$[ebp]
	mov	DWORD PTR _iMapX$218629[ebp], ecx
$LN21@plotDirect:
	mov	edx, DWORD PTR $T218556[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T218578[ebp], al
	mov	ecx, DWORD PTR $T218556[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T218582[ebp], edx
	movzx	eax, BYTE PTR $T218578[ebp]
	test	eax, eax
	je	SHORT $LN30@plotDirect
	cmp	DWORD PTR _iY$[ebp], 0
	jge	SHORT $LN29@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T218582[ebp]
	add	edx, DWORD PTR $T218582[ebp]
	mov	DWORD PTR _iMapY$218630[ebp], edx
	jmp	SHORT $LN31@plotDirect
	jmp	SHORT $LN30@plotDirect
$LN29@plotDirect:
	mov	ecx, DWORD PTR _iY$[ebp]
	cmp	ecx, DWORD PTR $T218582[ebp]
	jl	SHORT $LN30@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T218582[ebp]
	mov	DWORD PTR _iMapY$218630[ebp], edx
	jmp	SHORT $LN31@plotDirect
$LN30@plotDirect:
	mov	edx, DWORD PTR _iY$[ebp]
	mov	DWORD PTR _iMapY$218630[ebp], edx
$LN31@plotDirect:
	mov	eax, DWORD PTR _iMapY$218630[ebp]
	push	eax
	mov	ecx, DWORD PTR _iMapX$218629[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T218556[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN11@plotDirect
	mov	edx, DWORD PTR $T218556[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T218594[ebp], eax
	mov	ecx, DWORD PTR _iMapY$218630[ebp]
	imul	ecx, DWORD PTR $T218594[ebp]
	add	ecx, DWORD PTR _iMapX$218629[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T218556[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv155[ebp], ecx
	jmp	SHORT $LN12@plotDirect
$LN11@plotDirect:
	mov	DWORD PTR tv155[ebp], 0
$LN12@plotDirect:
	mov	eax, DWORD PTR tv155[ebp]
	mov	DWORD PTR $T218631[ebp], eax
$LN9@plotDirect:
	mov	eax, DWORD PTR $T218631[ebp]
	jmp	$LN3@plotDirect

; 197  : 	}
; 198  : 	else

	jmp	$LN3@plotDirect
$LN2@plotDirect:

; 199  : 	{
; 200  : 		// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 201  : 		iX = xToHexspaceX(iX , iY);

	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN39@plotDirect
	mov	ecx, DWORD PTR _iY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv151[ebp], ecx
	jmp	SHORT $LN37@plotDirect
$LN39@plotDirect:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv151[ebp], eax
$LN37@plotDirect:
	mov	edx, DWORD PTR _iX$[ebp]
	sub	edx, DWORD PTR tv151[ebp]
	mov	DWORD PTR _iX$[ebp], edx

; 202  : 		iX += GC.getPlotDirectionX()[eDirection];

	mov	eax, DWORD PTR _eDirection$[ebp]
	mov	ecx, DWORD PTR _iX$[ebp]
	add	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A[eax*4+112]
	mov	DWORD PTR _iX$[ebp], ecx

; 203  : 		iY += GC.getPlotDirectionY()[eDirection];

	mov	edx, DWORD PTR _eDirection$[ebp]
	mov	eax, DWORD PTR _iY$[ebp]
	add	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A[edx*4+136]
	mov	DWORD PTR _iY$[ebp], eax

; 204  : 
; 205  : 		// convert from hex-space coordinates to the storage array
; 206  : 		iX = hexspaceXToX(iX, iY);

	js	SHORT $LN47@plotDirect
	mov	ecx, DWORD PTR _iY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv168[ebp], ecx
	jmp	SHORT $LN45@plotDirect
$LN47@plotDirect:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv168[ebp], eax
$LN45@plotDirect:
	mov	edx, DWORD PTR _iX$[ebp]
	add	edx, DWORD PTR tv168[ebp]
	mov	DWORD PTR _iX$[ebp], edx

; 207  : 
; 208  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T218655[ebp], eax
	cmp	DWORD PTR _iX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN51@plotDirect
	cmp	DWORD PTR _iY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN52@plotDirect
$LN51@plotDirect:
	mov	DWORD PTR $T218757[ebp], 0
	jmp	$LN53@plotDirect
$LN52@plotDirect:
	mov	ecx, DWORD PTR $T218655[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T218662[ebp], dl
	mov	eax, DWORD PTR $T218655[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T218666[ebp], ecx
	movzx	edx, BYTE PTR $T218662[ebp]
	test	edx, edx
	je	SHORT $LN64@plotDirect
	cmp	DWORD PTR _iX$[ebp], 0
	jge	SHORT $LN63@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T218666[ebp]
	add	edx, DWORD PTR $T218666[ebp]
	mov	DWORD PTR _iMapX$218755[ebp], edx
	jmp	SHORT $LN65@plotDirect
	jmp	SHORT $LN64@plotDirect
$LN63@plotDirect:
	mov	eax, DWORD PTR _iX$[ebp]
	cmp	eax, DWORD PTR $T218666[ebp]
	jl	SHORT $LN64@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T218666[ebp]
	mov	DWORD PTR _iMapX$218755[ebp], edx
	jmp	SHORT $LN65@plotDirect
$LN64@plotDirect:
	mov	ecx, DWORD PTR _iX$[ebp]
	mov	DWORD PTR _iMapX$218755[ebp], ecx
$LN65@plotDirect:
	mov	edx, DWORD PTR $T218655[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T218677[ebp], al
	mov	ecx, DWORD PTR $T218655[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T218681[ebp], edx
	movzx	eax, BYTE PTR $T218677[ebp]
	test	eax, eax
	je	SHORT $LN74@plotDirect
	cmp	DWORD PTR _iY$[ebp], 0
	jge	SHORT $LN73@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T218681[ebp]
	add	edx, DWORD PTR $T218681[ebp]
	mov	DWORD PTR _iMapY$218756[ebp], edx
	jmp	SHORT $LN75@plotDirect
	jmp	SHORT $LN74@plotDirect
$LN73@plotDirect:
	mov	ecx, DWORD PTR _iY$[ebp]
	cmp	ecx, DWORD PTR $T218681[ebp]
	jl	SHORT $LN74@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T218681[ebp]
	mov	DWORD PTR _iMapY$218756[ebp], edx
	jmp	SHORT $LN75@plotDirect
$LN74@plotDirect:
	mov	edx, DWORD PTR _iY$[ebp]
	mov	DWORD PTR _iMapY$218756[ebp], edx
$LN75@plotDirect:
	cmp	DWORD PTR _iMapX$218755[ebp], 0
	jl	SHORT $LN79@plotDirect
	mov	eax, DWORD PTR $T218655[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T218695[ebp], ecx
	mov	edx, DWORD PTR _iMapX$218755[ebp]
	cmp	edx, DWORD PTR $T218695[ebp]
	jge	SHORT $LN79@plotDirect
	cmp	DWORD PTR _iMapY$218756[ebp], 0
	jl	SHORT $LN79@plotDirect
	mov	eax, DWORD PTR $T218655[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T218699[ebp], ecx
	mov	edx, DWORD PTR _iMapY$218756[ebp]
	cmp	edx, DWORD PTR $T218699[ebp]
	jge	SHORT $LN79@plotDirect
	mov	DWORD PTR tv213[ebp], 1
	jmp	SHORT $LN77@plotDirect
$LN79@plotDirect:
	mov	DWORD PTR tv213[ebp], 0
$LN77@plotDirect:
	cmp	DWORD PTR tv213[ebp], 0
	je	SHORT $LN55@plotDirect
	mov	eax, DWORD PTR $T218655[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T218712[ebp], ecx
	mov	edx, DWORD PTR _iMapY$218756[ebp]
	imul	edx, DWORD PTR $T218712[ebp]
	add	edx, DWORD PTR _iMapX$218755[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T218655[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv198[ebp], edx
	jmp	SHORT $LN56@plotDirect
$LN55@plotDirect:
	mov	DWORD PTR tv198[ebp], 0
$LN56@plotDirect:
	mov	ecx, DWORD PTR tv198[ebp]
	mov	DWORD PTR $T218757[ebp], ecx
$LN53@plotDirect:
	mov	eax, DWORD PTR $T218757[ebp]
$LN3@plotDirect:

; 209  : 	}
; 210  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ENDP ; plotDirection
_TEXT	ENDS
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isCity@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T218763 = -4						; size = 4
?isCity@CvPlot@@QBE_NXZ PROC				; CvPlot::isCity, COMDAT
; _this$ = ecx

; 244  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 245  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+104], 0
	jl	SHORT $LN1@isCity
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+104], 64			; 00000040H
	jge	SHORT $LN1@isCity

; 246  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID)) != NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T218763[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	mov	ecx, DWORD PTR $T218763[ebp]
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	neg	eax
	sbb	eax, eax
	neg	eax
	jmp	SHORT $LN2@isCity
$LN1@isCity:

; 247  : 
; 248  : 		return false;

	xor	al, al
$LN2@isCity:

; 249  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?isCity@CvPlot@@QBE_NXZ ENDP				; CvPlot::isCity
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isRoughGround@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isRoughGround@CvPlot@@QBE_NXZ PROC			; CvPlot::isRoughGround, COMDAT
; _this$ = ecx

; 452  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 453  : 		if(isHills())

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	sub	ecx, 1
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN7@isRoughGro

; 454  : 		{
; 455  : 			return true;

	mov	al, 1
	jmp	SHORT $LN3@isRoughGro

; 456  : 		}
; 457  : 		if(isMountain())

$LN7@isRoughGro:
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@isRoughGro

; 458  : 		{
; 459  : 			return true;

	mov	al, 1
	jmp	SHORT $LN3@isRoughGro
$LN1@isRoughGro:

; 460  : 		}
; 461  : 
; 462  : 		return m_bRoughFeature;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+462]
	shr	al, 3
	and	al, 1
$LN3@isRoughGro:

; 463  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?isRoughGround@CvPlot@@QBE_NXZ ENDP			; CvPlot::isRoughGround
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T218777 = -4						; size = 4
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ PROC		; CvPlot::getPlotCity, COMDAT
; _this$ = ecx

; 532  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 533  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+104], 0
	jl	SHORT $LN1@getPlotCit
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+104], 64			; 00000040H
	jge	SHORT $LN1@getPlotCit

; 534  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T218777[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	mov	ecx, DWORD PTR $T218777[ebp]
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	jmp	SHORT $LN2@getPlotCit
$LN1@getPlotCit:

; 535  : 
; 536  : 		return NULL;

	xor	eax, eax
$LN2@getPlotCit:

; 537  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ ENDP		; CvPlot::getPlotCity
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
_TEXT	ENDS
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
tv72 = -16						; size = 4
_this$ = -12						; size = 4
$T218789 = -8						; size = 4
$T218785 = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	cmp	DWORD PTR _iX$[ebp], 0
	jl	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T218785[ebp], ecx
	mov	edx, DWORD PTR _iX$[ebp]
	cmp	edx, DWORD PTR $T218785[ebp]
	jge	SHORT $LN3@isPlot
	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T218789[ebp], ecx
	mov	edx, DWORD PTR _iY$[ebp]
	cmp	edx, DWORD PTR $T218789[ebp]
	jge	SHORT $LN3@isPlot
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN4@isPlot
$LN3@isPlot:
	mov	DWORD PTR tv72[ebp], 0
$LN4@isPlot:
	mov	eax, DWORD PTR tv72[ebp]

; 161  : #endif
; 162  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
END
